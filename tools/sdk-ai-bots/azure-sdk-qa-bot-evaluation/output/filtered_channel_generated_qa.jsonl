{"query": "title: Is there any simplified way to create several operation for one specific resource?\n\nquestion: I have one specific resource with URL path: /configurations/event-hub\nThat means event-hub is one specific resource under configurations.\nCurrently, I write code like below, and does anyone can help review to see if I can refactor my code with any other simplified way? Because all the 4 operations are based on the same route: /configurations/event-hub, and they are the PUT/GET/DELETE/POST action for the same resource.\n@added(ApiVersions.v2025_05_20)\n@doc(\"Create or replace EventHub configuration.\")\n@route(\"/configurations/event-hub\")\n@put\nop createOrReplaceEventHubConfig(\n@doc(\"API version parameter\")\n@query(\"api-version\") apiVersion: string,\n@doc(\"EventHub configuration.\")\n@added(ApiVersions.v2025_05_20)\n@body body: EventHubConfig\n): {\n@statusCode status: 200;\n@doc(\"EventHub configuration.\")\n@added(ApiVersions.v2025_05_20)\n@body body: EventHubConfig;\n};\n@added(ApiVersions.v2025_05_20)\n@doc(\"Get EventHub configuration.\")\n@route(\"/configurations/event-hub\")\n@get\nop getEventHubConfig(\n@doc(\"API version parameter\")\n@query(\"api-version\") apiVersion: string,\n): {\n@statusCode status: 200 | 404;\n@doc(\"EventHub configuration.\")\n@added(ApiVersions.v2025_05_20)\n@body body: EventHubConfig;\n};\n@added(ApiVersions.v2025_05_20)\n@doc(\"Delete EventHub configuration.\")\n@route(\"/configurations/event-hub\")\n@delete\nop deleteEventHubConfig(\n@doc(\"API version parameter\")\n@query(\"api-version\") apiVersion: string,\n): {\n@statusCode status: 204;\n};\n@added(ApiVersions.v2025_05_20)\n@doc(\"Send ping to EventHub to verify configuration.\")\n@route(\"/configurations/event-hub:ping\")\n@post\nop pingEventHub(\n@doc(\"API version parameter\")\n@query(\"api-version\") apiVersion: string,\n): {\n@statusCode status: 200;\n};", "ground_truth": "I've recommended Dapeng to use RpcOperation for these ops.\nOne item we likely to hear your opinion, on using RpcOperation<{}, Response> for an op that does not take request body.\nhttps://github.com/Azure/azure-rest-api-specs/pull/34199#discussion_r2059441091", "response": "You can simplify your code by grouping operations under a namespace using the `@route` decorator. This approach allows you to define all operations for the same resource in a single namespace, reducing redundancy and improving readability. Here's an example:\n\n```typespec\n@route(\"/configurations/event-hub\")\nnamespace EventHubConfig {\n  @added(ApiVersions.v2025_05_20)\n  @doc(\"Create or replace EventHub configuration.\")\n  @put\n  op createOrReplace(\n    @query(\"api-version\") apiVersion: string,\n    @body body: EventHubConfig\n  ): {\n    @statusCode status: 200;\n    @body body: EventHubConfig;\n  };\n\n  @added(ApiVersions.v2025_05_20)\n  @doc(\"Get EventHub configuration.\")\n  @get\n  op get(\n    @query(\"api-version\") apiVersion: string\n  ): {\n    @statusCode status: 200 | 404;\n    @body body: EventHubConfig;\n  };\n\n  @added(ApiVersions.v2025_05_20)\n  @doc(\"Delete EventHub configuration.\")\n  @delete\n  op delete(\n    @query(\"api-version\") apiVersion: string\n  ): {\n    @statusCode status: 204;\n  };\n}\n\n@route(\"/configurations/event-hub:ping\")\nnamespace EventHubPing {\n  @added(ApiVersions.v2025_05_20)\n  @doc(\"Send ping to EventHub to verify configuration.\")\n  @post\n  op ping(\n    @query(\"api-version\") apiVersion: string\n  ): {\n    @statusCode status: 200;\n  };\n}\n```\n\nThis approach groups operations logically under namespaces, making the code easier to maintain and understand. The `@route` decorator ensures that all operations within the namespace share the same base path.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#rest#resource-routing.md\n- document_title: Resource and routes\n- document_link: https://typespec.io/docs/libraries/rest/resource-routing\n- document_content: # libraries#rest#resource-routing.md\n\n# Resource and routes\n\nResources are operations that are grouped in a namespace. You declare such a namespace by adding the `@route` decorator to provide the path to that resource:\r\n\r\n```typespec\r\nusing Http;\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n\r\n}\r\n```\r\n\r\nTo define an operation on this resource, you need to provide the HTTP verb for the route using the `@get`, `@head` `@post`, `@put`, `@patch`, or `@delete` decorators. If an HTTP method decorator is not specified then the default is post if there is a body and get otherwise. Lets add an operation to our `Pets` resource:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(): Pet[];\r\n\r\n  // or you could also use\r\n  @get op listPets(): Pet[];\r\n}\r\n```\r\n\r\nIf `@route` is applied to an interface, that route is not \"portable\". It will be applied to that interface but will not carry over if another interface extends it.\r\n\r\n```typespec\r\n// Operations prepended with /pets\r\n@route(\"/pets\")\r\ninterface PetOps {\r\n  list(): Pet[]\r\n}\r\n\r\n// Operations will *not* be prepended with /pets\r\ninterface MyPetOps extends PetOps {\r\n  ...\r\n}\r\n```\n\n### Automatic route generation\n\nInstead of manually specifying routes using the `@route` decorator, you automatically generate routes from operation parameters by applying the `@autoRoute` decorator to an operation or interface containing operations.\r\n\r\nFor this to work, an operation's path parameters (those marked with `@path`) must also be marked with\r\nthe `@segment` decorator to define the preceding path segment.\r\n\r\nThis is especially useful when reusing common parameter sets defined as model types.\r\n\r\nFor example:\r\n\r\n```typespec\r\nmodel CommonParameters {\r\n  @path\r\n  @segment(\"tenants\")\r\n  tenantId: string;\r\n\r\n  @path\r\n  @segment(\"users\")\r\n  userName: string;\r\n}\r\n\r\n@autoRoute\r\ninterface UserOperations {\r\n  @get\r\n  getUser(...CommonParameters): User | Error;\r\n\r\n  @put\r\n  updateUser(...CommonParameters, user: User): User | Error;\r\n}\r\n```\r\n\r\nThis will result in the following route for both operations\r\n\r\n```text\r\n/tenants/{tenantId}/users/{userName}\r\n```\r\n\r\nIf `@autoRoute` is applied to an interface, it is not \"portable\". It will be applied to that interface but will not carry over if another interface extends it.\r\n\r\n```typespec\r\n// Operations prepended with /pets\r\n@autoRoute\r\ninterface PetOps {\r\n  action(@path @segment(\"pets\") id: string): void;\r\n}\r\n\r\n// Operations will *not* be prepended with /pets\r\ninterface MyPetOps extends PetOps {\r\n  ...\r\n}\r\n```\n\n### Customizing Automatic Route Generation\n\nInstead of manually specifying routes using the `@route` decorator, you automatically generate\r\nroutes from operation parameters by applying the `@autoRoute` decorator to an operation, namespace,\r\nor interface containing operations.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-resource-manager#step02.md\n- document_title: 3. Defining the Resources\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step02\n- document_content: # getstarted#azure-resource-manager#step02.md\n\n# 3. Defining the Resources\n\nAn ARM resource provider is composed of resources. The TypeSpec Azure Resource Manager library makes it much easier to define the structure and endpoints of such resources.\r\n\r\nThere are three essential components of a resource defined with TypeSpec:\r\n\r\n- A model type representing the resource, derived from one of the [base resource types](#base-resource-types)\r\n- A model type defining the properties of the resource type\r\n- An interface that defines the operations that can be performed on the resource type, usually a combination of [recommended and required Operations](../../howtos/ARM/resource-operations.md#recommended-and-required-operations) and [resource actions](../../howtos/ARM/resource-operations.md#resource-actions-post)\r\n\r\n> Read the [TypeSpec tutorial](https://github.com/Microsoft/typespec/blob/main/docs/tutorial.md) to learn the basics about TypeSpec model types and interfaces.\n\n## 1. **Define a model representing the `properties` of the ARM resource**\n\nEach resource type must have a properties type which defines its custom properties. This type will be exposed as the `properties` property of the resource type.\r\n\r\n```typespec\r\n/** The properties of User */\r\nmodel UserProperties {\r\n  /** The user's full name */\r\n  fullName: string;\r\n\r\n  /** The user's email address */\r\n  emailAddress: string;\r\n}\r\n```\n\n## 2. **Define a model representing the resource type**\n\nResource types are defined as plain models which pull in a standard resource type using the `is` keyword.\r\n\r\nYou define a resource type, you need the following:\r\n\r\n- A property model type which defines the resource type's custom properties as we described in step 1\r\n- A `name` parameter definition. You should use `ResourceNameParameter` model which automatically populate the following decorators with camel cased name for `@key` and pluralized name for `@segment` as values. You can override these values via `ResourceNameParameter`'s optional template parameter.\r\n  - `@key`: Specifies the parameter name for this resource type in the service URI hierarchy\r\n  - `@segment`: Specifies the name of the resource \"collection\", the URI segment that comes just before the parameter name which identifies the resource type\r\n\r\nHere we define a tracked resource called `User`:\r\n\r\n```typespec\r\n/** A User Resource */\r\nmodel User is TrackedResource<UserProperties> {\r\n  ...ResourceNameParameter<User>;\r\n}\r\n```\n\n## 3. **Define an interface with operations for the resource type**\n\n```typespec\r\n@armResourceOperations\r\ninterface Users {\r\n  get is ArmResourceRead<User>;\r\n  create is ArmResourceCreateOrReplaceAsync<User>;\r\n  update is ArmCustomPatchSync<\r\n    User,\r\n    Azure.ResourceManager.Foundations.ResourceUpdateModel<User, UserProperties>\r\n  >;\r\n  delete is ArmResourceDeleteSync<User>;\r\n  listByResourceGroup is ArmResourceListByParent<User>;\r\n  listBySubscription is ArmListBySubscription<User>;\r\n}\r\n```\r\n\r\nThis uses operation templates defined in the `Azure.ResourceManager` namespace to define the operations over your resource. For operations like `create (PUT)`, `update (PATCH)` and `delete (DELETE)` there are both asynchronous (long-running) and synchronous (operation completes in the same http request) versions of the operation templates.\r\n\r\nThe interface above creates the following operations for your service:\r\n\r\n| Method & Path                                                                                                        | Description                     |\r\n| -------------------------------------------------------------------------------------------------------------------- | ------------------------------- |\r\n| `GET /subscriptions/{subscriptionId}/providers/Contoso.Users/users`                                                  | list all User by subscription   |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users`               | list all User by resource group |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                        |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | create item                     |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                      |\r\n|\n\nall User by resource group |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                        |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | create item                     |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                      |\r\n| `DELETE /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}` | delete item                     |\r\n\r\n#### Base Resource Types\r\n\r\nHere are the base resource types you can use when defining your own ARM resources:\r\n\r\n| Name                             | Description                                                                            |\r\n| -------------------------------- | -------------------------------------------------------------------------------------- |\r\n| `TrackedResource<TProperties>`   | Defines a normal ARM resource where `TProperties` is the model of the `properties`     |\r\n| `ProxyResource<TProperties>`     | Defines a proxy ARM resource where `TProperties` is the model of the `properties`      |\r\n| `ExtensionResource<TProperties>` | Defines an extension ARM resource where `TProperties` is the model of the `properties` |\n\n### Alternate (Legacy) Syntax for Operations\n\nAlternately, you can use interface templates, which define a set of operations in your resource operations interface. Interface templates are convenient if you want to conform to standard\r\npractices, but are less flexible than operation templates.\r\n\r\nTo specify the standard set of TrackedResource operations for your resource, you can use the following code:\r\n\r\n```typespec\r\n@armResourceOperations\r\ninterface Users extends TrackedResourceOperations<User, UserProperties> {}\r\n```\r\n\r\nThis will now produce all the endpoints(`get`, `post`, `put`, `patch` and `delete`, listByResourceGroup, listBySubscription) for a resource called `Users` and the `operations` endpoint for the service:\r\n\r\n| Method & Path                                                                                                        | Description                          |\r\n| -------------------------------------------------------------------------------------------------------------------- | ------------------------------------ |\r\n| `GET /providers/Contoso.Users/operations`                                                                            | List all operations for your service |\r\n| `GET /subscriptions/{subscriptionId}/providers/Contoso.Users/users`                                                  | list all User by subscription        |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users`               | list all User by resource group      |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                             |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | insert item                          |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                           |\r\n|\n\ngroup      |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                             |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | insert item                          |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                           |\r\n| `DELETE /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}` | delete item                          |\r\n\r\n#### Base Resource Types\r\n\r\nHere are the base resource types you can use when defining your own ARM resources:\r\n\r\n| Name                             | Description                                                                            |\r\n| -------------------------------- | -------------------------------------------------------------------------------------- |\r\n| `TrackedResource<TProperties>`   | Defines a normal ARM resource where `TProperties` is the model of the `properties`     |\r\n| `ProxyResource<TProperties>`     | Defines a proxy ARM resource where `TProperties` is the model of the `properties`      |\r\n| `ExtensionResource<TProperties>` | Defines an extension ARM resource where `TProperties` is the model of the `properties` |\n", "latency": 13.138379335403442, "response_length": 1479}
{"query": "title: Override contentType: \"application/json\" for ResourceCreateOrUpdate\n\nquestion: Hi\nTypeSpec Discussion\n,\nI am migrating an old swagger to typespec. I came across a method which is a PATCH ops with a application/json as content type. The API behaves exactly as a merge-patch route, but I cannot change it since it'll be consider a breaking change. In order to still use the convenient functionalities of typespec traits, I have define a custom function like so playground and am using it.\nIs there a better alternative?", "ground_truth": "Yes. it's expected that if you are using a non-standard content-type for PATCH you will need to use a custom operation or a custom operation template.", "response": "To override the `contentType` for a PATCH operation in TypeSpec, you can use the `@header` decorator to explicitly specify the `contentType` header for the operation. This approach allows you to maintain compatibility with the existing API behavior while leveraging TypeSpec's traits and decorators. Here's an example:\n\n```typespec\n@patch\nop updateResource(\n  @header contentType: \"application/json\",\n  @body resource: Partial<Resource>\n): Resource;\n```\n\nThis ensures that the `contentType` is explicitly set to `application/json` for the PATCH operation. If you need to handle multiple content types, you can specify them as a union:\n\n```typespec\n@patch\nop updateResource(\n  @header contentType: \"application/json\" | \"application/merge-patch+json\",\n  @body resource: Partial<Resource>\n): Resource;\n```\n\nThis approach is straightforward and aligns with TypeSpec's best practices for specifying content types. If you have already implemented a custom function, this method provides a simpler alternative without requiring additional customization.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#events#reference#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/libraries/events/reference/decorators\n- document_content: # libraries#events#reference#decorators.md\n\n# Decorators\n\n## TypeSpec.Events\n\n### `@contentType` {#@TypeSpec.Events.contentType}\n\nSpecifies the content type of the event envelope, event body, or event payload.\r\nWhen applied to an event payload, that field must also have a corresponding `@data`\r\ndecorator.\r\n\r\n```typespec\r\n@TypeSpec.Events.contentType(contentType: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`UnionVariant | ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name        | Type             | Description |\r\n| ----------- | ---------------- | ----------- |\r\n| contentType | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@events\r\nunion MixedEvents {\r\n  @contentType(\"application/json\")\r\n  message: {\r\n    id: string,\r\n    text: string,\r\n  },\r\n}\r\n```\r\n\r\n##### Specify the content type of the event payload.\r\n\r\n```typespec\r\n@events\r\nunion MixedEvents {\r\n  {\r\n    done: true,\r\n  },\r\n  {\r\n    done: false,\r\n    @data @contentType(\"text/plain\") value: string,\r\n  },\r\n}\r\n```\n\n### `@data` {#@TypeSpec.Events.data}\n\nIdentifies the payload of an event.\r\nOnly one field in an event can be marked as the payload.\r\n\r\n```typespec\r\n@TypeSpec.Events.data\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@events\r\nunion MixedEvents {\r\n  {\r\n    metadata: Record<string>,\r\n    @data payload: string,\r\n  },\r\n}\r\n```\n\n### `@events` {#@TypeSpec.Events.events}\n\nSpecify that this union describes a set of events.\r\n\r\n```typespec\r\n@TypeSpec.Events.events\r\n```\r\n\r\n#### Target\r\n\r\n`Union`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@events\r\nunion MixedEvents {\r\n  pingEvent: string,\r\n  doneEvent: \"done\",\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#http#content-types.md\n- document_title: Content types\n- document_link: https://typespec.io/docs/libraries/http/content-types\n- document_content: # libraries#http#content-types.md\n\n# Content types\n\n## Default behavior\n\nBy default, if the content-type is not explicitly specified, the HTTP library will use the [`@mediaTypeHint`](../../standard-library/built-in-decorators.md#mediatypehint-mediatypehint) of the body type. For built-in TypeSpec types, the default content-type values are:\r\n\r\n- `\"application/json\"` if the body is a Model or a union that contains `null`.\r\n- `\"application/octet-stream\"` if the body is `TypeSpec.bytes` or a scalar that extends it (unless that scalar provides its own `@mediaTypeHint`).\r\n- `\"text/plain\"` if the body is any other scalar type that does not have a `@mediaTypeHint`.\r\n\r\n**Examples:**\r\n\r\n```typespec\r\n// Returns an application/octet-stream binary body\r\nop download(): bytes;\r\n\r\n// Returns a text/plain string\r\nop getContent(): string;\r\n\r\n// Returns an application/json body that is either a string or the `null` value\r\nop getContentNullable(): string | null;\r\n\r\n// Returns an application/json body with a `name` property.\r\nop getPet(): {\r\n  name: string;\r\n};\r\n```\r\n\r\nThe same logic applies to requests and response bodies, and it uses the precise type of the body if `@body` or `@bodyRoot` are used.\n\n## Specifying Content-Type\n\nYou can specify the content type for an operation by including a header parameter named `contentType`.\n\n### Request Content-Type\n\n```typespec\r\nop uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n```\n\n### Response Content-Type\n\n```typespec\r\nop downloadImage(): {\r\n  @header contentType: \"image/png\";\r\n  @body image: bytes;\r\n};\r\n```\n\n### Multiple Content-Type values\n\nIf there are multiple content types for the same body, you can specify them as a union of strings.\r\n\r\n```typespec\r\nop uploadImage(@header contentType: \"image/png\" | \"image/jpeg\", @body image: bytes): void;\r\n```\n\n## Content-Type negotiation\n\nIn some cases, the same endpoint might return different content depending on the requested content type. This can be achieved in two ways:\r\n\r\n- Using shared routes where different content responses are represented as different operations that share the same endpoint.\r\n- Using overloads where each different content response is an overload.\r\n\r\nFor example, an API that lets you download an avatar as either `png` or `jpeg` based on the `Accept` header.\n\n### Option 1: Using a shared route\n\n```tsp\r\nmodel PngImage {\r\n  @header contentType: \"image/png\";\r\n  @body image: bytes;\r\n}\r\n\r\nmodel JpegImage {\r\n  @header contentType: \"image/jpeg\";\r\n  @body image: bytes;\r\n}\r\n\r\n@route(\"/avatar\")\r\n@sharedRoute\r\nop getAvatarAsPng(@header accept: \"image/png\"): PngImage;\r\n\r\n@route(\"/avatar\")\r\n@sharedRoute\r\nop getAvatarAsJpeg(@header accept: \"image/jpeg\"): JpegImage;\r\n```\n\n### Option 2: Using overload\n\n```tsp\r\nmodel PngImage {\r\n  @header contentType: \"image/png\";\r\n  @body image: bytes;\r\n}\r\n\r\nmodel JpegImage {\r\n  @header contentType: \"image/jpeg\";\r\n  @body image: bytes;\r\n}\r\n\r\n@route(\"/avatar\")\r\nop getAvatar(@header accept: \"image/png\" | \"image/jpeg\"): PngImage | JpegImage;\r\n\r\n@overload(getAvatar)\r\nop getAvatarAsPng(@header accept: \"image/png\"): PngImage;\r\n\r\n@overload(getAvatar)\r\nop getAvatarAsJpeg(@header accept: \"image/jpeg\"): JpegImage;\r\n```\n\n## Multipart request\n\nSee [the documentation of multipart requests and responses for more information](./multipart.md).\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n", "latency": 12.296274900436401, "response_length": 1046}
{"query": "Defining a GET /latest API in TypeSpec", "ground_truth": "We could either model this as a singleton sub-resource using resource read, or as a resource action (overriding the verb to get) over the resource\n[Here is a playground](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BQAhkBwYXJlbnTIKyjIHikKQOQCZ2xldG9uKCJsYXTkAzop5wCQUnVu9ACLUnVu%2FwCG6gCGUnVuPjvGIURlZmF1bHTlAQPnAvdTdGF06ADSeeUAqOQBLspdIG9mIHRoZSBydeUB7iNzdXBwcmVzc%2F8Die8DiS9hcm3KFXDrAIAtc%2BQAgSIgImtpbmRh6QGSIuoBAOsAjOgCkuQAkWRlc2NyaXB05AKH7gCkIMwcPzogc3Ry5QPg5wDc6QHjcMpZ8QIA03VBZ2XEaWXIP8VqYWdlPzogaW50MzI7CscpQ2l0edIqY2l0eesAjccsUHJvZmls01lAZW5jb2RlKCJiYXNlNjR1cmwi5ALkcMYwPzogYnl0ZXPJSFRoZSDkAUp16QGxbGFzdCDkAMVh5AEH5QSAICBA5AF4YmlsaXR5KExpZmVjeWNs5ANkYWTHXe4CGD865gTQzBTpAUjEc8wy5QCA5QDK6gHHxXdAbHJvxDt1cwp1buQBr9FU5QFk5gEaLOwA0shHIGNyZcQncmVxdWVzdCBoYXMgYmVlbiBhY2NlcHRlZMRnICBBxw46ICLICyLWUGnEQOQAtOkAwchE7ACcOiAizA%2FaTHVwZGF0xE%2FFQ1XHDjogIsgLyjvpBinpAMTmANxk5wGiU3VjY2VlZOUAxckM0z%2FFNuQBTWZhaWzJPkbFDTogIsYJ3Dh3YXMgY2FuY2XKPkPHD%2BQGgccL%2FwFAIGRlbGXpAYBExA3mAPnICyLpBYHpA3dtb3bqAcrpA3lNb3ZlUscV6ANyxHNtb3bEaGZyb20gbG9j5gC8xW7EE%2FEDUMszdG%2FPMXRv%2BgQM5wCVc3BvbnPrBg%2FmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AegT%2BgDlHMgZXh0ZW5kc%2FYIYi7LKXvkBkBhcm3II8oby1noAM3mBLNnZXTkAadByjXkA%2BfsBpQg5wJ7T3LlAqflAdbLL0PHHVJlcGxhY2VBc3luY84%2F5QL30DdQYXRjaFPMLCzzBVbFQOYCPc9A5QI6ZVdpdGhvdXRPa9N3bGlzdEJ5yDBHcm91cM9ETMUiUOUHcNQ8U3Vi6gY9xjvGM8wZzDnoBgMgc2FtcGzrAwlhY8VEdGhhdOYCBukFxnRvIGRpZmZl5ACE7wKJxSnuALJBxUjvATfrAxTIDeYCi%2FMAkkhFQUTqBe%2FEfmNoZWNr6gCqZXhpc3RlbuYI7SDGHkXJFO8B%2B80d7wEJZ2V05gLgzzXlAl%2FmCG19Cg%3D%3D&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D) showing this as a resource\n[Here is a playground](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhkRldGFpbHMgb2YgYSBydeUBQcZ5UnVu6QFxcnAt5ALVaWZpYyBwyW3ELCDLED86xDXqAI07CuYAjERlZmF1bHTlAOjnAtxTdGF06AC3eekAjco75ACQdGhl6ACSI3N1cHByZXNz%2FwNu7wNuL2FybcoVcOsAgC1z5ACBIiAia2luZGHpAXci6gD86wCM6AEG5ACRZGVzY3JpcHTkAmzuAKQgzBw%2FOiBzdHLlA8XnANzpAcjuAUDuAeXTdUFnZcRpZcg%2FxWphZ2U%2FOiBpbnQzMuUBZcQpQ2l0edIqY2l0eesAjccsUHJvZmls01lAZW5jb2RlKCJiYXNlNjR1cmwi5ALJcMYwPzogYnl05wHZxEhUaGUg5AFKdekBsWxhc3Qg5ADFYeQBB%2BUEZSAgQOQBeGJpbGl0eShMaWZlY3ljbOQDSWFkx13uAhg%2FOuYEtcwU6QFIxHPMMuUAgOUAyuoBx8V3QGxyb8Q7dXMKdW7kAa%2FRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QYO6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBmbHC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QVm6QN3bW926gHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b%2FoEDOcAlXNwb25z6wX05gCWxxbsAJfuA2zFPsVkxnzmAu7NbmludGVyZuQHhU%2FoA5RzIGV4dGVuZHP2CEcuyyl7fQrlCCPII8oby1noAM3mBLNnZXTkAadByjXkA%2BfsBnkg5wJ7T3LlAqflAdbLL0PHHVJlcGxhY2VBc3luY84%2F5QL30DdQYXRjaFPMLCzzBVbFQOYCPc9A5QI6ZVdpdGhvdXRPa9N3bGlzdEJ5yDBHcm91cM9ETMUiUGFyZW501DxTdWLqBj3GO8YzzBnMOegGAyBzYW1wbOsDCWFjxUR0aGF05gIG6QXGdG8gZGlmZmXkAITvAonFKe4AskHFSO8BN%2BsDFMgN5gKL8wCSSEVBROoF78R%2BY2hlY2vqAKpleGlzdGVu5gjSIMYeRckU7wH7zR3vAQlAZ2V0xAfmAPsoInJ1bnMvbGF05AvW5AZGZ2V05gMA%2FwDj5QDjdm9pZCzkB%2BblCQk%3D&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D) showing modeling this as an action.  In both cases, using 'getStatus' as the operation name.", "response": "To define a `GET /latest` API in TypeSpec, you can use the `@get` decorator to specify the HTTP method and the `@route` decorator to define the path. Below is an example:\n\n```tsp\nimport \"@typespec/http\";\n\nusing Http;\n\n@service(#{ title: \"Latest API Service\" })\n@server(\"https://example.com\", \"API Server\")\nnamespace LatestAPI {\n  @route(\"/latest\")\n  @get\n  op getLatest(): {\n    @statusCode status: 200;\n    @body body: string;\n  };\n}\n```\n\nIn this example:\n- `@route(\"/latest\")` specifies the path for the operation.\n- `@get` indicates that the operation uses the HTTP GET method.\n- The return type defines the response structure, including a `200` status code and a body containing a string.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#http#reference#data-types.md\n- document_title: Data types\n- document_link: https://typespec.io/docs/libraries/http/reference/data-types\n- document_content: # libraries#http#reference#data-types.md\n\n# Data types\n\n## TypeSpec.Http\n\n### `AcceptedResponse` {#TypeSpec.Http.AcceptedResponse}\n\nThe request has been accepted for processing, but processing has not yet completed.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.AcceptedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `202` | The status code. |\n\n### `ApiKeyAuth` {#TypeSpec.Http.ApiKeyAuth}\n\nAn API key is a token that a client provides when making API calls. The key can be sent in the query string:\r\n\r\n```\r\nGET /something?api_key=abcdef12345\r\n```\r\n\r\nor as a request header\r\n\r\n```\r\nGET /something HTTP/1.1\r\nX-API-Key: abcdef12345\r\n```\r\n\r\nor as a cookie\r\n\r\n```\r\nGET /something HTTP/1.1\r\nCookie: X-API-KEY=abcdef12345\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ApiKeyAuth<Location, Name>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                 |\r\n| -------- | --------------------------- |\r\n| Location | The location of the API key |\r\n| Name     | The name of the API key     |\r\n\r\n#### Properties\r\n\r\n| Name | Type                            | Description |\r\n| ---- | ------------------------------- | ----------- |\r\n| type | `TypeSpec.Http.AuthType.apiKey` |             |\r\n| in   | `Location`                      |             |\r\n| name | `Name`                          |             |\n\n### `AuthorizationCodeFlow` {#TypeSpec.Http.AuthorizationCodeFlow}\n\nAuthorization Code flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.AuthorizationCodeFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                             | Description                       |\r\n| ---------------- | ------------------------------------------------ | --------------------------------- |\r\n| type             | `TypeSpec.Http.OAuth2FlowType.authorizationCode` | authorization code flow           |\r\n| authorizationUrl | `string`                                         | the authorization URL             |\r\n| tokenUrl         | `string`                                         | the token URL                     |\r\n| refreshUrl?      | `string`                                         | the refresh URL                   |\r\n| scopes?          | `string[]`                                       | list of scopes for the credential |\n\n### `BadRequestResponse` {#TypeSpec.Http.BadRequestResponse}\n\nThe server could not understand the request due to invalid syntax.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.BadRequestResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `400` | The status code. |\n\n### `BasicAuth` {#TypeSpec.Http.BasicAuth}\n\nBasic authentication is a simple authentication scheme built into the HTTP protocol.\r\nThe client sends HTTP requests with the Authorization header that contains the word Basic word followed by a space and a base64-encoded string username:password.\r\nFor example, to authorize as demo / `p@55w0rd` the client would send\r\n\r\n```\r\nAuthorization: Basic ZGVtbzpwQDU1dzByZA==\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.BasicAuth\r\n```\r\n\r\n#### Properties\r\n\r\n| Name   | Type                          | Description         |\r\n| ------ | ----------------------------- | ------------------- |\r\n| type   | `TypeSpec.Http.AuthType.http` | Http authentication |\r\n| scheme | `\"Basic\"`                     | basic auth scheme   |\n\n### `BearerAuth` {#TypeSpec.Http.BearerAuth}\n\nBearer authentication (also called token authentication) is an HTTP authentication scheme that involves security tokens called bearer tokens.\r\nThe name Bearer authentication can be understood as give access to the bearer of this token. The bearer token is a cryptic string, usually generated by the server in response to a login request.\r\nThe client must send this token in the Authorization header when making requests to protected resources:\r\n\r\n```\r\nAuthorization: Bearer <token>\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.BearerAuth\r\n```\r\n\r\n#### Properties\r\n\r\n| Name   | Type                          | Description         |\r\n| ------ | ----------------------------- | ------------------- |\r\n| type   | `TypeSpec.Http.AuthType.http` | Http authentication |\r\n| scheme | `\"Bearer\"`                    | bearer auth scheme  |\n\n### `Body` {#TypeSpec.Http.Body}\n\nDefines a model with a single property of the given type, marked with `@body`.\r\n\r\nThis can be useful in situations where you cannot use a bare type as the body\r\nand it is awkward to add a property.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.Body<Type>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name | Description                              |\r\n| ---- | ---------------------------------------- |\r\n| Type | The type of the model's `body` property. |\r\n\r\n#### Properties\r\n\r\n| Name | Type   | Description |\r\n| ---- | ------ | ----------- |\r\n| body | `Type` |             |\n\n### `ClientCredentialsFlow` {#TypeSpec.Http.ClientCredentialsFlow}\n\nClient credentials flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ClientCredentialsFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type                                             | Description                       |\r\n| ----------- | ------------------------------------------------ | --------------------------------- |\r\n| type        | `TypeSpec.Http.OAuth2FlowType.clientCredentials` | client credential flow            |\r\n| tokenUrl    | `string`                                         | the token URL                     |\r\n| refreshUrl? | `string`                                         | the refresh URL                   |\r\n| scopes?     | `string[]`                                       | list of scopes for the credential |\n\n### `ConflictResponse` {#TypeSpec.Http.ConflictResponse}\n\nThe request conflicts with the current state of the server.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ConflictResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `409` | The status code. |\n\n### `CookieOptions` {#TypeSpec.Http.CookieOptions}\n\nCookie Options.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.CookieOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type     | Description         |\r\n| ----- | -------- | ------------------- |\r\n| name? | `string` | Name in the cookie. |\n\n### `CreatedResponse` {#TypeSpec.Http.CreatedResponse}\n\nThe request has succeeded and a new resource has been created as a result.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.CreatedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `201` | The status code. |\n\n### `File` {#TypeSpec.Http.File}\n\nbelow for more information.\r\n\r\nNOTE: The `filename` and `contentType` fields are optional. Furthermore, the default location of `filename`\r\n(`Content-Disposition: <disposition>; filename=<filename>`) is only valid in HTTP responses and multipart payloads. If\r\nyou wish to send the `filename` in a request, you must use HTTP metadata decorators to describe the location of the\r\n`filename` field. You can combine the metadata decorators with `@visibility` to control when the `filename` location\r\nis overridden, as shown in the examples below.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.File<ContentType, Contents>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name        | Description                                                                                    |\r\n| ----------- | ---------------------------------------------------------------------------------------------- |\r\n| ContentType | The allowed media (MIME) types of the file contents.                                           |\r\n| Contents    | The type of the file contents. This can be `string`, `bytes`, or any scalar that extends them. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n// Download a file\r\n@get op download(): File;\r\n\r\n// Upload a file\r\n@post op upload(@bodyRoot file: File): void;\r\n```\r\n\r\n```tsp\r\n// Upload and download files in a multipart payload\r\nop multipartFormDataUpload(\r\n  @multipartBody fields: {\r\n    files: HttpPart<File>[];\r\n  },\r\n): void;\r\n\r\nop multipartFormDataDownload(): {\r\n  @multipartBody formFields: {\r\n    files: HttpPart<File>[];\r\n  };\r\n};\r\n```\r\n\r\n```tsp\r\n// Declare a custom type of text file, where the filename goes in the path\r\n// in requests.\r\nmodel SpecFile extends File<\"application/json\" | \"application/yaml\", string> {\r\n  // Provide a header that contains the name of the file when created or updated\r\n  @header(\"x-filename\")\r\n  @path\r\n  filename: string;\r\n}\r\n\r\n@get op downloadSpec(@path name: string): SpecFile;\r\n\r\n@post op uploadSpec(@bodyRoot spec: SpecFile): void;\r\n```\r\n\r\n```tsp\n\nA file in an HTTP request, response, or multipart payload.\r\n\r\nFiles have a special meaning that the HTTP library understands. When the body of an HTTP request, response,\r\nor multipart payload is _effectively_ an instance of `TypeSpec.Http.File` or any type that extends it, the\r\noperation is treated as a file upload or download.\r\n\r\nWhen using file bodies, the fields of the file model are defined to come from particular locations by default:\r\n\r\n- `contentType`: The `Content-Type` header of the request, response, or multipart payload (CANNOT be overridden or changed).\r\n- `contents`: The body of the request, response, or multipart payload (CANNOT be overridden or changed).\r\n- `filename`: The `filename` parameter value of the `Content-Disposition` header of the response or multipart payload\r\n  (MAY be overridden or changed).\r\n\r\nA File may be used as a normal structured JSON object in a request or response, if the request specifies an explicit\r\n`Content-Type` header. In this case, the entire File model is serialized as if it were any other model. In a JSON payload,\r\nit will have a structure like:\r\n\r\n```\r\n{\r\n  \"contentType\": <string?>,\r\n  \"filename\": <string?>,\r\n  \"contents\": <string, base64>\r\n}\r\n```\r\n\r\nThe `contentType` _within_ the file defines what media types the data inside the file can be, but if the specification\r\ndefines a `Content-Type` for the payload as HTTP metadata, that `Content-Type` metadata defines _how the file is\r\nserialized_. See the examples below for more information.\r\n\r\nNOTE: The `filename` and `contentType` fields are optional. Furthermore, the default location of `filename`\r\n(`Content-Disposition: <disposition>; filename=<filename>`) is only valid in HTTP responses and multipart payloads. If\r\nyou wish to send the `filename` in a request, you must use HTTP metadata decorators to describe the location of the\r\n`filename` field. You can combine the metadata decorators with `@visibility` to control when the `filename` location\n\n{\r\n    files: HttpPart<File>[];\r\n  };\r\n};\r\n```\r\n\r\n```tsp\r\n// Declare a custom type of text file, where the filename goes in the path\r\n// in requests.\r\nmodel SpecFile extends File<\"application/json\" | \"application/yaml\", string> {\r\n  // Provide a header that contains the name of the file when created or updated\r\n  @header(\"x-filename\")\r\n  @path\r\n  filename: string;\r\n}\r\n\r\n@get op downloadSpec(@path name: string): SpecFile;\r\n\r\n@post op uploadSpec(@bodyRoot spec: SpecFile): void;\r\n```\r\n\r\n```tsp\r\n// Declare a custom type of binary file\r\nmodel ImageFile extends File {\r\n  contentType: \"image/png\" | \"image/jpeg\";\r\n  @path filename: string;\r\n}\r\n\r\n@get op downloadImage(@path name: string): ImageFile;\r\n\r\n@post op uploadImage(@bodyRoot image: ImageFile): void;\r\n```\r\n\r\n````tsp\r\n// Use a File as a structured JSON object. The HTTP library will warn you that the File will be serialized as JSON,\r\n// so you should suppress the warning if it's really what you want instead of a binary file upload/download.\r\n\r\n// The response body is a JSON object like `{\"contentType\":<string?>,\"filename\":<string?>,\"contents\":<string>}`\r\n@get op downloadTextFileJson(): {\r\n  @header contentType: \"application/json\",\r\n  @body file: File<\"text/plain\", string>,\r\n};\r\n\r\n// The request body is a JSON object like `{\"contentType\":<string?>,\"filename\":<string?>,\"contents\":<base64>}`\r\n@post op uploadBinaryFileJson(\r\n  @header contentType: \"application/json\",\r\n  @body file: File<\"image/png\", bytes>,\r\n): void;\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| contentType? | `ContentType` | The allowed media (MIME) types of the file contents.<br /><br />In file bodies, this value comes from the `Content-Type` header of the request or response. In JSON bodies,<br />this value is serialized as a field in the response.<br /><br />NOTE: this is not _necessarily_ the same as the `Content-Type` header of the request or response, but<br />it will be for file bodies.\n\n): void;\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| contentType? | `ContentType` | The allowed media (MIME) types of the file contents.<br /><br />In file bodies, this value comes from the `Content-Type` header of the request or response. In JSON bodies,<br />this value is serialized as a field in the response.<br /><br />NOTE: this is not _necessarily_ the same as the `Content-Type` header of the request or response, but<br />it will be for file bodies. It may be different if the file is serialized as a JSON object. It always refers to the<br />_contents_ of the file, and not necessarily the way the file itself is transmitted or serialized. |\r\n| filename? | `string` | The name of the file, if any.<br /><br />In file bodies, this value comes from the `filename` parameter of the `Content-Disposition` header of the response<br />or multipart payload. In JSON bodies, this value is serialized as a field in the response.<br /><br />NOTE: By default, `filename` cannot be sent in request payloads and can only be sent in responses and multipart<br />payloads, as the `Content-Disposition` header is not valid in requests. If you want to send the `filename` in a request,<br />you must extend the `File` model and override the `filename` property with a different location defined by HTTP metadata<br />decorators. |\r\n| contents | `Contents` | The contents of the file.<br /><br />In file bodies, this value comes from the body of the request, response, or multipart payload. In JSON bodies,<br />this value is serialized as a field in the response. |\n\n### `ForbiddenResponse` {#TypeSpec.Http.ForbiddenResponse}\n\nAccess is forbidden.\r\n```typespec\r\nmodel TypeSpec.Http.ForbiddenResponse\r\n````\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `403` | The status code. |\n\n### `HeaderOptions` {#TypeSpec.Http.HeaderOptions}\n\nHeader options.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.HeaderOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| -------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| name?    | `string`  | Name of the header when sent over HTTP.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\r\n| explode? | `boolean` | Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)<br /><br />\\| Style \\| Explode \\| Primitive value = 5 \\|\n\n|\r\n| explode? | `boolean` | Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)<br /><br />\\| Style \\| Explode \\| Primitive value = 5 \\| Array = [3, 4, 5] \\| Object = {\"role\": \"admin\", \"firstName\": \"Alex\"} \\|<br />\\| ------ \\| ------- \\| ------------------- \\| ----------------- \\| ----------------------------------------------- \\|<br />\\| simple \\| false \\| `5   ` \\| `3,4,5` \\| `role,admin,firstName,Alex` \\|<br />\\| simple \\| true \\| `5` \\| `3,4,5` \\| `role=admin,firstName=Alex` \\| |\n\n### `HttpPart` {#TypeSpec.Http.HttpPart}\n\n```typespec\r\nmodel TypeSpec.Http.HttpPart<Type, Options>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name    | Description |\r\n| ------- | ----------- |\r\n| Type    |             |\r\n| Options |             |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `HttpPartOptions` {#TypeSpec.Http.HttpPartOptions}\n\n```typespec\r\nmodel TypeSpec.Http.HttpPartOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type     | Description                                 |\r\n| ----- | -------- | ------------------------------------------- |\r\n| name? | `string` | Name of the part when using the array form. |\n\n### `ImplicitFlow` {#TypeSpec.Http.ImplicitFlow}\n\nImplicit flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ImplicitFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                    | Description                       |\r\n| ---------------- | --------------------------------------- | --------------------------------- |\r\n| type             | `TypeSpec.Http.OAuth2FlowType.implicit` | implicit flow                     |\r\n| authorizationUrl | `string`                                | the authorization URL             |\r\n| refreshUrl?      | `string`                                | the refresh URL                   |\r\n| scopes?          | `string[]`                              | list of scopes for the credential |\n\n### `Link` {#TypeSpec.Http.Link}\n\n```typespec\r\nmodel TypeSpec.Http.Link\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type              | Description |\r\n| ----------- | ----------------- | ----------- |\r\n| target      | `url`             |             |\r\n| rel         | `string`          |             |\r\n| attributes? | `Record<unknown>` |             |\n\n### `LocationHeader` {#TypeSpec.Http.LocationHeader}\n\nThe Location header contains the URL where the status of the long running operation can be checked.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.LocationHeader\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type     | Description                                                                                         |\r\n| -------- | -------- | --------------------------------------------------------------------------------------------------- |\r\n| location | `string` | The Location header contains the URL where the status of the long running operation can be checked. |\n\n### `MovedResponse` {#TypeSpec.Http.MovedResponse}\n\nThe URL of the requested resource has been changed permanently. The new URL is given in the response.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.MovedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type     | Description                                                                                         |\r\n| ---------- | -------- | --------------------------------------------------------------------------------------------------- |\r\n| statusCode | `301`    | The status code.                                                                                    |\r\n| location   | `string` | The Location header contains the URL where the status of the long running operation can be checked. |\n\n### `NoAuth` {#TypeSpec.Http.NoAuth}\n\nThis authentication option signifies that API is not secured at all.\r\nIt might be useful when overriding authentication on interface of operation level.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NoAuth\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type                            | Description |\r\n| ---- | ------------------------------- | ----------- |\r\n| type | `TypeSpec.Http.AuthType.noAuth` |             |\n\n### `NoContentResponse` {#TypeSpec.Http.NoContentResponse}\n\nThere is no content to send for this request, but the headers may be useful.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NoContentResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `204` | The status code. |\n\n### `NotFoundResponse` {#TypeSpec.Http.NotFoundResponse}\n\nThe server cannot find the requested resource.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NotFoundResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `404` | The status code. |\n\n### `NotModifiedResponse` {#TypeSpec.Http.NotModifiedResponse}\n\nThe client has made a conditional request and the resource has not been modified.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NotModifiedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `304` | The status code. |\n\n### `OAuth2Auth` {#TypeSpec.Http.OAuth2Auth}\n\nOAuth 2.0 is an authorization protocol that gives an API client limited access to user data on a web server.\r\n\r\nOAuth relies on authentication scenarios called flows, which allow the resource owner (user) to share the protected content from the resource server without sharing their credentials.\r\nFor that purpose, an OAuth 2.0 server issues access tokens that the client applications can use to access protected resources on behalf of the resource owner.\r\nFor more information about OAuth 2.0, see oauth.net and RFC 6749.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.OAuth2Auth<Flows, Scopes>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name   | Description                                                                                                                                      |\r\n| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Flows  | The list of supported OAuth2 flows                                                                                                               |\r\n| Scopes | The list of OAuth2 scopes, which are common for every flow from `Flows`. This list is combined with the scopes defined in specific OAuth2 flows. |\r\n\r\n#### Properties\r\n\r\n| Name          | Type                            | Description |\r\n| ------------- | ------------------------------- | ----------- |\r\n| type          | `TypeSpec.Http.AuthType.oauth2` |             |\r\n| flows         | `Flows`                         |             |\r\n| defaultScopes | `Scopes`                        |             |\n\n### `OkResponse` {#TypeSpec.Http.OkResponse}\n\nThe request has succeeded.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.OkResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `200` | The status code. |\n\n### `OpenIdConnectAuth` {#TypeSpec.Http.OpenIdConnectAuth}\n\nOpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0 protocol and supported by some OAuth 2.0 providers, such as Google and Azure Active Directory.\r\nIt defines a sign-in flow that enables a client application to authenticate a user, and to obtain information (or \"claims\") about that user, such as the user name, email, and so on.\r\nUser identity information is encoded in a secure JSON Web Token (JWT), called ID token.\r\nOpenID Connect defines a discovery mechanism, called OpenID Connect Discovery, where an OpenID server publishes its metadata at a well-known URL, typically\r\n\r\n```http\r\nhttps://server.com/.well-known/openid-configuration\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.OpenIdConnectAuth<ConnectUrl>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description |\r\n| ---------- | ----------- |\r\n| ConnectUrl |             |\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                   | Description                                                 |\r\n| ---------------- | -------------------------------------- | ----------------------------------------------------------- |\r\n| type             | `TypeSpec.Http.AuthType.openIdConnect` | Auth type                                                   |\r\n| openIdConnectUrl | `ConnectUrl`                           | Connect url. It can be specified relative to the server URL |\n\n### `PasswordFlow` {#TypeSpec.Http.PasswordFlow}\n\nResource Owner Password flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.PasswordFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type                                    | Description                       |\r\n| ----------- | --------------------------------------- | --------------------------------- |\r\n| type        | `TypeSpec.Http.OAuth2FlowType.password` | password flow                     |\r\n| tokenUrl    | `string`                                | the token URL                     |\r\n| refreshUrl? | `string`                                | the refresh URL                   |\r\n| scopes?     | `string[]`                              | list of scopes for the credential |\n\n### `PatchOptions` {#TypeSpec.Http.PatchOptions}\n\nOptions for PATCH operations.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.PatchOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name                 | Type      | Description                                                                                                       |\r\n| -------------------- | --------- | ----------------------------------------------------------------------------------------------------------------- |\r\n| implicitOptionality? | `boolean` | If set to `false`, disables the implicit transform that makes the body of a<br />PATCH operation deeply optional. |\n\n### `PathOptions` {#TypeSpec.Http.PathOptions}\n\n```typespec\r\nmodel TypeSpec.Http.PathOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name           | Type                                                      | Description                                                                                                                                                                                                                                  |\r\n| -------------- | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| name?          | `string`                                                  | Name of the parameter in the uri template.                                                                                                                                                                                                   |\r\n| explode?       | `boolean`                                                 | When interpolating this parameter in the case of array or object expand each value using the given style.<br />Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3) |\r\n| style?         | `\"simple\" \\| \"label\" \\| \"matrix\" \\| \"fragment\" \\| \"path\"` | Different interpolating styles for the path parameter.<br />- `simple`: No special encoding.<br />- `label`: Using `.` separator.<br />- `matrix`: `;` as separator.<br />- `fragment`: `#` as separator.<br />- `path`: `/` as separator.   |\r\n| allowReserved? | `boolean`                                                 | When interpolating this parameter do not encode reserved characters.<br />Equivalent of adding `+` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)                                      |\n\n### `PlainData` {#TypeSpec.Http.PlainData}\n\nProduces a new model with the same properties as T, but with `@query`,\r\n`@header`, `@body`, and `@path` decorators removed from all properties.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.PlainData<Data>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name | Description                            |\r\n| ---- | -------------------------------------- |\r\n| Data | The model to spread as the plain data. |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `QueryOptions` {#TypeSpec.Http.QueryOptions}\n\nQuery parameter options.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.QueryOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| -------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| name?    | `string`  | Name of the query when included in the url.\n\n|\r\n| name?    | `string`  | Name of the query when included in the url.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| explode? | `boolean` | If true send each value in the array/object as a separate query parameter.<br />Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)<br /><br />\\| Style \\| Explode \\| Uri Template \\| Primitive value id = 5 \\| Array id = [3, 4, 5] \\| Object id = {\"role\": \"admin\", \"firstName\": \"Alex\"} \\|<br />\\| ------ \\| ------- \\| -------------- \\| ---------------------- \\| ----------------------- \\| -------------------------------------------------- \\|<br />\\| simple \\| false \\| `/users{?id}` \\| `/users?id=5` \\| `/users?id=3,4,5` \\| `/users?id=role,admin,firstName,Alex` \\|<br />\\| simple \\| true \\| `/users{?id*}` \\| `/users?id=5` \\| `/users?id=3&id=4&id=5` \\| `/users?role=admin&firstName=Alex` \\| |\n\n### `Response` {#TypeSpec.Http.Response}\n\nDescribes an HTTP response.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.Response<Status>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name   | Description                      |\r\n| ------ | -------------------------------- |\r\n| Status | The status code of the response. |\r\n\r\n#### Properties\r\n\r\n| Name       | Type     | Description |\r\n| ---------- | -------- | ----------- |\r\n| statusCode | `Status` |             |\n\n### `UnauthorizedResponse` {#TypeSpec.Http.UnauthorizedResponse}\n\nAccess is unauthorized.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.UnauthorizedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `401` | The status code. |\n\n### `ApiKeyLocation` {#TypeSpec.Http.ApiKeyLocation}\n\nDescribes the location of the API key\r\n\r\n```typespec\r\nenum TypeSpec.Http.ApiKeyLocation\r\n```\r\n\r\n| Name   | Value | Description                  |\r\n| ------ | ----- | ---------------------------- |\r\n| header |       | API key is a header value    |\r\n| query  |       | API key is a query parameter |\r\n| cookie |       | API key is found in a cookie |\n\n### `AuthType` {#TypeSpec.Http.AuthType}\n\nAuthentication type\r\n\r\n```typespec\r\nenum TypeSpec.Http.AuthType\r\n```\r\n\r\n| Name          | Value | Description    |\r\n| ------------- | ----- | -------------- |\r\n| http          |       | HTTP           |\r\n| apiKey        |       | API key        |\r\n| oauth2        |       | OAuth2         |\r\n| openIdConnect |       | OpenID connect |\r\n| noAuth        |       | Empty auth     |\n\n### `OAuth2FlowType` {#TypeSpec.Http.OAuth2FlowType}\n\nDescribes the OAuth2 flow type\r\n\r\n```typespec\r\nenum TypeSpec.Http.OAuth2FlowType\r\n```\r\n\r\n| Name              | Value | Description             |\r\n| ----------------- | ----- | ----------------------- |\r\n| authorizationCode |       | authorization code flow |\r\n| implicit          |       | implicit flow           |\r\n| password          |       | password flow           |\r\n| clientCredentials |       | client credential flow  |\n\n### `LinkHeader` {#TypeSpec.Http.LinkHeader}\n\n```typespec\r\nscalar TypeSpec.Http.LinkHeader\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n", "latency": 12.540308237075806, "response_length": 692}
{"query": "title: Is path case sensitive?\n\nquestion: I have these swaggers paths:\n```\n\"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ElasticSan/elasticSans/{elasticSanName}/volumeGroups\"\n\"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ElasticSan/elasticSans/{elasticSanName}/volumegroups/{volumeGroupName}\"\n```\nThe second path represents a resource like\n```\nmodel VolumeGroup\nis Azure.ResourceManager.ProxyResource<VolumeGroupProperties> {\n...ResourceNameParameter<\nResource = VolumeGroup,\nKeyName = \"volumeGroupName\",\nSegmentName = \"volumegroups\",\nNamePattern = \"^[A-Za-z0-9]+((-|_)[a-z0-9A-Z]+)*$\"\n>;\n```\nPay attention to segment is volumegroups.\nThe first path is a list operation to this resource. However, its last segment is volumeGroups. If I use ArmResourceListByParent<VolumeGroup> for the first path it produces volumegroups. Can I use it?", "ground_truth": "static segments in ARM urls are meant to be case-insensitive.  In this case, the swagger is incorrect, since this is clearly meant to be the ARM type name.  You should use the correct type name in both cases.\nIf the url is /subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/..., is that the same as `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/...? The \"G\" in resourceGroups has different cases.\nThese are case insensitive,  we should favor the camel case here, there is no need to match the exact casing of these in existing swagger", "response": "In TypeSpec, paths are case-sensitive. This means that the segment names in your Swagger paths must match exactly, including capitalization. If the `ArmResourceListByParent<VolumeGroup>` operation produces `volumegroups` as the segment name, it will not match the `volumeGroups` segment in your first path. To resolve this, you should ensure that the segment name in your TypeSpec definition matches the case used in your Swagger path. Update the `SegmentName` parameter in your resource definition to `volumeGroups` to align with the Swagger path.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-operations.md\n- document_title: ARM Resource Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations\n- document_content: # howtos#arm#resource-operations.md\n\n# ARM Resource Operations\n\n## Recommended and Required Operations\n\n### TrackedResource\n\n| Operation             | Recommended | Required | TypeSpec Representation                                          |\r\n| --------------------- | ----------- | -------- | ---------------------------------------------------------------- |\r\n| GET                   | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                              |\r\n| CreateOrUpdate (PUT)  | Yes         | Yes      | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`    |\r\n| Tags Update (PATCH)   | No          | Yes\\*    | `update is ArmResourceTagsPatchSync<Resource>;`                  |\r\n| Full Update (PATCH)   | Yes         | No\\*     | `update is ArmCustomPatchSync<Resource, PatchRequest>;`          |\r\n| Delete                | Yes         | Yes      | `delete is ArmResourceDeleteSync<Resource>;`                     |\r\n| List by ResourceGroup | Yes         | Yes      | `listByResourceGroup is ArmResourceListByParent<Resource>;`      |\r\n| List by Subscription  | Yes         | Yes      | `listBySubscription is ArmResourceListBySubscription<Resource>;` |\r\n\r\n\\* Arm requires that, at minimum, a TrackedResource can update Tags. A Full PATCH of all updateable resource properties is preferred.\n\n### Proxy Resource\n\n| Operation            | Recommended | Required | TypeSpec Representation                                       |\r\n| -------------------- | ----------- | -------- | ------------------------------------------------------------- |\r\n| GET                  | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                           |\r\n| CreateOrUpdate (PUT) | Yes         | No\\*     | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;` |\r\n| Update (PATCH)       | Yes         | No       | `update is ArmCustomPatchSync<Resource, PatchRequest>;`       |\r\n| Delete               | Yes         | No\\*     | `delete is ArmResourceDeleteSync<Resource>;`                  |\r\n| List by Parent       | Yes         | Yes      | `listByParent is ArmResourceListByParent<Resource>;`          |\r\n\r\n\\* Note that, if a resource implements Create, it is highly recommended that it implement delete as well, and vice-versa.\n\n## TypeSpec Operation Templates and Interface Templates\n\nTypeSpec provide operation templates that describe the request and response of standard resource operations. A description of the options available for each resource template, and how to choose which one is described in the sections below.\n\n### Synchronous and Asynchronous APIs\n\nCreateOrUpdate (PUT), Update (Patch), Delete, and Action (POST) operations over a resource may\n\n### Determining Which Resource Properties Appear in Lifecycle Operations\n\nBy default, any property that occurs in your resource model will also appear in the response to GET, PUT, PATCH, and LIST operations, and in the request for PUT and PATCH operations. This does not work for all properties. Some properties are calculated by the service and cannot be directly set by PUT or PATCH (provisioningState, modification date, etc.). Some properties can only be set when creating a resource, but always appear in responses (e.g. 'location'). Some properties can only be set when updating the resource, and appear in responses. Some properties (rarely) may be settable when updating the resource via PUT or PATCH. To allow using a common resource model, but applying these `views` of resources to determine how the resource appear in request and responses, TypeSpec provides the visibility framework. You can see a complete representation of available visibilities in the table [on Property Visibility and Other Constraints](./resource-type.md#property-visibility-and-other-constraints). The sections below outline some common scenarios for designing properties with your operations in mind.\r\n\r\n#### Properties That Are Never Directly Set by the User\r\n\r\nIt is common to have properties that are calculated by the service or otherwise not directly set by the user, examples include timestamps, dates, values that are only set by specific actions (on/off, enabled/disabled, provisioningState). You want to make sure that these properties are marked so that they will appear in responses and not requests. this is done using the `@visibility(Lifecycle.Read)` decorator instance:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Read)\r\nprovisioningState: ProvisioningState;\r\n```\n\n### Resource Get Operations\n\nGet is the operation to retrieve a single resource TypeSpec provides a single operation template for GET:\r\n\r\n```typespec\r\nop get is ArmResourceRead<MyResource>;\r\n```\r\n\r\n- **get**: The name of the operation passed on to clients.\r\n- **Resource**: A reference to your resource type.\n\n### Resource CreateOrUpdate Operations (PUT)\n\nThe CreateOrUpdate operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\n- Simple resources may have synchronous PUT operations. If a resource may need to perform additional checks, creation of other dependent resources, or the like, it is best to use an Asynchronous API.\r\n- Asynchronous operations for PUT occur when the RP needs to perform additional validaton actions, create other resources, or perform other tasks as part of resource creation or update that can cause the operation to take longer than the length of a single request/response.\r\n\r\n| Operation        | TypeSpec                                                          |\r\n| ---------------- | ----------------------------------------------------------------- |\r\n| Synchronous PUT  | `createOrUpdate is ArmResourceCreateOrReplaceSync<ResourceType>`  |\r\n| Asynchronous PUT | `createOrUpdate is ArmResourceCreateOrReplaceAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `createOrUpdate` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being created (or updated)\n\n### Resource Update Operations (PATCH)\n\nPATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\r\nThe ArmCustomPatch\\* templates take the resource type and your custom PATCH request type as parameters.\n\nARM Requires that all `Tracked` resources implement PATCH for ARM tags, which are contained in the envelope of every `TrackedResource`. ARM recommends that you also allow PATCH of other envelope properties and resource-specific properties. Unless marked with a specific visibility, any property in your rp-specific properties will be automatically included in the PATCH schema.\r\n\r\nTypeSpec Provides both Synchronous and Asynchronous PATCH Operations, and allows you to specify a PATCH for Resource tags only, a PATCH for all updateable properties, or a custom patch. Generally, you should choose the patch for all updateable properties, unless you have a very good reason for choosing another PATCH operation.\r\n\r\n| Operation Description      | TypeSpec                                                                                                                                   |\r\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Sync TagsOnly PATCH        | `update is ArmTagsPatchSync<ResourceType>`                                                                                                 |\r\n| Async TagsOnly PATCH       | `update is ArmTagsPatchAsync<ResourceType>`                                                                                                |\r\n| Sync All Properties PATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\n\n### Resource Delete Operations (DELETE)\n\nThe Delete operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\nSimple resources may have synchronous DELETE operations. If a resource needs to clean up other resources or do other validations as part of delete, the delete operation may need to be asynchronous.\r\n\r\n| Operation           | TypeSpec                                                  |\r\n| ------------------- | --------------------------------------------------------- |\r\n| Synchronous Delete  | `delete is ArmResourceDeleteSync<ResourceType>`           |\r\n| Asynchronous Delete | `delete is ArmResourceDeleteWithoutOkAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `delete` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being deleted.\n\n### Resource List Operations (GET)\n\nArm Resource list operations return a list of Tracked or Proxy Resources at a particular scope.\r\n\r\n- All resources _should_ include a list operation at its immediate parent scope\r\n  - For **Tenant Resources**, this is at the tenant scope\r\n  - For **Extension Resources**, this is at the scope of resources they are extending\r\n  - For **Tracked Resources**, this is at the resource group scope.\r\n  - For **Child Resources**, this is at the scope of the resource parent.\r\n- Tracked resources _must_ include a list operation at the Subscription level.\r\n\r\n| Operation          | TypeSpec                                                            |\r\n| ------------------ | ------------------------------------------------------------------- |\r\n| ListByParent       | `listByWidget is ArmResourceListByParent<ResourceType>`             |\r\n| ListBySubscription | `listBySubscription is ArmResourceListBySubscription<ResourceType>` |\n\n### Resource Actions (POST)\n\nCustom actions define any operations over resources outside the simple CRUDL (Create< Read, Update, Delete, List) or lifecycle operations described above. Any operation that returns data that is not made up of resources, performs a prescriptive state change on the resource (cycling power, upgrading, etc.), or any operation that does not fit into the operations described above should be modelled as a _resource action_. Examples of resource actions include:\r\n\r\n- Operations that manage credentials associated with a resource\r\n- Operations that calculate statistics about resources\r\n- Operations that make specific state changes to resources (power cycle, upgrade, etc.)\r\n\r\n#### Actions that take input and output\r\n\r\nOperations that manage credentials are a good example fo this category. TypeSpec defines synchronous and asynchronous templates for actions that consume and produce information.\r\n\r\n| Operation                    | TypeSpec                                                                       |\r\n| ---------------------------- | ------------------------------------------------------------------------------ |\r\n| Synchronous Resource Action  | `updateCredentials is ArmResourceActionSync<ResourceType, Request, Response>`  |\r\n| Asynchronous Resource Action | `updateCredentials is ArmResourceActionAsync<ResourceType, Request, Response>` |\r\n\r\nParameters to the template are the ResourceType, the model for the operation Request body, and the model for the operation Response body.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- |\n\nbody.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- | ------------------------------------------------------------------------------------- |\r\n| Synchronous NoContent Action  | `updateCredentials is ArmResourceActionNoContentSync<ResourceType, Request>`          |\r\n| Asynchronous NoContent Action | `updateCredentials is ArmResourceActionNoResponseContentAsync<ResourceType, Request>` |\r\n\r\nParameters to the template are the ResourceType and the model for the operation Request body.\n\n### Actions that take no input but produce output (data retrieval actions)\n\nSome operations return data or paged lists of data. TypeSpec does not yet provide templates for these kinds of actions, but here are two templates that you could reuse in your own specification, described in the next section of the document:\r\n\r\n- [Synchronous Resource List Actions](#synchronous-list-action)\r\n- [Asynchronous List Action](#asynchronous-list-action)\n\n### Check Name Operations\n\nSome services provide operations to check name availability, either location-specific (locally) or globally, especially if a resource name must be globally unique (such as when an exposed endpoint uses the resource name in the url).\r\n\r\n| Operation                      | TypeSpec                                                                                             |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------- |\r\n| Global Name Availability Check | `checkGlobalName is checkGlobalNameAvailability<TRequest, TResponse, TAdditionalParams>`             |\r\n| Local Name Availability Check  | `checkLocalName is checkLocalNameAvailability<TRequest, TResponse, TAdditionalParams>`               |\r\n| Custom Name Availability Check | `customNameCheck is checkNameAvailability<TScopeParameters, TRequest, TResponse, TAdditionalParams>` |\r\n\r\n`checkGlobalNameAvailability` and `checkLocalNameAvailability` have default values that allow them to be used without specifying any template parameters. `checkNameAvailability` requires the `TScopeParameters` template parameter, which describes the parameters which define the scope of the name check request. For reference, the following table shows the `TScopeParameters` for the standard templates:\r\n\r\n| Operation                      | Scope Parameters                                                       |\r\n| ------------------------------ | ---------------------------------------------------------------------- |\r\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\r\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\n\n## Writing Custom Operations\n\nTypeSpec operation templates provide a simple mechanism for producing the most common operation patterns in ARM, using best practices and conforming to ARM RPC guidelines. However, sometimes a service has special requirements for operations that fall outside these boundaries. The `Azure.ResourceManager.Foundations` namespace provides lower level building blocks that can be used to produce operations and operation templates.\r\n\r\nThe building blocks are described in the sections below:\n\n### ARM Response Types\n\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\r\n\r\n| Model                               | Code | Description                                   |\r\n| ----------------------------------- | ---- | --------------------------------------------- |\r\n| `ArmResponse<T>`                    | 200  | Base Arm 200 response.                        |\r\n| `ArmResourceUpdatedResponse<T>`     | 200  | Resource updated (PUT) response.              |\r\n| `ArmResourceCreatedResponse<T>`     | 201  | Resource created response for an lro.         |\r\n| `ArmResourceCreatedSyncResponse<T>` | 201  | Resource created synchronously.               |\r\n| `ArmAcceptedResponse`               | 202  | Base Arm Accepted response.                   |\r\n| `ArmNoContentResponse`              | 204  | Base Arm No Content response.                 |\r\n| `ArmDeletedResponse`                | 200  | Resource deleted response.                    |\r\n| `ArmDeleteAcceptedResponse`         | 202  | Resource deletion in progress response.       |\r\n| `ResourceListResult<T>`             | 200  | Return a list of resource with ARM pagination |\r\n| `ErrorResponse`                     | x    | Error response                                |\n\n### Common Operation Parameters\n\nThere are a number of model types which specify common parameters which are used in resource type operations:\r\n\r\n| Model                           | In           | Description                                                 |\r\n| ------------------------------- | ------------ | ----------------------------------------------------------- |\r\n| `ApiVersionParameter`           | query        | api-version parameter                                       |\r\n| `SubscriptionIdParameter`       | path         | Subscription ID path parameter                              |\r\n| `ResourceGroupNameParameter`    | path         | Resource Group Name path parameter                          |\r\n| `ResourceInstanceParameters<T>` | path & query | Identity parameters for a resource, with api-version        |\r\n| `ResourceParentParameters<T>`   | path & query | Identity Parameters for listing by parent, with api-version |\r\n| `ResourceUriParameter`          | path         | Resource uri path parameter for Extension resources         |\r\n| `OperationIdParameter`          | path         | Operation Id path parameter                                 |\n\n### Synchronous List Action\n\nHere is a sample template for resource list actions that return synchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionSync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionSync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n\n### Asynchronous List Action\n\nHere is a sample template for resource list actions that return asynchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionAsync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ArmAcceptedResponse | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionAsync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-resource-manager#step03.md\n- document_title: 4. Defining Child Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step03\n- document_content: # getstarted#azure-resource-manager#step03.md\n\n# 4. Defining Child Resource Types\n\nYou can create parent/child relationships between resource types by using the `@parentResource` decorator when defining a resource type.\r\n\r\nFor example, here's how you could create a new `AddressResource` resource under the `User` defined above:\r\n\r\n```typespec\r\n/** An address resource belonging to a user resource */\r\n@parentResource(User)\r\nmodel AddressResource is ProxyResource<AddressResourceProperties> {\r\n  @key(\"addressName\")\r\n  @segment(\"addresses\")\r\n  name: string;\r\n}\r\n\r\n/** The properties of AddressResource */\r\nmodel AddressResourceProperties {\r\n  /** The street address */\r\n  streetAddress: string;\r\n\r\n  /** The city of the address */\r\n  city: string;\r\n\r\n  /** The state of the address */\r\n  state: string;\r\n\r\n  /** The zip code of the address */\r\n  zip: int32;\r\n}\r\n\r\n@armResourceOperations\r\ninterface Addresses {\r\n  get is ArmResourceRead<AddressResource>;\r\n  create is ArmResourceCreateOrReplaceSync<AddressResource>;\r\n  update is ArmCustomPatchSync<\r\n    AddressResource,\r\n    Azure.ResourceManager.Foundations.ResourceUpdateModel<\r\n      AddressResource,\r\n      AddressResourceProperties\r\n    >\r\n  >;\r\n  delete is ArmResourceDeleteSync<AddressResource>;\r\n  listByParent is ArmResourceListByParent<AddressResource>;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-resource-manager#reference#interfaces.md\n- document_title: Interfaces and Operations\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/interfaces\n- document_content: # libraries#azure-resource-manager#reference#interfaces.md\n\n# Interfaces and Operations\n\n## Azure.ResourceManager\n\n### `ExtensionResourceCollectionOperations` {#Azure.ResourceManager.ExtensionResourceCollectionOperations}\n\nA composite interface for resource collections that include a paginated list operation.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ExtensionResourceCollectionOperations<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                                    |\r\n| -------- | ---------------------------------------------- |\r\n| Resource | The ArmResource that provides these operations |\r\n\r\n#### `ExtensionResourceCollectionOperations.listByParent` {#Azure.ResourceManager.ExtensionResourceCollectionOperations.listByParent}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceCollectionOperations.listByParent(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ExtensionResourceInstanceOperations` {#Azure.ResourceManager.ExtensionResourceInstanceOperations}\n\nA composite interface for resources that includes CRUD operations.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ExtensionResourceInstanceOperations<Resource, Properties>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description                                    |\r\n| ---------- | ---------------------------------------------- |\r\n| Resource   | The ArmResource that provides these operations |\r\n| Properties | RP-specific property bag for the resource      |\r\n\r\n#### `ExtensionResourceInstanceOperations.get` {#Azure.ResourceManager.ExtensionResourceInstanceOperations.get}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceInstanceOperations.get(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ExtensionResourceInstanceOperations.createOrUpdate` {#Azure.ResourceManager.ExtensionResourceInstanceOperations.createOrUpdate}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceInstanceOperations.createOrUpdate(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Azure.ResourceManager.ArmResourceUpdatedResponse<Resource> | Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ExtensionResourceInstanceOperations.update` {#Azure.ResourceManager.ExtensionResourceInstanceOperations.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceInstanceOperations.update(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ExtensionResourceInstanceOperations.delete` {#Azure.ResourceManager.ExtensionResourceInstanceOperations.delete}\r\n\r\n```typespec\n\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceInstanceOperations.update(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ExtensionResourceInstanceOperations.delete` {#Azure.ResourceManager.ExtensionResourceInstanceOperations.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceInstanceOperations.delete(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse | Azure.ResourceManager.ArmDeleteAcceptedLroResponse<Azure.ResourceManager.{ location: string, retryAfter: int32 }> | Azure.ResourceManager.ArmDeletedNoContentResponse | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ExtensionResourceOperations` {#Azure.ResourceManager.ExtensionResourceOperations}\n\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceOperations.update(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ExtensionResourceOperations.delete` {#Azure.ResourceManager.ExtensionResourceOperations.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceOperations.delete(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse | Azure.ResourceManager.ArmDeleteAcceptedLroResponse<Azure.ResourceManager.{ location: string, retryAfter: int32 }> | Azure.ResourceManager.ArmDeletedNoContentResponse | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ExtensionResourceOperations.listByParent` {#Azure.ResourceManager.ExtensionResourceOperations.listByParent}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceOperations.listByParent(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\nA composite interface for resources that include CRUD and list operations.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ExtensionResourceOperations<Resource, Properties>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description                                    |\r\n| ---------- | ---------------------------------------------- |\r\n| Resource   | The ArmResource that provides these operations |\r\n| Properties | RP-specific property bag for the resource      |\r\n\r\n#### `ExtensionResourceOperations.get` {#Azure.ResourceManager.ExtensionResourceOperations.get}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceOperations.get(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ExtensionResourceOperations.createOrUpdate` {#Azure.ResourceManager.ExtensionResourceOperations.createOrUpdate}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceOperations.createOrUpdate(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Azure.ResourceManager.ArmResourceUpdatedResponse<Resource> | Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ExtensionResourceOperations.update` {#Azure.ResourceManager.ExtensionResourceOperations.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ExtensionResourceOperations.update(apiVersion: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ExtensionResourceOperations.delete` {#Azure.ResourceManager.ExtensionResourceOperations.delete}\r\n\r\n```typespec\n\n### `Operations` {#Azure.ResourceManager.Operations}\n\nThis is the interface that implements the standard Azure Resource Manager operation that returns\r\nall supported RP operations. You should have exactly one declaration for each\r\nAzure Resource Manager service. It implements\r\nGET \"/providers/Microsoft.ContosoProviderHub/operations\"\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.Operations<>\r\n```\r\n\r\n#### `Operations.list` {#Azure.ResourceManager.Operations.list}\r\n\r\nList the operations for the provider\r\n\r\n```typespec\r\nop Azure.ResourceManager.Operations.list(apiVersion: string, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.CommonTypes.OperationListResult> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ProxyResourceOperations` {#Azure.ResourceManager.ProxyResourceOperations}\n\n| Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ProxyResourceOperations.delete` {#Azure.ResourceManager.ProxyResourceOperations.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ProxyResourceOperations.delete(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse | Azure.ResourceManager.ArmDeleteAcceptedLroResponse<Azure.ResourceManager.{ location: string, retryAfter: int32 }> | Azure.ResourceManager.ArmDeletedNoContentResponse | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ProxyResourceOperations.listByParent` {#Azure.ResourceManager.ProxyResourceOperations.listByParent}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ProxyResourceOperations.listByParent(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\nA composite interface for Proxy resources that include `ResourceInstanceOperations<Resource, Properties>`\r\nand `ResourceListByParent<Resource>`. It includes: `GET`, `PUT`, `PATCH`, `DELETE`, ListByParent operations.\r\n\r\nThe actual route depends on the resource model but would have started with\r\n`/subscriptions/{id}/resourcegroups/{rg}/providers/Microsoft.XXX/...`\r\n\r\nThis is the most common API pattern for Proxy Resources to use.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ProxyResourceOperations<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | the ArmResource that provides these operations   |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ProxyResourceOperations.get` {#Azure.ResourceManager.ProxyResourceOperations.get}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ProxyResourceOperations.get(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ProxyResourceOperations.createOrUpdate` {#Azure.ResourceManager.ProxyResourceOperations.createOrUpdate}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ProxyResourceOperations.createOrUpdate(provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Azure.ResourceManager.ArmResourceUpdatedResponse<Resource> | Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ProxyResourceOperations.delete` {#Azure.ResourceManager.ProxyResourceOperations.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ProxyResourceOperations.delete(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse | Azure.ResourceManager.ArmDeleteAcceptedLroResponse<Azure.ResourceManager.{ location: string, retryAfter: int32 }> |\n\n### `ResourceCollectionOperations` {#Azure.ResourceManager.ResourceCollectionOperations}\n\nA composite interface for resource collections.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceCollectionOperations<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | The ArmResource that provides these operations   |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ResourceCollectionOperations.listByParent` {#Azure.ResourceManager.ResourceCollectionOperations.listByParent}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceCollectionOperations.listByParent(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceCollectionOperations.listBySubscription` {#Azure.ResourceManager.ResourceCollectionOperations.listBySubscription}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceCollectionOperations.listBySubscription(apiVersion: string, subscriptionId: Azure.Core.uuid, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ResourceCreateAsync` {#Azure.ResourceManager.ResourceCreateAsync}\n\nA composite interface for resources that include a long-running create or update operation.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceCreateAsync<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | The ArmResource that provides these operations   |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ResourceCreateAsync.createOrUpdate` {#Azure.ResourceManager.ResourceCreateAsync.createOrUpdate}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceCreateAsync.createOrUpdate(provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Azure.ResourceManager.ArmResourceUpdatedResponse<Resource> | Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ResourceCreateSync` {#Azure.ResourceManager.ResourceCreateSync}\n\nA composite interface for resources that include a synchronous create or update operation.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceCreateSync<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | The ArmResource that provides these operations   |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ResourceCreateSync.createOrUpdate` {#Azure.ResourceManager.ResourceCreateSync.createOrUpdate}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceCreateSync.createOrUpdate(provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Azure.ResourceManager.ArmResourceUpdatedResponse<Resource> | Azure.ResourceManager.ArmResourceCreatedSyncResponse<Resource> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ResourceDeleteAsync` {#Azure.ResourceManager.ResourceDeleteAsync}\n\n:::caution\r\n**Deprecated**: This should be deprecated in a future release\r\n:::\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceDeleteAsync<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | The ArmResource that provides these operations   |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ResourceDeleteAsync.delete` {#Azure.ResourceManager.ResourceDeleteAsync.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceDeleteAsync.delete(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse | Azure.ResourceManager.ArmDeleteAcceptedLroResponse<Azure.ResourceManager.{ location: string, retryAfter: int32 }> | Azure.ResourceManager.ArmDeletedNoContentResponse | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ResourceDeleteSync` {#Azure.ResourceManager.ResourceDeleteSync}\n\nA composite interface for resources that include a synchronous delete operation.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceDeleteSync<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | The ArmResource that provides these operations   |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ResourceDeleteSync.delete` {#Azure.ResourceManager.ResourceDeleteSync.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceDeleteSync.delete(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse | Azure.ResourceManager.ArmDeletedNoContentResponse | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ResourceDeleteWithoutOkAsync` {#Azure.ResourceManager.ResourceDeleteWithoutOkAsync}\n\n```typespec\r\ninterface Azure.ResourceManager.ResourceDeleteWithoutOkAsync<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | The ArmResource that provides these operations   |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ResourceDeleteWithoutOkAsync.delete` {#Azure.ResourceManager.ResourceDeleteWithoutOkAsync.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceDeleteWithoutOkAsync.delete(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeleteAcceptedLroResponse<Azure.ResourceManager.{ location: string, retryAfter: int32 }> | Azure.ResourceManager.ArmDeletedNoContentResponse | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ResourceInstanceOperations` {#Azure.ResourceManager.ResourceInstanceOperations}\n\n{#Azure.ResourceManager.ResourceInstanceOperations.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceInstanceOperations.update(provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceInstanceOperations.delete` {#Azure.ResourceManager.ResourceInstanceOperations.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceInstanceOperations.delete(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse | Azure.ResourceManager.ArmDeleteAcceptedLroResponse<Azure.ResourceManager.{ location: string, retryAfter: int32 }> | Azure.ResourceManager.ArmDeletedNoContentResponse | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\nA composite interface for resources that have CRUD operations.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceInstanceOperations<Resource, Properties, BaseParameters, PatchModel>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | The ArmResource that provides these operations   |\r\n| Properties     | RP-specific property bag for the resource        |\r\n| BaseParameters | The http parameters that are part of the request |\r\n| PatchModel     | The model used for PATCH operations              |\r\n\r\n#### `ResourceInstanceOperations.get` {#Azure.ResourceManager.ResourceInstanceOperations.get}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceInstanceOperations.get(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceInstanceOperations.createOrUpdate` {#Azure.ResourceManager.ResourceInstanceOperations.createOrUpdate}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceInstanceOperations.createOrUpdate(provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Azure.ResourceManager.ArmResourceUpdatedResponse<Resource> | Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceInstanceOperations.update` {#Azure.ResourceManager.ResourceInstanceOperations.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceInstanceOperations.update(provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceInstanceOperations.delete` {#Azure.ResourceManager.ResourceInstanceOperations.delete}\r\n\r\n```typespec\n\n### `ResourceListByParent` {#Azure.ResourceManager.ResourceListByParent}\n\nAn interface for resources which can be listed by parent.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceListByParent<Resource, BaseParameters, ParentName, ParentFriendlyName>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name               | Description                                      |\r\n| ------------------ | ------------------------------------------------ |\r\n| Resource           | The ArmResource that provides these operations   |\r\n| BaseParameters     | The http parameters that are part of the request |\r\n| ParentName         | The name of the parent resource                  |\r\n| ParentFriendlyName | The friendly name of the parent resource         |\r\n\r\n#### `ResourceListByParent.listByParent` {#Azure.ResourceManager.ResourceListByParent.listByParent}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceListByParent.listByParent(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ResourceListBySubscription` {#Azure.ResourceManager.ResourceListBySubscription}\n\nAn interface for resources with can be listed by subscription.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceListBySubscription<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                                    |\r\n| -------- | ---------------------------------------------- |\r\n| Resource | The ArmResource that provides these operations |\r\n\r\n#### `ResourceListBySubscription.listBySubscription` {#Azure.ResourceManager.ResourceListBySubscription.listBySubscription}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceListBySubscription.listBySubscription(apiVersion: string, subscriptionId: Azure.Core.uuid, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ResourceOperations` {#Azure.ResourceManager.ResourceOperations}\n\n\"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceOperations.delete` {#Azure.ResourceManager.ResourceOperations.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceOperations.delete(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse | Azure.ResourceManager.ArmDeleteAcceptedLroResponse<Azure.ResourceManager.{ location: string, retryAfter: int32 }> | Azure.ResourceManager.ArmDeletedNoContentResponse | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceOperations.listByParent` {#Azure.ResourceManager.ResourceOperations.listByParent}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceOperations.listByParent(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceOperations.listBySubscription` {#Azure.ResourceManager.ResourceOperations.listBySubscription}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceOperations.listBySubscription(apiVersion: string, subscriptionId: Azure.Core.uuid, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n:::caution\r\n**Deprecated**: Use Azure.ResourceManager.TrackedResourceOperations instead\r\n:::\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceOperations<Resource, Properties, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | the ArmResource that provides these operations   |\r\n| Properties     | RP-specific property bag for the resource        |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ResourceOperations.get` {#Azure.ResourceManager.ResourceOperations.get}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceOperations.get(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceOperations.createOrUpdate` {#Azure.ResourceManager.ResourceOperations.createOrUpdate}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceOperations.createOrUpdate(provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Azure.ResourceManager.ArmResourceUpdatedResponse<Resource> | Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceOperations.update` {#Azure.ResourceManager.ResourceOperations.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceOperations.update(provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `ResourceOperations.delete` {#Azure.ResourceManager.ResourceOperations.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceOperations.delete(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse |\n\n### `ResourceRead` {#Azure.ResourceManager.ResourceRead}\n\nA composite interface for resources that include a GET operation.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceRead<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | The ArmResource that provides these operations   |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ResourceRead.get` {#Azure.ResourceManager.ResourceRead.get}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceRead.get(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ResourceUpdateAsync` {#Azure.ResourceManager.ResourceUpdateAsync}\n\n```typespec\r\ninterface Azure.ResourceManager.ResourceUpdateAsync<Resource, Properties, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | The ArmResource that provides these operations   |\r\n| Properties     | RP-specific property bag for the resource        |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ResourceUpdateAsync.update` {#Azure.ResourceManager.ResourceUpdateAsync.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceUpdateAsync.update(provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.ArmAcceptedLroResponse<\"Resource update request accepted.\", Azure.ResourceManager.{ location: string, retryAfter: int32 }> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ResourceUpdateSync` {#Azure.ResourceManager.ResourceUpdateSync}\n\nA composite interface for resources that include a synchronous update operation.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.ResourceUpdateSync<Resource, Properties, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | The ArmResource that provides these operations   |\r\n| Properties     | RP-specific property bag for the resource        |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `ResourceUpdateSync.update` {#Azure.ResourceManager.ResourceUpdateSync.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.ResourceUpdateSync.update(provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `TenantResourceOperations` {#Azure.ResourceManager.TenantResourceOperations}\n\nLroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TenantResourceOperations.update` {#Azure.ResourceManager.TenantResourceOperations.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TenantResourceOperations.update(apiVersion: string, provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TenantResourceOperations.delete` {#Azure.ResourceManager.TenantResourceOperations.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TenantResourceOperations.delete(apiVersion: string, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse | Azure.ResourceManager.ArmDeleteAcceptedLroResponse<Azure.ResourceManager.{ location: string, retryAfter: int32 }> | Azure.ResourceManager.ArmDeletedNoContentResponse | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TenantResourceOperations.listByParent` {#Azure.ResourceManager.TenantResourceOperations.listByParent}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TenantResourceOperations.listByParent(apiVersion: string, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\nA composite interface for Tenant resources that include `ResourceInstanceOperations<Resource, Properties>`\r\nand `ResourceListByParent<Resource>`. It includes: `GET`, `PUT`, `PATCH`, `DELETE`, ListByParent operations.\r\n\r\nThe routes are always start at root level:\r\n`/providers/Microsoft.XXX/...`\r\n\r\nThis is the most common API pattern for Tenant Resources to use.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.TenantResourceOperations<Resource, Properties>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description                                    |\r\n| ---------- | ---------------------------------------------- |\r\n| Resource   | the ArmResource that provides these operations |\r\n| Properties | RP-specific property bag for the resource      |\r\n\r\n#### `TenantResourceOperations.get` {#Azure.ResourceManager.TenantResourceOperations.get}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TenantResourceOperations.get(apiVersion: string, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TenantResourceOperations.createOrUpdate` {#Azure.ResourceManager.TenantResourceOperations.createOrUpdate}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TenantResourceOperations.createOrUpdate(apiVersion: string, provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Azure.ResourceManager.ArmResourceUpdatedResponse<Resource> | Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TenantResourceOperations.update` {#Azure.ResourceManager.TenantResourceOperations.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TenantResourceOperations.update(apiVersion: string, provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `TrackedResourceOperations` {#Azure.ResourceManager.TrackedResourceOperations}\n\nA composite interface for resources that include `ResourceInstanceOperations<Resource, Properties>`\r\nand `ResourceCollectionOperations<Resource>`. It includes: `GET`, `PUT`, `PATCH`, `DELETE`, ListByParent,\r\nListBySubscription operations. The actual route depends on the resource model.\r\nThis is the most common API pattern for Tracked Resources to use.\r\n\r\n```typespec\r\ninterface Azure.ResourceManager.TrackedResourceOperations<Resource, Properties, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                      |\r\n| -------------- | ------------------------------------------------ |\r\n| Resource       | the ArmResource that provides these operations   |\r\n| Properties     | RP-specific property bag for the resource        |\r\n| BaseParameters | The http parameters that are part of the request |\r\n\r\n#### `TrackedResourceOperations.get` {#Azure.ResourceManager.TrackedResourceOperations.get}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TrackedResourceOperations.get(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TrackedResourceOperations.createOrUpdate` {#Azure.ResourceManager.TrackedResourceOperations.createOrUpdate}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TrackedResourceOperations.createOrUpdate(provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Azure.ResourceManager.ArmResourceUpdatedResponse<Resource> | Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TrackedResourceOperations.update` {#Azure.ResourceManager.TrackedResourceOperations.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TrackedResourceOperations.update(provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> |\n\n| Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TrackedResourceOperations.update` {#Azure.ResourceManager.TrackedResourceOperations.update}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TrackedResourceOperations.update(provider: \"Microsoft.ThisWillBeReplaced\", properties: Azure.ResourceManager.Foundations.ResourceUpdateModel<Resource, Properties>): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TrackedResourceOperations.delete` {#Azure.ResourceManager.TrackedResourceOperations.delete}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TrackedResourceOperations.delete(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmDeletedResponse | Azure.ResourceManager.ArmDeleteAcceptedLroResponse<Azure.ResourceManager.{ location: string, retryAfter: int32 }> | Azure.ResourceManager.ArmDeletedNoContentResponse | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TrackedResourceOperations.listByParent` {#Azure.ResourceManager.TrackedResourceOperations.listByParent}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TrackedResourceOperations.listByParent(provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### `TrackedResourceOperations.listBySubscription` {#Azure.ResourceManager.TrackedResourceOperations.listBySubscription}\r\n\r\n```typespec\r\nop Azure.ResourceManager.TrackedResourceOperations.listBySubscription(apiVersion: string, subscriptionId: Azure.Core.uuid, provider: \"Microsoft.ThisWillBeReplaced\"): Azure.ResourceManager.ArmResponse<Azure.ResourceManager.ResourceListResult<Resource>> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\n\n### `ArmCustomPatchAsync` {#Azure.ResourceManager.ArmCustomPatchAsync}\n\nA long-running resource update using a custom PATCH payload (Asynchronous)\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmCustomPatchAsync(provider: \"Microsoft.ThisWillBeReplaced\", properties: PatchModel): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                                   |\r\n| -------------- | ----------------------------------------------------------------------------- |\r\n| Resource       | the resource being patched                                                    |\r\n| PatchModel     | The input model for the PATCH request                                         |\r\n| BaseParameters | Optional. Allows overriding the operation parameters                          |\r\n| LroHeaders     | Optional. Allows overriding the lro headers returned in the Accepted response |\r\n| Parameters     | Optional. Additional parameters after the path parameters                     |\r\n| Response       | Optional. The success response for the patch operation                        |\r\n| Error          | Optional. The error response, if non-standard.                                |\n\n### `ArmCustomPatchSync` {#Azure.ResourceManager.ArmCustomPatchSync}\n\nA resource update using a custom PATCH payload (synchronous)\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmCustomPatchSync(provider: \"Microsoft.ThisWillBeReplaced\", properties: PatchModel): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                               |\r\n| -------------- | --------------------------------------------------------- |\r\n| Resource       | the resource being patched                                |\r\n| PatchModel     | The input model for the PATCH request                     |\r\n| BaseParameters | Optional. Allows overriding the operation parameters      |\r\n| Parameters     | Optional. Additional parameters after the path parameters |\r\n| Response       | Optional. The success response for the patch operation    |\r\n| Error          | Optional. The error response, if non-standard.            |\n\n### `ArmListBySubscription` {#Azure.ResourceManager.ArmListBySubscription}\n\nA resource list operation, at the subscription scope\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmListBySubscription(apiVersion: string, subscriptionId: Azure.Core.uuid, provider: \"Microsoft.ThisWillBeReplaced\"): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description                                               |\r\n| ---------- | --------------------------------------------------------- |\r\n| Resource   | the resource being patched                                |\r\n| Parameters | Optional. Additional parameters after the path parameters |\r\n| Response   | Optional. The success response for the list operation     |\r\n| Error      | Optional. The error response, if non-standard.            |\n\n### `ArmProviderActionAsync` {#Azure.ResourceManager.ArmProviderActionAsync}\n\n```typespec\r\nop Azure.ResourceManager.ArmProviderActionAsync(apiVersion: string, subscriptionId: Azure.Core.uuid, location: string, resourceGroupName: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\", body: Request): Azure.ResourceManager.ArmAcceptedLroResponse<Description, LroHeaders> | Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description                                                                   |\r\n| ---------- | ----------------------------------------------------------------------------- |\r\n| Request    | The request model for the action                                              |\r\n| Response   | The response type for the action                                              |\r\n| Scope      | The scope of the action (SubscriptionActionScope or TenantActionScope)        |\r\n| Parameters | Optional. Additional parameters after the path parameters (e.g. Location)     |\r\n| LroHeaders | Optional. Allows overriding the lro headers returned in the Accepted response |\r\n| Error      | Optional. The error response, if non-standard.                                |\n\n### `ArmProviderActionSync` {#Azure.ResourceManager.ArmProviderActionSync}\n\n```typespec\r\nop Azure.ResourceManager.ArmProviderActionSync(apiVersion: string, subscriptionId: Azure.Core.uuid, location: string, resourceGroupName: string, resourceUri: string, provider: \"Microsoft.ThisWillBeReplaced\", body: Request): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description                                                               |\r\n| ---------- | ------------------------------------------------------------------------- |\r\n| Request    | The request model for the action                                          |\r\n| Response   | The response type for the action                                          |\r\n| Scope      | The scope of the action (SubscriptionActionScope or TenantActionScope)    |\r\n| Parameters | Optional. Additional parameters after the path parameters (e.g. Location) |\r\n| Error      | Optional. The error response, if non-standard.                            |\n\n### `ArmResourceActionAsync` {#Azure.ResourceManager.ArmResourceActionAsync}\n\n```typespec\r\nop Azure.ResourceManager.ArmResourceActionAsync(provider: \"Microsoft.ThisWillBeReplaced\", body: Request): Azure.ResourceManager.ArmAcceptedLroResponse<Description, LroHeaders> | Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                               |\r\n| -------------- | ------------------------------------------------------------------------- |\r\n| Resource       | The resource being acted upon                                             |\r\n| Request        | The request model for the action                                          |\r\n| Response       | The response model for the action                                         |\r\n| BaseParameters | Optional. Allows overriding the parameters for the operation              |\r\n| LroHeaders     | Optional. Allows overriding the headers returned in the Accepted response |\r\n| Parameters     | Optional. Additional parameters after the path parameters                 |\r\n| Error          | Optional. The error response, if non-standard.                            |\n\n### `ArmResourceActionAsyncBase` {#Azure.ResourceManager.ArmResourceActionAsyncBase}\n\nA long-running resource action.\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceActionAsyncBase(provider: \"Microsoft.ThisWillBeReplaced\", body: Request): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                  |\r\n| -------------- | ------------------------------------------------------------ |\r\n| Resource       | The resource being acted upon                                |\r\n| Request        | The request model for the action                             |\r\n| Response       | The response type for the action                             |\r\n| BaseParameters | Optional. Allows overriding the parameters for the operation |\r\n| Parameters     | Optional. Additional parameters after the path parameters    |\r\n| Error          | Optional. The error response, if non-standard.               |\n\n### `ArmResourceActionNoContentAsync` {#Azure.ResourceManager.ArmResourceActionNoContentAsync}\n\n```typespec\r\nop Azure.ResourceManager.ArmResourceActionNoContentAsync(provider: \"Microsoft.ThisWillBeReplaced\", body: Request): Azure.ResourceManager.ArmAcceptedLroResponse<Description, LroHeaders> | Azure.ResourceManager.ArmNoContentResponse<\"Action completed successfully.\"> | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                               |\r\n| -------------- | ------------------------------------------------------------------------- |\r\n| Resource       | The resource being acted upon                                             |\r\n| Request        | The request model for the action                                          |\r\n| BaseParameters | Optional. Allows overriding the parameters for the operation              |\r\n| LroHeaders     | Optional. Allows overriding the headers returned in the Accepted response |\r\n| Parameters     | Optional. Additional parameters after the path parameters                 |\r\n| Error          | Optional. The error response, if non-standard.                            |\n\n### `ArmResourceActionNoContentSync` {#Azure.ResourceManager.ArmResourceActionNoContentSync}\n\nA synchronous resource action that returns no content.\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceActionNoContentSync(provider: \"Microsoft.ThisWillBeReplaced\", body: Request): Azure.ResourceManager.ArmNoContentResponse<\"Action completed successfully.\"> | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                  |\r\n| -------------- | ------------------------------------------------------------ |\r\n| Resource       | The resource being acted upon                                |\r\n| Request        | The request model for the action                             |\r\n| BaseParameters | Optional. Allows overriding the parameters for the operation |\r\n| Parameters     | Optional. Additional parameters after the path parameters    |\r\n| Error          | Optional. The error response, if non-standard.               |\n\n### `ArmResourceActionNoResponseContentAsync` {#Azure.ResourceManager.ArmResourceActionNoResponseContentAsync}\n\n```typespec\r\nop Azure.ResourceManager.ArmResourceActionNoResponseContentAsync(provider: \"Microsoft.ThisWillBeReplaced\", body: Request): Azure.ResourceManager.ArmAcceptedLroResponse<Description, LroHeaders> | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                  |\r\n| -------------- | ------------------------------------------------------------ |\r\n| Resource       | The resource being acted upon                                |\r\n| Request        | The request model for the action                             |\r\n| BaseParameters | Optional. Allows overriding the parameters for the operation |\r\n| LroHeaders     |                                                              |\r\n| Parameters     | Optional. Additional parameters after the path parameters    |\r\n| Error          | Optional. The error response, if non-standard.               |\n\n### `ArmResourceActionSync` {#Azure.ResourceManager.ArmResourceActionSync}\n\nA synchronous resource action.\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceActionSync(provider: \"Microsoft.ThisWillBeReplaced\", body: Request): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                  |\r\n| -------------- | ------------------------------------------------------------ |\r\n| Resource       | The resource being acted upon                                |\r\n| Request        | The request model for the action                             |\r\n| Response       | The response model for the action                            |\r\n| BaseParameters | Optional. Allows overriding the parameters for the operation |\r\n| Parameters     | Optional. Additional parameters after the path parameters    |\r\n| Error          | Optional. The error response, if non-standard.               |\n\n### `ArmResourceCheckExistence` {#Azure.ResourceManager.ArmResourceCheckExistence}\n\nCheck a resource's existence via HEAD operation\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceCheckExistence(provider: \"Microsoft.ThisWillBeReplaced\"): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                               |\r\n| -------------- | --------------------------------------------------------- |\r\n| Resource       | the resource being checked                                |\r\n| BaseParameters | Optional. Allows overriding the operation parameters      |\r\n| Parameters     | Optional. Additional parameters after the path parameters |\r\n| Response       | Optional. The success response for the read operation     |\r\n| Error          | Optional. The error response, if non-standard.            |\n\n### `ArmResourceCreateOrReplaceAsync` {#Azure.ResourceManager.ArmResourceCreateOrReplaceAsync}\n\n```typespec\r\nop Azure.ResourceManager.ArmResourceCreateOrReplaceAsync(provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                             |\r\n| -------------- | ----------------------------------------------------------------------- |\r\n| Resource       | the resource being created or replaced                                  |\r\n| BaseParameters | Optional. Allows overriding the operation parameters                    |\r\n| LroHeaders     | Optional. Allows overriding the lro headers returned on resource create |\r\n| Parameters     | Optional. Additional parameters after the path parameters               |\r\n| Response       | Optional. The success response for the createOrReplace operation        |\r\n| Error          | Optional. The error response, if non-standard.                          |\n\n### `ArmResourceCreateOrReplaceSync` {#Azure.ResourceManager.ArmResourceCreateOrReplaceSync}\n\nSynchronous PUT operation for Azure Resource Manager resources\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceCreateOrReplaceSync(provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                     |\r\n| -------------- | --------------------------------------------------------------- |\r\n| Resource       | the resource being created or replaced                          |\r\n| BaseParameters | Optional. Allows overriding the operation parameters            |\r\n| Parameters     | Optional. Additional parameters after the path parameters       |\r\n| Response       | Optional. The success response for the createOrUpdate operation |\r\n| Error          | Optional. The error response, if non-standard.                  |\n\n### `ArmResourceCreateOrUpdateAsync` {#Azure.ResourceManager.ArmResourceCreateOrUpdateAsync}\n\nA long-running resource CreateOrUpdate (PUT)\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceCreateOrUpdateAsync(provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                             |\r\n| -------------- | ----------------------------------------------------------------------- |\r\n| Resource       | the resource being created or updated                                   |\r\n| BaseParameters | Optional. Allows overriding the operation parameters                    |\r\n| LroHeaders     | Optional. Allows overriding the lro headers returned on resource create |\r\n| Parameters     | Optional. Additional parameters after the path parameters               |\r\n| Response       | Optional. The success response for the createOrUpdate operation         |\r\n| Error          | Optional. The error response, if non-standard.                          |\n\n### `ArmResourceCreateOrUpdateSync` {#Azure.ResourceManager.ArmResourceCreateOrUpdateSync}\n\n:::caution\r\n**Deprecated**: Please use ArmResourceCreateOrReplaceSync instead\r\n:::\r\n\r\nDEPRECATED: Please use ArmResourceCreateOrReplaceSync instead\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceCreateOrUpdateSync(provider: \"Microsoft.ThisWillBeReplaced\", resource: Resource): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                     |\r\n| -------------- | --------------------------------------------------------------- |\r\n| Resource       | the resource being created or updated                           |\r\n| BaseParameters | Optional. Allows overriding the operation parameters            |\r\n| Parameters     | Optional. Additional parameters after the path parameters       |\r\n| Response       | Optional. The success response for the createOrUpdate operation |\r\n| Error          | Optional. The error response, if non-standard.                  |\n\n### `ArmResourceDeleteAsync` {#Azure.ResourceManager.ArmResourceDeleteAsync}\n\n:::caution\r\n**Deprecated**: Use 'ArmResourceDeleteWithoutOkAsync' instead\r\n:::\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceDeleteAsync(provider: \"Microsoft.ThisWillBeReplaced\"): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                      |\r\n| -------------- | ---------------------------------------------------------------- |\r\n| Resource       | The resource being deleted                                       |\r\n| BaseParameters | Optional. Allows overriding the parameters for the operation     |\r\n| LroHeaders     | Optional. Allows overriding the headers in the Accepted response |\r\n| Parameters     | Optional. Additional parameters after the path parameters        |\r\n| Response       | Optional. The success response(s) for the delete operation       |\r\n| Error          | Optional. The error response, if non-standard.                   |\n\n### `ArmResourceDeleteAsyncBase` {#Azure.ResourceManager.ArmResourceDeleteAsyncBase}\n\n```typespec\r\nop Azure.ResourceManager.ArmResourceDeleteAsyncBase(provider: \"Microsoft.ThisWillBeReplaced\"): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                  |\r\n| -------------- | ------------------------------------------------------------ |\r\n| Resource       | The resource being deleted                                   |\r\n| Response       | The response type for the operation                          |\r\n| BaseParameters | Optional. Allows overriding the parameters for the operation |\r\n| Parameters     | Optional. Additional parameters after the path parameters    |\r\n| Error          | Optional. The error response, if non-standard.               |\n\n### `ArmResourceDeleteSync` {#Azure.ResourceManager.ArmResourceDeleteSync}\n\nDelete a resource synchronously\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceDeleteSync(provider: \"Microsoft.ThisWillBeReplaced\"): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                  |\r\n| -------------- | ------------------------------------------------------------ |\r\n| Resource       | The resource being deleted                                   |\r\n| BaseParameters | Optional. Allows overriding the parameters for the operation |\r\n| Parameters     | Optional. Additional parameters after the path parameters    |\r\n| Response       | Optional. The success response(s) for the delete operation   |\r\n| Error          | Optional. The error response, if non-standard.               |\n\n### `ArmResourceDeleteWithoutOkAsync` {#Azure.ResourceManager.ArmResourceDeleteWithoutOkAsync}\n\n```typespec\r\nop Azure.ResourceManager.ArmResourceDeleteWithoutOkAsync(provider: \"Microsoft.ThisWillBeReplaced\"): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                               |\r\n| -------------- | ------------------------------------------------------------------------- |\r\n| Resource       | The resource being deleted                                                |\r\n| BaseParameters | Optional. Allows overriding the parameters for the operation              |\r\n| LroHeaders     | Optional. Allows overriding the headers returned in the Accepted response |\r\n| Parameters     | Optional. Additional parameters after the path parameters                 |\r\n| Response       | Optional. The success response(s) for the delete operation                |\r\n| Error          | Optional. The error response, if non-standard.                            |\n\n### `ArmResourceListAtScope` {#Azure.ResourceManager.ArmResourceListAtScope}\n\nA resource list operation, with scope determined by BaseParameters\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceListAtScope(provider: \"Microsoft.ThisWillBeReplaced\"): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                               |\r\n| -------------- | --------------------------------------------------------- |\r\n| Resource       | the resource being patched                                |\r\n| BaseParameters | Optional. Allows overriding the operation parameters      |\r\n| Parameters     | Optional. Additional parameters after the path parameters |\r\n| Response       | Optional. The success response for the list operation     |\r\n| Error          | Optional. The error response, if non-standard.            |\n\n### `ArmResourceListByParent` {#Azure.ResourceManager.ArmResourceListByParent}\n\nA resource list operation, at the scope of the resource's parent\r\n\r\n```typespec\r\nop Azure.ResourceManager.ArmResourceListByParent(provider: \"Microsoft.ThisWillBeReplaced\"): Response | Error\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name               | Description                                               |\r\n| ------------------ | --------------------------------------------------------- |\r\n| Resource           | the resource being patched                                |\r\n| BaseParameters     | Optional. Allows overriding the operation parameters      |\r\n| ParentName         | Optional. The name of the parent resource                 |\r\n| ParentFriendlyName | Optional. The friendly name of the parent resource        |\r\n| Parameters         | Optional. Additional parameters after the path parameters |\r\n| Response           | Optional. The success response for the list operation     |\r\n| Error              | Optional. The error response, if non-standard.            |\n\n### `ArmResourcePatchAsync` {#Azure.ResourceManager.ArmResourcePatchAsync}\n\n```typespec\r\nop Azure.ResourceManager.ArmResourcePatchAsync(provider: \"Microsoft.ThisWillBeReplaced\", properties: Resource): Azure.ResourceManager.ArmResponse<ResponseBody> | Azure.ResourceManager.ArmAcceptedLroResponse<Description, LroHeaders> | Azure.ResourceManager.CommonTypes.ErrorResponse\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                                                   |\r\n| -------------- | ----------------------------------------------------------------------------- |\r\n| Resource       | the resource being patched                                                    |\r\n| Properties     | The model type of the resource properties                                     |\r\n| BaseParameters | Optional. Allows overriding the operation parameters                          |\r\n| LroHeaders     | Optional. Allows overriding the lro headers returned in the Accepted response |\r\n| Parameters     | Optional. Additional parameters after the path parameters                     |\n", "latency": 9.226984024047852, "response_length": 548}
{"query": "title: Defining custom action with path /:action\n\nquestion: Hi\nTypeSpec Discussion\n,\nWhat is the right way to define a path like following. Its an action but its not a ResourceAction. Closest I could find was an RpcOperation. Is there a better alternative?\n```\n\"/:query-test\":{\n\"post\":{\n\"operationId\": \"QuestionAnswering_GetAnswersFromText\",\n\"summary\": \"Answers the specified question using the provided text in the body.\",\n\"products\":[\n\"application/json\"\n],\n\"consumes\":[\n\"application/json\"\n],\n}\n}\n```\n```\n@route(\"/:query-text\")\n@post\ngetAnswersFromText is RpcOperation<\n{\n@bodyRoot\ntextQueryOptions: AnswersFromTextOptions;\n},\nAnswersFromTextResult,\n{},\nErrorResponse\n>;\n```", "ground_truth": "RPC operation is essentially for this.", "response": "The correct way to define a path like `/:query-test` in TypeSpec is to use the `@route` decorator with the desired path and the HTTP method decorators like `@post`. The example you provided aligns with TypeSpec's approach for defining operations. Using `RpcOperation` is appropriate for defining operations that are not tied to a specific resource but perform actions. Here's the refined example:\n\n```typescript\n@route(\"/:query-test\")\n@post\ngetAnswersFromText is RpcOperation<\n  {\n    @bodyRoot\n    textQueryOptions: AnswersFromTextOptions;\n  },\n  AnswersFromTextResult,\n  {},\n  ErrorResponse\n>;\n```\n\nThis approach ensures that the operation is correctly mapped to the specified path and HTTP method, while also defining the request and response types. If you need additional metadata like `operationId` or `summary`, you can use decorators such as `@operationId` and `@summary` to enhance the operation definition.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n", "latency": 9.436423540115356, "response_length": 915}
{"query": "title: Typespec -> Autorest generation : multiple specs per service\n\nquestion: Currently while we are able to organize and manage multiple typespec files per service easily, the final generated swagger is a single file.\nI was asked during my API review to check if there is feasibility to produce multiple specs per service for organizational purposes considering the generated file is huge.\nI see prior posts on this indicating this is not supported, but looking for any latest update/guidance here.\nSecondly, if the above is in fact supported, any idea if the SDK generation part can handle multiple specs per service?", "ground_truth": "It was confirmed that splitting a TypeSpec specification into multiple OpenAPI files is not supported. Additionally, merging Swagger files does not impact REST API reference documentation, and the readme.md file should be checked for updates.", "response": "Currently, TypeSpec supports generating multiple OpenAPI specifications per service by leveraging versioning or organizing specifications for multiple services. This can be achieved using the `@versioned` decorator or by configuring emitter options such as `output-file` and `azure-resource-provider-folder`. For example, you can generate separate OpenAPI files for different versions or services, which helps in managing large specifications.\n\nRegarding SDK generation, AutoRest can handle multiple OpenAPI specifications as input files. You can pass multiple generated OpenAPI files to the AutoRest CLI for SDK generation. However, you may need to ensure proper configuration and organization of the input files to align with your SDK requirements.", "context": "- document_dir: typespec_azure_docs\n- document_filename: emitters#typespec-autorest#index.md\n- document_title: TypeSpec AutoRest Library\n- document_link: https://azure.github.io/typespec-azure/docs/emitters/typespec-autorest/index\n- document_content: # emitters#typespec-autorest#index.md\n\n# TypeSpec AutoRest Library\n\nThis is a TypeSpec library that will emit an enriched OpenAPI 2.0 specification that can be consumed by AutoRest.\r\nThe generated OpenAPI spec will have custom `x-ms-` extensions properties and conform to standards required by AutoRest to generate a more accurate SDK.\n\n## Getting started\n\n1. Include `@azure-tools/typespec-autorest` dependencies in package.json\r\n\r\n```json\r\n{\r\n  ...\r\n  \"dependencies\": {\r\n    ...\r\n    \"@azure-tools/typespec-autorest\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\n2. Run `npm install` to install the dependency\r\n3. Import `@azure-tools/typespec-autorest` in your `main.tsp` file\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-autorest\";\r\n```\r\n\r\n4. Run `tsp compile`. This will result in a `swagger.json` file crated in `./tsp-output/swagger.json`\n\n## Use in autorest\n\nGenerate the OpenAPI spec as shown above then run autorest cli directly on it.\r\n\r\n```bash\r\nautorest --input-file=<path/to/generated/file.json>\n\n# Example\n\nautorest --input-file=./tsp-output/@azure-tools/typespec-autorest/openapi.json --python\r\n```\n\n## Configuration\n\n### Emitter options:\n\nEmitter options can be configured via the `tspconfig.yaml` configuration:\r\n\r\n```yaml\r\nemitters:\r\n  '@azure-tools/typespec-autorest':\r\n    <optionName>: <value>\n\n# For example\n\n`openapi.Org1.Service2.yaml`\r\n\r\nExample: Single service with versioning\r\n\r\n- `openapi.v1.yaml`\r\n- `openapi.v2.yaml`\r\n\r\nExample: Multiple service with versioning\r\n\r\n- `openapi.Org1.Service1.v1.yaml`\r\n- `openapi.Org1.Service1.v2.yaml`\r\n- `openapi.Org1.Service2.v1.0.yaml`\r\n- `openapi.Org1.Service2.v1.1.yaml`\r\n\r\nExample: azureResourceProviderFolder is provided\r\n\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n\r\n#### `examples-directory`\r\n\r\nDirectory where the x-ms-examples are located so the emitter can automatically link.\r\n\r\n#### `version`\r\n\r\nSelect which version should be emitted if the spec support versioning. By default all the version with be emitted in this format `<outputFileName>.<version>.json`\n\nemitters:\r\n  '@azure-tools/typespec-autorest':\r\n    output-file: my-custom-swagger.json\r\n```\r\n\r\nor via the command line with\r\n\r\n```bash\r\n--option \"@azure-tools/typespec-autorest.<optionName>=<value>\"\r\n\r\n--option \"@azure-tools/typespec-autorest.output-file=my-custom-swagger.json\"\r\n```\r\n\r\n#### `azure-resource-provider-folder`\r\n\r\n`resource-manager` directory under your service folder are located so the emitter can emit correct sub-folder structure and swagger files for each of the API versions. You must specify it for ARM specs with folder path relative to the TypeSpec files.\r\n\r\n#### `emitter-output-dir`\r\n\r\nSet the emitter output-dir. [See here](https://typespec.io/docs/handbook/configuration#emitter-output-dir)\r\n\r\n#### `output-file`\r\n\r\nConfigure the name of the swagger output file relative to the `output-dir`.\r\n\r\nOutput file will interpolate the following values:\r\n\r\n- service-name: Name of the service if multiple\r\n- version: Version of the service if multiple\r\n- azure-resource-provider-folder: Value of the azure-resource-provider-folder option\r\n- version-status: Only enabled if azure-resource-provider-folder is set. `preview` if version contains preview, stable otherwise.\r\n\r\nDefault: `{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/openapi.json`\r\n\r\nExample: Single service no versioning\r\n\r\n- `openapi.yaml`\r\n\r\nExample: Multiple services no versioning\r\n\r\n- `openapi.Org1.Service1.yaml`\r\n- `openapi.Org1.Service2.yaml`\r\n\r\nExample: Single service with versioning\r\n\r\n- `openapi.v1.yaml`\r\n- `openapi.v2.yaml`\r\n\r\nExample: Multiple service with versioning\r\n\r\n- `openapi.Org1.Service1.v1.yaml`\r\n- `openapi.Org1.Service1.v2.yaml`\r\n- `openapi.Org1.Service2.v1.0.yaml`\r\n- `openapi.Org1.Service2.v1.1.yaml`\r\n\r\nExample: azureResourceProviderFolder is provided\r\n\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n\r\n#### `examples-directory`\n\n### `new-line`\n\nSet the newline character for emitting files. Can be either:\r\n\r\n- `lf`(Default)\r\n- `crlf`\n\n### `omit-unreachable-types`\n\nOnly include types referenced via an operation.\n\n## Decorators\n\n- [@collectionFormat](#collectionformat)\r\n- [@example](#example)\r\n- [@useRef](#useref)\n\n### @collectionFormat\n\nSyntax:\r\n\r\n```\r\n@collectionFormat(formatString)\r\n```\r\n\r\n`@collectionFormat` specifies array property type serialization format. Valid format strings are \"csv\", \"multi\", \"ssv\", \"tsv\", \"pipes\" though \"csv\" or \"multi\" are recommended.\r\n\r\n`@collectionFormat` can only be specified on model properties that are arrays.\n\n### @example\n\nSyntax:\r\n\r\n```\r\n@example(pathOrUri, title)\r\n```\r\n\r\n`@example` attaches example files to an operation. Multiple examples can be specified.\r\n\r\n`@example` can only be specified on operations.\n\n### @useRef\n\nSyntax:\r\n\r\n```\r\n@useRef(urlString)\r\n```\r\n\r\n`@useRef` is used to replace the TypeSpec model type in emitter output with a pre-existing named OpenAPI schema such as ARM common types.\n\n## How to\n\n### Include `x-ms-skip-url-encoding` in `x-ms-parmaeterized-host` parameter\n\nEvery parameter of type `uri` in `@server` will be marked with `x-ms-skip-url-encoding`.\r\n\r\n```typespec\r\n@server(\"{endpoint}/v2\", \"Account endpoint\", {endpoint: url})\r\n```\r\n\r\nResult in\r\n\r\n```json5\r\n{\r\n  in: \"path\",\r\n  name: \"endpoint\",\r\n  required: true,\r\n  type: \"string\",\r\n  format: \"uri\",\r\n  \"x-ms-skip-url-encoding\": true,\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: emitters#typespec-autorest-canonical#reference#emitter.md\n- document_title: Emitter usage\n- document_link: https://azure.github.io/typespec-azure/docs/emitters/typespec-autorest-canonical/reference/emitter\n- document_content: # emitters#typespec-autorest-canonical#reference#emitter.md\n\n# Emitter usage\n\n## Usage\n\n1. Via the command line\r\n\r\n```bash\r\ntsp compile . --emit=@azure-tools/typespec-autorest-canonical\r\n```\r\n\r\n2. Via the config\r\n\r\n```yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest-canonical\"\r\n```\r\n\r\nThe config can be extended with options as follows:\r\n\r\n```yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest-canonical\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest-canonical\":\r\n    option: value\r\n```\n\n## Emitter options\n\n### `emitter-output-dir`\n\n**Type:** `absolutePath`\r\n\r\nDefines the emitter output directory. Defaults to `{output-dir}/@azure-tools/typespec-autorest-canonical`\r\nSee [Configuring output directory for more info](https://typespec.io/docs/handbook/configuration/configuration/#configuring-output-directory)\n\n### `output-file`\n\n**Type:** `string`\r\n\r\nName of the output file.\r\nOutput file will interpolate the following values:\r\n\r\n- service-name: Name of the service if multiple\r\n- azure-resource-provider-folder: Value of the azure-resource-provider-folder option\r\n\r\nDefault: `{azure-resource-provider-folder}/{service-name}/canonical/openapi.json`\r\n\r\nExample: Single service\r\n\r\n- `canonical.openapi.json`\r\n\r\nExample: Multiple services\r\n\r\n- `Service1.canonical.openapi.json`\r\n- `Service2.canonical.openapi.json`\n\n### `azure-resource-provider-folder`\n\n**Type:** `string`\n\n### `arm-types-dir`\n\n**Type:** `string`\r\n\r\nPath to the common-types.json file folder. Default: '${project-root}/../../common-types/resource-management'\n\n### `new-line`\n\n**Type:** `\"crlf\" | \"lf\"`\r\n\r\nSet the newline character for emitting files.\n\n### `omit-unreachable-types`\n\n**Type:** `boolean`\r\n\r\nOmit unreachable types. By default all types declared under the service namespace will be included. With this flag on only types references in an operation will be emitted.\n\n### `include-x-typespec-name`\n\n**Type:** `\"inline-only\" | \"never\"`\r\n\r\nIf the generated openapi types should have the `x-typespec-name` extension set with the name of the TypeSpec type that created it.\r\nThis extension is meant for debugging and should not be depended on.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n", "latency": 13.941712617874146, "response_length": 750}
{"query": "title: Version Control in TypeSpec\n\nquestion: Hi team,\nWe are introducing a new version, 2025-05-01-GA, which adds new APIs based on 2023-04-01-GA. However, we already have several preview versions introduced between these two GA versions  2023-04-15-preview, 2024-11-15-preview, and 2025-05-15-preview.\nThe issue is that 2025-05-01-GA only includes a subset of the APIs introduced in 2023-04-15-preview. If we make 2025-05-01-GA the latest version, it will appear to remove a number of APIs or models that exist in 2025-05-15-preview.\nWould it be better to insert 2025-05-01-GA right after 2023-04-01-GA, treating it as a smaller update? We could then convert some APIs from 2023-04-15-preview into 2025-05-01-GA, and let later preview versions inherit from 2025-05-01-GA accordingly.\nWhats the best approach for handling this versioning situation in TypeSpec?\nThank you!\n```\n/**\n* The available API versions.\n*/\nenum Versions {\n/** Version 2023-04-01 */\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\nv2023_04_01: \"2023-04-01\",\n/**\n* The 2025-05-01 API version.\n*/\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\nv2025_05_01: \"2025-05-01\",\n/**\n* The 2023-04-15-preview API version.\n*/\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\nv2023_04_15_preview: \"2023-04-15-preview\",\n/**\n* The 2024-11-15-preview API version.\n*/\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\nv2024_11_15_preview: \"2024-11-15-preview\",\n/**\n* The 2025-05-15-preview API version.\n*/\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\nv2025_05_15_preview: \"2025-05-15-preview\",\n}\n```", "ground_truth": "Preview versions should stop working in 90 days after a new preview or stable version is introduced.\n2025-05-15-preview will be the corresponding preview version for 2025-05-01-GA.\nOld preview versions will be retired and old swaggers removed from the repo.\nThe final typespec should have any @added/@removed between GA versions and then just @added for the new preview version.\nA formal retirement process is needed for previous preview versions in the service backend.", "response": "To handle this versioning situation in TypeSpec, the recommended approach is to treat `2025-05-01-GA` as a smaller update to `2023-04-01-GA` and insert it immediately after. This ensures that the new GA version does not inadvertently remove APIs or models introduced in the preview versions. Here's how you can proceed:\n\n1. **Update the `Versions` Enum**:\n   - Place `2025-05-01-GA` after `2023-04-01-GA` in the `Versions` enum.\n   - Use the `@added` decorator to specify which APIs or models from `2023-04-15-preview` should be included in `2025-05-01-GA`.\n\n2. **Inherit Preview Versions**:\n   - Ensure that later preview versions like `2025-05-15-preview` inherit from `2025-05-01-GA` to maintain consistency and avoid API removal.\n\n3. **Use the `@added` and `@removed` Decorators**:\n   - Use `@added` to explicitly include APIs or models in `2025-05-01-GA`.\n   - If necessary, use `@removed` to indicate APIs or models that are not part of `2025-05-01-GA` but exist in preview versions.\n\nThis approach ensures a clear and logical progression of versions while maintaining backward compatibility and avoiding confusion for API consumers.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step10.md\n- document_title: 10. Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10\n- document_content: # getstarted#azure-core#step10.md\n\n# 10. Versioning\n\n## Versioning your service\n\nIt is inevitable that service specifications will change over time. It is a best practice to add versioning support to your specification from the first version. To do that, you will need to define an `enum` containing your service versions and then apply the `@versioned` decorator to your service namespace.\r\n\r\nHere is an example for the `WidgetManager` service:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n}\r\n```\r\n\r\nThere are a few things to point out here:\r\n\r\n- We define an `enum` called `Versions` inside of the service namespace. For each service version, we map a version symbol like `v2022_08_31` to a version string like `2022-08-31`. This service currently only has a single version, but we can add more to this enum as things change over time.\r\n- We add the `@versioned` decorator and reference the `Versions` enum we defined using the fully-qualified name `Contoso.WidgetManager.Versions`. This marks the service as being versioned and specifies the set of versions.\r\n- We change the `@useDependency` decorator we used previously to now link each service version to a specific version of `Azure.Core`. See the [Using Azure.Core Versions](#using-azurecore-versions) section for more information.\r\n\r\nImagine that it's 3 months later and you want to release a new version of your service with some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\n\nwith some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nFinally, you can express changes to your service using the `@added` and `@removed` decorators. Here's an example of adding a new property to `Widget` and removing an old one:\r\n\r\n```typespec\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  @added(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  color: string;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  @removed(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n> You can do a lot more with versioning decorators, so consult the `typespec-versioning` [README.md](https://github.com/microsoft/typespec/tree/main/packages/versioning#enable-versioning-for-service-or-library) for more information on how you can use them to annotate your service and describe changes between different versions.\n\n## Using Azure.Core versions\n\n`typespec-azure-core` is a versioned TypeSpec library. This means that even as the TypeSpec portions of the typespec-azure-core library are updated, you can anchor each version of your spec to a specific `Azure.Core` version. This is done by decorating your service namespace with the `@useDependency` decorator from the `typespec-versioning` library.\r\n\r\nSimple TypeSpec specs need only pass the desired `Azure.Core` version into the `@useDependency` decorator:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nIf your spec has [multiple versions](#versioning-your-service), you will need to specify the version of `typespec-azure-core` that was used for each version in your spec. Assuming that there are two versions of `Azure.Core` and each version of your service uses a different one, it would look like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"v20220831\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"v20221130\",\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#09versioning.mdx\n- document_title: Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/09versioning\n- document_content: # howtos#generate-client-libraries#09versioning.mdx\n\n# Versioning\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis doc details what emitters will generate for versioned specs\n\n## Single api Version\n\nIf there is just one api version in the spec, we will generate the api surface area for that one version.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\nstatic ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01\")\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\nwith pytest.expect(ImportError):\r\n  preview_model = models.PreviewModel(preview_functionality=\"not present\")\r\n\r\nwith pytest.expect(AttributeError):\r\n  client.preview_functionality({\"previewFunctionality\": \"not present\"})\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api-version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\n//neither PreviewModel nor PreviewFunctionality will be generated\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n# python allows you to override the api version, even if only one version is defined in the spec\n\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01\"\r\n```\r\n\r\n```typescript\r\n// there's no apiVersion defined in the all the operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n## Multiple api versions\n\nThe configuration flag `api-version` allows you to toggle the behavior that our emitters will generate.\r\n\r\nWe will get the versioning information from the `Versions` enum that you pass to the `@versioned` decorator from the `@typespec/versioning` library.\r\n\r\n> NOTE: The ordering of the values in the `Versions` enum is very important. We use this information to determine the order of versions. Our default value will be the **last entry** in the `Versions` list\n\n### Default\n\nBy default our emitters will only generate the surface used by the latest api version if there are multiple defined. This includes generating only the models used in the surface area of the latest api version.\r\n\r\nDocumentation and enums showing the available api versions will still include all of the known api versions, meaning there will be documentation for both the preview and stable releases.\r\n\r\nFor the below example, all languages will generate the api surface of default version `v2023_11_01`. There will be no generation of the operation `previewFunctionality`, and we will also not generate the `PreviewModel` because it's only used in `previewFunctionality`, and therefore is not used in the api surface of `v2023_11_01`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\n### Override to a specific version\n\nYou can override the signature to return the api surface area for a specific api version.\r\n\r\nIn this example, you can see how this change is made in tspconfig.yaml, and we are going to override to return the preview api surface area for our spec. The preview api surface area contains all of the functionality.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01-preview\"\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\npreview_client.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\n# the model is generated as part of the api surface\n\npreview_client.preview_functionality(preview_model) # call goes through\r\n\r\n````\r\n\r\n```csharp\r\n// ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n// client's api-version will be \"2023-11-01-preview\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n````\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01_PREVIEW(\"2023-11-01-preview\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01_PREVIEW\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01-preview\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\nPreviewModel previewModel = new PreviewModel(\"present\");\r\n// call goes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\n\ngoes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01_Preview);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01-preview\"\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n### Override to return all\n\nYou can also override the signature to return the combined api surface area of all of the separate api versions. Different languages have different support for versioning validation.\r\n\r\nIn the following examples, you can observe how this change is made in `tspconfig.yaml`.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n## Overriding the Client Api Version Parameter\n\nonto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient clientWithSpecifiedApiVersion = new ServiceClient(endpoint, options);\r\n//client's version will be \"2023-11-01\"\r\nResponse response = client.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n    V2024_04_01(\"2024-04-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2024_04_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient client = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's version will be 2024-04-01\r\n\r\nServiceClientClient clientWithSpecifiedApiVersion = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    .buildClient();\r\n// client's version will be 2023-11-01\r\n\r\nclient.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```go\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n\nBy default, we find api version parameters in specs based off of names. There is special logic we do with api version parameters:\r\n\r\n1. These api version parameters get elevated up to the client level (if the service is versioned)\r\n2. We auto-add api version information to next links when paging\r\n3. We set the client default for these parameters to be the default api version for your service.\r\n\r\nThere are cases where you have an api-versioning parameter without the explicit name `api-version`. In these cases, you can use the `@isApiVersion` decorator to override and explicitly say whether that parameter is an api version param or not.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\nusing Versioning;\r\nusing Http;\r\nusing Azure.ClientGenerator.Core;\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n  v2024_04_01: \"2024-04-01\",\r\n}\r\nop get(\r\n  @isApiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\r\n\r\n```python\r\nfrom my.service import MyServiceClient\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\r\nprint(client.version) # == \"2024-04-01\", since that is the default\r\n\r\nclient_with_specified_api_version = MyServiceClient(endpoint=..., credential=..., version=\"2023-11-01\")\r\nprint(client.version) # == \"2023-11-01\", since we specified\r\n\r\nretval = client.get() # version is elevated onto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\n", "latency": 14.317307710647583, "response_length": 1139}
{"query": "title: Proper Service Versioning\n\nquestion: Hi\nTypeSpec Discussion\n. I'm looking to understand how to properly add a new service version to my team's typespec. I've been looking at this doc here as a baseline, and I think I generally understand everything there. But I've got a couple of questions for my specific case.\nWhat does the added decorator actually do? Just tell the swagger which version should/shouldn't contain a property? I'm assuming the question of whether it has an impact on any of the SDKs is a question for the individual generator teams?\nMy team's spec has a client.tsp file with a customization namespace, which has this decorator: @useDependency(AI.Model.Versions.v2024_05_01_Preview). I get the general gist that this ties things to a specific version, but what does that mean from a practical standpoint? I maybe can understand client customizations being specific to individual versions, but what about modifications that work across versions? I don't seem to be able to provide a list or anything to that decorator. I've tried removing it, and I get an error saying that the customization namespace is referencing a versioned namespace and should add the decorator. I've also tried just changing the namespace to match, but then I get an error from my client interfaces saying that I have duplicate operations. So I'm trying to understand how to correctly handle this.\nAny pointers would be appreciated. Thanks in advance!", "ground_truth": "TypeSpec allows versioning based on differences, tagging changes with versioning decorators to reconstruct the API at each active version.\nThe @added decorator is used for adding new types to the spec, indicating the version when the change occurred. Similar decorators include @removed, @renamedFrom, and @typeChangedFrom.\nVersioning is tied to a namespace, including all child namespaces. If the client.tsp is a child namespace of the versioned namespace, no explicit version coupling is required. Otherwise, replicate the versions enum from the service namespace in client.tsp and tie each version explicitly.\nVersion-specific client.tsp changes are possible, but using @useDependency decorators ensures the client.tsp is used in both versions.", "response": "The `@added` decorator in TypeSpec is used to specify that a model, property, or operation was introduced in a specific version of your API. This metadata is primarily used to generate version-specific OpenAPI specifications, ensuring that the correct features are included or excluded based on the version being emitted. For example, if a property is marked with `@added(Versions.v2)`, it will only appear in the OpenAPI specification for version `v2` and later.\n\nRegarding SDK generation, the impact of the `@added` decorator depends on the specific generator being used. Some SDK generators may use this metadata to tailor the SDK to include or exclude features based on the version, but this behavior is generator-specific and should be confirmed with the generator team.\n\nThe `@useDependency` decorator ties a versioned namespace to a specific dependency version, such as `Azure.Core`. This ensures that the versioned namespace aligns with the correct version of the dependency library. If your customization namespace references a versioned namespace, it must include the `@useDependency` decorator to specify which version it depends on. This is why removing the decorator or mismatching the namespace causes errors. For modifications that work across versions, you would typically define them in a non-versioned namespace or ensure compatibility across all versions within the versioned namespace.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/language-basics/decorators\n- document_content: # language-basics#decorators.md\n\n# Decorators\n\nDecorators in TypeSpec allow developers to attach metadata to types within a TypeSpec program. They can also be used to compute types based on their inputs. Decorators form the core of TypeSpec's extensibility, providing the flexibility to describe a wide variety of APIs and associated metadata such as documentation, constraints, samples, and more.\r\n\r\nThe vast majority of TypeSpec declarations may be decorated, including [namespaces](./namespaces.md), [interfaces](./interfaces.md), [operations](./operations.md) and their parameters, [scalars](./scalars.md), and [models](./models.md) and their members. In general, any declaration that creates a Type can be decorated. Notably, [aliases](./alias.md) cannot be decorated, as they do not create new Types, nor can any type expressions such as unions that use the `|` syntax or anonymous models, as they are not declarations.\r\n\r\nDecorators are defined using JavaScript functions that are exported from a standard ECMAScript module. When a JavaScript file is imported, TypeSpec will look for any exported functions prefixed with `$`, and make them available as decorators within the TypeSpec syntax. When a decorated declaration is evaluated by TypeSpec, the decorator function is invoked, passing along a reference to the current compilation, an object representing the type it is attached to, and any arguments the user provided to the decorator.\n\n## Applying decorators\n\nDecorators are referenced using the `@` prefix and must be placed before the entity they are decorating. Arguments can be provided by using parentheses, similar to function calls in many programming languages, e.g., `@myDec1(\"hi\", { a: string })`.\r\n\r\nHere's an example of declaring and then using a decorator:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {\r\n  @validate(false)\r\n  name: string;\r\n}\r\n```\r\n\r\nIf no arguments are provided, the parentheses can be omitted.\r\n\r\n```typespec\r\n@mark\r\nmodel Dog {}\r\n```\n\n## Augmenting decorators\n\nDecorators can also be applied from a different location by referring to the type being decorated. For this, you can declare an augment decorator using the `@@` prefix. The first argument of an augment decorator is the type reference that should be decorated. As the augment decorator is a statement, it must end with a semicolon (`;`).\r\n\r\n```typespec\r\nmodel Dog {}\r\n\r\n@@tag(Dog, \"Sample\");\r\n```\r\n\r\nThis is equivalent to:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {}\r\n```\r\n\r\nExample: decorating a model property to indicate that it is read-only\r\n\r\n```typespec\r\nmodel Dog {\r\n  name: string;\r\n}\r\n\r\n@@visibility(Dog.name, Lifecycle.Read);\r\n```\n\n## Creating decorators\n\nFor more information on creating decorators, see [Creating Decorators](../extending-typespec/create-decorators.md).\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step10.md\n- document_title: 10. Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10\n- document_content: # getstarted#azure-core#step10.md\n\n# 10. Versioning\n\n## Versioning your service\n\nIt is inevitable that service specifications will change over time. It is a best practice to add versioning support to your specification from the first version. To do that, you will need to define an `enum` containing your service versions and then apply the `@versioned` decorator to your service namespace.\r\n\r\nHere is an example for the `WidgetManager` service:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n}\r\n```\r\n\r\nThere are a few things to point out here:\r\n\r\n- We define an `enum` called `Versions` inside of the service namespace. For each service version, we map a version symbol like `v2022_08_31` to a version string like `2022-08-31`. This service currently only has a single version, but we can add more to this enum as things change over time.\r\n- We add the `@versioned` decorator and reference the `Versions` enum we defined using the fully-qualified name `Contoso.WidgetManager.Versions`. This marks the service as being versioned and specifies the set of versions.\r\n- We change the `@useDependency` decorator we used previously to now link each service version to a specific version of `Azure.Core`. See the [Using Azure.Core Versions](#using-azurecore-versions) section for more information.\r\n\r\nImagine that it's 3 months later and you want to release a new version of your service with some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\n\nwith some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nFinally, you can express changes to your service using the `@added` and `@removed` decorators. Here's an example of adding a new property to `Widget` and removing an old one:\r\n\r\n```typespec\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  @added(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  color: string;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  @removed(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n> You can do a lot more with versioning decorators, so consult the `typespec-versioning` [README.md](https://github.com/microsoft/typespec/tree/main/packages/versioning#enable-versioning-for-service-or-library) for more information on how you can use them to annotate your service and describe changes between different versions.\n\n## Using Azure.Core versions\n\n`typespec-azure-core` is a versioned TypeSpec library. This means that even as the TypeSpec portions of the typespec-azure-core library are updated, you can anchor each version of your spec to a specific `Azure.Core` version. This is done by decorating your service namespace with the `@useDependency` decorator from the `typespec-versioning` library.\r\n\r\nSimple TypeSpec specs need only pass the desired `Azure.Core` version into the `@useDependency` decorator:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nIf your spec has [multiple versions](#versioning-your-service), you will need to specify the version of `typespec-azure-core` that was used for each version in your spec. Assuming that there are two versions of `Azure.Core` and each version of your service uses a different one, it would look like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"v20220831\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"v20221130\",\r\n}\r\n```\n", "latency": 13.763246536254883, "response_length": 1405}
{"query": "title: Traditional RP to use typespec. Can this be done? Are there any challenges?\n\nquestion: Hi team,\nWe are currently using traditional RP and wanted to leverage using typespec for our newer set of service offering using the same RP. We came across typespec and wanted to check if we can leverage using typespec for tradiiotnal RPs. Are there any other teams who have done something like that. Are there any challenges with this approach?\nThanks!!", "ground_truth": "I am not sure what you mean by 'traditional RP'  can you clarify?  There is some documentation on converting older RPs to TypeSpec here: [Migrate ARM spec | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips/)", "response": "Yes, it is possible to use TypeSpec with traditional Resource Providers (RPs) to define newer service offerings. TypeSpec provides a structured way to define data models and service APIs, which can be leveraged to model ARM resources and operations effectively. However, there are challenges and considerations to keep in mind:\n\n1. **Learning Curve**: Teams transitioning from traditional RP definitions to TypeSpec may need to familiarize themselves with TypeSpec syntax, decorators, and modeling patterns.\n\n2. **Resource Modeling**: TypeSpec requires resources to be modeled using specific base types such as `TrackedResource`, `ProxyResource`, or `ExtensionResource`. You will need to decide the appropriate resource type based on whether the resource is tracked, proxy, tenant-based, or extension-based.\n\n3. **Standard ARM Contracts**: TypeSpec enforces adherence to ARM contracts, such as implementing properties like `provisioningState` for tracked resources. Teams must ensure their resource definitions comply with these requirements.\n\n4. **Operation Definitions**: Defining operations for resources (e.g., `GET`, `PUT`, `PATCH`, `DELETE`) requires using TypeSpec operation templates or interface templates. This may differ from traditional RP approaches.\n\n5. **Integration with Existing Systems**: If your traditional RP setup includes custom tooling or workflows, integrating TypeSpec-generated artifacts (e.g., OpenAPI specifications) may require adjustments.\n\n6. **Optional ARM Features**: TypeSpec supports optional ARM features like Managed Identity, SKU, and ETags. Teams must decide whether to include these features in their resource definitions.\n\nOther teams have successfully transitioned to TypeSpec for ARM resource modeling, as evidenced by examples like the DynaTrace and TenantResource samples. These samples demonstrate how to define resources, properties, and operations using TypeSpec effectively.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-type.md\n- document_title: ARM Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type\n- document_content: # howtos#arm#resource-type.md\n\n# ARM Resource Types\n\n## Introductions\n\nIntroduction\r\nResources are the basic building blocks of Azure. When a customer interacts with Azure through the Control Plane (ARM), they generally will be reading (GET), writing (PUT/PATCH), deleting (DELETE) or performing actions upon (POST) one or more resources. Each resource is managed by a particular Resource Provider, so we uniquely identify a resource by its 'fully-qualified type'. Some well-known examples of types are Microsoft.Compute/virtualMachines, or Microsoft.Network/networkSecurityGroups/securityRules. See Resource Ids for a more in-depth breakdown of the id and associated fields.\r\n\r\nIn order to give customers a consistent API when working with many different Resource Providers, and to allow ARM to understand and manage resources programmatically, ARM requires each RP to follow a set of contracts for resource management, defined in the ARM RPC.\n\n## ARM Resource Terminology\n\nThe most important distinction between resources is between _Tracked_ and _Proxy_ resources. Tracked resources are resources in which all of the metadata is maintained in Azure Resource Manager. Tracked Resources can be targeted to specific regions, and are generally the best choice for most top-level resources. Azure Resource Manager maintains data about Tracked Resources, and generally will handle many implementation details or operations on the resource. See [RPC: Resource API Reference](https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md) for further information on the contract for Tracked Resources.\r\n\r\nProxy resources are resources in which only a portion of resource metadata is tracked in ARM. Generally, these model resources maintained on other systems, or that resource-providers want to track themselves. Generally, resource providers must implement most of the operations for Proxy resources. Tenant, Extension, and child resources are usually modeled as Proxy resources.\r\n\r\nThere is a good discussion on making the choice between Tracked and Proxy Resources in the armwiki discussion [Tracked vs Proxy Resources](https://armwiki.azurewebsites.net/rp_onboarding/tracked_vs_proxy_resources.html)\n\n## Choosing a Resource Type\n\n- The large majority of resources have their metadata tracked by ARM, can be assigned to regions, and are contained inside a resource group in a subscription, for ease of management and billing. These are called [Tracked Resources](#tracked-resources).\r\n- Some resources may need to have scope across an entire customer tenant, or may need to have a single instance across all customer subscriptions. These are called [tenant resources](#tenant-resources).\r\n- Some kinds of resources may augment or alter the functionality of resources or resource containers provided by other resource-providers. For example, policy or RBAC rules may be applied to any resource or resource container. These resources are called [extension resources](#extension-resource).\r\n- Some resources are complex and naturally break down into one or more components that are separately configurable, but an integral part of the larger resource (for example, a virtual network resource may contain many separately configurable subnets). These component resources are called [child resources](#child-resource).\r\n- Rarely, some resources may need to apply across a subscription, or have a single instance in a customer subscription, these are called [subscription-based resources](#subscription-based-resource).\r\n- Rarer still, some resources may need to apply across a specific region, or have a single instance in a region, these are called [location-based resources](#location-based-resource).\r\n- In some cases, there can only be one instance of a resource at a specific scope - this is rare, but happens most frequently in tenant, child, and location resources. In typespec, you will need to specify that the resource is a singleton, and the resource manager tools will automatically apply the correct pattern for singleton resources (using the recommended resource name 'default')\n\n## Modeling Resources in TypeSpec\n\nResources are modeled in TypeSpec by choosing a _base resource type_, defining _rp-specific properties_, and optionally mixing in _standard envelope properties_. Later sections document [how to model resource operations](./resource-operations.md). The following sections discuss usage of each of the base resource types. Later sections discuss [designing rp-specific properties](#designing-resource-specific-properties) and [adding standard ARM envelope properties](#adding-optional-standard-envelope-properties).\n\n### Tracked Resources\n\nTracked resources use the `TrackedResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tracked Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Tenant Resources\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@tenantResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tenant Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Extension Resource\n\nExtension resources use the `ExtensionResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is ExtensionResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Extension Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Child Resource\n\nChild resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@parentResource(EmployeeResource)\r\nmodel JobResource is ProxyResource<JobProperties> {\r\n  /** The job name */\r\n  @segment(\"jobs\")\r\n  @key(\"jobName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@parentResource`: designates the model type for the parent of this child resource. The resource identifier for this resource will be prepended with the resource identity of the parent.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Child Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Subscription-based Resource\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@subscriptionResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@subscriptionResource`: designates this resource as being a cross-subscription resource, with scope across all resource groups in the subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Subscription Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Location-based Resource\n\nLocation-based resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@locationResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@locationResource`: designates this resource as being a cross-location resource, with scope across a location within a subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Location Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Singleton Resource\n\nSingleton resources can use any resource base type, but most often use `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@singleton\r\n@tenantResource\r\nmodel EmployeeAgreementResource is ProxyResource<EmployeeAgreementProperties> {\r\n  /** The default employee agreement, applying to all employees. */\r\n  @segment(\"employeeAgreements\")\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@singleton`: indicates that there can only be one of the resources in the resource container (in this case, only one instance in the customer tenant).\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource. For a singleton, the name value will always be the same.\r\n`@segment(employeeAGreements)`: provides the resource type name for this resource.\r\n`@key`: provides the parameter name for the name of the resource in operations that use this resource - this will not be a settable value for singleton resources.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Singleton Resources [in the Singleton sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/arm-scenarios/singleton/main.tsp#L29).\n\n## Designing Resource-specific Properties\n\nEach resource model consists of two distinct parts\r\n\r\n- An outer _envelope_ of information that provides metadata for optional standardized ARM functionality, like entity-tags and managed identities, and is processed by Azure Resource Manager.\r\n- An inner set of properties that are specific to the resource and are defined by the resource provider.\r\n\r\nModifying the ARM envelope is discussed in later sections on [mixing in standard ARM envelope add-ons](#adding-optional-standard-envelope-properties).\r\n\r\nThe inner _rp-specific property bag_ consists of all of the properties that the RP needs to manage about the resource. Properties should be completely specified, should not duplicate properties from the _ARM envelope_, and may consist of simple types, arrays, or other complex properties.\r\n\r\nHere is an example of a property bag for the `EmployeeResource` resource.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n\r\nunion EmployeeProvisioningState {\r\n  string,\r\n\r\n  /** The resource create request has been accepted */\r\n  Accepted: \"Accepted\",\r\n\r\n  /** The resource is being provisioned */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is updating */\r\n  Updating: \"Updating\",\r\n\r\n  /** Resource has been created. */\r\n  Succeeded: \"Succeeded\",\r\n\r\n  /** Resource creation failed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\n\nfailed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n\r\nmodel EmployeeProperties {\r\n  /** The current title of the employee */\r\n  title: string;\r\n\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  level: EmployeeLevel;\r\n\r\n  @visibility(Lifecycle.Read)\r\n  employeeId: int32;\r\n\r\n  biography?: string = \"No biography provided\";\r\n  colleagues: EmployeeResourceId[];\r\n  employmentHistory: Job[];\r\n\r\n  @visibility(Lifecycle.Create)\r\n  password: Password;\r\n\r\n  provisioningState?: EmployeeProvisioningState;\r\n}\r\n```\r\n\r\n`EmployeeProperties` specifies the employee metadata that the RP needs to track and manage. Notice that the model uses built-in scalar types like `string` and `int32`, new types built from scalar types with added constraints, like `Password` and `EmployeeLevel`, enumerations of values, like `EmployeeProvisioningState`, and complex types. The individual components of this model are described below.\r\n\r\nNote that _documentation comments on all models and model properties are required when specs are checked in_. Here they are omitted for clarity. The TypeSpec compiler and TypeSpec IDE tooling will emit warning diagnostics if you emit required documentation, and about most of the ARM rules described in this document.\n\n### The `provisioningState` Property for Tracked Resources\n\nAll Tracked Resources are required to implement a 'provisioningState' property in their rp-specific property bag. This is used by ARM and some ARM clients to track the provisioning state of a resource as it is created and deleted. At minimum, the provisioning state must contain the standard terminal values that ARM is looking for. There are contained in the `ResourceProvisioningState` enumeration in the Azure.ResourceManager library. If RPs have other provisioning states they would like to track, they can define their own provisioning state enum, and mix in the value, as shown in the sample above, or they may simply use the standard provisioning state as shown in the sample below:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  ...ResourceProvisioningState;\r\n}\r\n```\r\n\r\nNote that this example uses the spread operator `...`, which allows you to simply include the properties from a source model in the target model you are constructing. This has the effect of copying the properties of the source model and their decorations into the target model, without creating any nominal inheritance relationship.\r\n\r\nAlternately, this is also equivalent:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  /** The status of the last provisioning operation performed on the resource. */\r\n  @visibility(Lifecycle.Read)\r\n  provisioningState?: ResourceProvisioningState;\r\n}\r\n```\n\n### Required and Optional properties and Property Defaults\n\nIn the examples, note that some model properties use the optional operator `?` after the property name, like `biography?` and some do not, like `title`. Property names using the `?` are optional properties, which may or may not be provided in the request body for CreateOrUpdate (PUT) requests. Property names without the `?` are required properties, which must be provided in PUT requests. The exception is that properties that have 'readOnly' visibility do not appear in requests, but may be required or optional in responses.\r\n\r\nAlso note that optional properties may specify defaults, as with `biography?: string = \"No biography provided\"`. The default indicates the value that will be recorded on the server if no value is sent by the client.\n\n### Defining Custom Types\n\nIn the sample, new constrained scalar types and new complex model types are defined and used inside the _rp-specific property bag_. TypeSpec allows you to define custom types for use in your specification.\r\n\r\nYou will often want to define scalar types or properties that have constraints. For example, numeric values may be constrained to have a certain minimum or maximum, strign values may be constrained to follow a particular regex pattern, and so on. Whenever these constrained types are used in your spec, the constraints will be transmitted to the usage.\r\n\r\nThe example creates a numeric type with minimum and maximum constraints:\r\n\r\n```typespec\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n```\r\n\r\nThis defines 'EmployeeLevel' as an integer value between 50 and 70. The example also defines a complex type used in an array:\r\n\r\n```typespec\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n```\r\n\r\nMode details on what to consider when using complex types in an array are discussed in the section on [modeling arrays of complex types](#modeling-arrays-of-complex-types).\n\n### Using Resource identifiers\n\nIt is often the case that resources need to reference other resources to provide specific pieces of functionality. For example, resources may need to reference a storage account to use for storing user data, or a NIC to attach to a Network. The `Azure.ResourceManager` library defines a `ResourceIdentifier` template that allows you to easily represent references to resources in your API. The template allows you to specify one or more acceptable resource types, automatically designating the value as a resource reference, and providing the appropriate pattern validation - which helps in generating better code, better ARM templates, and better documentation for your API.\r\n\r\n```typespec\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\nscalar NetworkInterfaceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/networkInterfaces\",\r\n    },\r\n    {\r\n      type: \"Microsoft.ClassicNetwork/networkInterfaces\",\r\n    }\r\n  ]>;\r\n```\r\n\r\nThe `NetworkInterfaceId example shows how to allow multiple resource types in a reference.\n\n### Property Visibility and Other Constraints\n\nThe sample uses the `@visibility` decorator to indicate how the resource definition is used in requests to PUT and PATCH operations, and in responses to PUT, PATCH, GET, and LIST operations.\r\n\r\nThis table shows how visibility is used to determine whether a property is used in requests and responses:\r\n\r\n| Visibility           | In Create Request? | In Patch Request/ Updateable in PUT | In Responses | Sample                                         |\r\n| -------------------- | ------------------ | ----------------------------------- | ------------ | ---------------------------------------------- |\r\n| None                 | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create, update | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create         | Yes                | No                                  | Yes          | resource location                              |\r\n| read, update         | No                 | Yes                                 | Yes          | Properties only settable after creation (keys) |\r\n| create, update       | Yes                | Yes                                 | No           | Secrets (e.g. password)                        |\r\n| read                 | No                 | No                                  | Yes          | Calculated properties, e.g. provisioningState  |\r\n| update               | No                 | Yes                                 | No           | Secrets (e.g. keys)                            |\r\n| create               | Yes                | No                                  | No           | Secrets (e.g. user-defined password)           |\n\n### Modeling Arrays of Complex Types\n\nFinally, when your _rp-specific property bag_ contains an array of complex properties, there are a few important considerations:\r\n\r\n- The complex properties in an array must have a key property - this means a property named 'name' or 'id' that uniquely identifies the property in the array. The TypeSpec tools will emit a diagnostic if you omit this.\r\n- ARM resources must be fully loaded in memory, so there are limits to the size of arrays in the properties of a resource. If your array is not strictly bounded, you should consider modeling the array property as a [child resource](#child-resource)\r\n- Updating the contents of arrays can be difficult, and result in data loss under simultaneous updates, especially as Json-Merge-Patch is not widely supported in ARM update operations. If users will frequently need to update the contents of arrays, you should consider modeling as a [child resource](#child-resource).\n\n## Adding Optional Standard Envelope Properties\n\nIn addition to the resource-specific property bag, a resource may configure on or more standard ARM features through the use of standard properties in the _ARM Envelope_. Standard features configured in the envelope include:\r\n\r\n- **Managed Identity**: Associating a managed identity with the resource to authorize actions taken by this resource on other resources.\r\n- **SKU**: A standard mechanism for configuring levels of service for a resource.\r\n- **Plan**: A standard mechanism for configuring MarketPlace billing plans for a resource.\r\n- **ETags**: A standard mechanism for managing concurrent operations over the resource.\r\n- **ResourceKind**: A standard mechanism for specifying a type of user experience in the portal.\n\n### Managed Identity\n\nStandard configuration for ARM support of both SystemAssigned and UserAssigned Managed Service Identity (MSI)\r\n\r\n- If a resource allows both generated (SystemAssigned) and user-assigned (UserAssigned) Managed Identity, use the spread (...) operator to include the standard ManagedServiceIdentity envelope property. This will allow users to manage any ManagedServiceIdentity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedServiceIdentity;\r\n  }\r\n  ```\r\n\r\n- If a resource allows only generated (SystemAssigned) Managed Identity, use the spread operator (...) to include the `ManagedSystemAssignedIdentity` standard envelope property in the resource definition. This will allow users to manage the SystemAssigned identity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedSystemAssignedIdentity;\r\n  }\r\n  ```\r\n\r\nFor more information, see [Managed Service Identity Support](https://eng.ms/docs/products/arm/rpaas/msisupport)\n\n### SKU\n\nStandard support for setting a SKU-based service level for a resource. To enable SKU support, add the `ResourceSku` enevelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceSku;\r\n}\r\n```\r\n\r\nFor more information, see [SKU Support](https://eng.ms/docs/products/arm/rpaas/skusupport)\n\n### ETags\n\nIndicator that entity-tag operation concurrency support is enabled for this resource. To enable ETags, add the `EntityTag` envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...EntityTag;\r\n}\r\n```\r\n\r\nFor more information, and limitations on RPaaS concurrency support, see [RPaaS ETag Support](https://eng.ms/docs/products/arm/rpaas/etags)\n\n### Plan\n\nSupport for marketplace billing configuration for the resource. To enable `Plan` support, add the `ResourcePlan` standard envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourcePlan;\r\n}\r\n```\r\n\r\nSee [MarketPlace Third Party Billing SUpport](https://eng.ms/docs/products/arm/rpaas/custom_billing)\n\n### ResourceKind\n\nSupport for certain kinds of portal user experiences based on the kind of resource. To include 'Kind' in the resource defintion, add the `ResourceKind` standard envelope property.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceKind;\r\n}\r\n```\r\n\r\nFor more information on user experiences in the Azure Portal, see [Portal Support](https://eng.ms/docs/products/arm/rpaas/portal/gettingstarted)\n\n### ManagedBy\n\nSupport for management of this resource by other resources. To add 'ManagedBy' support to the resource, add the `ManagedBy` envelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ManagedBy;\r\n}\r\n```\r\n\r\nFor more information on supporting 'ManagedBy', see [ManagedBy API Contract](https://eng.ms/docs/products/arm/api_contracts/managedby)\n\n## Reference\n\n[Fundamentals - ARM Wiki](https://armwiki.azurewebsites.net/fundamentals/overview.html)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-resource-manager#step02.md\n- document_title: 3. Defining the Resources\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step02\n- document_content: # getstarted#azure-resource-manager#step02.md\n\n# 3. Defining the Resources\n\nAn ARM resource provider is composed of resources. The TypeSpec Azure Resource Manager library makes it much easier to define the structure and endpoints of such resources.\r\n\r\nThere are three essential components of a resource defined with TypeSpec:\r\n\r\n- A model type representing the resource, derived from one of the [base resource types](#base-resource-types)\r\n- A model type defining the properties of the resource type\r\n- An interface that defines the operations that can be performed on the resource type, usually a combination of [recommended and required Operations](../../howtos/ARM/resource-operations.md#recommended-and-required-operations) and [resource actions](../../howtos/ARM/resource-operations.md#resource-actions-post)\r\n\r\n> Read the [TypeSpec tutorial](https://github.com/Microsoft/typespec/blob/main/docs/tutorial.md) to learn the basics about TypeSpec model types and interfaces.\n\n## 1. **Define a model representing the `properties` of the ARM resource**\n\nEach resource type must have a properties type which defines its custom properties. This type will be exposed as the `properties` property of the resource type.\r\n\r\n```typespec\r\n/** The properties of User */\r\nmodel UserProperties {\r\n  /** The user's full name */\r\n  fullName: string;\r\n\r\n  /** The user's email address */\r\n  emailAddress: string;\r\n}\r\n```\n\n## 2. **Define a model representing the resource type**\n\nResource types are defined as plain models which pull in a standard resource type using the `is` keyword.\r\n\r\nYou define a resource type, you need the following:\r\n\r\n- A property model type which defines the resource type's custom properties as we described in step 1\r\n- A `name` parameter definition. You should use `ResourceNameParameter` model which automatically populate the following decorators with camel cased name for `@key` and pluralized name for `@segment` as values. You can override these values via `ResourceNameParameter`'s optional template parameter.\r\n  - `@key`: Specifies the parameter name for this resource type in the service URI hierarchy\r\n  - `@segment`: Specifies the name of the resource \"collection\", the URI segment that comes just before the parameter name which identifies the resource type\r\n\r\nHere we define a tracked resource called `User`:\r\n\r\n```typespec\r\n/** A User Resource */\r\nmodel User is TrackedResource<UserProperties> {\r\n  ...ResourceNameParameter<User>;\r\n}\r\n```\n\n## 3. **Define an interface with operations for the resource type**\n\n```typespec\r\n@armResourceOperations\r\ninterface Users {\r\n  get is ArmResourceRead<User>;\r\n  create is ArmResourceCreateOrReplaceAsync<User>;\r\n  update is ArmCustomPatchSync<\r\n    User,\r\n    Azure.ResourceManager.Foundations.ResourceUpdateModel<User, UserProperties>\r\n  >;\r\n  delete is ArmResourceDeleteSync<User>;\r\n  listByResourceGroup is ArmResourceListByParent<User>;\r\n  listBySubscription is ArmListBySubscription<User>;\r\n}\r\n```\r\n\r\nThis uses operation templates defined in the `Azure.ResourceManager` namespace to define the operations over your resource. For operations like `create (PUT)`, `update (PATCH)` and `delete (DELETE)` there are both asynchronous (long-running) and synchronous (operation completes in the same http request) versions of the operation templates.\r\n\r\nThe interface above creates the following operations for your service:\r\n\r\n| Method & Path                                                                                                        | Description                     |\r\n| -------------------------------------------------------------------------------------------------------------------- | ------------------------------- |\r\n| `GET /subscriptions/{subscriptionId}/providers/Contoso.Users/users`                                                  | list all User by subscription   |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users`               | list all User by resource group |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                        |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | create item                     |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                      |\r\n|\n\nall User by resource group |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                        |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | create item                     |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                      |\r\n| `DELETE /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}` | delete item                     |\r\n\r\n#### Base Resource Types\r\n\r\nHere are the base resource types you can use when defining your own ARM resources:\r\n\r\n| Name                             | Description                                                                            |\r\n| -------------------------------- | -------------------------------------------------------------------------------------- |\r\n| `TrackedResource<TProperties>`   | Defines a normal ARM resource where `TProperties` is the model of the `properties`     |\r\n| `ProxyResource<TProperties>`     | Defines a proxy ARM resource where `TProperties` is the model of the `properties`      |\r\n| `ExtensionResource<TProperties>` | Defines an extension ARM resource where `TProperties` is the model of the `properties` |\n\n### Alternate (Legacy) Syntax for Operations\n\nAlternately, you can use interface templates, which define a set of operations in your resource operations interface. Interface templates are convenient if you want to conform to standard\r\npractices, but are less flexible than operation templates.\r\n\r\nTo specify the standard set of TrackedResource operations for your resource, you can use the following code:\r\n\r\n```typespec\r\n@armResourceOperations\r\ninterface Users extends TrackedResourceOperations<User, UserProperties> {}\r\n```\r\n\r\nThis will now produce all the endpoints(`get`, `post`, `put`, `patch` and `delete`, listByResourceGroup, listBySubscription) for a resource called `Users` and the `operations` endpoint for the service:\r\n\r\n| Method & Path                                                                                                        | Description                          |\r\n| -------------------------------------------------------------------------------------------------------------------- | ------------------------------------ |\r\n| `GET /providers/Contoso.Users/operations`                                                                            | List all operations for your service |\r\n| `GET /subscriptions/{subscriptionId}/providers/Contoso.Users/users`                                                  | list all User by subscription        |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users`               | list all User by resource group      |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                             |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | insert item                          |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                           |\r\n|\n\ngroup      |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                             |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | insert item                          |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                           |\r\n| `DELETE /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}` | delete item                          |\r\n\r\n#### Base Resource Types\r\n\r\nHere are the base resource types you can use when defining your own ARM resources:\r\n\r\n| Name                             | Description                                                                            |\r\n| -------------------------------- | -------------------------------------------------------------------------------------- |\r\n| `TrackedResource<TProperties>`   | Defines a normal ARM resource where `TProperties` is the model of the `properties`     |\r\n| `ProxyResource<TProperties>`     | Defines a proxy ARM resource where `TProperties` is the model of the `properties`      |\r\n| `ExtensionResource<TProperties>` | Defines an extension ARM resource where `TProperties` is the model of the `properties` |\n", "latency": 15.859399795532227, "response_length": 1924}
{"query": "title: Record<string> alternative\n\nquestion: Our spec used Record<string> in the past and this is no longer recommended per this rule: link\nOur service was designed in such a way to depend on allowing the user to pass a dictionary with a string with any key/any value.\nOther than suppression, is there a suggested workaround?", "ground_truth": "You will have to suppress the rule.", "response": "The recommended workaround for avoiding suppression while still allowing users to pass a dictionary with any key and any value is to use `Record<string>` directly, as this is considered correct usage according to the rule. If you need more flexibility or specific constraints, you can define a custom model with known properties or use `Record<string>` in combination with additional constraints. For example:\n\n```tsp\nmodel UserDictionary {\n  data: Record<string>;\n}\n```\n\nThis approach ensures compliance with the rule while maintaining the ability to accept a dictionary structure. If you need to enforce specific types for values, you can replace `string` with the desired type, such as `Record<int32>` or another type.", "context": "- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#bad-record-type.md\n- document_title: bad-record-type\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/bad-record-type\n- document_content: # libraries#azure-core#rules#bad-record-type.md\n\n# bad-record-type\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/bad-record-type\r\n```\r\n\r\nUse of `Record<X>` should be limited in Azure services.\r\n\r\n1. It is recommended to use `Record<string>` instead of `Record<unknown>`\r\n2. Specifying a type with Record and some known properties is also not recommended.\r\n\r\n####  Incorrect\r\n\r\n```tsp\r\nmodel Pet {\r\n  data: Record<unknown>;\r\n}\r\n```\r\n\r\n```tsp\r\nmodel Pet is Record<string> {\r\n  name: string;\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\nmodel Pet {\r\n  tags: Record<string>;\r\n}\r\n```\r\n\r\n```tsp\r\nmodel Pet is Record<string>;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#type-relations.md\n- document_title: Type Relations\n- document_link: https://typespec.io/docs/language-basics/type-relations\n- document_content: # language-basics#type-relations.md\n\n# Type Relations\n\n## Type hierarchy\n\n```mermaid\r\ngraph RL\r\n    record[\"Record<Element>\"] --> unknown\r\n    customModel[\"Custom model with properties\"] --> record[\"Record<T>\"]\r\n    array[\"Array<Element>\"] --> unknown\r\n    tuple[\"Tuple\"] --> array\r\n    numeric --> unknown\r\n    subgraph numerics[For numeric types, a narrower type can be assigned to a wider one]\r\n      integer --> numeric\r\n        int8 --> integer\r\n        int16 --> integer\r\n        int32 --> integer\r\n        safeint --> integer\r\n        int64 --> integer\r\n        uint8 --> integer\r\n        uint16 --> integer\r\n        uint32 --> integer\r\n        uint64 --> integer\r\n      float --> numeric\r\n        float32 --> float\r\n        float64 -->  float\r\n      decimal --> numeric\r\n        decimal128 --> decimal\r\n    end\r\n    string --> unknown\r\n    boolean --> unknown\r\n    null --> unknown\r\n    bytes --> unknown\r\n    plainDate --> unknown\r\n    plainTime --> unknown\r\n    zoneDateTime --> unknown\r\n    duration --> unknown\r\n```\n\n## Model with properties\n\nWhen determining if type `S` can be assigned to type `T`, if `T` is a model with properties, it checks whether all those properties are present in `S` and if their types can be assigned to the type of the corresponding property in `T`.\r\n\r\nFor instance,\r\n\r\n```typespec\r\nmodel T {\r\n  foo: string;\r\n  bar: int32;\r\n}\r\n\r\n// Valid\r\n\r\nmodel S { // When properties types are the exact same\r\n  foo: string;\r\n  bar: int32;\r\n}\r\nmodel S { // When the properties types are literal assignable to the target type\r\n  foo: \"abc\";\r\n  bar: 123;\r\n}\r\nmodel S {\r\n  foo: string;\r\n  bar: int8; // int8 is assignable to int16\r\n}\r\nmodel S {\r\n  foo: string;\r\n  bar: int32;\r\n  otherProp: boolean; // Additional properties are valid.\r\n}\r\n\r\n// Invalid\r\nmodel S { // Missing property bar\r\n  foo: string;\r\n}\r\nmodel S {\r\n  foo: string;\r\n  bar: int64; // int64 is NOT assignable to int32\r\n}\r\n```\n\n## `Record<T>`\n\nA record is a model indexed with a string with a value of T. It represents a model where all properties (string keys) are assignable to the type T. You can assign a model expression where all the properties are of type T or another model that `is` also a `Record<T>`.\r\n\r\n```typespec\r\n// Represent an object where all the values are int32.\r\nalias T = Record<int32>;\r\n\r\n// Valid\r\nalias S = {\r\n  foo: 123;\r\n  bar: 345;\r\n};\r\nalias S = {\r\n  foo: int8;\r\n  bar: int32;\r\n};\r\nmodel S is Record<int32>;\r\nmodel S is Record<int32> {\r\n  foo: 123;\r\n}\r\n\r\n// Invalid\r\nalias S = {\r\n  foo: \"abc\";\r\n  bar: 456;\r\n};\r\nalias S = {\r\n  foo: int64;\r\n  bar: int32;\r\n};\r\nmodel S {\r\n  foo: 123;\r\n  bar: 456;\r\n}\r\n```\r\n\r\n#### Why isn't the last case assignable to `Record<int32>`?\r\n\r\nIn this scenario,\r\n\r\n```typespec\r\nalias T = Record<int32>;\r\nmodel S {\r\n  foo: 123;\r\n  bar: 456;\r\n}\r\n```\r\n\r\nThe reason why `model S` is not assignable, but the model expression `{ foo: 123; bar: 456; }` is, is because model S could be extended with additional properties that might not be compatible.\r\n\r\nFor instance, if you add a new model,\r\n\r\n```typespec\r\nmodel Foo is S {\r\n  otherProp: string;\r\n}\r\n```\r\n\r\nHere, `Foo` is assignable to `S` following the [model with property logic](#model-with-properties), and if `S` was assignable to `Record<int32>`, `Foo` would also be passable. However, this is now invalid as `otherProp` is not an `int32` property.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#built-in-types.md\n- document_title: Built-in types\n- document_link: https://typespec.io/docs/language-basics/built-in-types\n- document_content: # language-basics#built-in-types.md\n\n# Built-in types\n\nTypeSpec Standard Library provide some built-in types that can be used to build more complex types.\r\n\r\nBuilt in types are related to each other according to the rules described in [type relations](../language-basics/type-relations.md).\n\n## Numeric types\n\n| A 8-bit integer                           |\r\n| `safeint`    | <code>9007199254740991 ((2<sup>53</sup>  1))</code> to <code>9007199254740991 (2<sup>53</sup>  1)</code> | An integer that can be serialized to JSON |\r\n| `uint64`     | `0` to `18,446,744,073,709,551,615`                                                                          | Unsigned 64-bit integer                   |\r\n| `uint32`     | `0` to `4,294,967,295`                                                                                       | Unsigned 32-bit integer                   |\r\n| `uint16`     | `0` to `65,535`                                                                                              | Unsigned 16-bit integer                   |\r\n| `uint8`      | `0` to `255 `                                                                                                | Unsigned 8-bit integer                    |\r\n| `float32`    | <code> 1.5 x 10<sup>45</sup></code> to <code>3.4 x 10<sup>38</sup></code>                                  | A 32 bit floating point number            |\r\n| `float64`    | <code>5.0  10<sup>324</sup></code> to <code>1.7  10<sup>308</sup></code>                                | A 64 bit floating point number            |\r\n| `decimal`    | [\\*](#numeric-supertypes)                                                                                    | A decimal number                          |\r\n| `decimal128` | 34 decimal digits with an exponent range from `-6143` to `6144`                                              | A 128 bit decimal number                  |\n\n| Type         | Range                                                                                                        | Description                               |\r\n| ------------ | ------------------------------------------------------------------------------------------------------------ | ----------------------------------------- |\r\n| `numeric`    | [\\*](#numeric-supertypes)                                                                                    | Parent type for all numeric types         |\r\n| `integer`    | [\\*](#numeric-supertypes)                                                                                    | A whole-number                            |\r\n| `float`      | [\\*](#numeric-supertypes)                                                                                    | A binary number                           |\r\n| `int64`      | `-9,223,372,036,854,775,808` to `9,223,372,036,854,775,807`                                                  | A 64-bit integer                          |\r\n| `int32`      | `-2,147,483,648` to `2,147,483,647`                                                                          | A 32-bit integer                          |\r\n| `int16`      | `-32,768` to `32,767`                                                                                        | A 16-bit integer                          |\r\n| `int8`       | `-128` to `127`                                                                                              | A 8-bit integer                           |\r\n| `safeint`    | <code>9007199254740991 ((2<sup>53</sup>  1))</code> to <code>9007199254740991 (2<sup>53</sup>  1)</code> | An integer that can be serialized to JSON |\r\n| `uint64`     | `0` to `18,446,744,073,709,551,615`                                                                          | Unsigned 64-bit integer                   |\r\n| `uint32`     |\n\n### Numeric supertypes\n\n`numeric`, `integer`, `float` and `decimal` are types that represent any possible number in their category. For some emit targets, `BigInt` or `BigDecimal` might be an analogous type satisfying the TypeSpec types `integer` and `decimal` respectively. For other targets where the language, serialization format, or protocol does not support an analogous type, emitters may decide on a policy for emitting the numeric supertypes. This might involve picking the closest analogous type and reporting a warning when they are encountered.\n\n## Date and time types\n\n| Type             | Description                                                                         |\r\n| ---------------- | ----------------------------------------------------------------------------------- |\r\n| `plainDate`      | A date on a calendar without a time zone, e.g. \"April 10th\"                         |\r\n| `plainTime`      | A time on a clock without a time zone, e.g. \"3:00 am\"                               |\r\n| `utcDateTime`    | A date and time in coordinated universal time (UTC), e.g. \"1985-04-12T23:20:50.52Z\" |\r\n| `offsetDateTime` | A date and time in a particular time zone, e.g. \"April 10th at 3:00am in PST\"       |\r\n| `duration`       | A duration/time period. e.g 5s, 10h                                                 |\r\n\r\n:::note\r\n\r\nThese types do not define any specific serialization format. They represent the concept of time. Each protocol or serialization format should define the default serialization format.\r\n\r\nThe default encodings for various protocols are defined here:\r\n\r\n- [JSON over HTTP](../libraries/http/encoding.md#utcdatetime-and-offsetdatetime)\r\n- [XML](../libraries/xml/guide.md)\r\n  :::\n\n## Other core types\n\n| Type              | Description                                                                                                                                                |\r\n| ----------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `bytes`           | A sequence of bytes                                                                                                                                        |\r\n| `string`          | A sequence of textual characters                                                                                                                           |\r\n| `boolean`         | Boolean with `true` and `false` values                                                                                                                     |\r\n| `null`            | Null value                                                                                                                                                 |\r\n| `Array<Element>`  | Array model type, equivalent to `Element[]`                                                                                                                |\r\n| `Record<Element>` | Model with string keys where all the values have type `Element` (similar to `Map<string, Element>` in TypeScript or `Dictionary<string, Element>` in .Net) |\r\n| `unknown`         | A top type in TypeSpec that all types can be assigned to. Values that can have any type should be assigned this value (similar to `any` in JavaScript)     |\r\n| `void`            | A function/operation return type indicating the function/operation doesn't return a value.                                                                 |\r\n| `never`           | The never type indicates the values that will never occur.                                                                                                 |\n\n## String types\n\nBuilt-in types that are known string formats\r\n\r\n| Type  | Description  |\r\n| ----- | ------------ |\r\n| `url` | A url String |\n", "latency": 9.270746946334839, "response_length": 721}
{"query": "title: Change parent resource\n\nquestion: Hi,\nI have a scenario where I'm renaming a tracked resource AutoActions to ScheduledActions a new API version.  The way I thought about doing this is by leveraging @added and @removed decorators.\nHowever, AutoActions has a child resource occurrence, that now needs to be a child resource of Scheduled Actions. But if I do something like this it gives conflict error. How can I unblock this scenario?\n```\n@added(Microsoft.ComputeSchedule.Versions.`2024-08-01-preview`)\n@removed(Microsoft.ComputeSchedule.Versions.`2025-04-01-preview`)\n@parentResource(AutoAction)\nmodel Occurrence is ProxyResource<OccurrenceProperties> {\n...ResourceNameParameter<\nOccurrence,\nKeyName = \"occurrenceId\",\nNamePattern = \"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\"\n>;\n}\n@added(Microsoft.ComputeSchedule.Versions.`2025-04-01-preview`)\n@parentResource(ScheduledAction)\nmodel Occurrence is ProxyResource<OccurrenceProperties> {\n...ResourceNameParameter<\nOccurrence,\nKeyName = \"occurrenceId\",\nNamePattern = \"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\"\n>;\n}\n```", "ground_truth": "Renaming a tracked resource from AutoActions to ScheduledActions in a new API version caused conflict errors, leading to renaming old resources and filing a bug report for TypeSpec support.\n[Bug](https://github.com/Azure/typespec-azure/issues/2551): Renaming resource not working properly  Issue #2551  Azure/typespec-azure", "response": "To resolve the conflict error when changing the parent resource of `Occurrence` from `AutoAction` to `ScheduledAction`, you can use the `@sharedRoute` and `@renamedFrom` decorators. These decorators help avoid name and route conflicts during version transitions. Here's how you can modify your code:\n\n```typespec\n@removed(Microsoft.ComputeSchedule.Versions.`2025-04-01-preview`)\n@sharedRoute\n@renamedFrom(Microsoft.ComputeSchedule.Versions.`2025-04-01-preview`, \"Occurrence\")\n@parentResource(AutoAction)\nmodel OccurrenceOld is ProxyResource<OccurrenceProperties> {\n  ...ResourceNameParameter<\n    Occurrence,\n    KeyName = \"occurrenceId\",\n    NamePattern = \"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\"\n  >;\n}\n\n@added(Microsoft.ComputeSchedule.Versions.`2025-04-01-preview`)\n@sharedRoute\n@parentResource(ScheduledAction)\nmodel Occurrence is ProxyResource<OccurrenceProperties> {\n  ...ResourceNameParameter<\n    Occurrence,\n    KeyName = \"occurrenceId\",\n    NamePattern = \"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\"\n  >;\n}\n```\n\nThis approach ensures backward compatibility while transitioning the parent resource. The `@sharedRoute` decorator allows both versions to coexist without route conflicts, and `@renamedFrom` helps maintain clarity in versioning changes.", "context": "- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step10.md\n- document_title: 10. Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10\n- document_content: # getstarted#azure-core#step10.md\n\n# 10. Versioning\n\n## Versioning your service\n\nIt is inevitable that service specifications will change over time. It is a best practice to add versioning support to your specification from the first version. To do that, you will need to define an `enum` containing your service versions and then apply the `@versioned` decorator to your service namespace.\r\n\r\nHere is an example for the `WidgetManager` service:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n}\r\n```\r\n\r\nThere are a few things to point out here:\r\n\r\n- We define an `enum` called `Versions` inside of the service namespace. For each service version, we map a version symbol like `v2022_08_31` to a version string like `2022-08-31`. This service currently only has a single version, but we can add more to this enum as things change over time.\r\n- We add the `@versioned` decorator and reference the `Versions` enum we defined using the fully-qualified name `Contoso.WidgetManager.Versions`. This marks the service as being versioned and specifies the set of versions.\r\n- We change the `@useDependency` decorator we used previously to now link each service version to a specific version of `Azure.Core`. See the [Using Azure.Core Versions](#using-azurecore-versions) section for more information.\r\n\r\nImagine that it's 3 months later and you want to release a new version of your service with some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\n\nwith some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nFinally, you can express changes to your service using the `@added` and `@removed` decorators. Here's an example of adding a new property to `Widget` and removing an old one:\r\n\r\n```typespec\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  @added(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  color: string;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  @removed(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n> You can do a lot more with versioning decorators, so consult the `typespec-versioning` [README.md](https://github.com/microsoft/typespec/tree/main/packages/versioning#enable-versioning-for-service-or-library) for more information on how you can use them to annotate your service and describe changes between different versions.\n\n## Using Azure.Core versions\n\n`typespec-azure-core` is a versioned TypeSpec library. This means that even as the TypeSpec portions of the typespec-azure-core library are updated, you can anchor each version of your spec to a specific `Azure.Core` version. This is done by decorating your service namespace with the `@useDependency` decorator from the `typespec-versioning` library.\r\n\r\nSimple TypeSpec specs need only pass the desired `Azure.Core` version into the `@useDependency` decorator:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nIf your spec has [multiple versions](#versioning-your-service), you will need to specify the version of `typespec-azure-core` that was used for each version in your spec. Assuming that there are two versions of `Azure.Core` and each version of your service uses a different one, it would look like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"v20220831\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"v20221130\",\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#versioning_operation_template_changes.md\n- document_title: How can I change the operation template of an operation in newer versions\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/versioning_operation_template_changes\n- document_content: # troubleshoot#versioning_operation_template_changes.md\n\n# How can I change the operation template of an operation in newer versions\n\n## Symtoms\n\nIf you are switching to a different operation template in a new version, you may run into compilation errors if you only leverage `@added` and `@removed` versioning decorators.\n\n## Workaround\n\nIn the example below, you are switch from an old deprecated operation template to the new one. Note the uses of `@sharedRoute` and `renamedFrom` to avoid name and route conflict errors.\r\n\r\n```typespec\r\n  #suppress \"deprecated\" \"back compat\"\r\n  @removed(Versions.`2024-10-01-preview`)\r\n  @sharedRoute\r\n  @renamedFrom(Versions.`2024-10-01-preview`, \"delete\")\r\n  deleteOld is ArmResourceDeleteAsync<Employee>;\r\n\r\n  @added(Versions.`2024-10-01-preview`)\r\n  @sharedRoute\r\n  delete is ArmResourceDeleteWithoutOkAsync<Employee>;\r\n```\r\n\r\n**Please note**: In the `delete is ArmResourceDeleteAsync` example above, if you are RPSaaS service, you CAN do a direct replacement with `delete is ArmResourceDeleteWithoutOkAsync`. This is because RPSaaS will never send `200 OK`. Update in-place is just an API spec bug fix.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-resource-manager#step03.md\n- document_title: 4. Defining Child Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step03\n- document_content: # getstarted#azure-resource-manager#step03.md\n\n# 4. Defining Child Resource Types\n\nYou can create parent/child relationships between resource types by using the `@parentResource` decorator when defining a resource type.\r\n\r\nFor example, here's how you could create a new `AddressResource` resource under the `User` defined above:\r\n\r\n```typespec\r\n/** An address resource belonging to a user resource */\r\n@parentResource(User)\r\nmodel AddressResource is ProxyResource<AddressResourceProperties> {\r\n  @key(\"addressName\")\r\n  @segment(\"addresses\")\r\n  name: string;\r\n}\r\n\r\n/** The properties of AddressResource */\r\nmodel AddressResourceProperties {\r\n  /** The street address */\r\n  streetAddress: string;\r\n\r\n  /** The city of the address */\r\n  city: string;\r\n\r\n  /** The state of the address */\r\n  state: string;\r\n\r\n  /** The zip code of the address */\r\n  zip: int32;\r\n}\r\n\r\n@armResourceOperations\r\ninterface Addresses {\r\n  get is ArmResourceRead<AddressResource>;\r\n  create is ArmResourceCreateOrReplaceSync<AddressResource>;\r\n  update is ArmCustomPatchSync<\r\n    AddressResource,\r\n    Azure.ResourceManager.Foundations.ResourceUpdateModel<\r\n      AddressResource,\r\n      AddressResourceProperties\r\n    >\r\n  >;\r\n  delete is ArmResourceDeleteSync<AddressResource>;\r\n  listByParent is ArmResourceListByParent<AddressResource>;\r\n}\r\n```\n", "latency": 14.088581562042236, "response_length": 1299}
{"query": "title: JSON merge-patch support in TypeSpec\n\nquestion: How exactly does TypeSpec support application/merge-patch+json i.e., \"JSON merge-patch\"? Is there explicit types, or is it really just a matter of service authors adding | null to their type defs e.g.,\n```\nmodel M {\n@key(\"id\")\nid: string;\nname: string | null;\ndob?: utcDateTime | null;\n}\n```\nThis will greatly affect how Rust will support this, give a discussion Larry, Johan, and I were having yesterday.", "ground_truth": "Design a new MergePatch template to make it easier for service authors to create accurate MergePatch schemas in OpenAPI.\nAzure takes the same stance as Graph, where JSON merge patch is considered a service fundamental and null is not expressed in TypeSpec models.\nGenerators for both client and service side types should make everything optional to accurately represent JSON merge-patch support.", "response": "TypeSpec does not provide explicit support for `application/merge-patch+json` (JSON merge-patch) as a distinct feature. However, it can be implemented by service authors using TypeSpec's type system. Specifically, adding `| null` to properties in a model allows for the representation of optional fields that can be explicitly set to `null`, which aligns with the JSON merge-patch semantics.\n\nFor example:\n```typespec\nmodel M {\n  @key(\"id\")\n  id: string;\n  name: string | null;\n  dob?: utcDateTime | null;\n}\n```\nIn this model:\n- `name` can be updated to `null` explicitly.\n- `dob` is optional and can also be set to `null`.\n\nThis approach enables JSON merge-patch functionality by allowing partial updates where fields can be omitted or explicitly set to `null`. The TypeSpec HTTP library defaults to `application/json` for models and unions containing `null`, which aligns with JSON merge-patch requirements.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#http#content-types.md\n- document_title: Content types\n- document_link: https://typespec.io/docs/libraries/http/content-types\n- document_content: # libraries#http#content-types.md\n\n# Content types\n\n## Default behavior\n\nBy default, if the content-type is not explicitly specified, the HTTP library will use the [`@mediaTypeHint`](../../standard-library/built-in-decorators.md#mediatypehint-mediatypehint) of the body type. For built-in TypeSpec types, the default content-type values are:\r\n\r\n- `\"application/json\"` if the body is a Model or a union that contains `null`.\r\n- `\"application/octet-stream\"` if the body is `TypeSpec.bytes` or a scalar that extends it (unless that scalar provides its own `@mediaTypeHint`).\r\n- `\"text/plain\"` if the body is any other scalar type that does not have a `@mediaTypeHint`.\r\n\r\n**Examples:**\r\n\r\n```typespec\r\n// Returns an application/octet-stream binary body\r\nop download(): bytes;\r\n\r\n// Returns a text/plain string\r\nop getContent(): string;\r\n\r\n// Returns an application/json body that is either a string or the `null` value\r\nop getContentNullable(): string | null;\r\n\r\n// Returns an application/json body with a `name` property.\r\nop getPet(): {\r\n  name: string;\r\n};\r\n```\r\n\r\nThe same logic applies to requests and response bodies, and it uses the precise type of the body if `@body` or `@bodyRoot` are used.\n\n## Specifying Content-Type\n\nYou can specify the content type for an operation by including a header parameter named `contentType`.\n\n### Request Content-Type\n\n```typespec\r\nop uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n```\n\n### Response Content-Type\n\n```typespec\r\nop downloadImage(): {\r\n  @header contentType: \"image/png\";\r\n  @body image: bytes;\r\n};\r\n```\n\n### Multiple Content-Type values\n\nIf there are multiple content types for the same body, you can specify them as a union of strings.\r\n\r\n```typespec\r\nop uploadImage(@header contentType: \"image/png\" | \"image/jpeg\", @body image: bytes): void;\r\n```\n\n## Content-Type negotiation\n\nIn some cases, the same endpoint might return different content depending on the requested content type. This can be achieved in two ways:\r\n\r\n- Using shared routes where different content responses are represented as different operations that share the same endpoint.\r\n- Using overloads where each different content response is an overload.\r\n\r\nFor example, an API that lets you download an avatar as either `png` or `jpeg` based on the `Accept` header.\n\n### Option 1: Using a shared route\n\n```tsp\r\nmodel PngImage {\r\n  @header contentType: \"image/png\";\r\n  @body image: bytes;\r\n}\r\n\r\nmodel JpegImage {\r\n  @header contentType: \"image/jpeg\";\r\n  @body image: bytes;\r\n}\r\n\r\n@route(\"/avatar\")\r\n@sharedRoute\r\nop getAvatarAsPng(@header accept: \"image/png\"): PngImage;\r\n\r\n@route(\"/avatar\")\r\n@sharedRoute\r\nop getAvatarAsJpeg(@header accept: \"image/jpeg\"): JpegImage;\r\n```\n\n### Option 2: Using overload\n\n```tsp\r\nmodel PngImage {\r\n  @header contentType: \"image/png\";\r\n  @body image: bytes;\r\n}\r\n\r\nmodel JpegImage {\r\n  @header contentType: \"image/jpeg\";\r\n  @body image: bytes;\r\n}\r\n\r\n@route(\"/avatar\")\r\nop getAvatar(@header accept: \"image/png\" | \"image/jpeg\"): PngImage | JpegImage;\r\n\r\n@overload(getAvatar)\r\nop getAvatarAsPng(@header accept: \"image/png\"): PngImage;\r\n\r\n@overload(getAvatar)\r\nop getAvatarAsJpeg(@header accept: \"image/jpeg\"): JpegImage;\r\n```\n\n## Multipart request\n\nSee [the documentation of multipart requests and responses for more information](./multipart.md).\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: standard-library#built-in-decorators.md\n- document_title: Built-in Decorators\n- document_link: https://typespec.io/docs/standard-library/built-in-decorators\n- document_content: # standard-library#built-in-decorators.md\n\n# Built-in Decorators\n\n## TypeSpec\n\n### `@continuationToken` {#@continuationToken}\n\nPagination property defining the token to get to the next page.\r\nIt MUST be specified both on the request parameter and the response.\r\n```typespec\r\n@continuationToken\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @continuationToken continuationToken: string;\r\n}\r\n@list op listPets(@continuationToken continuationToken: string): Page<Pet>;\r\n```\n\n### `@defaultVisibility` {#@defaultVisibility}\n\nDeclares the default visibility modifiers for a visibility class.\r\n\r\nThe default modifiers are used when a property does not have any visibility decorators\r\napplied to it.\r\n\r\nThe modifiers passed to this decorator _MUST_ be members of the target Enum.\r\n```typespec\r\n@defaultVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Enum`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | the list of modifiers to use as the default visibility modifiers. |\n\n### `@discriminated` {#@discriminated}\n\nSpecify that this union is discriminated.\r\n```typespec\r\n@discriminated(options?: valueof DiscriminatedOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Union`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| options | [valueof `DiscriminatedOptions`](./built-in-data-types.md#DiscriminatedOptions) | Options to configure the serialization of the discriminated union. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@discriminated\r\nunion Pet{ cat: Cat, dog: Dog }\r\n\r\nmodel Cat { name: string, meow: boolean }\r\nmodel Dog { name: string, bark: boolean }\r\n```\r\nSerialized as:\r\n```json\r\n{\r\n  \"kind\": \"cat\",\r\n  \"value\": {\r\n    \"name\": \"Whiskers\",\r\n    \"meow\": true\r\n  }\r\n},\r\n{\r\n  \"kind\": \"dog\",\r\n  \"value\": {\r\n    \"name\": \"Rex\",\r\n    \"bark\": false\r\n  }\r\n}\r\n```\r\n\r\n##### Custom property names\r\n\r\n\r\n```typespec\r\n@discriminated(#{discriminatorPropertyName: \"dataKind\", envelopePropertyName: \"data\"})\r\nunion Pet{ cat: Cat, dog: Dog }\r\n\r\nmodel Cat { name: string, meow: boolean }\r\nmodel Dog { name: string, bark: boolean }\r\n```\r\nSerialized as:\r\n```json\r\n{\r\n  \"dataKind\": \"cat\",\r\n  \"data\": {\r\n    \"name\": \"Whiskers\",\r\n    \"meow\": true\r\n  }\r\n},\r\n{\r\n  \"dataKind\": \"dog\",\r\n  \"data\": {\r\n    \"name\": \"Rex\",\r\n    \"bark\": false\r\n  }\r\n}\r\n```\n\n### `@discriminator` {#@discriminator}\n\nSpecify the property to be used to discriminate this type.\r\n```typespec\r\n@discriminator(propertyName: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| propertyName | [valueof `string`](#string) | The property name to use for discrimination |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet{ kind: string }\r\n\r\nmodel Cat extends Pet {kind: \"cat\", meow: boolean}\r\nmodel Dog extends Pet  {kind: \"dog\", bark: boolean}\r\n```\n\n### `@doc` {#@doc}\n\nAttach a documentation string. Content support CommonMark markdown formatting.\r\n```typespec\r\n@doc(doc: valueof string, formatArgs?: {})\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n| formatArgs | `{}` | Record with key value pair that can be interpolated in the doc. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@doc(\"Represent a Pet available in the PetStore\")\r\nmodel Pet {}\r\n```\n\n### `@encode` {#@encode}\n\nSpecify how to encode the target type.\r\n```typespec\r\n@encode(encodingOrEncodeAs: Scalar | valueof string | EnumMember, encodedAs?: Scalar)\r\n```\r\n\r\n#### Target\r\n\r\n`Scalar | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| encodingOrEncodeAs | `Scalar` \\| `valueof string \\| EnumMember` | Known name of an encoding or a scalar type to encode as(Only for numeric types to encode as string). |\r\n| encodedAs | `Scalar` | What target type is this being encoded as. Default to string. |\r\n\r\n#### Examples\r\n##### offsetDateTime encoded with rfc7231\r\n\r\n\r\n```tsp\r\n@encode(\"rfc7231\")\r\nscalar myDateTime extends offsetDateTime;\r\n```\r\n\r\n##### utcDateTime encoded with unixTimestamp\r\n\r\n\r\n```tsp\r\n@encode(\"unixTimestamp\", int32)\r\nscalar myDateTime extends unixTimestamp;\r\n```\r\n\r\n##### encode numeric type to string\r\n\r\n\r\n```tsp\r\nmodel Pet {\r\n  @encode(string) id: int64;\r\n}\r\n```\n\n### `@encodedName` {#@encodedName}\n\nProvide an alternative name for this type when serialized to the given mime type.\r\n```typespec\r\n@encodedName(mimeType: valueof string, name: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| mimeType | [valueof `string`](#string) | Mime type this should apply to. The mime type should be a known mime type as described here https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types without any suffix (e.g. `+json`) |\r\n| name | [valueof `string`](#string) | Alternative name |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Certificate {\r\n  @encodedName(\"application/json\", \"exp\")\r\n  @encodedName(\"application/xml\", \"expiry\")\r\n  expireAt: int32;\r\n}\r\n```\r\n\r\n##### Invalid values\r\n\r\n\r\n```typespec\r\n@encodedName(\"application/merge-patch+json\", \"exp\")\r\n             ^ error cannot use subtype\r\n```\n\n### `@error` {#@error}\n\nSpecify that this model is an error type. Operations return error types when the operation has failed.\r\n```typespec\r\n@error\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@error\r\nmodel PetStoreError {\r\n  code: string;\r\n  message: string;\r\n}\r\n```\n\n### `@errorsDoc` {#@errorsDoc}\n\nAttach a documentation string to describe the error return types of an operation.\r\nIf an operation returns a union of success and errors it only describes the errors. See `@returnsDoc` for success documentation.\r\n```typespec\r\n@errorsDoc(doc: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@errorsDoc(\"Errors doc\")\r\nop get(): Pet | NotFound;\r\n```\n\n### `@example` {#@example}\n\nProvide an example value for a data type.\r\n```typespec\r\n@example(example: valueof unknown, options?: valueof ExampleOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Scalar | Union | ModelProperty | UnionVariant`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| example | `valueof unknown` | Example value. |\r\n| options | [valueof `ExampleOptions`](./built-in-data-types.md#ExampleOptions) | Optional metadata for the example. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@example(#{name: \"Fluffy\", age: 2})\r\nmodel Pet {\r\n name: string;\r\n age: int32;\r\n}\r\n```\n\n### `@firstLink` {#@firstLink}\n\nPagination property defining a link to the first page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@firstLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@format` {#@format}\n\nSpecify a known data format hint for this string type. For example `uuid`, `uri`, etc.\r\nThis differs from the `@pattern` decorator which is meant to specify a regular expression while `@format` accepts a known format name.\r\nThe format names are open ended and are left to emitter to interpret.\r\n```typespec\r\n@format(format: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| format | [valueof `string`](#string) | format name. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@format(\"uuid\")\r\nscalar uuid extends string;\r\n```\n\n### `@friendlyName` {#@friendlyName}\n\nSpecifies how a templated type should name their instances.\r\n```typespec\r\n@friendlyName(name: valueof string, formatArgs?: unknown)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| name | [valueof `string`](#string) | name the template instance should take |\r\n| formatArgs | `unknown` | Model with key value used to interpolate the name |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@friendlyName(\"{name}List\", T)\r\nmodel List<Item> {\r\n  value: Item[];\r\n  nextLink: string;\r\n}\r\n```\n\n### `@inspectType` {#@inspectType}\n\nA debugging decorator used to inspect a type.\r\n```typespec\r\n@inspectType(text: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| text | [valueof `string`](#string) | Custom text to log |\n\n### `@inspectTypeName` {#@inspectTypeName}\n\nA debugging decorator used to inspect a type name.\r\n```typespec\r\n@inspectTypeName(text: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| text | [valueof `string`](#string) | Custom text to log |\n\n### `@invisible` {#@invisible}\n\nIndicates that a property is not visible in the given visibility class.\r\n\r\nThis decorator removes all active visibility modifiers from the property within\r\nthe given visibility class, making it invisible to any context that selects for\r\nvisibility modifiers within that class.\r\n```typespec\r\n@invisible(visibilityClass: Enum)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilityClass | `Enum` | The visibility class to make the property invisible within. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Example {\r\n  @invisible(Lifecycle)\r\n  hidden_property: string;\r\n}\r\n```\n\n### `@key` {#@key}\n\nMark a model property as the key to identify instances of that type\r\n```typespec\r\n@key(altName?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| altName | [valueof `string`](#string) | Name of the property. If not specified, the decorated property name is used. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Pet {\r\n  @key id: string;\r\n}\r\n```\n\n### `@lastLink` {#@lastLink}\n\nPagination property defining a link to the last page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@lastLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@list` {#@list}\n\nMark this operation as a `list` operation that returns a paginated list of items.\r\n```typespec\r\n@list\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\nNone\n\n### `@maxItems` {#@maxItems}\n\nSpecify the maximum number of items this array should have.\r\n```typespec\r\n@maxItems(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown[] | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Maximum number |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxItems(5)\r\nmodel Endpoints is string[];\r\n```\n\n### `@maxLength` {#@maxLength}\n\nSpecify the maximum length this string type should be.\r\n```typespec\r\n@maxLength(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Maximum length |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxLength(20)\r\nscalar Username extends string;\r\n```\n\n### `@maxValue` {#@maxValue}\n\nSpecify the maximum value this numeric type should be.\r\n```typespec\r\n@maxValue(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Maximum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxValue(200)\r\nscalar Age is int32;\r\n```\n\n### `@maxValueExclusive` {#@maxValueExclusive}\n\nSpecify the maximum value this numeric type should be, exclusive of the given\r\nvalue.\r\n```typespec\r\n@maxValueExclusive(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Maximum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxValueExclusive(50)\r\nscalar distance is float64;\r\n```\n\n### `@mediaTypeHint` {#@mediaTypeHint}\n\nApplies a media type hint to a TypeSpec type. Emitters and libraries may choose to use this hint to determine how a\r\ntype should be serialized. For example, the `@typespec/http` library will use the media type hint of the response\r\nbody type as a default `Content-Type` if one is not explicitly specified in the operation.\r\n\r\nMedia types (also known as MIME types) are defined by RFC 6838. The media type hint should be a valid media type\r\nstring as defined by the RFC, but the decorator does not enforce or validate this constraint.\r\n\r\nNotes: the applied media type is _only_ a hint. It may be overridden or not used at all. Media type hints are\r\ninherited by subtypes. If a media type hint is applied to a model, it will be inherited by all other models that\r\n`extend` it unless they delcare their own media type hint.\r\n```typespec\r\n@mediaTypeHint(mediaType: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Scalar | Enum | Union`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| mediaType | [valueof `string`](#string) | The media type hint to apply to the target type. |\r\n\r\n#### Examples\r\n##### create a model that serializes as XML by default\r\n\r\n\r\n```tsp\r\n@mediaTypeHint(\"application/xml\")\r\nmodel Example {\r\n  @visibility(Lifecycle.Read)\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n```\n\n### `@minItems` {#@minItems}\n\nSpecify the minimum number of items this array should have.\r\n```typespec\r\n@minItems(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown[] | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Minimum number |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minItems(1)\r\nmodel Endpoints is string[];\r\n```\n\n### `@minLength` {#@minLength}\n\nSpecify the minimum length this string type should be.\r\n```typespec\r\n@minLength(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Minimum length |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minLength(2)\r\nscalar Username extends string;\r\n```\n\n### `@minValue` {#@minValue}\n\nSpecify the minimum value this numeric type should be.\r\n```typespec\r\n@minValue(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Minimum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minValue(18)\r\nscalar Age is int32;\r\n```\n\n### `@minValueExclusive` {#@minValueExclusive}\n\nSpecify the minimum value this numeric type should be, exclusive of the given\r\nvalue.\r\n```typespec\r\n@minValueExclusive(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Minimum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minValueExclusive(0)\r\nscalar distance is float64;\r\n```\n\n### `@nextLink` {#@nextLink}\n\nPagination property defining a link to the next page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@nextLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@offset` {#@offset}\n\nPagination property defining the number of items to skip.\r\n```typespec\r\n@offset\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@offset skip: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@opExample` {#@opExample}\n\nProvide example values for an operation's parameters and corresponding return type.\r\n```typespec\r\n@opExample(example: valueof OperationExample, options?: valueof ExampleOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| example | [valueof `OperationExample`](./built-in-data-types.md#OperationExample) | Example value. |\r\n| options | [valueof `ExampleOptions`](./built-in-data-types.md#ExampleOptions) | Optional metadata for the example. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@opExample(#{parameters: #{name: \"Fluffy\", age: 2}, returnType: #{name: \"Fluffy\", age: 2, id: \"abc\"})\r\nop createPet(pet: Pet): Pet;\r\n```\n\n### `@overload` {#@overload}\n\nSpecify this operation is an overload of the given operation.\r\n```typespec\r\n@overload(overloadbase: Operation)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| overloadbase | `Operation` | Base operation that should be a union of all overloads |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(data: string | bytes, @header contentType: \"text/plain\" | \"application/octet-stream\"): void;\r\n@overload(upload)\r\nop uploadString(data: string, @header contentType: \"text/plain\" ): void;\r\n@overload(upload)\r\nop uploadBytes(data: bytes, @header contentType: \"application/octet-stream\"): void;\r\n```\n\n### `@pageIndex` {#@pageIndex}\n\nPagination property defining the page index.\r\n```typespec\r\n@pageIndex\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@pageItems` {#@pageItems}\n\nSpecify the the property that contains the array of page items.\r\n```typespec\r\n@pageItems\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@pageSize` {#@pageSize}\n\nSpecify the pagination parameter that controls the maximum number of items to include in a page.\r\n```typespec\r\n@pageSize\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@parameterVisibility` {#@parameterVisibility}\n\nDeclares the visibility constraint of the parameters of a given operation.\r\n\r\nA parameter or property nested within a parameter will be visible if it has _any_ of the visibilities\r\nin the list.\r\n\r\nIt is invalid to call this decorator with no visibility modifiers.\r\n```typespec\r\n@parameterVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibility modifiers that apply to the parameters of this operation. |\n\n### `@pattern` {#@pattern}\n\nSpecify the the pattern this string should respect using simple regular expression syntax.\r\nThe following syntax is allowed: alternations (`|`), quantifiers (`?`, `*`, `+`, and `{ }`), wildcard (`.`), and grouping parentheses.\r\nAdvanced features like look-around, capture groups, and references are not supported.\r\n\r\nThis decorator may optionally provide a custom validation _message_. Emitters may choose to use the message to provide\r\ncontext when pattern validation fails. For the sake of consistency, the message should be a phrase that describes in\r\nplain language what sort of content the pattern attempts to validate. For example, a complex regular expression that\r\nvalidates a GUID string might have a message like \"Must be a valid GUID.\"\r\n```typespec\r\n@pattern(pattern: valueof string, validationMessage?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`string | bytes | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| pattern | [valueof `string`](#string) | Regular expression. |\r\n| validationMessage | [valueof `string`](#string) | Optional validation message that may provide context when validation fails. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@pattern(\"[a-z]+\", \"Must be a string consisting of only lower case letters and of at least one character.\")\r\nscalar LowerAlpha extends string;\r\n```\n\n### `@prevLink` {#@prevLink}\n\nPagination property defining a link to the previous page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@prevLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@removeVisibility` {#@removeVisibility}\n\nRemoves visibility modifiers from a property.\r\n\r\nIf the visibility modifiers for a visibility class have not been initialized,\r\nthis decorator will use the default visibility modifiers for the visibility\r\nclass as the default modifier set.\r\n```typespec\r\n@removeVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\nThe property to remove visibility from.\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | The visibility modifiers to remove from the target property. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Example {\r\n  // This property will have all Lifecycle visibilities except the Read\r\n  // visibility, since it is removed.\r\n  @removeVisibility(Lifecycle.Read)\r\n  secret_property: string;\r\n}\r\n```\n\n### `@returnsDoc` {#@returnsDoc}\n\nAttach a documentation string to describe the successful return types of an operation.\r\nIf an operation returns a union of success and errors it only describes the success. See `@errorsDoc` for error documentation.\r\n```typespec\r\n@returnsDoc(doc: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@returnsDoc(\"Returns doc\")\r\nop get(): Pet | NotFound;\r\n```\n\n### `@returnTypeVisibility` {#@returnTypeVisibility}\n\nDeclares the visibility constraint of the return type of a given operation.\r\n\r\nA property within the return type of the operation will be visible if it has _any_ of the visibilities\r\nin the list.\r\n\r\nIt is invalid to call this decorator with no visibility modifiers.\r\n```typespec\r\n@returnTypeVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibility modifiers that apply to the return type of this operation. |\n\n### `@secret` {#@secret}\n\nMark this string as a secret value that should be treated carefully to avoid exposure\r\n```typespec\r\n@secret\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@secret\r\nscalar Password is string;\r\n```\n\n### `@service` {#@service}\n\nMark this namespace as describing a service and configure service properties.\r\n```typespec\r\n@service(options?: valueof ServiceOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| options | [valueof `ServiceOptions`](./built-in-data-types.md#ServiceOptions) | Optional configuration for the service. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\nnamespace PetStore;\r\n```\r\n\r\n##### Setting service title\r\n\r\n```typespec\r\n@service(#{title: \"Pet store\"})\r\nnamespace PetStore;\r\n```\r\n\r\n##### Setting service version\r\n\r\n```typespec\r\n@service(#{version: \"1.0\"})\r\nnamespace PetStore;\r\n```\n\n### `@summary` {#@summary}\n\nTypically a short, single-line description.\r\n```typespec\r\n@summary(summary: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| summary | [valueof `string`](#string) | Summary string. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@summary(\"This is a pet\")\r\nmodel Pet {}\r\n```\n\n### `@tag` {#@tag}\n\nAttaches a tag to an operation, interface, or namespace. Multiple `@tag` decorators can be specified to attach multiple tags to a TypeSpec element.\r\n```typespec\r\n@tag(tag: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| tag | [valueof `string`](#string) | Tag value |\n\n### `@visibility` {#@visibility}\n\nSets the visibility modifiers that are active on a property, indicating that it is only considered to be present\r\n(or \"visible\") in contexts that select for the given modifiers.\r\n\r\nA property without any visibility settings applied for any visibility class (e.g. `Lifecycle`) is considered to have\r\nthe default visibility settings for that class.\r\n\r\nIf visibility for the property has already been set for a visibility class (for example, using `@invisible` or\r\n`@removeVisibility`), this decorator will **add** the specified visibility modifiers to the property.\r\n\r\nSee: [Visibility](https://typespec.io/docs/language-basics/visibility)\r\n\r\nThe `@typespec/http` library uses `Lifecycle` visibility to determine which properties are included in the request or\r\nresponse bodies of HTTP operations. By default, it uses the following visibility settings:\r\n\r\n- For the return type of operations, properties are included if they have `Lifecycle.Read` visibility.\r\n- For POST operation parameters, properties are included if they have `Lifecycle.Create` visibility.\r\n- For PUT operation parameters, properties are included if they have `Lifecycle.Create` or `Lifecycle.Update` visibility.\r\n- For PATCH operation parameters, properties are included if they have `Lifecycle.Update` visibility.\r\n- For DELETE operation parameters, properties are included if they have `Lifecycle.Delete` visibility.\r\n- For GET or HEAD operation parameters, properties are included if they have `Lifecycle.Query` visibility.\r\n\r\nBy default, properties have all five Lifecycle visibility modifiers enabled, so a property is visible in all contexts\r\nby default.\r\n\r\nThe default settings may be overridden using the `@returnTypeVisibility` and `@parameterVisibility` decorators.\r\n\r\nSee also: [Automatic visibility](https://typespec.io/docs/libraries/http/operations#automatic-visibility)\r\n```typespec\r\n@visibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type |\n\nBy default, properties have all five Lifecycle visibility modifiers enabled, so a property is visible in all contexts\r\nby default.\r\n\r\nThe default settings may be overridden using the `@returnTypeVisibility` and `@parameterVisibility` decorators.\r\n\r\nSee also: [Automatic visibility](https://typespec.io/docs/libraries/http/operations#automatic-visibility)\r\n```typespec\r\n@visibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibilities which apply to this property. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  // The service will generate an ID, so you don't need to send it.\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // The service will store this secret name, but won't ever return it.\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  // The regular name has all vi\r\n  name: string;\r\n}\r\n```\n\n### `@withDefaultKeyVisibility` {#@withDefaultKeyVisibility}\n\nSet the visibility of key properties in a model if not already set.\r\n\r\nThis will set the visibility modifiers of all key properties in the model if the visibility is not already _explicitly_ set,\r\nbut will not change the visibility of any properties that have visibility set _explicitly_, even if the visibility\r\nis the same as the default visibility.\r\n\r\nVisibility may be set explicitly using any of the following decorators:\r\n\r\n- `@visibility`\r\n- `@removeVisibility`\r\n- `@invisible`\r\n```typespec\r\n@withDefaultKeyVisibility(visibility: valueof EnumMember)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibility | `valueof EnumMember` | The desired default visibility value. If a key property already has visibility set, it will not be changed. |\n\n### `@withLifecycleUpdate` {#@withLifecycleUpdate}\n\nTransforms the `target` model to include only properties that are visible during the\r\n\"Update\" lifecycle phase.\r\n\r\nAny nested models of optional properties will be transformed into the \"CreateOrUpdate\"\r\nlifecycle phase instead of the \"Update\" lifecycle phase, so that nested models may be\r\nfully updated.\r\n```typespec\r\n@withLifecycleUpdate\r\n```\r\n\r\n#### Target\r\nThe model to apply the transformation to.\r\n`Model`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@withLifecycleUpdate\r\nmodel DogUpdate {\r\n  ...Dog\r\n}\r\n```\n\n### `@withOptionalProperties` {#@withOptionalProperties}\n\nReturns the model with required properties removed.\r\n```typespec\r\n@withOptionalProperties\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\nNone\n", "latency": 9.937919855117798, "response_length": 909}
{"query": "title: Versioning the body of a route\n\nquestion: We added a post route called align in our last preview version, 2025-03-01-preview\n```\n@action(\"align\")\n@added(APIVersions.v2025_03_01_preview)\nalignDevBox is DevCenterOps.LongRunningResourceAction<\nDevBox,\n{}, // Body of the POST request\nOperationStatus\n>;\n```\nHowever, now we need to change it from no body (i.e parameter 2, {}) into taking in one in our new preview API version, 2025-04-01-preview\nFull example\n```\n@action(\"align\")\n@added(APIVersions.v2025_03_01_preview)\nalignDevBox is DevCenterOps.LongRunningResourceAction<\nDevBox,\nAlignBody, // Went from no body, to taking in this new model\nOperationStatus\n>;\n```\nThis returns error message DevCenterService.DevBoxes.alignDevBox' was added in version 'v2025_03_01_preview' but referencing type 'DevCenterService.AlignBody' added in version 'v2025_04_01_preview'.\nHowever, we don't see a way to version a parameter. What would be the best course of action here?", "ground_truth": "The team decided to open an issue for allowing versioning on body parameter of a route/operation in TypeSpec.\n[Issue](https://github.com/microsoft/typespec/issues/7032)", "response": "The error occurs because the `AlignBody` type was added in the newer API version (`v2025_04_01_preview`), but the `alignDevBox` action was originally defined in the older version (`v2025_03_01_preview`). Since TypeSpec does not support versioning individual parameters directly, the recommended approach is to create a new action for the updated version of the route. This ensures backward compatibility and avoids conflicts between versions.\n\nHeres how you can define the new action:\n\n```typescript\n@action(\"align\")\n@added(APIVersions.v2025_04_01_preview)\nalignDevBoxWithBody is DevCenterOps.LongRunningResourceAction<\n  DevBox,\n  AlignBody, // New body model for the updated version\n  OperationStatus\n>;\n```\n\nThis approach keeps the original `alignDevBox` action intact for the older version (`v2025_03_01_preview`) and introduces a new action (`alignDevBoxWithBody`) for the newer version (`v2025_04_01_preview`). This ensures that clients using the older version of the API can continue to use the route without a body, while clients using the newer version can utilize the updated functionality with the `AlignBody` model.", "context": "- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step09.md\n- document_title: 9. Customizing operations with traits\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step09\n- document_content: # getstarted#azure-core#step09.md\n\n# 9. Customizing operations with traits\n\nFor all standard lifecycle operations you can customize the operation parameters and response body by passing a special model type to the `Traits` parameter of the operation template, typically the second parameter of the operation template. You can also customize the whole set of resource operations by passing traits to the `ResourceOperations` interface.\r\n\r\nYou can combine multiple traits using the model intersection operator `&`. Here's an example of defining the `ServiceTraits` with `SupportsRepeatableRequests`, `SupportsConditionalRequests` and `SupportsClientRequestId`. These are then passed into the `Azure.Core.ResourceOperations` template:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = Azure.Core.ResourceOperations<ServiceTraits>;\r\n```\r\n\r\nTraits can be applied simultaneously at both the interface and operation level, they will be composed together when your operation is defined.\r\n\r\nFor example, if you wanted to add standard list operation query parameters to the `listWidgets` operation, you could use the `ListQueryParametersTrait`:\r\n\r\n```typespec\r\n/** List Widget resources */\r\nop listWidgets is Operations.ResourceList<\r\n  Widget,\r\n  ListQueryParametersTrait<StandardListQueryParameters & SelectQueryParameter>\r\n>;\r\n```\n\n## Useful trait types\n\nThe following trait types can be used for typical operation customization patterns:\n\n### `QueryParametersTrait<TParams, Contexts>`\n\nThis trait adds query parameters to operation signatures. It accepts a model type containing the query parameters that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is Operations.ResourceRead<\r\n  Widget,\r\n  QueryParametersTrait<{\r\n    @query foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@query` or an error will be raised.\r\n\r\nThe `Contexts` parameter is configured to apply the query parameters to all operations by default.\r\n\r\nTo constrain the types of operations that these query parameters will apply to, pass one ore more of the following values:\r\n\r\n- **TraitContext.Read**: Applies to read operations\r\n- **TraitContext.Create**: Applies to create operations\r\n- **TraitContext.Update**: Applies to update operations\r\n- **TraitContext.Delete**: Applies to delete operations\r\n- **TraitContext.List**: Applies to list operations\r\n- **TraitContext.Action**: Applies to custom action operations\r\n\r\nHere is an example of applying query parameters to `Read` and `List` operations:\r\n\r\n```typespec\r\nalias MyQueryParams = QueryParametersTrait<\r\n  {\r\n    @query foo: string;\r\n  },\r\n  TraitContext.Read | TraitContext.List\r\n>;\r\n\r\n// This will have a `foo` parameter added\r\nop getWidget is Operations.ResourceRead<Widget, MyQueryParams>;\r\n\r\n// This will not get the `foo` parameter because it doesn't match the contexts\r\nop deleteWidget is Operations.ResourceDelete<\r\n  Widget,\r\n  QueryParametersTrait<{\r\n    @query foo: string;\r\n  }>\r\n>;\r\n```\n\n### `ListQueryParametersTrait<TParams>`\n\nThis is a helper trait that specialized `QueryParametersTrait` to the `TraitContext.List` context. For example:\r\n\r\n```typespec\r\nalias MyListQueryParams = ListQueryParametersTrait<{\r\n  @query foo: string;\r\n}>;\r\n\r\n// Will get the `foo` parameter\r\nop listWidgets is Operations.ResourceList<Widget, MyListQueryParams>;\r\n\r\n// Will not get the `foo` parameter\r\nop deleteWidget is Operations.ResourceDelete<Widget, MyListQueryParams>;\r\n```\n\n### `RequestHeadersTrait<TParams, Contexts>`\n\nThis trait adds request headers to operation signatures. It accepts a model type containing the request headers that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is ResourceRead<\r\n  Widget,\r\n  RequestHeadersTrait<{\r\n    @header foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@header` or an error will be raised.\r\n\r\nYou can specify `Contexts` where this trait applies in the way as described for the `QueryParametersTrait`.\n\n### `ResponseHeadersTrait<TParams, Contexts>`\n\nThis trait adds response headers to operation signatures. It accepts a model type containing the response headers that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is ResourceRead<\r\n  Widget,\r\n  ResponseHeadersTrait<{\r\n    @header foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@header` or an error will be raised.\r\n\r\nYou can specify `Contexts` where this trait applies in the way as described for the `QueryParametersTrait`.\n\n## Applying traits to all resource operations\n\nIf you would like to apply the same traits to all resource operations, you can do so by adding them to the traits object for your instance of the `ResourceOperations` interface. Here's an example of adding a request header called `foo` to all resource operations:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId &\r\n  RequestHeadersTrait<{\r\n    @header foo: string;\r\n  }>;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n\r\nop deleteWidget is Operations.ResourceDelete<Widget>;\r\n```\r\n\r\nThis defines `deleteWidget` by using the `ResourceDelete` template defined inside of your customized `Operations` interface.\r\n\r\n**IMPORTANT NOTE:** The `ResourceOperations` interface requires that an explicit set of traits be included to describe whether certain Azure service features are supported.\r\n\r\nHere is the list of the required traits with the names of the trait models to enable and disable those features:\r\n\r\n- **RepeatableRequests**: `SupportsRepeatableRequests` and `NoRepeatableRequests`\r\n- **ConditionalRequests**: `SupportsConditionalRequests` and `NoConditionalRequests`\r\n- **ClientRequestId**: `SupportsClientRequestId` and `NoClientRequestId`\n\n## Customizing the API version parameter\n\nYou can use the `VersionParameterTrait` to customize the API version parameter for resource operations, either at the level of interface or individual operation. To do this, use the `TraitOverride` type to override the existing `api-version` query parameter:\r\n\r\n```typespec\r\n/** The ApiVersion path parameter. */\r\nmodel ApiVersionPathParameter {\r\n  /** The API version to use for this operation. */\r\n  @segment(\"api\")\r\n  @path(\"api-version\")\r\n  apiVersion: string;\r\n}\r\n\r\nop deleteWidget is ResourceDelete<\r\n  Widget,\r\n  TraitOverride<VersionParameterTrait<ApiVersionPathParameter>>\r\n>;\r\n```\r\n\r\nUsing the `TraitOverride` modifier with the `VersionParameterTrait<ApiVersionPathParameter>` causes any existing `VersionParameterTrait` instances in the operation signature to be overridden by the one you have supplied.\r\n\r\nThis will result in an operation that has the route path `/api/{apiVersion}/widgets/{widgetName}` while also removing the old `api-version` query parameter from the operation signature.\n\n## Versioning the use of traits\n\nIt is possible that a service will begin to support a particular feature or trait in a later version. There are two ways to express that a trait is being added in a later service version:\n\n### Using the `TVersionAdded` parameter of some trait types\n\n> **NOTE:** Versioning of Azure Core service specifications is covered in more detail on [this page](https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10).\r\n\r\nSome standard trait types accept an optional `TVersionAdded` parameter which enables you to specify the service version enum representing the version where support for this trait is added:\r\n\r\n- `SupportsClientRequestId`\r\n- `SupportsRepeatableRequests`\r\n- `SupportsConditionalRequests`\r\n\r\nHere is an example of adding support for repeatable requests in a later service version:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_08_31: \"v20220831\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"v20221130\",\r\n}\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests<Versions.v2022_11_30> &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n```\n\n### Define a custom trait and add the `@traitAdded` decorator\n\nBuilding on the previous example, we can add a custom header trait at a later service version using the `@traitAdded` decorator:\r\n\r\n```typespec\r\n/** A custom trait added at a later service version. */\r\n@traitAdded(Versions.v2022_11_30)\r\nmodel CustomRequestHeadersTrait\r\n  is RequestHeadersTrait<{\r\n    @TypeSpec.Http.header foo: string;\r\n  }>;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests<Versions.v2022_11_30> &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId &\r\n  CustomRequestHeadersTrait;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#09versioning.mdx\n- document_title: Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/09versioning\n- document_content: # howtos#generate-client-libraries#09versioning.mdx\n\n# Versioning\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis doc details what emitters will generate for versioned specs\n\n## Single api Version\n\nIf there is just one api version in the spec, we will generate the api surface area for that one version.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\nstatic ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01\")\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\nwith pytest.expect(ImportError):\r\n  preview_model = models.PreviewModel(preview_functionality=\"not present\")\r\n\r\nwith pytest.expect(AttributeError):\r\n  client.preview_functionality({\"previewFunctionality\": \"not present\"})\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api-version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\n//neither PreviewModel nor PreviewFunctionality will be generated\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n# python allows you to override the api version, even if only one version is defined in the spec\n\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01\"\r\n```\r\n\r\n```typescript\r\n// there's no apiVersion defined in the all the operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n## Multiple api versions\n\nThe configuration flag `api-version` allows you to toggle the behavior that our emitters will generate.\r\n\r\nWe will get the versioning information from the `Versions` enum that you pass to the `@versioned` decorator from the `@typespec/versioning` library.\r\n\r\n> NOTE: The ordering of the values in the `Versions` enum is very important. We use this information to determine the order of versions. Our default value will be the **last entry** in the `Versions` list\n\n### Default\n\nBy default our emitters will only generate the surface used by the latest api version if there are multiple defined. This includes generating only the models used in the surface area of the latest api version.\r\n\r\nDocumentation and enums showing the available api versions will still include all of the known api versions, meaning there will be documentation for both the preview and stable releases.\r\n\r\nFor the below example, all languages will generate the api surface of default version `v2023_11_01`. There will be no generation of the operation `previewFunctionality`, and we will also not generate the `PreviewModel` because it's only used in `previewFunctionality`, and therefore is not used in the api surface of `v2023_11_01`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\n### Override to a specific version\n\nYou can override the signature to return the api surface area for a specific api version.\r\n\r\nIn this example, you can see how this change is made in tspconfig.yaml, and we are going to override to return the preview api surface area for our spec. The preview api surface area contains all of the functionality.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01-preview\"\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\npreview_client.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\n# the model is generated as part of the api surface\n\npreview_client.preview_functionality(preview_model) # call goes through\r\n\r\n````\r\n\r\n```csharp\r\n// ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n// client's api-version will be \"2023-11-01-preview\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n````\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01_PREVIEW(\"2023-11-01-preview\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01_PREVIEW\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01-preview\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\nPreviewModel previewModel = new PreviewModel(\"present\");\r\n// call goes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\n\ngoes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01_Preview);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01-preview\"\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n### Override to return all\n\nYou can also override the signature to return the combined api surface area of all of the separate api versions. Different languages have different support for versioning validation.\r\n\r\nIn the following examples, you can observe how this change is made in `tspconfig.yaml`.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n## Overriding the Client Api Version Parameter\n\nonto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient clientWithSpecifiedApiVersion = new ServiceClient(endpoint, options);\r\n//client's version will be \"2023-11-01\"\r\nResponse response = client.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n    V2024_04_01(\"2024-04-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2024_04_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient client = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's version will be 2024-04-01\r\n\r\nServiceClientClient clientWithSpecifiedApiVersion = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    .buildClient();\r\n// client's version will be 2023-11-01\r\n\r\nclient.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```go\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n\nBy default, we find api version parameters in specs based off of names. There is special logic we do with api version parameters:\r\n\r\n1. These api version parameters get elevated up to the client level (if the service is versioned)\r\n2. We auto-add api version information to next links when paging\r\n3. We set the client default for these parameters to be the default api version for your service.\r\n\r\nThere are cases where you have an api-versioning parameter without the explicit name `api-version`. In these cases, you can use the `@isApiVersion` decorator to override and explicitly say whether that parameter is an api version param or not.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\nusing Versioning;\r\nusing Http;\r\nusing Azure.ClientGenerator.Core;\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n  v2024_04_01: \"2024-04-01\",\r\n}\r\nop get(\r\n  @isApiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\r\n\r\n```python\r\nfrom my.service import MyServiceClient\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\r\nprint(client.version) # == \"2024-04-01\", since that is the default\r\n\r\nclient_with_specified_api_version = MyServiceClient(endpoint=..., credential=..., version=\"2023-11-01\")\r\nprint(client.version) # == \"2023-11-01\", since we specified\r\n\r\nretval = client.get() # version is elevated onto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\n", "latency": 10.753943681716919, "response_length": 1128}
{"query": "title: GraphQL emitters\n\nquestion: Is anyone working on GraphQL client/server emitters?", "ground_truth": "yeah I think they work on this repo https://github.com/pinterest/typespec/tree/feature/graphql, they started working on a branch of microsoft/typespec but the friction was a bit too much", "response": "Currently, there is no specific mention in the provided documentation about GraphQL client/server emitters being actively developed for TypeSpec. However, TypeSpec does support various client emitters for HTTP-based APIs, including JavaScript, Python, Java, and C#. These emitters are in preview and focus on generating HTTP clients from TypeSpec definitions. Additionally, the TypeSpec Client Generator Core (TCGC) provides abstractions for client emitters, which could potentially be extended to support GraphQL emitters in the future. If you are looking for GraphQL-specific emitters, you may need to explore custom implementations or check for updates in the TypeSpec ecosystem.", "context": "- document_dir: typespec_docs\n- document_filename: emitters#clients#introduction.mdx\n- document_title: Client Emitters\n- document_link: https://typespec.io/docs/emitters/clients/introduction\n- document_content: # emitters#clients#introduction.mdx\n\n# Client Emitters\n\nimport { Aside, Steps } from \"@astrojs/starlight/components\";\n\n## How to Use Emitters to Generate HTTP Clients from TypeSpec\n\n### Introduction\n\nThis guide will walk you through the process of using different client emitters (JavaScript, Python, Java, C#) to generate HTTP clients from TypeSpec. Please note that all client emitters are currently in **preview** and are subject to changes in future versions.\r\n\r\nBy following this guide, you will learn:\r\n\r\n1. How to set up client emitters in `package.json`.\r\n2. Update the client emitter configurations in `tspconfig.yaml`.\r\n3. How to generate HTTP clients for each specific programming language.\n\n## Location of All Client Emitters\n\nThe client emitters are defined in the `package.json` file within your project.\r\n\r\n| **Emitter Name**             | **Language** | **Version**                                                    |\r\n| ---------------------------- | ------------ | -------------------------------------------------------------- |\r\n| @typespec/http-client-js     | JavaScript   | ![](https://img.shields.io/npm/v/@typespec/http-client-js)     |\r\n| @typespec/http-client-python | Python       | ![](https://img.shields.io/npm/v/@typespec/http-client-python) |\r\n| @typespec/http-client-java   | Java         | ![](https://img.shields.io/npm/v/@typespec/http-client-java)   |\r\n| @typespec/http-client-csharp | C#           | ![](https://img.shields.io/npm/v/@typespec/http-client-csharp) |\r\n\r\nBelow is an example of the `package.json` snippet where client emitters are defined:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\",\r\n    \"@typespec/http-client-java\": \"^0.1.9\",\r\n    \"@typespec/http-client-python\": \"^0.6.6\",\r\n    \"@typespec/http-client-js\": \"^0.38.1\",\r\n  }\r\n```\n\n## Client Emitter Settings\n\nThis part provides an overview of the common and language-specific settings for each client emitter. These settings are stored in the `tspconfig.yaml` file.\n\n### Common Configuration Options\n\nThe below option applies to all client emitters.\r\n\r\n- `emitter-output-dir`: Defines where the generated SDK files will be stored.\n\n### JavaScript Client Emitter Settings\n\nJavaScript generally requires minimal configuration. However, it is recommended to provide `packageDetails` for package metadata, which is used in `package.json` and `README.md` files.\r\n\r\n#### packageDetails\r\n\r\nProvide the metadata for `package.json`, `README.md` information.\r\n\r\n| Property    | Description                                                            |\r\n| ----------- | ---------------------------------------------------------------------- |\r\n| name        | Package name used in `package.json`                                    |\r\n| description | Package description used in `package.json` file                        |\r\n| version     | Detailed version for your package, the default value is `1.0.0-beta.1` |\r\n\r\nExample configuration:\r\n\r\n```yaml\r\npackageDetails:\r\n  name: \"${your_package_name}\"\r\n  version: 1.0.0\r\n```\n\n### Java Client Emitter Settings\n\n#### Prerequisites\r\n\r\nBefore using the Java client emitter, ensure the following dependencies are installed:\r\n\r\n- **Java 17 or later** - [Download here](https://docs.microsoft.com/java/openjdk/download)  \r\n  _(Verify installation with `java --version`)_\r\n- **Maven** - [Download here](https://maven.apache.org/download.cgi)  \r\n  _(Verify installation with `mvn --version`)_\n\n### C# Client Emitter Settings\n\nBefore using the C# client emitter, ensure that the [.NET 8.0 SDK](https://dotnet.microsoft.com/en-us/download/dotnet/8.0) (or higher) is installed.\r\nFull configuration options can be found in the [C# Client Emitter README](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md#configuration)\n\n## JavaScript Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-js\": \"^0.38.1\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-js\"\r\noptions:\r\n  \"@typespec/http-client-js\":\r\n    emitter-output-dir: \"{project-root}/clients/javascript\"\r\n    packageDetails:\r\n      name: \"your_package_name\"\r\n      version: 1.0.0\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the JavaScript client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Python Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-python\": \"^0.6.6\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-python\"\r\noptions:\r\n  \"@typespec/http-client-python\":\r\n    emitter-output-dir: \"{project-root}/clients/python\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Python client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Java Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-java\": \"^0.1.9\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-java\"\r\noptions:\r\n  \"@typespec/http-client-java\":\r\n    emitter-output-dir: \"{project-root}/clients/java\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Java client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## C# Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-csharp\"\r\noptions:\r\n  \"@typespec/http-client-csharp\":\r\n    emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the C# client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Running Language-Specific Emitters in CLI\n\n<Steps>\r\n\r\n1. Ensure that your package.json file is correctly configured to include the necessary dependencies for running the emitters\r\n\r\n2. Update the tspconfig.yaml file for properly configured for the language-specific emitter.\r\n\r\n   ```yaml\r\n   emit:\r\n     - \"@typespec/http-client-csharp\"\r\n     - \"@typespec/http-client-java\"\r\n     - \"@typespec/http-client-python\"\r\n     - \"@typespec/http-client-js\"\r\n   options:\r\n     \"@typespec/http-client-csharp\":\r\n       emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n     \"@typespec/http-client-java\":\r\n       emitter-output-dir: \"{project-root}/clients/java\"\r\n     \"@typespec/http-client-python\":\r\n       emitter-output-dir: \"{project-root}/clients/python\"\r\n     \"@typespec/http-client-js\":\r\n       emitter-output-dir: \"{project-root}/clients/javascript\"\r\n   ```\r\n\r\n3. Once the package.json and tspconfig.yaml files are updated, you need to install all required dependencies by running the following command in the project root:\r\n\r\n   ```bash\r\n   tsp install\r\n   ```\r\n\r\n4. Run the emitter to compile your TypeScript code into the desired language. Use the following command to trigger the emitter and compile your project:\r\n\r\n   ```bash\r\n   tsp compile {path to main.tsp}/main.tsp\r\n   ```\r\n\r\n</Steps>\n\n## Disclaimer\n\n<Aside>\r\n\r\n**All client emitters are in preview**. These emitters are actively being developed and may experience changes or updates that could affect their functionality. Please follow the official documentation for the latest updates.\r\n\r\n- [TypeSpec C# emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md)\r\n- [TypeSpec Python emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-python/README.md)\r\n- [TypeSpec Java emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-java/README.md)\r\n- [TypeSpec JS emitter library](https://github.com/Azure/autorest.typescript/blob/main/packages/typespec-ts/README.md)\r\n\r\n</Aside>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#guideline.md\n- document_title: Guideline for Client Emitter\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/guideline\n- document_content: # libraries#typespec-client-generator-core#guideline.md\n\n# Guideline for Client Emitter\n\nThis document provides guidance on using the TypeSpec Client Generator Core (TCGC) in client emitters.  \r\nTCGC introduces a client type graph and provides helper functions for generating client code.  \r\nClient emitters can rely on the client type graph instead of directly interacting with the TypeSpec core API.\n\n## TCGC Library\n\nTCGC abstracts common logic for client emitters across languages, allowing emitters to focus solely on language-specific code generation.\n\n### Usage\n\nTo use TCGC, add it to your `package.json`:\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-client-generator-core\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\nIn your emitter's `$onEmit` function, use [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to convert [`EmitContext`](https://typespec.io/docs/standard-library/reference/js-api/interfaces/emitcontext/) into [`SdkContext`](../reference/js-api/interfaces/sdkcontext/). The [`SdkContext.SdkPackage`](../reference/js-api/interfaces/sdkpackage/) contains the client type graph. See [\"Client Type Graph\"](#client-type-graph) for details.\r\n\r\nIf your client emitter has options or global variables, extend [`SdkContext`](../reference/js-api/interfaces/sdkcontext/) with your custom emitter context. Example:\r\n\r\n```ts\r\nimport { EmitContext } from \"@typespec/compiler\";\r\nimport { createSdkContext } from \"@azure-tools/typespec-client-generator-core\";\r\n\r\ninterface PythonEmitterOptions extends SdkEmitterOptions {\r\n  // Options specific to the client emitter\r\n}\r\n\r\ninterface PythonSdkContext extends SdkContext<PythonEmitterOptions> {\r\n  // Global variables for the client emitter\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext<PythonEmitterOptions>) {\r\n  const emitterContext: PythonSdkContext = {\r\n    ...createSdkContext(context),\r\n    // Initialize global variables\r\n  };\r\n}\r\n```\n\n### Exporting TCGC Type Graph\n\nTCGC can be used as a standalone emitter to export the type graph for debugging. Run:  \r\n`tsp compile . --emit=@azure-tools/typespec-client-generator-core --options=@azure-tools/typespec-client-generator-core.emitter-name=\"<emitter-name>\"`  \r\nReplace `<emitter-name>` with your emitter name to generate the type graph file.\r\n\r\nAlternatively, pass the [`exportTCGCoutput`](../reference/js-api/interfaces/createsdkcontextoptions/) option to [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to generate the type graph file (`<output-dir>/tcgc-output.yaml`) alongside client code.\n\n### TCGC Playground\n\nUse the [TCGC Playground](https://azure.github.io/typespec-azure/playground/?e=%40azure-tools%2Ftypespec-client-generator-core) to experiment with how specifications translate to the TCGC client type graph. Include the playground link when asking questions or reporting issues.\n\n### TCGC Flags\n\nTCGC provides flags to control the client type graph style, such as enabling or disabling convenience APIs. See the [documentation](../reference/emitter/#emitter-options) for details.\n\n## Client Type Graph\n\n### Namespace\n\n[`SdkPackage`](../reference/js-api/interfaces/sdkpackage/) represents a client package, containing all clients, operations, and types.\r\n\r\nClients, models, enums, and unions include namespace information. Emitters can use either:\r\n\r\n- A flattened structure (`SdkPackage.clients`, `SdkPackage.enums`, `SdkPackage.models`, `SdkPackage.unions`)\r\n- A hierarchical structure (`SdkPackage.namespaces`) requiring iteration through nested namespaces.\r\n\r\nThe `namespace` property in TCGC types indicates the type's namespace.\n\n### License Information\n\nThe `licenseInfo` property in [`LicenseInfo`](../reference/js-api/interfaces/licenseinfo/) contains license details for client code comments or license file generation.\r\n\r\nIf `licenseInfo` is `undefined`, omit license information in the generated code or files.\r\n\r\nUse `licenseInfo.name` (license name), `licenseInfo.company` (company name), `licenseInfo.link` (license document link), `licenseInfo.header` (header comments), and `licenseInfo.description` (license file content) directly when generating license-related content.\r\n\r\nFor Azure services, emitters should hard-code the license configuration as follows:\r\n\r\n```typescript\r\nexport async function $onEmit(context: EmitContext<SdkEmitterOptions>) {\r\n  context.options.license = {\r\n    name: \"MIT License\",\r\n    company: \"Microsoft Corporation\",\r\n  };\r\n  const sdkContext = await createSdkContext(context);\r\n  // ...\r\n}\r\n```\n\n### Client\n\nAn [`SdkClientType`](../reference/js-api/interfaces/sdkclienttype/) represents a single client in the package.\n\n### Method\n\nTODO\n\n### Operation\n\nTODO\n\n### Type\n\nTODO\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n", "latency": 10.044918298721313, "response_length": 682}
{"query": "title: How to make an interface internal ?\n\nquestion: I am looking for ways to make an interface internal so that it does not appear in public interface of python SDK. This is the interface which emits EvaluationResultsOperations which shows up on client. I would like to generate it but keep it hidden from public interface.\nI tried following:\nMark all operations under it internal\nAdding @access decorator to interface but that fails.\nIs there a way to achieve it ?", "ground_truth": "Remove all the output and regenerate the code completely to resolve the issue with the folder mix in the previous generated code.\nConfirmed that hiding an entire operation group is not supported, and suggested using client.tsp to reorganize operations or _patch.py to customize the code.", "response": "To make an interface internal in TypeSpec so that it does not appear in the public interface of the Python SDK, you can use the `@access` decorator with the value `\"internal\"`. This will mark the interface and its operations as internal, ensuring they are hidden from the public interface.\n\nHere is an example:\n\n```typespec\nimport \"@azure-tools/typespec-client-generator-core\";\n\nusing Azure.ClientGenerator.Core;\n\n@@access(Contoso.WidgetManager.Widgets, \"internal\");\n```\n\nThis approach ensures that the interface `Widgets` and its operations are marked as internal, preventing them from being exposed in the public SDK interface. Note that Python does not change behavior based on `protocolAPI` or `convenientAPI`, but marking the interface as internal will still hide it from direct imports and usage.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#04convenient.mdx\n- document_title: Convenient method generation\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/04convenient\n- document_content: # howtos#generate-client-libraries#04convenient.mdx\n\n# Convenient method generation\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents how to customize method generation for the emitters. For an overview of the setup, please visit the setup page.\n\n## Default behaviors\n\nBy default, any language code generator will generate both protocol methods and convenient methods.\r\n\r\n> **NOTE:** Python and Typescript don't have a separation of convenient/protocol methods.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=main.tsp\r\nnamespace PetStoreNamespace;\r\n\r\n/** This is the input I need */\r\n@resource(\"output\")\r\nmodel OutputModel {\r\n  /** Id of this object */\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n}\r\n\r\n/** Read my resource */\r\nop GetModel is ResourceRead<OutputModel>;\r\n```\r\n\r\n```python\r\nclass OutputModel:\r\n  name: str = rest_field(readonly=True)\r\nresponse: OutputModel = client.get(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class OutputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetModelAsync(string name, RequestContext context) {}\r\n    public virtual Response GetModel(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<OutputModel>> GetModelAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<OutputModel> GetModel(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\ninterface OutputModel {\r\n  name: string;\r\n}\r\n\r\nconst model: OutputModel = await client.path(\"/petStore/model/{name}\").get();\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class OutputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    // protocol method\r\n    public Response<BinaryData> getModelWithResponse(String name, RequestOptions requestOptions)\r\n    // convenient method\r\n    public OutputModel getModel(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\nThe detailed generation configuration of protocol and/or convenient methods that can be done:\r\n\r\nAs emitters global parameters:\r\n\r\n- `generate-protocol-methods`: boolean flag to shift the entire generation for the process (`true` by default)\r\n- `generate-convenience-methods`: boolean flag to shift the entire generation for the process (`true` by default)\r\n\r\nTo set global emitters parameters, read the documentation of [emitters configuration](https://microsoft.github.io/typespec/introduction/configuration#configuration-file).\r\n\r\nFor fine tuning, the set of decorators `@protocolAPI` and `@convenientAPI` can be used. They take a required boolean as parameter.\n\n### Shifting the generation of protocol and convenience on and off\n\nThis can be achieved with the augment operator and the emitter package\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@convenientAPI(PetStoreNamespace.GetModel, false);\r\n```\r\n\r\n```python\n\n# Python do not change behavior based on protocolAPI or convenientAPI\n\n```\r\n\r\n```csharp\r\n// Model class is not generated.\r\n// Convenient method is not generated.\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetModelAsync(string name, RequestContext context) {}\r\n    public virtual Response GetModel(string name, RequestContext context) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\n// Model class is not generated.\r\n// Convenient method is not generated.\r\n\r\npublic final class PetStoreNamespaceClient {\r\n    // protocol method\r\n    public Response<BinaryData> getModelWithResponse(String name, RequestOptions requestOptions)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n### Make methods private/internal\n\nSometimes it may be useful to still generate the method, but to make it private, so it can be re-used by a manual code wrapper.\r\n\r\nThe two possible value for the `Access` enum are `internal` and `public`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@access(PetStoreNamespace.GetModel, \"internal\");\r\n```\r\n\r\n```python\n\n# can't import form models directly\n\nfrom petstorenamespace.models import GetModel # will report error\r\n```\r\n\r\n```csharp\r\n// Model class is internal\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  internal partial class OutputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n// Client method is internal\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    //protocol method\r\n    internal virtual async Task<Response> GetModelAsync(string name, RequestContext context) {}\r\n    internal virtual Response GetModel(string name, RequestContext context) {}\r\n    //convenience method\r\n    internal virtual async Task<Response<OutputModel>> GetModelAsync(string name, CancellationToken cancellationToken = default) {}\r\n    internal virtual Response<OutputModel> GetModel(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\n// Model class resides in implementation package.\r\n// Client method is package private.\r\n\r\npackage petstorenamespace.implementation.models;\r\npublic final class OutputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    // protocol method\r\n    Response<BinaryData> getModelWithResponse(String name, RequestOptions requestOptions)\r\n    // convenient method\r\n    OutputModel getModel(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n### Decide the usage of a model\n\nModels can be used for input, output, or both at the same time. In some languages, this\r\nchanges the way the API is exposed for those models.\r\n\r\nBy default, the code generator will infer the usage based on the TypeSpec. If this inference doesn't\r\ncorrespond to expectation, this can be customized with the `usage` decorator. Possible values are\r\n`input` and `output`, and can be combined with `Usage.input | Usage.output`.\r\n\r\n> **NOTE:** If a model is never used, it will not be generated. Assigning a usage will force generation.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n// This model is input only\r\n@@usage(Azure.OpenAI.AzureCognitiveSearchIndexFieldMappingOptions, Usage.input);\r\n// This models is input/output\r\n@@usage(Azure.OpenAI.ImageGenerations, Usage.input | Usage.output);\r\n```\r\n\r\n```python\n\n# In that case, set a usage for the model\n\n```\r\n\r\n```csharp\r\n// If a model is input-only, it has one public constructor with all required properties as parameters.\r\n// The required properties only have getter. Optional properties have both getter and setter.\r\n// A collection property which is not nullable only has getter whatever it is required or not.\r\nnamespace Azure.AI.OpenAI.Models\r\n{\r\n  public partial class AzureCognitiveSearchIndexFieldMappingOptions\r\n  {\r\n    public AzureCognitiveSearchIndexFieldMappingOptions()\r\n\r\n    public string TitleFieldName { get; set; }\r\n    public string UrlFieldName { get; set; }\r\n    public string FilepathFieldName { get; set; }\r\n    public IList<string> ContentFieldNames { get; }\r\n    public string ContentFieldSeparator { get; set; }\r\n    public IList<string> VectorFieldNames { get; }\r\n    public IList<string> ImageVectorFieldNames { get; }\r\n  }\r\n}\r\n// If a model is output-only, it does not have any public constructor, and all properties only have getter, no setter.\r\n\r\n// If a model is roundtrip (input + output), it has one public constructor with all required properties as parameters.\r\n// All properties except colletion properties which are not nullable will have both getter and setter.\r\n// A collection property which is not nullable only has getter.\r\nnamespace Azure.AI.OpenAI.Models\r\n{\r\n  public partial class ImageGenerations\r\n  {\r\n    public ImageGenerations(DateTimeOffset created, IEnumerable<ImageGenerationData> data)\r\n\r\n    public DateTimeOffset Created { get; set; }\r\n    public IList<ImageGenerationData> Data { get; }\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// JS doesn't generate different code based on usage\r\n// However, the model may not be generated if it's never used\r\n// In that case, set a usage for the model\r\n```\r\n\r\n```java\r\n// If a model class is output-only, its constructor is not public.\r\n// Adding Usage.input to it would make its constructor public.\r\n\r\npackage azure.openai.models;\r\n\r\npublic final class AzureCognitiveSearchIndexFieldMappingOptions {\n\n}\r\n    public IList<ImageGenerationData> Data { get; }\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// JS doesn't generate different code based on usage\r\n// However, the model may not be generated if it's never used\r\n// In that case, set a usage for the model\r\n```\r\n\r\n```java\r\n// If a model class is output-only, its constructor is not public.\r\n// Adding Usage.input to it would make its constructor public.\r\n\r\npackage azure.openai.models;\r\n\r\npublic final class AzureCognitiveSearchIndexFieldMappingOptions {\r\n    public AzureCognitiveSearchIndexFieldMappingOptions()\r\n    public String getTitleField()\r\n    public AzureCognitiveSearchIndexFieldMappingOptions setTitleField(String titleField)\r\n    ...\r\n}\r\n\r\npublic final class ImageGenerations {\r\n    public ImageGenerations(OffsetDateTime createdAt, List<ImageGenerationData> data)\r\n    public OffsetDateTime getCreatedAt()\r\n    public List<ImageGenerationData> getData()\r\n}\r\n```\r\n\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#99tcgctypes.mdx\n- document_title: TypeSpec Type Representation in TCGC\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/99tcgctypes\n- document_content: # howtos#generate-client-libraries#99tcgctypes.mdx\n\n# TypeSpec Type Representation in TCGC\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents what type definitions in TypeSpec would look like when returned by TCGC\n\n## Main TypeSpec Code Example\n\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@useAuth(ApiKeyAuth<ApiKeyLocation.header, \"api-key\">)\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    endpoint: string,\r\n  }\r\n)\r\nnamespace Contoso.WidgetManager;\r\n\r\nmodel Widget {\r\n  @visibility(Lifecycle.Read, Lifecycle.Update)\r\n  @path\r\n  id: string;\r\n\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  @get list(): Widget[] | Error;\r\n  @get read(@path id: string): Widget | Error;\r\n  @post create(...Widget): Widget | Error;\r\n  @patch update(...Widget): Widget | Error;\r\n  @delete delete(@path id: string): void | Error;\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): string | Error;\r\n}\r\n```\n\n## SdkClientType\n\nAn `SdkClientType` represents a single client in your package.\r\n\r\nAll clients will have an `initialization` property. Whether that property's access is `internal` or `public` will determine whether your client can be publicly instantiated or not.\n\n### Interface\n\n```ts\r\nexport interface SdkClientType<TServiceOperation extends SdkServiceOperation> {\r\n  name: string;\r\n  kind: \"client\";\r\n  description?: string;\r\n  details?: string;\r\n  initialization: SdkInitializationType;\r\n  apiVersions: string[];\r\n  // fully qualified. Compare to sdkPackage.rootNamespace to figure out where to generate\r\n  nameSpace: string;\r\n  methods: SdkMethod<TServiceOperation>[];\r\n}\r\n```\n\n### Example\n\n```ts\r\nconst sdkClient = {\r\n  name: \"ContosoWidgetManagerClient\";\r\n  kind: \"client\";\r\n  initialization: {\r\n    name: \"WidgetManagerOptions\",\r\n    kind: \"model\",\r\n    access: \"public\",\r\n    ...\r\n  };\r\n  apiVersions: [],\r\n  nameSpace: \"Contoso.WidgetManager\",\r\n  methods: [\r\n    {\r\n      name: \"getWidgets\",\r\n      kind: \"clientaccessor\",\r\n      response: {\r\n        name: \"Widgets\",\r\n        kind: \"client\",\r\n        initialization: {\r\n          kind: \"model\",\r\n          access: \"internal\",\r\n        },\r\n        apiVersions: [],\r\n        nameSpace: \"Contoso.WidgetManager\",\r\n        methods: [\r\n          {\r\n            name: \"list\",\r\n            kind: \"method\",\r\n            ...\r\n          },\r\n          {\r\n            name: \"read\",\r\n            kind: \"method\",\r\n            ...\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  ],\r\n}\r\n```\n\n### Usage\n\n```ts\r\nimport { SdkClientType } from \"@azure-tools/typespec-client-generator-core\";\r\nimport { PythonSdkServiceOperation } from \"./interfaces.js\";\r\nimport { get }\r\n\r\nconst serializedClients: PythonSdkClientType[] = [];\r\n\r\nfunction serializeClient<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  sdkContext: PythonSdkContext<TServiceOperation>,\r\n  client: SdkClientType<TServiceOperation>,\r\n): PythonSdkClientType {\r\n  // Map the information from the SdkClientType to your language's interface for a client.\r\n  // Would recommend that eventually your language's client type interface extends from\r\n  // SdkClientType, and just adds your language-specific information on top.\r\n  const pythonClient = {\r\n    ...client,\r\n    parameters: (client.initialization.properties.map(\r\n        (x) => getSdkModelPropertyType(\r\n          context, x\r\n        )\r\n      ) : undefined\r\n    ),\r\n    methods: client.methods.filter(\r\n      (x) => x.kind ===  \"method\"\r\n    ).map(\r\n      (x) => serializeServiceMethod(sdkContext, x)\r\n    ),\r\n    subclients: [],\r\n  }\r\n  sdkContext.ClientMap.set(client, pythonClient)\r\n  return pythonClient\r\n}\r\n\r\nfor (const client of sdkPackage.clients) {\r\n  serializedClients.push(serializeClient(sdkContext, client));\r\n}\r\n```\n\n## SdkInitializationType\n\nInitialization model for a client. Whether it's `access` is `public` or `internal` tells you whether the client is publicly instantiable.\n\n### Interface\n\n```ts\r\nexport interface SdkInitializationType extends SdkModelType {\r\n  // properties takes care of all of the initialization info that you will need.\r\n  properties: (SdkEndpointParameter | SdkCredentialParameter | SdkMethodParameter)[];\r\n}\r\n```\n\n### Example\n\n```ts\r\nconst sdkInitializationType = {\r\n  name: \"WidgetManagerOptions\",\r\n  kind: \"model\",\r\n  properties: [\r\n    {\r\n      kind: \"endpoint\",\r\n      serverUrl: \"{endpoint}/widget\",\r\n      templateArguments: [\r\n        {\r\n          kind: \"path\",\r\n          name: \"endpoint\",\r\n          type: {\r\n            kind: \"string\",\r\n          },\r\n        },\r\n      ],\r\n    },\r\n    {\r\n      kind: \"credential\",\r\n      type: {\r\n        kind: \"credential\",\r\n        scheme: {\r\n          kind: \"apiKey\",\r\n          in: \"header\",\r\n          name: \"api-key\",\r\n        },\r\n      },\r\n      onClient: true,\r\n    },\r\n  ],\r\n  crossLanguageDefinitionId: \"Contoso.WidgetManager.WidgetManagerOptions\",\r\n  apiVersions: [],\r\n  usage: UsageFlags.Input,\r\n  access: \"public\",\r\n  isFormDataType: false,\r\n  isError: false,\r\n};\r\n```\n\n### Usage\n\nThe usage of this property is more language-dependent.\r\n\r\nSome emitters will create a model and have the client accept the model as options to initialize your client. Others will flatten out the parameters and accept them individually as parameter input.\n\n## SdkMethod\n\nAn `SdkMethod` is any of the types of methods that can be a method on a client.\r\n\r\nThere are two main types of an `SdkMethod`:\r\n\r\n1. `SdkClientAccessor` returns a subclient of the client it's on\r\n2. `SdkServiceMethod` wraps a service call\r\n\r\n```ts\r\nexport type SdkMethod<TServiceOperation extends PythonSdkServiceOperation> =\r\n  | SdkServiceMethod<TServiceOperation>\r\n  | SdkClientAccessor<TServiceOperation>;\r\n```\r\n\r\nThey each extend from the shared `SdkMethodBase`\r\n\r\n```ts\r\ninterface SdkMethodBase<TServiceOperation extends SdkServiceOperation> {\r\n  __raw?: Operation;\r\n  name: string;\r\n  access: AccessFlags;\r\n  parameters: SdkParameter[];\r\n  apiVersions: string[];\r\n  description?: string;\r\n  details?: string;\r\n}\r\n```\r\n\r\nBelow we go into each method type\n\n### SdkClientAccessor\n\nA `clientaccessor` method is simply a method on a client that returns another client. The returned client can be instantiable or un-instantiable. If the returned client is instantiable, most likely your `clientaccessor` will be part of the public api surface, so users can instantiate the subclient using your client method. If it is not instantiable, it is up to you how to expose the subclient on your current client for users to access.\r\n\r\n#### Interface\r\n\r\n```ts\r\ninterface SdkClientAccessor<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkMethodBase<TServiceOperation> {\r\n  kind: \"clientaccessor\";\r\n  response: SdkClientType<TServiceOperation>;\r\n}\r\n```\r\n\r\n#### Example\r\n\r\n```ts\r\nconst sdkClientAccessor = {\r\n  name: \"getWidgets\",\r\n  kind: \"clientaccessor\",\r\n  response: {\r\n    name: \"Widgets\",\r\n    kind: \"client\",\r\n    initialization: undefined,\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\n#### Usage\r\n\r\nOur strong recommendation is you build up a list of clients by iterating through `sdkPackage.clients` first, and to _not_ recurse into creating the subclients.\r\nOnly once you've processed each client, then you go through and link clients to their subclients. Not doing recursion prevents confusion over where you are in the call chain.\r\n\r\n```ts\r\nimport { SdkServiceOperation, SdkClientType } from \"@azure-tools/typespec-client-generator-core\";\r\nimport { PythonSdkContext } from \"./lib.js\";\r\nimport { PythonSdkClientType } from \"./interfaces.js\";\r\n\r\nfunction linkSubClients<TServiceOperation extends PythonSdkServiceOperation>(\r\n  sdkContext: PythonSdkContext<TServiceOperation>,\r\n): void {\r\n  for (const client of sdkContext.clients) {\r\n    client.subclients = client.methods\r\n      .filter((x) => x.kind === \"clientaccessor\")\r\n      .map((x) => x.returnType)\r\n      .map((x) => sdkContext.ClientMap.get(x));\r\n  }\r\n}\r\n```\n\n### SdkServiceMethod\n\n\"lropaging\";\r\n  __raw_lro_metadata: LroMetadata;\r\n  // initial call to start LRO\r\n  operation: SdkServiceOperation;\r\n  __raw_paged_metadata: PagedResultMetadata;\r\n  nextLinkPath?: string; // off means fake paging\r\n  nextLinkOperation?: SdkServiceOperation;\r\n}\r\n```\r\n\r\n##### Usage\r\n\r\n```ts\r\nfunction serializeLroPagingServiceMethod<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkLroPagingServiceMethod<TServiceOperation>,\r\n): PythonSdkLroPagingServiceMethod<TServiceOperation> {\r\n  return {\r\n    ...method,\r\n    name: camelToSnakeCase(method.name),\r\n    operation: serializeServiceOperation(context, method, method.operation),\r\n    nextLinkOperation: method.nextLinkOperation ? serializeServiceOperation(context, method, method.nextLinkOperation) : undefined,\r\n  },\r\n}\r\n```\n\n// Widget Operations\r\n/** Creates or updates a Widget asynchronously */\r\n@pollingOperation(getWidgetOperationStatus)\r\ncreateOrUpdateWidget is Operations.LongRunningResourceCreateOrUpdate<Widget>;\r\n```\r\n\r\n```ts\r\nconst sdkLroServiceMethod = {\r\n  kind: \"lro\",\r\n  __raw?: {\r\n    // Original Tsp Operation type\r\n    kind: \"Operation\",\r\n  },\r\n  __raw_lro_metadata: {\r\n    // Raw output from getLroMetadata\r\n  }\r\n  name: \"createOrUpdateWidget\",\r\n  access: \"public\",\r\n  apiVersions: [],\r\n  parameters: [],\r\n  operation: {\r\n    kind: \"http\",\r\n    ...\r\n  },\r\n  response: {\r\n    kind: \"method\",\r\n    type: {\r\n      kind: \"model\",\r\n      name: \"Widget\",\r\n    }\r\n  },\r\n}\r\n```\r\n\r\n##### Usage\r\n\r\n```ts\r\nfunction serializeLroServiceMethod<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkLroServiceMethod<TServiceOperation>,\r\n): PythonSdkLroServiceMethod<TServiceOperation> {\r\n  return {\r\n    ...method,\r\n    name: camelToSnakeCase(method.name),\r\n    operation: serializeServiceOperation(context, method),\r\n  },\r\n}\r\n```\r\n\r\n#### SdkLroPagingServiceMethod\r\n\r\nThis is a combination of Lro and paging. We start off with an LRO call to the service, and then the response is returned to us in pages. Also only available for azure-sdks.\r\n\r\n##### Interface\r\n\r\n```ts\r\nexport interface SdkLroPagingServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"lropaging\";\r\n  __raw_lro_metadata: LroMetadata;\r\n  // initial call to start LRO\r\n  operation: SdkServiceOperation;\r\n  __raw_paged_metadata: PagedResultMetadata;\r\n  nextLinkPath?: string; // off means fake paging\r\n  nextLinkOperation?: SdkServiceOperation;\r\n}\r\n```\r\n\r\n##### Usage\r\n\r\n```ts\r\nfunction serializeLroPagingServiceMethod<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkLroPagingServiceMethod<TServiceOperation>,\n\nAn `SdkServiceMethod` is any service method on a client that calls the service.\r\n\r\nThe actual service call is a separate property on the method, `.operation`. This way, our service methods are able to abstract away the protocol used to call the service (i.e. `http` or `gRPC`)\r\n\r\nAll `SdkServiceMethod`s share the following base:\r\n\r\n```ts\r\ninterface SdkServiceMethodBase<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkMethodBase<TServiceOperation> {\r\n  // This represents the operation request we need to send to the service.\r\n  // This helps abstract away the transport\r\n  operation: TServiceOperation;\r\n  // The parameters you generate on the method signature that users will interact with.\r\n  // These aren't tied to any protocol, so there are no 'header' / 'path' parameters etc.\r\n  parameters: SdkMethodParameter[];\r\n  response: SdkMethodResponse;\r\n  exception?: SdkMethodResponse;\r\n}\r\n```\r\n\r\n```ts\r\nfunction serializeServiceMethod<TServiceOperation extends PythonSdkServiceOperation>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkServiceMethod<TServiceOperation>,\r\n): PythonSdkServiceMethod {\r\n  switch (method.kind) {\r\n    case \"basic\":\r\n      return serializeBasicServiceMethod(context, method);\r\n    case \"paging\":\r\n      return serializePagingServiceMethod(context, method);\r\n    case \"lro\":\r\n      return serializeLroServiceMethod(context, method);\r\n    case \"lropaging\":\r\n      return serializeLroPagingServiceMethod(context, method);\r\n  }\r\n}\r\n```\r\n\r\n#### SdkBasicServiceMethod\r\n\r\nThis models a basic service call that is synchronous server side.\r\n\r\n##### Interface\r\n\r\n```ts\r\nexport interface SdkBasicServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"basic\";\r\n}\r\n```\r\n\r\n##### Example\r\n\r\n```ts\r\nconst sdkBasicServiceMethod = {\r\n  kind: \"basic\",\r\n  __raw?: {\r\n    // Original Tsp Operation type\r\n    kind: \"Operation\",\r\n  },\r\n  name: \"read\",\r\n  access: \"public\",\n\n}\r\n}\r\n```\r\n\r\n#### SdkBasicServiceMethod\r\n\r\nThis models a basic service call that is synchronous server side.\r\n\r\n##### Interface\r\n\r\n```ts\r\nexport interface SdkBasicServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"basic\";\r\n}\r\n```\r\n\r\n##### Example\r\n\r\n```ts\r\nconst sdkBasicServiceMethod = {\r\n  kind: \"basic\",\r\n  __raw?: {\r\n    // Original Tsp Operation type\r\n    kind: \"Operation\",\r\n  },\r\n  name: \"read\",\r\n  access: \"public\",\r\n  apiVersions: [],\r\n  parameters: [\r\n    {\r\n      name: \"id\",\r\n      kind: \"method\",\r\n      ...\r\n    },\r\n  ],\r\n  operation: {\r\n    kind: \"http\",\r\n    ...\r\n  },\r\n  response: {\r\n    kind: \"method\",\r\n    type: {\r\n      kind: \"model\",\r\n      name: \"Widget\",\r\n    }\r\n  },\r\n}\r\n```\r\n\r\n##### Usage\r\n\r\n```ts\r\nfunction serializeBasicServiceMethod<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkBasicServiceMethod<TServiceOperation>,\r\n): PythonSdkBasicServiceMethod<TServiceOperation> {\r\n  return {\r\n    ...method,\r\n    name: camelToSnakeCase(method.name),\r\n    operation: serializeServiceOperation(context, method, method.operation)\r\n  },\r\n}\r\n```\r\n\r\n#### SdkPagingServiceMethod\r\n\r\nThis represents a paging method we will generate on the client. It includes an initial service operation call, and potentially a next link operation as well.\r\n\r\nWe currently only have paging method support for azure-generated sdks.\r\n\r\n##### Interface\r\n\r\n```ts\r\nexport interface SdkPagingServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"paging\";\r\n  // raw paging information returned from getPagedResult\r\n  __raw_paged_metadata: PagedResultMetadata;\r\n  // string to get to next link. If undefined, we are doing fake paging\r\n  nextLinkPath?: string;\r\n  // service operation if separate requests need to be made for subsequent paging\r\n  nextLinkOperation?: TServiceOperation;\r\n}\n\nTServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkPagingServiceMethod<TServiceOperation>,\r\n): PythonSdkBasicServiceMethod<TServiceOperation> {\r\n  return {\r\n    ...method,\r\n    name: camelToSnakeCase(method.name),\r\n    operation: serializeServiceOperation(context, method, method.operation),\r\n    nextLinkOperation: method.nextLinkOperation ? serializeServiceOperation(context, method, method.nextLinkOperation) : undefined,\r\n  },\r\n}\r\n```\r\n\r\n#### SdkLroServiceMethod\r\n\r\nRepresents an LRO method we want to generate on the client.\r\n\r\nOnly returned for azure-generated sdks\r\n\r\n##### Interfaces\r\n\r\n```ts\r\nexport interface SdkLroServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"lro\";\r\n  // raw LroMetadata returned from azure-core helper function getLroMetadata\r\n  __raw_lro_metadata: LroMetadata;\r\n  // initial call to begin LRO polling\r\n  // thinking of instead making it the regular operation property so we can continue using that property\r\n  operation: TServiceOperation;\r\n}\r\n```\r\n\r\n#### Example\r\n\r\n```tsp\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\n// Skipping past service definitions\r\n\r\nalias Operations = Azure.Core.ResourceOperations<SupportsRepeatableRequests>;\r\n\r\n// Operation Status\r\n/** Gets status of a Widget operation. */\r\ngetWidgetOperationStatus is Operations.GetResourceOperationStatus<Widget>;\r\n\r\n// Widget Operations\r\n/** Creates or updates a Widget asynchronously */\r\n@pollingOperation(getWidgetOperationStatus)\r\ncreateOrUpdateWidget is Operations.LongRunningResourceCreateOrUpdate<Widget>;\r\n```\r\n\r\n```ts\r\nconst sdkLroServiceMethod = {\r\n  kind: \"lro\",\r\n  __raw?: {\r\n    // Original Tsp Operation type\r\n    kind: \"Operation\",\r\n  },\r\n  __raw_lro_metadata: {\r\n    // Raw output from getLroMetadata\r\n  }\r\n  name: \"createOrUpdateWidget\",\r\n  access: \"public\",\r\n  apiVersions: [],\n\n```ts\r\nexport interface SdkPagingServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"paging\";\r\n  // raw paging information returned from getPagedResult\r\n  __raw_paged_metadata: PagedResultMetadata;\r\n  // string to get to next link. If undefined, we are doing fake paging\r\n  nextLinkPath?: string;\r\n  // service operation if separate requests need to be made for subsequent paging\r\n  nextLinkOperation?: TServiceOperation;\r\n}\r\n```\r\n\r\n##### Example\r\n\r\n```tsp\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\n// Skipping past service definitions\r\n\r\nalias Operations = Azure.Core.ResourceOperations<SupportsRepeatableRequests>;\r\n\r\nlistWidgets is Operations.ResourceList<Widget>;\r\n```\r\n\r\n```ts\r\nconst sdkPagingServiceMethod = {\r\n  kind: \"paging\",\r\n  __raw?: {\r\n    // Original Tsp Operation type\r\n    kind: \"Operation\",\r\n  },\r\n  __raw_paged_metadata: {\r\n    // Raw output from getPagedMetadata\r\n  }\r\n  name: \"listWidgets\",\r\n  access: \"public\",\r\n  apiVersions: [],\r\n  parameters: [],\r\n  operation: {\r\n    kind: \"http\",\r\n    ...\r\n  },\r\n  response: {\r\n    kind: \"method\",\r\n    type: {\r\n      kind: \"model\",\r\n      name: \"Widget\",\r\n    },\r\n    // we want to return the `.value` part of the service response to users\r\n    pathFromService: \"value\",\r\n  },\r\n  nextLinkPath: \"nextLink\",\r\n  nextLinkOperation: undefined,\r\n}\r\n```\r\n\r\n##### Usage\r\n\r\n```ts\r\nfunction serializePagingServiceMethod<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkPagingServiceMethod<TServiceOperation>,\r\n): PythonSdkBasicServiceMethod<TServiceOperation> {\r\n  return {\r\n    ...method,\r\n    name: camelToSnakeCase(method.name),\r\n    operation: serializeServiceOperation(context, method, method.operation),\r\n    nextLinkOperation: method.nextLinkOperation ? serializeServiceOperation(context, method, method.nextLinkOperation) : undefined,\n\n## SdkServiceOperation\n\nOne main part of this design is we've decoupled the actual service operation call from the method we generate on our client. This is because we want to abstract away the protocol used to call our service. Additionally, while there is a high level of correlation between the method parameters we intake from SDK users, and the parameters we end up passing the service, it's not one-to-one. We need to serialize the method parameters and additionally, when parameters are spread or grouped together, it requires us to do mapping between which method parameters correspond to which service parameters.\r\n\r\nWe currently only support HTTP calls to the service.\n\n### Interface\n\n```ts\r\nexport interface SdkHttpOperation {\r\n  kind: \"http\";\r\n  // raw HTTP operation output from typespec/http\r\n  __raw: HttpOperation;\r\n  // route path for the target operation. TypeSpec suggest to use `uriTemplate` instead as `path` will not work for complex cases like not-escaping reserved chars.\r\n  path: string;\r\n  // the fully resolved URI template for the target operation as defined by [RFC 6570](https://datatracker.ietf.org/doc/html/rfc6570).\r\n  uriTemplate: string;\r\n  verb: HttpVerb;\r\n  parameters: (SdkPathParameter | SdkQueryParameter | SdkHeaderParameter)[];\r\n  bodyParam: SdkBodyParameter;\r\n  // mapping of status codes to SdkHttpResponse for valid responses\r\n  // HttpStatusCodeRange can represent either a single status code or a range.\r\n  responses: SdkHttpResponse[];\r\n  exceptions: SdkHttpResponse[];\r\n  examples?: SdkHttpOperationExample[];\r\n}\r\n```\n\n### Example\n\n```ts\r\nconst sdkHttpOperation = {\r\n  kind: \"http\",\r\n  __raw: {\r\n    // raw HttpOperation from @typespec/http;\r\n  },\r\n  path: \"/widgets\",\r\n  uriTemplate: \"/widgets\",\r\n  verb: \"get\",\r\n  parameters: [\r\n    {\r\n      kind: \"path\",\r\n      name: \"id\",\r\n      ...\r\n    }\r\n  ],\r\n  bodyParam: undefined,\r\n  responses: {\r\n    200: {\r\n      kind: \"http\",\r\n      ...\r\n    },\r\n  },\r\n  exceptions: {\r\n    \"*\": {\r\n      kind: \"http\",\r\n      ...\r\n    }\r\n  },\r\n  examples: [\r\n    {\r\n      kind: \"http\",\r\n      name: \"Example 1\",\r\n      description: \"Example 1\",\r\n      filePath: \"example1.json\",\r\n      rawExample: {...},\r\n      parameters: [...],\r\n      responses: {...}\r\n    }\r\n  ]\r\n}\r\n```\n\n### Usage\n\n```ts\r\nfunction serializeServiceOperation<TServiceOperation extends PythonSdkServiceOperation>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkServiceMethod<TServiceOperation>,\r\n  operation: TServiceOperation,\r\n): TServiceOperation {\r\n  switch (operation.kind) {\r\n    case \"http\":\r\n      return serializeHttpServiceOperation(context, method, operation);\r\n  }\r\n}\r\n```\n\n## Parameters and Properties\n\nLike the TypeSpec concept of a `ModelProperty`, all properties and parameters are part of the `SdkModelPropertyType`. They all extend from `SdkModelPropertyTypeBase`.\r\n\r\n```ts\r\nexport type SdkModelPropertyType =\r\n  | SdkMethodParameter\r\n  | SdkEndpointParameter\r\n  | SdkCredentialParameter\r\n  | SdkBodyModelPropertyType\r\n  | SdkQueryParameter\r\n  | SdkPathParameter\r\n  | SdkHeaderParameter\r\n  | SdkBodyParameter;\r\n```\r\n\r\n```ts\r\ninterface SdkModelPropertyTypeBase {\r\n  __raw?: ModelProperty;\r\n  type: SdkType;\r\n  name: string;\r\n  description?: string;\r\n  details?: string;\r\n  apiVersions: string[];\r\n  onClient: boolean;\r\n  // clientDefaultValue only exists for api versions\r\n  clientDefaultValue?: any;\r\n  isApiVersionParam: boolean;\r\n  optional: boolean;\r\n  nullable: boolean;\r\n}\r\n```\n\n### Method parameters\n\nThese are parameters to client initialization and method son the client. These will be the parameters that SDK users directly use. They will eventually be mapped to\r\n\r\n#### SdkEndpointParameter\r\n\r\nAn `SdkEndpointParameter` represents a parameter to a client's endpoint.\r\n\r\nTCGC will always give it to you as overridable:\r\n\r\nIf the server URL is a constant, we will return a templated endpoint with a default value of the constant server URL.\r\nIn the case where the endpoint has extra template arguments, the type is a union of a completely-overridable endpoint, and an endpoint that accepts template arguments.\r\nIf there are multiple servers, we will return the union of all of the possibilities.\r\n\r\n```tsp\r\nexport interface SdkEndpointParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"endpoint\";\r\n  urlEncode: boolean;\r\n  onClient: true;\r\n  serializedName?: string;\r\n  type: SdkEndpointType | SdkUnionType<SdkEndpointType>;\r\n}\r\n```\r\n\r\n#### SdkCredentialParameter\r\n\r\nParameter for credential input to clients.\r\n\r\n```ts\r\nexport interface SdkCredentialParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"credential\";\r\n  // can be either an SdkCredentialType or a union\r\n  // of different credential types\r\n  type: SdkCredentialType | SdkUnionType;\r\n  onClient: true;\r\n}\r\n```\r\n\r\n#### SdkMethodParameter\r\n\r\nRepresents a parameter to a client method. Does not have any transport (i.e. HTTP) related information on it. This is solely meant to represent information that we expect sdk users to pass in. We then take care to map the method input and create our request to the service using the information users have inputted.\r\n\r\n```ts\r\nexport interface SdkMethodParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"method\";\r\n}\r\n```\n\n### Service Parameters\n\ntreat each value in array as a separate header parameter\r\nexport type CollectionFormat = \"multi\" | \"csv\" | \"ssv\" | \"tsv\" | \"pipes\" | \"simple\" | \"form\";\r\n\r\nexport interface SdkHeaderParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"header\";\r\n  collectionFormat?: CollectionFormat;\r\n  serializedName: string;\r\n  correspondingMethodParams: SdkModelPropertyType[];\r\n}\r\n```\r\n\r\n#### SdkPathParameter\r\n\r\n```ts\r\nexport interface SdkPathParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"path\";\r\n  // when interpolating this parameter in the case of array or object, expand each value using the given style, default is `false`\r\n  explode: boolean;\r\n  // different interpolating styles for the path parameter, default is `\"simple\"`\r\n  // - simple: no separator\r\n  // - label: . as separator\r\n  // - matrix: ; as separator\r\n  // - fragment: # as separator\r\n  // - path: / as separator\r\n  style: \"simple\" | \"label\" | \"matrix\" | \"fragment\" | \"path\";\r\n  // when interpolating this parameter, do not encode reserved characters, default is `false`\r\n  allowReserved: boolean;\r\n  serializedName: string;\r\n  optional: false;\r\n  correspondingMethodParams: SdkModelPropertyType[];\r\n}\r\n```\r\n\r\n#### SdkBodyParameter\r\n\r\n```ts\r\nexport interface SdkBodyParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"body\";\r\n  optional: boolean;\r\n  contentTypes: string[];\r\n  defaultContentType: string;\r\n  correspondingMethodParams: SdkModelPropertyType[];\r\n}\r\n```\n\nCurrently we only support HTTP service parameters.\r\n\r\n#### SdkQueryParameter\r\n\r\nThis represents an HTTP query parameter.\r\n\r\n```ts\r\n// different collection format to use to separate each value in array\r\n// - multi: no separator, treat each value in array as a separate query parameter\r\n// - csv: , as separator\r\n// - ssv: space as separator\r\n// - tsv: tab as separator\r\n// - pipes: | as separator\r\n// - simple: , as separator\r\n// - form: no separator, treat each value in array as a separate query parameter\r\nexport type CollectionFormat = \"multi\" | \"csv\" | \"ssv\" | \"tsv\" | \"pipes\" | \"simple\" | \"form\";\r\n\r\nexport interface SdkQueryParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"query\";\r\n  // the collection format to use to separate each value in array of a query parameter\r\n  collectionFormat?: CollectionFormat;\r\n  serializedName: string;\r\n  correspondingMethodParams: SdkModelPropertyType[];\r\n  // if true, send each value in array or object as a separate query parameter, default is `false`\r\n  explode: boolean;\r\n}\r\n```\r\n\r\n#### SdkHeaderParameter\r\n\r\nThis is an HTTP header parameter.\r\n\r\n```ts\r\n// different collection format to use to separate each value in array\r\n// - multi: no separator, treat each value in array as a separate header parameter\r\n// - csv: , as separator\r\n// - ssv: space as separator\r\n// - tsv: tab as separator\r\n// - pipes: | as separator\r\n// - simple: , as separator\r\n// - form: no separator, treat each value in array as a separate header parameter\r\nexport type CollectionFormat = \"multi\" | \"csv\" | \"ssv\" | \"tsv\" | \"pipes\" | \"simple\" | \"form\";\r\n\r\nexport interface SdkHeaderParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"header\";\r\n  collectionFormat?: CollectionFormat;\r\n  serializedName: string;\r\n  correspondingMethodParams: SdkModelPropertyType[];\r\n}\r\n```\r\n\r\n#### SdkPathParameter\r\n\r\n```ts\r\nexport interface SdkPathParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"path\";\n\n### Properties\n\n#### SdkBodyModelPropertyType\r\n\r\nThis represents a property on a body model\r\n\r\n```ts\r\nexport interface SdkBodyModelPropertyType extends SdkModelPropertyTypeBase {\r\n  kind: \"property\";\r\n  discriminator: boolean;\r\n  serializedName: string;\r\n  isMultipartFileInput: boolean;\r\n  visibility: Visibility[];\r\n  flatten: boolean;\r\n}\r\n```\n\n### Usage\n\nWe recommend that for usage, you use one single function with switch statements for each kind of property.\r\nThis allows for the circular nature of an `SdkModelPropertyType`.\r\n\r\n```\r\nimport { SdkServiceOperation, SdkModelPropertyType } from \"@azure-tools/typespec-client-generator-core\";\r\nimport { PythonSdkContext } from \"./lib.js\";\r\nimport { getPythonSdkType } from \"./types.js\";\r\n\r\nexport function getSdkModelPropertyType<\r\n  TServiceOperation extends SdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  prop: SdkModelPropertyType\r\n): PythonSdkModelType {\r\n  const type = getPythonSdkType(context, prop.type)\r\n  switch (prop.kind) {\r\n    case \"query\":\r\n    case \"header\"\r\n    case \"path\":\r\n      return {\r\n        ...prop,\r\n        type,\r\n        correspondingMethodParams: prop.correspondingMethodParams.map(\r\n          (x) => getSdkModelPropertyType(context, x),\r\n        )\r\n      }\r\n    default:\r\n      return {\r\n        ...prop,\r\n        type,\r\n      }\r\n  }\r\n}\r\n```\n\n## SdkMethodResponse\n\nThis represents the response that our method will ultimately return.\r\nIt is not tied to a transport, like http, it solely represents what we want to return to users\n\n### Interface\n\n```ts\r\nexport interface SdkMethodResponse {\r\n  kind: \"method\";\r\n  // the path from the service response to what the method returns.\r\n  logicalPath?: string;\r\n  type?: SdkType;\r\n  description?: string;\r\n  details?: string;\r\n}\r\n```\n\n### Example\n\n```ts\r\nconst sdkMethodResponse = {\r\n  kind: \"method\",\r\n  logicalPath: undefined,\r\n  type: {\r\n    kind: string,\r\n  },\r\n}\r\n\r\nconst sdkPagingMethodResponse = {\r\n  kind: \"method\",\r\n  logicalPath: \"value\",\r\n  type: {\r\n    kind: \"array\",\r\n    valueType: {\r\n      kind: \"model\",\r\n      name: \"Widget\",\r\n      nullableValues: false,\r\n      ...\r\n    }\r\n  }\r\n}\r\n```\n\n### Usage\n\n```ts\r\nimport { SdkMethodResponse } from \"@azure-tools/typespec-client-generator-core\";\r\nimport { PythonSdkContext, PythonSdkMethodResponse } from \"./lib.js\";\r\nimport { getPythonSdkType } from \"./types.js\";\r\n\r\nfunction serializeMethodResponse<TServiceOperation extends SdkServiceOperation>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  response: SdkMethodResponse,\r\n): PythonSdkMethodResponse {\r\n  return {\r\n    ...response,\r\n    type: getPythonSdkType(context, response.type),\r\n  };\r\n}\r\n```\n\n## SdkHttpResponse\n\nThis is the response returned from an HTTP service. The emitters should take care to map it to what the method ultimately returns to end users.\r\n\r\nEach response is mapped to an `HttpStatusCodeRange` on the `SdkHttpOperation` interface.\n\n### Interface\n\n```ts\r\ninterface HttpStatusCodeRange {\r\n  start: number; // inclusive start. If there's only start, then it's just a single value.\r\n  end?: number; // exclusive end. If it's a range, end is present, otherwise it's undefined.\r\n}\r\n\r\nexport interface SdkHttpResponse {\r\n  kind: \"http\";\r\n  statusCodes: number | HttpStatusCodeRange | \"*\";\r\n  headers: SdkServiceResponseHeader[];\r\n  apiVersions: string[];\r\n  type?: SdkType;\r\n  contentTypes: string[];\r\n  defaultContentType?: string;\r\n}\r\n```\n\n## SdkType\n\nThese are the TCGC versions of each TypeSpec Type. They include information that all emitters want, i.e. their description directly on them.\r\n\r\nThey all share this base:\r\n\r\n```ts\r\ninterface SdkTypeBase {\r\n  // the raw TypeSpec type. Some of our types are currently\r\n  // created by tcgc. Those won't have an original type\r\n  __raw?: Type;\r\n  kind: string;\r\n  deprecation?: string;\r\n  description?: string;\r\n  details?: string;\r\n}\r\n```\n\n### SdkBuiltInType\n\nA `SdkBuiltInType` represents a built-in scalar TypeSpec type or scalar type that derives from a built-in scalar TypeSpec type, but datetime and duration are not included.\r\nWe add `encode` onto these types if `@encode` decorator exists, telling us how to encode when sending to the service.\r\n\r\nThere is a one-to-one mapping between the TypeSpec scalar kinds and the `SdkBuiltInKinds`.\r\n\r\n#### Interface\r\n\r\n```ts\r\nexport interface SdkBuiltInType extends SdkTypeBase {\r\n  kind: SdkBuiltInKinds;\r\n  name: string;\r\n  encode?: string;\r\n  baseType?: SdkBuiltInType;\r\n  crossLanguageDefinitionId: string;\r\n}\r\n```\r\n\r\nThe `crossLanguageDefinitionId` represents the fully qualified name of this type in TypeSpec language for the emitter to distinguish from the built-in TypeSpec types.\r\n\r\nFor a full list of types defined in `@azure-tools/typespec-azure-core` library, please refer to its reference doc.\n\n### SdkDateTimeType\n\n```ts\r\ninterface SdkDatetimeTypeBase extends SdkTypeBase {\r\n  name: string;\r\n  baseType?: SdkDateTimeType;\r\n  encode: DateTimeKnownEncoding;\r\n  // what we send over the wire. Often it's string\r\n  wireType: SdkBuiltInType;\r\n  crossLanguageDefinitionId: string;\r\n}\r\n\r\ninterface SdkUtcDatetimeType extends SdkDatetimeTypeBase {\r\n  kind: \"utcDateTime\";\r\n}\r\n\r\ninterface SdkOffsetDatetimeType extends SdkDatetimeTypeBase {\r\n  kind: \"offsetDateTime\";\r\n}\r\n```\n\n### SdkDurationType\n\n```ts\r\ninterface SdkDurationType extends SdkTypeBase {\r\n  kind: \"duration\";\r\n  name: string;\r\n  baseType?: SdkDurationType;\r\n  encode: DurationKnownEncoding;\r\n  // What we send over the wire. It's usually either a string or a float\r\n  wireType: SdkBuiltInType;\r\n  crossLanguageDefinitionId: string;\r\n}\r\n```\n\n### SdkArrayType\n\n```ts\r\ninterface SdkArrayType extends SdkTypeBase {\r\n  kind: \"array\";\r\n  name: string;\r\n  valueType: SdkType;\r\n  crossLanguageDefinitionId: string;\r\n}\r\n```\n\n### SdkDictionaryType\n\n```ts\r\ninterface SdkDictionaryType extends SdkTypeBase {\r\n  kind: \"dict\";\r\n  keyType: SdkType; // currently can only be string\r\n  valueType: SdkType;\r\n}\r\n```\n\n### SdkEnumType\n\n```ts\r\nexport interface SdkEnumType extends SdkTypeBase {\r\n  kind: \"enum\";\r\n  name: string;\r\n  // Determines whether the name was generated or not\r\n  isGeneratedName: boolean;\r\n  valueType: SdkBuiltInType;\r\n  values: SdkEnumValueType[];\r\n  isFixed: boolean;\r\n  isFlags: boolean;\r\n  usage: UsageFlags;\r\n  access: AccessFlags;\r\n  crossLanguageDefinitionId: string;\r\n  apiVersions: string[];\r\n  isUnionAsEnum: boolean;\r\n}\r\n```\n\n### SdkEnumValueType\n\n```ts\r\nexport interface SdkEnumValueType extends SdkTypeBase {\r\n  kind: \"enumvalue\";\r\n  name: string;\r\n  value: string | number;\r\n  enumType: SdkEnumType;\r\n  valueType: SdkBuiltInType;\r\n}\r\n```\n\n### SdkConstantType\n\n```ts\r\nexport interface SdkConstantType extends SdkTypeBase {\r\n  kind: \"constant\";\r\n  value: string | number | boolean | null;\r\n  valueType: SdkBuiltInType;\r\n  name: string;\r\n  isGeneratedName: boolean;\r\n}\r\n```\n\n### SdkUnionType\n\n```ts\r\nexport interface SdkUnionType extends SdkTypeBase {\r\n  name: string;\r\n  // determines if the union name was generated or not\r\n  isGeneratedName: boolean;\r\n  kind: \"union\";\r\n  variantTypes: SdkType[];\r\n  crossLanguageDefinitionId: string;\r\n}\r\n```\n\n### SdkTupleType\n\n```ts\r\nexport interface SdkTupleType extends SdkTypeBase {\r\n  kind: \"tuple\";\r\n  valueTypes: SdkType[];\r\n}\r\n```\n\n### SdkModelType\n\n```ts\r\nexport interface SdkModelType extends SdkTypeBase {\r\n  kind: \"model\";\r\n  // purposely can also be header / query params for fidelity with TypeSpec\r\n  properties: SdkModelPropertyType[];\r\n  // we will always have a name. generatedName determines if it's generated or not.\r\n  name: string;\r\n  isGeneratedName: boolean;\r\n  access: AccessFlags;\r\n  usage: UsageFlags;\r\n  additionalProperties?: SdkType;\r\n  discriminatorValue?: string;\r\n  discriminatedSubtypes?: Record<string, SdkModelType>;\r\n  discriminatorProperty?: SdkModelPropertyType;\r\n  baseModel?: SdkModelType;\r\n  crossLanguageDefinitionId: string;\r\n  apiVersions: string[];\r\n}\r\n```\n\n### UsageFlags\n\n```ts\r\nexport enum UsageFlags {\r\n  None = 0,\r\n  Input = 1 << 1,\r\n  Output = 1 << 2,\r\n  ApiVersionEnum = 1 << 3,\r\n  JsonMergePatch = 1 << 4,\r\n  MultipartFormData = 1 << 5,\r\n}\r\n```\n\n### AccessFlags\n\nWe default the value of `.access` property on model, enum, and method types to be `\"public\"`. So if the `@access` decorator isn't explicitly applied to one of these definitions, its value will be `\"public\"`.\r\n\r\nIf you want to know if a tsp author explicitly set the value with an `@access` decorator, you can call `getAccessOverride`\r\n\r\n```ts\r\nexport type AccessFlags = \"internal\" | \"public\";\r\n```\n\n### SdkEndpointType\n\n```ts\r\nexport interface SdkEndpointType {\r\n  kind: \"endpoint\";\r\n  serverUrl: string;\r\n  templateArguments: SdkPathParameter[];\r\n}\r\n```\n\n## Example Types\n\nThe example types help to model the examples that TypeSpec author defined to help user understand how to use the API.\r\n\r\nWe currently only have examples based on the payload, so the examples model will bind to the SdkServiceOperation.\n", "latency": 9.075622081756592, "response_length": 802}
{"query": "title: Define multiple response types from ResourceCollectionAction\n\nquestion: Hi,\nIs there a way to define multiple responses for \"ResourceCollectionAction\"?\nFor instance, I need to create a \"Post\" request where the response body varies based on the input values. However, \"ResourceCollectionAction\" seems to only allow a single response model by default. I am looking to pass multiple response models, such as 200, 201, and 202, to this single action operation \"ResourceCollectionAction.\"", "ground_truth": "Use the @sharedRoute decorator to model multiple logical operations at the same path.\nPrefer using a union of two models rather than a union of status codes for better API evolution.", "response": "Yes, TypeSpec allows you to define multiple response types for a single operation, including different status codes and response bodies. You can use the union operator (`|`) to specify multiple possible responses for an operation. Each response block can define a different status code and response body. For example, in a `POST` operation, you can define responses for status codes 200, 201, and 202, each with its own response model.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#02-operations-responses.md\n- document_title: Operations and Responses\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/02-operations-responses\n- document_content: # getting-started#getting-started-rest#02-operations-responses.md\n\n# Operations and Responses\n\n## Introduction\n\nIn this section, we'll build upon the basics we covered in the previous section. We'll define CRUD operations (Create, Read, Update, Delete) for our Pet Store API and discuss the benefits of using nested namespaces.\n\n## Defining CRUD Operations\n\nNext, we'll discuss how to define CRUD operations for our API. We'll cover operations for `Creating`, `Reading`, `Updating`, and `Deleting` pets, all within a nested namespace for better organization.\n\n### Example: Adding CRUD Operations\n\nLet's define the CRUD operations for our `Pet` model:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  };\r\n\r\n  @post\r\n  op createPet(@body pet: Pet): {\r\n    @statusCode statusCode: 201;\r\n    @body newPet: Pet;\r\n  };\r\n\r\n  @put\r\n  op updatePet(@path petId: int32, @body pet: Pet): {\r\n    @statusCode statusCode: 200;\r\n    @body updatedPet: Pet;\r\n  };\r\n\r\n  @delete\r\n  op deletePet(@path petId: int32): {\r\n    @statusCode statusCode: 204;\r\n  };\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@route` decorator defines the base path for the `Pets` namespace.\r\n- The `listPets` operation lists all pets.\r\n- The `getPet` operation retrieves a specific pet by its `petId`.\r\n- The `createPet` operation creates a new pet.\r\n- The `updatePet` operation updates an existing pet.\r\n- The `deletePet` operation deletes an existing pet.\n\n### Benefits of Nested Namespaces\n\nUsing nested namespaces in TypeSpec provides several benefits:\r\n\r\n1. **Organization**: Grouping related operations under a common namespace makes the API easier to manage and understand.\r\n2. **Operation IDs**: The TypeSpec compiler appends the namespace name to the `operationId` in the OpenAPI spec, making it clear which resource each operation is intended to operate on.\r\n3. **Clarity**: It helps in avoiding naming conflicts and provides a clear structure for the API.\r\n\r\n#### Example: Operation ID in OpenAPI Spec\r\n\r\nFor the `listPets` operation defined in the `Pets` namespace, the OpenAPI spec will generate an `operationId` like `Pets_listPets`, making it clear that this operation is related to the `Pets` resource.\n\n### Example: Route URLs for CRUD Operations\n\nHere's what the route URLs will look like for the CRUD operations defined in the `Pets` namespace:\r\n\r\n- **List Pets**: `GET https://example.com/pets`\r\n  - Retrieves a list of all pets.\r\n- **Get Pet by ID**: `GET https://example.com/pets/{petId}`\r\n  - Retrieves a specific pet by its `petId`.\r\n- **Create Pet**: `POST https://example.com/pets`\r\n  - Creates a new pet.\r\n- **Update Pet by ID**: `PUT https://example.com/pets/{petId}`\r\n  - Updates an existing pet by its `petId`.\r\n- **Delete Pet by ID**: `DELETE https://example.com/pets/{petId}`\r\n  - Deletes an existing pet by its `petId`.\n\n### Operation Flowchart\n\nFor clarity, here's a flowchart that depicts the flow of data and operations within the API:\r\n\r\n```\r\n[Client] --> [API Gateway] --> [listPets Operation] --> [Database] --> [Response: List of Pets]\r\n[Client] --> [API Gateway] --> [getPet Operation] --> [Database] --> [Response: Pet Details]\r\n[Client] --> [API Gateway] --> [createPet Operation] --> [Database] --> [Response: Created Pet]\r\n[Client] --> [API Gateway] --> [updatePet Operation] --> [Database] --> [Response: Updated Pet]\r\n[Client] --> [API Gateway] --> [deletePet Operation] --> [Database] --> [Response: Deletion Confirmation]\r\n```\n\n## Handling Different Types of Responses\n\nIn a real-world API, different operations might return different types of successful responses. Let's see how we can handle various response scenarios in TypeSpec.\n\n### Example: Handling Different Status Codes\n\nLet's update our pet operations to return different status codes based on the outcome.\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n    // highlight-start\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    // highlight-end\r\n  };\r\n\r\n  @post\r\n  op createPet(@body pet: Pet): {\r\n    @statusCode statusCode: 201;\r\n    @body newPet: Pet;\r\n    // highlight-start\r\n  } | {\r\n    @statusCode statusCode: 202;\r\n    @body acceptedPet: Pet;\r\n    // highlight-end\r\n  };\r\n\r\n  @put\r\n  op updatePet(@path petId: int32, @body pet: Pet): {\r\n    @statusCode statusCode: 200;\r\n    @body updatedPet: Pet;\r\n    // highlight-start\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    // highlight-end\r\n  };\r\n\r\n  @delete\r\n  op deletePet(@path petId: int32): {\r\n    @statusCode statusCode: 204;\r\n  };\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The pet operations are updated to handle different status codes, depending on the outcome of the operation reported by the backend service.\r\n\r\n**Explanation of the `|` Operator**:\r\n\r\n- The `|` operator is used to define multiple possible responses for an operation. Each response block specifies a different status code and response body.\r\n- In the `createPet` operation, for example, the `|` operator allows the operation to return either a 201 status code with a `newPet` object or a 202 status code with an `acceptedPet` object.\n\n### OpenAPI Spec Mapping\n\nHere is how the TypeSpec operation definitions map to the OpenAPI specification:\r\n\r\n<table>\r\n<tr>\r\n<td>TypeSpec Definition</td>\r\n<td>OpenAPI Spec</td>\r\n</tr>\r\n<td>\r\n\r\n```tsp\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n@get\r\nop listPets(): {\r\n@statusCode statusCode: 200;\r\n@body pets: Pet[];\r\n};\r\n\r\n@get\r\nop getPet(@path petId: int32): {\r\n@statusCode statusCode: 200;\r\n@body pet: Pet;\r\n} | {\r\n@statusCode statusCode: 404;\r\n};\r\n\r\n@post\r\nop createPet(@body pet: Pet): {\r\n@statusCode statusCode: 201;\r\n@body newPet: Pet;\r\n} | {\r\n@statusCode statusCode: 202;\r\n@body acceptedPet: Pet;\r\n};\r\n\r\n@put\r\nop updatePet(@path petId: int32, @body pet: Pet):{\r\n@statusCode statusCode: 200;\r\n@body updatedPet: Pet;\r\n} | {\r\n@statusCode statusCode: 404;\r\n} | {\r\n@statusCode statusCode: 500;\r\n};\r\n\r\n@delete\r\nop deletePet(@path petId: int32): {\r\n@statusCode statusCode: 204;\r\n@body NoContentResponse;\r\n} | {\r\n@statusCode statusCode: 404;\r\n};\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yml\r\npaths:\r\n  /pets:\r\n    get:\r\n      operationId: Pets_listPets\r\n      parameters: []\r\n      responses:\r\n        \"200\":\r\n          description: The request has succeeded.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                type: array\r\n                items:\r\n                  $ref: \"#/components/schemas/Pet\"\r\n    post:\r\n      operationId: Pets_createPet\r\n      parameters: []\r\n      responses:\r\n        \"201\":\r\n          description: The request has succeeded and a new resource has been created as a result.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n        \"202\":\r\n          description: The request has been accepted for processing, but processing has not yet completed.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\n\nas a result.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n        \"202\":\r\n          description: The request has been accepted for processing, but processing has not yet completed.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/Pet\"\r\n  /pets/{petId}:\r\n    get:\r\n      operationId: Pets_getPet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n      responses:\r\n        \"200\":\r\n          description: The request has succeeded.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n        \"404\":\r\n          description: The server cannot find the requested resource.\r\n    put:\r\n      operationId: Pets_updatePet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n      responses:\r\n        \"200\":\r\n          description: The request has succeeded.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n        \"404\":\r\n          description: The server cannot find the requested resource.\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/Pet\"\r\n    delete:\r\n      operationId: Pets_deletePet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n      responses:\r\n        \"204\":\n\n\"404\":\r\n          description: The server cannot find the requested resource.\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/Pet\"\r\n    delete:\r\n      operationId: Pets_deletePet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n      responses:\r\n        \"204\":\r\n          description: \"There is no content to send for this request, but the headers may be useful. \"\r\n```\r\n\r\n</td>\r\n</table>\r\n\r\n**Note**: As you can see, TypeSpec is much more compact and easier to read compared to the equivalent OpenAPI specification.\n\n## Conclusion\n\nIn this section, we demonstrated how to define CRUD operations for your REST API using TypeSpec and discussed the benefits of using nested namespaces. We also covered how to handle different types of successful responses.\r\n\r\nIn the next section, we'll dive deeper into handling errors in your REST API, including defining custom response models for error handling.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n", "latency": 15.601543664932251, "response_length": 435}
{"query": "title: How to keep the preview swagger files at same time when we publish a new version\n\nquestion: PR link: [Add first stable version for ACO API by liangchenmicrosoft  Pull Request #21743  Azure/azure-rest-api-specs-pr](https://teams.microsoft.com/l/message/19:906c1efbbec54dc8949ac736633e6bdf@thread.skype/1744044764127?tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47&groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&parentMessageId=1744044764127&teamName=Azure%20SDK&channelName=TypeSpec%20Discussion&createdTime=1744044764127)\nWe are going to publish a stable version API , but validation pipeline was failed with below error message, it looks like a new enabled validation rule, PR was build success previously.  Is it possible that we can skip this validation rule?\nAdd first stable version for ACO API  Azure/azure-rest-api-specs-pr@7c9d64c\nGenerated Swaggers:\n175  specification/carbon/resource-manager/Microsoft.Carbon/stable/2025-04-01/main.json\n176\n177  Output folder:\n178  specification/carbon/resource-manager/Microsoft.Carbon\n179\n180  Swaggers matching output folder and filename:\n181  specification/carbon/resource-manager/Microsoft.Carbon/preview/2023-04-01-preview/main.json\n182  specification/carbon/resource-manager/Microsoft.Carbon/preview/2024-02-01-preview/main.json\n183  specification/carbon/resource-manager/Microsoft.Carbon/stable/2025-04-01/main.json\n184\n185  Swaggers excluded via suppressions.yaml:\n186\n187\n188  Remaining swaggers:\n189  specification/carbon/resource-manager/Microsoft.Carbon/preview/2023-04-01-preview/main.json\n190  specification/carbon/resource-manager/Microsoft.Carbon/preview/2024-02-01-preview/main.json\n191  specification/carbon/resource-manager/Microsoft.Carbon/stable/2025-04-01/main.json\n192\n193  Rule Compile failed\n194\n195  Output folder 'specification/carbon/resource-manager/Microsoft.Carbon' appears to contain TypeSpec-generated swagger files, not generated from the current TypeSpec sources. Perhaps you deleted a version from your TypeSpec, but didn't delete the associated swaggers?\n196\n197  specification/carbon/resource-manager/Microsoft.Carbon/preview/2023-04-01-preview/main.json\n198  specification/carbon/resource-manager/Microsoft.Carbon/preview/2024-02-01-preview/main.json", "ground_truth": "Delete extra swagger files listed in the error or add previous versions back to TSP sources.\nAdd suppression rule for \"ExtraSwagger\" failure in the PR.\nDiscuss and provide proper guidance on how and when previews should be removed.\nKeep only one active preview version across all Azure specs.\nEnforce the standard of having only one active preview version in TypeSpec in the current quarter.", "response": "To keep the preview Swagger files while publishing a new stable version, you need to ensure that the TypeSpec configuration and validation rules are correctly set up. The validation error indicates that the pipeline is detecting Swagger files that may not align with the current TypeSpec sources. Here are steps to address this:\n\n1. **Ensure TypeSpec Sources Are Up-to-Date**: Verify that the TypeSpec definitions for all versions (including preview and stable) are correctly defined and aligned with the Swagger files.\n\n2. **Versioning in TypeSpec**: Ensure that versioning is enabled in your TypeSpec definitions using the `@versioned` decorator. This allows you to maintain multiple versions of the API, including preview and stable versions. Refer to the [Versioning Guide](https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis).\n\n3. **Suppress Validation Errors (if necessary)**: If the validation rule is new and you need to bypass it temporarily, you can use a `suppressions.yaml` file to exclude specific rules. However, this should be done cautiously and only as a temporary measure.\n\n4. **Review Swagger File Generation**: Ensure that the emitter configuration in `tspconfig.yaml` is correctly set up to generate Swagger files for all versions. Use the `azure-resource-provider-folder` option to specify the correct folder structure for preview and stable versions.\n\n5. **Run `tsp compile`**: Compile your TypeSpec files and address any warnings or errors to ensure consistency across all versions.\n\nBy following these steps, you can maintain both preview and stable Swagger files while ensuring the validation pipeline passes.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: emitters#typespec-autorest#index.md\n- document_title: TypeSpec AutoRest Library\n- document_link: https://azure.github.io/typespec-azure/docs/emitters/typespec-autorest/index\n- document_content: # emitters#typespec-autorest#index.md\n\n# TypeSpec AutoRest Library\n\nThis is a TypeSpec library that will emit an enriched OpenAPI 2.0 specification that can be consumed by AutoRest.\r\nThe generated OpenAPI spec will have custom `x-ms-` extensions properties and conform to standards required by AutoRest to generate a more accurate SDK.\n\n## Getting started\n\n1. Include `@azure-tools/typespec-autorest` dependencies in package.json\r\n\r\n```json\r\n{\r\n  ...\r\n  \"dependencies\": {\r\n    ...\r\n    \"@azure-tools/typespec-autorest\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\n2. Run `npm install` to install the dependency\r\n3. Import `@azure-tools/typespec-autorest` in your `main.tsp` file\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-autorest\";\r\n```\r\n\r\n4. Run `tsp compile`. This will result in a `swagger.json` file crated in `./tsp-output/swagger.json`\n\n## Use in autorest\n\nGenerate the OpenAPI spec as shown above then run autorest cli directly on it.\r\n\r\n```bash\r\nautorest --input-file=<path/to/generated/file.json>\n\n# Example\n\nautorest --input-file=./tsp-output/@azure-tools/typespec-autorest/openapi.json --python\r\n```\n\n## Configuration\n\n### Emitter options:\n\nEmitter options can be configured via the `tspconfig.yaml` configuration:\r\n\r\n```yaml\r\nemitters:\r\n  '@azure-tools/typespec-autorest':\r\n    <optionName>: <value>\n\n# For example\n\n`openapi.Org1.Service2.yaml`\r\n\r\nExample: Single service with versioning\r\n\r\n- `openapi.v1.yaml`\r\n- `openapi.v2.yaml`\r\n\r\nExample: Multiple service with versioning\r\n\r\n- `openapi.Org1.Service1.v1.yaml`\r\n- `openapi.Org1.Service1.v2.yaml`\r\n- `openapi.Org1.Service2.v1.0.yaml`\r\n- `openapi.Org1.Service2.v1.1.yaml`\r\n\r\nExample: azureResourceProviderFolder is provided\r\n\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n\r\n#### `examples-directory`\r\n\r\nDirectory where the x-ms-examples are located so the emitter can automatically link.\r\n\r\n#### `version`\r\n\r\nSelect which version should be emitted if the spec support versioning. By default all the version with be emitted in this format `<outputFileName>.<version>.json`\n\nemitters:\r\n  '@azure-tools/typespec-autorest':\r\n    output-file: my-custom-swagger.json\r\n```\r\n\r\nor via the command line with\r\n\r\n```bash\r\n--option \"@azure-tools/typespec-autorest.<optionName>=<value>\"\r\n\r\n--option \"@azure-tools/typespec-autorest.output-file=my-custom-swagger.json\"\r\n```\r\n\r\n#### `azure-resource-provider-folder`\r\n\r\n`resource-manager` directory under your service folder are located so the emitter can emit correct sub-folder structure and swagger files for each of the API versions. You must specify it for ARM specs with folder path relative to the TypeSpec files.\r\n\r\n#### `emitter-output-dir`\r\n\r\nSet the emitter output-dir. [See here](https://typespec.io/docs/handbook/configuration#emitter-output-dir)\r\n\r\n#### `output-file`\r\n\r\nConfigure the name of the swagger output file relative to the `output-dir`.\r\n\r\nOutput file will interpolate the following values:\r\n\r\n- service-name: Name of the service if multiple\r\n- version: Version of the service if multiple\r\n- azure-resource-provider-folder: Value of the azure-resource-provider-folder option\r\n- version-status: Only enabled if azure-resource-provider-folder is set. `preview` if version contains preview, stable otherwise.\r\n\r\nDefault: `{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/openapi.json`\r\n\r\nExample: Single service no versioning\r\n\r\n- `openapi.yaml`\r\n\r\nExample: Multiple services no versioning\r\n\r\n- `openapi.Org1.Service1.yaml`\r\n- `openapi.Org1.Service2.yaml`\r\n\r\nExample: Single service with versioning\r\n\r\n- `openapi.v1.yaml`\r\n- `openapi.v2.yaml`\r\n\r\nExample: Multiple service with versioning\r\n\r\n- `openapi.Org1.Service1.v1.yaml`\r\n- `openapi.Org1.Service1.v2.yaml`\r\n- `openapi.Org1.Service2.v1.0.yaml`\r\n- `openapi.Org1.Service2.v1.1.yaml`\r\n\r\nExample: azureResourceProviderFolder is provided\r\n\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n\r\n#### `examples-directory`\n\n### `new-line`\n\nSet the newline character for emitting files. Can be either:\r\n\r\n- `lf`(Default)\r\n- `crlf`\n\n### `omit-unreachable-types`\n\nOnly include types referenced via an operation.\n\n## Decorators\n\n- [@collectionFormat](#collectionformat)\r\n- [@example](#example)\r\n- [@useRef](#useref)\n\n### @collectionFormat\n\nSyntax:\r\n\r\n```\r\n@collectionFormat(formatString)\r\n```\r\n\r\n`@collectionFormat` specifies array property type serialization format. Valid format strings are \"csv\", \"multi\", \"ssv\", \"tsv\", \"pipes\" though \"csv\" or \"multi\" are recommended.\r\n\r\n`@collectionFormat` can only be specified on model properties that are arrays.\n\n### @example\n\nSyntax:\r\n\r\n```\r\n@example(pathOrUri, title)\r\n```\r\n\r\n`@example` attaches example files to an operation. Multiple examples can be specified.\r\n\r\n`@example` can only be specified on operations.\n\n### @useRef\n\nSyntax:\r\n\r\n```\r\n@useRef(urlString)\r\n```\r\n\r\n`@useRef` is used to replace the TypeSpec model type in emitter output with a pre-existing named OpenAPI schema such as ARM common types.\n\n## How to\n\n### Include `x-ms-skip-url-encoding` in `x-ms-parmaeterized-host` parameter\n\nEvery parameter of type `uri` in `@server` will be marked with `x-ms-skip-url-encoding`.\r\n\r\n```typespec\r\n@server(\"{endpoint}/v2\", \"Account endpoint\", {endpoint: url})\r\n```\r\n\r\nResult in\r\n\r\n```json5\r\n{\r\n  in: \"path\",\r\n  name: \"endpoint\",\r\n  required: true,\r\n  type: \"string\",\r\n  format: \"uri\",\r\n  \"x-ms-skip-url-encoding\": true,\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n", "latency": 12.677921056747437, "response_length": 1663}
{"query": "title: Customizing key for child operation\n\nquestion: Is there a way to customize the key of a parent resource for a specific child operation?\nIn SDKs we are being asked to change the name, but I couldn't find a good place to apply the @clientName decorator.", "ground_truth": "Rename the property globally to \"jobName\" for consistent naming.\nUse the @key decorator on the name property of the resource.", "response": "Yes, you can customize the key of a parent resource for a specific child operation in TypeSpec. To achieve this, you can use the `@key` decorator to define the parameter name for the child resource's key. Additionally, you can use the `@clientName` decorator to rename the key for specific SDKs or languages. For example, if you have a child resource and want to customize its key, you can define it as follows:\n\n```typespec\n@parentResource(ParentResource)\nmodel ChildResource {\n  @key(\"customKeyName\")\n  name: string;\n}\n\n@@clientName(ChildResource.name, \"custom_client_key\", \"python\");\n```\n\nIn this example, the `@key` decorator specifies the key name for the child resource, and the `@clientName` decorator customizes the name for the Python SDK. This approach ensures that the key is properly defined for the parent-child relationship and can be customized for specific SDKs.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#05renaming.mdx\n- document_title: Renaming\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/05renaming\n- document_content: # howtos#generate-client-libraries#05renaming.mdx\n\n# Renaming\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents how to customize the name of models, operations, and parameters. For an overview of the setup, please visit the setup page.\r\n\r\n:::note\r\nThe TypeSpec compiler provides an `@encodedName` decorator that allows changing the name of the property for a given serialization format.\r\nHowever in Azure we recommend that you define the property name as the value sent on the wire and use the `@clientName` decorator to change the name of the generated property.\r\n:::\n\n## Default behaviors\n\nBy default, any language code generator will assume the TYPESPEC name is the client. For clarity, generators do not attempt to do any auto-magic rename.\r\n\r\n> **NOTE:** While names are not transformed, they will be adapted to what is idiomatic of the language (Python snake_case, etc.).\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=main.tsp\r\nnamespace PetStoreNamespace;\r\n\r\n/** This is the input I need */\r\n@resource(\"input\")\r\nmodel InputModel {\r\n  /** Id of this object */\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n}\r\n\r\n/** Read my resource */\r\nop get is ResourceRead<InputModel>;\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  name: str = rest_field(readonly=True)\r\n\r\nresponse: InputModel = client.get_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\ninterface InputModel {\r\n  name: string;\r\n}\r\n\r\nconst model: InputModel = await client.path(\"/petStore/model/{name}\").get();\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\n### Renaming models and attributes\n\nYou can rename models and attributes. [Renames have a target](https://microsoft.github.io/typespec/standard-library/projected-names#known-targets):\r\n\r\n- `client` means that all client will use that name\r\n- `csharp`, `javascript`, `python`, `java` means you target this specific language\r\n\r\nLanguage target takes priority over `client` target.\r\n\r\n> **NOTE:** As model name do not get serialized as JSON, sometimes the best choice is to rename the main TYPESPEC for clarity. Talk to your emitter contact is you're unsure\r\n> if you should rename the model in the main TYPESPEC or customize it.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(InputModel, \"InputOptions\"); // Use InputOptions as a base name in clients\r\n@@clientName(InputModel, \"ParameterOptions\", \"csharp\"); // Prefer a different name for C# only\r\n\r\n@@clientName(InputModel.name, \"input_name\", \"python\"); // Python may need a different to be idiomatic\r\n```\r\n\r\n```python\r\nclass InputOptions:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\n\r\nresponse: InputOptions = client.get_computed_model(input_name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class ParameterOptions\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\n\n{\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputOptions {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputOptions get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n### Renaming operations and parameters\n\nSimilarly, you can rename operations like in the example below:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(Get, \"Read\"); // Use InputOptions as a base name in clients\r\n@@clientName(Get, \"GetComputed\", \"python\"); // Note that Python will still snake_case it\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\nresponse: InputModel = client.get_computed_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> ReadModelAsync(string name, RequestContext context) {}\r\n    public virtual Response ReadModel(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> ReadModelAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> ReadModel(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> readModelWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel readModel(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\r\n\r\nYou cannot at this moment rename parameters in the client.tsp file. You will need to add the `@clientName` decorator over the parameter directly, example:\n\n## Implementation\n\n### Order of Operations\n\nFor consistency when generating code, the order in which overrides are applied is important. Code emitters should apply overrides in the following order.\r\n\r\n#### Over-the-Wire JSON Names\r\n\r\nFor determining the final name of a TypeSpec entity when sent over-the-wire in JSON:\r\n\r\n1. If the `@encodedName` decorator exists, use this value\r\n2. Use the original name in the spec\r\n\r\n#### Client SDK Names\r\n\r\nFor determining the final name of a TypeSpec entity when used in a client SDK (e.g. Python):\r\n\r\n1. Check if there's a scoped `@clientName` decorator for your emitter\r\n2. Check if there's a `@clientName` decorator at all\r\n3. Check the friendly name\r\n4. Use the original name in the spec\r\n\r\n**Note: If the object name is from `@clientName` decorator, do not apply your language's casing rules on it. If it's not, apply your language's heuristics (i.e. for Python, apply snake casing)**\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step07.md\n- document_title: 7. Defining child resources\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step07\n- document_content: # getstarted#azure-core#step07.md\n\n# 7. Defining child resources\n\nSometimes your resource types will need to have child resources that relate to their parent types. You can identify that a resource type is the child of another resource by using the `@parentResource` decorator.\r\n\r\nFor example, here's how you could create a new `WidgetPart` resource under the `Widget` defined above:\r\n\r\n```typespec\r\n/** A WidgetPart resource belonging to a Widget resource. */\r\n@resource(\"parts\")\r\n@parentResource(Widget)\r\nmodel WidgetPart {\r\n  @key(\"partName\")\r\n  name: string;\r\n\r\n  /** The part number. */\r\n  number: string;\r\n\r\n  /** The part name. */\r\n  partName: string;\r\n}\r\n```\r\n\r\nWhen you use the standard resource operations with child resource types, their operation routes will include the route of the parent resource. For example, we might define the following operations for `WidgetPart`:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = Azure.Core.ResourceOperations<ServiceTraits>;\r\n\r\n/** Creates a WidgetPart */\r\ncreateWidgetPart is Operations.ResourceCreateWithServiceProvidedName<WidgetPart>;\r\n\r\n/** Get a WidgetPart */\r\ngetWidgetPart is Operations.ResourceRead<WidgetPart>;\r\n```\r\n\r\nThese operations will be defined under the route path:\r\n\r\n```\r\n/widgets/{widgetName}/parts/{partName}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-type.md\n- document_title: ARM Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type\n- document_content: # howtos#arm#resource-type.md\n\n# ARM Resource Types\n\n## Introductions\n\nIntroduction\r\nResources are the basic building blocks of Azure. When a customer interacts with Azure through the Control Plane (ARM), they generally will be reading (GET), writing (PUT/PATCH), deleting (DELETE) or performing actions upon (POST) one or more resources. Each resource is managed by a particular Resource Provider, so we uniquely identify a resource by its 'fully-qualified type'. Some well-known examples of types are Microsoft.Compute/virtualMachines, or Microsoft.Network/networkSecurityGroups/securityRules. See Resource Ids for a more in-depth breakdown of the id and associated fields.\r\n\r\nIn order to give customers a consistent API when working with many different Resource Providers, and to allow ARM to understand and manage resources programmatically, ARM requires each RP to follow a set of contracts for resource management, defined in the ARM RPC.\n\n## ARM Resource Terminology\n\nThe most important distinction between resources is between _Tracked_ and _Proxy_ resources. Tracked resources are resources in which all of the metadata is maintained in Azure Resource Manager. Tracked Resources can be targeted to specific regions, and are generally the best choice for most top-level resources. Azure Resource Manager maintains data about Tracked Resources, and generally will handle many implementation details or operations on the resource. See [RPC: Resource API Reference](https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md) for further information on the contract for Tracked Resources.\r\n\r\nProxy resources are resources in which only a portion of resource metadata is tracked in ARM. Generally, these model resources maintained on other systems, or that resource-providers want to track themselves. Generally, resource providers must implement most of the operations for Proxy resources. Tenant, Extension, and child resources are usually modeled as Proxy resources.\r\n\r\nThere is a good discussion on making the choice between Tracked and Proxy Resources in the armwiki discussion [Tracked vs Proxy Resources](https://armwiki.azurewebsites.net/rp_onboarding/tracked_vs_proxy_resources.html)\n\n## Choosing a Resource Type\n\n- The large majority of resources have their metadata tracked by ARM, can be assigned to regions, and are contained inside a resource group in a subscription, for ease of management and billing. These are called [Tracked Resources](#tracked-resources).\r\n- Some resources may need to have scope across an entire customer tenant, or may need to have a single instance across all customer subscriptions. These are called [tenant resources](#tenant-resources).\r\n- Some kinds of resources may augment or alter the functionality of resources or resource containers provided by other resource-providers. For example, policy or RBAC rules may be applied to any resource or resource container. These resources are called [extension resources](#extension-resource).\r\n- Some resources are complex and naturally break down into one or more components that are separately configurable, but an integral part of the larger resource (for example, a virtual network resource may contain many separately configurable subnets). These component resources are called [child resources](#child-resource).\r\n- Rarely, some resources may need to apply across a subscription, or have a single instance in a customer subscription, these are called [subscription-based resources](#subscription-based-resource).\r\n- Rarer still, some resources may need to apply across a specific region, or have a single instance in a region, these are called [location-based resources](#location-based-resource).\r\n- In some cases, there can only be one instance of a resource at a specific scope - this is rare, but happens most frequently in tenant, child, and location resources. In typespec, you will need to specify that the resource is a singleton, and the resource manager tools will automatically apply the correct pattern for singleton resources (using the recommended resource name 'default')\n\n## Modeling Resources in TypeSpec\n\nResources are modeled in TypeSpec by choosing a _base resource type_, defining _rp-specific properties_, and optionally mixing in _standard envelope properties_. Later sections document [how to model resource operations](./resource-operations.md). The following sections discuss usage of each of the base resource types. Later sections discuss [designing rp-specific properties](#designing-resource-specific-properties) and [adding standard ARM envelope properties](#adding-optional-standard-envelope-properties).\n\n### Tracked Resources\n\nTracked resources use the `TrackedResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tracked Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Tenant Resources\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@tenantResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tenant Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Extension Resource\n\nExtension resources use the `ExtensionResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is ExtensionResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Extension Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Child Resource\n\nChild resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@parentResource(EmployeeResource)\r\nmodel JobResource is ProxyResource<JobProperties> {\r\n  /** The job name */\r\n  @segment(\"jobs\")\r\n  @key(\"jobName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@parentResource`: designates the model type for the parent of this child resource. The resource identifier for this resource will be prepended with the resource identity of the parent.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Child Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Subscription-based Resource\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@subscriptionResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@subscriptionResource`: designates this resource as being a cross-subscription resource, with scope across all resource groups in the subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Subscription Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Location-based Resource\n\nLocation-based resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@locationResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@locationResource`: designates this resource as being a cross-location resource, with scope across a location within a subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Location Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Singleton Resource\n\nSingleton resources can use any resource base type, but most often use `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@singleton\r\n@tenantResource\r\nmodel EmployeeAgreementResource is ProxyResource<EmployeeAgreementProperties> {\r\n  /** The default employee agreement, applying to all employees. */\r\n  @segment(\"employeeAgreements\")\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@singleton`: indicates that there can only be one of the resources in the resource container (in this case, only one instance in the customer tenant).\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource. For a singleton, the name value will always be the same.\r\n`@segment(employeeAGreements)`: provides the resource type name for this resource.\r\n`@key`: provides the parameter name for the name of the resource in operations that use this resource - this will not be a settable value for singleton resources.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Singleton Resources [in the Singleton sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/arm-scenarios/singleton/main.tsp#L29).\n\n## Designing Resource-specific Properties\n\nEach resource model consists of two distinct parts\r\n\r\n- An outer _envelope_ of information that provides metadata for optional standardized ARM functionality, like entity-tags and managed identities, and is processed by Azure Resource Manager.\r\n- An inner set of properties that are specific to the resource and are defined by the resource provider.\r\n\r\nModifying the ARM envelope is discussed in later sections on [mixing in standard ARM envelope add-ons](#adding-optional-standard-envelope-properties).\r\n\r\nThe inner _rp-specific property bag_ consists of all of the properties that the RP needs to manage about the resource. Properties should be completely specified, should not duplicate properties from the _ARM envelope_, and may consist of simple types, arrays, or other complex properties.\r\n\r\nHere is an example of a property bag for the `EmployeeResource` resource.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n\r\nunion EmployeeProvisioningState {\r\n  string,\r\n\r\n  /** The resource create request has been accepted */\r\n  Accepted: \"Accepted\",\r\n\r\n  /** The resource is being provisioned */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is updating */\r\n  Updating: \"Updating\",\r\n\r\n  /** Resource has been created. */\r\n  Succeeded: \"Succeeded\",\r\n\r\n  /** Resource creation failed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\n\nfailed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n\r\nmodel EmployeeProperties {\r\n  /** The current title of the employee */\r\n  title: string;\r\n\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  level: EmployeeLevel;\r\n\r\n  @visibility(Lifecycle.Read)\r\n  employeeId: int32;\r\n\r\n  biography?: string = \"No biography provided\";\r\n  colleagues: EmployeeResourceId[];\r\n  employmentHistory: Job[];\r\n\r\n  @visibility(Lifecycle.Create)\r\n  password: Password;\r\n\r\n  provisioningState?: EmployeeProvisioningState;\r\n}\r\n```\r\n\r\n`EmployeeProperties` specifies the employee metadata that the RP needs to track and manage. Notice that the model uses built-in scalar types like `string` and `int32`, new types built from scalar types with added constraints, like `Password` and `EmployeeLevel`, enumerations of values, like `EmployeeProvisioningState`, and complex types. The individual components of this model are described below.\r\n\r\nNote that _documentation comments on all models and model properties are required when specs are checked in_. Here they are omitted for clarity. The TypeSpec compiler and TypeSpec IDE tooling will emit warning diagnostics if you emit required documentation, and about most of the ARM rules described in this document.\n\n### The `provisioningState` Property for Tracked Resources\n\nAll Tracked Resources are required to implement a 'provisioningState' property in their rp-specific property bag. This is used by ARM and some ARM clients to track the provisioning state of a resource as it is created and deleted. At minimum, the provisioning state must contain the standard terminal values that ARM is looking for. There are contained in the `ResourceProvisioningState` enumeration in the Azure.ResourceManager library. If RPs have other provisioning states they would like to track, they can define their own provisioning state enum, and mix in the value, as shown in the sample above, or they may simply use the standard provisioning state as shown in the sample below:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  ...ResourceProvisioningState;\r\n}\r\n```\r\n\r\nNote that this example uses the spread operator `...`, which allows you to simply include the properties from a source model in the target model you are constructing. This has the effect of copying the properties of the source model and their decorations into the target model, without creating any nominal inheritance relationship.\r\n\r\nAlternately, this is also equivalent:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  /** The status of the last provisioning operation performed on the resource. */\r\n  @visibility(Lifecycle.Read)\r\n  provisioningState?: ResourceProvisioningState;\r\n}\r\n```\n\n### Required and Optional properties and Property Defaults\n\nIn the examples, note that some model properties use the optional operator `?` after the property name, like `biography?` and some do not, like `title`. Property names using the `?` are optional properties, which may or may not be provided in the request body for CreateOrUpdate (PUT) requests. Property names without the `?` are required properties, which must be provided in PUT requests. The exception is that properties that have 'readOnly' visibility do not appear in requests, but may be required or optional in responses.\r\n\r\nAlso note that optional properties may specify defaults, as with `biography?: string = \"No biography provided\"`. The default indicates the value that will be recorded on the server if no value is sent by the client.\n\n### Defining Custom Types\n\nIn the sample, new constrained scalar types and new complex model types are defined and used inside the _rp-specific property bag_. TypeSpec allows you to define custom types for use in your specification.\r\n\r\nYou will often want to define scalar types or properties that have constraints. For example, numeric values may be constrained to have a certain minimum or maximum, strign values may be constrained to follow a particular regex pattern, and so on. Whenever these constrained types are used in your spec, the constraints will be transmitted to the usage.\r\n\r\nThe example creates a numeric type with minimum and maximum constraints:\r\n\r\n```typespec\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n```\r\n\r\nThis defines 'EmployeeLevel' as an integer value between 50 and 70. The example also defines a complex type used in an array:\r\n\r\n```typespec\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n```\r\n\r\nMode details on what to consider when using complex types in an array are discussed in the section on [modeling arrays of complex types](#modeling-arrays-of-complex-types).\n\n### Using Resource identifiers\n\nIt is often the case that resources need to reference other resources to provide specific pieces of functionality. For example, resources may need to reference a storage account to use for storing user data, or a NIC to attach to a Network. The `Azure.ResourceManager` library defines a `ResourceIdentifier` template that allows you to easily represent references to resources in your API. The template allows you to specify one or more acceptable resource types, automatically designating the value as a resource reference, and providing the appropriate pattern validation - which helps in generating better code, better ARM templates, and better documentation for your API.\r\n\r\n```typespec\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\nscalar NetworkInterfaceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/networkInterfaces\",\r\n    },\r\n    {\r\n      type: \"Microsoft.ClassicNetwork/networkInterfaces\",\r\n    }\r\n  ]>;\r\n```\r\n\r\nThe `NetworkInterfaceId example shows how to allow multiple resource types in a reference.\n\n### Property Visibility and Other Constraints\n\nThe sample uses the `@visibility` decorator to indicate how the resource definition is used in requests to PUT and PATCH operations, and in responses to PUT, PATCH, GET, and LIST operations.\r\n\r\nThis table shows how visibility is used to determine whether a property is used in requests and responses:\r\n\r\n| Visibility           | In Create Request? | In Patch Request/ Updateable in PUT | In Responses | Sample                                         |\r\n| -------------------- | ------------------ | ----------------------------------- | ------------ | ---------------------------------------------- |\r\n| None                 | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create, update | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create         | Yes                | No                                  | Yes          | resource location                              |\r\n| read, update         | No                 | Yes                                 | Yes          | Properties only settable after creation (keys) |\r\n| create, update       | Yes                | Yes                                 | No           | Secrets (e.g. password)                        |\r\n| read                 | No                 | No                                  | Yes          | Calculated properties, e.g. provisioningState  |\r\n| update               | No                 | Yes                                 | No           | Secrets (e.g. keys)                            |\r\n| create               | Yes                | No                                  | No           | Secrets (e.g. user-defined password)           |\n\n### Modeling Arrays of Complex Types\n\nFinally, when your _rp-specific property bag_ contains an array of complex properties, there are a few important considerations:\r\n\r\n- The complex properties in an array must have a key property - this means a property named 'name' or 'id' that uniquely identifies the property in the array. The TypeSpec tools will emit a diagnostic if you omit this.\r\n- ARM resources must be fully loaded in memory, so there are limits to the size of arrays in the properties of a resource. If your array is not strictly bounded, you should consider modeling the array property as a [child resource](#child-resource)\r\n- Updating the contents of arrays can be difficult, and result in data loss under simultaneous updates, especially as Json-Merge-Patch is not widely supported in ARM update operations. If users will frequently need to update the contents of arrays, you should consider modeling as a [child resource](#child-resource).\n\n## Adding Optional Standard Envelope Properties\n\nIn addition to the resource-specific property bag, a resource may configure on or more standard ARM features through the use of standard properties in the _ARM Envelope_. Standard features configured in the envelope include:\r\n\r\n- **Managed Identity**: Associating a managed identity with the resource to authorize actions taken by this resource on other resources.\r\n- **SKU**: A standard mechanism for configuring levels of service for a resource.\r\n- **Plan**: A standard mechanism for configuring MarketPlace billing plans for a resource.\r\n- **ETags**: A standard mechanism for managing concurrent operations over the resource.\r\n- **ResourceKind**: A standard mechanism for specifying a type of user experience in the portal.\n\n### Managed Identity\n\nStandard configuration for ARM support of both SystemAssigned and UserAssigned Managed Service Identity (MSI)\r\n\r\n- If a resource allows both generated (SystemAssigned) and user-assigned (UserAssigned) Managed Identity, use the spread (...) operator to include the standard ManagedServiceIdentity envelope property. This will allow users to manage any ManagedServiceIdentity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedServiceIdentity;\r\n  }\r\n  ```\r\n\r\n- If a resource allows only generated (SystemAssigned) Managed Identity, use the spread operator (...) to include the `ManagedSystemAssignedIdentity` standard envelope property in the resource definition. This will allow users to manage the SystemAssigned identity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedSystemAssignedIdentity;\r\n  }\r\n  ```\r\n\r\nFor more information, see [Managed Service Identity Support](https://eng.ms/docs/products/arm/rpaas/msisupport)\n\n### SKU\n\nStandard support for setting a SKU-based service level for a resource. To enable SKU support, add the `ResourceSku` enevelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceSku;\r\n}\r\n```\r\n\r\nFor more information, see [SKU Support](https://eng.ms/docs/products/arm/rpaas/skusupport)\n\n### ETags\n\nIndicator that entity-tag operation concurrency support is enabled for this resource. To enable ETags, add the `EntityTag` envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...EntityTag;\r\n}\r\n```\r\n\r\nFor more information, and limitations on RPaaS concurrency support, see [RPaaS ETag Support](https://eng.ms/docs/products/arm/rpaas/etags)\n\n### Plan\n\nSupport for marketplace billing configuration for the resource. To enable `Plan` support, add the `ResourcePlan` standard envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourcePlan;\r\n}\r\n```\r\n\r\nSee [MarketPlace Third Party Billing SUpport](https://eng.ms/docs/products/arm/rpaas/custom_billing)\n\n### ResourceKind\n\nSupport for certain kinds of portal user experiences based on the kind of resource. To include 'Kind' in the resource defintion, add the `ResourceKind` standard envelope property.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceKind;\r\n}\r\n```\r\n\r\nFor more information on user experiences in the Azure Portal, see [Portal Support](https://eng.ms/docs/products/arm/rpaas/portal/gettingstarted)\n\n### ManagedBy\n\nSupport for management of this resource by other resources. To add 'ManagedBy' support to the resource, add the `ManagedBy` envelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ManagedBy;\r\n}\r\n```\r\n\r\nFor more information on supporting 'ManagedBy', see [ManagedBy API Contract](https://eng.ms/docs/products/arm/api_contracts/managedby)\n\n## Reference\n\n[Fundamentals - ARM Wiki](https://armwiki.azurewebsites.net/fundamentals/overview.html)\n", "latency": 8.780639171600342, "response_length": 878}
{"query": "title: Default value starting from a specific API version\n\nquestion: Hello, we currently have a property (StatelessServiceProperties,minInstancePercentage) that does not currently have a default value in our spec, but in practice is treated as if it is 0.\nazure-rest-api-specs/specification/servicefabricmanagedclusters/resource-manager/Microsoft.ServiceFabric/preview/2025-03-01-preview/servicefabricmanagedclusters.json at main  Azure/azure-rest-api-specs\nWe would like to treat the default prior to 2025-06-01 as 0, then as a different value from 2025-06-01 onward in our service.\nWe haven't changed the default for an existing property before. Are there concerns about this intended behavior?\nIn Typespec, is it possible to add a default value in our spec from a specific api version (say 2025-06-01) onward?", "ground_truth": "I think you need to run this change by the breaking change board, as a change in the default may be breaking, depending on the details.  Also, the most important thing is to make sure that the API description accurately reflects service behavior - if the default has always been in place, for example, it may be better to just change the default and go through the breaking change process.  Yes, it is possible to do this in TypeSpec, but involves removing and renaming the old property and adding a new property with the new default, [like this](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjQtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCu0AxTH%2FAMX%2FAMX%2FAMX%2FAMX%2FAMXtAMXsAKntAMU1LTAzLTAx%2FwC9%2FwC9%2FwC9%2FwC9%2FgC95wChYCwKfeYCbUHoAm%2FrAogg6AOq5ADAbW9kZWwgRW1wbG95ZWUgaXMgVHJhY2tlZMh6PMgcUHJvcGVydGllcz7lAp4uLukAnuQDUFBhcmFtZXRlcskxPjvoAIbJX3DJRNJ8ymDpAv1BZ2Ugb2YgZcg%2F5gFwcmVtb3brA4Au9AG35QFacmXkA5pkRnJvbd4uLCAiYWdlIsQ1Zm9ybWVyQWdlPzogaW50MzI76AIB9gCOYWRk%2FwCM5QCMYcpRID0gMjHJVkNpdHnSV2NpdHk%2FOiBzdHLlBR7HLFByb2ZpbPQAhmVuY29kZSgiYmFzZTY0dXJs5QDMcMYwPzogYnl0ZXPJSFRoZSBzdGF0dXPES3RoZSBsYXN0IOQBgGF0aW9u5QUxICBAdmlzaWJpbGl0eShMaWZlY3ljbOQCk2Fkx13EIOUFwFN0YXTEZ%2BUCZswU6QIDxHPMMuUAgOUAymHpApDFd0Bscm%2FEO3VzCnVu5ANl0VTlAh%2FmARrpA53EX8hHIGNyZcQncmVxdWVzdCBoYXMgYmVlbiBhY2NlcHRlZMRnICBBxw46ICLICyLWUGnEQOQAtOkAwchE7ACcOiAizA%2FaTHVwZGF0xE%2FFQ1XHDjogIsgLyjvpBtrpAMTmANxk5wGiU3VjY2VlZOUAxckM0z%2FFNuQBTWZhaWzJPkbFDTogIsYJ3Dh3YXMgY2FuY2XKPkPHD%2BQHMscL%2FwFAIGRlbGXpAYBExA3mAPnICyLpBLjpBDLkA%2BvpAcrpBDRNb3ZlUscV6AQtxHNtb3bEaGZyb20gbG9j5gC8xW7EE%2FEDUMszdG%2FPMXRvyi%2F3AJVzcG9uc%2BsFRuYAlscW7ACX7gNsxT7FZMZ85gLuzW5pbnRlcmbkCFFP6AOUcyBleHRlbmRz9gkTLsspe30K5QjvyCPKG8tZ6ADN5gVuZ2V05AGnQco15APn7AXLIOcCe09y5QKn5QHWyy9Dxx1SZXBsYWNlQXN5bmPOP%2BUC99A3UGF0Y2hTzCws8wYRxUDmAj3PQOUCOmVXaXRob3V0T2vTd2xpc3RCecgwR3JvdXDPREzFIlBhcmVudNQ8U3Vic2NyaXDlAhzGO8YzzBnMOegGMCBzYW1wbOsDCWFjxUR0aGF05gIG6QXGdG8gZGlmZmXkAITvAonFKe4AskHFSO8BN%2BsDFMgN5gKL8wCSSEVBROoF78R%2BY2hlY2vqAKpleGlzdGVu5ggkIMYeRckU7wH7zR3uB%2F8%3D&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D)", "response": "Yes, in TypeSpec, you can specify default values for properties starting from a specific API version using the `@added` decorator from the `@typespec/versioning` library. This allows you to define version-specific behavior for models or properties. For example, you can define a property with a default value starting from a specific version like this:\n\n```tsp\nimport \"@typespec/versioning\";\nusing Versioning;\n\n@versioned(Versions)\nnamespace MyService;\n\nenum Versions {\n  v1: \"1.0\",\n  v2: \"2.0\",\n}\n\nmodel Example {\n  @added(Versions.v2)\n  propertyWithDefault?: int32 = 42;\n}\n```\n\nIn this example, the `propertyWithDefault` is introduced in version `v2` with a default value of `42`. For earlier versions, this property will not exist in the API specification.", "context": "- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n", "latency": 8.721836566925049, "response_length": 759}
{"query": "title: Swagger LintDiff error: Properties of a PATCH request body must not be required, property:location\n\nquestion: Hi all,\nI'm getting a LintDiff error for a PATCH API, where it wants the location property of the TrackedResource type to not be required (you can see the failure is here: Release the Fleet 2025-04-01-preview API by dvadas  Pull Request #33620  Azure/azure-rest-api-specs). What's the simplest way to fix this?\nI see an old thread about this issue: Alexander Zaslonov: Location property in TrackedResource breaks validation\nposted in Azure SDK / TypeSpec Discussion on Thursday, October 24, 2024 12:15 PM. There are a few solutions mentioned there:\nUse the #emit-common-types-schema setting and suppress the LintDiff error (how?)\nUse the \"better support for PATCH common types in both swagger and typespec that will be rolling out next sprint.\" Assumedly this is rolled out by now, but I'm not clear what it is?\nFallback to a custom solution\nNone of these are very clear. I tried setting #emit-common-types-schema to for-visibility-changesand it does indeed go and update a bunch of old API versions (as described in the old thread), so that seems like a bad idea.", "ground_truth": "Use ArmCustomPatchAsync instead of ArmResourcePatchAsync for the PATCH API issue.\nCreate a custom GatePatch model to resolve the LintDiff error.", "response": "To resolve the LintDiff error for your PATCH API, where the `location` property of the `TrackedResource` type must not be required, you can use the `@azure-tools/typespec-autorest` emitter configuration to suppress the error. Specifically, you can configure the `tspConfig.yaml` file to use the `#emit-common-types-schema` setting. However, based on your concern about updating old API versions, the recommended approach is to use the latest PATCH operation template provided by TypeSpec for ARM resources.\n\nHeres how you can define your PATCH operation:\n\n```tsp\n// LRO PATCH template with required headers, response codes, and lro options\nop update is ArmResourcePatchAsync<MyResource, MyResourceProperties>;\n```\n\nThis ensures that the PATCH operation adheres to the latest standards and avoids the LintDiff error. If you still encounter issues, you can suppress the error by configuring the emitter in `tspConfig.yaml`:\n\n```yaml\ntspConfig.yaml\nemit:\n  - \"@azure-tools/typespec-autorest\"\noptions:\n  \"@azure-tools/typespec-autorest\":\n    use-read-only-status-schema: true\n```\n\nThis configuration ensures that properties like `location` are treated as non-required for PATCH operations.", "context": "- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#status-read-only-error.md\n- document_title: `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error\n- document_content: # troubleshoot#status-read-only-error.md\n\n# `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\n\nWhen trying to check in an ARM specification to the `azure-rest-api-specs` repository, your specification\r\nshows violations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\n\n## Symptoms\n\nIn the `Swagger LintDiff` or `Swagger(RPaaS) LintDiff` checks, your specification shows one or more\r\nviolations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\n\n## Cause\n\nThe LintDiff swagger scripts use an old validation mechanism that does not detect `readOnly` properties, but requires the\r\ntype schema referenced by the properties to be `readOnly` instead.\n\n## Workaround\n\nUntil this validation is fixed, you can configure the `@azure-tools/typespec-autorest` emitter in `tspConfig.yaml`\r\nto always output any `ProvisioningState` schema as readOnly, using the `read-only-status-schema` option. This\r\nresolves the LintDiff violation. Note that if you use the scaffolding template for `ARM`, this configuration is\r\nenabled automatically.\r\n\r\n```diff lang=yaml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n+    use-read-only-status-schema: true\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#lintdiff.md\n- document_title: Resolving Swagger Lint Diff Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/lintdiff\n- document_content: # migrate-swagger#faq#lintdiff.md\n\n# Resolving Swagger Lint Diff Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Resolving Swagger LintDiff Violations\n\n### `VisibilityChanged` for `nextLink` and `value` properties\n\nThe issue is that some older specifications marked these values as read only. This has no real impact on the API or client generation, but it is easy to mitigate for the whole specification. To fix, simply add the following augment decorator statements to the `main.tsp` file.\r\n\r\n```tsp\r\n@@visibility(Azure.Core.Page.value, \"read\");\r\n@@visibility(Azure.Core.Page.nextLink, \"read\");\r\n```\n\n### `ProvisioningStateMustBeReadOnly`\n\nThis violation is caused by a problem with the mechanism that ARM Api validation uses to determine if a [property is read-only. You can work around the issue by setting the `use-read-only-status-schema` configuration setting in `azure/tools/typespec-autorest` options to `true` in your `tspConfig.yaml` configuration file:\r\n\r\n```yml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n    use-read-only-status-schema: true\r\n```\n\n### `LroLocationHeader`\n\nThis violation occurs when your spec uses an LRO operation template that follows the older version of LRO standards. Tof fix the issue, you would change the operation template to match the latest recommendation.\r\n\r\n#### PUT Operations\r\n\r\n```tsp\r\n// LRO PUT template with required headers and no 200 response\r\nop createOrUpdate is ArmResourceCreateOrReplaceAsync<MyResource>;\r\n```\r\n\r\n#### PATCH Operations\r\n\r\n```tsp\r\n// LRO PATCH template with required headers, response codes, and lro options\r\nop update is ArmResourcePatchAsync<MyResource, MyResourceProperties>;\r\n```\n\n### POST(Action) Operations\n\n```tsp\r\n// LRO POST (Action) template with required headers, response codes, and lro options\r\nop doAction is ArmResourceActionAsync<MyResource, RequestModel, ResponseModel>;\r\n```\n\n### DELETE Operations\n\n```tsp\r\n// LRO delete template with required headers and no 200 response\r\nop delete is ArmResourceDeleteWithoutOKAsync<MyResource>;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-resource-manager#reference#linter.md\n- document_title: Linter usage\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/linter\n- document_content: # libraries#azure-resource-manager#reference#linter.md\n\n# Linter usage\n\n## Usage\n\nAdd the following in `tspconfig.yaml`:\r\n\r\n```yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-resource-manager/all\"\r\n```\n\n## RuleSets\n\nAvailable ruleSets:\r\n\r\n- `@azure-tools/typespec-azure-resource-manager/all`\n\n## Rules\n\n| `@armResourceAction` should not be used with `@segment`.                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-duplicate-property`                                                                                   | Warn about duplicate properties in resources.                                                                                                                                                                                                         |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-envelope-property`                                                                            | Check for invalid resource envelope properties.                                                                                                                                                                                                       |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-version-format`                                                                               | Check for valid versions.                                                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-key-invalid-chars`                                                                                    | Arm resource key must contain only alphanumeric characters.                                                                                                                                                                                           |\r\n|\n\n|\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-operation`                                                                                            | Validate ARM Resource operations.                                                                                                                                                                                                                     |\r\n| `@azure-tools/typespec-azure-resource-manager/no-resource-delete-operation`                                                                                      | Check for resources that must have a delete operation.                                                                                                                                                                                                |\r\n| `@azure-tools/typespec-azure-resource-manager/empty-updateable-properties`                                                                                       | Should have updateable properties.                                                                                                                                                                                                                    |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-interface-requires-decorator`                                                                         | Each resource interface must have an @armResourceOperations decorator.                                                                                                                                                                                |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-action-verb`](/libraries/azure-resource-manager/rules/arm-resource-invalid-action-verb.md)   |\n\n| Name                                                                                                                                                             | Description                                                                                                                                                                                                                                           |\r\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-no-record`](/libraries/azure-resource-manager/rules/arm-no-record.md)                                         | Don't use Record types for ARM resources.                                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-common-types-version`                                                                                          | Specify the ARM common-types version using @armCommonTypesVersion.                                                                                                                                                                                    |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-delete-operation-response-codes`](/libraries/azure-resource-manager/rules/delete-operation-response-codes.md) | Ensure delete operations have the appropriate status codes.\n\n| Each resource interface must have an @armResourceOperations decorator.                                                                                                                                                                                |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-action-verb`](/libraries/azure-resource-manager/rules/arm-resource-invalid-action-verb.md)   | Actions must be HTTP Post or Get operations.                                                                                                                                                                                                          |\r\n| `@azure-tools/typespec-azure-resource-manager/improper-subscription-list-operation`                                                                              | Tenant and Extension resources should not define a list by subscription operation.                                                                                                                                                                    |\r\n| [`@azure-tools/typespec-azure-resource-manager/lro-location-header`](/libraries/azure-resource-manager/rules/lro-location-header.md)                             | A 202 response should include a Location response header.                                                                                                                                                                                             |\r\n| [`@azure-tools/typespec-azure-resource-manager/missing-x-ms-identifiers`](/libraries/azure-resource-manager/rules/missing-x-ms-identifiers.md)                   | Array properties should describe their identifying properties with x-ms-identifiers. Decorate the property with @OpenAPI.extension(\"x-ms-identifiers\", #[id-prop]) where \"id-prop\" is a list of the names of identifying properties in the item type. |\r\n|\n\n|\r\n| [`@azure-tools/typespec-azure-resource-manager/missing-x-ms-identifiers`](/libraries/azure-resource-manager/rules/missing-x-ms-identifiers.md)                   | Array properties should describe their identifying properties with x-ms-identifiers. Decorate the property with @OpenAPI.extension(\"x-ms-identifiers\", #[id-prop]) where \"id-prop\" is a list of the names of identifying properties in the item type. |\r\n| [`@azure-tools/typespec-azure-resource-manager/no-response-body`](/libraries/azure-resource-manager/rules/no-response-body.md)                                   | Check that the body is empty for 202 and 204 responses, and not empty for other success (2xx) responses.                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/missing-operations-endpoint`                                                                                       | Check for missing Operations interface.                                                                                                                                                                                                               |\r\n| `@azure-tools/typespec-azure-resource-manager/patch-envelope`                                                                                                    | Patch envelope properties should match the resource properties.                                                                                                                                                                                       |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-patch`                                                                                                |\n\n|\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-key-invalid-chars`                                                                                    | Arm resource key must contain only alphanumeric characters.                                                                                                                                                                                           |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-resource-name-pattern`](/libraries/azure-resource-manager/rules/resource-name-pattern.md)                     | The resource name parameter should be defined with a 'pattern' restriction.                                                                                                                                                                           |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-operation-response`                                                                                   | [RPC 008]: PUT, GET, PATCH & LIST must return the same resource schema.                                                                                                                                                                               |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-path-segment-invalid-chars`                                                                           | Arm resource name must contain only alphanumeric characters.                                                                                                                                                                                          |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-provisioning-state`                                                                                   |\n\n|\r\n| [`@azure-tools/typespec-azure-resource-manager/unsupported-type`](/libraries/azure-resource-manager/rules/unsupported-type.md)                                   | Check for unsupported ARM types.                                                                                                                                                                                                                      |\r\n| [`@azure-tools/typespec-azure-resource-manager/no-empty-model`](/libraries/azure-resource-manager/rules/no-empty-model.md)                                       | ARM Properties with type:object that don't reference a model definition are not allowed. ARM doesn't allow generic type definitions as this leads to bad customer experience.                                                                         |\n\n| Arm resource name must contain only alphanumeric characters.                                                                                                                                                                                          |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-provisioning-state`                                                                                   | Check for properly configured provisioningState property.                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-custom-resource-usage-discourage`                                                                              | Verify the usage of @customAzureResource decorator.                                                                                                                                                                                                   |\r\n| `@azure-tools/typespec-azure-resource-manager/beyond-nesting-levels`                                                                                             | Tracked Resources must use 3 or fewer levels of nesting.                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-operation`                                                                                            | Validate ARM Resource operations.                                                                                                                                                                                                                     |\r\n|\n\n|\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-delete-operation-response-codes`](/libraries/azure-resource-manager/rules/delete-operation-response-codes.md) | Ensure delete operations have the appropriate status codes.                                                                                                                                                                                           |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-put-operation-response-codes`](/libraries/azure-resource-manager/rules/put-operation-response-codes.md)       | Ensure put operations have the appropriate status codes.                                                                                                                                                                                              |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-post-operation-response-codes`](/libraries/azure-resource-manager/rules/post-operation-response-codes.md)     | Ensure post operations have the appropriate status codes.                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-action-no-segment`                                                                                    | `@armResourceAction` should not be used with `@segment`.                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-duplicate-property`                                                                                   |\n\n| Patch envelope properties should match the resource properties.                                                                                                                                                                                       |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-patch`                                                                                                | Validate ARM PATCH operations.                                                                                                                                                                                                                        |\r\n| `@azure-tools/typespec-azure-resource-manager/resource-name`                                                                                                     | Check the resource name.                                                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/retry-after`                                                                                                       | Check if retry-after header appears in response body.                                                                                                                                                                                                 |\r\n| [`@azure-tools/typespec-azure-resource-manager/unsupported-type`](/libraries/azure-resource-manager/rules/unsupported-type.md)                                   | Check for unsupported ARM types.                                                                                                                                                                                                                      |\r\n|\n", "latency": 10.981385946273804, "response_length": 1186}
{"query": "title: Is there way to change property from required to optional?\n\nquestion: Hi, dear, I am working releasing video translation GA API with new version.\nAnd we want to change a property from required to optional in the new version.\nPreviously we have a required property: sourceLocale: localeName\n(Here localeName is a defined as: scalar localeName extends string;)\nAnd now we want to change the property to optional: sourceLocale?: localeName\nIs there anyway I can do to make the change for the new version?\nI have tried this but doesn't work:\n@doc(\"Translation input.\")\nmodel TranslationInput {\n@typeChangedFrom(ApiVersions.v2024_05_20_preview, localeName)\nsourceLocale?: localeName;\n}\nCould anyone help please?", "ground_truth": "https://typespec.io/docs/libraries/versioning/reference/decorators/#@TypeSpec.Versioning.madeOptional", "response": "To change a property from required to optional in a new version, you can use the `@madeOptional` decorator provided by the TypeSpec versioning library. This decorator specifies the version in which the property became optional. Here's how you can implement this change:\n\n```typespec\nmodel TranslationInput {\n  @madeOptional(ApiVersions.v2024_05_20_preview)\n  sourceLocale?: localeName;\n}\n```\n\nThis approach ensures backward compatibility and allows the API to reflect the correct state for the specified version. The `@madeOptional` decorator indicates the version in which the property became optional, enabling tools to generate version-aware code.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#versioning#guide.md\n- document_title: Tutorial\n- document_link: https://typespec.io/docs/libraries/versioning/guide\n- document_content: # libraries#versioning#guide.md\n\n# Tutorial\n\n## Implementing versioned APIs\n\nThe primary role of the TypeSpec.Versioning library is to enable API versioning. Let's start with an API that lacks versioning.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nTo introduce versioning to this API, we need to use the `@versioned` decorator on the namespace and define an enum that outlines the supported versions.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n```\n\n## Declaring versioned dependencies\n\nBoth versioned and unversioned services can declare their dependencies on versioned TypeSpec libraries. This is achieved using the `@useDependency` decorator. For unversioned services, this is declared on the namespace. For versioned services, it's declared on the versioned enum.\r\n\r\nFor example, if our unversioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager Unversioned\" })\r\n@useDependency(Azure.Core.v1_0_Preview_1)\r\nnamespace Contoso.WidgetManager.Unversioned;\r\n```\r\n\r\nIf our versioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n}\r\n```\r\n\r\nLet's say we introduce a new version to our service, and it uses features from a newer version of the Azure.Core library. We can declare that dependency like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n\r\n  @useDependency(Azure.Core.v1_0_Preview_2)\r\n  v2,\r\n}\r\n```\n\n## Versioning APIs\n\nreflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    description:\r\n      type: string\r\n  required:\r\n    - id\r\n```\r\n\r\nHowever, the OpenAPI definition for versions 1 and 2 still reflect the original name and the mandatory nature of the property:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    name:\r\n      type: string\r\n  required:\r\n    - id\r\n    - name\r\n```\r\n\r\nThis is a common pattern with the versioning decorators. The TypeSpec should represent the _current state_ of the API. The decorators indicate the version at which this definition became accurate and, depending on the decorator, the other parameters reflect the previous values to retain that information.\n\nThe versioning library simplifies the process of versioning APIs. Let's start with a basic example. Assume we have a service with a single API that returns a list of widgets. We can define that API like this:\r\n\r\n```typespec\r\nusing Versioning;\r\nusing Rest;\r\nusing Http;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: string;\r\n  message?: string;\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\nop list(): Widget[] | Error;\r\n```\r\n\r\nNow, let's suppose that in version 2 of the service, we add a get operation to retrieve a single widget. We can add that like this:\r\n\r\n```typespec\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@route(\"/widget\")\r\nop list(): Widget[] | Error;\r\n\r\n@added(Versions.v2)\r\n@route(\"/widget/{id}\")\r\nop get(...Resource.KeysOf<Widget>): Widget | Error;\r\n```\r\n\r\nNow, let's suppose that in version 3 of the service, we realize that `name` is not accurate and that this field should be called `description`. Also, we decide that the description should be optional, not mandatory. We can implement these changes like this:\r\n\r\n```typespec\r\nmodel Widget {\r\n  @key\r\n  widgetId: string;\r\n\r\n  @renamedFrom(Versions.v3, \"name\")\r\n  @madeOptional(Versions.v3)\r\n  description?: string;\r\n}\r\n```\r\n\r\nWe made the change to the actual model property so that it now reflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#non-breaking-versioning.md\n- document_title: non-breaking-versioning\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/non-breaking-versioning\n- document_content: # libraries#azure-core#rules#non-breaking-versioning.md\n\n# non-breaking-versioning\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/non-breaking-versioning\r\n```\r\n\r\nVerify that only backward compatible changes are made to the API.\r\n\r\n####  Incorrect\r\n\r\n- Removed\r\n\r\n```tsp\r\nmodel Foo {\r\n  @removed(Versions.v2024_01_01)\r\n  bar: string;\r\n}\r\n```\r\n\r\n- Renamed\r\n\r\n```tsp\r\nmodel Foo {\r\n  @renamedFrom(Versions.v2024_01_01, \"baz\")\r\n  bar: string;\r\n}\r\n```\r\n\r\n- Added required property\r\n\r\n```tsp\r\nmodel Foo {\r\n  @added(Versions.v2024_01_01)\r\n  bar: string;\r\n}\r\n```\r\n\r\n- Made optional without default\r\n\r\n```tsp\r\nmodel Foo {\r\n  @madeOptional(Versions.v2024_01_01)\r\n  bar: string;\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n- Adding new type\r\n\r\n```tsp\r\n@added(Versions.v2024_01_01)\r\nmodel Foo {}\r\n```\r\n\r\n- Adding operation\r\n\r\n```tsp\r\n@added(Versions.v2024_01_01)\r\nop foo(): Foo;\r\n```\r\n\r\n- Adding optional property\r\n\r\n```tsp\r\nmodel Foo {\r\n  @added(Versions.v2024_01_01)\r\n  bar?: string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-nullable.md\n- document_title: no-nullable\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-nullable\n- document_content: # libraries#azure-core#rules#no-nullable.md\n\n# no-nullable\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-nullable\r\n```\r\n\r\nProperties are most often not nullable but optional.\r\nDo not use `| null` to specify that a property is nullable. Instead, use the `?` operator to indicate that a property is optional.\r\n\r\n####  Incorrect\r\n\r\n```tsp\r\nmodel Pet {\r\n  id: string;\r\n  owner: string | null;\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\nmodel Pet {\r\n  id: string;\r\n  owner?: string;\r\n}\r\n```\n", "latency": 10.616822957992554, "response_length": 650}
{"query": "title: Playground goes blank when choosing TCGC output\n\nquestion: I've this playground [simple spec](https://teams.microsoft.com/l/message/19:906c1efbbec54dc8949ac736633e6bdf@thread.skype/1743179774446?tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47&groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&parentMessageId=1743179774446&teamName=Azure%20SDK&channelName=TypeSpec%20Discussion&createdTime=1743179774446) which outputs in openapi3 format, but as soon as I change output format to TCGC, the page goes blank.", "ground_truth": "File a bug for the playground crash issue.\nFix the invalid value returned by TCGC causing the playground to crash.\nReproduce the TCGC crash using any emitter and create a TCGC issue.\nFix the playground crash issue in core and merge it.\nFix the TCGC error related to the @override method missing some params.", "response": "The issue of the playground going blank when switching the output format to TCGC could be related to how the TypeSpec Client Generator Core (TCGC) emitter is configured or used. To debug this issue, you can try the following steps:\n\n1. **Verify TCGC Setup**: Ensure that the TCGC emitter is correctly installed and configured in your project. Add `@azure-tools/typespec-client-generator-core` to your `package.json` dependencies and confirm that the emitter is properly referenced in your TypeSpec configuration.\n\n2. **Export TCGC Output for Debugging**: Use TCGC as a standalone emitter to export the type graph for debugging. Run the following command:\n   ```\n   tsp compile . --emit=@azure-tools/typespec-client-generator-core --options=@azure-tools/typespec-client-generator-core.emitter-name=\"<emitter-name>\"\n   ```\n   Replace `<emitter-name>` with your emitter name. This will generate a type graph file that can help identify any issues.\n\n3. **Use TCGC Playground**: Experiment with your specification in the [TCGC Playground](https://azure.github.io/typespec-azure/playground/?e=%40azure-tools%2Ftypespec-client-generator-core) to see how it translates to the TCGC client type graph. This can help pinpoint any problems with your specification or emitter configuration.\n\n4. **Check for Errors**: Look for any error messages or stack traces in the TypeSpec output or browser console when the page goes blank. These can provide clues about the underlying issue.\n\n5. **File an Issue**: If the problem persists, consider filing an issue in the [TypeSpec Azure GitHub repository](https://github.com/azure/typespec-azure/issues) with detailed information, including your TypeSpec code, expected and actual results, and any error messages.", "context": "- document_dir: typespec_docs\n- document_filename: emitters#openapi3#diagnostics.md\n- document_title: Diagnostics\n- document_link: https://typespec.io/docs/emitters/openapi3/diagnostics\n- document_content: # emitters#openapi3#diagnostics.md\n\n# Diagnostics\n\nThe OpenAPI emitter may produce any of the following diagnostic messages.\r\n\r\n<!-- Topics within this section should be ordered alphabetically for easy lookup -->\n\n## duplicate-header\n\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\r\n\r\nTo fix this issue, ensure that each response header is defined only once for each status code.\n\n### Example\n\n```yaml\r\nresponses:\r\n  \"200\":\r\n    description: Successful response\r\n    headers:\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n```\r\n\r\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\n\n## duplicate-type-name\n\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\r\n\r\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\n\n### Example\n\n```typespec\r\n@friendlyName(\"User\")\r\nmodel Customer {\r\n  id: string;\r\n}\r\n\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\n\n## inline-cycle\n\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\r\n\r\nTo fix this issue, refactor the schemas to remove the cyclic reference.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    Node:\r\n      type: object\r\n      properties:\r\n        value:\r\n          type: string\r\n        next:\r\n          $ref: \"#/components/schemas/Node\"\r\n```\r\n\r\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\n\n## invalid-default\n\nThis diagnostic is issued when a default value is invalid for the specified schema type.\r\n\r\nTo fix this issue, ensure that the default value is valid for the schema type.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        age:\r\n          type: integer\r\n          default: \"twenty\"\r\n```\r\n\r\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\n\n## invalid-extension-key\n\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \"x-\" as\r\nrequired by the OpenAPI v3 specification.\r\n\r\nTo fix this issue, change the extension name to start with \"x-\".\n\n### Example\n\n```typespec\r\n@extension(\"invalid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nShould be changed to:\r\n\r\n```typespec\r\n@extension(\"x-valid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\n\n## invalid-schema\n\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\r\n\r\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        id:\r\n          type: string\r\n        age:\r\n          type: integer\r\n          format: \"int\" # Invalid format\r\n```\r\n\r\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\n\n## invalid-server-variable\n\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\r\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\r\n\r\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\n\n### Example\n\n```typespec\r\n@server(\"{protocol}://{host}/api/{version}\", \"Custom endpoint\", {\r\n  protocol: \"http\" | \"https\",\r\n  host: string,\r\n  version: 1, // Should be a string: \"1\"\r\n})\r\n```\n\n## path-query\n\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\r\n\r\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\n\n### Example\n\nInstead of:\r\n\r\n```typespec\r\n@route(\"/users?filter={filter}\")\r\nop getUsers(filter: string): User[];\r\n```\r\n\r\nUse:\r\n\r\n```typespec\r\n@route(\"/users\")\r\nop getUsers(@query filter?: string): User[];\r\n```\r\n\r\nAlternatively, you can leverage TypeSpec's support for URI templates:\r\n\r\n```typespec\r\n@route(\"/users{?filter}\")\r\nop getUsers(filter?: string): User[];\r\n```\n\n## union-null\n\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\r\nrepresented in OpenAPI.\r\n\r\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\n\n## union-unsupported\n\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\r\n\r\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#guideline.md\n- document_title: Guideline for Client Emitter\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/guideline\n- document_content: # libraries#typespec-client-generator-core#guideline.md\n\n# Guideline for Client Emitter\n\nThis document provides guidance on using the TypeSpec Client Generator Core (TCGC) in client emitters.  \r\nTCGC introduces a client type graph and provides helper functions for generating client code.  \r\nClient emitters can rely on the client type graph instead of directly interacting with the TypeSpec core API.\n\n## TCGC Library\n\nTCGC abstracts common logic for client emitters across languages, allowing emitters to focus solely on language-specific code generation.\n\n### Usage\n\nTo use TCGC, add it to your `package.json`:\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-client-generator-core\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\nIn your emitter's `$onEmit` function, use [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to convert [`EmitContext`](https://typespec.io/docs/standard-library/reference/js-api/interfaces/emitcontext/) into [`SdkContext`](../reference/js-api/interfaces/sdkcontext/). The [`SdkContext.SdkPackage`](../reference/js-api/interfaces/sdkpackage/) contains the client type graph. See [\"Client Type Graph\"](#client-type-graph) for details.\r\n\r\nIf your client emitter has options or global variables, extend [`SdkContext`](../reference/js-api/interfaces/sdkcontext/) with your custom emitter context. Example:\r\n\r\n```ts\r\nimport { EmitContext } from \"@typespec/compiler\";\r\nimport { createSdkContext } from \"@azure-tools/typespec-client-generator-core\";\r\n\r\ninterface PythonEmitterOptions extends SdkEmitterOptions {\r\n  // Options specific to the client emitter\r\n}\r\n\r\ninterface PythonSdkContext extends SdkContext<PythonEmitterOptions> {\r\n  // Global variables for the client emitter\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext<PythonEmitterOptions>) {\r\n  const emitterContext: PythonSdkContext = {\r\n    ...createSdkContext(context),\r\n    // Initialize global variables\r\n  };\r\n}\r\n```\n\n### Exporting TCGC Type Graph\n\nTCGC can be used as a standalone emitter to export the type graph for debugging. Run:  \r\n`tsp compile . --emit=@azure-tools/typespec-client-generator-core --options=@azure-tools/typespec-client-generator-core.emitter-name=\"<emitter-name>\"`  \r\nReplace `<emitter-name>` with your emitter name to generate the type graph file.\r\n\r\nAlternatively, pass the [`exportTCGCoutput`](../reference/js-api/interfaces/createsdkcontextoptions/) option to [`createSdkContext`](../reference/js-api/functions/createsdkcontext/) to generate the type graph file (`<output-dir>/tcgc-output.yaml`) alongside client code.\n\n### TCGC Playground\n\nUse the [TCGC Playground](https://azure.github.io/typespec-azure/playground/?e=%40azure-tools%2Ftypespec-client-generator-core) to experiment with how specifications translate to the TCGC client type graph. Include the playground link when asking questions or reporting issues.\n\n### TCGC Flags\n\nTCGC provides flags to control the client type graph style, such as enabling or disabling convenience APIs. See the [documentation](../reference/emitter/#emitter-options) for details.\n\n## Client Type Graph\n\n### Namespace\n\n[`SdkPackage`](../reference/js-api/interfaces/sdkpackage/) represents a client package, containing all clients, operations, and types.\r\n\r\nClients, models, enums, and unions include namespace information. Emitters can use either:\r\n\r\n- A flattened structure (`SdkPackage.clients`, `SdkPackage.enums`, `SdkPackage.models`, `SdkPackage.unions`)\r\n- A hierarchical structure (`SdkPackage.namespaces`) requiring iteration through nested namespaces.\r\n\r\nThe `namespace` property in TCGC types indicates the type's namespace.\n\n### License Information\n\nThe `licenseInfo` property in [`LicenseInfo`](../reference/js-api/interfaces/licenseinfo/) contains license details for client code comments or license file generation.\r\n\r\nIf `licenseInfo` is `undefined`, omit license information in the generated code or files.\r\n\r\nUse `licenseInfo.name` (license name), `licenseInfo.company` (company name), `licenseInfo.link` (license document link), `licenseInfo.header` (header comments), and `licenseInfo.description` (license file content) directly when generating license-related content.\r\n\r\nFor Azure services, emitters should hard-code the license configuration as follows:\r\n\r\n```typescript\r\nexport async function $onEmit(context: EmitContext<SdkEmitterOptions>) {\r\n  context.options.license = {\r\n    name: \"MIT License\",\r\n    company: \"Microsoft Corporation\",\r\n  };\r\n  const sdkContext = await createSdkContext(context);\r\n  // ...\r\n}\r\n```\n\n### Client\n\nAn [`SdkClientType`](../reference/js-api/interfaces/sdkclienttype/) represents a single client in the package.\n\n### Method\n\nTODO\n\n### Operation\n\nTODO\n\n### Type\n\nTODO\n", "latency": 15.608318090438843, "response_length": 1740}
{"query": "title: Value template parameters as default values\n\nquestion: I feel like I should be able to do something like this:\n```\n// Reusable package\n@get op searchIssues<TQDefault extends valueof string=\"\">(\n@query q: string=TQD): string;\n// Concrete package implementing a Copilot plugin\n@get op is global.githubapi.searchIssues<\"repo:microsoft/typespec\">;\n```\nAm I missing a technique or is this a gap?\nThe motivator here is that Sydney (M365 Copilot's orchestrator) for err, reasons, uses the default value in the OpenAPI spec as the actual forced value for the function parameter.\nWe're trying to create a really nice terse syntax for reusing a standard function but overriding a parameter value here or there.", "ground_truth": "To track the issue for the capability of allowing template parameters to be used in default values.\nTo create a custom decorator in the package called @omit(Model) that is a simple cover over @withoutOmittedProperties listing out the names of the properties of the model in a string union.\nTo raise issues for minor additions to clean up the syntax, including the ability to put @query on a model and have it apply to all properties, and the ability to pass a type as the parameter to @withoutOmittedProperties.", "response": "In TypeSpec, you can use `valueof` to define default values for template parameters, which can then be overridden in concrete implementations. However, your example syntax has some issues. Here's how you can achieve your goal:\n\n### Corrected Example\n```typescript\n// Reusable package\n@get op searchIssues<TQDefault extends valueof string>(\n  @query q: string = TQDefault\n): string;\n\n// Concrete package implementing a Copilot plugin\n@get op is global.githubapi.searchIssues<\"repo:microsoft/typespec\">;\n```\n\n### Explanation\n1. **Template Parameter with Default Value**:\n   - The `TQDefault` template parameter is defined as extending `valueof string`. This ensures it is treated as a value.\n   - The `@query q` parameter uses `TQDefault` as its default value.\n\n2. **Concrete Implementation**:\n   - When implementing the operation in a concrete package, you can override the default value by specifying the template parameter value (e.g., `<\"repo:microsoft/typespec\">`).\n\n### Why This Works\nThe `valueof` keyword ensures that the template parameter is treated as a value, which can be used as a default for operation parameters. This approach aligns with TypeSpec's rules for values and types, as described in the documentation.\n\n### Note on OpenAPI Behavior\nIf Sydney (M365 Copilot's orchestrator) uses the default value in the OpenAPI spec as a forced value, this approach should work seamlessly, as the default value is explicitly defined in the operation signature.", "context": "- document_dir: typespec_docs\n- document_filename: language-basics#values.md\n- document_title: Values\n- document_link: https://typespec.io/docs/language-basics/values\n- document_content: # language-basics#values.md\n\n# Values\n\nTypeSpec can define values in addition to types. Values are useful in an API description to define default values for types or provide example values. They are also useful when passing data to decorators, and for template parameters that are ultimately passed to decorators or used as default values.\r\n\r\nValues cannot be used as types, and types cannot be used as values, they are completely separate. However, string, number, boolean, and null literals can be either a type or a value depending on context (see also [scalar literals](#scalar-literals)). Additionally, union and enum member references may produce a type or a value depending on context (see also [enum member &amp; union variant references](#enum-member--union-variant-references)).\n\n## Value kinds\n\nThere are four kinds of values: objects, arrays, scalars, and null. These values can be created with object values, array values, scalar values and initializers, and the null literal respectively. Additionally, values can result from referencing enum members and union variants.\n\n### Object values\n\nObject values use the syntax `#{}` and can define any number of properties. For example:\r\n\r\n```typespec\r\nconst point = #{ x: 0, y: 0 };\r\n```\r\n\r\nThe object value's properties must refer to other values. It is an error to reference a type.\r\n\r\n```typespec\r\nconst example = #{\r\n  prop1: #{ nested: true }, // ok\r\n  prop2: {\r\n    nested: true,\r\n  }, // error: values can't reference a type\r\n  prop3: string, // error: values can't reference a type\r\n};\r\n```\n\n### Array values\n\nArray values use the syntax `#[]` and can define any number of items. For example:\r\n\r\n```typespec\r\nconst points = #[#{ x: 0, y: 0 }, #{ x: 1, y: 1 }];\r\n```\r\n\r\nAs with object values, array values cannot contain types.\r\n\r\nIf an array type defines a minimum and maximum size using the `@minValue` and `@maxValue` decorators, the compiler will validate that the array value has the appropriate number of items. For example:\r\n\r\n```typespec\r\n/** Can have at most 2 tags */\r\n@maxItems(2)\r\nmodel Tags is Array<string>;\r\n\r\nconst exampleTags1: Tags = #[\"TypeSpec\", \"JSON\"]; // ok\r\nconst exampleTags2: Tags = #[\"TypeSpec\", \"JSON\", \"OpenAPI\"]; // error\r\n```\n\n### Scalar values\n\nScalar initializers create scalar values by calling an initializer with one or more values. Scalar initializers for types extended from `numeric`, `string`, and `boolean` are called by adding parenthesis after the scalar reference:\r\n\r\n```typespec\r\nconst n = int8(100);\r\nconst s = string(\"hello\");\r\n```\r\n\r\nAny scalar can additionally be declared with named initializers that take one or more value parameters. For example, `utcDateTime` provides a `fromISO` initializer that takes an ISO string. Named scalars can be declared like so:\r\n\r\n```typespec\r\nscalar ipv4 extends string {\r\n  init fromInt(value: uint32);\r\n}\r\n\r\nconst ip = ipv4.fromInt(2341230);\r\n```\r\n\r\n#### Null values\r\n\r\nNull values are created with the `null` literal.\r\n\r\n```typespec\r\nconst value: string | null = null;\r\n```\r\n\r\nThe `null` value, like the `null` type, doesn't have any special behavior in the TypeSpec language. It is just the value `null` like that in JSON.\n\nThere are two ways to create scalar values: with a literal syntax like `\"string value\"`, and with a scalar initializer like `utcDateTime.fromISO(\"2020-12-01T12:00:00Z\")`.\r\n\r\n#### Scalar literals\r\n\r\nThe literal syntax for strings, numerics, booleans and null can evaluate to either a type or a value depending on the surrounding context of the literal. When the literal is in _type context_ (a model property type, operation return type, alias definition, etc.) the literal becomes a literal type. When the literal is in _value context_ (a default value, property of an object value, const definition, etc.), the literal becomes a value. When the literal is in an _ambiguous context_ (e.g. an argument to a template or decorator that can accept either a type or a value) the literal becomes a value. The `typeof` operator can be used to convert the literal to a type in such ambiguous contexts.\r\n\r\n```typespec\r\n// Sample decorator signatures. They have no backing implementation and shown here for demonstration purposes.\r\nextern dec setNumberValue(target: unknown, color: valueof numeric);\r\nextern dec setNumberType(target: unknown, color: numeric);\r\nextern dec setNumberTypeOrValue(target: unknown, color: numeric | (valueof numeric));\r\n\r\n@setNumberValue(123) // Passes the scalar value `numeric(123)`.\r\n@setNumberType(123) // Passes the numeric literal type 123.\r\n@setNumberTypeOrValue(123) // passes the scalar value `numeric(123)`.\r\nmodel A {}\r\n```\r\n\r\n#### Scalar initializers\r\n\r\nScalar initializers create scalar values by calling an initializer with one or more values. Scalar initializers for types extended from `numeric`, `string`, and `boolean` are called by adding parenthesis after the scalar reference:\r\n\r\n```typespec\r\nconst n = int8(100);\r\nconst s = string(\"hello\");\r\n```\r\n\r\nAny scalar can additionally be declared with named initializers that take one or more value parameters. For example, `utcDateTime` provides a `fromISO` initializer that takes an ISO string.\n\n## Const declarations\n\nConst declarations allow storing values in a variable for later reference. Const declarations have an optional type annotation. When the type annotation is absent, the type is inferred from the value by constructing an exact type from the initializer.\r\n\r\n```typespec\r\nconst stringValue: string = \"hello\";\r\n//      ^-- type: string\r\n\r\nconst oneValue = 1;\r\n//      ^-- type: 1\r\n\r\nconst objectValue = #{ x: 0, y: 0 };\r\n//      ^-- type: { x: 0, y: 0 }\r\n```\n\n## The `typeof` operator\n\nThe `typeof` operator returns the declared or inferred type of a value reference. Note that the actual value being stored by the referenced variable may be more specific than the declared type of the value. For example, if a const is declared with a union type, the value will only ever store one specific variant at a time, but typeof will give you the declared union type.\r\n\r\n```typespec\r\nconst stringValue: string = \"hello\";\r\n// typeof stringValue returns `string`.\r\n\r\nconst oneValue = 1;\r\n// typeof oneValue returns `1`\r\n\r\nconst stringOrOneValue: string | 1 = 1;\r\n// typeof stringOrOneValue returns `string | 1`\r\n```\n\n## Validation\n\nTypeSpec will validate values against built-in validation decorators like `@minLength` and `@maxValue`.\r\n\r\n```typespec\r\n@maxLength(3)\r\nscalar shortString extends string;\r\n\r\nconst s1: shortString = \"abc\"; // ok\r\nconst s2: shortString = \"abcd\"; // error:\r\n\r\nmodel Entity {\r\n  a: shortString;\r\n}\r\n\r\nconst e1: Entity = #{ a: \"abcd\" }; // error\r\n```\n\n## Enum member &amp; union variant references\n\nReferences to enum members and union variants can be either types or values and follow the same rules as scalar literals. When an enum member reference is in _type context_, the reference becomes an enum member type. When in _value context_ or _ambiguous context_ the reference becomes the enum member's value.\r\n\r\n```typespec\r\nextern dec setColorValue(target: unknown, color: valueof string);\r\nextern dec setColorMember(target: unknown, color: Reflection.EnumMember);\r\n\r\nenum Color {\r\n  red,\r\n  green,\r\n  blue,\r\n}\r\n\r\n@setColorValue(Color.red) // same as passing the literal \"red\"\r\n@setColorMember(Color.red) // passes the enum member Color.red\r\nmodel A {}\r\n```\r\n\r\nWhen a union variant reference is in _type context_, the reference becomes the type of the union variant. When in _value context_ or _ambiguous context_ the reference becomes the value of the union variant. It is an error to refer to a union variant whose type is not a literal type.\r\n\r\n```typespec\r\nextern dec setColorValue(target: unknown, color: valueof string);\r\nextern dec setColorType(target: unknown, color: string);\r\n\r\nunion Color {\r\n  red: \"red\",\r\n  green: \"green\",\r\n  blue: \"blue\",\r\n  other: string,\r\n}\r\n\r\n@setColorValue(Color.red) // passes the scalar value `string(\"red\")`\r\n@setColorValue(Color.other) // error, trying to pass a type as a value.\r\n@setColorType(Color.red) // passes the string literal type `\"red\"`\r\nmodel A {}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: standard-library#built-in-decorators.md\n- document_title: Built-in Decorators\n- document_link: https://typespec.io/docs/standard-library/built-in-decorators\n- document_content: # standard-library#built-in-decorators.md\n\n# Built-in Decorators\n\n## TypeSpec\n\n### `@continuationToken` {#@continuationToken}\n\nPagination property defining the token to get to the next page.\r\nIt MUST be specified both on the request parameter and the response.\r\n```typespec\r\n@continuationToken\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @continuationToken continuationToken: string;\r\n}\r\n@list op listPets(@continuationToken continuationToken: string): Page<Pet>;\r\n```\n\n### `@defaultVisibility` {#@defaultVisibility}\n\nDeclares the default visibility modifiers for a visibility class.\r\n\r\nThe default modifiers are used when a property does not have any visibility decorators\r\napplied to it.\r\n\r\nThe modifiers passed to this decorator _MUST_ be members of the target Enum.\r\n```typespec\r\n@defaultVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Enum`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | the list of modifiers to use as the default visibility modifiers. |\n\n### `@discriminated` {#@discriminated}\n\nSpecify that this union is discriminated.\r\n```typespec\r\n@discriminated(options?: valueof DiscriminatedOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Union`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| options | [valueof `DiscriminatedOptions`](./built-in-data-types.md#DiscriminatedOptions) | Options to configure the serialization of the discriminated union. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@discriminated\r\nunion Pet{ cat: Cat, dog: Dog }\r\n\r\nmodel Cat { name: string, meow: boolean }\r\nmodel Dog { name: string, bark: boolean }\r\n```\r\nSerialized as:\r\n```json\r\n{\r\n  \"kind\": \"cat\",\r\n  \"value\": {\r\n    \"name\": \"Whiskers\",\r\n    \"meow\": true\r\n  }\r\n},\r\n{\r\n  \"kind\": \"dog\",\r\n  \"value\": {\r\n    \"name\": \"Rex\",\r\n    \"bark\": false\r\n  }\r\n}\r\n```\r\n\r\n##### Custom property names\r\n\r\n\r\n```typespec\r\n@discriminated(#{discriminatorPropertyName: \"dataKind\", envelopePropertyName: \"data\"})\r\nunion Pet{ cat: Cat, dog: Dog }\r\n\r\nmodel Cat { name: string, meow: boolean }\r\nmodel Dog { name: string, bark: boolean }\r\n```\r\nSerialized as:\r\n```json\r\n{\r\n  \"dataKind\": \"cat\",\r\n  \"data\": {\r\n    \"name\": \"Whiskers\",\r\n    \"meow\": true\r\n  }\r\n},\r\n{\r\n  \"dataKind\": \"dog\",\r\n  \"data\": {\r\n    \"name\": \"Rex\",\r\n    \"bark\": false\r\n  }\r\n}\r\n```\n\n### `@discriminator` {#@discriminator}\n\nSpecify the property to be used to discriminate this type.\r\n```typespec\r\n@discriminator(propertyName: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| propertyName | [valueof `string`](#string) | The property name to use for discrimination |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet{ kind: string }\r\n\r\nmodel Cat extends Pet {kind: \"cat\", meow: boolean}\r\nmodel Dog extends Pet  {kind: \"dog\", bark: boolean}\r\n```\n\n### `@doc` {#@doc}\n\nAttach a documentation string. Content support CommonMark markdown formatting.\r\n```typespec\r\n@doc(doc: valueof string, formatArgs?: {})\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n| formatArgs | `{}` | Record with key value pair that can be interpolated in the doc. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@doc(\"Represent a Pet available in the PetStore\")\r\nmodel Pet {}\r\n```\n\n### `@encode` {#@encode}\n\nSpecify how to encode the target type.\r\n```typespec\r\n@encode(encodingOrEncodeAs: Scalar | valueof string | EnumMember, encodedAs?: Scalar)\r\n```\r\n\r\n#### Target\r\n\r\n`Scalar | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| encodingOrEncodeAs | `Scalar` \\| `valueof string \\| EnumMember` | Known name of an encoding or a scalar type to encode as(Only for numeric types to encode as string). |\r\n| encodedAs | `Scalar` | What target type is this being encoded as. Default to string. |\r\n\r\n#### Examples\r\n##### offsetDateTime encoded with rfc7231\r\n\r\n\r\n```tsp\r\n@encode(\"rfc7231\")\r\nscalar myDateTime extends offsetDateTime;\r\n```\r\n\r\n##### utcDateTime encoded with unixTimestamp\r\n\r\n\r\n```tsp\r\n@encode(\"unixTimestamp\", int32)\r\nscalar myDateTime extends unixTimestamp;\r\n```\r\n\r\n##### encode numeric type to string\r\n\r\n\r\n```tsp\r\nmodel Pet {\r\n  @encode(string) id: int64;\r\n}\r\n```\n\n### `@encodedName` {#@encodedName}\n\nProvide an alternative name for this type when serialized to the given mime type.\r\n```typespec\r\n@encodedName(mimeType: valueof string, name: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| mimeType | [valueof `string`](#string) | Mime type this should apply to. The mime type should be a known mime type as described here https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types without any suffix (e.g. `+json`) |\r\n| name | [valueof `string`](#string) | Alternative name |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Certificate {\r\n  @encodedName(\"application/json\", \"exp\")\r\n  @encodedName(\"application/xml\", \"expiry\")\r\n  expireAt: int32;\r\n}\r\n```\r\n\r\n##### Invalid values\r\n\r\n\r\n```typespec\r\n@encodedName(\"application/merge-patch+json\", \"exp\")\r\n             ^ error cannot use subtype\r\n```\n\n### `@error` {#@error}\n\nSpecify that this model is an error type. Operations return error types when the operation has failed.\r\n```typespec\r\n@error\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@error\r\nmodel PetStoreError {\r\n  code: string;\r\n  message: string;\r\n}\r\n```\n\n### `@errorsDoc` {#@errorsDoc}\n\nAttach a documentation string to describe the error return types of an operation.\r\nIf an operation returns a union of success and errors it only describes the errors. See `@returnsDoc` for success documentation.\r\n```typespec\r\n@errorsDoc(doc: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@errorsDoc(\"Errors doc\")\r\nop get(): Pet | NotFound;\r\n```\n\n### `@example` {#@example}\n\nProvide an example value for a data type.\r\n```typespec\r\n@example(example: valueof unknown, options?: valueof ExampleOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Scalar | Union | ModelProperty | UnionVariant`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| example | `valueof unknown` | Example value. |\r\n| options | [valueof `ExampleOptions`](./built-in-data-types.md#ExampleOptions) | Optional metadata for the example. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@example(#{name: \"Fluffy\", age: 2})\r\nmodel Pet {\r\n name: string;\r\n age: int32;\r\n}\r\n```\n\n### `@firstLink` {#@firstLink}\n\nPagination property defining a link to the first page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@firstLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@format` {#@format}\n\nSpecify a known data format hint for this string type. For example `uuid`, `uri`, etc.\r\nThis differs from the `@pattern` decorator which is meant to specify a regular expression while `@format` accepts a known format name.\r\nThe format names are open ended and are left to emitter to interpret.\r\n```typespec\r\n@format(format: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| format | [valueof `string`](#string) | format name. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@format(\"uuid\")\r\nscalar uuid extends string;\r\n```\n\n### `@friendlyName` {#@friendlyName}\n\nSpecifies how a templated type should name their instances.\r\n```typespec\r\n@friendlyName(name: valueof string, formatArgs?: unknown)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| name | [valueof `string`](#string) | name the template instance should take |\r\n| formatArgs | `unknown` | Model with key value used to interpolate the name |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@friendlyName(\"{name}List\", T)\r\nmodel List<Item> {\r\n  value: Item[];\r\n  nextLink: string;\r\n}\r\n```\n\n### `@inspectType` {#@inspectType}\n\nA debugging decorator used to inspect a type.\r\n```typespec\r\n@inspectType(text: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| text | [valueof `string`](#string) | Custom text to log |\n\n### `@inspectTypeName` {#@inspectTypeName}\n\nA debugging decorator used to inspect a type name.\r\n```typespec\r\n@inspectTypeName(text: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| text | [valueof `string`](#string) | Custom text to log |\n\n### `@invisible` {#@invisible}\n\nIndicates that a property is not visible in the given visibility class.\r\n\r\nThis decorator removes all active visibility modifiers from the property within\r\nthe given visibility class, making it invisible to any context that selects for\r\nvisibility modifiers within that class.\r\n```typespec\r\n@invisible(visibilityClass: Enum)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilityClass | `Enum` | The visibility class to make the property invisible within. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Example {\r\n  @invisible(Lifecycle)\r\n  hidden_property: string;\r\n}\r\n```\n\n### `@key` {#@key}\n\nMark a model property as the key to identify instances of that type\r\n```typespec\r\n@key(altName?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| altName | [valueof `string`](#string) | Name of the property. If not specified, the decorated property name is used. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Pet {\r\n  @key id: string;\r\n}\r\n```\n\n### `@lastLink` {#@lastLink}\n\nPagination property defining a link to the last page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@lastLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@list` {#@list}\n\nMark this operation as a `list` operation that returns a paginated list of items.\r\n```typespec\r\n@list\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\nNone\n\n### `@maxItems` {#@maxItems}\n\nSpecify the maximum number of items this array should have.\r\n```typespec\r\n@maxItems(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown[] | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Maximum number |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxItems(5)\r\nmodel Endpoints is string[];\r\n```\n\n### `@maxLength` {#@maxLength}\n\nSpecify the maximum length this string type should be.\r\n```typespec\r\n@maxLength(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Maximum length |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxLength(20)\r\nscalar Username extends string;\r\n```\n\n### `@maxValue` {#@maxValue}\n\nSpecify the maximum value this numeric type should be.\r\n```typespec\r\n@maxValue(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Maximum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxValue(200)\r\nscalar Age is int32;\r\n```\n\n### `@maxValueExclusive` {#@maxValueExclusive}\n\nSpecify the maximum value this numeric type should be, exclusive of the given\r\nvalue.\r\n```typespec\r\n@maxValueExclusive(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Maximum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxValueExclusive(50)\r\nscalar distance is float64;\r\n```\n\n### `@mediaTypeHint` {#@mediaTypeHint}\n\nApplies a media type hint to a TypeSpec type. Emitters and libraries may choose to use this hint to determine how a\r\ntype should be serialized. For example, the `@typespec/http` library will use the media type hint of the response\r\nbody type as a default `Content-Type` if one is not explicitly specified in the operation.\r\n\r\nMedia types (also known as MIME types) are defined by RFC 6838. The media type hint should be a valid media type\r\nstring as defined by the RFC, but the decorator does not enforce or validate this constraint.\r\n\r\nNotes: the applied media type is _only_ a hint. It may be overridden or not used at all. Media type hints are\r\ninherited by subtypes. If a media type hint is applied to a model, it will be inherited by all other models that\r\n`extend` it unless they delcare their own media type hint.\r\n```typespec\r\n@mediaTypeHint(mediaType: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Scalar | Enum | Union`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| mediaType | [valueof `string`](#string) | The media type hint to apply to the target type. |\r\n\r\n#### Examples\r\n##### create a model that serializes as XML by default\r\n\r\n\r\n```tsp\r\n@mediaTypeHint(\"application/xml\")\r\nmodel Example {\r\n  @visibility(Lifecycle.Read)\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n```\n\n### `@minItems` {#@minItems}\n\nSpecify the minimum number of items this array should have.\r\n```typespec\r\n@minItems(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown[] | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Minimum number |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minItems(1)\r\nmodel Endpoints is string[];\r\n```\n\n### `@minLength` {#@minLength}\n\nSpecify the minimum length this string type should be.\r\n```typespec\r\n@minLength(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Minimum length |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minLength(2)\r\nscalar Username extends string;\r\n```\n\n### `@minValue` {#@minValue}\n\nSpecify the minimum value this numeric type should be.\r\n```typespec\r\n@minValue(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Minimum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minValue(18)\r\nscalar Age is int32;\r\n```\n\n### `@minValueExclusive` {#@minValueExclusive}\n\nSpecify the minimum value this numeric type should be, exclusive of the given\r\nvalue.\r\n```typespec\r\n@minValueExclusive(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Minimum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minValueExclusive(0)\r\nscalar distance is float64;\r\n```\n\n### `@nextLink` {#@nextLink}\n\nPagination property defining a link to the next page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@nextLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@offset` {#@offset}\n\nPagination property defining the number of items to skip.\r\n```typespec\r\n@offset\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@offset skip: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@opExample` {#@opExample}\n\nProvide example values for an operation's parameters and corresponding return type.\r\n```typespec\r\n@opExample(example: valueof OperationExample, options?: valueof ExampleOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| example | [valueof `OperationExample`](./built-in-data-types.md#OperationExample) | Example value. |\r\n| options | [valueof `ExampleOptions`](./built-in-data-types.md#ExampleOptions) | Optional metadata for the example. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@opExample(#{parameters: #{name: \"Fluffy\", age: 2}, returnType: #{name: \"Fluffy\", age: 2, id: \"abc\"})\r\nop createPet(pet: Pet): Pet;\r\n```\n\n### `@overload` {#@overload}\n\nSpecify this operation is an overload of the given operation.\r\n```typespec\r\n@overload(overloadbase: Operation)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| overloadbase | `Operation` | Base operation that should be a union of all overloads |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(data: string | bytes, @header contentType: \"text/plain\" | \"application/octet-stream\"): void;\r\n@overload(upload)\r\nop uploadString(data: string, @header contentType: \"text/plain\" ): void;\r\n@overload(upload)\r\nop uploadBytes(data: bytes, @header contentType: \"application/octet-stream\"): void;\r\n```\n\n### `@pageIndex` {#@pageIndex}\n\nPagination property defining the page index.\r\n```typespec\r\n@pageIndex\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@pageItems` {#@pageItems}\n\nSpecify the the property that contains the array of page items.\r\n```typespec\r\n@pageItems\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@pageSize` {#@pageSize}\n\nSpecify the pagination parameter that controls the maximum number of items to include in a page.\r\n```typespec\r\n@pageSize\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@parameterVisibility` {#@parameterVisibility}\n\nDeclares the visibility constraint of the parameters of a given operation.\r\n\r\nA parameter or property nested within a parameter will be visible if it has _any_ of the visibilities\r\nin the list.\r\n\r\nIt is invalid to call this decorator with no visibility modifiers.\r\n```typespec\r\n@parameterVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibility modifiers that apply to the parameters of this operation. |\n\n### `@pattern` {#@pattern}\n\nSpecify the the pattern this string should respect using simple regular expression syntax.\r\nThe following syntax is allowed: alternations (`|`), quantifiers (`?`, `*`, `+`, and `{ }`), wildcard (`.`), and grouping parentheses.\r\nAdvanced features like look-around, capture groups, and references are not supported.\r\n\r\nThis decorator may optionally provide a custom validation _message_. Emitters may choose to use the message to provide\r\ncontext when pattern validation fails. For the sake of consistency, the message should be a phrase that describes in\r\nplain language what sort of content the pattern attempts to validate. For example, a complex regular expression that\r\nvalidates a GUID string might have a message like \"Must be a valid GUID.\"\r\n```typespec\r\n@pattern(pattern: valueof string, validationMessage?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`string | bytes | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| pattern | [valueof `string`](#string) | Regular expression. |\r\n| validationMessage | [valueof `string`](#string) | Optional validation message that may provide context when validation fails. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@pattern(\"[a-z]+\", \"Must be a string consisting of only lower case letters and of at least one character.\")\r\nscalar LowerAlpha extends string;\r\n```\n\n### `@prevLink` {#@prevLink}\n\nPagination property defining a link to the previous page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@prevLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@removeVisibility` {#@removeVisibility}\n\nRemoves visibility modifiers from a property.\r\n\r\nIf the visibility modifiers for a visibility class have not been initialized,\r\nthis decorator will use the default visibility modifiers for the visibility\r\nclass as the default modifier set.\r\n```typespec\r\n@removeVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\nThe property to remove visibility from.\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | The visibility modifiers to remove from the target property. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Example {\r\n  // This property will have all Lifecycle visibilities except the Read\r\n  // visibility, since it is removed.\r\n  @removeVisibility(Lifecycle.Read)\r\n  secret_property: string;\r\n}\r\n```\n\n### `@returnsDoc` {#@returnsDoc}\n\nAttach a documentation string to describe the successful return types of an operation.\r\nIf an operation returns a union of success and errors it only describes the success. See `@errorsDoc` for error documentation.\r\n```typespec\r\n@returnsDoc(doc: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@returnsDoc(\"Returns doc\")\r\nop get(): Pet | NotFound;\r\n```\n\n### `@returnTypeVisibility` {#@returnTypeVisibility}\n\nDeclares the visibility constraint of the return type of a given operation.\r\n\r\nA property within the return type of the operation will be visible if it has _any_ of the visibilities\r\nin the list.\r\n\r\nIt is invalid to call this decorator with no visibility modifiers.\r\n```typespec\r\n@returnTypeVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibility modifiers that apply to the return type of this operation. |\n\n### `@secret` {#@secret}\n\nMark this string as a secret value that should be treated carefully to avoid exposure\r\n```typespec\r\n@secret\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@secret\r\nscalar Password is string;\r\n```\n\n### `@service` {#@service}\n\nMark this namespace as describing a service and configure service properties.\r\n```typespec\r\n@service(options?: valueof ServiceOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| options | [valueof `ServiceOptions`](./built-in-data-types.md#ServiceOptions) | Optional configuration for the service. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\nnamespace PetStore;\r\n```\r\n\r\n##### Setting service title\r\n\r\n```typespec\r\n@service(#{title: \"Pet store\"})\r\nnamespace PetStore;\r\n```\r\n\r\n##### Setting service version\r\n\r\n```typespec\r\n@service(#{version: \"1.0\"})\r\nnamespace PetStore;\r\n```\n\n### `@summary` {#@summary}\n\nTypically a short, single-line description.\r\n```typespec\r\n@summary(summary: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| summary | [valueof `string`](#string) | Summary string. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@summary(\"This is a pet\")\r\nmodel Pet {}\r\n```\n\n### `@tag` {#@tag}\n\nAttaches a tag to an operation, interface, or namespace. Multiple `@tag` decorators can be specified to attach multiple tags to a TypeSpec element.\r\n```typespec\r\n@tag(tag: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| tag | [valueof `string`](#string) | Tag value |\n\n### `@visibility` {#@visibility}\n\nSets the visibility modifiers that are active on a property, indicating that it is only considered to be present\r\n(or \"visible\") in contexts that select for the given modifiers.\r\n\r\nA property without any visibility settings applied for any visibility class (e.g. `Lifecycle`) is considered to have\r\nthe default visibility settings for that class.\r\n\r\nIf visibility for the property has already been set for a visibility class (for example, using `@invisible` or\r\n`@removeVisibility`), this decorator will **add** the specified visibility modifiers to the property.\r\n\r\nSee: [Visibility](https://typespec.io/docs/language-basics/visibility)\r\n\r\nThe `@typespec/http` library uses `Lifecycle` visibility to determine which properties are included in the request or\r\nresponse bodies of HTTP operations. By default, it uses the following visibility settings:\r\n\r\n- For the return type of operations, properties are included if they have `Lifecycle.Read` visibility.\r\n- For POST operation parameters, properties are included if they have `Lifecycle.Create` visibility.\r\n- For PUT operation parameters, properties are included if they have `Lifecycle.Create` or `Lifecycle.Update` visibility.\r\n- For PATCH operation parameters, properties are included if they have `Lifecycle.Update` visibility.\r\n- For DELETE operation parameters, properties are included if they have `Lifecycle.Delete` visibility.\r\n- For GET or HEAD operation parameters, properties are included if they have `Lifecycle.Query` visibility.\r\n\r\nBy default, properties have all five Lifecycle visibility modifiers enabled, so a property is visible in all contexts\r\nby default.\r\n\r\nThe default settings may be overridden using the `@returnTypeVisibility` and `@parameterVisibility` decorators.\r\n\r\nSee also: [Automatic visibility](https://typespec.io/docs/libraries/http/operations#automatic-visibility)\r\n```typespec\r\n@visibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type |\n\nBy default, properties have all five Lifecycle visibility modifiers enabled, so a property is visible in all contexts\r\nby default.\r\n\r\nThe default settings may be overridden using the `@returnTypeVisibility` and `@parameterVisibility` decorators.\r\n\r\nSee also: [Automatic visibility](https://typespec.io/docs/libraries/http/operations#automatic-visibility)\r\n```typespec\r\n@visibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibilities which apply to this property. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  // The service will generate an ID, so you don't need to send it.\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // The service will store this secret name, but won't ever return it.\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  // The regular name has all vi\r\n  name: string;\r\n}\r\n```\n\n### `@withDefaultKeyVisibility` {#@withDefaultKeyVisibility}\n\nSet the visibility of key properties in a model if not already set.\r\n\r\nThis will set the visibility modifiers of all key properties in the model if the visibility is not already _explicitly_ set,\r\nbut will not change the visibility of any properties that have visibility set _explicitly_, even if the visibility\r\nis the same as the default visibility.\r\n\r\nVisibility may be set explicitly using any of the following decorators:\r\n\r\n- `@visibility`\r\n- `@removeVisibility`\r\n- `@invisible`\r\n```typespec\r\n@withDefaultKeyVisibility(visibility: valueof EnumMember)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibility | `valueof EnumMember` | The desired default visibility value. If a key property already has visibility set, it will not be changed. |\n\n### `@withLifecycleUpdate` {#@withLifecycleUpdate}\n\nTransforms the `target` model to include only properties that are visible during the\r\n\"Update\" lifecycle phase.\r\n\r\nAny nested models of optional properties will be transformed into the \"CreateOrUpdate\"\r\nlifecycle phase instead of the \"Update\" lifecycle phase, so that nested models may be\r\nfully updated.\r\n```typespec\r\n@withLifecycleUpdate\r\n```\r\n\r\n#### Target\r\nThe model to apply the transformation to.\r\n`Model`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@withLifecycleUpdate\r\nmodel DogUpdate {\r\n  ...Dog\r\n}\r\n```\n\n### `@withOptionalProperties` {#@withOptionalProperties}\n\nReturns the model with required properties removed.\r\n```typespec\r\n@withOptionalProperties\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\nNone\n", "latency": 11.742420434951782, "response_length": 1467}
{"query": "title: Does TypeSpec support example generation for new added versions?\n\nquestion: Hi team, when adding a new api version in the TypeSpec, is there any way I can generate thoes example Json files from preview version and with the \"api-version\" property changed? Or I will need to manually cope the example Json files from preview version and update the \"api-version\" property inside all of them?", "ground_truth": "Example generation for specs works the same way as it did before.\nVersion-specific examples need to be placed under examples[version].\nSwagger-based example generation can be used for new versions, but it is less attractive if examples are customized.", "response": "When adding a new API version in TypeSpec, you can generate example JSON files for the new version by leveraging the `@typespec/versioning` library and its decorators like `@added`. However, TypeSpec does not automatically copy example JSON files from a previous version and update the `api-version` property. You will need to manually copy the example JSON files from the preview version and update the `api-version` property, or use a custom script to automate this process. Additionally, you can configure the `examples-directory` option in the TypeSpec AutoRest emitter to manage and link examples effectively.", "context": "- document_dir: typespec_azure_docs\n- document_filename: emitters#typespec-autorest#index.md\n- document_title: TypeSpec AutoRest Library\n- document_link: https://azure.github.io/typespec-azure/docs/emitters/typespec-autorest/index\n- document_content: # emitters#typespec-autorest#index.md\n\n# TypeSpec AutoRest Library\n\nThis is a TypeSpec library that will emit an enriched OpenAPI 2.0 specification that can be consumed by AutoRest.\r\nThe generated OpenAPI spec will have custom `x-ms-` extensions properties and conform to standards required by AutoRest to generate a more accurate SDK.\n\n## Getting started\n\n1. Include `@azure-tools/typespec-autorest` dependencies in package.json\r\n\r\n```json\r\n{\r\n  ...\r\n  \"dependencies\": {\r\n    ...\r\n    \"@azure-tools/typespec-autorest\": \"latest\"\r\n  }\r\n}\r\n```\r\n\r\n2. Run `npm install` to install the dependency\r\n3. Import `@azure-tools/typespec-autorest` in your `main.tsp` file\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-autorest\";\r\n```\r\n\r\n4. Run `tsp compile`. This will result in a `swagger.json` file crated in `./tsp-output/swagger.json`\n\n## Use in autorest\n\nGenerate the OpenAPI spec as shown above then run autorest cli directly on it.\r\n\r\n```bash\r\nautorest --input-file=<path/to/generated/file.json>\n\n# Example\n\nautorest --input-file=./tsp-output/@azure-tools/typespec-autorest/openapi.json --python\r\n```\n\n## Configuration\n\n### Emitter options:\n\nEmitter options can be configured via the `tspconfig.yaml` configuration:\r\n\r\n```yaml\r\nemitters:\r\n  '@azure-tools/typespec-autorest':\r\n    <optionName>: <value>\n\n# For example\n\n`openapi.Org1.Service2.yaml`\r\n\r\nExample: Single service with versioning\r\n\r\n- `openapi.v1.yaml`\r\n- `openapi.v2.yaml`\r\n\r\nExample: Multiple service with versioning\r\n\r\n- `openapi.Org1.Service1.v1.yaml`\r\n- `openapi.Org1.Service1.v2.yaml`\r\n- `openapi.Org1.Service2.v1.0.yaml`\r\n- `openapi.Org1.Service2.v1.1.yaml`\r\n\r\nExample: azureResourceProviderFolder is provided\r\n\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n\r\n#### `examples-directory`\r\n\r\nDirectory where the x-ms-examples are located so the emitter can automatically link.\r\n\r\n#### `version`\r\n\r\nSelect which version should be emitted if the spec support versioning. By default all the version with be emitted in this format `<outputFileName>.<version>.json`\n\nemitters:\r\n  '@azure-tools/typespec-autorest':\r\n    output-file: my-custom-swagger.json\r\n```\r\n\r\nor via the command line with\r\n\r\n```bash\r\n--option \"@azure-tools/typespec-autorest.<optionName>=<value>\"\r\n\r\n--option \"@azure-tools/typespec-autorest.output-file=my-custom-swagger.json\"\r\n```\r\n\r\n#### `azure-resource-provider-folder`\r\n\r\n`resource-manager` directory under your service folder are located so the emitter can emit correct sub-folder structure and swagger files for each of the API versions. You must specify it for ARM specs with folder path relative to the TypeSpec files.\r\n\r\n#### `emitter-output-dir`\r\n\r\nSet the emitter output-dir. [See here](https://typespec.io/docs/handbook/configuration#emitter-output-dir)\r\n\r\n#### `output-file`\r\n\r\nConfigure the name of the swagger output file relative to the `output-dir`.\r\n\r\nOutput file will interpolate the following values:\r\n\r\n- service-name: Name of the service if multiple\r\n- version: Version of the service if multiple\r\n- azure-resource-provider-folder: Value of the azure-resource-provider-folder option\r\n- version-status: Only enabled if azure-resource-provider-folder is set. `preview` if version contains preview, stable otherwise.\r\n\r\nDefault: `{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/openapi.json`\r\n\r\nExample: Single service no versioning\r\n\r\n- `openapi.yaml`\r\n\r\nExample: Multiple services no versioning\r\n\r\n- `openapi.Org1.Service1.yaml`\r\n- `openapi.Org1.Service2.yaml`\r\n\r\nExample: Single service with versioning\r\n\r\n- `openapi.v1.yaml`\r\n- `openapi.v2.yaml`\r\n\r\nExample: Multiple service with versioning\r\n\r\n- `openapi.Org1.Service1.v1.yaml`\r\n- `openapi.Org1.Service1.v2.yaml`\r\n- `openapi.Org1.Service2.v1.0.yaml`\r\n- `openapi.Org1.Service2.v1.1.yaml`\r\n\r\nExample: azureResourceProviderFolder is provided\r\n\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\r\n\r\n#### `examples-directory`\n\n### `new-line`\n\nSet the newline character for emitting files. Can be either:\r\n\r\n- `lf`(Default)\r\n- `crlf`\n\n### `omit-unreachable-types`\n\nOnly include types referenced via an operation.\n\n## Decorators\n\n- [@collectionFormat](#collectionformat)\r\n- [@example](#example)\r\n- [@useRef](#useref)\n\n### @collectionFormat\n\nSyntax:\r\n\r\n```\r\n@collectionFormat(formatString)\r\n```\r\n\r\n`@collectionFormat` specifies array property type serialization format. Valid format strings are \"csv\", \"multi\", \"ssv\", \"tsv\", \"pipes\" though \"csv\" or \"multi\" are recommended.\r\n\r\n`@collectionFormat` can only be specified on model properties that are arrays.\n\n### @example\n\nSyntax:\r\n\r\n```\r\n@example(pathOrUri, title)\r\n```\r\n\r\n`@example` attaches example files to an operation. Multiple examples can be specified.\r\n\r\n`@example` can only be specified on operations.\n\n### @useRef\n\nSyntax:\r\n\r\n```\r\n@useRef(urlString)\r\n```\r\n\r\n`@useRef` is used to replace the TypeSpec model type in emitter output with a pre-existing named OpenAPI schema such as ARM common types.\n\n## How to\n\n### Include `x-ms-skip-url-encoding` in `x-ms-parmaeterized-host` parameter\n\nEvery parameter of type `uri` in `@server` will be marked with `x-ms-skip-url-encoding`.\r\n\r\n```typespec\r\n@server(\"{endpoint}/v2\", \"Account endpoint\", {endpoint: url})\r\n```\r\n\r\nResult in\r\n\r\n```json5\r\n{\r\n  in: \"path\",\r\n  name: \"endpoint\",\r\n  required: true,\r\n  type: \"string\",\r\n  format: \"uri\",\r\n  \"x-ms-skip-url-encoding\": true,\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#09versioning.mdx\n- document_title: Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/09versioning\n- document_content: # howtos#generate-client-libraries#09versioning.mdx\n\n# Versioning\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis doc details what emitters will generate for versioned specs\n\n## Single api Version\n\nIf there is just one api version in the spec, we will generate the api surface area for that one version.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\nstatic ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01\")\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\nwith pytest.expect(ImportError):\r\n  preview_model = models.PreviewModel(preview_functionality=\"not present\")\r\n\r\nwith pytest.expect(AttributeError):\r\n  client.preview_functionality({\"previewFunctionality\": \"not present\"})\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api-version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\n//neither PreviewModel nor PreviewFunctionality will be generated\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n# python allows you to override the api version, even if only one version is defined in the spec\n\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01\"\r\n```\r\n\r\n```typescript\r\n// there's no apiVersion defined in the all the operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n## Multiple api versions\n\nThe configuration flag `api-version` allows you to toggle the behavior that our emitters will generate.\r\n\r\nWe will get the versioning information from the `Versions` enum that you pass to the `@versioned` decorator from the `@typespec/versioning` library.\r\n\r\n> NOTE: The ordering of the values in the `Versions` enum is very important. We use this information to determine the order of versions. Our default value will be the **last entry** in the `Versions` list\n\n### Default\n\nBy default our emitters will only generate the surface used by the latest api version if there are multiple defined. This includes generating only the models used in the surface area of the latest api version.\r\n\r\nDocumentation and enums showing the available api versions will still include all of the known api versions, meaning there will be documentation for both the preview and stable releases.\r\n\r\nFor the below example, all languages will generate the api surface of default version `v2023_11_01`. There will be no generation of the operation `previewFunctionality`, and we will also not generate the `PreviewModel` because it's only used in `previewFunctionality`, and therefore is not used in the api surface of `v2023_11_01`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\n### Override to a specific version\n\nYou can override the signature to return the api surface area for a specific api version.\r\n\r\nIn this example, you can see how this change is made in tspconfig.yaml, and we are going to override to return the preview api surface area for our spec. The preview api surface area contains all of the functionality.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01-preview\"\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\npreview_client.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\n# the model is generated as part of the api surface\n\npreview_client.preview_functionality(preview_model) # call goes through\r\n\r\n````\r\n\r\n```csharp\r\n// ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n// client's api-version will be \"2023-11-01-preview\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n````\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01_PREVIEW(\"2023-11-01-preview\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01_PREVIEW\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01-preview\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\nPreviewModel previewModel = new PreviewModel(\"present\");\r\n// call goes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\n\ngoes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01_Preview);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01-preview\"\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n### Override to return all\n\nYou can also override the signature to return the combined api surface area of all of the separate api versions. Different languages have different support for versioning validation.\r\n\r\nIn the following examples, you can observe how this change is made in `tspconfig.yaml`.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n## Overriding the Client Api Version Parameter\n\nonto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient clientWithSpecifiedApiVersion = new ServiceClient(endpoint, options);\r\n//client's version will be \"2023-11-01\"\r\nResponse response = client.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n    V2024_04_01(\"2024-04-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2024_04_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient client = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's version will be 2024-04-01\r\n\r\nServiceClientClient clientWithSpecifiedApiVersion = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    .buildClient();\r\n// client's version will be 2023-11-01\r\n\r\nclient.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```go\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n\nBy default, we find api version parameters in specs based off of names. There is special logic we do with api version parameters:\r\n\r\n1. These api version parameters get elevated up to the client level (if the service is versioned)\r\n2. We auto-add api version information to next links when paging\r\n3. We set the client default for these parameters to be the default api version for your service.\r\n\r\nThere are cases where you have an api-versioning parameter without the explicit name `api-version`. In these cases, you can use the `@isApiVersion` decorator to override and explicitly say whether that parameter is an api version param or not.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\nusing Versioning;\r\nusing Http;\r\nusing Azure.ClientGenerator.Core;\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n  v2024_04_01: \"2024-04-01\",\r\n}\r\nop get(\r\n  @isApiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\r\n\r\n```python\r\nfrom my.service import MyServiceClient\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\r\nprint(client.version) # == \"2024-04-01\", since that is the default\r\n\r\nclient_with_specified_api_version = MyServiceClient(endpoint=..., credential=..., version=\"2023-11-01\")\r\nprint(client.version) # == \"2023-11-01\", since we specified\r\n\r\nretval = client.get() # version is elevated onto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\n", "latency": 9.159295558929443, "response_length": 614}
{"query": "title: Update API definition in typespec-providerhub\n\nquestion: Hi team, I'm using providerhub template to generate a new RP, when trying to add custom API(simple health check for testing) in main.tsp, after build it doesn't generate the new model and controllers that I added, does the template have restrictions on what kind of APIs can be added? Here's what I tried to add into typespec.\n```\n// Add the health check operation\n@doc(\"Health check endpoint to verify the service is running.\")\nmodel HealthCheckResponse {\nmessage: string;\n}\ninterface HealthCheck {\n@get\n@route(\"/api/healthcheck\")\n@doc(\"Returns a simple message indicating the service is running.\")\nhealthCheck(): HealthCheckResponse;\n}\n```", "ground_truth": "The emitter is specifically for generating RPaaS extensions, not APIs. Custom controllers can be written outside of generated extensions.\nDocumentation for the typespec-providerhub-controller emitter can be found at [typespec-azure-pr/docs/getstarted/providerhub at providerhub  Azure/typespec-azure-pr](https://github.com/Azure/typespec-azure-pr/tree/providerhub/docs/getstarted/providerhub) and [typespec-azure-pr/packages/typespec-providerhub-controller/readme.md at providerhub  Azure/typespec-azure-pr](https://github.com/Azure/typespec-azure-pr/blob/providerhub/packages/typespec-providerhub-controller/readme.md).", "response": "The TypeSpec language itself does not impose restrictions on adding custom APIs like your health check operation. However, if you are using a specific template, such as the `providerhub` template, it may include predefined configurations or rules that could affect the generation of models and controllers. To ensure your custom API is included, verify the following:\n\n1. **Namespace and Service Definition**: Ensure your `HealthCheck` interface and `HealthCheckResponse` model are defined within the correct namespace and are part of the service definition. For example:\n\n   ```tsp\n   @service(#{ title: \"My Service\" })\n   @server(\"https://example.com\", \"Default server\")\n   namespace MyNamespace;\n\n   model HealthCheckResponse {\n     message: string;\n   }\n\n   interface HealthCheck {\n     @get\n     @route(\"/api/healthcheck\")\n     healthCheck(): HealthCheckResponse;\n   }\n   ```\n\n2. **Compilation and Output**: After adding your custom API, run `tsp compile .` to ensure the changes are reflected in the generated OpenAPI specification or other outputs. Check the `tsp-output` folder for the updated files.\n\n3. **Template-Specific Rules**: If the `providerhub` template enforces specific patterns or rules, consult its documentation or configuration files (e.g., `tspconfig.yaml`) to ensure your custom API aligns with its requirements.\n\nIf the issue persists, consider reviewing the generated OpenAPI specification (`openapi.yaml`) to confirm whether your custom API is included. If not, there may be additional constraints in the template or configuration that need adjustment.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/language-basics/decorators\n- document_content: # language-basics#decorators.md\n\n# Decorators\n\nDecorators in TypeSpec allow developers to attach metadata to types within a TypeSpec program. They can also be used to compute types based on their inputs. Decorators form the core of TypeSpec's extensibility, providing the flexibility to describe a wide variety of APIs and associated metadata such as documentation, constraints, samples, and more.\r\n\r\nThe vast majority of TypeSpec declarations may be decorated, including [namespaces](./namespaces.md), [interfaces](./interfaces.md), [operations](./operations.md) and their parameters, [scalars](./scalars.md), and [models](./models.md) and their members. In general, any declaration that creates a Type can be decorated. Notably, [aliases](./alias.md) cannot be decorated, as they do not create new Types, nor can any type expressions such as unions that use the `|` syntax or anonymous models, as they are not declarations.\r\n\r\nDecorators are defined using JavaScript functions that are exported from a standard ECMAScript module. When a JavaScript file is imported, TypeSpec will look for any exported functions prefixed with `$`, and make them available as decorators within the TypeSpec syntax. When a decorated declaration is evaluated by TypeSpec, the decorator function is invoked, passing along a reference to the current compilation, an object representing the type it is attached to, and any arguments the user provided to the decorator.\n\n## Applying decorators\n\nDecorators are referenced using the `@` prefix and must be placed before the entity they are decorating. Arguments can be provided by using parentheses, similar to function calls in many programming languages, e.g., `@myDec1(\"hi\", { a: string })`.\r\n\r\nHere's an example of declaring and then using a decorator:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {\r\n  @validate(false)\r\n  name: string;\r\n}\r\n```\r\n\r\nIf no arguments are provided, the parentheses can be omitted.\r\n\r\n```typespec\r\n@mark\r\nmodel Dog {}\r\n```\n\n## Augmenting decorators\n\nDecorators can also be applied from a different location by referring to the type being decorated. For this, you can declare an augment decorator using the `@@` prefix. The first argument of an augment decorator is the type reference that should be decorated. As the augment decorator is a statement, it must end with a semicolon (`;`).\r\n\r\n```typespec\r\nmodel Dog {}\r\n\r\n@@tag(Dog, \"Sample\");\r\n```\r\n\r\nThis is equivalent to:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {}\r\n```\r\n\r\nExample: decorating a model property to indicate that it is read-only\r\n\r\n```typespec\r\nmodel Dog {\r\n  name: string;\r\n}\r\n\r\n@@visibility(Dog.name, Lifecycle.Read);\r\n```\n\n## Creating decorators\n\nFor more information on creating decorators, see [Creating Decorators](../extending-typespec/create-decorators.md).\n", "latency": 11.952677011489868, "response_length": 1581}
{"query": "title: Data Plane Resource Additional List operation\n\nquestion: We have a data plane resource that exists under a parent scope and has a list operation. We would like to add another list operation to enable the caller to list all resources of that type across parents.  How do I define this operation?\nHave list by parent: GET /parentType/{parantName}/childType\nWant list all: GET /childType\nI'm currently duplicating the type model ( where duplicate model has no parent) to make this possible but I'm not a fan of the duplicate type:\n```\n@doc(\"A catalog agent definition.\")\n@parentResource(Catalog)\n@resource(\"agentDefinitions\")\nmodel AgentDefinition {\n@doc(\"The agent name.\")\n@visibility(Lifecycle.Read)\n@key(\"agentName\")\nname: string;\n...BaseAgentDefinition;\n}\n@doc(\"A catalog agent definition.\")\n@resource(\"agentDefinitions\")\nmodel AgentDefinitionAnyCatalog {\n@doc(\"The agent name.\")\n@visibility(Lifecycle.Read)\n@key(\"agentName\")\nname: string;\n...BaseAgentDefinition;\n}\n```\n```\n@doc(\"List AgentDefinition resources by Project\")\nlistAgentDefinitions is ResourceList<AgentDefinition>;\n@doc(\"List AgentDefinition resources for all Projects\")\n@route(\"/\")\nlistAgentDefinitionsAll is ResourceList<AgentDefinitionAnyCatalog>;\n```", "ground_truth": "Use RPC template, ResourceAction template (with verb overridden to @get), or a lower-level operation template for listing all resources across parents.\nEnsure @autoRoute is not enabled for the operation and add @listsResource decorator for associating operations with particular resources.\nUse CustomPage or Page directly for paged responses.\nGroup operations using an interface or namespace.", "response": "To define a `list all` operation for your data plane resource without duplicating the type model, you can use the `ArmResourceListBySubscription` operation template provided by TypeSpec. This template is specifically designed for listing resources across parent scopes, such as listing all resources of a type within a subscription. Here's how you can define the operation:\n\n```typespec\n@doc(\"List AgentDefinition resources by Project\")\nlistAgentDefinitions is ArmResourceListByParent<AgentDefinition>;\n\n@doc(\"List all AgentDefinition resources across Projects\")\nlistAgentDefinitionsAll is ArmResourceListBySubscription<AgentDefinition>;\n```\n\nThis approach avoids duplicating the type model and adheres to best practices for defining resource operations in TypeSpec. The `ArmResourceListBySubscription` template ensures that the operation is correctly modeled for listing resources across parent scopes.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-operations.md\n- document_title: ARM Resource Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations\n- document_content: # howtos#arm#resource-operations.md\n\n# ARM Resource Operations\n\n## Recommended and Required Operations\n\n### TrackedResource\n\n| Operation             | Recommended | Required | TypeSpec Representation                                          |\r\n| --------------------- | ----------- | -------- | ---------------------------------------------------------------- |\r\n| GET                   | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                              |\r\n| CreateOrUpdate (PUT)  | Yes         | Yes      | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`    |\r\n| Tags Update (PATCH)   | No          | Yes\\*    | `update is ArmResourceTagsPatchSync<Resource>;`                  |\r\n| Full Update (PATCH)   | Yes         | No\\*     | `update is ArmCustomPatchSync<Resource, PatchRequest>;`          |\r\n| Delete                | Yes         | Yes      | `delete is ArmResourceDeleteSync<Resource>;`                     |\r\n| List by ResourceGroup | Yes         | Yes      | `listByResourceGroup is ArmResourceListByParent<Resource>;`      |\r\n| List by Subscription  | Yes         | Yes      | `listBySubscription is ArmResourceListBySubscription<Resource>;` |\r\n\r\n\\* Arm requires that, at minimum, a TrackedResource can update Tags. A Full PATCH of all updateable resource properties is preferred.\n\n### Proxy Resource\n\n| Operation            | Recommended | Required | TypeSpec Representation                                       |\r\n| -------------------- | ----------- | -------- | ------------------------------------------------------------- |\r\n| GET                  | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                           |\r\n| CreateOrUpdate (PUT) | Yes         | No\\*     | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;` |\r\n| Update (PATCH)       | Yes         | No       | `update is ArmCustomPatchSync<Resource, PatchRequest>;`       |\r\n| Delete               | Yes         | No\\*     | `delete is ArmResourceDeleteSync<Resource>;`                  |\r\n| List by Parent       | Yes         | Yes      | `listByParent is ArmResourceListByParent<Resource>;`          |\r\n\r\n\\* Note that, if a resource implements Create, it is highly recommended that it implement delete as well, and vice-versa.\n\n## TypeSpec Operation Templates and Interface Templates\n\nTypeSpec provide operation templates that describe the request and response of standard resource operations. A description of the options available for each resource template, and how to choose which one is described in the sections below.\n\n### Synchronous and Asynchronous APIs\n\nCreateOrUpdate (PUT), Update (Patch), Delete, and Action (POST) operations over a resource may\n\n### Determining Which Resource Properties Appear in Lifecycle Operations\n\nBy default, any property that occurs in your resource model will also appear in the response to GET, PUT, PATCH, and LIST operations, and in the request for PUT and PATCH operations. This does not work for all properties. Some properties are calculated by the service and cannot be directly set by PUT or PATCH (provisioningState, modification date, etc.). Some properties can only be set when creating a resource, but always appear in responses (e.g. 'location'). Some properties can only be set when updating the resource, and appear in responses. Some properties (rarely) may be settable when updating the resource via PUT or PATCH. To allow using a common resource model, but applying these `views` of resources to determine how the resource appear in request and responses, TypeSpec provides the visibility framework. You can see a complete representation of available visibilities in the table [on Property Visibility and Other Constraints](./resource-type.md#property-visibility-and-other-constraints). The sections below outline some common scenarios for designing properties with your operations in mind.\r\n\r\n#### Properties That Are Never Directly Set by the User\r\n\r\nIt is common to have properties that are calculated by the service or otherwise not directly set by the user, examples include timestamps, dates, values that are only set by specific actions (on/off, enabled/disabled, provisioningState). You want to make sure that these properties are marked so that they will appear in responses and not requests. this is done using the `@visibility(Lifecycle.Read)` decorator instance:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Read)\r\nprovisioningState: ProvisioningState;\r\n```\n\n### Resource Get Operations\n\nGet is the operation to retrieve a single resource TypeSpec provides a single operation template for GET:\r\n\r\n```typespec\r\nop get is ArmResourceRead<MyResource>;\r\n```\r\n\r\n- **get**: The name of the operation passed on to clients.\r\n- **Resource**: A reference to your resource type.\n\n### Resource CreateOrUpdate Operations (PUT)\n\nThe CreateOrUpdate operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\n- Simple resources may have synchronous PUT operations. If a resource may need to perform additional checks, creation of other dependent resources, or the like, it is best to use an Asynchronous API.\r\n- Asynchronous operations for PUT occur when the RP needs to perform additional validaton actions, create other resources, or perform other tasks as part of resource creation or update that can cause the operation to take longer than the length of a single request/response.\r\n\r\n| Operation        | TypeSpec                                                          |\r\n| ---------------- | ----------------------------------------------------------------- |\r\n| Synchronous PUT  | `createOrUpdate is ArmResourceCreateOrReplaceSync<ResourceType>`  |\r\n| Asynchronous PUT | `createOrUpdate is ArmResourceCreateOrReplaceAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `createOrUpdate` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being created (or updated)\n\n### Resource Update Operations (PATCH)\n\nPATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\r\nThe ArmCustomPatch\\* templates take the resource type and your custom PATCH request type as parameters.\n\nARM Requires that all `Tracked` resources implement PATCH for ARM tags, which are contained in the envelope of every `TrackedResource`. ARM recommends that you also allow PATCH of other envelope properties and resource-specific properties. Unless marked with a specific visibility, any property in your rp-specific properties will be automatically included in the PATCH schema.\r\n\r\nTypeSpec Provides both Synchronous and Asynchronous PATCH Operations, and allows you to specify a PATCH for Resource tags only, a PATCH for all updateable properties, or a custom patch. Generally, you should choose the patch for all updateable properties, unless you have a very good reason for choosing another PATCH operation.\r\n\r\n| Operation Description      | TypeSpec                                                                                                                                   |\r\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Sync TagsOnly PATCH        | `update is ArmTagsPatchSync<ResourceType>`                                                                                                 |\r\n| Async TagsOnly PATCH       | `update is ArmTagsPatchAsync<ResourceType>`                                                                                                |\r\n| Sync All Properties PATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\n\n### Resource Delete Operations (DELETE)\n\nThe Delete operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\nSimple resources may have synchronous DELETE operations. If a resource needs to clean up other resources or do other validations as part of delete, the delete operation may need to be asynchronous.\r\n\r\n| Operation           | TypeSpec                                                  |\r\n| ------------------- | --------------------------------------------------------- |\r\n| Synchronous Delete  | `delete is ArmResourceDeleteSync<ResourceType>`           |\r\n| Asynchronous Delete | `delete is ArmResourceDeleteWithoutOkAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `delete` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being deleted.\n\n### Resource List Operations (GET)\n\nArm Resource list operations return a list of Tracked or Proxy Resources at a particular scope.\r\n\r\n- All resources _should_ include a list operation at its immediate parent scope\r\n  - For **Tenant Resources**, this is at the tenant scope\r\n  - For **Extension Resources**, this is at the scope of resources they are extending\r\n  - For **Tracked Resources**, this is at the resource group scope.\r\n  - For **Child Resources**, this is at the scope of the resource parent.\r\n- Tracked resources _must_ include a list operation at the Subscription level.\r\n\r\n| Operation          | TypeSpec                                                            |\r\n| ------------------ | ------------------------------------------------------------------- |\r\n| ListByParent       | `listByWidget is ArmResourceListByParent<ResourceType>`             |\r\n| ListBySubscription | `listBySubscription is ArmResourceListBySubscription<ResourceType>` |\n\n### Resource Actions (POST)\n\nCustom actions define any operations over resources outside the simple CRUDL (Create< Read, Update, Delete, List) or lifecycle operations described above. Any operation that returns data that is not made up of resources, performs a prescriptive state change on the resource (cycling power, upgrading, etc.), or any operation that does not fit into the operations described above should be modelled as a _resource action_. Examples of resource actions include:\r\n\r\n- Operations that manage credentials associated with a resource\r\n- Operations that calculate statistics about resources\r\n- Operations that make specific state changes to resources (power cycle, upgrade, etc.)\r\n\r\n#### Actions that take input and output\r\n\r\nOperations that manage credentials are a good example fo this category. TypeSpec defines synchronous and asynchronous templates for actions that consume and produce information.\r\n\r\n| Operation                    | TypeSpec                                                                       |\r\n| ---------------------------- | ------------------------------------------------------------------------------ |\r\n| Synchronous Resource Action  | `updateCredentials is ArmResourceActionSync<ResourceType, Request, Response>`  |\r\n| Asynchronous Resource Action | `updateCredentials is ArmResourceActionAsync<ResourceType, Request, Response>` |\r\n\r\nParameters to the template are the ResourceType, the model for the operation Request body, and the model for the operation Response body.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- |\n\nbody.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- | ------------------------------------------------------------------------------------- |\r\n| Synchronous NoContent Action  | `updateCredentials is ArmResourceActionNoContentSync<ResourceType, Request>`          |\r\n| Asynchronous NoContent Action | `updateCredentials is ArmResourceActionNoResponseContentAsync<ResourceType, Request>` |\r\n\r\nParameters to the template are the ResourceType and the model for the operation Request body.\n\n### Actions that take no input but produce output (data retrieval actions)\n\nSome operations return data or paged lists of data. TypeSpec does not yet provide templates for these kinds of actions, but here are two templates that you could reuse in your own specification, described in the next section of the document:\r\n\r\n- [Synchronous Resource List Actions](#synchronous-list-action)\r\n- [Asynchronous List Action](#asynchronous-list-action)\n\n### Check Name Operations\n\nSome services provide operations to check name availability, either location-specific (locally) or globally, especially if a resource name must be globally unique (such as when an exposed endpoint uses the resource name in the url).\r\n\r\n| Operation                      | TypeSpec                                                                                             |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------- |\r\n| Global Name Availability Check | `checkGlobalName is checkGlobalNameAvailability<TRequest, TResponse, TAdditionalParams>`             |\r\n| Local Name Availability Check  | `checkLocalName is checkLocalNameAvailability<TRequest, TResponse, TAdditionalParams>`               |\r\n| Custom Name Availability Check | `customNameCheck is checkNameAvailability<TScopeParameters, TRequest, TResponse, TAdditionalParams>` |\r\n\r\n`checkGlobalNameAvailability` and `checkLocalNameAvailability` have default values that allow them to be used without specifying any template parameters. `checkNameAvailability` requires the `TScopeParameters` template parameter, which describes the parameters which define the scope of the name check request. For reference, the following table shows the `TScopeParameters` for the standard templates:\r\n\r\n| Operation                      | Scope Parameters                                                       |\r\n| ------------------------------ | ---------------------------------------------------------------------- |\r\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\r\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\n\n## Writing Custom Operations\n\nTypeSpec operation templates provide a simple mechanism for producing the most common operation patterns in ARM, using best practices and conforming to ARM RPC guidelines. However, sometimes a service has special requirements for operations that fall outside these boundaries. The `Azure.ResourceManager.Foundations` namespace provides lower level building blocks that can be used to produce operations and operation templates.\r\n\r\nThe building blocks are described in the sections below:\n\n### ARM Response Types\n\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\r\n\r\n| Model                               | Code | Description                                   |\r\n| ----------------------------------- | ---- | --------------------------------------------- |\r\n| `ArmResponse<T>`                    | 200  | Base Arm 200 response.                        |\r\n| `ArmResourceUpdatedResponse<T>`     | 200  | Resource updated (PUT) response.              |\r\n| `ArmResourceCreatedResponse<T>`     | 201  | Resource created response for an lro.         |\r\n| `ArmResourceCreatedSyncResponse<T>` | 201  | Resource created synchronously.               |\r\n| `ArmAcceptedResponse`               | 202  | Base Arm Accepted response.                   |\r\n| `ArmNoContentResponse`              | 204  | Base Arm No Content response.                 |\r\n| `ArmDeletedResponse`                | 200  | Resource deleted response.                    |\r\n| `ArmDeleteAcceptedResponse`         | 202  | Resource deletion in progress response.       |\r\n| `ResourceListResult<T>`             | 200  | Return a list of resource with ARM pagination |\r\n| `ErrorResponse`                     | x    | Error response                                |\n\n### Common Operation Parameters\n\nThere are a number of model types which specify common parameters which are used in resource type operations:\r\n\r\n| Model                           | In           | Description                                                 |\r\n| ------------------------------- | ------------ | ----------------------------------------------------------- |\r\n| `ApiVersionParameter`           | query        | api-version parameter                                       |\r\n| `SubscriptionIdParameter`       | path         | Subscription ID path parameter                              |\r\n| `ResourceGroupNameParameter`    | path         | Resource Group Name path parameter                          |\r\n| `ResourceInstanceParameters<T>` | path & query | Identity parameters for a resource, with api-version        |\r\n| `ResourceParentParameters<T>`   | path & query | Identity Parameters for listing by parent, with api-version |\r\n| `ResourceUriParameter`          | path         | Resource uri path parameter for Extension resources         |\r\n| `OperationIdParameter`          | path         | Operation Id path parameter                                 |\n\n### Synchronous List Action\n\nHere is a sample template for resource list actions that return synchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionSync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionSync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n\n### Asynchronous List Action\n\nHere is a sample template for resource list actions that return asynchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionAsync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ArmAcceptedResponse | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionAsync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#http#operations.md\n- document_title: Operations\n- document_link: https://typespec.io/docs/libraries/http/operations\n- document_content: # libraries#http#operations.md\n\n# Operations\n\n## Operation verb\n\n**Default behavior:**\r\n\r\n- If `@post` operation has a request body\r\n- `@get` otherwise\r\n\r\n**Configure:**\r\n\r\nYou can use one of the [verb decorators](./reference/decorators.md): `@get`, `@put`, etc.\n\n## Route\n\nAn operation route can be specified using the `@route` decorator.\r\n\r\n```typespec\r\n@route(\"/pets\") op list(): Pet[];\r\n```\r\n\r\nRoute path parameters are declared using `{}`. Providing `@path` on the model property with the matching name is optional.\r\n\r\n```typespec\r\n@route(\"/pets/{petId}\") op get(petId: string): Pet;\r\n// or explicit @path\r\n@route(\"/pets/{petId}\") op get(@path petId: string): Pet;\r\n```\r\n\r\nRoute can be specified on a parent namespace or interface. In that case all the operations, interfaces and namespaces underneath will be prefixed with it.\r\n\r\n```typespec\r\n@route(\"/store\")\r\nnamespace PetStore {\r\n  op hello(): void; // `/store`\r\n  @route(\"ping\") op ping(): void; // `/store/ping`\r\n\r\n  @route(\"/pets\")\r\n  interface Pets {\r\n    list(): Pet[]; // `/store/pets`\r\n    @route(\"{petId}\") read(petId: string): Pet; // `/store/pets/{petId}`\r\n  }\r\n}\r\n```\n\n## Path and query parameters\n\nModel properties and parameters which should be passed as path and query parameters use the `@path` and `@query` parameters respectively. Let's modify our list operation to support pagination, and add a read operation to our Pets resource:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): Pet[];\r\n  op read(@path petId: int32): Pet;\r\n}\r\n```\r\n\r\nPath parameters are appended to the URL unless a substitution with that parameter name exists on the resource path. For example, we might define a sub-resource using the following TypeSpec. Note how the path parameter for our sub-resource's list operation corresponds to the substitution in the URL.\r\n\r\n```typespec\r\n@route(\"/pets/{petId}/toys\")\r\nnamespace PetToys {\r\n  op list(@path petId: int32): Toy[];\r\n}\r\n```\n\n## Request & response bodies\n\nRequest and response bodies can be declared explicitly using the `@body` decorator. Let's add an endpoint to create a pet. Let's also use this decorator for the responses, although this doesn't change anything about the API.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[];\r\n  };\r\n  op read(@path petId: int32): {\r\n    @body pet: Pet;\r\n  };\r\n  @post\r\n  op create(@body pet: Pet): {};\r\n}\r\n```\r\n\r\nNote that in the absence of explicit `@body`:\r\n\r\n1. The set of parameters that are not marked @header, @query, or @path form the request body.\r\n2. The set of properties of the return model that are not marked @header or @statusCode form the response body.\r\n3. If the return type is not a model, then it defines the response body.\r\n\r\nThis is how we were able to return Pet and Pet[] bodies without using @body for list and read. We can actually write\r\ncreate in the same terse style by spreading the Pet object into the parameter list like this:\r\n\r\nSee also [metadata](./operations.md#metadata) for more advanced details.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @post\r\n  op create(...Pet): {};\r\n}\r\n```\n\n## Headers\n\nModel properties and parameters that should be passed in a header use the `@header` decorator. The decorator takes the header name as a parameter. If a header name is not provided, it is inferred from the property or parameter name. Let's add `etag` support to our pet store's read operation.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[];\r\n  };\r\n  op read(@path petId: int32, @header ifMatch?: string): {\r\n    @header eTag: string;\r\n    @body pet: Pet;\r\n  };\r\n  @post\r\n  op create(@body pet: Pet): {};\r\n}\r\n```\n\n## Status codes\n\n**Default behavior:**\r\n\r\n- `4xx,5xx` if response is marked with `@error`\r\n- `200` otherwise\r\n\r\n**Configure:**\r\n\r\nUse the `@statusCode` decorator on a property to declare a status code for a response. Generally, setting this to just `int32` isn't particularly useful. Instead, use number literal types to create a discriminated union of response types. Let's add status codes to our responses, and add a 404 response to our read endpoint.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @error\r\n  model Error {\r\n    code: string;\r\n  }\r\n\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[]; // statusCode: 200 Implicit\r\n  };\r\n  op read(@path petId: int32, @header ifMatch?: string): {\r\n    @statusCode statusCode: 200;\r\n    @header eTag: string;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n  };\r\n  op create(@body pet: Pet): {\r\n    @statusCode statusCode: 204;\r\n  } | Error; //statusCode: 4xx,5xx as Error use `@error` decorator\r\n}\r\n```\n\n## Content type\n\n[See the documentation of Content-Types](./content-types.md).\n\n## Built-in response shapes\n\nSince status codes are so common for REST APIs, TypeSpec comes with some built-in types for common status codes so you don't need to declare status codes so frequently.\r\n\r\nThere is also a `Body<T>` type, which can be used as a shorthand for { @body body: T } when an explicit body is required.\r\n\r\nLets update our sample one last time to use these built-in types:\r\n\r\n```typespec\r\nmodel ETag {\r\n  @header eTag: string;\r\n}\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): OkResponse & Body<Pet[]>;\r\n  op read(@path petId: int32, @header ifMatch?: string): (OkResponse &\r\n    Body<Pet> &\r\n    ETag) | NotFoundResponse;\r\n  @post\r\n  op create(...Pet): NoContentResponse;\r\n}\r\n```\r\n\r\nNote that the default status code is 200 for non-empty bodies and 204 for empty bodies. Similarly, explicit `Body<T>` is not required when T is known to be a model. So the following terser form is equivalent:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): Pet[];\r\n  op read(@path petId: int32, @header ifMatch?: string): (Pet & ETag) | NotFoundResponse;\r\n  @post\r\n  op create(...Pet): {};\r\n}\r\n```\r\n\r\nFinally, another common style is to make helper response types that are\r\nshared across a larger service definition. In this style, you can be\r\nentirely explicit while also keeping operation definitions concise.\r\n\r\nFor example, we could write :\r\n\r\n```typespec\r\nmodel ListResponse<T> {\r\n  ...OkResponse;\r\n  ...Body<T[]>;\r\n}\r\n\r\nmodel ReadSuccessResponse<T> {\r\n  ...OkResponse;\r\n  ...ETag;\r\n  ...Body<T>;\r\n}\r\n\r\nalias ReadResponse<T> = ReadSuccessResponse<T> | NotFoundResponse;\r\n\r\nmodel CreateResponse {\r\n  ...NoContentResponse;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): ListResponse<Pet>;\r\n  op read(@path petId: int32, @header ifMatch?: string): ReadResponse<Pet>;\r\n  @post\r\n  op create(...Pet): CreateResponse;\r\n}\r\n```\n\n## Handling files\n\n`@typespec/http` provides a special model [`TypeSpec.Http.File`](../http/reference/data-types.md#file-typespechttpfile) for handling file uploads and downloads in HTTP operations. When working with files, emitters need to implement special handling due to their binary nature.\r\n\r\nFor more information about HTTP file bodies and how to configure them, see [the documentation on Files][http-files].\r\n\r\n[http-files][./files.md]\n\n### Basic File Handling\n\nWhen the model `Http.File` (or any model that extends `Http.File`) is the _exact_ body of an HTTP request, emitters **must** treat this model with special care:\r\n\r\n- The `contentType` property should be used as the value for the `Content-Type` header in requests and vice-versa for responses.\r\n- The `filename` property should be used in the `Content-Disposition` header in responses and vice-versa for multipart requests (`filename` cannot be sent in a non-multipart HTTP request because `Content-Disposition` is only valid for responses and multipart requests).\r\n- The file content should be treated as the raw body of the request/response without any additional parsing.\r\n\r\nSee [`isHttpFile`](../http/reference/js-api/functions/isHttpFile.md) for a helper that emitters/libraries can use to detect instances of `Http.File`.\n\n### Examples\n\n#### Uploading and downloading files\r\n\r\n```typespec\r\n// Uploading and downloading\r\n@route(\"/files\")\r\ninterface Files {\r\n  @post\r\n  upload(@body file: Http.File): {\r\n    @statusCode statusCode: 201;\r\n  };\r\n\r\n  download(@path fileId: string): Http.File;\r\n}\r\n```\r\n\r\n#### Custom file types\r\n\r\nIf you want to declare specific types of files that are accepted, but still treated as binary files, declare the content types by extending the `Http.File` model and overriding the `contentType` field.\r\n\r\n```typespec\r\n// Custom file type for images\r\nmodel ImageFile extends Http.File {\r\n  contentType: \"image/jpeg\" | \"image/png\" | \"image/gif\";\r\n}\r\n\r\n@route(\"/images\")\r\ninterface Images {\r\n  @post\r\n  upload(@body image: ImageFile): {\r\n    @statusCode statusCode: 201;\r\n  };\r\n\r\n  download(@path imageId: string): ImageFile;\r\n}\r\n```\n\n## Automatic visibility\n\nThe `@typespec/rest` library understands [Lifecycle Visibility](../../language-basics/visibility.md#lifecycle-visibility) and provides functionality for emitters to apply visibility transforms based on whether a model represents a request or response and on HTTP method usage as detailed in the table below.\r\n\r\nSee [handling visibility and metadata](../../extending-typespec/emitter-metadata-handling.md) for details on how to incorporate this information into an emitter implementation.\r\n\r\n| Modifier         | Visible in           |\r\n| ---------------- | -------------------- |\r\n| Lifecycle.Read   | Any response         |\r\n| Lifecycle.Query  | GET or HEAD request  |\r\n| Lifecycle.Create | POST or PUT request  |\r\n| Lifecycle.Update | PATCH or PUT request |\r\n| Lifecycle.Delete | DELETE request       |\r\n\r\nThis allows a single logical TypeSpec model to be used as in the following example:\r\n\r\n```typespec\r\nmodel User {\r\n  name: string;\r\n  @visibility(Lifecycle.Read) id: string;\r\n  @visibility(Lifecycle.Create) password: string;\r\n}\r\n\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(@path id: string, ...User): User;\r\n  @get get(@path id: string): User;\r\n}\r\n```\r\n\r\nThere is a single logical user entity represented by the single TypeSpec type `User`, but the HTTP payload for this entity varies based on context. When returned in a response, the `id` property is included, but when sent in a request, it is not. Similarly, the `password` property is only included in create requests, but not present in responses.\r\n\r\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(Lifecycle.Read)` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas.\n\nincluded in create requests, but not present in responses.\r\n\r\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(Lifecycle.Read)` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas. For example, `@visibility(Lifecycle.Create)` applied to a model property of a type named Widget will generate a `WidgetCreate` schema.\r\n\r\nAnother emitter such as one generating client code can see and preserve a single logical type and deal with these HTTP payload differences by means other than type proliferation.\r\n\r\nModeling with logical entities rather than HTTP-specific shapes also keeps the TypeSpec spec decoupled from HTTP and REST and can allow the same spec to be used with multiple protocols.\n\n## Metadata\n\nin terms of the logical entity:\r\n\r\n```typespec\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(...User): User;\r\n}\r\n```\r\n\r\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\r\n\r\n```\r\nPOST /Users/TypeSpecFan42 HTTP/1.1\r\nContent-Type: application/json\r\n{\r\n  \"name\": \"TypeSpec Fan\",\r\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\r\n}\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\n{\r\n  name: \"TypeSpec Fan\",\r\n  id: \"TypeSpecFan42\r\n}\r\n```\n\nThe properties that designate content for the HTTP envelope (`@header`, `@path`, `@query`, `@statusCode`) rather than the content in an HTTP payload are often called \"metadata\".\r\n\r\nMetadata is determined to be applicable or inapplicable based on the context that it is used:\r\n\r\n| Context       | Applicability       |\r\n| ------------- | ------------------- |\r\n| `@query`      | request only        |\r\n| `@path`       | request only        |\r\n| `@statusCode` | response only       |\r\n| `@header`     | request or response |\r\n\r\nAdditionally metadata that appears in an array element type always inapplicable.\r\n\r\nWhen metadata is deemed \"inapplicable\", for example, if a `@path` property is seen in a response, it becomes part of the payload instead unless the [@includeInapplicableMetadataInPayload](./reference/decorators.md#@TypeSpec.Http.includeInapplicableMetadataInPayload) decorator is used and given a value of `false`.\r\n\r\nThe handling of metadata applicability furthers the goal of keeping a single logical model in TypeSpec. For example, this defines a logical `User` entity that has a name, ID and password, but further annotates that the ID is sent in the HTTP path and the HTTP body in responses. Also, using automatic visibility as before, we further indicate that the password is only present in create requests.\r\n\r\n```typespec\r\nmodel User {\r\n  name: string;\r\n  @path id: string;\r\n  @visibility(Lifecycle.Create) password: string;\r\n}\r\n```\r\n\r\nThen, we can write operations in terms of the logical entity:\r\n\r\n```typespec\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(...User): User;\r\n}\r\n```\r\n\r\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\r\n\r\n```\r\nPOST /Users/TypeSpecFan42 HTTP/1.1\r\nContent-Type: application/json\r\n{\r\n  \"name\": \"TypeSpec Fan\",\r\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\r\n}\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\n{\n\n### Visibility vs. Metadata applicability\n\nMetadata properties are filtered based on visibility as [described above](#automatic-visibility). This is done independently before applicability is considered. If a a metadata property is not visible then it is neither part of the envelope nor the HTTP payload, irrespective of its applicability.\n\n### Nested metadata\n\nMetadata properties are not required to be top-level. They can also be nested deeper in a parameter or response model type. For example:\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: {\r\n    @header example: string;\r\n  };\r\n  name: string;\r\n}\r\n```\r\n\r\nNote that nesting in this sense does not require the use of anonymous models. This is equivalent:\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: Headers;\r\n  name: string;\r\n}\r\nmodel Headers {\r\n  @header example: string;\r\n}\r\n```\r\n\r\nIn the event that this nesting introduces duplication, then the least nested property with a given name is preferred and the duplicate metadata properties are ignored.\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: {\r\n    @header example: string; // preferred\r\n    more: {\r\n      @header example: string; // ignored\r\n    };\r\n  };\r\n}\r\n```\n\n## Emitter resources\n\nSee [Handling metadata and visibility in emitters for REST API](../../extending-typespec/emitter-metadata-handling.md) for information on how to handle metadata applicability and automatic visibility in a custom emitter.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step05.md\n- document_title: 5. Defining standard resource operations\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step05\n- document_content: # getstarted#azure-core#step05.md\n\n# 5. Defining standard resource operations\n\nThe `Azure.Core` namespace provides a variety of [standard lifecycle operations](https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/interfaces#Azure.Core.ResourceOperations) for resource types. These operations adhere to the requirements of the [Azure REST API Guidelines](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md).\n\n## Operation interface definition\n\nTo define standard operations for a resource type, create an instance of the `ResourceOperations` interface that is tailored to your service. Here's an example:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = Azure.Core.ResourceOperations<ServiceTraits>;\r\n```\r\n\r\nIn this example:\r\n\r\n1. `ServiceTraits` is defined as the intersection of three trait model types available in `Azure.Core`. Learn more about interface-level service traits [here](https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/data-types).\r\n2. `Operations` is defined as the instantiation of `Azure.Core.ResourceOperations` with the service trait types you defined.\r\n\r\n> **Note:** The name `Operations` is used for convenience, but you might define multiple aliases of `ResourceOperation` for a single service to apply different customizations for some operations. You might choose a more explicit name like `StandardOperations`.\r\n\r\nNext, we'll use this interface alias to define the standard resource operations we need.\n\n## Resource operations definition\n\nWe'll define the standard set of CRUD (Create, Read, Update, Delete) operations typically needed for a resource type in an Azure service. We'll do this by defining an interface called `Widgets`:\r\n\r\n```typespec\r\ninterface Widgets {\r\n  /** Fetch a Widget by name. */\r\n  getWidget is Operations.ResourceRead<Widget>;\r\n\r\n  /** Creates or updates a Widget. */\r\n  createOrUpdateWidget is Operations.ResourceCreateOrUpdate<Widget>;\r\n\r\n  /** Delete a Widget. */\r\n  deleteWidget is Operations.ResourceDelete<Widget>;\r\n\r\n  /** List Widget resources. */\r\n  listWidgets is Operations.ResourceList<Widget>;\r\n}\r\n```\r\n\r\n> **Note:** It's not necessary to define your resource operations inside of an `interface`. You can also define them in a sub-namespace of your service or inside the top-level namespace of the service. However, it's a best practice in TypeSpec to use `interface` to encapsulate the operations of a particular resource type.\r\n\r\nThe `Widget` interface defines the following standard lifecycle operations:\r\n\r\n- `ResourceRead<TResource>`: Defines a \"read\" operation for a single resource instance.\r\n- `ResourceCreateOrUpdate<TResource>`: Defines an \"upsert\" operation which either creates or updates an instance of the resource type depending on whether it already exists.\r\n- `ResourceDelete<TResource>`: Defines a \"delete\" operation to delete a specific instance of the resource.\r\n- `ResourceList<TResource>`: Defines an operation that lists all instances of the resource type.\r\n\r\n> **Note:** There are both instantaneous and long-running versions of \"create\", \"update\", and \"delete\" operations for resource types depending on what you need for a particular resource!\r\n\r\nThese operations will all exist under the route path `/widgets/{widgetName}`, with the list operation generating the path `/widgets`.\n\n## Error response customization\n\nIf your service needs to use a custom error response type for all resource operations (which is uncommon), you may pass in a custom error response type to the `ResourceOperations` interface:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\n/** A custom error response type. */\r\n@error\r\nmodel ErrorResponse {\r\n  /** The error code. */\r\n  code: string;\r\n\r\n  /** The error message. */\r\n  message: string;\r\n}\r\n\r\nalias Operations = Azure.Core.ResourceOperations<ServiceTraits, ErrorResponse>;\r\n```\r\n\r\nYou can also reuse the standard Azure Core error types with minor customizations:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\n/** A custom error type. */\r\nmodel Error is Azure.Core.Foundations.Error {\r\n  /** The environment where the error occurred. */\r\n  environment: string;\r\n}\r\n\r\nalias Operations = Azure.Core.ResourceOperations<\r\n  ServiceTraits,\r\n  Azure.Core.Foundations.ErrorResponseBase<Error>\r\n>;\r\n```\n", "latency": 9.600893259048462, "response_length": 903}
{"query": "title: RP modeling Q: Resource Properties required on PUT but Optional on PATCH\n\nquestion: Hello\nTypeSpec Discussion\n,\nPer Resource Provier Contract( https://armwiki.azurewebsites.net/api_contracts/guidelines/rpc.html) PATCH should support partial updates.\nI have a few properties that are required on a PUT, but unfortunately this means that the PATCH experience is quite terrible in the Management SDKs generated using MTG.\nHow can I express properties as optional in PATCH while keeping them required in PUT? I'd really love some kind of OptionalPatch  annotation.\nI would prefer avoiding defining the resource properties twice as that creates bloat in API docs and SDKs. Is that the preferred approach for now?\nAlternatively, I could mark the properties all as optional and rely on server side validation logic (rather than RPaaS builtin swagger validation), but that's also not ideal.", "ground_truth": "Use ArmCustomPatchAsync<Scheduler, Scheduler> to see if it generates a different SDK shape.\nChange the TypeSpec model as suggested by Pan Shao to avoid a swagger breaking change.\nUse @parameterVisibility(Lifecycle.Update) for the update operation.\nThe default PATCH template will implement best practices for ARM PATCH APIs once the linked issue is resolved in the next sprint.", "response": "To express properties as required in PUT but optional in PATCH, TypeSpec provides a mechanism using the `@visibility` decorator. This decorator allows you to specify how properties behave in different lifecycle operations, such as Create (PUT), Update (PATCH), and Read (GET). For your use case, you can mark properties with `@visibility(Lifecycle.Create)` to make them required in PUT operations but optional in PATCH operations. This avoids duplicating resource properties and ensures a clean API design.\n\nHeres an example:\n\n```typespec\nmodel MyResourceProperties {\n  /** Required in PUT but optional in PATCH */\n  @visibility(Lifecycle.Create)\n  requiredProperty: string;\n\n  /** Always optional */\n  optionalProperty?: string;\n}\n\nmodel MyResource is TrackedResource<MyResourceProperties> {\n  @segment(\"myResources\")\n  @key(\"resourceName\")\n  @path\n  name: string;\n}\n```\n\nIn this example:\n- `requiredProperty` is required in PUT operations but optional in PATCH operations.\n- `optionalProperty` is always optional.\n\nThis approach avoids duplicating resource properties and leverages TypeSpec's visibility framework for lifecycle-specific constraints.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#http#reference#data-types.md\n- document_title: Data types\n- document_link: https://typespec.io/docs/libraries/http/reference/data-types\n- document_content: # libraries#http#reference#data-types.md\n\n# Data types\n\n## TypeSpec.Http\n\n### `AcceptedResponse` {#TypeSpec.Http.AcceptedResponse}\n\nThe request has been accepted for processing, but processing has not yet completed.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.AcceptedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `202` | The status code. |\n\n### `ApiKeyAuth` {#TypeSpec.Http.ApiKeyAuth}\n\nAn API key is a token that a client provides when making API calls. The key can be sent in the query string:\r\n\r\n```\r\nGET /something?api_key=abcdef12345\r\n```\r\n\r\nor as a request header\r\n\r\n```\r\nGET /something HTTP/1.1\r\nX-API-Key: abcdef12345\r\n```\r\n\r\nor as a cookie\r\n\r\n```\r\nGET /something HTTP/1.1\r\nCookie: X-API-KEY=abcdef12345\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ApiKeyAuth<Location, Name>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                 |\r\n| -------- | --------------------------- |\r\n| Location | The location of the API key |\r\n| Name     | The name of the API key     |\r\n\r\n#### Properties\r\n\r\n| Name | Type                            | Description |\r\n| ---- | ------------------------------- | ----------- |\r\n| type | `TypeSpec.Http.AuthType.apiKey` |             |\r\n| in   | `Location`                      |             |\r\n| name | `Name`                          |             |\n\n### `AuthorizationCodeFlow` {#TypeSpec.Http.AuthorizationCodeFlow}\n\nAuthorization Code flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.AuthorizationCodeFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                             | Description                       |\r\n| ---------------- | ------------------------------------------------ | --------------------------------- |\r\n| type             | `TypeSpec.Http.OAuth2FlowType.authorizationCode` | authorization code flow           |\r\n| authorizationUrl | `string`                                         | the authorization URL             |\r\n| tokenUrl         | `string`                                         | the token URL                     |\r\n| refreshUrl?      | `string`                                         | the refresh URL                   |\r\n| scopes?          | `string[]`                                       | list of scopes for the credential |\n\n### `BadRequestResponse` {#TypeSpec.Http.BadRequestResponse}\n\nThe server could not understand the request due to invalid syntax.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.BadRequestResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `400` | The status code. |\n\n### `BasicAuth` {#TypeSpec.Http.BasicAuth}\n\nBasic authentication is a simple authentication scheme built into the HTTP protocol.\r\nThe client sends HTTP requests with the Authorization header that contains the word Basic word followed by a space and a base64-encoded string username:password.\r\nFor example, to authorize as demo / `p@55w0rd` the client would send\r\n\r\n```\r\nAuthorization: Basic ZGVtbzpwQDU1dzByZA==\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.BasicAuth\r\n```\r\n\r\n#### Properties\r\n\r\n| Name   | Type                          | Description         |\r\n| ------ | ----------------------------- | ------------------- |\r\n| type   | `TypeSpec.Http.AuthType.http` | Http authentication |\r\n| scheme | `\"Basic\"`                     | basic auth scheme   |\n\n### `BearerAuth` {#TypeSpec.Http.BearerAuth}\n\nBearer authentication (also called token authentication) is an HTTP authentication scheme that involves security tokens called bearer tokens.\r\nThe name Bearer authentication can be understood as give access to the bearer of this token. The bearer token is a cryptic string, usually generated by the server in response to a login request.\r\nThe client must send this token in the Authorization header when making requests to protected resources:\r\n\r\n```\r\nAuthorization: Bearer <token>\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.BearerAuth\r\n```\r\n\r\n#### Properties\r\n\r\n| Name   | Type                          | Description         |\r\n| ------ | ----------------------------- | ------------------- |\r\n| type   | `TypeSpec.Http.AuthType.http` | Http authentication |\r\n| scheme | `\"Bearer\"`                    | bearer auth scheme  |\n\n### `Body` {#TypeSpec.Http.Body}\n\nDefines a model with a single property of the given type, marked with `@body`.\r\n\r\nThis can be useful in situations where you cannot use a bare type as the body\r\nand it is awkward to add a property.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.Body<Type>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name | Description                              |\r\n| ---- | ---------------------------------------- |\r\n| Type | The type of the model's `body` property. |\r\n\r\n#### Properties\r\n\r\n| Name | Type   | Description |\r\n| ---- | ------ | ----------- |\r\n| body | `Type` |             |\n\n### `ClientCredentialsFlow` {#TypeSpec.Http.ClientCredentialsFlow}\n\nClient credentials flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ClientCredentialsFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type                                             | Description                       |\r\n| ----------- | ------------------------------------------------ | --------------------------------- |\r\n| type        | `TypeSpec.Http.OAuth2FlowType.clientCredentials` | client credential flow            |\r\n| tokenUrl    | `string`                                         | the token URL                     |\r\n| refreshUrl? | `string`                                         | the refresh URL                   |\r\n| scopes?     | `string[]`                                       | list of scopes for the credential |\n\n### `ConflictResponse` {#TypeSpec.Http.ConflictResponse}\n\nThe request conflicts with the current state of the server.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ConflictResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `409` | The status code. |\n\n### `CookieOptions` {#TypeSpec.Http.CookieOptions}\n\nCookie Options.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.CookieOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type     | Description         |\r\n| ----- | -------- | ------------------- |\r\n| name? | `string` | Name in the cookie. |\n\n### `CreatedResponse` {#TypeSpec.Http.CreatedResponse}\n\nThe request has succeeded and a new resource has been created as a result.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.CreatedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `201` | The status code. |\n\n### `File` {#TypeSpec.Http.File}\n\nbelow for more information.\r\n\r\nNOTE: The `filename` and `contentType` fields are optional. Furthermore, the default location of `filename`\r\n(`Content-Disposition: <disposition>; filename=<filename>`) is only valid in HTTP responses and multipart payloads. If\r\nyou wish to send the `filename` in a request, you must use HTTP metadata decorators to describe the location of the\r\n`filename` field. You can combine the metadata decorators with `@visibility` to control when the `filename` location\r\nis overridden, as shown in the examples below.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.File<ContentType, Contents>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name        | Description                                                                                    |\r\n| ----------- | ---------------------------------------------------------------------------------------------- |\r\n| ContentType | The allowed media (MIME) types of the file contents.                                           |\r\n| Contents    | The type of the file contents. This can be `string`, `bytes`, or any scalar that extends them. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n// Download a file\r\n@get op download(): File;\r\n\r\n// Upload a file\r\n@post op upload(@bodyRoot file: File): void;\r\n```\r\n\r\n```tsp\r\n// Upload and download files in a multipart payload\r\nop multipartFormDataUpload(\r\n  @multipartBody fields: {\r\n    files: HttpPart<File>[];\r\n  },\r\n): void;\r\n\r\nop multipartFormDataDownload(): {\r\n  @multipartBody formFields: {\r\n    files: HttpPart<File>[];\r\n  };\r\n};\r\n```\r\n\r\n```tsp\r\n// Declare a custom type of text file, where the filename goes in the path\r\n// in requests.\r\nmodel SpecFile extends File<\"application/json\" | \"application/yaml\", string> {\r\n  // Provide a header that contains the name of the file when created or updated\r\n  @header(\"x-filename\")\r\n  @path\r\n  filename: string;\r\n}\r\n\r\n@get op downloadSpec(@path name: string): SpecFile;\r\n\r\n@post op uploadSpec(@bodyRoot spec: SpecFile): void;\r\n```\r\n\r\n```tsp\n\nA file in an HTTP request, response, or multipart payload.\r\n\r\nFiles have a special meaning that the HTTP library understands. When the body of an HTTP request, response,\r\nor multipart payload is _effectively_ an instance of `TypeSpec.Http.File` or any type that extends it, the\r\noperation is treated as a file upload or download.\r\n\r\nWhen using file bodies, the fields of the file model are defined to come from particular locations by default:\r\n\r\n- `contentType`: The `Content-Type` header of the request, response, or multipart payload (CANNOT be overridden or changed).\r\n- `contents`: The body of the request, response, or multipart payload (CANNOT be overridden or changed).\r\n- `filename`: The `filename` parameter value of the `Content-Disposition` header of the response or multipart payload\r\n  (MAY be overridden or changed).\r\n\r\nA File may be used as a normal structured JSON object in a request or response, if the request specifies an explicit\r\n`Content-Type` header. In this case, the entire File model is serialized as if it were any other model. In a JSON payload,\r\nit will have a structure like:\r\n\r\n```\r\n{\r\n  \"contentType\": <string?>,\r\n  \"filename\": <string?>,\r\n  \"contents\": <string, base64>\r\n}\r\n```\r\n\r\nThe `contentType` _within_ the file defines what media types the data inside the file can be, but if the specification\r\ndefines a `Content-Type` for the payload as HTTP metadata, that `Content-Type` metadata defines _how the file is\r\nserialized_. See the examples below for more information.\r\n\r\nNOTE: The `filename` and `contentType` fields are optional. Furthermore, the default location of `filename`\r\n(`Content-Disposition: <disposition>; filename=<filename>`) is only valid in HTTP responses and multipart payloads. If\r\nyou wish to send the `filename` in a request, you must use HTTP metadata decorators to describe the location of the\r\n`filename` field. You can combine the metadata decorators with `@visibility` to control when the `filename` location\n\n{\r\n    files: HttpPart<File>[];\r\n  };\r\n};\r\n```\r\n\r\n```tsp\r\n// Declare a custom type of text file, where the filename goes in the path\r\n// in requests.\r\nmodel SpecFile extends File<\"application/json\" | \"application/yaml\", string> {\r\n  // Provide a header that contains the name of the file when created or updated\r\n  @header(\"x-filename\")\r\n  @path\r\n  filename: string;\r\n}\r\n\r\n@get op downloadSpec(@path name: string): SpecFile;\r\n\r\n@post op uploadSpec(@bodyRoot spec: SpecFile): void;\r\n```\r\n\r\n```tsp\r\n// Declare a custom type of binary file\r\nmodel ImageFile extends File {\r\n  contentType: \"image/png\" | \"image/jpeg\";\r\n  @path filename: string;\r\n}\r\n\r\n@get op downloadImage(@path name: string): ImageFile;\r\n\r\n@post op uploadImage(@bodyRoot image: ImageFile): void;\r\n```\r\n\r\n````tsp\r\n// Use a File as a structured JSON object. The HTTP library will warn you that the File will be serialized as JSON,\r\n// so you should suppress the warning if it's really what you want instead of a binary file upload/download.\r\n\r\n// The response body is a JSON object like `{\"contentType\":<string?>,\"filename\":<string?>,\"contents\":<string>}`\r\n@get op downloadTextFileJson(): {\r\n  @header contentType: \"application/json\",\r\n  @body file: File<\"text/plain\", string>,\r\n};\r\n\r\n// The request body is a JSON object like `{\"contentType\":<string?>,\"filename\":<string?>,\"contents\":<base64>}`\r\n@post op uploadBinaryFileJson(\r\n  @header contentType: \"application/json\",\r\n  @body file: File<\"image/png\", bytes>,\r\n): void;\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| contentType? | `ContentType` | The allowed media (MIME) types of the file contents.<br /><br />In file bodies, this value comes from the `Content-Type` header of the request or response. In JSON bodies,<br />this value is serialized as a field in the response.<br /><br />NOTE: this is not _necessarily_ the same as the `Content-Type` header of the request or response, but<br />it will be for file bodies.\n\n): void;\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| contentType? | `ContentType` | The allowed media (MIME) types of the file contents.<br /><br />In file bodies, this value comes from the `Content-Type` header of the request or response. In JSON bodies,<br />this value is serialized as a field in the response.<br /><br />NOTE: this is not _necessarily_ the same as the `Content-Type` header of the request or response, but<br />it will be for file bodies. It may be different if the file is serialized as a JSON object. It always refers to the<br />_contents_ of the file, and not necessarily the way the file itself is transmitted or serialized. |\r\n| filename? | `string` | The name of the file, if any.<br /><br />In file bodies, this value comes from the `filename` parameter of the `Content-Disposition` header of the response<br />or multipart payload. In JSON bodies, this value is serialized as a field in the response.<br /><br />NOTE: By default, `filename` cannot be sent in request payloads and can only be sent in responses and multipart<br />payloads, as the `Content-Disposition` header is not valid in requests. If you want to send the `filename` in a request,<br />you must extend the `File` model and override the `filename` property with a different location defined by HTTP metadata<br />decorators. |\r\n| contents | `Contents` | The contents of the file.<br /><br />In file bodies, this value comes from the body of the request, response, or multipart payload. In JSON bodies,<br />this value is serialized as a field in the response. |\n\n### `ForbiddenResponse` {#TypeSpec.Http.ForbiddenResponse}\n\nAccess is forbidden.\r\n```typespec\r\nmodel TypeSpec.Http.ForbiddenResponse\r\n````\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `403` | The status code. |\n\n### `HeaderOptions` {#TypeSpec.Http.HeaderOptions}\n\nHeader options.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.HeaderOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| -------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| name?    | `string`  | Name of the header when sent over HTTP.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\r\n| explode? | `boolean` | Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)<br /><br />\\| Style \\| Explode \\| Primitive value = 5 \\|\n\n|\r\n| explode? | `boolean` | Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)<br /><br />\\| Style \\| Explode \\| Primitive value = 5 \\| Array = [3, 4, 5] \\| Object = {\"role\": \"admin\", \"firstName\": \"Alex\"} \\|<br />\\| ------ \\| ------- \\| ------------------- \\| ----------------- \\| ----------------------------------------------- \\|<br />\\| simple \\| false \\| `5   ` \\| `3,4,5` \\| `role,admin,firstName,Alex` \\|<br />\\| simple \\| true \\| `5` \\| `3,4,5` \\| `role=admin,firstName=Alex` \\| |\n\n### `HttpPart` {#TypeSpec.Http.HttpPart}\n\n```typespec\r\nmodel TypeSpec.Http.HttpPart<Type, Options>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name    | Description |\r\n| ------- | ----------- |\r\n| Type    |             |\r\n| Options |             |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `HttpPartOptions` {#TypeSpec.Http.HttpPartOptions}\n\n```typespec\r\nmodel TypeSpec.Http.HttpPartOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type     | Description                                 |\r\n| ----- | -------- | ------------------------------------------- |\r\n| name? | `string` | Name of the part when using the array form. |\n\n### `ImplicitFlow` {#TypeSpec.Http.ImplicitFlow}\n\nImplicit flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ImplicitFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                    | Description                       |\r\n| ---------------- | --------------------------------------- | --------------------------------- |\r\n| type             | `TypeSpec.Http.OAuth2FlowType.implicit` | implicit flow                     |\r\n| authorizationUrl | `string`                                | the authorization URL             |\r\n| refreshUrl?      | `string`                                | the refresh URL                   |\r\n| scopes?          | `string[]`                              | list of scopes for the credential |\n\n### `Link` {#TypeSpec.Http.Link}\n\n```typespec\r\nmodel TypeSpec.Http.Link\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type              | Description |\r\n| ----------- | ----------------- | ----------- |\r\n| target      | `url`             |             |\r\n| rel         | `string`          |             |\r\n| attributes? | `Record<unknown>` |             |\n\n### `LocationHeader` {#TypeSpec.Http.LocationHeader}\n\nThe Location header contains the URL where the status of the long running operation can be checked.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.LocationHeader\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type     | Description                                                                                         |\r\n| -------- | -------- | --------------------------------------------------------------------------------------------------- |\r\n| location | `string` | The Location header contains the URL where the status of the long running operation can be checked. |\n\n### `MovedResponse` {#TypeSpec.Http.MovedResponse}\n\nThe URL of the requested resource has been changed permanently. The new URL is given in the response.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.MovedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type     | Description                                                                                         |\r\n| ---------- | -------- | --------------------------------------------------------------------------------------------------- |\r\n| statusCode | `301`    | The status code.                                                                                    |\r\n| location   | `string` | The Location header contains the URL where the status of the long running operation can be checked. |\n\n### `NoAuth` {#TypeSpec.Http.NoAuth}\n\nThis authentication option signifies that API is not secured at all.\r\nIt might be useful when overriding authentication on interface of operation level.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NoAuth\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type                            | Description |\r\n| ---- | ------------------------------- | ----------- |\r\n| type | `TypeSpec.Http.AuthType.noAuth` |             |\n\n### `NoContentResponse` {#TypeSpec.Http.NoContentResponse}\n\nThere is no content to send for this request, but the headers may be useful.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NoContentResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `204` | The status code. |\n\n### `NotFoundResponse` {#TypeSpec.Http.NotFoundResponse}\n\nThe server cannot find the requested resource.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NotFoundResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `404` | The status code. |\n\n### `NotModifiedResponse` {#TypeSpec.Http.NotModifiedResponse}\n\nThe client has made a conditional request and the resource has not been modified.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NotModifiedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `304` | The status code. |\n\n### `OAuth2Auth` {#TypeSpec.Http.OAuth2Auth}\n\nOAuth 2.0 is an authorization protocol that gives an API client limited access to user data on a web server.\r\n\r\nOAuth relies on authentication scenarios called flows, which allow the resource owner (user) to share the protected content from the resource server without sharing their credentials.\r\nFor that purpose, an OAuth 2.0 server issues access tokens that the client applications can use to access protected resources on behalf of the resource owner.\r\nFor more information about OAuth 2.0, see oauth.net and RFC 6749.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.OAuth2Auth<Flows, Scopes>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name   | Description                                                                                                                                      |\r\n| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Flows  | The list of supported OAuth2 flows                                                                                                               |\r\n| Scopes | The list of OAuth2 scopes, which are common for every flow from `Flows`. This list is combined with the scopes defined in specific OAuth2 flows. |\r\n\r\n#### Properties\r\n\r\n| Name          | Type                            | Description |\r\n| ------------- | ------------------------------- | ----------- |\r\n| type          | `TypeSpec.Http.AuthType.oauth2` |             |\r\n| flows         | `Flows`                         |             |\r\n| defaultScopes | `Scopes`                        |             |\n\n### `OkResponse` {#TypeSpec.Http.OkResponse}\n\nThe request has succeeded.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.OkResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `200` | The status code. |\n\n### `OpenIdConnectAuth` {#TypeSpec.Http.OpenIdConnectAuth}\n\nOpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0 protocol and supported by some OAuth 2.0 providers, such as Google and Azure Active Directory.\r\nIt defines a sign-in flow that enables a client application to authenticate a user, and to obtain information (or \"claims\") about that user, such as the user name, email, and so on.\r\nUser identity information is encoded in a secure JSON Web Token (JWT), called ID token.\r\nOpenID Connect defines a discovery mechanism, called OpenID Connect Discovery, where an OpenID server publishes its metadata at a well-known URL, typically\r\n\r\n```http\r\nhttps://server.com/.well-known/openid-configuration\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.OpenIdConnectAuth<ConnectUrl>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description |\r\n| ---------- | ----------- |\r\n| ConnectUrl |             |\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                   | Description                                                 |\r\n| ---------------- | -------------------------------------- | ----------------------------------------------------------- |\r\n| type             | `TypeSpec.Http.AuthType.openIdConnect` | Auth type                                                   |\r\n| openIdConnectUrl | `ConnectUrl`                           | Connect url. It can be specified relative to the server URL |\n\n### `PasswordFlow` {#TypeSpec.Http.PasswordFlow}\n\nResource Owner Password flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.PasswordFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type                                    | Description                       |\r\n| ----------- | --------------------------------------- | --------------------------------- |\r\n| type        | `TypeSpec.Http.OAuth2FlowType.password` | password flow                     |\r\n| tokenUrl    | `string`                                | the token URL                     |\r\n| refreshUrl? | `string`                                | the refresh URL                   |\r\n| scopes?     | `string[]`                              | list of scopes for the credential |\n\n### `PatchOptions` {#TypeSpec.Http.PatchOptions}\n\nOptions for PATCH operations.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.PatchOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name                 | Type      | Description                                                                                                       |\r\n| -------------------- | --------- | ----------------------------------------------------------------------------------------------------------------- |\r\n| implicitOptionality? | `boolean` | If set to `false`, disables the implicit transform that makes the body of a<br />PATCH operation deeply optional. |\n\n### `PathOptions` {#TypeSpec.Http.PathOptions}\n\n```typespec\r\nmodel TypeSpec.Http.PathOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name           | Type                                                      | Description                                                                                                                                                                                                                                  |\r\n| -------------- | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| name?          | `string`                                                  | Name of the parameter in the uri template.                                                                                                                                                                                                   |\r\n| explode?       | `boolean`                                                 | When interpolating this parameter in the case of array or object expand each value using the given style.<br />Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3) |\r\n| style?         | `\"simple\" \\| \"label\" \\| \"matrix\" \\| \"fragment\" \\| \"path\"` | Different interpolating styles for the path parameter.<br />- `simple`: No special encoding.<br />- `label`: Using `.` separator.<br />- `matrix`: `;` as separator.<br />- `fragment`: `#` as separator.<br />- `path`: `/` as separator.   |\r\n| allowReserved? | `boolean`                                                 | When interpolating this parameter do not encode reserved characters.<br />Equivalent of adding `+` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)                                      |\n\n### `PlainData` {#TypeSpec.Http.PlainData}\n\nProduces a new model with the same properties as T, but with `@query`,\r\n`@header`, `@body`, and `@path` decorators removed from all properties.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.PlainData<Data>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name | Description                            |\r\n| ---- | -------------------------------------- |\r\n| Data | The model to spread as the plain data. |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `QueryOptions` {#TypeSpec.Http.QueryOptions}\n\nQuery parameter options.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.QueryOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| -------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| name?    | `string`  | Name of the query when included in the url.\n\n|\r\n| name?    | `string`  | Name of the query when included in the url.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| explode? | `boolean` | If true send each value in the array/object as a separate query parameter.<br />Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)<br /><br />\\| Style \\| Explode \\| Uri Template \\| Primitive value id = 5 \\| Array id = [3, 4, 5] \\| Object id = {\"role\": \"admin\", \"firstName\": \"Alex\"} \\|<br />\\| ------ \\| ------- \\| -------------- \\| ---------------------- \\| ----------------------- \\| -------------------------------------------------- \\|<br />\\| simple \\| false \\| `/users{?id}` \\| `/users?id=5` \\| `/users?id=3,4,5` \\| `/users?id=role,admin,firstName,Alex` \\|<br />\\| simple \\| true \\| `/users{?id*}` \\| `/users?id=5` \\| `/users?id=3&id=4&id=5` \\| `/users?role=admin&firstName=Alex` \\| |\n\n### `Response` {#TypeSpec.Http.Response}\n\nDescribes an HTTP response.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.Response<Status>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name   | Description                      |\r\n| ------ | -------------------------------- |\r\n| Status | The status code of the response. |\r\n\r\n#### Properties\r\n\r\n| Name       | Type     | Description |\r\n| ---------- | -------- | ----------- |\r\n| statusCode | `Status` |             |\n\n### `UnauthorizedResponse` {#TypeSpec.Http.UnauthorizedResponse}\n\nAccess is unauthorized.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.UnauthorizedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `401` | The status code. |\n\n### `ApiKeyLocation` {#TypeSpec.Http.ApiKeyLocation}\n\nDescribes the location of the API key\r\n\r\n```typespec\r\nenum TypeSpec.Http.ApiKeyLocation\r\n```\r\n\r\n| Name   | Value | Description                  |\r\n| ------ | ----- | ---------------------------- |\r\n| header |       | API key is a header value    |\r\n| query  |       | API key is a query parameter |\r\n| cookie |       | API key is found in a cookie |\n\n### `AuthType` {#TypeSpec.Http.AuthType}\n\nAuthentication type\r\n\r\n```typespec\r\nenum TypeSpec.Http.AuthType\r\n```\r\n\r\n| Name          | Value | Description    |\r\n| ------------- | ----- | -------------- |\r\n| http          |       | HTTP           |\r\n| apiKey        |       | API key        |\r\n| oauth2        |       | OAuth2         |\r\n| openIdConnect |       | OpenID connect |\r\n| noAuth        |       | Empty auth     |\n\n### `OAuth2FlowType` {#TypeSpec.Http.OAuth2FlowType}\n\nDescribes the OAuth2 flow type\r\n\r\n```typespec\r\nenum TypeSpec.Http.OAuth2FlowType\r\n```\r\n\r\n| Name              | Value | Description             |\r\n| ----------------- | ----- | ----------------------- |\r\n| authorizationCode |       | authorization code flow |\r\n| implicit          |       | implicit flow           |\r\n| password          |       | password flow           |\r\n| clientCredentials |       | client credential flow  |\n\n### `LinkHeader` {#TypeSpec.Http.LinkHeader}\n\n```typespec\r\nscalar TypeSpec.Http.LinkHeader\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-type.md\n- document_title: ARM Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type\n- document_content: # howtos#arm#resource-type.md\n\n# ARM Resource Types\n\n## Introductions\n\nIntroduction\r\nResources are the basic building blocks of Azure. When a customer interacts with Azure through the Control Plane (ARM), they generally will be reading (GET), writing (PUT/PATCH), deleting (DELETE) or performing actions upon (POST) one or more resources. Each resource is managed by a particular Resource Provider, so we uniquely identify a resource by its 'fully-qualified type'. Some well-known examples of types are Microsoft.Compute/virtualMachines, or Microsoft.Network/networkSecurityGroups/securityRules. See Resource Ids for a more in-depth breakdown of the id and associated fields.\r\n\r\nIn order to give customers a consistent API when working with many different Resource Providers, and to allow ARM to understand and manage resources programmatically, ARM requires each RP to follow a set of contracts for resource management, defined in the ARM RPC.\n\n## ARM Resource Terminology\n\nThe most important distinction between resources is between _Tracked_ and _Proxy_ resources. Tracked resources are resources in which all of the metadata is maintained in Azure Resource Manager. Tracked Resources can be targeted to specific regions, and are generally the best choice for most top-level resources. Azure Resource Manager maintains data about Tracked Resources, and generally will handle many implementation details or operations on the resource. See [RPC: Resource API Reference](https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md) for further information on the contract for Tracked Resources.\r\n\r\nProxy resources are resources in which only a portion of resource metadata is tracked in ARM. Generally, these model resources maintained on other systems, or that resource-providers want to track themselves. Generally, resource providers must implement most of the operations for Proxy resources. Tenant, Extension, and child resources are usually modeled as Proxy resources.\r\n\r\nThere is a good discussion on making the choice between Tracked and Proxy Resources in the armwiki discussion [Tracked vs Proxy Resources](https://armwiki.azurewebsites.net/rp_onboarding/tracked_vs_proxy_resources.html)\n\n## Choosing a Resource Type\n\n- The large majority of resources have their metadata tracked by ARM, can be assigned to regions, and are contained inside a resource group in a subscription, for ease of management and billing. These are called [Tracked Resources](#tracked-resources).\r\n- Some resources may need to have scope across an entire customer tenant, or may need to have a single instance across all customer subscriptions. These are called [tenant resources](#tenant-resources).\r\n- Some kinds of resources may augment or alter the functionality of resources or resource containers provided by other resource-providers. For example, policy or RBAC rules may be applied to any resource or resource container. These resources are called [extension resources](#extension-resource).\r\n- Some resources are complex and naturally break down into one or more components that are separately configurable, but an integral part of the larger resource (for example, a virtual network resource may contain many separately configurable subnets). These component resources are called [child resources](#child-resource).\r\n- Rarely, some resources may need to apply across a subscription, or have a single instance in a customer subscription, these are called [subscription-based resources](#subscription-based-resource).\r\n- Rarer still, some resources may need to apply across a specific region, or have a single instance in a region, these are called [location-based resources](#location-based-resource).\r\n- In some cases, there can only be one instance of a resource at a specific scope - this is rare, but happens most frequently in tenant, child, and location resources. In typespec, you will need to specify that the resource is a singleton, and the resource manager tools will automatically apply the correct pattern for singleton resources (using the recommended resource name 'default')\n\n## Modeling Resources in TypeSpec\n\nResources are modeled in TypeSpec by choosing a _base resource type_, defining _rp-specific properties_, and optionally mixing in _standard envelope properties_. Later sections document [how to model resource operations](./resource-operations.md). The following sections discuss usage of each of the base resource types. Later sections discuss [designing rp-specific properties](#designing-resource-specific-properties) and [adding standard ARM envelope properties](#adding-optional-standard-envelope-properties).\n\n### Tracked Resources\n\nTracked resources use the `TrackedResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tracked Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Tenant Resources\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@tenantResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tenant Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Extension Resource\n\nExtension resources use the `ExtensionResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is ExtensionResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Extension Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Child Resource\n\nChild resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@parentResource(EmployeeResource)\r\nmodel JobResource is ProxyResource<JobProperties> {\r\n  /** The job name */\r\n  @segment(\"jobs\")\r\n  @key(\"jobName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@parentResource`: designates the model type for the parent of this child resource. The resource identifier for this resource will be prepended with the resource identity of the parent.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Child Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Subscription-based Resource\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@subscriptionResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@subscriptionResource`: designates this resource as being a cross-subscription resource, with scope across all resource groups in the subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Subscription Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Location-based Resource\n\nLocation-based resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@locationResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@locationResource`: designates this resource as being a cross-location resource, with scope across a location within a subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Location Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Singleton Resource\n\nSingleton resources can use any resource base type, but most often use `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@singleton\r\n@tenantResource\r\nmodel EmployeeAgreementResource is ProxyResource<EmployeeAgreementProperties> {\r\n  /** The default employee agreement, applying to all employees. */\r\n  @segment(\"employeeAgreements\")\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@singleton`: indicates that there can only be one of the resources in the resource container (in this case, only one instance in the customer tenant).\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource. For a singleton, the name value will always be the same.\r\n`@segment(employeeAGreements)`: provides the resource type name for this resource.\r\n`@key`: provides the parameter name for the name of the resource in operations that use this resource - this will not be a settable value for singleton resources.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Singleton Resources [in the Singleton sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/arm-scenarios/singleton/main.tsp#L29).\n\n## Designing Resource-specific Properties\n\nEach resource model consists of two distinct parts\r\n\r\n- An outer _envelope_ of information that provides metadata for optional standardized ARM functionality, like entity-tags and managed identities, and is processed by Azure Resource Manager.\r\n- An inner set of properties that are specific to the resource and are defined by the resource provider.\r\n\r\nModifying the ARM envelope is discussed in later sections on [mixing in standard ARM envelope add-ons](#adding-optional-standard-envelope-properties).\r\n\r\nThe inner _rp-specific property bag_ consists of all of the properties that the RP needs to manage about the resource. Properties should be completely specified, should not duplicate properties from the _ARM envelope_, and may consist of simple types, arrays, or other complex properties.\r\n\r\nHere is an example of a property bag for the `EmployeeResource` resource.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n\r\nunion EmployeeProvisioningState {\r\n  string,\r\n\r\n  /** The resource create request has been accepted */\r\n  Accepted: \"Accepted\",\r\n\r\n  /** The resource is being provisioned */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is updating */\r\n  Updating: \"Updating\",\r\n\r\n  /** Resource has been created. */\r\n  Succeeded: \"Succeeded\",\r\n\r\n  /** Resource creation failed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\n\nfailed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n\r\nmodel EmployeeProperties {\r\n  /** The current title of the employee */\r\n  title: string;\r\n\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  level: EmployeeLevel;\r\n\r\n  @visibility(Lifecycle.Read)\r\n  employeeId: int32;\r\n\r\n  biography?: string = \"No biography provided\";\r\n  colleagues: EmployeeResourceId[];\r\n  employmentHistory: Job[];\r\n\r\n  @visibility(Lifecycle.Create)\r\n  password: Password;\r\n\r\n  provisioningState?: EmployeeProvisioningState;\r\n}\r\n```\r\n\r\n`EmployeeProperties` specifies the employee metadata that the RP needs to track and manage. Notice that the model uses built-in scalar types like `string` and `int32`, new types built from scalar types with added constraints, like `Password` and `EmployeeLevel`, enumerations of values, like `EmployeeProvisioningState`, and complex types. The individual components of this model are described below.\r\n\r\nNote that _documentation comments on all models and model properties are required when specs are checked in_. Here they are omitted for clarity. The TypeSpec compiler and TypeSpec IDE tooling will emit warning diagnostics if you emit required documentation, and about most of the ARM rules described in this document.\n\n### The `provisioningState` Property for Tracked Resources\n\nAll Tracked Resources are required to implement a 'provisioningState' property in their rp-specific property bag. This is used by ARM and some ARM clients to track the provisioning state of a resource as it is created and deleted. At minimum, the provisioning state must contain the standard terminal values that ARM is looking for. There are contained in the `ResourceProvisioningState` enumeration in the Azure.ResourceManager library. If RPs have other provisioning states they would like to track, they can define their own provisioning state enum, and mix in the value, as shown in the sample above, or they may simply use the standard provisioning state as shown in the sample below:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  ...ResourceProvisioningState;\r\n}\r\n```\r\n\r\nNote that this example uses the spread operator `...`, which allows you to simply include the properties from a source model in the target model you are constructing. This has the effect of copying the properties of the source model and their decorations into the target model, without creating any nominal inheritance relationship.\r\n\r\nAlternately, this is also equivalent:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  /** The status of the last provisioning operation performed on the resource. */\r\n  @visibility(Lifecycle.Read)\r\n  provisioningState?: ResourceProvisioningState;\r\n}\r\n```\n\n### Required and Optional properties and Property Defaults\n\nIn the examples, note that some model properties use the optional operator `?` after the property name, like `biography?` and some do not, like `title`. Property names using the `?` are optional properties, which may or may not be provided in the request body for CreateOrUpdate (PUT) requests. Property names without the `?` are required properties, which must be provided in PUT requests. The exception is that properties that have 'readOnly' visibility do not appear in requests, but may be required or optional in responses.\r\n\r\nAlso note that optional properties may specify defaults, as with `biography?: string = \"No biography provided\"`. The default indicates the value that will be recorded on the server if no value is sent by the client.\n\n### Defining Custom Types\n\nIn the sample, new constrained scalar types and new complex model types are defined and used inside the _rp-specific property bag_. TypeSpec allows you to define custom types for use in your specification.\r\n\r\nYou will often want to define scalar types or properties that have constraints. For example, numeric values may be constrained to have a certain minimum or maximum, strign values may be constrained to follow a particular regex pattern, and so on. Whenever these constrained types are used in your spec, the constraints will be transmitted to the usage.\r\n\r\nThe example creates a numeric type with minimum and maximum constraints:\r\n\r\n```typespec\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n```\r\n\r\nThis defines 'EmployeeLevel' as an integer value between 50 and 70. The example also defines a complex type used in an array:\r\n\r\n```typespec\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n```\r\n\r\nMode details on what to consider when using complex types in an array are discussed in the section on [modeling arrays of complex types](#modeling-arrays-of-complex-types).\n\n### Using Resource identifiers\n\nIt is often the case that resources need to reference other resources to provide specific pieces of functionality. For example, resources may need to reference a storage account to use for storing user data, or a NIC to attach to a Network. The `Azure.ResourceManager` library defines a `ResourceIdentifier` template that allows you to easily represent references to resources in your API. The template allows you to specify one or more acceptable resource types, automatically designating the value as a resource reference, and providing the appropriate pattern validation - which helps in generating better code, better ARM templates, and better documentation for your API.\r\n\r\n```typespec\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\nscalar NetworkInterfaceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/networkInterfaces\",\r\n    },\r\n    {\r\n      type: \"Microsoft.ClassicNetwork/networkInterfaces\",\r\n    }\r\n  ]>;\r\n```\r\n\r\nThe `NetworkInterfaceId example shows how to allow multiple resource types in a reference.\n\n### Property Visibility and Other Constraints\n\nThe sample uses the `@visibility` decorator to indicate how the resource definition is used in requests to PUT and PATCH operations, and in responses to PUT, PATCH, GET, and LIST operations.\r\n\r\nThis table shows how visibility is used to determine whether a property is used in requests and responses:\r\n\r\n| Visibility           | In Create Request? | In Patch Request/ Updateable in PUT | In Responses | Sample                                         |\r\n| -------------------- | ------------------ | ----------------------------------- | ------------ | ---------------------------------------------- |\r\n| None                 | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create, update | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create         | Yes                | No                                  | Yes          | resource location                              |\r\n| read, update         | No                 | Yes                                 | Yes          | Properties only settable after creation (keys) |\r\n| create, update       | Yes                | Yes                                 | No           | Secrets (e.g. password)                        |\r\n| read                 | No                 | No                                  | Yes          | Calculated properties, e.g. provisioningState  |\r\n| update               | No                 | Yes                                 | No           | Secrets (e.g. keys)                            |\r\n| create               | Yes                | No                                  | No           | Secrets (e.g. user-defined password)           |\n\n### Modeling Arrays of Complex Types\n\nFinally, when your _rp-specific property bag_ contains an array of complex properties, there are a few important considerations:\r\n\r\n- The complex properties in an array must have a key property - this means a property named 'name' or 'id' that uniquely identifies the property in the array. The TypeSpec tools will emit a diagnostic if you omit this.\r\n- ARM resources must be fully loaded in memory, so there are limits to the size of arrays in the properties of a resource. If your array is not strictly bounded, you should consider modeling the array property as a [child resource](#child-resource)\r\n- Updating the contents of arrays can be difficult, and result in data loss under simultaneous updates, especially as Json-Merge-Patch is not widely supported in ARM update operations. If users will frequently need to update the contents of arrays, you should consider modeling as a [child resource](#child-resource).\n\n## Adding Optional Standard Envelope Properties\n\nIn addition to the resource-specific property bag, a resource may configure on or more standard ARM features through the use of standard properties in the _ARM Envelope_. Standard features configured in the envelope include:\r\n\r\n- **Managed Identity**: Associating a managed identity with the resource to authorize actions taken by this resource on other resources.\r\n- **SKU**: A standard mechanism for configuring levels of service for a resource.\r\n- **Plan**: A standard mechanism for configuring MarketPlace billing plans for a resource.\r\n- **ETags**: A standard mechanism for managing concurrent operations over the resource.\r\n- **ResourceKind**: A standard mechanism for specifying a type of user experience in the portal.\n\n### Managed Identity\n\nStandard configuration for ARM support of both SystemAssigned and UserAssigned Managed Service Identity (MSI)\r\n\r\n- If a resource allows both generated (SystemAssigned) and user-assigned (UserAssigned) Managed Identity, use the spread (...) operator to include the standard ManagedServiceIdentity envelope property. This will allow users to manage any ManagedServiceIdentity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedServiceIdentity;\r\n  }\r\n  ```\r\n\r\n- If a resource allows only generated (SystemAssigned) Managed Identity, use the spread operator (...) to include the `ManagedSystemAssignedIdentity` standard envelope property in the resource definition. This will allow users to manage the SystemAssigned identity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedSystemAssignedIdentity;\r\n  }\r\n  ```\r\n\r\nFor more information, see [Managed Service Identity Support](https://eng.ms/docs/products/arm/rpaas/msisupport)\n\n### SKU\n\nStandard support for setting a SKU-based service level for a resource. To enable SKU support, add the `ResourceSku` enevelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceSku;\r\n}\r\n```\r\n\r\nFor more information, see [SKU Support](https://eng.ms/docs/products/arm/rpaas/skusupport)\n\n### ETags\n\nIndicator that entity-tag operation concurrency support is enabled for this resource. To enable ETags, add the `EntityTag` envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...EntityTag;\r\n}\r\n```\r\n\r\nFor more information, and limitations on RPaaS concurrency support, see [RPaaS ETag Support](https://eng.ms/docs/products/arm/rpaas/etags)\n\n### Plan\n\nSupport for marketplace billing configuration for the resource. To enable `Plan` support, add the `ResourcePlan` standard envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourcePlan;\r\n}\r\n```\r\n\r\nSee [MarketPlace Third Party Billing SUpport](https://eng.ms/docs/products/arm/rpaas/custom_billing)\n\n### ResourceKind\n\nSupport for certain kinds of portal user experiences based on the kind of resource. To include 'Kind' in the resource defintion, add the `ResourceKind` standard envelope property.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceKind;\r\n}\r\n```\r\n\r\nFor more information on user experiences in the Azure Portal, see [Portal Support](https://eng.ms/docs/products/arm/rpaas/portal/gettingstarted)\n\n### ManagedBy\n\nSupport for management of this resource by other resources. To add 'ManagedBy' support to the resource, add the `ManagedBy` envelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ManagedBy;\r\n}\r\n```\r\n\r\nFor more information on supporting 'ManagedBy', see [ManagedBy API Contract](https://eng.ms/docs/products/arm/api_contracts/managedby)\n\n## Reference\n\n[Fundamentals - ARM Wiki](https://armwiki.azurewebsites.net/fundamentals/overview.html)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-operations.md\n- document_title: ARM Resource Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations\n- document_content: # howtos#arm#resource-operations.md\n\n# ARM Resource Operations\n\n## Recommended and Required Operations\n\n### TrackedResource\n\n| Operation             | Recommended | Required | TypeSpec Representation                                          |\r\n| --------------------- | ----------- | -------- | ---------------------------------------------------------------- |\r\n| GET                   | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                              |\r\n| CreateOrUpdate (PUT)  | Yes         | Yes      | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`    |\r\n| Tags Update (PATCH)   | No          | Yes\\*    | `update is ArmResourceTagsPatchSync<Resource>;`                  |\r\n| Full Update (PATCH)   | Yes         | No\\*     | `update is ArmCustomPatchSync<Resource, PatchRequest>;`          |\r\n| Delete                | Yes         | Yes      | `delete is ArmResourceDeleteSync<Resource>;`                     |\r\n| List by ResourceGroup | Yes         | Yes      | `listByResourceGroup is ArmResourceListByParent<Resource>;`      |\r\n| List by Subscription  | Yes         | Yes      | `listBySubscription is ArmResourceListBySubscription<Resource>;` |\r\n\r\n\\* Arm requires that, at minimum, a TrackedResource can update Tags. A Full PATCH of all updateable resource properties is preferred.\n\n### Proxy Resource\n\n| Operation            | Recommended | Required | TypeSpec Representation                                       |\r\n| -------------------- | ----------- | -------- | ------------------------------------------------------------- |\r\n| GET                  | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                           |\r\n| CreateOrUpdate (PUT) | Yes         | No\\*     | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;` |\r\n| Update (PATCH)       | Yes         | No       | `update is ArmCustomPatchSync<Resource, PatchRequest>;`       |\r\n| Delete               | Yes         | No\\*     | `delete is ArmResourceDeleteSync<Resource>;`                  |\r\n| List by Parent       | Yes         | Yes      | `listByParent is ArmResourceListByParent<Resource>;`          |\r\n\r\n\\* Note that, if a resource implements Create, it is highly recommended that it implement delete as well, and vice-versa.\n\n## TypeSpec Operation Templates and Interface Templates\n\nTypeSpec provide operation templates that describe the request and response of standard resource operations. A description of the options available for each resource template, and how to choose which one is described in the sections below.\n\n### Synchronous and Asynchronous APIs\n\nCreateOrUpdate (PUT), Update (Patch), Delete, and Action (POST) operations over a resource may\n\n### Determining Which Resource Properties Appear in Lifecycle Operations\n\nBy default, any property that occurs in your resource model will also appear in the response to GET, PUT, PATCH, and LIST operations, and in the request for PUT and PATCH operations. This does not work for all properties. Some properties are calculated by the service and cannot be directly set by PUT or PATCH (provisioningState, modification date, etc.). Some properties can only be set when creating a resource, but always appear in responses (e.g. 'location'). Some properties can only be set when updating the resource, and appear in responses. Some properties (rarely) may be settable when updating the resource via PUT or PATCH. To allow using a common resource model, but applying these `views` of resources to determine how the resource appear in request and responses, TypeSpec provides the visibility framework. You can see a complete representation of available visibilities in the table [on Property Visibility and Other Constraints](./resource-type.md#property-visibility-and-other-constraints). The sections below outline some common scenarios for designing properties with your operations in mind.\r\n\r\n#### Properties That Are Never Directly Set by the User\r\n\r\nIt is common to have properties that are calculated by the service or otherwise not directly set by the user, examples include timestamps, dates, values that are only set by specific actions (on/off, enabled/disabled, provisioningState). You want to make sure that these properties are marked so that they will appear in responses and not requests. this is done using the `@visibility(Lifecycle.Read)` decorator instance:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Read)\r\nprovisioningState: ProvisioningState;\r\n```\n\n### Resource Get Operations\n\nGet is the operation to retrieve a single resource TypeSpec provides a single operation template for GET:\r\n\r\n```typespec\r\nop get is ArmResourceRead<MyResource>;\r\n```\r\n\r\n- **get**: The name of the operation passed on to clients.\r\n- **Resource**: A reference to your resource type.\n\n### Resource CreateOrUpdate Operations (PUT)\n\nThe CreateOrUpdate operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\n- Simple resources may have synchronous PUT operations. If a resource may need to perform additional checks, creation of other dependent resources, or the like, it is best to use an Asynchronous API.\r\n- Asynchronous operations for PUT occur when the RP needs to perform additional validaton actions, create other resources, or perform other tasks as part of resource creation or update that can cause the operation to take longer than the length of a single request/response.\r\n\r\n| Operation        | TypeSpec                                                          |\r\n| ---------------- | ----------------------------------------------------------------- |\r\n| Synchronous PUT  | `createOrUpdate is ArmResourceCreateOrReplaceSync<ResourceType>`  |\r\n| Asynchronous PUT | `createOrUpdate is ArmResourceCreateOrReplaceAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `createOrUpdate` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being created (or updated)\n\n### Resource Update Operations (PATCH)\n\nPATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\r\nThe ArmCustomPatch\\* templates take the resource type and your custom PATCH request type as parameters.\n\nARM Requires that all `Tracked` resources implement PATCH for ARM tags, which are contained in the envelope of every `TrackedResource`. ARM recommends that you also allow PATCH of other envelope properties and resource-specific properties. Unless marked with a specific visibility, any property in your rp-specific properties will be automatically included in the PATCH schema.\r\n\r\nTypeSpec Provides both Synchronous and Asynchronous PATCH Operations, and allows you to specify a PATCH for Resource tags only, a PATCH for all updateable properties, or a custom patch. Generally, you should choose the patch for all updateable properties, unless you have a very good reason for choosing another PATCH operation.\r\n\r\n| Operation Description      | TypeSpec                                                                                                                                   |\r\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Sync TagsOnly PATCH        | `update is ArmTagsPatchSync<ResourceType>`                                                                                                 |\r\n| Async TagsOnly PATCH       | `update is ArmTagsPatchAsync<ResourceType>`                                                                                                |\r\n| Sync All Properties PATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\n\n### Resource Delete Operations (DELETE)\n\nThe Delete operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\nSimple resources may have synchronous DELETE operations. If a resource needs to clean up other resources or do other validations as part of delete, the delete operation may need to be asynchronous.\r\n\r\n| Operation           | TypeSpec                                                  |\r\n| ------------------- | --------------------------------------------------------- |\r\n| Synchronous Delete  | `delete is ArmResourceDeleteSync<ResourceType>`           |\r\n| Asynchronous Delete | `delete is ArmResourceDeleteWithoutOkAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `delete` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being deleted.\n\n### Resource List Operations (GET)\n\nArm Resource list operations return a list of Tracked or Proxy Resources at a particular scope.\r\n\r\n- All resources _should_ include a list operation at its immediate parent scope\r\n  - For **Tenant Resources**, this is at the tenant scope\r\n  - For **Extension Resources**, this is at the scope of resources they are extending\r\n  - For **Tracked Resources**, this is at the resource group scope.\r\n  - For **Child Resources**, this is at the scope of the resource parent.\r\n- Tracked resources _must_ include a list operation at the Subscription level.\r\n\r\n| Operation          | TypeSpec                                                            |\r\n| ------------------ | ------------------------------------------------------------------- |\r\n| ListByParent       | `listByWidget is ArmResourceListByParent<ResourceType>`             |\r\n| ListBySubscription | `listBySubscription is ArmResourceListBySubscription<ResourceType>` |\n\n### Resource Actions (POST)\n\nCustom actions define any operations over resources outside the simple CRUDL (Create< Read, Update, Delete, List) or lifecycle operations described above. Any operation that returns data that is not made up of resources, performs a prescriptive state change on the resource (cycling power, upgrading, etc.), or any operation that does not fit into the operations described above should be modelled as a _resource action_. Examples of resource actions include:\r\n\r\n- Operations that manage credentials associated with a resource\r\n- Operations that calculate statistics about resources\r\n- Operations that make specific state changes to resources (power cycle, upgrade, etc.)\r\n\r\n#### Actions that take input and output\r\n\r\nOperations that manage credentials are a good example fo this category. TypeSpec defines synchronous and asynchronous templates for actions that consume and produce information.\r\n\r\n| Operation                    | TypeSpec                                                                       |\r\n| ---------------------------- | ------------------------------------------------------------------------------ |\r\n| Synchronous Resource Action  | `updateCredentials is ArmResourceActionSync<ResourceType, Request, Response>`  |\r\n| Asynchronous Resource Action | `updateCredentials is ArmResourceActionAsync<ResourceType, Request, Response>` |\r\n\r\nParameters to the template are the ResourceType, the model for the operation Request body, and the model for the operation Response body.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- |\n\nbody.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- | ------------------------------------------------------------------------------------- |\r\n| Synchronous NoContent Action  | `updateCredentials is ArmResourceActionNoContentSync<ResourceType, Request>`          |\r\n| Asynchronous NoContent Action | `updateCredentials is ArmResourceActionNoResponseContentAsync<ResourceType, Request>` |\r\n\r\nParameters to the template are the ResourceType and the model for the operation Request body.\n\n### Actions that take no input but produce output (data retrieval actions)\n\nSome operations return data or paged lists of data. TypeSpec does not yet provide templates for these kinds of actions, but here are two templates that you could reuse in your own specification, described in the next section of the document:\r\n\r\n- [Synchronous Resource List Actions](#synchronous-list-action)\r\n- [Asynchronous List Action](#asynchronous-list-action)\n\n### Check Name Operations\n\nSome services provide operations to check name availability, either location-specific (locally) or globally, especially if a resource name must be globally unique (such as when an exposed endpoint uses the resource name in the url).\r\n\r\n| Operation                      | TypeSpec                                                                                             |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------- |\r\n| Global Name Availability Check | `checkGlobalName is checkGlobalNameAvailability<TRequest, TResponse, TAdditionalParams>`             |\r\n| Local Name Availability Check  | `checkLocalName is checkLocalNameAvailability<TRequest, TResponse, TAdditionalParams>`               |\r\n| Custom Name Availability Check | `customNameCheck is checkNameAvailability<TScopeParameters, TRequest, TResponse, TAdditionalParams>` |\r\n\r\n`checkGlobalNameAvailability` and `checkLocalNameAvailability` have default values that allow them to be used without specifying any template parameters. `checkNameAvailability` requires the `TScopeParameters` template parameter, which describes the parameters which define the scope of the name check request. For reference, the following table shows the `TScopeParameters` for the standard templates:\r\n\r\n| Operation                      | Scope Parameters                                                       |\r\n| ------------------------------ | ---------------------------------------------------------------------- |\r\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\r\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\n\n## Writing Custom Operations\n\nTypeSpec operation templates provide a simple mechanism for producing the most common operation patterns in ARM, using best practices and conforming to ARM RPC guidelines. However, sometimes a service has special requirements for operations that fall outside these boundaries. The `Azure.ResourceManager.Foundations` namespace provides lower level building blocks that can be used to produce operations and operation templates.\r\n\r\nThe building blocks are described in the sections below:\n\n### ARM Response Types\n\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\r\n\r\n| Model                               | Code | Description                                   |\r\n| ----------------------------------- | ---- | --------------------------------------------- |\r\n| `ArmResponse<T>`                    | 200  | Base Arm 200 response.                        |\r\n| `ArmResourceUpdatedResponse<T>`     | 200  | Resource updated (PUT) response.              |\r\n| `ArmResourceCreatedResponse<T>`     | 201  | Resource created response for an lro.         |\r\n| `ArmResourceCreatedSyncResponse<T>` | 201  | Resource created synchronously.               |\r\n| `ArmAcceptedResponse`               | 202  | Base Arm Accepted response.                   |\r\n| `ArmNoContentResponse`              | 204  | Base Arm No Content response.                 |\r\n| `ArmDeletedResponse`                | 200  | Resource deleted response.                    |\r\n| `ArmDeleteAcceptedResponse`         | 202  | Resource deletion in progress response.       |\r\n| `ResourceListResult<T>`             | 200  | Return a list of resource with ARM pagination |\r\n| `ErrorResponse`                     | x    | Error response                                |\n\n### Common Operation Parameters\n\nThere are a number of model types which specify common parameters which are used in resource type operations:\r\n\r\n| Model                           | In           | Description                                                 |\r\n| ------------------------------- | ------------ | ----------------------------------------------------------- |\r\n| `ApiVersionParameter`           | query        | api-version parameter                                       |\r\n| `SubscriptionIdParameter`       | path         | Subscription ID path parameter                              |\r\n| `ResourceGroupNameParameter`    | path         | Resource Group Name path parameter                          |\r\n| `ResourceInstanceParameters<T>` | path & query | Identity parameters for a resource, with api-version        |\r\n| `ResourceParentParameters<T>`   | path & query | Identity Parameters for listing by parent, with api-version |\r\n| `ResourceUriParameter`          | path         | Resource uri path parameter for Extension resources         |\r\n| `OperationIdParameter`          | path         | Operation Id path parameter                                 |\n\n### Synchronous List Action\n\nHere is a sample template for resource list actions that return synchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionSync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionSync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n\n### Asynchronous List Action\n\nHere is a sample template for resource list actions that return asynchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionAsync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ArmAcceptedResponse | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionAsync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n", "latency": 10.888192892074585, "response_length": 1152}
{"query": "title: How to properly update the TypeSpec environment?\n\nquestion: I tried inferring steps from the various installation documents but just managed to break my environment and have no idea how to fix it.\nI saw a recent post where it was said to run `npm install -g @typespec/compiler` to get the latest (0.66) but it looks like it did not work for me. My compiler is still 0.64.\n```\nNORTHAMERICA+darkoa@darkoa-ws MINGW64 /d/Dev/Projects/git/github/azure-rest-api-specs-pr (RPSaaSMaster)\n$ npm install -g @typespec/compiler\nchanged 268 packages in 11s\n34 packages are looking for funding\nrun `npm fund` for details\nNORTHAMERICA+darkoa@darkoa-ws MINGW64 /d/Dev/Projects/git/github/azure-rest-api-specs-pr (RPSaaSMaster)\n$ tsp compile specification/deviceupdate/DeviceUpdate.Edge.Management/\nTypeSpec compiler v0.64.0\nDiagnostics were reported during compilation:\n```\nI get a bunch of errors, although we made no changes recently. I am guessing those changes were made by the TypeSpec team and I am also guessing that if I manage to properly update tools, the errors should go away.\nSo, is there a single document that describes how to update the environment to the latest?", "ground_truth": "Dependency Installation: The team decided that dependencies should be installed using npm ci in the spec repo. 1 2 3\nGlobal CLI Access: The team agreed that running npm install -g @typespec/compiler only upgrades the global version for CLI access, not for local dependencies.\nDocumentation Reference: The team decided to use the documentation link shared by Mike Harder for managing the environment in the spec repo.\nWarnings Clarification: The team clarified that the warnings received are related to SDK emitters configuration and are not errors.\nFeedback Process: The team decided that feedback for the TypeSpecValidation rule should be directed to the Shanghai team via an issue in azure-rest-api-specs assigned to \"wanlwanl\".", "response": "To properly update your TypeSpec environment and ensure you are using the latest version of the TypeSpec compiler, follow these steps:\n\n1. **Verify Node.js Version**: Ensure you have Node.js 18.3 LTS or later installed. You can check your version by running:\n   ```sh\n   node -v\n   ```\n\n2. **Update TypeSpec Compiler**: Run the following command to update the TypeSpec compiler globally:\n   ```sh\n   npm install -g @typespec/compiler\n   ```\n\n3. **Clean Install Dependencies**: If you are working within a project directory, run:\n   ```sh\n   npm ci\n   ```\n   This ensures a clean installation of dependencies specified in your `package.json` file.\n\n4. **Verify Installed Version**: After updating, confirm the installed version of the TypeSpec compiler by running:\n   ```sh\n   tsp --version\n   ```\n   Ensure it matches the latest version (e.g., 0.66).\n\n5. **Check Configuration**: Ensure your `tspconfig.yaml` file is correctly configured. Refer to the [example tspconfig.yaml](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml) for guidance.\n\n6. **Compile and Address Errors**: Run the following command to compile your TypeSpec project:\n   ```sh\n   tsp compile [path-to-your-specification]\n   ```\n   Address any errors or warnings reported during compilation.\n\nIf you continue to encounter issues, consult the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) or file an issue in the [TypeSpec Azure GitHub repo](https://github.com/azure/typespec-azure/issues).", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n", "latency": 13.195518970489502, "response_length": 1750}
{"query": "title: Changing TCGC generated names\n\nquestion: I generated a Go package that can't build because it has conflicting definitions for a type. I didn't find any reference to this type in the input TSP, so I looked at the TCGC output. There I found a model with the name in question and isGeneratedName: true. So, it appears TCGC generated a name for this model and the Go emitter dutifully wrote a type having that name. Unfortunately, Go SDK guidelines mandate using the same name for a response envelope type, so the emitter wrote a conflicting type.\nI want to continue following the Go SDK guidelines, so I need to change TCGC's generated name. Can I do this in TSP (I don't see anything I can apply @clientName to)?", "ground_truth": "BatchCertificate has some properties that has only CREATE visibility, so typespec http lib will create a type without such properties to be the http operation response. since this type is created by http lib, not defined in the spec, we have no way to locate it.\nsince most languages do not care about visibility, i think there are two ways to workaround the problem:\n1. change the spec to add @body directly, see line 833 of TypeSpec Azure Playground:\n```\ngetCertificate is ReadOperation<\n{\n@doc(\"The algorithm used to derive the thumbprint parameter. This must be sha1.\")\n@path\nthumbprintAlgorithm: string;\n@doc(\"The thumbprint of the Certificate to get.\")\n@path\nthumbprint: string;\n@doc(\"An OData $select clause.\")\n@query\n@clientName(\"select\")\n$select?: string[];\n},\n{@body body: BatchCertificate}\n>;\n```\n2. i'm working on a tcgc change to switch back to the original model for http response body with visibility. after that, the response will changed to BatchCertificate with CREATE properties, not the created GetCertificateResponse model. see pr [[tcgc] ignore visibility when finding response type if it is anonymous model by tadelesh  Pull Request #2402  Azure/typespec-azure](https://teams.microsoft.com/l/message/19:906c1efbbec54dc8949ac736633e6bdf@thread.skype/1742279390520?tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47&groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&parentMessageId=1741990183297&teamName=Azure%20SDK&channelName=TypeSpec%20Discussion&createdTime=1742279390520)", "response": "Yes, you can change the generated name in TypeSpec using the `@clientName` decorator. This decorator allows you to specify a custom name for models, operations, or parameters in the generated client code. Since the conflicting type name is generated by TCGC, you can apply `@clientName` to the model in your TypeSpec file to resolve the conflict. For example:\n\n```typespec\n@@clientName(GeneratedModel, \"CustomModelName\");\n```\n\nThis will rename the model `GeneratedModel` to `CustomModelName` in the client code. If you need to target a specific language, you can specify the language as an additional parameter:\n\n```typespec\n@@clientName(GeneratedModel, \"CustomModelName\", \"go\");\n```\n\nThis ensures the name change applies only to the Go emitter, allowing you to follow Go SDK guidelines without affecting other languages.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#05renaming.mdx\n- document_title: Renaming\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/05renaming\n- document_content: # howtos#generate-client-libraries#05renaming.mdx\n\n# Renaming\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents how to customize the name of models, operations, and parameters. For an overview of the setup, please visit the setup page.\r\n\r\n:::note\r\nThe TypeSpec compiler provides an `@encodedName` decorator that allows changing the name of the property for a given serialization format.\r\nHowever in Azure we recommend that you define the property name as the value sent on the wire and use the `@clientName` decorator to change the name of the generated property.\r\n:::\n\n## Default behaviors\n\nBy default, any language code generator will assume the TYPESPEC name is the client. For clarity, generators do not attempt to do any auto-magic rename.\r\n\r\n> **NOTE:** While names are not transformed, they will be adapted to what is idiomatic of the language (Python snake_case, etc.).\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=main.tsp\r\nnamespace PetStoreNamespace;\r\n\r\n/** This is the input I need */\r\n@resource(\"input\")\r\nmodel InputModel {\r\n  /** Id of this object */\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n}\r\n\r\n/** Read my resource */\r\nop get is ResourceRead<InputModel>;\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  name: str = rest_field(readonly=True)\r\n\r\nresponse: InputModel = client.get_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\ninterface InputModel {\r\n  name: string;\r\n}\r\n\r\nconst model: InputModel = await client.path(\"/petStore/model/{name}\").get();\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\n### Renaming models and attributes\n\nYou can rename models and attributes. [Renames have a target](https://microsoft.github.io/typespec/standard-library/projected-names#known-targets):\r\n\r\n- `client` means that all client will use that name\r\n- `csharp`, `javascript`, `python`, `java` means you target this specific language\r\n\r\nLanguage target takes priority over `client` target.\r\n\r\n> **NOTE:** As model name do not get serialized as JSON, sometimes the best choice is to rename the main TYPESPEC for clarity. Talk to your emitter contact is you're unsure\r\n> if you should rename the model in the main TYPESPEC or customize it.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(InputModel, \"InputOptions\"); // Use InputOptions as a base name in clients\r\n@@clientName(InputModel, \"ParameterOptions\", \"csharp\"); // Prefer a different name for C# only\r\n\r\n@@clientName(InputModel.name, \"input_name\", \"python\"); // Python may need a different to be idiomatic\r\n```\r\n\r\n```python\r\nclass InputOptions:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\n\r\nresponse: InputOptions = client.get_computed_model(input_name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class ParameterOptions\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\n\n{\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputOptions {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputOptions get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n### Renaming operations and parameters\n\nSimilarly, you can rename operations like in the example below:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(Get, \"Read\"); // Use InputOptions as a base name in clients\r\n@@clientName(Get, \"GetComputed\", \"python\"); // Note that Python will still snake_case it\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\nresponse: InputModel = client.get_computed_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> ReadModelAsync(string name, RequestContext context) {}\r\n    public virtual Response ReadModel(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> ReadModelAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> ReadModel(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> readModelWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel readModel(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\r\n\r\nYou cannot at this moment rename parameters in the client.tsp file. You will need to add the `@clientName` decorator over the parameter directly, example:\n\n## Implementation\n\n### Order of Operations\n\nFor consistency when generating code, the order in which overrides are applied is important. Code emitters should apply overrides in the following order.\r\n\r\n#### Over-the-Wire JSON Names\r\n\r\nFor determining the final name of a TypeSpec entity when sent over-the-wire in JSON:\r\n\r\n1. If the `@encodedName` decorator exists, use this value\r\n2. Use the original name in the spec\r\n\r\n#### Client SDK Names\r\n\r\nFor determining the final name of a TypeSpec entity when used in a client SDK (e.g. Python):\r\n\r\n1. Check if there's a scoped `@clientName` decorator for your emitter\r\n2. Check if there's a `@clientName` decorator at all\r\n3. Check the friendly name\r\n4. Use the original name in the spec\r\n\r\n**Note: If the object name is from `@clientName` decorator, do not apply your language's casing rules on it. If it's not, apply your language's heuristics (i.e. for Python, apply snake casing)**\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#openapi3#diagnostics.md\n- document_title: Diagnostics\n- document_link: https://typespec.io/docs/emitters/openapi3/diagnostics\n- document_content: # emitters#openapi3#diagnostics.md\n\n# Diagnostics\n\nThe OpenAPI emitter may produce any of the following diagnostic messages.\r\n\r\n<!-- Topics within this section should be ordered alphabetically for easy lookup -->\n\n## duplicate-header\n\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\r\n\r\nTo fix this issue, ensure that each response header is defined only once for each status code.\n\n### Example\n\n```yaml\r\nresponses:\r\n  \"200\":\r\n    description: Successful response\r\n    headers:\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n```\r\n\r\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\n\n## duplicate-type-name\n\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\r\n\r\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\n\n### Example\n\n```typespec\r\n@friendlyName(\"User\")\r\nmodel Customer {\r\n  id: string;\r\n}\r\n\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\n\n## inline-cycle\n\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\r\n\r\nTo fix this issue, refactor the schemas to remove the cyclic reference.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    Node:\r\n      type: object\r\n      properties:\r\n        value:\r\n          type: string\r\n        next:\r\n          $ref: \"#/components/schemas/Node\"\r\n```\r\n\r\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\n\n## invalid-default\n\nThis diagnostic is issued when a default value is invalid for the specified schema type.\r\n\r\nTo fix this issue, ensure that the default value is valid for the schema type.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        age:\r\n          type: integer\r\n          default: \"twenty\"\r\n```\r\n\r\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\n\n## invalid-extension-key\n\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \"x-\" as\r\nrequired by the OpenAPI v3 specification.\r\n\r\nTo fix this issue, change the extension name to start with \"x-\".\n\n### Example\n\n```typespec\r\n@extension(\"invalid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nShould be changed to:\r\n\r\n```typespec\r\n@extension(\"x-valid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\n\n## invalid-schema\n\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\r\n\r\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        id:\r\n          type: string\r\n        age:\r\n          type: integer\r\n          format: \"int\" # Invalid format\r\n```\r\n\r\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\n\n## invalid-server-variable\n\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\r\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\r\n\r\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\n\n### Example\n\n```typespec\r\n@server(\"{protocol}://{host}/api/{version}\", \"Custom endpoint\", {\r\n  protocol: \"http\" | \"https\",\r\n  host: string,\r\n  version: 1, // Should be a string: \"1\"\r\n})\r\n```\n\n## path-query\n\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\r\n\r\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\n\n### Example\n\nInstead of:\r\n\r\n```typespec\r\n@route(\"/users?filter={filter}\")\r\nop getUsers(filter: string): User[];\r\n```\r\n\r\nUse:\r\n\r\n```typespec\r\n@route(\"/users\")\r\nop getUsers(@query filter?: string): User[];\r\n```\r\n\r\nAlternatively, you can leverage TypeSpec's support for URI templates:\r\n\r\n```typespec\r\n@route(\"/users{?filter}\")\r\nop getUsers(filter?: string): User[];\r\n```\n\n## union-null\n\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\r\nrepresented in OpenAPI.\r\n\r\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\n\n## union-unsupported\n\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\r\n\r\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: standard-library#encoded-names.md\n- document_title: Encoded names\n- document_link: https://typespec.io/docs/standard-library/encoded-names\n- document_content: # standard-library#encoded-names.md\n\n# Encoded names\n\nThere is some cases where the name you have in TypeSpec might differ from the name over the wire or for a certain language.\n\n## Update name for a given target\n\nTo update the name of a TypeSpec entity you can use the `@encodedName` decorator. This decorator takes 2 parameters:\r\n\r\n| Parameter     | Type     | Description                                                                                                                                                                                                            |\r\n| ------------- | -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `mimeType`    | `string` | Mime type this should apply to. The mime type should be a known mime type as described here https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types without any suffix (e.g. `+json`) |\r\n| `encodedName` | `string` | The name should be when serialized to the given mime type.                                                                                                                                                             |\r\n\r\nExample:\r\n\r\n```typespec\r\nmodel Foo {\r\n  // Specify that when serializing to JSON `expireAt` property should be named `exp`\r\n  @encodedName(\"json\", \"exp\")\r\n  expireAt: string;\r\n}\r\n```\n\n## Example\n\n```typespec\r\nmodel CertificateAttributes {\r\n  @encodedName(\"application/json\", \"nbf\")\r\n  notBefore: int32;\r\n\r\n  @encodedName(\"application/json\", \"exp\")\r\n  @encodedName(\"application/xml\", \"ExpireAt\")\r\n  expires: int32;\r\n\r\n  created: int32;\r\n  updated: int32;\r\n}\r\n```\r\n\r\n<table>\r\n<thead>\r\n<tr>\r\n<th>Json</th>\r\n<th>Xml</th>\r\n<th>Yaml</th>\r\n</tr>\r\n</thead>\r\n<tr>\r\n<td>When serialized to `application/json` properties will use the encodedName for `application/json` if available or default to the property name.</td>\r\n<td>When serialized to `application/xml` properties will use the encodedName for `application/xml` if available or default to the property name.</td>\r\n<td>Yaml didn't provide any different names so it will serialize using the property names.</td>\r\n</tr>\r\n<tr>\r\n<td>\r\n\r\n```json\r\n{\r\n  \"nbf\": 1430344421,\r\n  \"exp\": 2208988799,\r\n  \"created\": 1493938289,\r\n  \"updated\": 1493938291\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<CertificateAttributes>\r\n  <notBefore>1430344421</notBefore>\r\n  <ExpireAt>2208988799</ExpireAt>\r\n  <created>1493938289</created>\r\n  <updated>1493938291</updated>\r\n</CertificateAttributes>\r\n```\r\n\r\n</td>\r\n\r\n<td>\r\n\r\n```yaml\r\nnotBefore: 1430344421\r\nexpires: 2208988799\r\ncreated: 1493938289\r\nupdated: 1493938291\r\n```\r\n\r\n</td>\r\n</tr>\r\n</table>\n\n## Use in library/emitter\n\nTo consume the value of `@encodedName` in your library or emitter you can use `resolveEncodedName(target: Type, mimeType: string): string` from the compiler.\r\n\r\n```ts\r\nimport { resolveEncodedName } from \"@typespec/compiler\";\r\n\r\n// Resolve the encoded name for the given property and mime type. If the property doesn't have a encoded name for the given mime type it will return the property name.\r\nconst encodedName = resolveEncodedName(property, \"application/json\");\r\n\r\n// You can also pass a full http mime type and `resolveEncodedName` will automatically resolve it to the base mime type.\r\nconst encodedName = resolveEncodedName(property, \"application/merge-patch+json\");\r\n```\n", "latency": 7.438072443008423, "response_length": 821}
{"query": "title: Is there a unique and certain `namespace` for data-plane api?\n\nquestion: in tsp for data-plane of devcenter, the namespace is DevCenterService,  while in the swagger api, the namespace looks like to be Microsoft.DevCenter, azure-rest-api-specs/specification/devcenter/DevCenter/main.tsp at main  Azure/azure-rest-api-specs\nIs the namespace certain in someway, or it's just a sequence or chars and it doesn't influence the api?\nFor mgmt-plane, the namespace matters cause it's a part of the operation id path, but for data-plane, not sure about the namespace constraints.", "ground_truth": "For data-plane client libraries, the namespace is generally defined in tspconfig.yaml through the namespace option and that takes precedence over what is in main.tsp.  Since DevCenter spec already has this defined in tspconfig.yaml, the namespace defined in main.tsp doesn't matter for generating client libraries.", "response": "In TypeSpec, the namespace used for a data-plane API does not directly influence the API's functionality but serves as an organizational tool. Namespaces help group related operations and models, making the API easier to manage and understand. For example, in the Swagger API, the namespace `Microsoft.DevCenter` is used, while in TypeSpec for DevCenter's data-plane, the namespace is `DevCenterService`. These namespaces are essentially sequences of characters used for structuring and clarity.\n\nFor management-plane APIs, namespaces are significant because they are part of the operation ID path, which impacts the generated OpenAPI specification and client SDKs. However, for data-plane APIs, namespaces primarily provide clarity and organization, and their constraints are less strict. They do not directly affect the API's behavior but can influence the generated operation IDs and documentation structure.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: intro.md\n- document_title: Introduction\n- document_link: https://azure.github.io/typespec-azure/docs/intro\n- document_content: # intro.md\n\n# Introduction\n\nTypeSpec is a language for describing cloud service APIs and generating other API description languages, client and service code, documentation, and other assets. TypeSpec provides highly extensible core language primitives that can describe API shapes common among REST, GraphQL, gRPC, and other protocols.\r\n\r\nYou can find more information at https://typespec.io/docs.\r\n\r\nThis site is focused on using TypeSpec in the context of Azure. We have published a set of libraries with standard patterns and templates to make defining Azure management and data-plane services easy and compliant with Azure API guidelines. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\n\n# TypeSpec Azure Libraries\n\n## Packages\n\n| ![](https://img.shields.io/npm/@azure-tools/typespec-azure-resource-manager/next) |\r\n| [@azure-tools/typespec-autorest][typespec-autorest_src]                       | Emitter | [Changelog][typespec-autorest_chg]               | [![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest)](https://www.npmjs.com/package/@azure-tools/typespec-autorest)                             | ![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest/next)             |\r\n\r\n[typespec-autorest_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-autorest\r\n[typespec-autorest_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-autorest/CHANGELOG.md\r\n[typespec-azure-core_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core\r\n[typespec-azure-core_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core/CHANGELOG.md\r\n[typespec-azure-resource-manager_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager\r\n[typespec-azure-resource-manager_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/CHANGELOG.md\r\n\r\n`@next` version of the package are the latest versions available on the `main` branch.\n\n| Name                                                                          | Type    | Changelog                                        | Latest                                                                                                                                                       | Next                                                                              |\r\n| ----------------------------------------------------------------------------- | ------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------- |\r\n| [@azure-tools/typespec-azure-core][typespec-azure-core_src]                   | Library | [Changelog][typespec-azure-core_chg]             | [![](https://img.shields.io/npm/v/@azure-tools/typespec-azure-core)](https://www.npmjs.com/package/@azure-tools/typespec-azure-core)                         | ![](https://img.shields.io/npm/@azure-tools/typespec-azure-core/next)             |\r\n| [@azure-tools/typespec-resource-manager][typespec-azure-resource-manager_src] | Library | [Changelog][typespec-azure-resource-manager_chg] | [![](https://img.shields.io/npm/v/@azure-tools/typespec-azure-resource-manager)](https://www.npmjs.com/package/@azure-tools/typespec-azure-resource-manager) | ![](https://img.shields.io/npm/@azure-tools/typespec-azure-resource-manager/next) |\r\n| [@azure-tools/typespec-autorest][typespec-autorest_src]                       | Emitter | [Changelog][typespec-autorest_chg]               | [![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest)](https://www.npmjs.com/package/@azure-tools/typespec-autorest)                             | ![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest/next)             |\n\n### Package Layering\n\nThe main packages in this repository can be considered a series of layers which progressively add functionality\r\nfor specific scenarios:\r\n\r\n- [**@azure-tools/typespec-azure-core:**](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core) Provides core models and interfaces for Azure service modelling\r\n- [**@azure-tools/typespec-azure-resource-manager:**](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager) Provides additional models and interfaces for modelling Azure Resource Manager services\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](./typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#02-operations-responses.md\n- document_title: Operations and Responses\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/02-operations-responses\n- document_content: # getting-started#getting-started-rest#02-operations-responses.md\n\n# Operations and Responses\n\n## Introduction\n\nIn this section, we'll build upon the basics we covered in the previous section. We'll define CRUD operations (Create, Read, Update, Delete) for our Pet Store API and discuss the benefits of using nested namespaces.\n\n## Defining CRUD Operations\n\nNext, we'll discuss how to define CRUD operations for our API. We'll cover operations for `Creating`, `Reading`, `Updating`, and `Deleting` pets, all within a nested namespace for better organization.\n\n### Example: Adding CRUD Operations\n\nLet's define the CRUD operations for our `Pet` model:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  };\r\n\r\n  @post\r\n  op createPet(@body pet: Pet): {\r\n    @statusCode statusCode: 201;\r\n    @body newPet: Pet;\r\n  };\r\n\r\n  @put\r\n  op updatePet(@path petId: int32, @body pet: Pet): {\r\n    @statusCode statusCode: 200;\r\n    @body updatedPet: Pet;\r\n  };\r\n\r\n  @delete\r\n  op deletePet(@path petId: int32): {\r\n    @statusCode statusCode: 204;\r\n  };\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@route` decorator defines the base path for the `Pets` namespace.\r\n- The `listPets` operation lists all pets.\r\n- The `getPet` operation retrieves a specific pet by its `petId`.\r\n- The `createPet` operation creates a new pet.\r\n- The `updatePet` operation updates an existing pet.\r\n- The `deletePet` operation deletes an existing pet.\n\n### Benefits of Nested Namespaces\n\nUsing nested namespaces in TypeSpec provides several benefits:\r\n\r\n1. **Organization**: Grouping related operations under a common namespace makes the API easier to manage and understand.\r\n2. **Operation IDs**: The TypeSpec compiler appends the namespace name to the `operationId` in the OpenAPI spec, making it clear which resource each operation is intended to operate on.\r\n3. **Clarity**: It helps in avoiding naming conflicts and provides a clear structure for the API.\r\n\r\n#### Example: Operation ID in OpenAPI Spec\r\n\r\nFor the `listPets` operation defined in the `Pets` namespace, the OpenAPI spec will generate an `operationId` like `Pets_listPets`, making it clear that this operation is related to the `Pets` resource.\n\n### Example: Route URLs for CRUD Operations\n\nHere's what the route URLs will look like for the CRUD operations defined in the `Pets` namespace:\r\n\r\n- **List Pets**: `GET https://example.com/pets`\r\n  - Retrieves a list of all pets.\r\n- **Get Pet by ID**: `GET https://example.com/pets/{petId}`\r\n  - Retrieves a specific pet by its `petId`.\r\n- **Create Pet**: `POST https://example.com/pets`\r\n  - Creates a new pet.\r\n- **Update Pet by ID**: `PUT https://example.com/pets/{petId}`\r\n  - Updates an existing pet by its `petId`.\r\n- **Delete Pet by ID**: `DELETE https://example.com/pets/{petId}`\r\n  - Deletes an existing pet by its `petId`.\n\n### Operation Flowchart\n\nFor clarity, here's a flowchart that depicts the flow of data and operations within the API:\r\n\r\n```\r\n[Client] --> [API Gateway] --> [listPets Operation] --> [Database] --> [Response: List of Pets]\r\n[Client] --> [API Gateway] --> [getPet Operation] --> [Database] --> [Response: Pet Details]\r\n[Client] --> [API Gateway] --> [createPet Operation] --> [Database] --> [Response: Created Pet]\r\n[Client] --> [API Gateway] --> [updatePet Operation] --> [Database] --> [Response: Updated Pet]\r\n[Client] --> [API Gateway] --> [deletePet Operation] --> [Database] --> [Response: Deletion Confirmation]\r\n```\n\n## Handling Different Types of Responses\n\nIn a real-world API, different operations might return different types of successful responses. Let's see how we can handle various response scenarios in TypeSpec.\n\n### Example: Handling Different Status Codes\n\nLet's update our pet operations to return different status codes based on the outcome.\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n    // highlight-start\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    // highlight-end\r\n  };\r\n\r\n  @post\r\n  op createPet(@body pet: Pet): {\r\n    @statusCode statusCode: 201;\r\n    @body newPet: Pet;\r\n    // highlight-start\r\n  } | {\r\n    @statusCode statusCode: 202;\r\n    @body acceptedPet: Pet;\r\n    // highlight-end\r\n  };\r\n\r\n  @put\r\n  op updatePet(@path petId: int32, @body pet: Pet): {\r\n    @statusCode statusCode: 200;\r\n    @body updatedPet: Pet;\r\n    // highlight-start\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    // highlight-end\r\n  };\r\n\r\n  @delete\r\n  op deletePet(@path petId: int32): {\r\n    @statusCode statusCode: 204;\r\n  };\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The pet operations are updated to handle different status codes, depending on the outcome of the operation reported by the backend service.\r\n\r\n**Explanation of the `|` Operator**:\r\n\r\n- The `|` operator is used to define multiple possible responses for an operation. Each response block specifies a different status code and response body.\r\n- In the `createPet` operation, for example, the `|` operator allows the operation to return either a 201 status code with a `newPet` object or a 202 status code with an `acceptedPet` object.\n\n### OpenAPI Spec Mapping\n\nHere is how the TypeSpec operation definitions map to the OpenAPI specification:\r\n\r\n<table>\r\n<tr>\r\n<td>TypeSpec Definition</td>\r\n<td>OpenAPI Spec</td>\r\n</tr>\r\n<td>\r\n\r\n```tsp\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n@get\r\nop listPets(): {\r\n@statusCode statusCode: 200;\r\n@body pets: Pet[];\r\n};\r\n\r\n@get\r\nop getPet(@path petId: int32): {\r\n@statusCode statusCode: 200;\r\n@body pet: Pet;\r\n} | {\r\n@statusCode statusCode: 404;\r\n};\r\n\r\n@post\r\nop createPet(@body pet: Pet): {\r\n@statusCode statusCode: 201;\r\n@body newPet: Pet;\r\n} | {\r\n@statusCode statusCode: 202;\r\n@body acceptedPet: Pet;\r\n};\r\n\r\n@put\r\nop updatePet(@path petId: int32, @body pet: Pet):{\r\n@statusCode statusCode: 200;\r\n@body updatedPet: Pet;\r\n} | {\r\n@statusCode statusCode: 404;\r\n} | {\r\n@statusCode statusCode: 500;\r\n};\r\n\r\n@delete\r\nop deletePet(@path petId: int32): {\r\n@statusCode statusCode: 204;\r\n@body NoContentResponse;\r\n} | {\r\n@statusCode statusCode: 404;\r\n};\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yml\r\npaths:\r\n  /pets:\r\n    get:\r\n      operationId: Pets_listPets\r\n      parameters: []\r\n      responses:\r\n        \"200\":\r\n          description: The request has succeeded.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                type: array\r\n                items:\r\n                  $ref: \"#/components/schemas/Pet\"\r\n    post:\r\n      operationId: Pets_createPet\r\n      parameters: []\r\n      responses:\r\n        \"201\":\r\n          description: The request has succeeded and a new resource has been created as a result.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n        \"202\":\r\n          description: The request has been accepted for processing, but processing has not yet completed.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\n\nas a result.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n        \"202\":\r\n          description: The request has been accepted for processing, but processing has not yet completed.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/Pet\"\r\n  /pets/{petId}:\r\n    get:\r\n      operationId: Pets_getPet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n      responses:\r\n        \"200\":\r\n          description: The request has succeeded.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n        \"404\":\r\n          description: The server cannot find the requested resource.\r\n    put:\r\n      operationId: Pets_updatePet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n      responses:\r\n        \"200\":\r\n          description: The request has succeeded.\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Pet\"\r\n        \"404\":\r\n          description: The server cannot find the requested resource.\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/Pet\"\r\n    delete:\r\n      operationId: Pets_deletePet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n      responses:\r\n        \"204\":\n\n\"404\":\r\n          description: The server cannot find the requested resource.\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/Pet\"\r\n    delete:\r\n      operationId: Pets_deletePet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n      responses:\r\n        \"204\":\r\n          description: \"There is no content to send for this request, but the headers may be useful. \"\r\n```\r\n\r\n</td>\r\n</table>\r\n\r\n**Note**: As you can see, TypeSpec is much more compact and easier to read compared to the equivalent OpenAPI specification.\n\n## Conclusion\n\nIn this section, we demonstrated how to define CRUD operations for your REST API using TypeSpec and discussed the benefits of using nested namespaces. We also covered how to handle different types of successful responses.\r\n\r\nIn the next section, we'll dive deeper into handling errors in your REST API, including defining custom response models for error handling.\n", "latency": 10.095887899398804, "response_length": 911}
{"query": "title: Setting x-ms-identifiers for objects in Azure.Core.Page<T>?\n\nquestion: Hi, I'm working on a typespec migration.\nI have a list operation response definition:\nmodel FaultSimulationListResult is Azure.Core.Page<FaultSimulation>;\nOur existing swagger has the output as:\n\"FaultSimulationListResult\": {\n\"type\": \"object\",\n\"properties\": {\n\"value\": {\n\"type\": \"array\",\n\"title\": \"fault simulation list value.\",\n\"description\": \"The list of fault simulations.\",\n\"items\": {\n\"$ref\": \"#/definitions/FaultSimulation\"\n},\n\"x-ms-identifiers\": [\n\"simulationId\"\n]\n},\n\"nextLink\": {\n\"type\": \"string\",\n\"description\": \"The URL to use for getting the next set of results.\"\n}\n},\n\"description\": \"Fault simulation list results\"\n}\nWhen I try adding a @OpenAPI.extension(\"x-ms-identifiers\", #[\"simulationId\"])\ndecorator to the model in Typespec, I get:\n```\n\"FaultSimulationListResult\": {\n\"type\": \"object\",\n\"description\": \"Fault simulation list results\",\n\"properties\": {\n\"value\": {\n\"type\": \"array\",\n\"description\": \"The FaultSimulation items on this page\",\n\"items\": {\n\"$ref\": \"#/definitions/FaultSimulation\"\n},\n\"x-ms-identifiers\": []\n},\n\"nextLink\": {\n\"type\": \"string\",\n\"format\": \"uri\",\n\"description\": \"The link to the next page of items\"\n}\n},\n\"required\": [\n\"value\"\n],\n\"x-ms-identifiers\": [\n\"simulationId\"\n]\n}\n```\nIs there a way to tag the array within the Azure.Core.Page?", "ground_truth": "- There is 2 options:\n- mark simulationId property with @key\n- Add @@identifiers(FaultSimulationListResult.value, #[\"simulationId\"])", "response": "To tag the array within the `Azure.Core.Page<T>` model with `x-ms-identifiers`, you need to apply the `@OpenAPI.extension` decorator directly to the `value` property of the model. In TypeSpec, this can be done as follows:\n\n```tsp\nmodel FaultSimulationListResult is Azure.Core.Page<FaultSimulation> {\n  @OpenAPI.extension(\"x-ms-identifiers\", [\"simulationId\"])\n  value: FaultSimulation[];\n}\n```\n\nThis ensures that the `x-ms-identifiers` extension is applied specifically to the `value` property, which represents the array of items in the page. The `simulationId` identifier will be correctly associated with the array items in the generated OpenAPI specification.", "context": "- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-resource-manager#reference#linter.md\n- document_title: Linter usage\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/linter\n- document_content: # libraries#azure-resource-manager#reference#linter.md\n\n# Linter usage\n\n## Usage\n\nAdd the following in `tspconfig.yaml`:\r\n\r\n```yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-resource-manager/all\"\r\n```\n\n## RuleSets\n\nAvailable ruleSets:\r\n\r\n- `@azure-tools/typespec-azure-resource-manager/all`\n\n## Rules\n\n| `@armResourceAction` should not be used with `@segment`.                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-duplicate-property`                                                                                   | Warn about duplicate properties in resources.                                                                                                                                                                                                         |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-envelope-property`                                                                            | Check for invalid resource envelope properties.                                                                                                                                                                                                       |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-version-format`                                                                               | Check for valid versions.                                                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-key-invalid-chars`                                                                                    | Arm resource key must contain only alphanumeric characters.                                                                                                                                                                                           |\r\n|\n\n|\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-operation`                                                                                            | Validate ARM Resource operations.                                                                                                                                                                                                                     |\r\n| `@azure-tools/typespec-azure-resource-manager/no-resource-delete-operation`                                                                                      | Check for resources that must have a delete operation.                                                                                                                                                                                                |\r\n| `@azure-tools/typespec-azure-resource-manager/empty-updateable-properties`                                                                                       | Should have updateable properties.                                                                                                                                                                                                                    |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-interface-requires-decorator`                                                                         | Each resource interface must have an @armResourceOperations decorator.                                                                                                                                                                                |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-action-verb`](/libraries/azure-resource-manager/rules/arm-resource-invalid-action-verb.md)   |\n\n| Name                                                                                                                                                             | Description                                                                                                                                                                                                                                           |\r\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-no-record`](/libraries/azure-resource-manager/rules/arm-no-record.md)                                         | Don't use Record types for ARM resources.                                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-common-types-version`                                                                                          | Specify the ARM common-types version using @armCommonTypesVersion.                                                                                                                                                                                    |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-delete-operation-response-codes`](/libraries/azure-resource-manager/rules/delete-operation-response-codes.md) | Ensure delete operations have the appropriate status codes.\n\n| Each resource interface must have an @armResourceOperations decorator.                                                                                                                                                                                |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-action-verb`](/libraries/azure-resource-manager/rules/arm-resource-invalid-action-verb.md)   | Actions must be HTTP Post or Get operations.                                                                                                                                                                                                          |\r\n| `@azure-tools/typespec-azure-resource-manager/improper-subscription-list-operation`                                                                              | Tenant and Extension resources should not define a list by subscription operation.                                                                                                                                                                    |\r\n| [`@azure-tools/typespec-azure-resource-manager/lro-location-header`](/libraries/azure-resource-manager/rules/lro-location-header.md)                             | A 202 response should include a Location response header.                                                                                                                                                                                             |\r\n| [`@azure-tools/typespec-azure-resource-manager/missing-x-ms-identifiers`](/libraries/azure-resource-manager/rules/missing-x-ms-identifiers.md)                   | Array properties should describe their identifying properties with x-ms-identifiers. Decorate the property with @OpenAPI.extension(\"x-ms-identifiers\", #[id-prop]) where \"id-prop\" is a list of the names of identifying properties in the item type. |\r\n|\n\n|\r\n| [`@azure-tools/typespec-azure-resource-manager/missing-x-ms-identifiers`](/libraries/azure-resource-manager/rules/missing-x-ms-identifiers.md)                   | Array properties should describe their identifying properties with x-ms-identifiers. Decorate the property with @OpenAPI.extension(\"x-ms-identifiers\", #[id-prop]) where \"id-prop\" is a list of the names of identifying properties in the item type. |\r\n| [`@azure-tools/typespec-azure-resource-manager/no-response-body`](/libraries/azure-resource-manager/rules/no-response-body.md)                                   | Check that the body is empty for 202 and 204 responses, and not empty for other success (2xx) responses.                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/missing-operations-endpoint`                                                                                       | Check for missing Operations interface.                                                                                                                                                                                                               |\r\n| `@azure-tools/typespec-azure-resource-manager/patch-envelope`                                                                                                    | Patch envelope properties should match the resource properties.                                                                                                                                                                                       |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-patch`                                                                                                |\n\n|\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-key-invalid-chars`                                                                                    | Arm resource key must contain only alphanumeric characters.                                                                                                                                                                                           |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-resource-name-pattern`](/libraries/azure-resource-manager/rules/resource-name-pattern.md)                     | The resource name parameter should be defined with a 'pattern' restriction.                                                                                                                                                                           |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-operation-response`                                                                                   | [RPC 008]: PUT, GET, PATCH & LIST must return the same resource schema.                                                                                                                                                                               |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-path-segment-invalid-chars`                                                                           | Arm resource name must contain only alphanumeric characters.                                                                                                                                                                                          |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-provisioning-state`                                                                                   |\n\n|\r\n| [`@azure-tools/typespec-azure-resource-manager/unsupported-type`](/libraries/azure-resource-manager/rules/unsupported-type.md)                                   | Check for unsupported ARM types.                                                                                                                                                                                                                      |\r\n| [`@azure-tools/typespec-azure-resource-manager/no-empty-model`](/libraries/azure-resource-manager/rules/no-empty-model.md)                                       | ARM Properties with type:object that don't reference a model definition are not allowed. ARM doesn't allow generic type definitions as this leads to bad customer experience.                                                                         |\n\n| Arm resource name must contain only alphanumeric characters.                                                                                                                                                                                          |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-provisioning-state`                                                                                   | Check for properly configured provisioningState property.                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-custom-resource-usage-discourage`                                                                              | Verify the usage of @customAzureResource decorator.                                                                                                                                                                                                   |\r\n| `@azure-tools/typespec-azure-resource-manager/beyond-nesting-levels`                                                                                             | Tracked Resources must use 3 or fewer levels of nesting.                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-operation`                                                                                            | Validate ARM Resource operations.                                                                                                                                                                                                                     |\r\n|\n\n|\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-delete-operation-response-codes`](/libraries/azure-resource-manager/rules/delete-operation-response-codes.md) | Ensure delete operations have the appropriate status codes.                                                                                                                                                                                           |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-put-operation-response-codes`](/libraries/azure-resource-manager/rules/put-operation-response-codes.md)       | Ensure put operations have the appropriate status codes.                                                                                                                                                                                              |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-post-operation-response-codes`](/libraries/azure-resource-manager/rules/post-operation-response-codes.md)     | Ensure post operations have the appropriate status codes.                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-action-no-segment`                                                                                    | `@armResourceAction` should not be used with `@segment`.                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-duplicate-property`                                                                                   |\n\n| Patch envelope properties should match the resource properties.                                                                                                                                                                                       |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-patch`                                                                                                | Validate ARM PATCH operations.                                                                                                                                                                                                                        |\r\n| `@azure-tools/typespec-azure-resource-manager/resource-name`                                                                                                     | Check the resource name.                                                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/retry-after`                                                                                                       | Check if retry-after header appears in response body.                                                                                                                                                                                                 |\r\n| [`@azure-tools/typespec-azure-resource-manager/unsupported-type`](/libraries/azure-resource-manager/rules/unsupported-type.md)                                   | Check for unsupported ARM types.                                                                                                                                                                                                                      |\r\n|\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-resource-manager#rules#missing-x-ms-identifiers.md\n- document_title: missing-x-ms-identifiers\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/rules/missing-x-ms-identifiers\n- document_content: # libraries#azure-resource-manager#rules#missing-x-ms-identifiers.md\n\n# missing-x-ms-identifiers\n\n```text title=- Full name-\r\n@azure-tools/typespec-azure-resource-manager/missing-x-ms-identifiers\r\n```\r\n\r\nCheck that array properties have `x-ms-identifiers` specified with `@OpenAPI.extension`\r\n\r\n####  Incorrect\r\n\r\n```tsp\r\nmodel Address {\r\n  city: string;\r\n  street: string;\r\n}\r\n\r\nmodel ResourceProperties {\r\n  array: Address[];\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\nmodel ResourceProperties {\r\n  @OpenAPI.extension(\"x-ms-identifiers\", [\"city\", \"street\"])\r\n  array: Address[];\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-openapi.md\n- document_title: no-openapi\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi\n- document_content: # libraries#azure-core#rules#no-openapi.md\n\n# no-openapi\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-openapi\r\n```\r\n\r\nAzure services should not be using decorators from the OpenAPIs libraries(`@azure-tools/openapi`, `@azure-tools/typespec-autorest` or `@azure-tools/openapi3`) in their spec.\r\nUsing those decorators is usually a sign that the spec is either not following the correct Azure or trying to match exactly a particular OpenAPI spec which should be a non-goal.\r\n\r\nThose decorators are only meant to be read by the openapi emitters which means this might achieve the correct OpenAPI output but other emitters(client SDK, service, etc.) will not be able to understand them and will see a broken representation of the spec.\n\n## Decorators and their alternatives\n\n|\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              | Use versioning library for `version` and `@service` for title                                                                                                   |\n\n| OpenAPI Decorator                    | Alternative                                                                                                                                                     |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `@example`                           | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-examples\", `       | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-client-flatten\", ` | TCGC [`@flattenProperty`](../../typespec-client-generator-core/reference/decorators#@Azure.ClientGenerator.Core.flattenProperty)                                |\r\n| `@extension(\"x-ms-mutability\", `     | Use [`@visibility` decorator](https://typespec.io/docs/next/standard-library/built-in-decorators#@visibility)                                                   |\r\n| `@extension(\"x-ms-enum\", `           | [Enum extensibility doc](https://azure.github.io/typespec-azure/docs/next/troubleshoot/enum-not-extensible)                                                     |\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              |\n\n## Exceptions\n\n- `@extension(\"x-ms-identifiers\"` is allowed as this right now has no alternative and is an ARM requirement that is not used by any other emitter.\n\n## Examples\n\n### `@extension(\"x-ms-enum\"`\n\n####  Incorrect\r\n\r\n```tsp\r\n@extension(\r\n  \"x-ms-enum\",\r\n  {\r\n    name: \"PetKind\",\r\n    modelAsString: true,\r\n  }\r\n)\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n\n### `@extension(\"x-ms-mutability\"`\n\n####  Incorrect\r\n\r\n```tsp\r\nmodel Pet {\r\n  @extension(\"x-ms-mutability\", [\"read\", \"create\"])\r\n  name: string;\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\nmodel Pet {\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  name: string;\r\n}\r\n```\n\n### `@operationId`\n\n####  Incorrect\r\n\r\n```tsp\r\n@operationId(\"Pet_Get\")\r\nop getPet(): Pet;\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\ninterface Pet {\r\n  get(): Pet;\r\n}\r\n```\n", "latency": 7.19177770614624, "response_length": 662}
{"query": "title: Issues with Spec PR\n\nquestion: I am seeing below errors with TypeSpec file validation.\nCan anyone let me know how to fix them?\n```\nExecuting rule: Compile\n137  run command:npm exec --no -- tsp compile --warn-as-error /home/runner/work/azure-rest-api-specs-pr/azure-rest-api-specs-pr/specification/carbon/Carbon.Management\n138  TypeSpec compiler v0.66.0\n139\n140  Compiling...\n141   Compiling\n142  Running @azure-tools/typespec-autorest...\n143   @azure-tools/typespec-autorest\n144  Diagnostics were reported during compilation:\nspecification/carbon/Carbon.Management/main.tsp:16:10 - error deprecated: Deprecated: Using a model as a value is deprecated. Use an object value instead(with #{}).\n147  > 16 | @service({\n148       |          ^\n149  > 17 |   title: \"Carbon\",\n150       | ^^^^^^^^^^^^^^^^^^\n151  > 18 | })\n152       | ^^\n153  specification/carbon/Carbon.Management/main.tsp:122:34 - error deprecated: Deprecated: Using a tuple as a value is deprecated. Use an array value instead(with #[]).\n154  > 122 |   @extension(\"x-ms-identifiers\", [])\n155        |                                  ^^\n156  specification/carbon/Carbon.Management/main.tsp:126:34 - error deprecated: Deprecated: Using a tuple as a value is deprecated. Use an array value instead(with #[]).\n157  > 126 |   @extension(\"x-ms-identifiers\", [])\n158        |                                  ^^\n159  specification/carbon/Carbon.Management/main.tsp:130:34 - error deprecated: Deprecated: Using a tuple as a value is deprecated. Use an array value instead(with #[]).\n160  > 130 |   @extension(\"x-ms-identifiers\", [])\n161        |                                  ^^\n162  specification/carbon/Carbon.Management/main.tsp:134:34 - error deprecated: Deprecated: Using a tuple as a value is deprecated. Use an array value instead(with #[]).\n163  > 134 |   @extension(\"x-ms-identifiers\", [])\n164        |                                  ^^\n165  specification/carbon/Carbon.Management/main.tsp:138:34 - error deprecated: Deprecated: Using a tuple as a value is deprecated. Use an array value instead(with #[]).\n166  > 138 |   @extension(\"x-ms-identifiers\", [])\n167        |                                  ^^\n168  specification/carbon/Carbon.Management/main.tsp:501:34 - error deprecated: Deprecated: Using a tuple as a value is deprecated. Use an array value instead(with #[]).\n169  > 501 |   @extension(\"x-ms-identifiers\", [])\n170        |                                  ^^\n171  specification/carbon/Carbon.Management/main.tsp:509:34 - error deprecated: Deprecated: Using a tuple as a value is deprecated. Use an array value instead(with #[]).\n172  > 509 |   @extension(\"x-ms-identifiers\", [])\n173        |                                  ^^\n```", "ground_truth": "You probably need to update your local fork from the target branch.  There was a recent breaking change that made all openapi extesnions  (and also the @service decorator ) use value types, and issued a warning diagnostic if you used the old syntax).  If you bring in the latest, these were all changed to use the new syntax.\nNote that there is also now an @identifiers decorator that allows you to set these values:, which you use [like this](https://github.com/Azure/azure-rest-api-specs-pr/blob/RPSaaSMaster/specification/carbon/Carbon.Management/main.tsp#L16)", "response": "The errors you are encountering are due to deprecated syntax in TypeSpec. Here's how you can fix them:\n\n1. **Using a model as a value**:\n   - The error indicates that using a model as a value is deprecated. Instead, you should use an object value with the `#{}` syntax. For example:\n     ```typespec\n     @service({\n       title: \"Carbon\",\n     })\n     ```\n     Ensure that any values passed to decorators are wrapped in `#{}` if they are object values.\n\n2. **Using a tuple as a value**:\n   - The error indicates that tuples are deprecated as values. You should use array values with the `#[]` syntax instead. For example:\n     ```typespec\n     @extension(\"x-ms-identifiers\", #[ ])\n     ```\n     Replace `[]` with `#[ ]` wherever tuples are used as values.\n\nBy updating your TypeSpec file to use the correct syntax for object and array values, these errors should be resolved.", "context": "- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: intro.md\n- document_title: Introduction\n- document_link: https://azure.github.io/typespec-azure/docs/intro\n- document_content: # intro.md\n\n# Introduction\n\nTypeSpec is a language for describing cloud service APIs and generating other API description languages, client and service code, documentation, and other assets. TypeSpec provides highly extensible core language primitives that can describe API shapes common among REST, GraphQL, gRPC, and other protocols.\r\n\r\nYou can find more information at https://typespec.io/docs.\r\n\r\nThis site is focused on using TypeSpec in the context of Azure. We have published a set of libraries with standard patterns and templates to make defining Azure management and data-plane services easy and compliant with Azure API guidelines. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\n\n# TypeSpec Azure Libraries\n\n## Packages\n\n| ![](https://img.shields.io/npm/@azure-tools/typespec-azure-resource-manager/next) |\r\n| [@azure-tools/typespec-autorest][typespec-autorest_src]                       | Emitter | [Changelog][typespec-autorest_chg]               | [![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest)](https://www.npmjs.com/package/@azure-tools/typespec-autorest)                             | ![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest/next)             |\r\n\r\n[typespec-autorest_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-autorest\r\n[typespec-autorest_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-autorest/CHANGELOG.md\r\n[typespec-azure-core_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core\r\n[typespec-azure-core_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core/CHANGELOG.md\r\n[typespec-azure-resource-manager_src]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager\r\n[typespec-azure-resource-manager_chg]: https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/CHANGELOG.md\r\n\r\n`@next` version of the package are the latest versions available on the `main` branch.\n\n| Name                                                                          | Type    | Changelog                                        | Latest                                                                                                                                                       | Next                                                                              |\r\n| ----------------------------------------------------------------------------- | ------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------- |\r\n| [@azure-tools/typespec-azure-core][typespec-azure-core_src]                   | Library | [Changelog][typespec-azure-core_chg]             | [![](https://img.shields.io/npm/v/@azure-tools/typespec-azure-core)](https://www.npmjs.com/package/@azure-tools/typespec-azure-core)                         | ![](https://img.shields.io/npm/@azure-tools/typespec-azure-core/next)             |\r\n| [@azure-tools/typespec-resource-manager][typespec-azure-resource-manager_src] | Library | [Changelog][typespec-azure-resource-manager_chg] | [![](https://img.shields.io/npm/v/@azure-tools/typespec-azure-resource-manager)](https://www.npmjs.com/package/@azure-tools/typespec-azure-resource-manager) | ![](https://img.shields.io/npm/@azure-tools/typespec-azure-resource-manager/next) |\r\n| [@azure-tools/typespec-autorest][typespec-autorest_src]                       | Emitter | [Changelog][typespec-autorest_chg]               | [![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest)](https://www.npmjs.com/package/@azure-tools/typespec-autorest)                             | ![](https://img.shields.io/npm/v/@azure-tools/typespec-autorest/next)             |\n\n### Package Layering\n\nThe main packages in this repository can be considered a series of layers which progressively add functionality\r\nfor specific scenarios:\r\n\r\n- [**@azure-tools/typespec-azure-core:**](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-core) Provides core models and interfaces for Azure service modelling\r\n- [**@azure-tools/typespec-azure-resource-manager:**](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager) Provides additional models and interfaces for modelling Azure Resource Manager services\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](./typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#values.md\n- document_title: Values\n- document_link: https://typespec.io/docs/language-basics/values\n- document_content: # language-basics#values.md\n\n# Values\n\nTypeSpec can define values in addition to types. Values are useful in an API description to define default values for types or provide example values. They are also useful when passing data to decorators, and for template parameters that are ultimately passed to decorators or used as default values.\r\n\r\nValues cannot be used as types, and types cannot be used as values, they are completely separate. However, string, number, boolean, and null literals can be either a type or a value depending on context (see also [scalar literals](#scalar-literals)). Additionally, union and enum member references may produce a type or a value depending on context (see also [enum member &amp; union variant references](#enum-member--union-variant-references)).\n\n## Value kinds\n\nThere are four kinds of values: objects, arrays, scalars, and null. These values can be created with object values, array values, scalar values and initializers, and the null literal respectively. Additionally, values can result from referencing enum members and union variants.\n\n### Object values\n\nObject values use the syntax `#{}` and can define any number of properties. For example:\r\n\r\n```typespec\r\nconst point = #{ x: 0, y: 0 };\r\n```\r\n\r\nThe object value's properties must refer to other values. It is an error to reference a type.\r\n\r\n```typespec\r\nconst example = #{\r\n  prop1: #{ nested: true }, // ok\r\n  prop2: {\r\n    nested: true,\r\n  }, // error: values can't reference a type\r\n  prop3: string, // error: values can't reference a type\r\n};\r\n```\n\n### Array values\n\nArray values use the syntax `#[]` and can define any number of items. For example:\r\n\r\n```typespec\r\nconst points = #[#{ x: 0, y: 0 }, #{ x: 1, y: 1 }];\r\n```\r\n\r\nAs with object values, array values cannot contain types.\r\n\r\nIf an array type defines a minimum and maximum size using the `@minValue` and `@maxValue` decorators, the compiler will validate that the array value has the appropriate number of items. For example:\r\n\r\n```typespec\r\n/** Can have at most 2 tags */\r\n@maxItems(2)\r\nmodel Tags is Array<string>;\r\n\r\nconst exampleTags1: Tags = #[\"TypeSpec\", \"JSON\"]; // ok\r\nconst exampleTags2: Tags = #[\"TypeSpec\", \"JSON\", \"OpenAPI\"]; // error\r\n```\n\n### Scalar values\n\nScalar initializers create scalar values by calling an initializer with one or more values. Scalar initializers for types extended from `numeric`, `string`, and `boolean` are called by adding parenthesis after the scalar reference:\r\n\r\n```typespec\r\nconst n = int8(100);\r\nconst s = string(\"hello\");\r\n```\r\n\r\nAny scalar can additionally be declared with named initializers that take one or more value parameters. For example, `utcDateTime` provides a `fromISO` initializer that takes an ISO string. Named scalars can be declared like so:\r\n\r\n```typespec\r\nscalar ipv4 extends string {\r\n  init fromInt(value: uint32);\r\n}\r\n\r\nconst ip = ipv4.fromInt(2341230);\r\n```\r\n\r\n#### Null values\r\n\r\nNull values are created with the `null` literal.\r\n\r\n```typespec\r\nconst value: string | null = null;\r\n```\r\n\r\nThe `null` value, like the `null` type, doesn't have any special behavior in the TypeSpec language. It is just the value `null` like that in JSON.\n\nThere are two ways to create scalar values: with a literal syntax like `\"string value\"`, and with a scalar initializer like `utcDateTime.fromISO(\"2020-12-01T12:00:00Z\")`.\r\n\r\n#### Scalar literals\r\n\r\nThe literal syntax for strings, numerics, booleans and null can evaluate to either a type or a value depending on the surrounding context of the literal. When the literal is in _type context_ (a model property type, operation return type, alias definition, etc.) the literal becomes a literal type. When the literal is in _value context_ (a default value, property of an object value, const definition, etc.), the literal becomes a value. When the literal is in an _ambiguous context_ (e.g. an argument to a template or decorator that can accept either a type or a value) the literal becomes a value. The `typeof` operator can be used to convert the literal to a type in such ambiguous contexts.\r\n\r\n```typespec\r\n// Sample decorator signatures. They have no backing implementation and shown here for demonstration purposes.\r\nextern dec setNumberValue(target: unknown, color: valueof numeric);\r\nextern dec setNumberType(target: unknown, color: numeric);\r\nextern dec setNumberTypeOrValue(target: unknown, color: numeric | (valueof numeric));\r\n\r\n@setNumberValue(123) // Passes the scalar value `numeric(123)`.\r\n@setNumberType(123) // Passes the numeric literal type 123.\r\n@setNumberTypeOrValue(123) // passes the scalar value `numeric(123)`.\r\nmodel A {}\r\n```\r\n\r\n#### Scalar initializers\r\n\r\nScalar initializers create scalar values by calling an initializer with one or more values. Scalar initializers for types extended from `numeric`, `string`, and `boolean` are called by adding parenthesis after the scalar reference:\r\n\r\n```typespec\r\nconst n = int8(100);\r\nconst s = string(\"hello\");\r\n```\r\n\r\nAny scalar can additionally be declared with named initializers that take one or more value parameters. For example, `utcDateTime` provides a `fromISO` initializer that takes an ISO string.\n\n## Const declarations\n\nConst declarations allow storing values in a variable for later reference. Const declarations have an optional type annotation. When the type annotation is absent, the type is inferred from the value by constructing an exact type from the initializer.\r\n\r\n```typespec\r\nconst stringValue: string = \"hello\";\r\n//      ^-- type: string\r\n\r\nconst oneValue = 1;\r\n//      ^-- type: 1\r\n\r\nconst objectValue = #{ x: 0, y: 0 };\r\n//      ^-- type: { x: 0, y: 0 }\r\n```\n\n## The `typeof` operator\n\nThe `typeof` operator returns the declared or inferred type of a value reference. Note that the actual value being stored by the referenced variable may be more specific than the declared type of the value. For example, if a const is declared with a union type, the value will only ever store one specific variant at a time, but typeof will give you the declared union type.\r\n\r\n```typespec\r\nconst stringValue: string = \"hello\";\r\n// typeof stringValue returns `string`.\r\n\r\nconst oneValue = 1;\r\n// typeof oneValue returns `1`\r\n\r\nconst stringOrOneValue: string | 1 = 1;\r\n// typeof stringOrOneValue returns `string | 1`\r\n```\n\n## Validation\n\nTypeSpec will validate values against built-in validation decorators like `@minLength` and `@maxValue`.\r\n\r\n```typespec\r\n@maxLength(3)\r\nscalar shortString extends string;\r\n\r\nconst s1: shortString = \"abc\"; // ok\r\nconst s2: shortString = \"abcd\"; // error:\r\n\r\nmodel Entity {\r\n  a: shortString;\r\n}\r\n\r\nconst e1: Entity = #{ a: \"abcd\" }; // error\r\n```\n\n## Enum member &amp; union variant references\n\nReferences to enum members and union variants can be either types or values and follow the same rules as scalar literals. When an enum member reference is in _type context_, the reference becomes an enum member type. When in _value context_ or _ambiguous context_ the reference becomes the enum member's value.\r\n\r\n```typespec\r\nextern dec setColorValue(target: unknown, color: valueof string);\r\nextern dec setColorMember(target: unknown, color: Reflection.EnumMember);\r\n\r\nenum Color {\r\n  red,\r\n  green,\r\n  blue,\r\n}\r\n\r\n@setColorValue(Color.red) // same as passing the literal \"red\"\r\n@setColorMember(Color.red) // passes the enum member Color.red\r\nmodel A {}\r\n```\r\n\r\nWhen a union variant reference is in _type context_, the reference becomes the type of the union variant. When in _value context_ or _ambiguous context_ the reference becomes the value of the union variant. It is an error to refer to a union variant whose type is not a literal type.\r\n\r\n```typespec\r\nextern dec setColorValue(target: unknown, color: valueof string);\r\nextern dec setColorType(target: unknown, color: string);\r\n\r\nunion Color {\r\n  red: \"red\",\r\n  green: \"green\",\r\n  blue: \"blue\",\r\n  other: string,\r\n}\r\n\r\n@setColorValue(Color.red) // passes the scalar value `string(\"red\")`\r\n@setColorValue(Color.other) // error, trying to pass a type as a value.\r\n@setColorType(Color.red) // passes the string literal type `\"red\"`\r\nmodel A {}\r\n```\n", "latency": 9.040732383728027, "response_length": 876}
{"query": "title: Updating enum with an arbitrary string\n\nquestion: Hi team, this is the type spec definition for my resource: azure-rest-api-specs-pr/specification/impact/Impact.Management/connectors.tsp at RPSaaSMaster  Azure/azure-rest-api-specs-pr\nconnectorType is one of the properties of this resource. This property is defined as an enum with only one value.\nOur expectation is updating this property with a value not present in the enum should throw an error. But we see that customers are able to update this property with a PATCH http call. We haven't implemented any additional logic for PATCH. RPaaS handles patch calls with default logic.\nPlease help me understand the reason why updating the property with random values is allowed even when I define the property to be an enum\nReplicating the issue locally:", "ground_truth": "You defined this property as an open union: azure-rest-api-specs-pr/specification/impact/Impact.Management/connectors.tsp at RPSaaSMaster  Azure/azure-rest-api-specs-pr.  This explicitly allows any string value.\nGenerally, the reason for doing this is that you think additional values will be enabled in future versions (or even in this version).  Note that, if you do not make this an open union, then adding any values in any future api-version would be a breaking change (which is why this is recommended).\nAs to what kind of validation is done over the spec, the RPaaS team is the one to ask about it, however, there are RPaaS extensions for validation that would allow you to reject requests for values that are not valid.", "response": "The issue arises because TypeSpec enums are closed by default, meaning they do not allow arbitrary values outside the defined set. However, Azure services favor extensible enums to avoid breaking changes when new values are added. If your `connectorType` property is defined as a strict enum, it will not enforce validation against arbitrary values unless additional logic is implemented. To ensure that arbitrary values are rejected, you should use a union type with the base scalar (e.g., `string`) as a variant instead of an enum. This approach allows extensibility while maintaining validation.\n\nFor example, instead of defining `connectorType` as:\n```tsp\nenum ConnectorType {\n  TypeA,\n}\n```\nYou should define it as:\n```tsp\nunion ConnectorType {\n  TypeA: \"TypeA\",\n  string,\n}\n```\nThis ensures that the property can accept predefined values (`TypeA`) and reject arbitrary strings unless explicitly allowed. Additionally, you may need to verify that RPaaS is correctly enforcing validation rules for PATCH operations.", "context": "- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-enum.md\n- document_title: no-enum\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n- document_content: # libraries#azure-core#rules#no-enum.md\n\n# no-enum\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-enum\r\n```\r\n\r\nAzure services favor extensible enums to avoid breaking changes as new enum values are added. TypeSpec enums are closed.\r\nUsing a union with the base scalar(`string`, `int32`, `int64`, etc.) as a variant instead of an enum makes it extensible.\r\n\r\n####  Incorrect\r\n\r\n```tsp\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\r\n\r\nOk. Enum is allowed for versioning purposes.\r\n\r\n```tsp\r\nenum Version {\r\n  2021_01_01: \"2021-01-01\",\r\n  2022_01_01: \"2022-01-01\",\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#enum-not-extensible.md\n- document_title: My enums are not extensible anymore\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/enum-not-extensible\n- document_content: # troubleshoot#enum-not-extensible.md\n\n# My enums are not extensible anymore\n\n## Symptoms\n\nI had an enum that used to generate `x-ms-enum.modelAsString: true` but now it is generating as `x-ms-enum.modelAsString: false` and I see a warning message `@azure-tools/typespec-azure-core/no-enum`\n\n## Cause\n\nAzure stopped treating enums as extensible.\n\n## Workaround\n\nTo define an extensible enum you will need instead to use a `union` where one of the variants is `string`.\r\nIf you see the linter warning [`@azure-tools/typespec-azure-core/no-enum`](https://tspwebsitepr.z22.web.core.windows.net/typespec-azure/prs/389/docs/next/libraries/azure-core/rules/no-enum) it also offers an automatic codefix (click the () bulb in VS Code)\r\nFor example\r\n\r\n```tsp\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\nshould be converted to\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#visibility.md\n- document_title: Visibility\n- document_link: https://typespec.io/docs/language-basics/visibility\n- document_content: # language-basics#visibility.md\n\n# Visibility\n\n**Visibility** is a language feature that allows you to share a model between multiple operations and define in which contexts\r\nproperties of the model are \"visible.\" Visibility is a very powerful feature that allows you to define different \"views\"\r\nof a model within different operations or contexts.\r\n\r\n**Note** : Enum-based visibility as described in this document _replaces_ visibility strings that you may have used\r\nin the past. The system is backwards-compatible with visibility strings, but you should use enum-based visibility for\r\nnew specifications. String-based visibility (e.g. `@visibility(\"create\")`) may be deprecated and removed in future\r\nversions of TypeSpec.\n\n## Basic concepts\n\n- Visibility applies to _model properties_ only. It is used to determine when an emitter should include or exclude a\r\n  property in a certain context.\r\n- Visibility is defined using a _visibility class_. A visibility class is an `enum` that defines the visibility modifiers\r\n  (or flags) that can be applied to a property. Any `enum` can serve as a visibility class.\r\n- Visibility classes have a _default_ visibility, which is the set of visibility modifiers that are applied _by default_\r\n  to a property if the visibility is not explicitly set.\n\n## Lifecycle visibility\n\nschema:\r\n                $ref: \"#/components/schemas/Example\"\r\n    patch:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/ExampleUpdate\"\r\ncomponents:\r\n  schemas:\r\n    Example:\r\n      type: object\r\n      required:\r\n        - id\r\n        - name\r\n        - description\r\n      properties:\r\n        id:\r\n          type: string\r\n          readOnly: true\r\n        name:\r\n          type: string\r\n        description:\r\n          type: string\r\n    ExampleUpdate:\r\n      type: object\r\n      properties:\r\n        description:\r\n          type: string\r\n```\r\n\r\nNotice:\r\n\r\n- The `id` property is marked `readOnly: true` because it is only visible when reading the resource.\r\n- The `ExampleUpdate` schema only includes the `description` property because it is the only property that is visible\r\n  when updating the resource.\r\n- Each of the `paths` reference the correct schema based on the lifecycle phase that the operations use.\r\n- The TypeSpec model is only defined _once_, and any changes in the output schemas are derived from the lifecycle\r\n  visibility of the properties in the model.\n\nTypeSpec provides a built-in visibility called \"resource lifecycle visibility.\" This visibility allows you to declare\r\nwhether properties are visible when passing a resource to or reading a resource from an API endpoint. For example:\r\n\r\n```typespec\r\nmodel Example {\r\n  /**\r\n   * The unique identifier of this resource.\r\n   *\r\n   * The ID is automatically generated by the service, so it cannot be set when the resource is created or updated,\r\n   * but the server will return it when the resource is read.\r\n   */\r\n  @visibility(Lifecycle.Read)\r\n  id: string;\r\n\r\n  /**\r\n   * The name of this resource.\r\n   *\r\n   * The name can be set when the resource is created, but may not be changed.\r\n   */\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  /**\r\n   * The description of this resource.\r\n   *\r\n   * By default, properties are visible in all lifecycle phases, so this property\r\n   * is present in all lifecycle phases.\r\n   */\r\n  description: string;\r\n}\r\n```\r\n\r\nIn the above example, each property of the `Example` model has a lifecycle visibility that instructs emitters to include\r\nor exclude the property when creating, updating, or reading the `Example` resource.\r\n\r\nTypeSpec's HTTP library, OpenAPI emitter, and other standard functionality use the `Lifecycle` visibility to create\r\ndifferent views of the `Example` model based on which lifecycle phase is used in a particular operation.\r\n\r\nIn the following example, the type of the input and output of each operation is affected by the lifecycle visibility\r\nof the properties in the `Example` model.\r\n\r\n```typespec\r\n@route(\"/example\")\r\ninterface Examples {\r\n  /**\r\n   * When an operation uses the POST verb, it uses the `Create` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @post create(@body example: Example): Created<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the GET verb, it uses the `Read` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\n\nby the lifecycle visibility\r\nof the properties in the `Example` model.\r\n\r\n```typespec\r\n@route(\"/example\")\r\ninterface Examples {\r\n  /**\r\n   * When an operation uses the POST verb, it uses the `Create` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @post create(@body example: Example): Created<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the GET verb, it uses the `Read` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @get read(@path id: string): Ok<Example> | Error;\r\n\r\n  /**\r\n   * When an operation uses the PATCH verb, it uses the `Update` lifecycle visibility to determine which properties\r\n   * are visible.\r\n   */\r\n  @patch update(@path id: string, @body example: Example): Ok<Example> | Error;\r\n}\r\n```\r\n\r\nThe above interface generates the following OpenAPIv3 schemas:\r\n\r\n```yml\r\npaths:\r\n  /example:\r\n    post:\r\n      parameters: []\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\r\n              $ref: \"#/components/schemas/Example\"\r\n  /example/{id}:\r\n    get:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n    patch:\r\n      parameters:\r\n        - name: id\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: string\r\n      responses:\r\n        \"200\":\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/Example\"\r\n      requestBody:\r\n        required: true\r\n        content:\r\n          application/json:\r\n            schema:\n\n### Lifecycle modifiers\n\nThe following visibility modifiers are available in the `Lifecycle` visibility class:\r\n\r\n- `Create`: The property is visible when the resource is created. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `POST` operation.\r\n- `Read`: The property is visible when the resource is read. This visibility is checked, for example, when a property is\r\n  returned in an HTTP `GET` operation.\r\n- `Update`: The property is visible when the resource is updated. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `PATCH` or `PUT` operation.\r\n- `Delete`: The property is visible when a resource is deleted. This visibility is checked, for example, when a property\r\n  is a parameter in an HTTP `DELETE` operation.\r\n- `Query`: The property is visible when a resource is passed as a parameter in a query. This visibility is checked, for\r\n  example, when a property is a parameter in an HTTP `GET` operation (**this should not be confused with an HTTP query\r\n  parameter defined using `@query`**).\n\n### Lifecycle visibility transforms\n\nYou can explicitly compute the shape of a model within a _specific_ lifecycle phase by using the four built-in\r\ntemplates for lifecycle transforms:\r\n\r\n- `Create<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Create` lifecycle\r\n  phase, recursively.\r\n- `Read<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Read` lifecycle phase,\r\n  recursively.\r\n- `Update<T extends Model>`: creates a copy of `T` with only the properties that are visible in the `Update` lifecycle\r\n  phase, with the types of the properties set to `CreateOrUpdate<T>`, recursively.\r\n- `CreateOrUpdate<T>`: creates a copy of `T` with only the properties that have _either_ the `Create` or `Update`\r\n  visibility modifiers enabled, recursively.\r\n- `Delete<T>`: creates a copy of `T` with only the properties that have the `Lifecycle.Delete` modifier enabled,\r\n  recursively.\r\n- `Query<T>`: creates a copy of `T` with only the properties that have the `Lifecycle.Query` modifier enabled,\r\n  recursively.\r\n\r\nFor example:\r\n\r\n```typespec\r\nmodel Example {\r\n  @visibility(Lifecycle.Create)\r\n  id: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  @visibility(Lifecycle.Update)\r\n  description: string;\r\n}\r\n\r\nmodel ReadExample is Read<Example>;\r\n\r\nmodel CreateExample is Create<Example>;\r\n\r\nmodel UpdateExample is Update<Example>;\r\n\r\nmodel CreateOrUpdateExample is CreateOrUpdate<Example>;\r\n```\r\n\r\nWhen you use these templates, the resulting models have no `Lifecycle` visibility modifiers applied, so that any\r\nemitters or libraries that use lifecycle visibility will not alter them further.\n\n## Visibility modifiers\n\nEach property has its own set of _active visibility modifiers_ for each visibility class. The active modifiers can be\r\nchanged using the decorators described in this section.\r\n\r\n**Note**: Changing the visibility for one visibility class _does not_ affect other visibility classes. If you change the\r\nvisibility for the `Lifecycle` visibility class, it will not affect the modifiers that are active for _any_ other\r\nvisibility classes.\n\n### `@visibility`\n\nThe `@visibility` decorator _enables_ visibility modifiers. It takes a list of visibility modifiers as arguments and\r\nsets them on the property. For example:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Create, Lifecycle.Read)\r\nname: string;\r\n```\r\n\r\nIn this example, the `name` property has the `Create` and `Read` visibility modifiers enabled.\r\n\r\nIf visibility has _already_ been set explicitly on a property, the `@visibility` decorator _ADDS_ its own visibility\r\nmodifiers to the currently-active modifiers. It does not _replace_ the existing modifiers. For example:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Create)\r\n@visibility(Lifecycle.Read)\r\nname: string;\r\n```\r\n\r\nIn this example, the `name` property has both the `Create` and `Read` visibility modifiers enabled, but _not_ the `Update`\r\nvisibility modifier. The `@visibility` decorator starts from an _empty_ set of modifiers and adds the `Create` modifier,\r\nthen adds the `Read` modifier.\n\n### `@removeVisibility`\n\nThe `@removeVisibility` decorator _disables_ visibility modifiers. It takes a list of visibility modifiers as arguments\r\nand removes them from the property. For example:\r\n\r\n```typespec\r\n@removeVisibility(Lifecycle.Update)\r\nname: string;\r\n```\r\n\r\nThis use of `@removeVisibility` is equivalent to the above examples with the `@visibility` decorator, but it uses the `@removeVisibility`\r\ndecorator to remove the `Update` visibility modifier from the `name` property rather than adding the `Create` and `Read`\r\nvisibility modifiers. The `@removeVisibility` decorator starts from the _default_ set of visibility modifiers and removes\r\nthe `Update` modifier.\r\n\r\nIf the visibility has _already_ been set on a property, the `@removeVisibility` decorator _removes_ its visibility from\r\nthe currently-active modifiers. It does not _replace_ the existing modifiers. For example:\r\n\r\n```typespec\r\n@removeVisibility(Lifecycle.Update)\r\n@removeVisibility(Lifecycle.Create)\r\nid: string;\r\n```\r\n\r\nIn this example, the `id` property has the `Update` and `Create` visibility modifiers removed, but it retains the `Read`\r\nvisibility modifier.\n\n### `@invisible`\n\nThe `@invisible` decorator _disables all visibility modifiers_ on a property within a given visibility class. For example:\r\n\r\n```typespec\r\n@invisible(Lifecycle)\r\ninvisible: string;\r\n```\r\n\r\nIn this example, the `invisible` property has _no_ visibility modifiers enabled in the `Lifecycle` visibility class.\n\n## Visibility filters\n\nThe `@withVisibilityFilter` decorator allows you to transform a model by applying a visibility filter to it. A\r\nvisibility filter is an object that defines constraints on which visibility modifiers must be enabled/disabled for a\r\nproperty to be visible. For example:\r\n\r\n```typespec\r\nmodel Example {\r\n  @visibility(Lifecycle.Create)\r\n  id: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Read)\r\n  name: string;\r\n\r\n  @visibility(Lifecycle.Update)\r\n  description: string;\r\n}\r\n\r\n@withVisibilityFilter(#{ all: [Lifecycle.Create, Lifecycle.Read] })\r\nmodel CreateAndReadExample {\r\n  ...Example;\r\n}\r\n\r\n@withVisibilityFilter(#{ any: [Lifecycle.Create, Lifecycle.Update] })\r\nmodel CreateOrUpdateExample {\r\n  ...Example;\r\n}\r\n\r\n@withVisibilityFilter(#{ none: [Lifecycle.Update] })\r\nmodel NonUpdateExample {\r\n  ...Example;\r\n}\r\n```\r\n\r\nIn the above example, the `CreateAndReadExample` model is a copy of the `Example` model with only the the properties\r\nthat have _BOTH_ the `Create` and `Read` visibility modifiers enabled (i.e. only the `name` property). The\r\n`CreateOrUpdateExample` model is a copy of the `Example` model with only the properties that have _EITHER_ the `Create`\r\nor `Update` visibility modifiers enabled (i.e. the `id` and `name` properties). The `NonUpdateExample` model is a copy\r\nof the `Example` model with only the properties that _do not_ have the `Update` visibility modifier enabled (i.e. the\r\n`id` and `name` properties).\r\n\r\n**Note**: For `Lifecycle` visibility, you should ordinarily use the `Create`, `Read`, `Update`, and `CreateOrUpdate`\r\ntemplates instead of `@withVisibilityFilter` directly, but you can use `@withVisibilityFilter` to create custom \"views\"\r\nof a model that use visibility classes other than `Lifecycle` or custom filter logic.\n\n## Visibility classes\n\nAny TypeSpec `enum` can serve as a visibility class. The members of the `enum` define the visibility modifiers in the\r\nclass. For example, the following is the definition of the `Lifecycle` visibility class defined in the TypeSpec standard\r\nlibrary:\r\n\r\n```typespec\r\nenum Lifecycle {\r\n  Create,\r\n  Read,\r\n  Update,\r\n}\r\n```\r\n\r\nThis visibility class defines three visibility modifiers: `Create`, `Read`, and `Update`. By default, all properties\r\nhave _ALL_ three visibilities in the `Lifecycle` enum enabled.\n\n### Setting default visibility\n\nYou can set the default visibility for a visibility class by declaring it on the enum using the `@defaultVisibility`\r\ndecorator:\r\n\r\n```typespec\r\n@defaultVisibility(Example.A)\r\nenum Example {\r\n  A,\r\n  B,\r\n}\r\n```\r\n\r\nIn this example, any property that does not declare an `Example` visibility modifier will have the `A` visibility by\r\ndefault.\r\n\r\n**Note**: While you can define your own visibility classes, emitters _will not recognize them_ unless they have been\r\nprogrammed to do so. You can leverage custom visibility classes in your own emitters, but they will have no effect on\r\nthe standard emitters unless those emitters choose to adopt and recognize those visibility classes as meaningful. The\r\n`Lifecycle` visibility class is a standard visibility class that is recognized by several emitters. You can, however,\r\nuse your own visibility classes with the built in `@withVisibilityFilter` decorator to transform your models in whatever\r\nways you see fit.\n", "latency": 12.510063409805298, "response_length": 1019}
{"query": "title: Urgent review for GA: Typespec regex pattern change\n\nquestion: Hi\nTypeSpec Discussion\n,\nI created a new GA version and I changed the regex pattern and it changed the pattern in older swagger jsons, which is causing a breaking change. Should I check-in only new GA swagger json or older swagger also where pattern is updated?\nIs versioning available here?\nWe plan to take this to GA and need to get signOff by end of this week. Please let me know further actions on this.\nAdded 2025-03-30 GA stable version by amritas  Pull Request #32911  Azure/azure-rest-api-specs", "ground_truth": "You want to accurately describe the constraint, which means you likely want to change it for all api-versions, or not make the change at all.  Note that, if all versions are preview, you should make the change for accuracy - generated clients do not use pattern values to validate inputs", "response": "When making changes to regex patterns in TypeSpec that result in breaking changes to older Swagger JSONs, it is recommended to use versioning to manage these changes effectively. TypeSpec provides the `@typespec/versioning` library, which allows you to describe changes to a service or library over time. This ensures that older versions remain unaffected while new versions incorporate the updated regex pattern. \n\nYou should check in both the new GA Swagger JSON and the older Swagger JSONs with the updated pattern, but ensure that versioning is applied to maintain compatibility. This approach will allow emitters to see the service representation at different versions without introducing breaking changes to older versions.\n\nTo proceed:\n1. Use the `@typespec/versioning` library to manage changes across versions.\n2. Check in both the new and older Swagger JSONs with appropriate versioning applied.\n3. Ensure that the changes are reviewed and validated to avoid unintended impacts.\n\nIf you plan to take this to GA by the end of the week, prioritize implementing versioning and testing thoroughly to ensure compatibility across versions.", "context": "- document_dir: typespec_docs\n- document_filename: handbook#reproducibility.md\n- document_title: Reproducibility\n- document_link: https://typespec.io/docs/handbook/reproducibility\n- document_content: # handbook#reproducibility.md\n\n# Reproducibility\n\nA crucial aspect of service definition is ensuring consistent output over time. This is important in scenarios such as:\r\n\r\n- An update to a dependency or sub-dependency introduces an unexpected breaking change.\r\n- Updates to a new version of a service should not impact older versions.\r\n- Modifications are made to the TypeSpec specification.\r\n\r\nThese issues can be mitigated with a few precautionary measures:\n\n## 1. Defend against dependency changes\n\n_Note: This section applies if using `tsp install` or `npm install` to install dependencies. However other package managers (`yarn`, `pnpm`, etc.) have their own similar lock mechanisms._\r\n\r\nWhen using `tsp install` or `npm install` a `package-lock.json` will be installed. This file SHOULD be committed to source control. It will ensure that later calls to `tsp install` or `npm install` will use the exact versions resolved in the lock files unless the `package.json` was updated or a command like `npm update` was run.\r\n\r\nThe command `npm ci` can also be used in the CI to ensure that the `package.json` and `package-lock.json` are in sync.\n\n## 2. Work with multiple versions of a service\n\nTypeSpec provides a library `@typespec/versioning` that can be used to describe changes to a service or library over time. Using this will ensure that a service can evolve while keeping track of the changes and allowing emitters to see the service representation at different versions.\r\n\r\n[See versioning docs](../libraries/versioning/reference/index.mdx)\n\n## 3. Change to the TypeSpec spec\n\nIf you don't directly control the spec, you might still want to make sure you remember which exact definition was used.\r\nUsing version control and pinning to a specific commit SHA will ensure that the spec will remain exactly as it was.\n\n## Summary\n\n1. Use `package-lock.json`\r\n2. Use [versioning library](../libraries/versioning/reference/index.mdx)\r\n3. Keep track of commit IDs\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#breakingchange.md\n- document_title: Resolving Swagger Breaking Change Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\n- document_content: # migrate-swagger#faq#breakingchange.md\n\n# Resolving Swagger Breaking Change Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Migrate ARM Specs\n\n### Changing the Names of Request Payload Parameters\n\nFor operations with non-empty request bodies (PUT, POST, PATCH), the TypeSpec operation templates provide a default name for the\r\nrequest parameter corresponding to the request payload. You can use augment decorators to make changes to this parameter, and other parts of the operation signature.\r\n\r\nThe following sections show how to do this for each operation template.\r\n\r\n#### CreateOrUpdate (PUT) APIs\r\n\r\nGiven a PUT operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  createOrUpdate is ArmResourceCreateOrReplaceAsync<Widget>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `resource` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.createOrUpdate::parameters.resource, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PUT operation template.\r\n\r\n#### Update (PATCH) APIs\r\n\r\nGiven a PATCH operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  update is ArmResourcePatchAsync<Widget, WidgetProperties>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `properties` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.update::parameters.properties, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PATCH operation template.\n\n### Action (POST) APIs\n\nGiven a POST operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  mungeWidget is ArmResourceActionAsync<Widget, MungeRequest, MungeResponse>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `body` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.mungeWidget::parameters.body, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ POST operation template.\n\n### Adding Request Query or Header Parameters\n\nThe `Parameters` template parameter allows you to specify additional parameters after the operation path (for example, query and header parameters) in the form of a model, with each model property corresponding to a parameter. You may use intersection to combine multiple separate parameters.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.StandardListQueryParameters\r\n>;\r\n\r\n// intersecting individual parameters\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.TopQueryParameter & Azure.Core.SkipQueryParameter\r\n>;\r\n```\n\n### Changing Response Types\n\nThe `Response` parameter allows you to specify non-error responses to the operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Response = MyCustomCollectionType>;\r\n```\n\n### Changing Error Types\n\nThe `Error` parameter allows you to change the default error type used in an operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Error = MyCustomError>;\r\n```\n\n### Converting Synchronous Operations to LROs\n\nusing the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation. It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op doStuff is ArmResourceActionAsync<Resource, ActionRequest, ActionResponse>;\r\n\r\n  // with no request body\r\n  op doStuffNoRequest is ArmResourceActionAsync<Resource, void, ActionResponse>;\r\n\r\n  // with no response body\r\n  op doStuffCommand is ArmResourceActionAsync<Resource, ActionRequest, void>;\r\n  ```\r\n\r\n#### Templates for Async DELETE Operations\r\n\r\n- `ArmResourceDeleteWithoutOKAsync` is a DELETE operation that uses no request body, will return a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op delete is ArmResourceDeleteWithoutOKAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourceDeleteAsync`iis a DELETE operation that uses no request body, and return a `200` response in the case of a successful synchronous delete, a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmResourceDeleteAsync<Resource>;\r\n  ```\n\nYou can generally choose an asynchronous operation template that matches your operation.\r\n\r\n#### Templates for Async PUT Operations\r\n\r\n- `ArmCreateOrReplaceAsync` is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Location` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrReplaceAsync<Resource>;\r\n  ```\r\n\r\n- `ArmCreateOrUpdateAsync`is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Azure-AsyncOperation` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrUpdateAsync<Resource>;\r\n  ```\r\n\r\n#### Templates for Async PATCH Operations\r\n\r\n- `ArmTagsPatchAsync` is a PATCH operation that only allows changing the resource tags (the minimum for Azure Resource Manager).\r\n\r\n  ```tsp\r\n  op update is ArmTagsPatchAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourcePatchAsync`is a PATCH operation that uses the visibility settings to select properties for the PATCH request body(any property with no visibility setting, or including visibility \"update\"). It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n", "latency": 8.28763461112976, "response_length": 1143}
{"query": "title: Description changes across versions?\n\nquestion: Hi, as part of this PR: Service Fabric Managed Clusters - API version 2025-03-01-preview  Azure/azure-rest-api-specs@599e269\nMy team wanted to add more details to a model description. This change results in a change in all spec versions generated with Typespec, and causes the Typespec validation to fail if I don't include the changes to the older specs.\nI wanted to know what the best course of action was for passing this check. Since we don't expect updates to our older specs, is it ok to just change the output path in our tspconfig.yaml to only point at the current version of the output spec? Or is there a better way to handle this?", "ground_truth": "Honestly, the best thing is to update your docs and take the update in previous versions (which are likely now more accurately described as well).  Documentation updates are not breaking changes, and, if changes are limited to documentation, this should be passed easily by the breaking change board. Documentation-only updates should not be flagged as breaking changes at all. If they are for some reason, I'll just approve it.", "response": "To address the issue of description changes across versions causing validation failures in TypeSpec, the recommended approach is to ensure that your TypeSpec represents the current state of the API while using versioning decorators to indicate changes across versions. This allows you to maintain compatibility with older versions without modifying their output paths unnecessarily.\n\nIf you don't expect updates to older specs, you can use the `@versioned` decorator to manage version-specific changes. For example, you can use decorators like `@renamedFrom` or `@madeOptional` to indicate changes in specific versions without altering the older versions' definitions. This ensures that the generated OpenAPI specifications for older versions remain consistent with their original definitions.\n\nChanging the output path in `tspconfig.yaml` to only point to the current version is not ideal unless you are certain that older versions will no longer be used or maintained. Instead, you should ensure that your TypeSpec definitions and versioning decorators accurately reflect the evolution of your API across versions. This approach aligns with best practices for versioning APIs in TypeSpec.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#lintdiff.md\n- document_title: Resolving Swagger Lint Diff Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/lintdiff\n- document_content: # migrate-swagger#faq#lintdiff.md\n\n# Resolving Swagger Lint Diff Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Resolving Swagger LintDiff Violations\n\n### `VisibilityChanged` for `nextLink` and `value` properties\n\nThe issue is that some older specifications marked these values as read only. This has no real impact on the API or client generation, but it is easy to mitigate for the whole specification. To fix, simply add the following augment decorator statements to the `main.tsp` file.\r\n\r\n```tsp\r\n@@visibility(Azure.Core.Page.value, \"read\");\r\n@@visibility(Azure.Core.Page.nextLink, \"read\");\r\n```\n\n### `ProvisioningStateMustBeReadOnly`\n\nThis violation is caused by a problem with the mechanism that ARM Api validation uses to determine if a [property is read-only. You can work around the issue by setting the `use-read-only-status-schema` configuration setting in `azure/tools/typespec-autorest` options to `true` in your `tspConfig.yaml` configuration file:\r\n\r\n```yml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n    use-read-only-status-schema: true\r\n```\n\n### `LroLocationHeader`\n\nThis violation occurs when your spec uses an LRO operation template that follows the older version of LRO standards. Tof fix the issue, you would change the operation template to match the latest recommendation.\r\n\r\n#### PUT Operations\r\n\r\n```tsp\r\n// LRO PUT template with required headers and no 200 response\r\nop createOrUpdate is ArmResourceCreateOrReplaceAsync<MyResource>;\r\n```\r\n\r\n#### PATCH Operations\r\n\r\n```tsp\r\n// LRO PATCH template with required headers, response codes, and lro options\r\nop update is ArmResourcePatchAsync<MyResource, MyResourceProperties>;\r\n```\n\n### POST(Action) Operations\n\n```tsp\r\n// LRO POST (Action) template with required headers, response codes, and lro options\r\nop doAction is ArmResourceActionAsync<MyResource, RequestModel, ResponseModel>;\r\n```\n\n### DELETE Operations\n\n```tsp\r\n// LRO delete template with required headers and no 200 response\r\nop delete is ArmResourceDeleteWithoutOKAsync<MyResource>;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#versioning#guide.md\n- document_title: Tutorial\n- document_link: https://typespec.io/docs/libraries/versioning/guide\n- document_content: # libraries#versioning#guide.md\n\n# Tutorial\n\n## Implementing versioned APIs\n\nThe primary role of the TypeSpec.Versioning library is to enable API versioning. Let's start with an API that lacks versioning.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nTo introduce versioning to this API, we need to use the `@versioned` decorator on the namespace and define an enum that outlines the supported versions.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n```\n\n## Declaring versioned dependencies\n\nBoth versioned and unversioned services can declare their dependencies on versioned TypeSpec libraries. This is achieved using the `@useDependency` decorator. For unversioned services, this is declared on the namespace. For versioned services, it's declared on the versioned enum.\r\n\r\nFor example, if our unversioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager Unversioned\" })\r\n@useDependency(Azure.Core.v1_0_Preview_1)\r\nnamespace Contoso.WidgetManager.Unversioned;\r\n```\r\n\r\nIf our versioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n}\r\n```\r\n\r\nLet's say we introduce a new version to our service, and it uses features from a newer version of the Azure.Core library. We can declare that dependency like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n\r\n  @useDependency(Azure.Core.v1_0_Preview_2)\r\n  v2,\r\n}\r\n```\n\n## Versioning APIs\n\nreflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    description:\r\n      type: string\r\n  required:\r\n    - id\r\n```\r\n\r\nHowever, the OpenAPI definition for versions 1 and 2 still reflect the original name and the mandatory nature of the property:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    name:\r\n      type: string\r\n  required:\r\n    - id\r\n    - name\r\n```\r\n\r\nThis is a common pattern with the versioning decorators. The TypeSpec should represent the _current state_ of the API. The decorators indicate the version at which this definition became accurate and, depending on the decorator, the other parameters reflect the previous values to retain that information.\n\nThe versioning library simplifies the process of versioning APIs. Let's start with a basic example. Assume we have a service with a single API that returns a list of widgets. We can define that API like this:\r\n\r\n```typespec\r\nusing Versioning;\r\nusing Rest;\r\nusing Http;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: string;\r\n  message?: string;\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\nop list(): Widget[] | Error;\r\n```\r\n\r\nNow, let's suppose that in version 2 of the service, we add a get operation to retrieve a single widget. We can add that like this:\r\n\r\n```typespec\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@route(\"/widget\")\r\nop list(): Widget[] | Error;\r\n\r\n@added(Versions.v2)\r\n@route(\"/widget/{id}\")\r\nop get(...Resource.KeysOf<Widget>): Widget | Error;\r\n```\r\n\r\nNow, let's suppose that in version 3 of the service, we realize that `name` is not accurate and that this field should be called `description`. Also, we decide that the description should be optional, not mandatory. We can implement these changes like this:\r\n\r\n```typespec\r\nmodel Widget {\r\n  @key\r\n  widgetId: string;\r\n\r\n  @renamedFrom(Versions.v3, \"name\")\r\n  @madeOptional(Versions.v3)\r\n  description?: string;\r\n}\r\n```\r\n\r\nWe made the change to the actual model property so that it now reflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n", "latency": 10.289634466171265, "response_length": 1190}
{"query": "title: Entity Framework Emitter?\n\nquestion: Has anyone built an Entity Framework Emitter?    I'm thinking it emits a DbContext and implementation of the http-server-csharp emitter.", "ground_truth": "I don't know enough (anything) about entity framework, but would be happy to discuss.  Would want to determine if this is a separate emitter, a configuration option (like asp.net web app versus minimal api), or something else.\nIt is definitely on the radar to think about various kinds of back ends to an emitted asp.net service", "response": "Yes, the `@typespec/http-server-csharp` emitter can generate a DbContext-like structure and server-side implementation for C# projects based on TypeSpec definitions. While it doesn't directly emit an Entity Framework DbContext, it generates models, controllers, and interfaces that can be integrated with Entity Framework for database operations. The emitter also supports scaffolding a fully functional .NET 9 project with mock implementations, which can be customized to include database logic using Entity Framework. You can use the `--emit-mocks` option to generate mock implementations and project files, and then integrate your database logic into the generated business logic interfaces.", "context": "- document_dir: typespec_docs\n- document_filename: emitters#servers#http-server-csharp#reference#emitter.md\n- document_title: Emitter usage\n- document_link: https://typespec.io/docs/emitters/servers/http-server-csharp/reference/emitter\n- document_content: # emitters#servers#http-server-csharp#reference#emitter.md\n\n# Emitter usage\n\n## Usage\n\n1. Via the command line\r\n\r\n```bash\r\ntsp compile . --emit=@typespec/http-server-csharp\r\n```\r\n\r\n2. Via the config\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-server-csharp\"\r\n```\r\n\r\nThe config can be extended with options as follows:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-server-csharp\"\r\noptions:\r\n  \"@typespec/http-server-csharp\":\r\n    option: value\r\n```\n\n## Emitter options\n\n### `emitter-output-dir`\n\n**Type:** `absolutePath`\r\n\r\nDefines the emitter output directory. Defaults to `{output-dir}/@typespec/http-server-csharp`\r\nSee [Configuring output directory for more info](https://typespec.io/docs/handbook/configuration/configuration/#configuring-output-directory)\n\n### `skip-format`\n\n**Type:** `boolean`\r\n\r\nSkips formatting of generated C# Types. By default, C# files are formatted using 'dotnet format'.\n\n### `output-type`\n\n**Type:** `\"models\" | \"all\"`\r\n\r\nChooses which service artifacts to emit. choices include 'models' or 'all' artifacts.\n\n### `emit-mocks`\n\n**Type:** `\"mocks-and-project-files\" | \"mocks-only\" | \"none\"`\r\n\r\nEmits mock implementations of business logic, setup code, and project files, enabling the service to respond to requests before a real implementation is provided\n\n### `use-swaggerui`\n\n**Type:** `boolean`\r\n\r\nConfigure a Swagger UI endpoint in the development configuration\n\n### `openapi-path`\n\n**Type:** `string`\r\n\r\nUse openapi at the given path for generating SwaggerUI endpoints. By default, this will be 'openapi/openapi.yaml' if the 'use-swaggerui' option is enabled.\n\n### `overwrite`\n\n**Type:** `boolean`\r\n\r\nWhen generating mock and project files, overwrite any existing files with the same name.\n\n### `project-name`\n\n**Type:** `string`\r\n\r\nThe name of the generated project.\n\n### `http-port`\n\n**Type:** `number`\r\n\r\nThe service http port when hosting the project locally.\n\n### `https-port`\n\n**Type:** `number`\r\n\r\nThe service https port when hosting the project locally.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#servers#http-server-csharp#project.md\n- document_title: About Generated Projects\n- document_link: https://typespec.io/docs/emitters/servers/http-server-csharp/project\n- document_content: # emitters#servers#http-server-csharp#project.md\n\n# About Generated Projects\n\n**This package is highly experimental and may be subject to breaking changes and bugs.** Please expect that your code may need to be updated as this package evolves, and please report any issues you encounter.\n\n## Layout\n\nThe code layout inside the 'generated' folder is as follows:\r\n\r\n- **generated**\r\n\r\n  - **controllers**: A set of ASP.Net core MVC controllers representing the operations in the spec, one for each interface or namespace with operations\r\n  - **lib**: A set of library files used in implementing generated models and controllers\r\n  - **models**: A set of models, each serving one of two distinct purposes:\r\n    - Request/Response Models: Represent the data used in requests and responses.\r\n    - Exception Models: Represent errors. These models inherit from `HttpServiceException` and are designed to encapsulate error details, making them suitable for throwing and handling exceptions.\r\n  - **operations**: A set of interfaces called by the controllers, that should be implemented with the business logic for each operation.\r\n\r\n  You should recompile whenever you make changes in your TypeSpec and these files will be replaced inline to reflect the spec changes, without changing any of your hand-written implementation in the project.\n\n## Scaffolding\n\nIf you use the scaffolding cli (hscs-scaffold) or use the `--emit-mocks \"mocks-and-project-files\"` option on compilation, a fully-functional .Net 9 project will be created with mock implementations of your business\r\nlogic, ready to compile and run.\r\n\r\nThe following additional files will be generated. It is expected that you will edit or replace these\r\nfiles as you implement your service, so you should only regenerate them when needed.\r\nTo protect from inadvertently changing any edits you may have made to these files,\r\nthese files will be overwritten by the emitter unless you specify the `--overwrite` option.\r\n\r\n- **ServiceProject.csproj**: The project file\r\n- **Program.cs**: Entry point that sets up the app\r\n- **appSettings.Development.json**: Configuration settings for the development environment\r\n- **appSettings.json**: Configuration settings for the production environment\r\n- **Properties**\r\n  - **launchSettings.json**: Launch configurations for the service (including local ports)\r\n- **mocks**: Simple implementations of business logic interfaces that return simple responses.\r\n  this allows testing your service out before writing any implementation code.\r\n\r\n  - **MockRegistration.cs**: Called from the Program.cs startup, registers each of the business\r\n    logic implementations in the dependency injection container.\r\n  - **IInitializer.cs**: Interface used in the mocks to create responses.\r\n  - **Initializer.cs**: Implementation of the interface to create mock responses.\n\n### Generating a Project and Mock Implementations using `tsp compile`\n\nIf you downloaded the `tsp` standalone component and you don't have `node` and `npm` installed, you will not be able to use the `hscs-scaffold` command to create an ASP.Net project. Instead, you can use compiler options, for example, the following command will create a new project using the TypeSpec in the current directory, enabling SwaggerUI, and overwriting any existing mocks or project files:\r\n\r\n```bash\r\ntsp compile . --emit @typespec/http-server-csharp --emit @typespec/openapi3 --option @typespec/http-server-csharp.emit-mocks=emit-mocks-and-project-files --option @typespec/http-server-csharp.use-swaggerui=true --option @typespec/http-server-csharp.overwrite=true\r\n```\r\n\r\nOnce you have customized the project, you can generate new mocks for any new APIs while leaving existing implementations unchanged using:\r\n\r\n```bash\r\ntsp compile . --emit @typespec/http-server-csharp --option @typespec/http-server-csharp.emit-mocks=mocks-only\r\n```\n\n## SwaggerUI\n\nIf you include the `@typespec/openapi3` emitter in your typespec project, you can include a\r\nSwaggerUI endpoint in the generated service using the `--use-swaggerui` option. This endpoint\r\nprovides a visual representation of operations and provides a web GUI client connected to the service that you can use right away to try out service operations.\n\n## How Components Work Together\n\n### Controllers\n\nThe generated controllers automatically listen at the routes you specified in TypeSpec. Controllers perform validation of input requests, call your implementation of business logic interfaces to perform the operation, and return the appropriate Http response.\n\n### Business Logic Interfaces\n\nYou must implement business loginc interfaces to perform the work of each operation. There is one\r\nbusiness logic interface for each `interface` type in your spec, or for each namespace that contain operations. Business logic can assume that input types meet the constraints specified in TypeSpec and are responsible for returning the response type for the operation.\r\n\r\nYou can use the `--emit-mocks` option to emit mock implementations of your business logic, these mocks demonstrate a simple implementation that returns responses that match the response type in TypeSpec. They also show how to use `IHttpContextAccessor` to access additional details of the Http request and response.\n\n### Discovery using the ASP.Net Core Dependency Injection Container\n\nThe Controllers find your business logic implementation through the ASP.Net dependency injection container. At server start, you register each of your implementations with the dependency injection container and they will automatically be instantiated and used by the controllers.\r\n\r\nIf you use the `--emit-mocks` option, sample code registering mock implementations is emitted to `mocks/MockRegistration.cs`.\n\n### Models\n\nModel classes represent the data passed in Http requests and response and the data that passes from the front end controllers to your business logic.\r\n\r\nModels are partial, so you can add additional members for internal usage as needed by putting a partial class definition with additional members outside the `generated` folder in your project.\n\n### Next Steps\n\nAfter successful generation, you should:\r\n\r\n- Use the SwaggerUI endpoint to test out the running service\r\n- Implement the business logic interfaces for your operations\r\n- Update MockRegistration.cs, or register each of your interfaces as part of application startup\r\n- Update configuration to suit your needs\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-csharp.md\n- document_title: Code Generation - C#\n- document_link: https://typespec.io/docs/getting-started/code-generation-csharp\n- document_content: # getting-started#code-generation-csharp.md\n\n# Code Generation - C#\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for C#\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the C# server emitter.\n\n## Prerequisites\n\n- .NET 9 installed (required for C# server code generation)\r\n- Node.js and npm (for the installation method)\r\n- Basic familiarity with TypeSpec\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"C# Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-csharp\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-csharp\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates C# server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hscs-scaffold . --use-swaggerui --overwrite\r\n```\r\n\r\n> **Note about `npx`**: The `npx` command executes binaries from your local node_modules directory. This ensures you're using the version of the scaffold tool installed in your project, which is especially useful if you have multiple TypeSpec projects with different versions.\r\n\r\nThe `--use-swaggerui` flag adds a Swagger UI endpoint to your generated service. This is useful during development as it allows you to interact with your API directly from a browser.\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n- Where to access the Swagger UI\r\n\r\nYou'll see output similar to this:\r\n\r\n```\r\nYour project was successfully created at \"tsp-output/server/aspnet\"\r\n\r\nYou can build and start the project using 'dotnet run --project \"tsp-output/server/aspnet\"'\r\nYou can browse the swagger UI to test your service using 'start https://localhost:7348/swagger/'\r\n```\n\n## 5. Running your service\n\nRun the generated service using the following command:\r\n\r\n```bash\r\ndotnet run --project \"tsp-output/server/aspnet\"\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `https://localhost:<port>/swagger` in your browser, replacing `<port>` with the port listed in the console output, which in the example above is `7348`.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe scaffolded code is organized into two main categories:\n\n### Generated files (don't modify directly)\n\nLocated in the `generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition:\r\n\r\n- **Controllers**: Front-end API endpoints that receive HTTP requests\r\n\r\n  - Example: `WidgetsController.cs` handles requests to `/widgets`\r\n  - Each controller method maps to an operation in your TypeSpec interface\r\n\r\n- **Operations interfaces**: Definitions for your business logic\r\n\r\n  - Example: `IWidgets.cs` defines methods like `ListWidgetsAsync()`\r\n  - These interfaces are what your implementation will need to fulfill\r\n\r\n- **Models**: Data structures for requests and responses\r\n  - Example: `Widget.cs`, `WidgetList.cs`\r\n  - These directly represent the models defined in your TypeSpec\n\n### Customizable files\n\nThese files are intended for you to modify with your implementation:\r\n\r\n- **Implementation classes**: Mock implementations of your operations interfaces\r\n\r\n  - Example: `Widgets.cs` is where you'll add your business logic\r\n  - The emitter generates these with mock implementations that return syntactically correct responses\r\n  - These files **won't be overwritten** when you recompile, preserving your business logic\r\n\r\n- **Program.cs**: Application entry point and service configuration\r\n\r\n- **MockRegistration.cs**: Dependency injection configuration\r\n  - This file connects your implementation classes to the controller interfaces\r\n  - If you create custom service classes, you'll register them here\n\n## 7. Understanding the dependency injection system\n\nThe generated C# service uses ASP.NET Core's dependency injection system to connect controllers with your business logic:\r\n\r\n1. Controllers defined in the `generated` folder depend on interface types (like `IWidgets`)\r\n2. Your implementation classes (like `Widgets`) implement these interfaces\r\n3. The `MockRegistration.cs` file registers your implementations with the dependency injection container\r\n4. When a request comes in, the controller receives it and calls your implementation\r\n\r\nIf you need to register additional services or dependencies, you would add them to the `MockRegistration.cs` file.\n\n## 8. Adding your business logic\n\n1. Locate the implementation file for your service (e.g., `Widgets.cs`)\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```csharp\r\npublic async Task<Widget[]> ListAsync()\r\n{\r\n    // Replace the mock implementation with your actual database query\r\n    return new Widget[]\r\n    {\r\n        new Widget { Id = \"1\", Weight = 10, Color = \"red\" },\r\n        new Widget { Id = \"2\", Weight = 15, Color = \"blue\" }\r\n    };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (controllers, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp\r\n```\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`CategoriesController.cs`, `ICategories.cs`, and `CategoriesImpl.cs`)\r\n- It won't overwrite your existing `Widgets.cs` with your custom business logic\r\n- This allows you to incrementally add new resources without losing your existing implementations\n\n## 10. Advanced customization options\n\nWhen scaffolding your service, you can use additional options for customization:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp --help\r\n```\r\n\r\nSome useful options include:\r\n\r\n- `--project-name <name>`: Set a custom project name\r\n- `--https-port <port>`: Set a different HTTPS port\r\n- `--output <path>`: Generate files to a different location\r\n- `--overwrite`: Overwrite existing files (use with caution)\r\n  - Normally, implementation files that already exist won't be overwritten\r\n  - Use this flag if you want to reset your implementations back to the generated mock versions\n\n## Next steps\n\n- Explore the included README and documentation in the `docs` folder of your generated project\r\n- Add authentication mechanisms to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\n", "latency": 9.585764169692993, "response_length": 694}
{"query": "title: Response body for ResourceCreateWithServiceProvidedName?\n\nquestion: Quick question for the typespec experts:\nIs it possible to have a response body for ResourceCreateWithServiceProvidedName operation? We don't want a put or patch operation so the other options (ResourceCreateOrUpdate and ResourceCreateOrReplace) dont seem to be a good fit.", "ground_truth": "The pattern for that template matches the guidelines for POST create of a resource - if you are planning something else, you should review your plans with the api vreview board", "response": "Yes, it is possible to have a response body for the `ResourceCreateWithServiceProvidedName` operation in TypeSpec. While the operation itself is not explicitly listed in the provided documentation, you can define a custom operation template using the `ArmResourceCreatedResponse<T>` response type for synchronous creation or `ArmResourceCreatedSyncResponse<T>` for asynchronous creation. These response types allow you to specify the response body for a resource creation operation. For example:\n\n```typespec\n@post\nop createResourceWithServiceProvidedName(@body resource: ResourceInput): ArmResourceCreatedResponse<ResourceOutput> | ErrorResponse;\n```\n\nHere, `ResourceInput` represents the request body model, and `ResourceOutput` represents the response body model. This approach aligns with ARM guidelines for resource creation responses.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-operations.md\n- document_title: ARM Resource Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations\n- document_content: # howtos#arm#resource-operations.md\n\n# ARM Resource Operations\n\n## Recommended and Required Operations\n\n### TrackedResource\n\n| Operation             | Recommended | Required | TypeSpec Representation                                          |\r\n| --------------------- | ----------- | -------- | ---------------------------------------------------------------- |\r\n| GET                   | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                              |\r\n| CreateOrUpdate (PUT)  | Yes         | Yes      | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`    |\r\n| Tags Update (PATCH)   | No          | Yes\\*    | `update is ArmResourceTagsPatchSync<Resource>;`                  |\r\n| Full Update (PATCH)   | Yes         | No\\*     | `update is ArmCustomPatchSync<Resource, PatchRequest>;`          |\r\n| Delete                | Yes         | Yes      | `delete is ArmResourceDeleteSync<Resource>;`                     |\r\n| List by ResourceGroup | Yes         | Yes      | `listByResourceGroup is ArmResourceListByParent<Resource>;`      |\r\n| List by Subscription  | Yes         | Yes      | `listBySubscription is ArmResourceListBySubscription<Resource>;` |\r\n\r\n\\* Arm requires that, at minimum, a TrackedResource can update Tags. A Full PATCH of all updateable resource properties is preferred.\n\n### Proxy Resource\n\n| Operation            | Recommended | Required | TypeSpec Representation                                       |\r\n| -------------------- | ----------- | -------- | ------------------------------------------------------------- |\r\n| GET                  | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                           |\r\n| CreateOrUpdate (PUT) | Yes         | No\\*     | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;` |\r\n| Update (PATCH)       | Yes         | No       | `update is ArmCustomPatchSync<Resource, PatchRequest>;`       |\r\n| Delete               | Yes         | No\\*     | `delete is ArmResourceDeleteSync<Resource>;`                  |\r\n| List by Parent       | Yes         | Yes      | `listByParent is ArmResourceListByParent<Resource>;`          |\r\n\r\n\\* Note that, if a resource implements Create, it is highly recommended that it implement delete as well, and vice-versa.\n\n## TypeSpec Operation Templates and Interface Templates\n\nTypeSpec provide operation templates that describe the request and response of standard resource operations. A description of the options available for each resource template, and how to choose which one is described in the sections below.\n\n### Synchronous and Asynchronous APIs\n\nCreateOrUpdate (PUT), Update (Patch), Delete, and Action (POST) operations over a resource may\n\n### Determining Which Resource Properties Appear in Lifecycle Operations\n\nBy default, any property that occurs in your resource model will also appear in the response to GET, PUT, PATCH, and LIST operations, and in the request for PUT and PATCH operations. This does not work for all properties. Some properties are calculated by the service and cannot be directly set by PUT or PATCH (provisioningState, modification date, etc.). Some properties can only be set when creating a resource, but always appear in responses (e.g. 'location'). Some properties can only be set when updating the resource, and appear in responses. Some properties (rarely) may be settable when updating the resource via PUT or PATCH. To allow using a common resource model, but applying these `views` of resources to determine how the resource appear in request and responses, TypeSpec provides the visibility framework. You can see a complete representation of available visibilities in the table [on Property Visibility and Other Constraints](./resource-type.md#property-visibility-and-other-constraints). The sections below outline some common scenarios for designing properties with your operations in mind.\r\n\r\n#### Properties That Are Never Directly Set by the User\r\n\r\nIt is common to have properties that are calculated by the service or otherwise not directly set by the user, examples include timestamps, dates, values that are only set by specific actions (on/off, enabled/disabled, provisioningState). You want to make sure that these properties are marked so that they will appear in responses and not requests. this is done using the `@visibility(Lifecycle.Read)` decorator instance:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Read)\r\nprovisioningState: ProvisioningState;\r\n```\n\n### Resource Get Operations\n\nGet is the operation to retrieve a single resource TypeSpec provides a single operation template for GET:\r\n\r\n```typespec\r\nop get is ArmResourceRead<MyResource>;\r\n```\r\n\r\n- **get**: The name of the operation passed on to clients.\r\n- **Resource**: A reference to your resource type.\n\n### Resource CreateOrUpdate Operations (PUT)\n\nThe CreateOrUpdate operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\n- Simple resources may have synchronous PUT operations. If a resource may need to perform additional checks, creation of other dependent resources, or the like, it is best to use an Asynchronous API.\r\n- Asynchronous operations for PUT occur when the RP needs to perform additional validaton actions, create other resources, or perform other tasks as part of resource creation or update that can cause the operation to take longer than the length of a single request/response.\r\n\r\n| Operation        | TypeSpec                                                          |\r\n| ---------------- | ----------------------------------------------------------------- |\r\n| Synchronous PUT  | `createOrUpdate is ArmResourceCreateOrReplaceSync<ResourceType>`  |\r\n| Asynchronous PUT | `createOrUpdate is ArmResourceCreateOrReplaceAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `createOrUpdate` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being created (or updated)\n\n### Resource Update Operations (PATCH)\n\nPATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\r\nThe ArmCustomPatch\\* templates take the resource type and your custom PATCH request type as parameters.\n\nARM Requires that all `Tracked` resources implement PATCH for ARM tags, which are contained in the envelope of every `TrackedResource`. ARM recommends that you also allow PATCH of other envelope properties and resource-specific properties. Unless marked with a specific visibility, any property in your rp-specific properties will be automatically included in the PATCH schema.\r\n\r\nTypeSpec Provides both Synchronous and Asynchronous PATCH Operations, and allows you to specify a PATCH for Resource tags only, a PATCH for all updateable properties, or a custom patch. Generally, you should choose the patch for all updateable properties, unless you have a very good reason for choosing another PATCH operation.\r\n\r\n| Operation Description      | TypeSpec                                                                                                                                   |\r\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Sync TagsOnly PATCH        | `update is ArmTagsPatchSync<ResourceType>`                                                                                                 |\r\n| Async TagsOnly PATCH       | `update is ArmTagsPatchAsync<ResourceType>`                                                                                                |\r\n| Sync All Properties PATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\n\n### Resource Delete Operations (DELETE)\n\nThe Delete operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\nSimple resources may have synchronous DELETE operations. If a resource needs to clean up other resources or do other validations as part of delete, the delete operation may need to be asynchronous.\r\n\r\n| Operation           | TypeSpec                                                  |\r\n| ------------------- | --------------------------------------------------------- |\r\n| Synchronous Delete  | `delete is ArmResourceDeleteSync<ResourceType>`           |\r\n| Asynchronous Delete | `delete is ArmResourceDeleteWithoutOkAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `delete` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being deleted.\n\n### Resource List Operations (GET)\n\nArm Resource list operations return a list of Tracked or Proxy Resources at a particular scope.\r\n\r\n- All resources _should_ include a list operation at its immediate parent scope\r\n  - For **Tenant Resources**, this is at the tenant scope\r\n  - For **Extension Resources**, this is at the scope of resources they are extending\r\n  - For **Tracked Resources**, this is at the resource group scope.\r\n  - For **Child Resources**, this is at the scope of the resource parent.\r\n- Tracked resources _must_ include a list operation at the Subscription level.\r\n\r\n| Operation          | TypeSpec                                                            |\r\n| ------------------ | ------------------------------------------------------------------- |\r\n| ListByParent       | `listByWidget is ArmResourceListByParent<ResourceType>`             |\r\n| ListBySubscription | `listBySubscription is ArmResourceListBySubscription<ResourceType>` |\n\n### Resource Actions (POST)\n\nCustom actions define any operations over resources outside the simple CRUDL (Create< Read, Update, Delete, List) or lifecycle operations described above. Any operation that returns data that is not made up of resources, performs a prescriptive state change on the resource (cycling power, upgrading, etc.), or any operation that does not fit into the operations described above should be modelled as a _resource action_. Examples of resource actions include:\r\n\r\n- Operations that manage credentials associated with a resource\r\n- Operations that calculate statistics about resources\r\n- Operations that make specific state changes to resources (power cycle, upgrade, etc.)\r\n\r\n#### Actions that take input and output\r\n\r\nOperations that manage credentials are a good example fo this category. TypeSpec defines synchronous and asynchronous templates for actions that consume and produce information.\r\n\r\n| Operation                    | TypeSpec                                                                       |\r\n| ---------------------------- | ------------------------------------------------------------------------------ |\r\n| Synchronous Resource Action  | `updateCredentials is ArmResourceActionSync<ResourceType, Request, Response>`  |\r\n| Asynchronous Resource Action | `updateCredentials is ArmResourceActionAsync<ResourceType, Request, Response>` |\r\n\r\nParameters to the template are the ResourceType, the model for the operation Request body, and the model for the operation Response body.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- |\n\nbody.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- | ------------------------------------------------------------------------------------- |\r\n| Synchronous NoContent Action  | `updateCredentials is ArmResourceActionNoContentSync<ResourceType, Request>`          |\r\n| Asynchronous NoContent Action | `updateCredentials is ArmResourceActionNoResponseContentAsync<ResourceType, Request>` |\r\n\r\nParameters to the template are the ResourceType and the model for the operation Request body.\n\n### Actions that take no input but produce output (data retrieval actions)\n\nSome operations return data or paged lists of data. TypeSpec does not yet provide templates for these kinds of actions, but here are two templates that you could reuse in your own specification, described in the next section of the document:\r\n\r\n- [Synchronous Resource List Actions](#synchronous-list-action)\r\n- [Asynchronous List Action](#asynchronous-list-action)\n\n### Check Name Operations\n\nSome services provide operations to check name availability, either location-specific (locally) or globally, especially if a resource name must be globally unique (such as when an exposed endpoint uses the resource name in the url).\r\n\r\n| Operation                      | TypeSpec                                                                                             |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------- |\r\n| Global Name Availability Check | `checkGlobalName is checkGlobalNameAvailability<TRequest, TResponse, TAdditionalParams>`             |\r\n| Local Name Availability Check  | `checkLocalName is checkLocalNameAvailability<TRequest, TResponse, TAdditionalParams>`               |\r\n| Custom Name Availability Check | `customNameCheck is checkNameAvailability<TScopeParameters, TRequest, TResponse, TAdditionalParams>` |\r\n\r\n`checkGlobalNameAvailability` and `checkLocalNameAvailability` have default values that allow them to be used without specifying any template parameters. `checkNameAvailability` requires the `TScopeParameters` template parameter, which describes the parameters which define the scope of the name check request. For reference, the following table shows the `TScopeParameters` for the standard templates:\r\n\r\n| Operation                      | Scope Parameters                                                       |\r\n| ------------------------------ | ---------------------------------------------------------------------- |\r\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\r\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\n\n## Writing Custom Operations\n\nTypeSpec operation templates provide a simple mechanism for producing the most common operation patterns in ARM, using best practices and conforming to ARM RPC guidelines. However, sometimes a service has special requirements for operations that fall outside these boundaries. The `Azure.ResourceManager.Foundations` namespace provides lower level building blocks that can be used to produce operations and operation templates.\r\n\r\nThe building blocks are described in the sections below:\n\n### ARM Response Types\n\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\r\n\r\n| Model                               | Code | Description                                   |\r\n| ----------------------------------- | ---- | --------------------------------------------- |\r\n| `ArmResponse<T>`                    | 200  | Base Arm 200 response.                        |\r\n| `ArmResourceUpdatedResponse<T>`     | 200  | Resource updated (PUT) response.              |\r\n| `ArmResourceCreatedResponse<T>`     | 201  | Resource created response for an lro.         |\r\n| `ArmResourceCreatedSyncResponse<T>` | 201  | Resource created synchronously.               |\r\n| `ArmAcceptedResponse`               | 202  | Base Arm Accepted response.                   |\r\n| `ArmNoContentResponse`              | 204  | Base Arm No Content response.                 |\r\n| `ArmDeletedResponse`                | 200  | Resource deleted response.                    |\r\n| `ArmDeleteAcceptedResponse`         | 202  | Resource deletion in progress response.       |\r\n| `ResourceListResult<T>`             | 200  | Return a list of resource with ARM pagination |\r\n| `ErrorResponse`                     | x    | Error response                                |\n\n### Common Operation Parameters\n\nThere are a number of model types which specify common parameters which are used in resource type operations:\r\n\r\n| Model                           | In           | Description                                                 |\r\n| ------------------------------- | ------------ | ----------------------------------------------------------- |\r\n| `ApiVersionParameter`           | query        | api-version parameter                                       |\r\n| `SubscriptionIdParameter`       | path         | Subscription ID path parameter                              |\r\n| `ResourceGroupNameParameter`    | path         | Resource Group Name path parameter                          |\r\n| `ResourceInstanceParameters<T>` | path & query | Identity parameters for a resource, with api-version        |\r\n| `ResourceParentParameters<T>`   | path & query | Identity Parameters for listing by parent, with api-version |\r\n| `ResourceUriParameter`          | path         | Resource uri path parameter for Extension resources         |\r\n| `OperationIdParameter`          | path         | Operation Id path parameter                                 |\n\n### Synchronous List Action\n\nHere is a sample template for resource list actions that return synchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionSync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionSync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n\n### Asynchronous List Action\n\nHere is a sample template for resource list actions that return asynchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionAsync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ArmAcceptedResponse | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionAsync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#rest#resource-routing.md\n- document_title: Resource and routes\n- document_link: https://typespec.io/docs/libraries/rest/resource-routing\n- document_content: # libraries#rest#resource-routing.md\n\n# Resource and routes\n\nResources are operations that are grouped in a namespace. You declare such a namespace by adding the `@route` decorator to provide the path to that resource:\r\n\r\n```typespec\r\nusing Http;\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n\r\n}\r\n```\r\n\r\nTo define an operation on this resource, you need to provide the HTTP verb for the route using the `@get`, `@head` `@post`, `@put`, `@patch`, or `@delete` decorators. If an HTTP method decorator is not specified then the default is post if there is a body and get otherwise. Lets add an operation to our `Pets` resource:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(): Pet[];\r\n\r\n  // or you could also use\r\n  @get op listPets(): Pet[];\r\n}\r\n```\r\n\r\nIf `@route` is applied to an interface, that route is not \"portable\". It will be applied to that interface but will not carry over if another interface extends it.\r\n\r\n```typespec\r\n// Operations prepended with /pets\r\n@route(\"/pets\")\r\ninterface PetOps {\r\n  list(): Pet[]\r\n}\r\n\r\n// Operations will *not* be prepended with /pets\r\ninterface MyPetOps extends PetOps {\r\n  ...\r\n}\r\n```\n\n### Automatic route generation\n\nInstead of manually specifying routes using the `@route` decorator, you automatically generate routes from operation parameters by applying the `@autoRoute` decorator to an operation or interface containing operations.\r\n\r\nFor this to work, an operation's path parameters (those marked with `@path`) must also be marked with\r\nthe `@segment` decorator to define the preceding path segment.\r\n\r\nThis is especially useful when reusing common parameter sets defined as model types.\r\n\r\nFor example:\r\n\r\n```typespec\r\nmodel CommonParameters {\r\n  @path\r\n  @segment(\"tenants\")\r\n  tenantId: string;\r\n\r\n  @path\r\n  @segment(\"users\")\r\n  userName: string;\r\n}\r\n\r\n@autoRoute\r\ninterface UserOperations {\r\n  @get\r\n  getUser(...CommonParameters): User | Error;\r\n\r\n  @put\r\n  updateUser(...CommonParameters, user: User): User | Error;\r\n}\r\n```\r\n\r\nThis will result in the following route for both operations\r\n\r\n```text\r\n/tenants/{tenantId}/users/{userName}\r\n```\r\n\r\nIf `@autoRoute` is applied to an interface, it is not \"portable\". It will be applied to that interface but will not carry over if another interface extends it.\r\n\r\n```typespec\r\n// Operations prepended with /pets\r\n@autoRoute\r\ninterface PetOps {\r\n  action(@path @segment(\"pets\") id: string): void;\r\n}\r\n\r\n// Operations will *not* be prepended with /pets\r\ninterface MyPetOps extends PetOps {\r\n  ...\r\n}\r\n```\n\n### Customizing Automatic Route Generation\n\nInstead of manually specifying routes using the `@route` decorator, you automatically generate\r\nroutes from operation parameters by applying the `@autoRoute` decorator to an operation, namespace,\r\nor interface containing operations.\n", "latency": 8.89933705329895, "response_length": 840}
{"query": "title: TypeSpec JsonSchema Emitter - possible to specify API version?\n\nquestion: Hello,\nWe are looking to generate a specific set of schemas aligned with a specific API version, and therefore want to respect all usage of @@removed and @addedas specified via TypeSpec versioning. Is that currently possible?\nExample: don't include \"Foo\" property in model if was removed in version I am currently generating JsonSchema for.", "ground_truth": "https://github.com/microsoft/typespec/issues/2051", "response": "Yes, it is possible to generate JSON schemas aligned with a specific API version in TypeSpec by leveraging the versioning decorators provided by the `@typespec/versioning` library. Specifically, you can use the `@added` and `@removed` decorators to specify when properties, models, or operations were added or removed in different versions. When generating JSON schemas for a specific version, the TypeSpec compiler will respect these decorators and exclude properties or models that were removed in the specified version.\n\nFor example, if you have a model with a property marked as `@removed` in a specific version, that property will not appear in the generated schema for that version:\n\n```tsp\nmodel ExampleModel {\n  id: int32;\n\n  @removed(Versions.v2)\n  oldProperty: string;\n\n  @added(Versions.v2)\n  newProperty: string;\n}\n```\n\nWhen generating schemas for version `v2`, `oldProperty` will be excluded, and `newProperty` will be included. To implement this, ensure your API namespace is marked with the `@versioned` decorator and define your versions using an enum. The TypeSpec compiler will then generate version-specific outputs based on these annotations.", "context": "- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step10.md\n- document_title: 10. Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10\n- document_content: # getstarted#azure-core#step10.md\n\n# 10. Versioning\n\n## Versioning your service\n\nIt is inevitable that service specifications will change over time. It is a best practice to add versioning support to your specification from the first version. To do that, you will need to define an `enum` containing your service versions and then apply the `@versioned` decorator to your service namespace.\r\n\r\nHere is an example for the `WidgetManager` service:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n}\r\n```\r\n\r\nThere are a few things to point out here:\r\n\r\n- We define an `enum` called `Versions` inside of the service namespace. For each service version, we map a version symbol like `v2022_08_31` to a version string like `2022-08-31`. This service currently only has a single version, but we can add more to this enum as things change over time.\r\n- We add the `@versioned` decorator and reference the `Versions` enum we defined using the fully-qualified name `Contoso.WidgetManager.Versions`. This marks the service as being versioned and specifies the set of versions.\r\n- We change the `@useDependency` decorator we used previously to now link each service version to a specific version of `Azure.Core`. See the [Using Azure.Core Versions](#using-azurecore-versions) section for more information.\r\n\r\nImagine that it's 3 months later and you want to release a new version of your service with some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\n\nwith some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nFinally, you can express changes to your service using the `@added` and `@removed` decorators. Here's an example of adding a new property to `Widget` and removing an old one:\r\n\r\n```typespec\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  @added(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  color: string;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  @removed(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n> You can do a lot more with versioning decorators, so consult the `typespec-versioning` [README.md](https://github.com/microsoft/typespec/tree/main/packages/versioning#enable-versioning-for-service-or-library) for more information on how you can use them to annotate your service and describe changes between different versions.\n\n## Using Azure.Core versions\n\n`typespec-azure-core` is a versioned TypeSpec library. This means that even as the TypeSpec portions of the typespec-azure-core library are updated, you can anchor each version of your spec to a specific `Azure.Core` version. This is done by decorating your service namespace with the `@useDependency` decorator from the `typespec-versioning` library.\r\n\r\nSimple TypeSpec specs need only pass the desired `Azure.Core` version into the `@useDependency` decorator:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nIf your spec has [multiple versions](#versioning-your-service), you will need to specify the version of `typespec-azure-core` that was used for each version in your spec. Assuming that there are two versions of `Azure.Core` and each version of your service uses a different one, it would look like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"v20220831\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"v20221130\",\r\n}\r\n```\n", "latency": 19.03434157371521, "response_length": 1162}
{"query": "title: Remove status 200?\n\nquestion: Hello!\nWe are trying to move private API specs to public, but we are getting some lint error because some of our delete actions have status code 200 and we should only have 202, 204 and default.\nHow can we remove that status 200 when generating the openapi.json file?\nOn the main.tsp I see we have\n```\n@doc(\"Workload Interface\")\n@armResourceOperations\ninterface Workload {\nget is ArmResourceRead<WorkloadResource>;\n@useFinalStateVia(\"azure-async-operation\")\ncreateOrUpdate is ArmResourceCreateOrReplaceAsync<\nWorkloadResource,\nLroHeaders = Azure.Core.Foundations.RetryAfterHeader &\nArmAsyncOperationHeader\n>;\nupdate is ArmResourcePatchAsync<WorkloadResource, WorkloadProperties>;\ndelete is ArmResourceDeleteAsync<WorkloadResource>;\nlistByEnclaveResource is ArmResourceListByParent<WorkloadResource>;\nlistBySubscription is ArmListBySubscription<WorkloadResource>;\n}\n```", "ground_truth": "use the ArmResourceDeleteWithoutOkAsync template for delete, as in [this playground](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D&sample=Azure+Resource+Manager+framework)", "response": "To remove the status code 200 from your delete operations when generating the OpenAPI JSON file, you need to use the `ArmResourceDeleteWithoutOkAsync` template for asynchronous delete operations. This template ensures that only the status codes 202, 204, and default are included in the OpenAPI output. Update your `delete` operation in the `Workload` interface as follows:\n\n```tsp\n@armResourceOperations\ninterface Workload {\n  delete is ArmResourceDeleteWithoutOkAsync<WorkloadResource>;\n}\n```\n\nThis change will align your delete operation with the expected response codes for asynchronous operations and resolve the lint error.", "context": "- document_dir: typespec_docs\n- document_filename: emitters#openapi3#diagnostics.md\n- document_title: Diagnostics\n- document_link: https://typespec.io/docs/emitters/openapi3/diagnostics\n- document_content: # emitters#openapi3#diagnostics.md\n\n# Diagnostics\n\nThe OpenAPI emitter may produce any of the following diagnostic messages.\r\n\r\n<!-- Topics within this section should be ordered alphabetically for easy lookup -->\n\n## duplicate-header\n\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\r\n\r\nTo fix this issue, ensure that each response header is defined only once for each status code.\n\n### Example\n\n```yaml\r\nresponses:\r\n  \"200\":\r\n    description: Successful response\r\n    headers:\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n      X-Rate-Limit:\r\n        description: The number of allowed requests in the current period\r\n        schema:\r\n          type: integer\r\n```\r\n\r\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\n\n## duplicate-type-name\n\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\r\n\r\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\n\n### Example\n\n```typespec\r\n@friendlyName(\"User\")\r\nmodel Customer {\r\n  id: string;\r\n}\r\n\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\n\n## inline-cycle\n\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\r\n\r\nTo fix this issue, refactor the schemas to remove the cyclic reference.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    Node:\r\n      type: object\r\n      properties:\r\n        value:\r\n          type: string\r\n        next:\r\n          $ref: \"#/components/schemas/Node\"\r\n```\r\n\r\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\n\n## invalid-default\n\nThis diagnostic is issued when a default value is invalid for the specified schema type.\r\n\r\nTo fix this issue, ensure that the default value is valid for the schema type.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        age:\r\n          type: integer\r\n          default: \"twenty\"\r\n```\r\n\r\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\n\n## invalid-extension-key\n\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \"x-\" as\r\nrequired by the OpenAPI v3 specification.\r\n\r\nTo fix this issue, change the extension name to start with \"x-\".\n\n### Example\n\n```typespec\r\n@extension(\"invalid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\r\n\r\nShould be changed to:\r\n\r\n```typespec\r\n@extension(\"x-valid-name\", \"value\")\r\nmodel User {\r\n  id: string;\r\n}\r\n```\n\n## invalid-schema\n\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\r\n\r\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\n\n### Example\n\n```yaml\r\ncomponents:\r\n  schemas:\r\n    User:\r\n      type: object\r\n      properties:\r\n        id:\r\n          type: string\r\n        age:\r\n          type: integer\r\n          format: \"int\" # Invalid format\r\n```\r\n\r\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\n\n## invalid-server-variable\n\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\r\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\r\n\r\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\n\n### Example\n\n```typespec\r\n@server(\"{protocol}://{host}/api/{version}\", \"Custom endpoint\", {\r\n  protocol: \"http\" | \"https\",\r\n  host: string,\r\n  version: 1, // Should be a string: \"1\"\r\n})\r\n```\n\n## path-query\n\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\r\n\r\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\n\n### Example\n\nInstead of:\r\n\r\n```typespec\r\n@route(\"/users?filter={filter}\")\r\nop getUsers(filter: string): User[];\r\n```\r\n\r\nUse:\r\n\r\n```typespec\r\n@route(\"/users\")\r\nop getUsers(@query filter?: string): User[];\r\n```\r\n\r\nAlternatively, you can leverage TypeSpec's support for URI templates:\r\n\r\n```typespec\r\n@route(\"/users{?filter}\")\r\nop getUsers(filter?: string): User[];\r\n```\n\n## union-null\n\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\r\nrepresented in OpenAPI.\r\n\r\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\n\n## union-unsupported\n\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\r\n\r\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-resource-manager#rules#delete-operation-response-codes.md\n- document_title: delete-operation-response-codes\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/rules/delete-operation-response-codes\n- document_content: # libraries#azure-resource-manager#rules#delete-operation-response-codes.md\n\n# delete-operation-response-codes\n\n```text title=- Full name-\r\n@azure-tools/typespec-azure-resource-manager/delete-operation-response-codes\r\n```\n\n## Synchronous\n\nSynchronous delete operations should use the `ArmResourceDeleteSync` template. They must have 200, 204, default and no other responses.\r\n\r\n####  Incorrect\r\n\r\n```tsp\r\n@armResourceOperations\r\ninterface Employees {\r\n  @armResourceDelete(Employee)\r\n  delete(...ApiVersionParameter): {\r\n    @statusCode _: 200;\r\n    result: boolean;\r\n  };\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\n@armResourceOperations\r\ninterface Employees {\r\n  delete is ArmResourceDeleteSync<Employee>;\r\n}\r\n```\n\n## Asynchronous\n\nLong-running (LRO) delete operations should use the `ArmResourceDeleteWithoutOkAsync` template. They must have 202, 204, default, and no other responses.\r\n\r\n####  Incorrect\r\n\r\n```tsp\r\n@armResourceOperations\r\ninterface Employees {\r\n  delete is ArmResourceDeleteAsync<Employee>;\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\n@armResourceOperations\r\ninterface Employees {\r\n  delete is ArmResourceDeleteWithoutOkAsync<Employee>;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n", "latency": 7.103339672088623, "response_length": 629}
{"query": "title: Multiple Continuation Token\n\nquestion: Just checking to be sure, is something like that valid?\n```TypeScript\n@list op listPets(\n@continuationToken @header token?: string,\n@continuationToken @query foo?: string\n): {\n@pageItems pets: Pet[];\n@continuationToken token?: string;\n@continuationToken foo?: string\n};\n```\nIOW, multiple continuation token, with some form of inference to know how to connect them (here, I used the same name, but I could be more evil).\nBrian ?", "ground_truth": "no, must be a single one https://typespec.io/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7Cgp1c2luZyBUeXBlU3BlYy5IdHRwOwpAc2VydmljZSh7CiAgdGl0bGU6ICJXaWRnZXQgU8YbIiwKfSkKbmFtZXNwYWNlIERlbW%2FHGzsKCm1vZGVsIFBldCDEQkB2aXNpYmlsaXR5KCJyZWFkIiwgInVwZGF0ZSIpxCBwYXRoCiAgaWQ6IHN0cmluZzsKCiAgd2VpZ2h0OiBpbnQzMjsKICBjb2xvcjogInJlZCIgfCAiYmx1ZSI7Cn0KCkBlcnJvcsd3RcQMxXljb2Rly0BtZXNzYWdlymXEOmxpc3Qgb3AgxAhQZXRzKOQAkWNvbnRpbnVhdGlvblRva2VuIEBoZWFkZXIgdMQOP8hDLNctcXVlcnkgZm9vyyopOuYBDXBhZ2VJdGVtcyBwZXRzOuQBJltd5ACf00nObtclzGc7Cn07Cg%3D%3D&e=%40typespec%2Fopenapi3&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40typespec%2Fhttp%2Fall%22%5D%7D%7D", "response": "No, using multiple continuation tokens in the way you described is not valid in TypeSpec. The `@continuationToken` decorator must be specified both on the request parameter and the response property, and it is intended to define a single token for pagination. The documentation does not support the use of multiple continuation tokens, as this would create ambiguity in how the pagination state is managed. If you need additional parameters for filtering or other purposes, they should be handled separately and not as continuation tokens.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#13pagingoperations.mdx\n- document_title: Paging Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/13pagingoperations\n- document_content: # howtos#generate-client-libraries#13pagingoperations.mdx\n\n# Paging Operations\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis doc details what emitters will generate for paging operations.\n\n## Using next link to indicate how to get the next page\n\nNext link is an absolute url returned by the paging operation, which indicates how to get the next page.\r\nIf the response does not return a next link, it indicates the last page of results.\r\nNext link should be annotated in the response model with `@nextLink`.\r\n\r\nThere are two ways to indicate a paging operation with `@nextLink`:\r\n\r\n1. Use `@pagedResult` and `@items` in `Azure.Core` lib.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nop listWithPage(): UserList;\r\n\r\nmodel User {\r\n  id: string;\r\n  name: string;\r\n}\r\n\r\n@pagedResult\r\nmodel UserList {\r\n  @items\r\n  value: User[];\r\n\r\n  @nextLink\r\n  nextLink?: url;\r\n}\r\n```\r\n\r\n```python\r\nclass User(_model_base.Model):\r\n    id: str = rest_field()\r\n    name: str = rest_field()\r\n\r\ndef list_with_page(self, **kwargs: Any) -> Iterable[\"_models.User\"]:\r\n    ...\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\npublic PagedIterable<User> listWithPage();\r\n```\r\n\r\n</ClientTabs>\r\n\r\n2. Use the `@list` and `@pageItems` decorators from TypeSpec core.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\n@list\r\nop listWithPage(): UserList;\r\n\r\nmodel User {\r\n  id: string;\r\n  name: string;\r\n}\r\n\r\nmodel UserList {\r\n  @pageItems\r\n  value: User[];\r\n\r\n  @nextLink\r\n  nextLink?: url;\r\n}\r\n```\r\n\r\n```python\r\nclass User(_model_base.Model):\r\n    id: str = rest_field()\r\n    name: str = rest_field()\r\n\r\ndef list_with_page(self, **kwargs: Any) -> Iterable[\"_models.User\"]:\r\n    ...\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\npublic PagedIterable<User> listWithPage();\r\n```\r\n\r\n</ClientTabs>\n\n## Using continuation token to indicate how to get the next page\n\nA continuation token is a string returned by a paging operation, which is used as a parameter value for the paging operation to get the next page.\r\nIf the response does not return a continuation token, it indicates the last page of results.\r\nThe request parameter that corresponds to the continuation token value in the paging operation should be decorated with `@continuationToken`. Similarly, the response property that contains the continuation token value should also be decorated with `@continuationToken`.\r\n\r\n1. Continuation token in query parameter and response body.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\n@list\r\nop listWithPage(@query @continuationToken continuationToken?: string): UserList;\r\n\r\nmodel User {\r\n  id: string;\r\n  name: string;\r\n}\r\n\r\nmodel UserList {\r\n  @pageItems\r\n  value: User[];\r\n\r\n  @continuationToken\r\n  continuationToken?: string;\r\n}\r\n```\r\n\r\n```python\r\nclass User(_model_base.Model):\r\n    id: str = rest_field()\r\n    name: str = rest_field()\r\n\r\ndef list_with_page(self, **kwargs: Any) -> Iterable[\"_models.User\"]:\r\n    ...\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\nNOT_SUPPORTED\r\n```\r\n\r\n</ClientTabs>\r\n\r\n2. Continuation token in header parameter and response body.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\n@list\r\nop listWithPage(@header @continuationToken continuationToken?: string): UserList;\r\n\r\nmodel User {\r\n  id: string;\r\n  name: string;\r\n}\r\n\r\nmodel UserList {\r\n  @pageItems\r\n  value: User[];\r\n\r\n  @continuationToken\r\n  continuationToken?: string;\r\n}\r\n```\r\n\r\n```python\r\nclass User(_model_base.Model):\r\n    id: str = rest_field()\r\n    name: str = rest_field()\r\n\r\ndef list_with_page(self, **kwargs: Any) -> Iterable[\"_models.User\"]:\r\n    ...\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\nNOT_SUPPORTED\r\n```\r\n\r\n</ClientTabs>\r\n\r\n3. Continuation token in query parameter and response header.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\n@list\r\nop listWithPage(@query @continuationToken continuationToken?: string): {\r\n  @header\n\nstring;\r\n}\r\n```\r\n\r\n```python\r\nclass User(_model_base.Model):\r\n    id: str = rest_field()\r\n    name: str = rest_field()\r\n\r\ndef list_with_page(self, **kwargs: Any) -> Iterable[\"_models.User\"]:\r\n    ...\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\nNOT_SUPPORTED\r\n```\r\n\r\n</ClientTabs>\r\n\r\n3. Continuation token in query parameter and response header.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\n@list\r\nop listWithPage(@query @continuationToken continuationToken?: string): {\r\n  @header\r\n  @continuationToken\r\n  continuationToken?: string;\r\n\r\n  @pageItems\r\n  value: User[];\r\n};\r\n\r\nmodel User {\r\n  id: string;\r\n  name: string;\r\n}\r\n```\r\n\r\n```python\r\nclass User(_model_base.Model):\r\n    id: str = rest_field()\r\n    name: str = rest_field()\r\n\r\ndef list_with_page(self, **kwargs: Any) -> Iterable[\"_models.User\"]:\r\n    ...\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\nNOT_SUPPORTED\r\n```\r\n\r\n</ClientTabs>\r\n\r\n4. Continuation token in header parameter and response header.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\n@list\r\nop listWithPage(@query @continuationToken continuationToken?: string): {\r\n  @header\r\n  @continuationToken\r\n  continuationToken?: string;\r\n\r\n  @pageItems\r\n  value: User[];\r\n};\r\n\r\nmodel User {\r\n  id: string;\r\n  name: string;\r\n}\r\n```\r\n\r\n```python\r\nclass User(_model_base.Model):\r\n    id: str = rest_field()\r\n    name: str = rest_field()\r\n\r\ndef list_with_page(self, **kwargs: Any) -> Iterable[\"_models.User\"]:\r\n    ...\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\nNOT_SUPPORTED\r\n```\r\n\r\n</ClientTabs>\n\n## Advanced\n\n### Parameterized next links (against guidelines)\n\n:::danger\r\nParameterized next links are against guidelines. Please don't follow this unless explicitly told to do so\r\n:::\r\n\r\nIn very rare cases, there are cases of next links that require parameterization. These cases exist outside of the Azure guidelines for paging, but must be supported for legacy reasons.\r\n\r\nIn cases like this, you may use the special scalar type `Azure.Core.Legacy.parameterizedNextLink`. You can specify which parameters must be reformatted into the next link. Your emitted SDK will handle the reformatting based on the tsp definition\r\n\r\n```tsp\r\nmodel ListCertificateOptions {\r\n  includePending?: string;\r\n}\r\nmodel Certificate {\r\n  name: string;\r\n}\r\nmodel Page {\r\n  @items items: Certificate[];\r\n  @nextLink nextLink: Azure.Core.Legacy.parameterizedNextLink<[\r\n    ListCertificateOptions.includePending\r\n  ]>;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: standard-library#built-in-decorators.md\n- document_title: Built-in Decorators\n- document_link: https://typespec.io/docs/standard-library/built-in-decorators\n- document_content: # standard-library#built-in-decorators.md\n\n# Built-in Decorators\n\n## TypeSpec\n\n### `@continuationToken` {#@continuationToken}\n\nPagination property defining the token to get to the next page.\r\nIt MUST be specified both on the request parameter and the response.\r\n```typespec\r\n@continuationToken\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @continuationToken continuationToken: string;\r\n}\r\n@list op listPets(@continuationToken continuationToken: string): Page<Pet>;\r\n```\n\n### `@defaultVisibility` {#@defaultVisibility}\n\nDeclares the default visibility modifiers for a visibility class.\r\n\r\nThe default modifiers are used when a property does not have any visibility decorators\r\napplied to it.\r\n\r\nThe modifiers passed to this decorator _MUST_ be members of the target Enum.\r\n```typespec\r\n@defaultVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Enum`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | the list of modifiers to use as the default visibility modifiers. |\n\n### `@discriminated` {#@discriminated}\n\nSpecify that this union is discriminated.\r\n```typespec\r\n@discriminated(options?: valueof DiscriminatedOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Union`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| options | [valueof `DiscriminatedOptions`](./built-in-data-types.md#DiscriminatedOptions) | Options to configure the serialization of the discriminated union. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@discriminated\r\nunion Pet{ cat: Cat, dog: Dog }\r\n\r\nmodel Cat { name: string, meow: boolean }\r\nmodel Dog { name: string, bark: boolean }\r\n```\r\nSerialized as:\r\n```json\r\n{\r\n  \"kind\": \"cat\",\r\n  \"value\": {\r\n    \"name\": \"Whiskers\",\r\n    \"meow\": true\r\n  }\r\n},\r\n{\r\n  \"kind\": \"dog\",\r\n  \"value\": {\r\n    \"name\": \"Rex\",\r\n    \"bark\": false\r\n  }\r\n}\r\n```\r\n\r\n##### Custom property names\r\n\r\n\r\n```typespec\r\n@discriminated(#{discriminatorPropertyName: \"dataKind\", envelopePropertyName: \"data\"})\r\nunion Pet{ cat: Cat, dog: Dog }\r\n\r\nmodel Cat { name: string, meow: boolean }\r\nmodel Dog { name: string, bark: boolean }\r\n```\r\nSerialized as:\r\n```json\r\n{\r\n  \"dataKind\": \"cat\",\r\n  \"data\": {\r\n    \"name\": \"Whiskers\",\r\n    \"meow\": true\r\n  }\r\n},\r\n{\r\n  \"dataKind\": \"dog\",\r\n  \"data\": {\r\n    \"name\": \"Rex\",\r\n    \"bark\": false\r\n  }\r\n}\r\n```\n\n### `@discriminator` {#@discriminator}\n\nSpecify the property to be used to discriminate this type.\r\n```typespec\r\n@discriminator(propertyName: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| propertyName | [valueof `string`](#string) | The property name to use for discrimination |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet{ kind: string }\r\n\r\nmodel Cat extends Pet {kind: \"cat\", meow: boolean}\r\nmodel Dog extends Pet  {kind: \"dog\", bark: boolean}\r\n```\n\n### `@doc` {#@doc}\n\nAttach a documentation string. Content support CommonMark markdown formatting.\r\n```typespec\r\n@doc(doc: valueof string, formatArgs?: {})\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n| formatArgs | `{}` | Record with key value pair that can be interpolated in the doc. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@doc(\"Represent a Pet available in the PetStore\")\r\nmodel Pet {}\r\n```\n\n### `@encode` {#@encode}\n\nSpecify how to encode the target type.\r\n```typespec\r\n@encode(encodingOrEncodeAs: Scalar | valueof string | EnumMember, encodedAs?: Scalar)\r\n```\r\n\r\n#### Target\r\n\r\n`Scalar | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| encodingOrEncodeAs | `Scalar` \\| `valueof string \\| EnumMember` | Known name of an encoding or a scalar type to encode as(Only for numeric types to encode as string). |\r\n| encodedAs | `Scalar` | What target type is this being encoded as. Default to string. |\r\n\r\n#### Examples\r\n##### offsetDateTime encoded with rfc7231\r\n\r\n\r\n```tsp\r\n@encode(\"rfc7231\")\r\nscalar myDateTime extends offsetDateTime;\r\n```\r\n\r\n##### utcDateTime encoded with unixTimestamp\r\n\r\n\r\n```tsp\r\n@encode(\"unixTimestamp\", int32)\r\nscalar myDateTime extends unixTimestamp;\r\n```\r\n\r\n##### encode numeric type to string\r\n\r\n\r\n```tsp\r\nmodel Pet {\r\n  @encode(string) id: int64;\r\n}\r\n```\n\n### `@encodedName` {#@encodedName}\n\nProvide an alternative name for this type when serialized to the given mime type.\r\n```typespec\r\n@encodedName(mimeType: valueof string, name: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| mimeType | [valueof `string`](#string) | Mime type this should apply to. The mime type should be a known mime type as described here https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types without any suffix (e.g. `+json`) |\r\n| name | [valueof `string`](#string) | Alternative name |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Certificate {\r\n  @encodedName(\"application/json\", \"exp\")\r\n  @encodedName(\"application/xml\", \"expiry\")\r\n  expireAt: int32;\r\n}\r\n```\r\n\r\n##### Invalid values\r\n\r\n\r\n```typespec\r\n@encodedName(\"application/merge-patch+json\", \"exp\")\r\n             ^ error cannot use subtype\r\n```\n\n### `@error` {#@error}\n\nSpecify that this model is an error type. Operations return error types when the operation has failed.\r\n```typespec\r\n@error\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@error\r\nmodel PetStoreError {\r\n  code: string;\r\n  message: string;\r\n}\r\n```\n\n### `@errorsDoc` {#@errorsDoc}\n\nAttach a documentation string to describe the error return types of an operation.\r\nIf an operation returns a union of success and errors it only describes the errors. See `@returnsDoc` for success documentation.\r\n```typespec\r\n@errorsDoc(doc: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@errorsDoc(\"Errors doc\")\r\nop get(): Pet | NotFound;\r\n```\n\n### `@example` {#@example}\n\nProvide an example value for a data type.\r\n```typespec\r\n@example(example: valueof unknown, options?: valueof ExampleOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Scalar | Union | ModelProperty | UnionVariant`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| example | `valueof unknown` | Example value. |\r\n| options | [valueof `ExampleOptions`](./built-in-data-types.md#ExampleOptions) | Optional metadata for the example. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@example(#{name: \"Fluffy\", age: 2})\r\nmodel Pet {\r\n name: string;\r\n age: int32;\r\n}\r\n```\n\n### `@firstLink` {#@firstLink}\n\nPagination property defining a link to the first page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@firstLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@format` {#@format}\n\nSpecify a known data format hint for this string type. For example `uuid`, `uri`, etc.\r\nThis differs from the `@pattern` decorator which is meant to specify a regular expression while `@format` accepts a known format name.\r\nThe format names are open ended and are left to emitter to interpret.\r\n```typespec\r\n@format(format: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| format | [valueof `string`](#string) | format name. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@format(\"uuid\")\r\nscalar uuid extends string;\r\n```\n\n### `@friendlyName` {#@friendlyName}\n\nSpecifies how a templated type should name their instances.\r\n```typespec\r\n@friendlyName(name: valueof string, formatArgs?: unknown)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| name | [valueof `string`](#string) | name the template instance should take |\r\n| formatArgs | `unknown` | Model with key value used to interpolate the name |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@friendlyName(\"{name}List\", T)\r\nmodel List<Item> {\r\n  value: Item[];\r\n  nextLink: string;\r\n}\r\n```\n\n### `@inspectType` {#@inspectType}\n\nA debugging decorator used to inspect a type.\r\n```typespec\r\n@inspectType(text: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| text | [valueof `string`](#string) | Custom text to log |\n\n### `@inspectTypeName` {#@inspectTypeName}\n\nA debugging decorator used to inspect a type name.\r\n```typespec\r\n@inspectTypeName(text: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| text | [valueof `string`](#string) | Custom text to log |\n\n### `@invisible` {#@invisible}\n\nIndicates that a property is not visible in the given visibility class.\r\n\r\nThis decorator removes all active visibility modifiers from the property within\r\nthe given visibility class, making it invisible to any context that selects for\r\nvisibility modifiers within that class.\r\n```typespec\r\n@invisible(visibilityClass: Enum)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilityClass | `Enum` | The visibility class to make the property invisible within. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Example {\r\n  @invisible(Lifecycle)\r\n  hidden_property: string;\r\n}\r\n```\n\n### `@key` {#@key}\n\nMark a model property as the key to identify instances of that type\r\n```typespec\r\n@key(altName?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| altName | [valueof `string`](#string) | Name of the property. If not specified, the decorated property name is used. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Pet {\r\n  @key id: string;\r\n}\r\n```\n\n### `@lastLink` {#@lastLink}\n\nPagination property defining a link to the last page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@lastLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@list` {#@list}\n\nMark this operation as a `list` operation that returns a paginated list of items.\r\n```typespec\r\n@list\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\nNone\n\n### `@maxItems` {#@maxItems}\n\nSpecify the maximum number of items this array should have.\r\n```typespec\r\n@maxItems(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown[] | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Maximum number |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxItems(5)\r\nmodel Endpoints is string[];\r\n```\n\n### `@maxLength` {#@maxLength}\n\nSpecify the maximum length this string type should be.\r\n```typespec\r\n@maxLength(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Maximum length |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxLength(20)\r\nscalar Username extends string;\r\n```\n\n### `@maxValue` {#@maxValue}\n\nSpecify the maximum value this numeric type should be.\r\n```typespec\r\n@maxValue(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Maximum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxValue(200)\r\nscalar Age is int32;\r\n```\n\n### `@maxValueExclusive` {#@maxValueExclusive}\n\nSpecify the maximum value this numeric type should be, exclusive of the given\r\nvalue.\r\n```typespec\r\n@maxValueExclusive(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Maximum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@maxValueExclusive(50)\r\nscalar distance is float64;\r\n```\n\n### `@mediaTypeHint` {#@mediaTypeHint}\n\nApplies a media type hint to a TypeSpec type. Emitters and libraries may choose to use this hint to determine how a\r\ntype should be serialized. For example, the `@typespec/http` library will use the media type hint of the response\r\nbody type as a default `Content-Type` if one is not explicitly specified in the operation.\r\n\r\nMedia types (also known as MIME types) are defined by RFC 6838. The media type hint should be a valid media type\r\nstring as defined by the RFC, but the decorator does not enforce or validate this constraint.\r\n\r\nNotes: the applied media type is _only_ a hint. It may be overridden or not used at all. Media type hints are\r\ninherited by subtypes. If a media type hint is applied to a model, it will be inherited by all other models that\r\n`extend` it unless they delcare their own media type hint.\r\n```typespec\r\n@mediaTypeHint(mediaType: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Scalar | Enum | Union`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| mediaType | [valueof `string`](#string) | The media type hint to apply to the target type. |\r\n\r\n#### Examples\r\n##### create a model that serializes as XML by default\r\n\r\n\r\n```tsp\r\n@mediaTypeHint(\"application/xml\")\r\nmodel Example {\r\n  @visibility(Lifecycle.Read)\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n```\n\n### `@minItems` {#@minItems}\n\nSpecify the minimum number of items this array should have.\r\n```typespec\r\n@minItems(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown[] | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Minimum number |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minItems(1)\r\nmodel Endpoints is string[];\r\n```\n\n### `@minLength` {#@minLength}\n\nSpecify the minimum length this string type should be.\r\n```typespec\r\n@minLength(value: valueof integer)\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `integer`](#integer) | Minimum length |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minLength(2)\r\nscalar Username extends string;\r\n```\n\n### `@minValue` {#@minValue}\n\nSpecify the minimum value this numeric type should be.\r\n```typespec\r\n@minValue(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Minimum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minValue(18)\r\nscalar Age is int32;\r\n```\n\n### `@minValueExclusive` {#@minValueExclusive}\n\nSpecify the minimum value this numeric type should be, exclusive of the given\r\nvalue.\r\n```typespec\r\n@minValueExclusive(value: valueof numeric)\r\n```\r\n\r\n#### Target\r\n\r\n`numeric | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| value | [valueof `numeric`](#numeric) | Minimum value |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@minValueExclusive(0)\r\nscalar distance is float64;\r\n```\n\n### `@nextLink` {#@nextLink}\n\nPagination property defining a link to the next page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@nextLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@offset` {#@offset}\n\nPagination property defining the number of items to skip.\r\n```typespec\r\n@offset\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@offset skip: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@opExample` {#@opExample}\n\nProvide example values for an operation's parameters and corresponding return type.\r\n```typespec\r\n@opExample(example: valueof OperationExample, options?: valueof ExampleOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| example | [valueof `OperationExample`](./built-in-data-types.md#OperationExample) | Example value. |\r\n| options | [valueof `ExampleOptions`](./built-in-data-types.md#ExampleOptions) | Optional metadata for the example. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n@opExample(#{parameters: #{name: \"Fluffy\", age: 2}, returnType: #{name: \"Fluffy\", age: 2, id: \"abc\"})\r\nop createPet(pet: Pet): Pet;\r\n```\n\n### `@overload` {#@overload}\n\nSpecify this operation is an overload of the given operation.\r\n```typespec\r\n@overload(overloadbase: Operation)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| overloadbase | `Operation` | Base operation that should be a union of all overloads |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(data: string | bytes, @header contentType: \"text/plain\" | \"application/octet-stream\"): void;\r\n@overload(upload)\r\nop uploadString(data: string, @header contentType: \"text/plain\" ): void;\r\n@overload(upload)\r\nop uploadBytes(data: bytes, @header contentType: \"application/octet-stream\"): void;\r\n```\n\n### `@pageIndex` {#@pageIndex}\n\nPagination property defining the page index.\r\n```typespec\r\n@pageIndex\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@pageItems` {#@pageItems}\n\nSpecify the the property that contains the array of page items.\r\n```typespec\r\n@pageItems\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@pageSize` {#@pageSize}\n\nSpecify the pagination parameter that controls the maximum number of items to include in a page.\r\n```typespec\r\n@pageSize\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n}\r\n@list op listPets(@pageIndex page: int32, @pageSize pageSize: int8): Page<Pet>;\r\n```\n\n### `@parameterVisibility` {#@parameterVisibility}\n\nDeclares the visibility constraint of the parameters of a given operation.\r\n\r\nA parameter or property nested within a parameter will be visible if it has _any_ of the visibilities\r\nin the list.\r\n\r\nIt is invalid to call this decorator with no visibility modifiers.\r\n```typespec\r\n@parameterVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibility modifiers that apply to the parameters of this operation. |\n\n### `@pattern` {#@pattern}\n\nSpecify the the pattern this string should respect using simple regular expression syntax.\r\nThe following syntax is allowed: alternations (`|`), quantifiers (`?`, `*`, `+`, and `{ }`), wildcard (`.`), and grouping parentheses.\r\nAdvanced features like look-around, capture groups, and references are not supported.\r\n\r\nThis decorator may optionally provide a custom validation _message_. Emitters may choose to use the message to provide\r\ncontext when pattern validation fails. For the sake of consistency, the message should be a phrase that describes in\r\nplain language what sort of content the pattern attempts to validate. For example, a complex regular expression that\r\nvalidates a GUID string might have a message like \"Must be a valid GUID.\"\r\n```typespec\r\n@pattern(pattern: valueof string, validationMessage?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`string | bytes | ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| pattern | [valueof `string`](#string) | Regular expression. |\r\n| validationMessage | [valueof `string`](#string) | Optional validation message that may provide context when validation fails. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@pattern(\"[a-z]+\", \"Must be a string consisting of only lower case letters and of at least one character.\")\r\nscalar LowerAlpha extends string;\r\n```\n\n### `@prevLink` {#@prevLink}\n\nPagination property defining a link to the previous page.\r\n\r\nIt is expected that navigating to the link will return the same set of responses as the operation that returned the current page.\r\n```typespec\r\n@prevLink\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nmodel Page<T> {\r\n  @pageItems items: T[];\r\n  @nextLink next: url;\r\n  @prevLink prev: url;\r\n  @firstLink first: url;\r\n  @lastLink last: url;\r\n}\r\n@list op listPets(): Page<Pet>;\r\n```\n\n### `@removeVisibility` {#@removeVisibility}\n\nRemoves visibility modifiers from a property.\r\n\r\nIf the visibility modifiers for a visibility class have not been initialized,\r\nthis decorator will use the default visibility modifiers for the visibility\r\nclass as the default modifier set.\r\n```typespec\r\n@removeVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\nThe property to remove visibility from.\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | The visibility modifiers to remove from the target property. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Example {\r\n  // This property will have all Lifecycle visibilities except the Read\r\n  // visibility, since it is removed.\r\n  @removeVisibility(Lifecycle.Read)\r\n  secret_property: string;\r\n}\r\n```\n\n### `@returnsDoc` {#@returnsDoc}\n\nAttach a documentation string to describe the successful return types of an operation.\r\nIf an operation returns a union of success and errors it only describes the success. See `@errorsDoc` for error documentation.\r\n```typespec\r\n@returnsDoc(doc: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| doc | [valueof `string`](#string) | Documentation string |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@returnsDoc(\"Returns doc\")\r\nop get(): Pet | NotFound;\r\n```\n\n### `@returnTypeVisibility` {#@returnTypeVisibility}\n\nDeclares the visibility constraint of the return type of a given operation.\r\n\r\nA property within the return type of the operation will be visible if it has _any_ of the visibilities\r\nin the list.\r\n\r\nIt is invalid to call this decorator with no visibility modifiers.\r\n```typespec\r\n@returnTypeVisibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibility modifiers that apply to the return type of this operation. |\n\n### `@secret` {#@secret}\n\nMark this string as a secret value that should be treated carefully to avoid exposure\r\n```typespec\r\n@secret\r\n```\r\n\r\n#### Target\r\n\r\n`string | ModelProperty`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@secret\r\nscalar Password is string;\r\n```\n\n### `@service` {#@service}\n\nMark this namespace as describing a service and configure service properties.\r\n```typespec\r\n@service(options?: valueof ServiceOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| options | [valueof `ServiceOptions`](./built-in-data-types.md#ServiceOptions) | Optional configuration for the service. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\nnamespace PetStore;\r\n```\r\n\r\n##### Setting service title\r\n\r\n```typespec\r\n@service(#{title: \"Pet store\"})\r\nnamespace PetStore;\r\n```\r\n\r\n##### Setting service version\r\n\r\n```typespec\r\n@service(#{version: \"1.0\"})\r\nnamespace PetStore;\r\n```\n\n### `@summary` {#@summary}\n\nTypically a short, single-line description.\r\n```typespec\r\n@summary(summary: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| summary | [valueof `string`](#string) | Summary string. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@summary(\"This is a pet\")\r\nmodel Pet {}\r\n```\n\n### `@tag` {#@tag}\n\nAttaches a tag to an operation, interface, or namespace. Multiple `@tag` decorators can be specified to attach multiple tags to a TypeSpec element.\r\n```typespec\r\n@tag(tag: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| tag | [valueof `string`](#string) | Tag value |\n\n### `@visibility` {#@visibility}\n\nSets the visibility modifiers that are active on a property, indicating that it is only considered to be present\r\n(or \"visible\") in contexts that select for the given modifiers.\r\n\r\nA property without any visibility settings applied for any visibility class (e.g. `Lifecycle`) is considered to have\r\nthe default visibility settings for that class.\r\n\r\nIf visibility for the property has already been set for a visibility class (for example, using `@invisible` or\r\n`@removeVisibility`), this decorator will **add** the specified visibility modifiers to the property.\r\n\r\nSee: [Visibility](https://typespec.io/docs/language-basics/visibility)\r\n\r\nThe `@typespec/http` library uses `Lifecycle` visibility to determine which properties are included in the request or\r\nresponse bodies of HTTP operations. By default, it uses the following visibility settings:\r\n\r\n- For the return type of operations, properties are included if they have `Lifecycle.Read` visibility.\r\n- For POST operation parameters, properties are included if they have `Lifecycle.Create` visibility.\r\n- For PUT operation parameters, properties are included if they have `Lifecycle.Create` or `Lifecycle.Update` visibility.\r\n- For PATCH operation parameters, properties are included if they have `Lifecycle.Update` visibility.\r\n- For DELETE operation parameters, properties are included if they have `Lifecycle.Delete` visibility.\r\n- For GET or HEAD operation parameters, properties are included if they have `Lifecycle.Query` visibility.\r\n\r\nBy default, properties have all five Lifecycle visibility modifiers enabled, so a property is visible in all contexts\r\nby default.\r\n\r\nThe default settings may be overridden using the `@returnTypeVisibility` and `@parameterVisibility` decorators.\r\n\r\nSee also: [Automatic visibility](https://typespec.io/docs/libraries/http/operations#automatic-visibility)\r\n```typespec\r\n@visibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type |\n\nBy default, properties have all five Lifecycle visibility modifiers enabled, so a property is visible in all contexts\r\nby default.\r\n\r\nThe default settings may be overridden using the `@returnTypeVisibility` and `@parameterVisibility` decorators.\r\n\r\nSee also: [Automatic visibility](https://typespec.io/docs/libraries/http/operations#automatic-visibility)\r\n```typespec\r\n@visibility(...visibilities: valueof EnumMember[])\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibilities | `valueof EnumMember[]` | List of visibilities which apply to this property. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  // The service will generate an ID, so you don't need to send it.\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // The service will store this secret name, but won't ever return it.\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  // The regular name has all vi\r\n  name: string;\r\n}\r\n```\n\n### `@withDefaultKeyVisibility` {#@withDefaultKeyVisibility}\n\nSet the visibility of key properties in a model if not already set.\r\n\r\nThis will set the visibility modifiers of all key properties in the model if the visibility is not already _explicitly_ set,\r\nbut will not change the visibility of any properties that have visibility set _explicitly_, even if the visibility\r\nis the same as the default visibility.\r\n\r\nVisibility may be set explicitly using any of the following decorators:\r\n\r\n- `@visibility`\r\n- `@removeVisibility`\r\n- `@invisible`\r\n```typespec\r\n@withDefaultKeyVisibility(visibility: valueof EnumMember)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| visibility | `valueof EnumMember` | The desired default visibility value. If a key property already has visibility set, it will not be changed. |\n\n### `@withLifecycleUpdate` {#@withLifecycleUpdate}\n\nTransforms the `target` model to include only properties that are visible during the\r\n\"Update\" lifecycle phase.\r\n\r\nAny nested models of optional properties will be transformed into the \"CreateOrUpdate\"\r\nlifecycle phase instead of the \"Update\" lifecycle phase, so that nested models may be\r\nfully updated.\r\n```typespec\r\n@withLifecycleUpdate\r\n```\r\n\r\n#### Target\r\nThe model to apply the transformation to.\r\n`Model`\r\n\r\n#### Parameters\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@withLifecycleUpdate\r\nmodel DogUpdate {\r\n  ...Dog\r\n}\r\n```\n\n### `@withOptionalProperties` {#@withOptionalProperties}\n\nReturns the model with required properties removed.\r\n```typespec\r\n@withOptionalProperties\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\nNone\n-------------------------\n- document_dir: typespec_docs\n- document_filename: standard-library#pagination.md\n- document_title: Pagination\n- document_link: https://typespec.io/docs/standard-library/pagination\n- document_content: # standard-library#pagination.md\n\n# Pagination\n\nTypeSpec provide built-in support for some of the common pagination pattern used.\r\n\r\nPagination can be categorized into two types:\r\n\r\n- Client driven pagination: In this pattern, the client is responsible for managing the pagination state(figuring out the next page, previous page, etc).\r\n- Server driven pagination: In this pattern the server gives the client information on how to navigate to the next, previous, first, last page, etc.\n\n## Basics\n\nTo enable pagination for an operation the first step is to decorate it with the `@list` decorator and have the return type contain a property decorated with `@pageItems`\r\n\r\n```tsp\r\n@list op listPets(): {\r\n  @pageItems pets: Pet[];\r\n};\r\n```\n\n## Client driven pagination\n\nFor client driven pagination there are 3 decorators that can be used to annotate the operation parameters.\r\n\r\n- `@pageSize`: Number of items to return per page.\r\n- `@offset`: Number of items to skip\r\n- `@pageIndex`: Page index.\r\n\r\n`@offset` and `@pageIndex` are not necessary mutually exclusive but they are used to achieve the same goal.\n\n### Example 1: Fixed page size and offset\n\n```tsp\r\n@list op listPets(@offset skip?: int32 = 0): {\r\n  @pageItems pets: Pet[];\r\n};\r\n```\n\n### Example 2: Custom page size and offset\n\n```tsp\r\n@list op listPets(@offset skip?: int32, @pageSize perPage?: int32 = 100): {\r\n  @pageItems pets: Pet[];\r\n};\r\n```\n\n### Example 2: Custom page size and page index\n\n```tsp\r\n@list op listPets(@pageIndex page?: int32 = 1, @pageSize perPage?: int32 = 100): {\r\n  @pageItems pets: Pet[];\r\n};\r\n```\n\n## Server driven pagination\n\nFor server driven pagination, the server returns information on how to navigate to other pages. There is 5 decorators that can be used to annotate the corersonding properties:\r\n\r\n- `@nextLink`: Link to the next page.\r\n- `@prevLink`: Link to the previous page.\r\n- `@firstLink`: Link to the first page.\r\n- `@lastLink`: Link to the last page.\r\n- `@continuationToken`: Should be specified in both the parameters and return type of the operation. In the return type it is the token to navigate to the next page and in the parameters it mark which parameter to use to pass the next continuation token.\r\n\r\n:::note\r\nIt is possible to use server driven pagination on top of client driven pagination.\r\n:::\n\n### Example 1: Using continuation token for an HTTP service\n\n```tsp\r\n@list op listPets(@query @continuationToken token?: string): {\r\n  @pageItems pets: Pet[];\r\n  @continuationToken nextToken?: string;\r\n};\r\n```\n\n### Example 2: Using links for an HTTP service\n\n```tsp\r\n@list op listPets(): {\r\n  @pageItems pets: Pet[];\r\n  links: {\r\n    @nextLink next?: url;\r\n    @prevLink prev?: url;\r\n    @firstLink first?: url;\r\n    @lastLink last?: url;\r\n  };\r\n};\r\n```\n\n### Example 3: Combining client and server driven pagination for an HTTP service\n\n```tsp\r\n@list op listPets(@query @pageIndex page?: int32 = 1, @query @pageSize perPage?: int32 = 100): {\r\n  @pageItems pets: Pet[];\r\n\r\n  // Links would return the url resolve with page and perPage set\r\n  links: {\r\n    @nextLink next?: url;\r\n    @prevLink prev?: url;\r\n    @firstLink first?: url;\r\n    @lastLink last?: url;\r\n  };\r\n};\r\n```\n\n## Handling of additional parameters\n\nA paged operation can offer additional parameters that are not used as paging control parameters like a filter parameter for example.\r\nThe expectation is those would be carried over to the next page requests with the exception of the link cases(next, prev, first and last links) where each protocol might have a different interpretation of what the link exactly represents. The link may encode parameters such as query parameters in HTTP. In such cases those parameters must be passed.\r\n\r\nFor example, HTTP links are expected to be opaque and contain all the necessary information for the next page URL. This means that query and path parameters are expected to already have been included in the link. On the other hand, any header parameters are expected to be resent in the next request as those cannot be represented in the link.\n\n### Examples\n\n#### Next link pagination in Http\r\n\r\n```tsp\r\n@route(\"pets\")\r\n@list\r\nop listPets(\r\n  @query filter?: string,\r\n  @query expand?: string,\r\n  @query @pageIndex page?: int32 = 1,\r\n  @query @pageSize perPage?: int32 = 100,\r\n  @header specialHeader?: \"x-special-value\",\r\n): {\r\n  @pageItems pets: Pet[];\r\n  @nextLink next?: url;\r\n};\r\n```\r\n\r\n```http\r\n// First request\r\nGET /pets?filter=dog\r\nSpecial-Header: x-special-value\r\n\r\n{\"pets\": [...], \"nextLink\": \"/pets?filter=dog&page=2&perPage=100\"}\r\n\r\n// Second request\r\nGET /pets?filter=dog&token=token2\r\nSpecial-Header: x-special-value\r\n\r\n{\"pets\": [...], \"continuationToken\": \"token3\"}\r\n```\n", "latency": 7.3377509117126465, "response_length": 539}
{"query": "title: Renaming old enum names for SDK\n\nquestion: TypeSpec Discussion\n: Hi team,\nOur GA Swagger (and the underlying SDK) had some enum names that had abbreviations or acronyms etc. (e.g. PFAction). However, now we have moved to Typespec and the new SDKs based off of those generate the enum models as well (earlier SDKs from the GA APIs didnt have models).\nGiven this, in the SDK review there are suggestions to rename the enum names to better user friendly names which we agree with. However, I would rather prefer to rename the actual enum to a more meaningful name (e.g. PassFailAction) instead of going the client customization route. These will show up in all of our Swagger versions but I dont think its a breaking change since model type names dont make any sense for API users.\nGiven this, is it better to rename enum type names in the actual specification or should we stick to client customizations route?", "ground_truth": "Rename in the typespec. While some breaking change tools may trigger, we know there are many false positives when you do a conversion. Assuming you are not changing what goes on the wire, of course!", "response": "Renaming enum type names directly in the TypeSpec specification is generally the preferred approach over client customizations. This ensures consistency across all SDKs and avoids the need for language-specific overrides. Since model type names are not serialized over the wire, renaming them in the specification is not considered a breaking change for API users. Additionally, this approach aligns with TypeSpec best practices, which recommend clarity and meaningful naming in the main specification.\n\nIf you decide to rename the enum type names, ensure that the new names are user-friendly and well-documented. For example, you can use the `@doc` decorator to provide clear descriptions for each enum value. If you are unsure about the impact of renaming, consult with your emitter contact or run a thorough review of the generated SDKs to confirm the changes are applied correctly.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#05renaming.mdx\n- document_title: Renaming\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/05renaming\n- document_content: # howtos#generate-client-libraries#05renaming.mdx\n\n# Renaming\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents how to customize the name of models, operations, and parameters. For an overview of the setup, please visit the setup page.\r\n\r\n:::note\r\nThe TypeSpec compiler provides an `@encodedName` decorator that allows changing the name of the property for a given serialization format.\r\nHowever in Azure we recommend that you define the property name as the value sent on the wire and use the `@clientName` decorator to change the name of the generated property.\r\n:::\n\n## Default behaviors\n\nBy default, any language code generator will assume the TYPESPEC name is the client. For clarity, generators do not attempt to do any auto-magic rename.\r\n\r\n> **NOTE:** While names are not transformed, they will be adapted to what is idiomatic of the language (Python snake_case, etc.).\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=main.tsp\r\nnamespace PetStoreNamespace;\r\n\r\n/** This is the input I need */\r\n@resource(\"input\")\r\nmodel InputModel {\r\n  /** Id of this object */\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n}\r\n\r\n/** Read my resource */\r\nop get is ResourceRead<InputModel>;\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  name: str = rest_field(readonly=True)\r\n\r\nresponse: InputModel = client.get_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\ninterface InputModel {\r\n  name: string;\r\n}\r\n\r\nconst model: InputModel = await client.path(\"/petStore/model/{name}\").get();\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n## Customizations\n\n### Renaming models and attributes\n\nYou can rename models and attributes. [Renames have a target](https://microsoft.github.io/typespec/standard-library/projected-names#known-targets):\r\n\r\n- `client` means that all client will use that name\r\n- `csharp`, `javascript`, `python`, `java` means you target this specific language\r\n\r\nLanguage target takes priority over `client` target.\r\n\r\n> **NOTE:** As model name do not get serialized as JSON, sometimes the best choice is to rename the main TYPESPEC for clarity. Talk to your emitter contact is you're unsure\r\n> if you should rename the model in the main TYPESPEC or customize it.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(InputModel, \"InputOptions\"); // Use InputOptions as a base name in clients\r\n@@clientName(InputModel, \"ParameterOptions\", \"csharp\"); // Prefer a different name for C# only\r\n\r\n@@clientName(InputModel.name, \"input_name\", \"python\"); // Python may need a different to be idiomatic\r\n```\r\n\r\n```python\r\nclass InputOptions:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\n\r\nresponse: InputOptions = client.get_computed_model(input_name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class ParameterOptions\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\n\n{\r\n    // protocol method\r\n    public virtual async Task<Response> GetAsync(string name, RequestContext context) {}\r\n    public virtual Response Get(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<ParameterOptions>> GetAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<ParameterOptions> Get(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputOptions {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> getWithResponse(String name, RequestOptions requestOptions)\r\n    public InputOptions get(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\n\n### Renaming operations and parameters\n\nSimilarly, you can rename operations like in the example below:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=client.tsp\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(Get, \"Read\"); // Use InputOptions as a base name in clients\r\n@@clientName(Get, \"GetComputed\", \"python\"); // Note that Python will still snake_case it\r\n```\r\n\r\n```python\r\nclass InputModel:\r\n  input_name: str = rest_field(rest_name=\"name\", readonly=True)\r\nresponse: InputModel = client.get_computed_model(name=\"name\")\r\n```\r\n\r\n```csharp\r\nnamespace PetStoreNamespace.Models\r\n{\r\n  public partial class InputModel\r\n  {\r\n    public string Name { get; }\r\n  }\r\n}\r\n\r\nnamespace PetStoreNamespace\r\n{\r\n  public partial class PetStoreNamespaceClient\r\n  {\r\n    // protocol method\r\n    public virtual async Task<Response> ReadModelAsync(string name, RequestContext context) {}\r\n    public virtual Response ReadModel(string name, RequestContext context) {}\r\n    // convenience method\r\n    public virtual async Task<Response<InputModel>> ReadModelAsync(string name, CancellationToken cancellationToken = default) {}\r\n    public virtual Response<InputModel> ReadModel(string name, CancellationToken cancellationToken = default) {}\r\n  }\r\n}\r\n```\r\n\r\n```typescript\r\n// Typescript do not change behavior based on protocolAPI or convenientAPI\r\n```\r\n\r\n```java\r\npackage petstorenamespace.models;\r\npublic final class InputModel {\r\n    public String getName()\r\n}\r\n\r\npackage petstorenamespace;\r\npublic final class PetStoreNamespaceClient {\r\n    public Response<BinaryData> readModelWithResponse(String name, RequestOptions requestOptions)\r\n    public InputModel readModel(String name)\r\n}\r\n```\r\n\r\n</ClientTabs>\r\n\r\nYou cannot at this moment rename parameters in the client.tsp file. You will need to add the `@clientName` decorator over the parameter directly, example:\n\n## Implementation\n\n### Order of Operations\n\nFor consistency when generating code, the order in which overrides are applied is important. Code emitters should apply overrides in the following order.\r\n\r\n#### Over-the-Wire JSON Names\r\n\r\nFor determining the final name of a TypeSpec entity when sent over-the-wire in JSON:\r\n\r\n1. If the `@encodedName` decorator exists, use this value\r\n2. Use the original name in the spec\r\n\r\n#### Client SDK Names\r\n\r\nFor determining the final name of a TypeSpec entity when used in a client SDK (e.g. Python):\r\n\r\n1. Check if there's a scoped `@clientName` decorator for your emitter\r\n2. Check if there's a `@clientName` decorator at all\r\n3. Check the friendly name\r\n4. Use the original name in the spec\r\n\r\n**Note: If the object name is from `@clientName` decorator, do not apply your language's casing rules on it. If it's not, apply your language's heuristics (i.e. for Python, apply snake casing)**\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-arm-tips.md\n- document_title: Migrate ARM spec\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\n- document_content: # migrate-swagger#checklists#migrate-arm-tips.md\n\n# Migrate ARM spec\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\n **DO** name your ARM spec folder with `.Management` suffix.\r\n\r\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/resource-manager\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** ensure you have correct ARM common type version select with each service version. Example:\r\n\r\n```tsp\r\n  ...\r\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)  <---\r\n  v2021_10_01_preview: \"2021-10-01-preview\",\r\n```\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure.ResourceManager and Azure.Core operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n **DO** make client customizations in a `client.tsp` file\n\nas possible\r\n\r\n **DO** use `union` instead of `enum` to define Azure extensible enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates `xxx.Private` namespaces\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/next/libraries/azure-resource-manager/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n", "latency": 8.654848575592041, "response_length": 885}
{"query": "title: SdkTspConfigValidation\n\nquestion: I'm making unrelated changes to my spec and tsv fails locally:\n```\nExecuting rule: SdkTspConfigValidation\n[SdkTspConfigValidation]: validation failed.\n- Failed to find \"parameters.service-dir.default\". Please add \"parameters.service-dir.default\".\n- Failed to find \"options.@azure-tools/typespec-java.package-dir\". Please add \"options.@azure-tools/typespec-java.package-dir\".\n- Failed to find \"options.@azure-tools/typespec-ts.generateMetadata\". Please add \"options.@azure-tools/typespec-ts.generateMetadata\".\n- Failed to find \"options.@azure-tools/typespec-ts.hierarchyClient\". Please add \"options.@azure-tools/typespec-ts.hierarchyClient\".\n- Failed to find \"options.@azure-tools/typespec-ts.experimentalExtensibleEnums\". Please add \"options.@azure-tools/typespec-ts.experimentalExtensibleEnums\".\n- Failed to find \"options.@azure-tools/typespec-ts.enableOperationGroup\". Please add \"options.@azure-tools/typespec-ts.enableOperationGroup\".\n- Failed to find \"options.@azure-tools/typespec-ts.package-dir\". Please add \"options.@azure-tools/typespec-ts.package-dir\".\n- Failed to find \"options.@azure-tools/typespec-ts.packageDetails.name\". Please add \"options.@azure-tools/typespec-ts.packageDetails.name\".\n- Failed to find \"options.@azure-tools/typespec-go.service-dir\". Please add \"options.@azure-tools/typespec-go.service-dir\".\n```\nI searched for SdkTspConfigValidation in this team (across channels) but couldn't find a single mention of it.\nHere's my README:\nMarkdown\n```yaml $(swagger-to-sdk)\nswagger-to-sdk:\n- repo: azure-resource-manager-schemas\n- repo: azure-sdk-for-net\n- repo: azure-powershell\n- repo: azure-cli-extensions\n```\nwhich is just a stub, I don't mind removing all of it for now. But I don't have any references of Java, TS, or Go. Where is it coming from?", "ground_truth": "Rule `SdkTspConfigValidation` should generate warnings, but not errors and not cause TSV to fail.  You can ignore the warnings for now.", "response": "The validation errors you are encountering are related to missing configurations in your `tspconfig.yaml` file. Specifically, the `SdkTspConfigValidation` rule is checking for certain parameters and options that are expected to be defined in your TypeSpec configuration. These include settings for emitters like `@azure-tools/typespec-java`, `@azure-tools/typespec-ts`, and `@azure-tools/typespec-go`. \n\nEven though your project does not explicitly reference Java, TypeScript, or Go, these configurations might be required by default if you are using a template or extending a base configuration that includes these emitters. \n\nTo resolve this issue, you can:\n\n1. **Add the missing configurations**: Update your `tspconfig.yaml` file to include the required parameters and options. For example:\n\n```yaml\ntspconfig.yaml\nparameters:\n  service-dir:\n    default: \"<your-default-service-dir>\"\n\noptions:\n  @azure-tools/typespec-java:\n    package-dir: \"<your-java-package-dir>\"\n  @azure-tools/typespec-ts:\n    generateMetadata: true\n    hierarchyClient: true\n    experimentalExtensibleEnums: true\n    enableOperationGroup: true\n    package-dir: \"<your-ts-package-dir>\"\n    packageDetails:\n      name: \"<your-package-name>\"\n  @azure-tools/typespec-go:\n    service-dir: \"<your-go-service-dir>\"\n```\n\nReplace `<your-default-service-dir>` and other placeholders with appropriate values for your project.\n\n2. **Remove or disable the emitters**: If you are not using these emitters, you can remove or disable them in your `tspconfig.yaml` file. For example:\n\n```yaml\ntspconfig.yaml\nemit: []\n```\n\nThis will prevent the emitters from running and eliminate the need for their configurations.\n\n3. **Check for inherited configurations**: If your `tspconfig.yaml` file uses the `extends` property to inherit settings from another configuration file, ensure that the parent configuration does not include these emitters or their options unless they are required for your project.", "context": "- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: handbook#configuration#configuration.mdx\n- document_title: Configuration\n- document_link: https://typespec.io/docs/handbook/configuration/configuration\n- document_content: # handbook#configuration#configuration.mdx\n\n# Configuration\n\nimport { FileTree } from \"@astrojs/starlight/components\";\r\n\r\nThe TypeSpec compiler and libraries can be configured either via a configuration-file or command line flags.\n\n## Configuration file\n\nTypeSpec configuration can be provided via the `tspconfig.yaml` configuration file.\n\n### Discovery\n\nThe TypeSpec compiler will look for the closest `tspconfig.yaml` file located in the same directory or closest parent directory from the TypeSpec entrypoint.\r\n\r\nFor example if running `tsp compile /dev/foo/bar/main.tsp`, the compiler will lookup the file at the folllowing paths (in order):\r\n\r\n- `/dev/foo/bar/tspconfig.yaml`\r\n- `/dev/foo/tspconfig.yaml`\r\n- `/dev/tspconfig.yaml`\r\n- `/tspconfig.yaml`\n\n### Schema\n\nThe file is a `yaml` document with the following structure. See the [next section](#typespec-configuration-options) for details on each option.\r\n\r\n```typespec\r\nmodel TypeSpecProjectSchema {\r\n  extends?: string;\r\n  parameters?: Record<{default: string}>\r\n  `environment-variables`?: Record<{default: string}>\r\n  `warn-as-error`?: boolean;\r\n  `output-dir`?: string;\r\n  `trace`?: string | string[];\r\n  imports?: string[];\r\n  emit?: string[];\r\n  `dry-run`?: boolean;\r\n  options?: Record<unknown>;\r\n  linter?: LinterConfig;\r\n}\r\n\r\nmodel LinterConfig {\r\n  extends?: RuleRef[];\r\n  enable?: Record<RuleRef, boolean>;\r\n  disable?: Record<RuleRef, string>;\r\n}\r\n```\n\n### Extending Project Files\n\nThere may be instances where you want to build different folders with varying options (such as different emitters), but still want to share some common configurations.\r\n\r\nIn such cases, you can use the `extends` property in the configuration file.\r\n\r\nFor instance, in `<my-pkg>/tspconfig.yaml`:\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  emitter1:\r\n    some-option: my-name\r\n  emitter2:\r\n    some-other-option: This is a title\r\n```\r\n\r\nin `<my-pkg>/proj2/tspconfig.yaml`, enable `emitter1` using the options specified in the parent `tspconfig.yaml`\r\n\r\n```yaml title=proj2/tspconfig.yaml\r\nextends: ../tspconfig.yaml\r\nemit:\r\n  - emitter1\r\n```\n\n### Variable interpolation\n\nThe TypeSpec project file provides variable interpolation using:\r\n\r\n- built-in variables\r\n- environment variables\r\n- config file parameters\r\n- emitter options can reference each other\r\n\r\nVariable interpolation is done using an variable expression surrounded by `{` and `}`. (`{<expression>}`)\r\n\r\nExamples:\r\n\r\n- `{output-dir}/my-path`\r\n- `{env.SHARED_PATH}/my-path`\n\n### Interpolation of Emitter Path Config\n\nfile can specify which environment variables it can interpolate.\r\n\r\nThe `{cwd}` and `{project-root}` variables can be used in the default value of these environment variables.\r\n\r\nThese environment variables can then be referred to by their name in a variable interpolation expression, using the `env.` prefix.\r\n\r\nAll environment variables must have a default value.\r\n\r\n**Example:**\r\n\r\n```yaml title=tspconfig.yaml\r\nenvironment-variables:\r\n  BASE_DIR:\r\n    default: \"{cwd}\"\r\n\r\noutput-dir: {env.BASE_DIR}/output\r\n```\r\n\r\n#### Emitter Options\r\n\r\nEmitter options can refer to each other by using the other option's name as the variable expression.\r\n\r\nInterpolation is only possible among emitter options from the same emitter.\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  @typespec/openapi3:\r\n    emitter-output-dir: {output-dir}/{emitter-sub-folder}\r\n    emitter-sub-folder: bar\r\n\r\n```\r\n\r\nEmitter options support a nested structure, enabling complex configurations.\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  emitter-sub-folder:\r\n    sub-folder: bar\r\n```\r\n\r\nTo set these values via the CLI, use dots to navigate deeper levels in the definition. `--option \"<option-name>.<nested-option-name>=<value>\"`\r\nDue to this capability, emitter option names should not contain a `.` in their name.\n\n|\r\n| `emitter-name`             | emitter options          | Name of the emitter                                                                  |\r\n| `service-name`             | service name             | Name of the service                                                                  |\r\n| `service-name-if-multiple` | service name if multiple | Name of the service if multiple, undefined if one                                    |\r\n\r\n#### Project Parameters\r\n\r\nA TypeSpec project file can define certain parameters that can subsequently be specified through the CLI.\r\nParameters can be organized in a nested structure, to access different levels of the structure, use dots (`.`) in the variable expression.\r\nTherefore, parameter names should not contain `.` in their name.\r\n\r\nThe `{cwd}` and `{project-root}` variables can be utilized in the default value of these parameters.\r\n\r\nThese parameters can then be referred to by their name in a variable interpolation expression.\r\n\r\nAll parameters must have a default value.\r\n**Example:**\r\n\r\n```yaml title=tspconfig.yaml\r\nparameters:\r\n  base-dir:\r\n    default: \"{cwd}\"\r\n\r\noutput-dir: {base-dir}/output\r\n```\r\n\r\nThe parameter can then be specified via `--arg` in this format `--arg \"<parameter-name>=<value>\"` and for nested structures `--arg \"<parameter-name>.<nested-parameter-name>=<value>\"`\r\n\r\n```bash\r\ntsp compile . --arg \"base-dir=/path/to/base\"\r\n```\r\n\r\n#### Environment variables\r\n\r\nA TypeSpec project file can specify which environment variables it can interpolate.\r\n\r\nThe `{cwd}` and `{project-root}` variables can be used in the default value of these environment variables.\r\n\r\nThese environment variables can then be referred to by their name in a variable interpolation expression, using the `env.` prefix.\r\n\r\nAll environment variables must have a default value.\r\n\r\n**Example:**\r\n\r\n```yaml title=tspconfig.yaml\r\nenvironment-variables:\r\n  BASE_DIR:\r\n    default: \"{cwd}\"\r\n\r\noutput-dir: {env.\n\nCertain emitter configurations can be interpolated using a specific rule designed to collapse a path.\r\n\r\nIf a variable is succeeded by a `/` or `.` and the emitter responsible for interpolating the config doesn't supply that variable, the path segment will be omitted.\r\n\r\nFor instance, consider the following config value: `{service-name}/output.{version}.json`\r\nHere's what would be produced:\r\n\r\n| Service name value | Version value | Result                    |\r\n| ------------------ | ------------- | ------------------------- |\r\n| `\"PetStore\"`       | `\"v1\"`        | `PetStore/output.v1.json` |\r\n| `\"PetStore\"`       | `undefined`   | `PetStore/output.json`    |\r\n\r\n#### Built-in variables\r\n\r\n| Variable name              | Scope                    | Description                                                                          |\r\n| -------------------------- | ------------------------ | ------------------------------------------------------------------------------------ |\r\n| `cwd`                      | \\*                       | Points to the current working directory                                              |\r\n| `project-root`             | \\*                       | Points to the the tspconfig.yaml file containing folder.                             |\r\n| `output-dir`               | emitter options          | Common `output-dir` See [output-dir](#output-dir---configure-the-default-output-dir) |\r\n| `emitter-name`             | emitter options          | Name of the emitter                                                                  |\r\n| `service-name`             | service name             | Name of the service                                                                  |\r\n| `service-name-if-multiple` | service name if multiple | Name of the service if multiple, undefined if one                                    |\r\n\r\n#### Project Parameters\n\n## TypeSpec Configuration Options\n\n| Config          | Cli                       | Description                                              |\r\n| --------------- | ------------------------- | -------------------------------------------------------- |\r\n| `output-dir`    | `--output-dir`            | Default output directory                                 |\r\n| `config`        | `--config`                | Path to config file or folder to search for config file. |\r\n| `trace`         | `--trace`                 | Specify tracing area to enable                           |\r\n| `warn-as-error` | `--warn-as-error`         | Treat warning as error                                   |\r\n| `imports`       | `--import`                | Additional imports to include                            |\r\n| `emit`          | `--emit`                  | Emitter configuration                                    |\r\n| `options`       | `--option` or `--options` | Emitter configuration                                    |\r\n| `dry-run`       | `--dry-run`               | Tell emitters to run in dryRun mode                      |\r\n| `linter`        |                           | Linter configuration                                     |\n\n### `output-dir` - Configure the default output dir\n\nSpecify the common output-dir for all emitters. See [this](#configuring-output-directory) to configure per emitter.\r\n\r\n```yaml title=tspconfig.yaml\r\noutput-dir: {cwd}/typespec-build\r\n```\r\n\r\nOutput dir can be provided using the `--output-dir` cli flag\r\n\r\n```bash\r\ntsp compile . --output-dir \"./typespec-build\"\r\n```\r\n\r\nOutput dir must be an absolute path in the config. Use `{cwd}` or `{project-root}` to explicitly specify what it should be relative to.\r\n\r\nSee [output directory configuration for mode details](#configuring-output-directory)\n\n### `trace` - Configure what to trace\n\nConfigure what area to trace. See [tracing docs](./tracing.md)\r\n\r\n```yaml title=tspconfig.yaml\n\n# Trace all.\n\ntrace: *\n\n# or specific areas\n\ntrace:\r\n  - import-resolution\r\n  - projection\r\n```\r\n\r\nTrace can be provided using the `--trace` cli flag\r\n\r\n```bash\r\ntsp compile . --trace import-resolution --trace projection\r\n```\n\n### `warn-as-error` - Treating Warnings as Errors\n\nAll warnings will be treated and emitted as errors, resulting in a non-zero exit code in the event of a warning.\r\n\r\n**It is recommended to use this feature in Continuous Integration (CI) to ensure all warnings are addressed.**\r\n\r\n```yaml title=tspconfig.yaml\r\nwarn-as-error: true\r\n```\r\n\r\nor via the cli\r\n\r\n```bash\r\ntsp compile . --warn-as-error\r\n```\n\n### `--ignore-deprecated`\n\nSuppress all `deprecated` diagnostics that are raised when declarations are marked with the `#deprecated` directive.\r\n\r\n```bash\r\ntsp compile . --ignore-deprecated\r\n```\n\n### `imports` - Configure additional imports\n\n```yaml title=tspconfig.yaml\r\nimports:\r\n  - sidecar.tsp\r\n```\r\n\r\nSpecify additional TypeSpec files to import\r\n\r\n```bash\r\ntsp compile . --import \"sidecar.tsp\"\r\n```\n\n### `emit` - Specifying which emitters to run\n\nSpecify which emitters to use and their options if applicable.\r\n\r\nThe value can be the name of an emitter or a path to the emitter package/entrypoint.\r\n\r\n```yaml title=tspconfig.yaml\r\nemit:\r\n  - emitter1 # Package name\r\n  - /path/to/emitter2 # Give a path to an emitter\r\n```\r\n\r\nor via the cli\r\n\r\n```bash\r\ntsp compile . --emit emitter1 --emit /path/to/emitter2\r\n```\n\n### `options` - Configuring emitters\n\nEmitters can define a set of options, those can be set as the value of the map.\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  # Enable and configure emitter1\r\n  emitter1:\r\n    option1: \"option1-value\"\r\n    option2: \"option1-value\"\r\n  # Only enable emitter2\r\n  emitter2: true\r\n```\r\n\r\nEmitters options can also be provided using the `--option` in this format `--option=<emitterName>.<optionName>=<value>`\r\n\r\n```bash\r\ntsp compile . --option \"emitter1.option1=option1-value\"\r\n```\r\n\r\nOptions specified via the CLI take precedence over the ones specified in `tspconfig.yaml`.\r\n\r\n#### Emitters built-in options\r\n\r\n##### `emitter-output-dir`\r\n\r\nRepresent the path where the emitter should be outputing the generated files.\r\n\r\nDefault: `{output-dir}/{emitter-name}`\r\n\r\nSee [output directory configuration for mode details](#configuring-output-directory)\n\n### `linter` - Setting Up Linters\n\nThis allows you to configure the linter rules to be enabled in this repository. When referencing a rule or ruleset, use their ID, which follows the format `<libraryName>:<ruleName>`.\r\n\r\n```yaml\r\nlinter:\r\n  extends: # Extend `recommended` ruleset from @typespec/best-practices library\r\n    - \"@typespec/best-practices/recommended\"\r\n\r\n  enable: # Explicitly enable some rules\r\n    \"@typespec/best-practices/no-x\": true\r\n\r\n  disable: # Disable some rules defined in one of the ruleset extended.\r\n    \"@typespec/best-practices/no-y\": \"This rule cannot be applied in this project because X\"\r\n```\n\n## CLI Flags for Emitter Control\n\n### `--no-emit`\n\nThis flag disables emitters. Emitters will not run, and no files will be emitted.\r\n\r\nThis flag can also be used to suppress the \"There are no emitters\" warning.\r\n\r\n```yaml title=tspconfig.yaml\r\ntsp compile . --no-emit\r\n```\n\n### `--dry-run`\n\nThis flag tells compatible emitters to run in dry-run mode. In this mode, emitters will not emit any files, but will still run and log diagnostics.\r\n\r\n```yaml title=tspconfig.yaml\r\ntsp compile . --dry-run\r\n```\n\n## Other Command line flags\n\n### `--config`\n\nSpecify a different config file\r\n\r\n```bash\r\ntsp compile . --config ./tspconfig.alt.yaml\r\n```\n\n### `--watch`\n\nStart the tsp compiler in watch mode: watch for file changes and compile on save.\r\n\r\n```bash\r\ntsp compile . --watch\r\n```\r\n\r\n:::caution\r\nKnown issue: the watch mode does not pickup changes in JS files that are indirectly included (only imported via another JS file.)\r\n:::\n\n### `--nostdlib`\n\nDon't load the TypeSpec standard library.\r\n\r\n```bash\r\ntsp compile . --nostdlib\r\n```\n\n### `--version`\n\nLog the version of the tsp compiler.\r\n\r\n```bash\r\ntsp compile . --version\r\n```\n\n### `--pretty`\n\n**Default: `true`**\r\n\r\nEnable/Disable pretty logging (colors, diagnostic preview, etc.).\r\n\r\n```bash\r\ntsp compile . --pretty=false\r\n```\n\n## Configuring Output Directory\n\nThe TypeSpec compiler assigns a unique output directory to each emitter that runs, in order to minimize conflicts. By default, the output directory of an emitter is set to:\r\n\r\n```\r\n{output-dir}/{emitter-name}\r\n```\r\n\r\nwhere:\r\n\r\n- `output-dir` is the common output directory for the compiler, which can be configured via `--output-dir`.\r\n- `emitter-name` is the name of the emitter package (for example, `/openapi3`).\r\n\r\nFor instance, if the emitters `@typespec/openapi3` and `@typespec/jsonschema` are given, the default output folder structure would be:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- \\{project-root}/tsp-output\r\n  - @typespec:\r\n    - openapi3\r\n      - ... openapi3 files ...\r\n    - jsonschema\r\n      - ... json schema files ...\r\n</FileTree>\r\n\r\nYou can change the compiler's `output-dir` with `--output-dir` or by setting that value in the tspconfig.yaml, which would result in the following structure:\r\n\r\n```bash\r\n--output-dir={cwd}/my-custom-output-dir\r\n```\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- \\{cwd}/my-custom-output-dir\r\n  - @typespec:\r\n    - openapi3\r\n      - ... openapi3 files ...\r\n    - jsonschema\r\n      - ... json schema files ...\r\n</FileTree>\r\n\r\nTo change a specific emitter's output directory, you can set the `emitter-output-dir` option for that emitter:\r\n\r\n```bash\r\n--option \"@typespec/openapi3.emitter-output-dir={project-root}/openapispec\"\r\n```\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- \\{project-root}\r\n  - openapispec\r\n    - ... openapi3 files ...\r\n  - tsp-output\r\n    - @typespec\r\n      - jsonschema\r\n        - ... json schema files ...\r\n</FileTree>\n-------------------------\n- document_dir: typespec_docs\n- document_filename: introduction#editor#vscode.md\n- document_title: VS Code Extension\n- document_link: https://typespec.io/docs/introduction/editor/vscode\n- document_content: # introduction#editor#vscode.md\n\n# VS Code Extension\n\n## Installation\n\nInstall the extension via the Visual Studio Code extension manager [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=typespec.typespec-vscode)\n\n## Features\n\nThe TypeSpec extension for Visual Studio Code enhances the development of TypeSpec by leveraging VS Code's powerful features. It provides:\r\n\r\n- IntelliSense and syntax highlighting\r\n- Code autocompletion and formatting\r\n- Live diagnostics and quick fixes\r\n- Refactoring tools (rename, go-to definition, etc.)\r\n- Seamless project setup and emitter configuration <_new_>\r\n- Import TypeSpec from existing OpenAPI 3 definitions <_new_>\r\n- Emit code from TypeSpec <_new_>\r\n- Preview API documentation <_new_>\n\n## Commands\n\nThe extension provides the following commands:\r\n\r\n| **Command**                                        | **Description**                                                     |\r\n| -------------------------------------------------- | ------------------------------------------------------------------- |\r\n| `TypeSpec: Create TypeSpec Project`                | Scaffold a new TypeSpec project.                                    |\r\n| `TypeSpec: Install TypeSpec Compiler/CLI globally` | Install the TypeSpec Compiler/CLI globally.                         |\r\n| `TypeSpec: Generate From TypeSpec`                 | Compile and generate from TypeSpec files into the specified output. |\r\n| `TypeSpec: Restart TypeSpec Server`                | Restart the TypeSpec language server.                               |\r\n| `TypeSpec: Show Output Channel`                    | Open the TypeSpec output channel to view logs.                      |\r\n| `TypeSpec: Preview API Documentation`              | Preview API documentation generated from TypeSpec in the workspace. |\r\n| `TypeSpec: Import TypeSpec from OpenAPI 3`         | Import TypeSpec from existing OpenAPI 3 definitions                 |\n\n## Configuration\n\nTypeSpec will interpolate a few variables using this pattern: `${<name>}`. For example: `${workspaceFolder}`.\r\n\r\nAvailable variables:\r\n\r\n- `workspaceFolder`: Corresponds to the root of your Visual Studio workspace.\n\n### `typespec.tsp-server.path`: Configure the server path\n\nThere are cases where the TypeSpec project is located in a subfolder. In such cases, the TypeSpec extension is not able to find the tsp compiler automatically and needs a little guidance.\r\nThis setting allows you to configure where the tsp compiler is located:\r\n\r\n```json\r\n{\r\n  \"typespec.tsp-server.path\": \"${workspaceFolder}/my-nested-project/node_modules/@typespec/compiler\"\r\n}\r\n```\n\n## Uninstall\n\nYou can uninstall the extension via the Visual Studio Code extension manager or through the command line:\r\n\r\n```bash\r\ntsp code uninstall\n\n# For VS Code insiders\n\ntsp code uninstall --insiders\r\n```\n\n## Telemetry\n\nThe extension for Visual Studio Code collects usage data and sends it to Microsoft to help improve our products and services. Read our [privacy statement](https://privacy.microsoft.com/privacystatement) to learn more. This extension respects the `telemetry.telemetryLevel` setting which you can find more information in the [FAQ](https://code.visualstudio.com/docs/supporting/faq#_how-to-disable-telemetry-reporting).\n\n### What telemetry data are collected\n\n- OperationTelemetry\r\n\r\n| Telemetry name | Type     | Example                            |\r\n| -------------- | -------- | ---------------------------------- |\r\n| EventName      | string   | \"start-extension\" for example      |\r\n| ActivityId     | string   |                                    |\r\n| StartTime      | datatime |                                    |\r\n| EndTime        | datatime |                                    |\r\n| Result         | string   | \"success\",\"fail\",\"cancelled\", etc. |\r\n| LastStep       | string   |                                    |\r\n\r\n- OperationDetailTelemetry\r\n\r\n| Telemetry name   | Type   | Example                                                                                                                      |\r\n| ---------------- | ------ | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| ActivityId       | string |                                                                                                                              |\r\n| EmitterName      | string | The extension will log only names of pre-defined emitters. Unknown emitters from customers will be masked to ensure privacy. |\r\n| EmitterVersion   | string |                                                                                                                              |\r\n| CompilerVersion  | string |                                                                                                                              |\r\n| CompilerLocation | string | \"global-compiler\", \"local-compiler\", etc. It is not to store the actual path of compiler being installed.                    |\r\n| Error            | string | tsp compiling errors                                                                                                         |\n", "latency": 14.465287446975708, "response_length": 1958}
{"query": "title: Versioning of updating the interface of an operation\n\nquestion: I have a question about versioning.\nIn the current version, this is an operation that we have,\n```\ninterface ItemsOperations {\n/** List top-level items. */\nlist is ListOperation<ItemDetails>;\n}\n```\nIn the new version, we add query parameters to this interface,\n```\nlist is CustomListOperation<\nResource = ItemDetails,\nResponse = PagedItemDetails,\nParameters = {\n...CustomFilterQueryParameter;\n...CustomSkipQueryParameter;\n...CustomTopQueryParameter;\n...CustomOrderByQueryParameter;\n}\n>;\n```\nWhat can I do to apply versioning to these two operations in different versions? Thanks\nI was planning to add @add to the new version, and @remove in the old version, but the error indicates there are two list operations (different versions)\nIf I remove the old version and only use the current one, I see this error, I do not know how to fix this issue either", "ground_truth": "Generally, the easiest way to version such an operation is to version the data (in this case, the parameters).  [Here is an example](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgVHlwZVNwZWMuSHR0cDvQFVJlc3TRFVbpAKnIG0HEZS5Db3JlzhJSx3dNxnY7CgovKiogQ29udG9zbyDIHiBQcm92aWRlciDmAJ5tZW50IEFQSS4gKi8KQGFybcggTmFtZXNwYWNlCkBzZXJ2aWNlKHsKICB0aXRsZTogIsdYyC5IdWJDbGllbnQiLAp9KQpA5wFgZWQo5wDBcykKbshSIE1pY3Jvc29mdC7SR%2B8AuEFQSSDHTXPkAKNlbnVtIMhUIOQAksQuMjAyMS0xMC0wMS1wcmV2aWV3yDXENCAgQHVzZURlcGVuZGVuY3ko9QEx6AFrcy52MV8wX1DGSF8xKdhA5AGD1zUyxTVhcm1Db21tb27kAc5zxyrXfcspy1Q1xEhg8gDeYCwK6gD6NP8A%2Bv8A%2Bv8A%2Bv8A%2Bv8A%2Bv8A%2Bv8A%2BuQA%2Bu8A3mAsCn3mAiJB6AIk6wI9IOgDfOQA%2FW1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUCUy4u6QCm5AMHUGFyYW1ldGVyyTE%2BO%2BgAhslfcMlE0nzKYOkCskFnZSBvZiBlyD%2FlAa1hZ2U%2FOiBpbnQzMjvoAeFDaXR50ipjaXR5Pzogc3Ry5QQaxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAWBwxjA%2FOiBieXRlc8lIVGhlIHN0YXR1c8RLdGhlIGxhc3Qg5ADFYXRpb27lBC0gIEB2aXNpYmlsaXR5KCJyZWFkyFXEGOUEtFN0YXTEX%2BUBo8wU6QFAxGvMMsV45QDCYekBzcVvQGxyb8Q7dXMKdW7kAt%2FRVOUBXOYBEukDH8RfyEcgY3JlxCdyZXF1ZXN0IGhhcyBiZWVuIGFjY2VwdGVkxGcgIEHHDjogIsgLItZQacRA5AC06QDByETsAJw6ICLMD9pMdXBkYXTET8VDVccOOiAiyAvKO%2BkFzukAxOYA3GTnAZpTdWNjZWVk5QDFyQzTP8U25AFNZmFpbMk%2BRsUNOiAixgncOHdhcyBjYW5jZco%2BQ8cP5AYlxwv%2FAUAgZGVsZekBgETEDeYA%2BcgL5AZV7wNvbW926gHK6QNxTW92ZVLHFegDasRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA0jLM3RvzzF0b8ov9wCVc3BvbnPrBIPmAJbHFuwAl%2B4DZMU%2BxWTGfOYC7s1uYWxpYXMgUXVlcnnpBJVzID3NVW51bWJlcsRVaXRlbXPkAMJza2lwxlpAYWRk6weVLvQFYuUFwnHEZOQDUGtpcPIEacRobWF4aW11bdRwcmV0dXLoBoHfctFydG%2FMcX07CgppbnRlcmbkCDlP6ASCcyBleHRlbmRz9gj9Lsspe30K5QjZyCPKG8tZ6AHD5gWhZ2V05AKdQco1UmVhZOwF%2FiDnA3FPcuUDneUCzMsvQ8cdUmVwbGFjZUFzeW5jzj%2FlA%2B3QN1BhdGNoU8wsLPMGRMVA5gMzz0DlAzBlV2l0aG91dE9r03dsaXN0QnnIMEdyb3Vwz0RMxSJQYXJlbnQ8CiAgIOkAgizFDu0CeO8CigogIMtmU3Vic2NyaXDlAzzGZcZdzBnsAJ%2FoBxsgc2FtcGzrBClhY8VEdGhhdOYDJukG3nRvIGRpZmZl5ACu7wOpxSnuANxBxUjvAWHrBDTIDeYDq%2FMAkkhFQUTqBwfEfmNoZWNr6gCqZXhpc3RlbuYIgSDGHkXJFO8CJc0d7ghc&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D) of how you would do this in ArmResourceListByParent, but using the Parameters prameter of any operation template shoudl work similarly.", "response": "To apply versioning to your operations, you can use the `@versioned` decorator to define API versions and the `@added` decorator to specify when a particular operation or model was introduced. Here's how you can handle the versioning for your `list` operation:\n\n1. **Define Versions**: Use the `@versioned` decorator to define the versions supported by your API. For example:\n\n```tsp\nimport \"@typespec/versioning\";\n\nusing Versioning;\n\n@versioned(Versions)\nnamespace ItemsAPI;\n\nenum Versions {\n  v1: \"1.0\",\n  v2: \"2.0\",\n}\n```\n\n2. **Version-Specific Operations**: Use the `@added` decorator to specify which version an operation was introduced in. For example:\n\n```tsp\ninterface ItemsOperations {\n  /** List top-level items in version 1 */\n  @added(Versions.v1)\n  listV1 is ListOperation<ItemDetails>;\n\n  /** List top-level items with query parameters in version 2 */\n  @added(Versions.v2)\n  listV2 is CustomListOperation<\n    Resource = ItemDetails,\n    Response = PagedItemDetails,\n    Parameters = {\n      ...CustomFilterQueryParameter;\n      ...CustomSkipQueryParameter;\n      ...CustomTopQueryParameter;\n      ...CustomOrderByQueryParameter;\n    }\n  >;\n}\n```\n\n3. **Remove Deprecated Operations**: If you want to remove the old version, you can use the `@removed` decorator to indicate that an operation is no longer available in a specific version.\n\n```tsp\n@removed(Versions.v2)\nlistV1 is ListOperation<ItemDetails>;\n```\n\nThis approach ensures that both versions of the `list` operation are clearly defined and versioned, avoiding conflicts and errors during compilation.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step09.md\n- document_title: 9. Customizing operations with traits\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step09\n- document_content: # getstarted#azure-core#step09.md\n\n# 9. Customizing operations with traits\n\nFor all standard lifecycle operations you can customize the operation parameters and response body by passing a special model type to the `Traits` parameter of the operation template, typically the second parameter of the operation template. You can also customize the whole set of resource operations by passing traits to the `ResourceOperations` interface.\r\n\r\nYou can combine multiple traits using the model intersection operator `&`. Here's an example of defining the `ServiceTraits` with `SupportsRepeatableRequests`, `SupportsConditionalRequests` and `SupportsClientRequestId`. These are then passed into the `Azure.Core.ResourceOperations` template:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = Azure.Core.ResourceOperations<ServiceTraits>;\r\n```\r\n\r\nTraits can be applied simultaneously at both the interface and operation level, they will be composed together when your operation is defined.\r\n\r\nFor example, if you wanted to add standard list operation query parameters to the `listWidgets` operation, you could use the `ListQueryParametersTrait`:\r\n\r\n```typespec\r\n/** List Widget resources */\r\nop listWidgets is Operations.ResourceList<\r\n  Widget,\r\n  ListQueryParametersTrait<StandardListQueryParameters & SelectQueryParameter>\r\n>;\r\n```\n\n## Useful trait types\n\nThe following trait types can be used for typical operation customization patterns:\n\n### `QueryParametersTrait<TParams, Contexts>`\n\nThis trait adds query parameters to operation signatures. It accepts a model type containing the query parameters that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is Operations.ResourceRead<\r\n  Widget,\r\n  QueryParametersTrait<{\r\n    @query foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@query` or an error will be raised.\r\n\r\nThe `Contexts` parameter is configured to apply the query parameters to all operations by default.\r\n\r\nTo constrain the types of operations that these query parameters will apply to, pass one ore more of the following values:\r\n\r\n- **TraitContext.Read**: Applies to read operations\r\n- **TraitContext.Create**: Applies to create operations\r\n- **TraitContext.Update**: Applies to update operations\r\n- **TraitContext.Delete**: Applies to delete operations\r\n- **TraitContext.List**: Applies to list operations\r\n- **TraitContext.Action**: Applies to custom action operations\r\n\r\nHere is an example of applying query parameters to `Read` and `List` operations:\r\n\r\n```typespec\r\nalias MyQueryParams = QueryParametersTrait<\r\n  {\r\n    @query foo: string;\r\n  },\r\n  TraitContext.Read | TraitContext.List\r\n>;\r\n\r\n// This will have a `foo` parameter added\r\nop getWidget is Operations.ResourceRead<Widget, MyQueryParams>;\r\n\r\n// This will not get the `foo` parameter because it doesn't match the contexts\r\nop deleteWidget is Operations.ResourceDelete<\r\n  Widget,\r\n  QueryParametersTrait<{\r\n    @query foo: string;\r\n  }>\r\n>;\r\n```\n\n### `ListQueryParametersTrait<TParams>`\n\nThis is a helper trait that specialized `QueryParametersTrait` to the `TraitContext.List` context. For example:\r\n\r\n```typespec\r\nalias MyListQueryParams = ListQueryParametersTrait<{\r\n  @query foo: string;\r\n}>;\r\n\r\n// Will get the `foo` parameter\r\nop listWidgets is Operations.ResourceList<Widget, MyListQueryParams>;\r\n\r\n// Will not get the `foo` parameter\r\nop deleteWidget is Operations.ResourceDelete<Widget, MyListQueryParams>;\r\n```\n\n### `RequestHeadersTrait<TParams, Contexts>`\n\nThis trait adds request headers to operation signatures. It accepts a model type containing the request headers that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is ResourceRead<\r\n  Widget,\r\n  RequestHeadersTrait<{\r\n    @header foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@header` or an error will be raised.\r\n\r\nYou can specify `Contexts` where this trait applies in the way as described for the `QueryParametersTrait`.\n\n### `ResponseHeadersTrait<TParams, Contexts>`\n\nThis trait adds response headers to operation signatures. It accepts a model type containing the response headers that will be mixed in to the operation signature:\r\n\r\n```typespec\r\nop getWidget is ResourceRead<\r\n  Widget,\r\n  ResponseHeadersTrait<{\r\n    @header foo: string;\r\n  }>\r\n>;\r\n```\r\n\r\n> **NOTE**: All properties in `TParams` must be marked with `@header` or an error will be raised.\r\n\r\nYou can specify `Contexts` where this trait applies in the way as described for the `QueryParametersTrait`.\n\n## Applying traits to all resource operations\n\nIf you would like to apply the same traits to all resource operations, you can do so by adding them to the traits object for your instance of the `ResourceOperations` interface. Here's an example of adding a request header called `foo` to all resource operations:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId &\r\n  RequestHeadersTrait<{\r\n    @header foo: string;\r\n  }>;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n\r\nop deleteWidget is Operations.ResourceDelete<Widget>;\r\n```\r\n\r\nThis defines `deleteWidget` by using the `ResourceDelete` template defined inside of your customized `Operations` interface.\r\n\r\n**IMPORTANT NOTE:** The `ResourceOperations` interface requires that an explicit set of traits be included to describe whether certain Azure service features are supported.\r\n\r\nHere is the list of the required traits with the names of the trait models to enable and disable those features:\r\n\r\n- **RepeatableRequests**: `SupportsRepeatableRequests` and `NoRepeatableRequests`\r\n- **ConditionalRequests**: `SupportsConditionalRequests` and `NoConditionalRequests`\r\n- **ClientRequestId**: `SupportsClientRequestId` and `NoClientRequestId`\n\n## Customizing the API version parameter\n\nYou can use the `VersionParameterTrait` to customize the API version parameter for resource operations, either at the level of interface or individual operation. To do this, use the `TraitOverride` type to override the existing `api-version` query parameter:\r\n\r\n```typespec\r\n/** The ApiVersion path parameter. */\r\nmodel ApiVersionPathParameter {\r\n  /** The API version to use for this operation. */\r\n  @segment(\"api\")\r\n  @path(\"api-version\")\r\n  apiVersion: string;\r\n}\r\n\r\nop deleteWidget is ResourceDelete<\r\n  Widget,\r\n  TraitOverride<VersionParameterTrait<ApiVersionPathParameter>>\r\n>;\r\n```\r\n\r\nUsing the `TraitOverride` modifier with the `VersionParameterTrait<ApiVersionPathParameter>` causes any existing `VersionParameterTrait` instances in the operation signature to be overridden by the one you have supplied.\r\n\r\nThis will result in an operation that has the route path `/api/{apiVersion}/widgets/{widgetName}` while also removing the old `api-version` query parameter from the operation signature.\n\n## Versioning the use of traits\n\nIt is possible that a service will begin to support a particular feature or trait in a later version. There are two ways to express that a trait is being added in a later service version:\n\n### Using the `TVersionAdded` parameter of some trait types\n\n> **NOTE:** Versioning of Azure Core service specifications is covered in more detail on [this page](https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10).\r\n\r\nSome standard trait types accept an optional `TVersionAdded` parameter which enables you to specify the service version enum representing the version where support for this trait is added:\r\n\r\n- `SupportsClientRequestId`\r\n- `SupportsRepeatableRequests`\r\n- `SupportsConditionalRequests`\r\n\r\nHere is an example of adding support for repeatable requests in a later service version:\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_08_31: \"v20220831\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"v20221130\",\r\n}\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests<Versions.v2022_11_30> &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n```\n\n### Define a custom trait and add the `@traitAdded` decorator\n\nBuilding on the previous example, we can add a custom header trait at a later service version using the `@traitAdded` decorator:\r\n\r\n```typespec\r\n/** A custom trait added at a later service version. */\r\n@traitAdded(Versions.v2022_11_30)\r\nmodel CustomRequestHeadersTrait\r\n  is RequestHeadersTrait<{\r\n    @TypeSpec.Http.header foo: string;\r\n  }>;\r\n\r\nalias ServiceTraits = SupportsRepeatableRequests<Versions.v2022_11_30> &\r\n  SupportsConditionalRequests &\r\n  SupportsClientRequestId &\r\n  CustomRequestHeadersTrait;\r\n\r\nalias Operations = ResourceOperations<ServiceTraits>;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n", "latency": 11.462198972702026, "response_length": 1574}
{"query": "title: TypeSpec Versioning Question\n\nquestion: I have a question about TypeSpec versioning decorators.\nLet's say we start with this:\n```TypeScript\nenum Versions {\nv1,\nlatest,\n}\nmodel Model {\n@added(Versions.latest)\nfoo: string;\n}\n```\nLater, we add a v2 version (before latest),  updating the versions enum to:\n```TypeScript\nenum Versions {\nv1,\nv2,\nlatest,\n}\n```\nWe also update the decorator on foo property from latest to v2:\n```TypeScript\nmodel Model {\n@added(Versions.v2)\nfoo: string;\n}\n```\nIn this case, will both v2 version and latest version include the foo property?", "ground_truth": "Yes, The version enum is ordered.", "response": "Yes, both the `v2` version and the `latest` version will include the `foo` property. When you update the `@added` decorator on the `foo` property to `@added(Versions.v2)`, it indicates that the property was introduced in version `v2`. Since `latest` is always considered the most recent version and includes all changes from earlier versions, it will also include the `foo` property.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#versioning#guide.md\n- document_title: Tutorial\n- document_link: https://typespec.io/docs/libraries/versioning/guide\n- document_content: # libraries#versioning#guide.md\n\n# Tutorial\n\n## Implementing versioned APIs\n\nThe primary role of the TypeSpec.Versioning library is to enable API versioning. Let's start with an API that lacks versioning.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nTo introduce versioning to this API, we need to use the `@versioned` decorator on the namespace and define an enum that outlines the supported versions.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n```\n\n## Declaring versioned dependencies\n\nBoth versioned and unversioned services can declare their dependencies on versioned TypeSpec libraries. This is achieved using the `@useDependency` decorator. For unversioned services, this is declared on the namespace. For versioned services, it's declared on the versioned enum.\r\n\r\nFor example, if our unversioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager Unversioned\" })\r\n@useDependency(Azure.Core.v1_0_Preview_1)\r\nnamespace Contoso.WidgetManager.Unversioned;\r\n```\r\n\r\nIf our versioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n}\r\n```\r\n\r\nLet's say we introduce a new version to our service, and it uses features from a newer version of the Azure.Core library. We can declare that dependency like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n\r\n  @useDependency(Azure.Core.v1_0_Preview_2)\r\n  v2,\r\n}\r\n```\n\n## Versioning APIs\n\nreflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    description:\r\n      type: string\r\n  required:\r\n    - id\r\n```\r\n\r\nHowever, the OpenAPI definition for versions 1 and 2 still reflect the original name and the mandatory nature of the property:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    name:\r\n      type: string\r\n  required:\r\n    - id\r\n    - name\r\n```\r\n\r\nThis is a common pattern with the versioning decorators. The TypeSpec should represent the _current state_ of the API. The decorators indicate the version at which this definition became accurate and, depending on the decorator, the other parameters reflect the previous values to retain that information.\n\nThe versioning library simplifies the process of versioning APIs. Let's start with a basic example. Assume we have a service with a single API that returns a list of widgets. We can define that API like this:\r\n\r\n```typespec\r\nusing Versioning;\r\nusing Rest;\r\nusing Http;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: string;\r\n  message?: string;\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\nop list(): Widget[] | Error;\r\n```\r\n\r\nNow, let's suppose that in version 2 of the service, we add a get operation to retrieve a single widget. We can add that like this:\r\n\r\n```typespec\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@route(\"/widget\")\r\nop list(): Widget[] | Error;\r\n\r\n@added(Versions.v2)\r\n@route(\"/widget/{id}\")\r\nop get(...Resource.KeysOf<Widget>): Widget | Error;\r\n```\r\n\r\nNow, let's suppose that in version 3 of the service, we realize that `name` is not accurate and that this field should be called `description`. Also, we decide that the description should be optional, not mandatory. We can implement these changes like this:\r\n\r\n```typespec\r\nmodel Widget {\r\n  @key\r\n  widgetId: string;\r\n\r\n  @renamedFrom(Versions.v3, \"name\")\r\n  @madeOptional(Versions.v3)\r\n  description?: string;\r\n}\r\n```\r\n\r\nWe made the change to the actual model property so that it now reflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step10.md\n- document_title: 10. Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10\n- document_content: # getstarted#azure-core#step10.md\n\n# 10. Versioning\n\n## Versioning your service\n\nIt is inevitable that service specifications will change over time. It is a best practice to add versioning support to your specification from the first version. To do that, you will need to define an `enum` containing your service versions and then apply the `@versioned` decorator to your service namespace.\r\n\r\nHere is an example for the `WidgetManager` service:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n}\r\n```\r\n\r\nThere are a few things to point out here:\r\n\r\n- We define an `enum` called `Versions` inside of the service namespace. For each service version, we map a version symbol like `v2022_08_31` to a version string like `2022-08-31`. This service currently only has a single version, but we can add more to this enum as things change over time.\r\n- We add the `@versioned` decorator and reference the `Versions` enum we defined using the fully-qualified name `Contoso.WidgetManager.Versions`. This marks the service as being versioned and specifies the set of versions.\r\n- We change the `@useDependency` decorator we used previously to now link each service version to a specific version of `Azure.Core`. See the [Using Azure.Core Versions](#using-azurecore-versions) section for more information.\r\n\r\nImagine that it's 3 months later and you want to release a new version of your service with some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\n\nwith some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nFinally, you can express changes to your service using the `@added` and `@removed` decorators. Here's an example of adding a new property to `Widget` and removing an old one:\r\n\r\n```typespec\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  @added(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  color: string;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  @removed(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n> You can do a lot more with versioning decorators, so consult the `typespec-versioning` [README.md](https://github.com/microsoft/typespec/tree/main/packages/versioning#enable-versioning-for-service-or-library) for more information on how you can use them to annotate your service and describe changes between different versions.\n\n## Using Azure.Core versions\n\n`typespec-azure-core` is a versioned TypeSpec library. This means that even as the TypeSpec portions of the typespec-azure-core library are updated, you can anchor each version of your spec to a specific `Azure.Core` version. This is done by decorating your service namespace with the `@useDependency` decorator from the `typespec-versioning` library.\r\n\r\nSimple TypeSpec specs need only pass the desired `Azure.Core` version into the `@useDependency` decorator:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nIf your spec has [multiple versions](#versioning-your-service), you will need to specify the version of `typespec-azure-core` that was used for each version in your spec. Assuming that there are two versions of `Azure.Core` and each version of your service uses a different one, it would look like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"v20220831\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"v20221130\",\r\n}\r\n```\n", "latency": 7.173602342605591, "response_length": 383}
{"query": "title: Using @client decorator in the Client.tsp prevents other clients from generating\n\nquestion: Using @client decorator in the Client.tsp prevents other clients from generating\nHi All, I'm trying to merge two generated clients into one in my Client.tsp, so I'm following the One client and two operation groups docs to do so. However, I noticed that using a @client decorator will stop the other clients that I had before from being generated.\nI want to understand if this is the expected behavior and I have to explicitly specify all of the clients that I want, or if there's a better way to accomplish my goal.\nFor context, here is what my Client.tsp looks like:\n```\n@client(\n{\nname: \"KeyVaultAccessControlRestClient\",\nservice: KeyVault,\n},\n\"csharp\"\n)\n@operationGroup\ninterface RoleDefinitions{\ndeleteRoleDefinition is KeyVault.RoleDefinitions.delete;\ncreateOrUpdateRoleDefinition is KeyVault.RoleDefinitions.createOrUpdate;\ngetRoleDefinition is KeyVault.RoleDefinitions.get;\nlistRoleDefinitions is KeyVault.RoleDefinitions.list;\n}\n@operationGroup\ninterface RoleAssignments{\ndeleteRoleAssignment is KeyVault.RoleAssignments.delete;\ncreateRoleAssignment is KeyVault.RoleAssignments.create;\ngetRoleAssignment is KeyVault.RoleAssignments.get;\nlistRoleAssignments is KeyVault.RoleAssignments.listForScope;\n}\n```\nBy doing this, I get a KeyVaultAccessControlRestClient generated client  but I lost my KeyVaultRestClient that was also generated before\nCC: Isabella Cai, Chenjie Shi, Catalina Peralta\nClients | TypeSpec Azure", "ground_truth": "it is expected and mentioned in doc. when you use explicit @client, you need to define all clients explicitly. we are not able to infer some clients from ns/interface, some from @client.", "response": "Yes, this is the expected behavior when using the `@client` decorator in TypeSpec. Once you define a custom client using the `@client` decorator, the default behavior of generating clients for all namespaces and interfaces is overridden. This means that only the explicitly defined clients in your `client.tsp` file will be generated. \n\nTo achieve your goal of merging two operation groups into one client while retaining the previously generated clients, you need to explicitly define all the clients you want in your `client.tsp` file. For example, if you want to keep the `KeyVaultRestClient` alongside your custom `KeyVaultAccessControlRestClient`, you need to define both clients explicitly in the `client.tsp` file.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#03client.mdx\n- document_title: Clients\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/03client\n- document_content: # howtos#generate-client-libraries#03client.mdx\n\n# Clients\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page explains client behavior and how to customize clients. For an overview of the setup, please refer to the previous page.\r\n\r\n> **NOTE:** JS RLC does not support customization. It will ignore `client.tsp`, and the following scenarios will not affect the JS RLC user experience. In this context, \"TypeScript part\" refers to the JS Modular Emitter.\n\n## Default Behavior\n\n### Basic Rules\n\nBy default, the namespace with the `@service` decorator is generated as a root client. The client name is the namespace name with `Client` appended as a suffix.\r\n\r\nSub-namespaces and interfaces under each root client are generated as operation groups with a hierarchical structure.\r\n\r\nThe sequence of operation groups is determined by the order of namespace declarations, followed by interface declarations.\r\n\r\nThe root client's SDK namespace corresponds to the namespace decorated with `@service`. If an operation group originates from a sub-namespace, its SDK namespace corresponds to that sub-namespace. If it originates from an interface, its SDK namespace corresponds to the namespace containing the interface.\r\n\r\nBy default, operation groups can only be initialized by the root client or their parent operation group.\r\n\r\nDifferent languages organize clients and operation groups differently. Refer to the examples below for details.\n\n### Single Client\n\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service(#{ title: \"Pet Store\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/feed\")\r\nop feed(): void;\r\n\r\n@route(\"/op2\")\r\nop pet(): void;\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\nPetStoreClient client = new PetStoreClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Client with One-Layer Child Operation Groups\n\n`PetStore` has two operation groups. The `Dogs` operation group comes from a sub-namespace, while `Cats` comes from an interface.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\n@service(#{ title: \"Pet Store\", version: \"v1\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/dogs\")\r\ninterface Dogs {\r\n  feed(): void;\r\n  pet(): void;\r\n}\r\n\r\n@route(\"/cats\")\r\nnamespace Cats {\r\n  op feed(): void;\r\n  op pet(): void;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.dogs.feed()\r\nclient.dogs.pet()\r\nclient.cats.feed()\r\nclient.cats.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.GetDogsClient().Feed();\r\nclient.GetDogsClient().Pet();\r\nclient.GetCatsClient().Feed();\r\nclient.GetCatsClient().Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.dogs.feed();\r\nclient.dogs.pet();\r\nclient.cats.feed();\r\nclient.cats.pet();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nDogsClient dogsClient = builder.buildDogsClient();\r\ndogsClient.feed();\r\ndogsClient.pet();\r\n\r\nCatsClient catsClient = builder.buildCatsClient();\r\ncatsClient.feed();\r\ncatsClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Client with Multi-Layer Child Operation Groups\n\nclient.pets.actions.pet();\r\nclient.actions.open();\r\nclient.actions.close();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nPetStoreClient petStoreClient = builder.buildClient();\r\npetStoreClient.info();\r\n\r\nBillingsClient billingsClient = builder.buildBillingsClient();\r\nbillingsClient.history();\r\n\r\nPetsClient petsClient = builder.buildPetsClient();\r\npetsClient.info();\r\n\r\nPetsActionsClient petsActionsClient = builder.buildPetsActionsClient();\r\npetsActionsClient.feed();\r\npetsActionsClient.pet();\r\n\r\nActionsClient actionsClient = builder.buildActionsClient();\r\nactionsClient.open();\r\nactionsClient.close();\r\n```\r\n\r\n</ClientTabs>\n\n`PetStore` has three operation groups: `Billings` (from an interface), `Pets` (from a sub-namespace), and `Actions` (from an interface). `Pets` also contains a nested operation group, `Actions`, from an interface.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service(#{ title: \"Pet Store\", version: \"v1\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/info\")\r\nop info(): void;\r\n\r\n@route(\"/billings\")\r\ninterface Billings {\r\n  @route(\"history\")\r\n  history(): void;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @route(\"info\")\r\n  op info(): void;\r\n\r\n  @route(\"/actions\")\r\n  interface Actions {\r\n    feed(): void;\r\n    pet(): void;\r\n  }\r\n}\r\n\r\n@route(\"/actions\")\r\ninterface Actions {\r\n  open(): void;\r\n  close(): void;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.info()\r\nclient.billings.history()\r\nclient.pets.info()\r\nclient.pets.actions.feed()\r\nclient.pets.actions.pet()\r\nclient.actions.open()\r\nclient.actions.close()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Info();\r\nclient.GetBillingsClient().History();\r\nclient.GetPetsClient().Info();\r\nclient.GetPetsClient().GetPetsActionsClient().Feed();\r\nclient.GetPetsClient().GetPetsActionsClient().Pet();\r\nclient.GetActionsClient().Open();\r\nclient.GetActionsClient().Close();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.info();\r\nclient.billings.history();\r\nclient.pets.info();\r\nclient.pets.actions.feed();\r\nclient.pets.actions.pet();\r\nclient.actions.open();\r\nclient.actions.close();\r\n```\r\n\r\n```java\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nPetStoreClient petStoreClient = builder.buildClient();\r\npetStoreClient.info();\r\n\r\nBillingsClient billingsClient = builder.buildBillingsClient();\r\nbillingsClient.history();\r\n\r\nPetsClient petsClient = builder.buildPetsClient();\r\npetsClient.info();\r\n\r\nPetsActionsClient petsActionsClient = builder.buildPetsActionsClient();\n\n## Customizations\n\nCustomizations SHOULD always be made in a file named `client.tsp` alongside `main.tsp`.\r\n\r\nYou can use `@client` and `@operationGroup` to restructure the client hierarchy. However, if any customizations are made, the client hierarchy will only reflect those customizations. The default behavior logic will no longer apply.\r\n\r\nIf customizations are made, the client's SDK namespace will follow the namespace decorated with `@client` or the namespace containing the interface decorated with `@client`. Similarly, the operation group's SDK namespace follows the same logic for `@operationGroup`. You can override this using `@clientNamespace` if needed.\r\n\r\nThe sequence of clients and operation groups is determined by the order of the `@client` and `@operationGroup` decorators.\r\n\r\nFor this section, we assume you have a service called `PetStore` in the `PetStore` namespace, defining two operations: `feed` and `pet`.\n\n### Renaming the Client Name\n\nThis can be achieved with the augment decorator: `@clientName` from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientName(PetStore, \"PetStoreGreatClient\");\r\n```\r\n\r\n```python\r\nfrom pet_store import PetStoreGreatClient\r\n\r\nclient = PetStoreGreatClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStore;\r\n\r\nPetStoreGreatClient client = new PetStoreGreatClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreGreatClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreGreatClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\nPetStoreGreatClient client = new PetStoreGreatClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Renaming the Client Namespace\n\nThis can be achieved with the augment decorator: `@clientNamespace` from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@@clientNamespace(PetStore, \"PetStoreRenamed\");\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\nclient.feed()\r\nclient.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\nclient.Feed();\r\nclient.Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nPetStoreClient client = new PetStoreClientBuilder().buildClient();\r\nclient.feed();\r\nclient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Two Clients\n\nTwo clients that separate the operations can be declared using the `@client` decorator from `typespec-client-generator-core`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import FoodClient, PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetActionClient petActionClient = new PetActionClient();\r\nFoodClient foodClient = new FoodClient();\r\n\r\npetActionClient.Pet();\r\nfoodClient.Feed();\r\n```\r\n\r\n```typescript\r\nimport { FoodClient, PetActionClient } from \"@azure/package-name\";\r\n\r\nconst client1 = new PetActionClient();\r\nconst client2 = new FoodClient();\r\nclient1.pet();\r\nclient2.feed();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\n\r\nfoodClient.feed()\r\npetActionClient.pet()\r\n```\r\n\r\n</ClientTabs>\n\n### One Client and Two Operation Groups\n\nTwo clients that separate the operations can be declared using the `@client` decorator and the `@operationGroup` decorator from `typespec-client-generator-core`:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\n@client({\r\n  name: \"PetStoreClient\",\r\n  service: PetStore,\r\n})\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@operationGroup\r\ninterface OpGrp1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@operationGroup\r\ninterface OpGrp2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import PetStoreClient\r\n\r\nclient = PetStoreClient()\r\n\r\nclient.op_grp_1.feed()\r\nclient.op_grp_2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\n\r\nPetStoreClient client = new PetStoreClient();\r\n\r\nclient.GetOpGrp1Client().Feed();\r\nclient.GetOpGrp2Client().Pet();\r\n```\r\n\r\n```typescript\r\nimport { PetStoreClient } from \"@azure/package-name\";\r\n\r\nconst client = new PetStoreClient();\r\nclient.opGrp1.feed();\r\nclient.opGrp2.pet();\r\n```\r\n\r\n```java\r\npackage petstorerenamed;\r\n\r\nPetStoreClientBuilder builder = new PetStoreClientBuilder();\r\n\r\nOpGrp1Client opGrp1Client = builder.buildOpGrp1Client();\r\nopGrp1Client.feed();\r\n\r\nOpGrp2Client opGrp2Client = builder.buildOpGrp2Client();\r\nopGrp2Client.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Sub-Namespaces\n\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace NewPetStore;\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\nnamespace Food {\r\n  op feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\nnamespace PetAction {\r\n  op pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom new_pet_store.food import FoodClient\r\nfrom new_pet_store.pet_action import PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\nNOT_SUPPORTED;\r\n```\r\n\r\n```java\r\nimport newpetstore.food.FoodClient;\r\nimport newpetstore.food.FoodClientBuilder;\r\nimport newpetstore.petaction.PetActionClient;\r\nimport newpetstore.petaction.PetActionClientBuilder;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nfoodClient.feed();\r\n\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\npetActionClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Splitting the Operations into Two Clients and Having Clients in Different Namespaces\n\nTwo clients that separate the operations can be declared using the `client` decorator of `typespec-client-generator-core`:\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace PetStoreRenamed; // this namespace will be the namespace of the clients and operation groups defined in this customization file\r\n\r\n@client({\r\n  name: \"FoodClient\",\r\n  service: PetStore,\r\n})\r\ninterface Client1 {\r\n  feed is PetStore.feed;\r\n}\r\n\r\n@client({\r\n  name: \"PetActionClient\",\r\n  service: PetStore,\r\n})\r\n@clientNamespace(\"PetStoreRenamed.SubNamespace\") // use @clientNamespace to specify the namespace of the client\r\ninterface Client2 {\r\n  pet is PetStore.pet;\r\n}\r\n```\r\n\r\n```python\r\nfrom pet_store_renamed import FoodClient\r\nfrom pet_store_renamed.sub_namespace import PetActionClient\r\n\r\nclient1 = FoodClient()\r\nclient2 = PetActionClient()\r\n\r\nclient1.feed()\r\nclient2.pet()\r\n```\r\n\r\n```csharp\r\nusing PetStoreRenamed;\r\nusing PetStoreRenamed.SubNamespace;\r\n\r\nSubNamespacePetActionClient petActionClient = new SubNamespacePetActionClient();\r\nFoodClient foodClient = new FoodClient();\r\n\r\npetActionClient.Pet();\r\nfoodClient.Feed();\r\n```\r\n\r\n```typescript\r\nNOT_SUPPORTED;\r\n```\r\n\r\n```java\r\nimport petstorerenamed.FoodClient;\r\nimport petstorerenamed.FoodClientBuilder;\r\nimport petstorerenamed.subnamespace.PetActionClient;\r\nimport petstorerenamed.subnamespace.PetActionClientBuilder;\r\n\r\nFoodClient foodClient = new FoodClientBuilder().buildClient();\r\nPetActionClient petActionClient = new PetActionClientBuilder().buildClient();\r\n\r\nfoodClient.feed();\r\npetActionClient.pet();\r\n```\r\n\r\n</ClientTabs>\n\n### Adding Client Initialization Parameters\n\nBy default, we only generate our clients with initialization parameters for `endpoint`, `credential`, and `apiVersion`, whenever any of these are applicable.\r\nThere are cases where spec authors would like their clients to have additional input parameters.\r\n\r\nWith `@clientInitialization`, you can pass in additional parameters you would like your client to have, by passing in `parameters` option of a model.\r\nAll properties of the model will be appended to the current default list of client initialization parameters.\r\nAdditionally, these client parameters will no longer appear on service methods that previously had them as part of the method signature.\r\nThe generated code will automatically pass in the inputted value from the client init to the service.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop upload(@path blobName: string): void;\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    parameters: StorageClientOptions,\r\n  }\r\n);\r\n```\r\n\r\n```python\r\nfrom storage import StorageClient\r\n\r\nclient = StorageClient(endpoint=\"<my-endpoint>\", blob_name=\"myBlobName\", ...)\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n```csharp\r\n// TODO: how do you pass in the options model\r\nusing Storage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blobName(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\n\nStorage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blobName(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n</ClientTabs>\r\n\r\nIf you want to rename the parameter name that you elevate to the client level, you can use the `@paramAlias` decorator.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop upload(@path blobName: string): void;\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  @paramAlias(\"blobName\")\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    parameters: StorageClientOptions,\r\n  }\r\n);\r\n```\r\n\r\n```python\r\nfrom storage import StorageClient\r\n\r\nclient = StorageClient(endpoint=\"<my-endpoint>\", blob=\"myBlobName\", ...)\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n```csharp\r\n// TODO: how do you pass in the options model\r\nusing Storage;\r\n\r\nStorageClient client = new StorageClient();\r\n\r\nclient.Upload();\r\nclient.Download();\r\n```\r\n\r\n```typescript\r\n// TODO: how do you pass in the options model\r\nimport { StorageClient } from \"@azure/package-name\";\r\n\r\nconst client = new StorageClient();\r\n\r\nclient.upload();\r\nclient.download();\r\n```\r\n\r\n```java\r\npackage storage;\r\n\r\nStorageClient client = new StorageClient()\r\n    .endpoint(\"<my-endpoint>\")\r\n    .blob(\"myBlobName\")\r\n    .buildClient();\r\n\r\nclient.upload()\r\nclient.download()\r\n```\r\n\r\n</ClientTabs>\n\n### Change Operation Group Initialization Way\n\nBy default, all the nested operation group could only be initialized by parent client or operation group.\r\nThere are cases where spec authors would like their operation groups could both be initialized by parent as well as individually.\r\n\r\nWith `@clientInitialization`, you can change the initialization way, by passing in `initializedBy` option of `InitializedBy.individually | InitializedBy.parent` value.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service\r\nnamespace Storage;\r\n\r\nop download(@path blobName: string): void;\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nusing Azure.ClientGenerator.Core;\r\n\r\nnamespace Customizations;\r\n\r\nmodel StorageClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(Storage,\r\n  {\r\n    initializedBy: InitializedBy.individually | InitializedBy.parent,\r\n  }\r\n);\r\n```\r\n\r\n```python\n\n# TODO\n\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#02package.mdx\n- document_title: Common Behavior for Client Packages\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/02package\n- document_content: # howtos#generate-client-libraries#02package.mdx\n\n# Common Behavior for Client Packages\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents the common behavior for a client package, including the service, namespace, license, and more.\n\n## Service\n\nThe service acts as the entry point for a client library. Currently, only one service per package is supported. The service is defined using the `@service` decorator. If multiple services are defined, the first one will be used as the entry point.\n\n## Namespace\n\nClients, models, enums, and unions in TypeSpec include namespace information. Code generators for different languages use this information to organize the generated code.\n\n### Basic Example\n\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service(#{ title: \"Pet Store\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/feed\")\r\nop feed(food: Food): void;\r\n\r\nmodel Food {\r\n  name: string;\r\n  quantity: int32;\r\n}\r\n```\r\n\r\n```python\n\n# TODO\n\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\r\n\r\n```\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n\n### Customization\n\nYou can use the `@clientNamespace` decorator to customize the namespace for specific clients, enums, models, or unions.\r\n\r\n<ClientTabs>\r\n\r\n```typespec title=\"main.tsp\"\r\n@service(#{ title: \"Pet Store\" })\r\nnamespace PetStore;\r\n\r\n@route(\"/feed\")\r\nop feed(food: Food): void;\r\n\r\nmodel Food {\r\n  name: string;\r\n  quantity: int32;\r\n}\r\n```\r\n\r\n```typespec title=\"client.tsp\"\r\nimport \"./main.tsp\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\n\r\nnamespace Customization;\r\n\r\n@@clientNamespace(PetStore.Food, \"PetStore.Models\");\r\n```\r\n\r\n```python\n\n## License\n\nLicense information is automatically generated in the client code header and the `LICENSE` file, depending on the language's emitter.\n\n### Azure License\n\nFor Azure scenarios, client code always uses the MIT license. The license information is included in the header of the generated code or in a separate file, depending on the language.\r\n\r\nFor example, here is the license comment in the generated code of a Java client:\r\n\r\n```java\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\n```\r\n\r\nAnd here is the `LICENSE` file for a Python client library:\r\n\r\n```text\r\nCopyright (c) Microsoft Corporation\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the Software), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n```\n\n### Unbranded License\n\nlibrary:\r\n\r\n```text\r\nCopyright (c) Microsoft Corporation\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n```\r\n\r\n#### Example: Custom License\r\n\r\n```yaml\r\nemit:\r\n  - \"@azure-tools/typespec-python\"\r\n  - \"@azure-tools/typespec-java\"\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n    license:\r\n      name: \"Mozilla Public License 2.0\"\r\n      link: \"https://www.mozilla.org/en-US/MPL/2.0/\"\r\n      header: \"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.\"\r\n      description: \"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.\"\r\n  \"@azure-tools/typespec-java\":\r\n    license:\r\n      name: \"Mozilla Public License 2.0\"\r\n      link: \"https://www.mozilla.org/en-US/MPL/2.0/\"\r\n      header: \"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.\"\r\n      description: \"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.\"\r\n```\r\n\r\nGenerated license comment in Java client code:\r\n\r\n```java\n\nheader: \"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.\"\r\n      description: \"This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.\"\r\n```\r\n\r\nGenerated license comment in Java client code:\r\n\r\n```java\r\n// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.\r\n```\r\n\r\nGenerated `LICENSE` file for Python client library:\r\n\r\n```text\r\nThis Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at https://mozilla.org/MPL/2.0/.\r\n```\n\nFor unbranded scenarios, client code will not include license information unless it is configured in `tspconfig.yaml`. Spec authors can define license information using the `license` configuration in `tspconfig.yaml` as shown below:\r\n\r\n```yaml\r\nlicense:\r\n  name: <License name. This is required. We support built-in licenses such as \"MIT License\", \"Apache License 2.0\", \"BSD 3-Clause License\", \"MPL 2.0\", \"GPL-3.0\", and \"LGPL-3.0\". For custom licenses, you must provide the name, company, link, header, and description manually.>\r\n  company: <Company name. Optional. For built-in licenses, this affects the copyright statement.>\r\n  link: <License link. Optional. Required for custom licenses.>\r\n  header: <License header in the generated code. Optional. Required for custom licenses.>\r\n  description: <License description in the separate license file. Optional. Required for custom licenses.>\r\n```\r\n\r\n#### Example: Built-in License\r\n\r\n```yaml\r\nemit:\r\n  - \"@azure-tools/typespec-python\"\r\n  - \"@azure-tools/typespec-java\"\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n    license:\r\n      name: \"Apache License 2.0\"\r\n      company: \"Microsoft Corporation\"\r\n  \"@azure-tools/typespec-java\":\r\n    license:\r\n      name: \"Apache License 2.0\"\r\n      company: \"Microsoft Corporation\"\r\n```\r\n\r\nGenerated license comment in Java client code:\r\n\r\n```java\r\n// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0.\r\n```\r\n\r\nGenerated `LICENSE` file for Python client library:\r\n\r\n```text\r\nCopyright (c) Microsoft Corporation\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n", "latency": 8.717202186584473, "response_length": 721}
{"query": "title: How to keep service code consistent with TypeSpec definition?\n\nquestion: I have a question regarding maintaining consistency between service code and TypeSpec definitions.\nCurrently, our TypeSpec definitions are written manually, but Im concerned that as the service evolves, the definitions may start to drift from the actual code implementation. This could lead to mismatches and potential errors down the line.\nCould you provide recommendations or best practices for keeping the service code in sync with the TypeSpec definition? Is there a way to automate the process of verifying that the code matches the TypeSpec, or to better integrate the TypeSpec definitions directly with the service code to reduce the chances of divergence?\nAny guidance on strategies for keeping these two aligned would be greatly appreciated.\nThank you!", "ground_truth": "Well, eventually the answer is code and maybe even test generation from typespec itself.  For ARM services, live validation occurs based on the emitted swagger, so you get some assurance", "response": "To maintain consistency between your service code and TypeSpec definitions, you can leverage TypeSpec's code generation capabilities. By using TypeSpec to define your API and then generating server stubs or client code, you ensure that the implementation aligns with the API specification. Here are some best practices and strategies:\n\n1. **Use Code Generation**: TypeSpec supports generating server stubs for languages like C# and JavaScript. This ensures that your service code is always in sync with the TypeSpec definition. For example, you can use the C# server emitter or JavaScript server emitter to scaffold your service code directly from the TypeSpec definition.\n\n2. **Iterative Updates**: As your API evolves, update the TypeSpec definition and recompile it to regenerate the code. TypeSpec's scaffolding tools are designed to preserve custom business logic in implementation files while updating generated files like models and interfaces.\n\n3. **Automate Verification**: Integrate TypeSpec compilation and code generation into your CI/CD pipeline. This ensures that any changes to the TypeSpec definition are automatically reflected in the generated code and that inconsistencies are caught early.\n\n4. **Customizable Files**: TypeSpec-generated projects separate generated files (which should not be modified) from customizable files (where you implement business logic). This separation helps prevent accidental overwrites during regeneration.\n\n5. **Swagger UI for Testing**: Use the Swagger UI generated alongside your service to test and verify that the implementation matches the API specification.\n\n6. **Documentation and Samples**: Refer to TypeSpec's documentation and samples for guidance on setting up and maintaining your project. For example, the [TypeSpec C# Code Generation Guide](https://typespec.io/docs/getting-started/code-generation-csharp) and [TypeSpec JavaScript Code Generation Guide](https://typespec.io/docs/getting-started/code-generation-javascript) provide detailed steps for scaffolding and maintaining your service.\n\nBy following these practices, you can minimize the risk of divergence between your TypeSpec definitions and service code, ensuring consistency and reducing potential errors.", "context": "- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-csharp.md\n- document_title: Code Generation - C#\n- document_link: https://typespec.io/docs/getting-started/code-generation-csharp\n- document_content: # getting-started#code-generation-csharp.md\n\n# Code Generation - C#\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for C#\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the C# server emitter.\n\n## Prerequisites\n\n- .NET 9 installed (required for C# server code generation)\r\n- Node.js and npm (for the installation method)\r\n- Basic familiarity with TypeSpec\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"C# Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-csharp\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-csharp\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates C# server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hscs-scaffold . --use-swaggerui --overwrite\r\n```\r\n\r\n> **Note about `npx`**: The `npx` command executes binaries from your local node_modules directory. This ensures you're using the version of the scaffold tool installed in your project, which is especially useful if you have multiple TypeSpec projects with different versions.\r\n\r\nThe `--use-swaggerui` flag adds a Swagger UI endpoint to your generated service. This is useful during development as it allows you to interact with your API directly from a browser.\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n- Where to access the Swagger UI\r\n\r\nYou'll see output similar to this:\r\n\r\n```\r\nYour project was successfully created at \"tsp-output/server/aspnet\"\r\n\r\nYou can build and start the project using 'dotnet run --project \"tsp-output/server/aspnet\"'\r\nYou can browse the swagger UI to test your service using 'start https://localhost:7348/swagger/'\r\n```\n\n## 5. Running your service\n\nRun the generated service using the following command:\r\n\r\n```bash\r\ndotnet run --project \"tsp-output/server/aspnet\"\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `https://localhost:<port>/swagger` in your browser, replacing `<port>` with the port listed in the console output, which in the example above is `7348`.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe scaffolded code is organized into two main categories:\n\n### Generated files (don't modify directly)\n\nLocated in the `generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition:\r\n\r\n- **Controllers**: Front-end API endpoints that receive HTTP requests\r\n\r\n  - Example: `WidgetsController.cs` handles requests to `/widgets`\r\n  - Each controller method maps to an operation in your TypeSpec interface\r\n\r\n- **Operations interfaces**: Definitions for your business logic\r\n\r\n  - Example: `IWidgets.cs` defines methods like `ListWidgetsAsync()`\r\n  - These interfaces are what your implementation will need to fulfill\r\n\r\n- **Models**: Data structures for requests and responses\r\n  - Example: `Widget.cs`, `WidgetList.cs`\r\n  - These directly represent the models defined in your TypeSpec\n\n### Customizable files\n\nThese files are intended for you to modify with your implementation:\r\n\r\n- **Implementation classes**: Mock implementations of your operations interfaces\r\n\r\n  - Example: `Widgets.cs` is where you'll add your business logic\r\n  - The emitter generates these with mock implementations that return syntactically correct responses\r\n  - These files **won't be overwritten** when you recompile, preserving your business logic\r\n\r\n- **Program.cs**: Application entry point and service configuration\r\n\r\n- **MockRegistration.cs**: Dependency injection configuration\r\n  - This file connects your implementation classes to the controller interfaces\r\n  - If you create custom service classes, you'll register them here\n\n## 7. Understanding the dependency injection system\n\nThe generated C# service uses ASP.NET Core's dependency injection system to connect controllers with your business logic:\r\n\r\n1. Controllers defined in the `generated` folder depend on interface types (like `IWidgets`)\r\n2. Your implementation classes (like `Widgets`) implement these interfaces\r\n3. The `MockRegistration.cs` file registers your implementations with the dependency injection container\r\n4. When a request comes in, the controller receives it and calls your implementation\r\n\r\nIf you need to register additional services or dependencies, you would add them to the `MockRegistration.cs` file.\n\n## 8. Adding your business logic\n\n1. Locate the implementation file for your service (e.g., `Widgets.cs`)\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```csharp\r\npublic async Task<Widget[]> ListAsync()\r\n{\r\n    // Replace the mock implementation with your actual database query\r\n    return new Widget[]\r\n    {\r\n        new Widget { Id = \"1\", Weight = 10, Color = \"red\" },\r\n        new Widget { Id = \"2\", Weight = 15, Color = \"blue\" }\r\n    };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (controllers, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp\r\n```\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`CategoriesController.cs`, `ICategories.cs`, and `CategoriesImpl.cs`)\r\n- It won't overwrite your existing `Widgets.cs` with your custom business logic\r\n- This allows you to incrementally add new resources without losing your existing implementations\n\n## 10. Advanced customization options\n\nWhen scaffolding your service, you can use additional options for customization:\r\n\r\n```bash\r\nnpx hscs-scaffold main.tsp --help\r\n```\r\n\r\nSome useful options include:\r\n\r\n- `--project-name <name>`: Set a custom project name\r\n- `--https-port <port>`: Set a different HTTPS port\r\n- `--output <path>`: Generate files to a different location\r\n- `--overwrite`: Overwrite existing files (use with caution)\r\n  - Normally, implementation files that already exist won't be overwritten\r\n  - Use this flag if you want to reset your implementations back to the generated mock versions\n\n## Next steps\n\n- Explore the included README and documentation in the `docs` folder of your generated project\r\n- Add authentication mechanisms to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n", "latency": 12.616292238235474, "response_length": 2231}
{"query": "title: Seeking Guidance on Defining ResourceStatusCode in TypeSpec\n\nquestion: Hello TypeSpec Discussion\nI am working on defining a `ResourceStatusCode` in TypeSpec, which is similar to HTTP status codes but specific to resource states. I would appreciate your guidance on the following:\n1. Should I use an `enum` or a `int` to define the `ResourceStatusCode`?\n2. What are the best practices for defining status codes in TypeSpec?\n3. How can I ensure that the `ResourceStatusCode` remains extensible for future updates?\nI want to add statuses like:\n- `NotSpecified: 204 No Content` - This indicates that the request was successful, but there is no content to return.\n- `Pending: 102 Processing` - This indicates that the server has received and is processing the request, but no response is available yet.\n- `Running: 202 Accepted` - This indicates that the request has been accepted for processing, but the processing has not been completed.\n- `Succeeded: 200 OK` - This indicates that the request has succeeded.\n- `Failed: 500 Internal Server Error` - This indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.\nThank you for your assistance.", "ground_truth": "As per one of our previous understanding, we defined similarly as an open union: [azure-rest-api-specs-pr/specification/impact/Impact.Management/connectors.tsp at RPSaaSMaster  Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/blob/RPSaaSMaster/specification/impact/Impact.Management/connectors.tsp#L88-L94).  This explicitly allows any string value.\nGenerally, the reason for doing this is that you think additional values will be enabled in future versions (or even in this version).  Note that, if you do not make this an open union, then adding any values in any future api-version would be a breaking change (which is why this is recommended).\nThere are RPaaS extensions for validation that would allow you to reject requests for values that are not valid.", "response": "To define `ResourceStatusCode` in TypeSpec, here are the recommendations:\n\n1. **Use an Enum**: Enums are the preferred way to define status codes in TypeSpec when the values are discrete and well-defined. This approach ensures clarity and type safety. For example:\n\n```typespec\nenum ResourceStatusCode {\n  NotSpecified: 204;\n  Pending: 102;\n  Running: 202;\n  Succeeded: 200;\n  Failed: 500;\n}\n```\n\n2. **Best Practices for Defining Status Codes**:\n   - Use descriptive names for each status code to make the intent clear.\n   - Include documentation for each enum value to explain its purpose.\n   - Use numeric values that align with HTTP status codes if applicable.\n\n3. **Ensure Extensibility**:\n   - Enums in TypeSpec can be extended by adding new values as needed. This makes them inherently extensible.\n   - If you anticipate frequent updates, consider using a union type for more flexibility:\n\n```typespec\nmodel ResourceStatus {\n  status: \"NotSpecified\" | \"Pending\" | \"Running\" | \"Succeeded\" | \"Failed\";\n}\n```\n\nThis approach allows you to add new statuses without modifying an enum declaration.\n\nBy following these guidelines, you can create a clear and maintainable `ResourceStatusCode` definition in TypeSpec.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#http#reference#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/libraries/http/reference/decorators\n- document_content: # libraries#http#reference#decorators.md\n\n# Decorators\n\n## TypeSpec.Http\n\n### `@body` {#@TypeSpec.Http.body}\n\nExplicitly specify that this property type will be exactly the HTTP body.\r\n\r\nThis means that any properties under `@body` cannot be marked as headers, query parameters, or path parameters.\r\nIf wanting to change the resolution of the body but still mix parameters, use `@bodyRoot`.\r\n\r\n```typespec\r\n@TypeSpec.Http.body\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(@body image: bytes): void;\r\nop download(): {\r\n  @body image: bytes;\r\n};\r\n```\n\n### `@bodyIgnore` {#@TypeSpec.Http.bodyIgnore}\n\nSpecify that this property shouldn't be included in the HTTP body.\r\nThis can be useful when bundling metadata together that would result in an empty property to be included in the body.\r\n\r\n```typespec\r\n@TypeSpec.Http.bodyIgnore\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(\r\n  name: string,\r\n  @bodyIgnore headers: {\r\n    @header id: string;\r\n  },\r\n): void;\r\n```\n\n### `@bodyRoot` {#@TypeSpec.Http.bodyRoot}\n\nSpecify that the body resolution should be resolved from that property.\r\nBy default the body is resolved by including all properties in the operation request/response that are not metadata.\r\nThis allows to nest the body in a property while still allowing to use headers, query parameters, and path parameters in the same model.\r\n\r\n```typespec\r\n@TypeSpec.Http.bodyRoot\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(\r\n  @bodyRoot user: {\r\n    name: string;\r\n    @header id: string;\r\n  },\r\n): void;\r\nop download(): {\r\n  @bodyRoot user: {\r\n    name: string;\r\n    @header id: string;\r\n  };\r\n};\r\n```\n\n### `@cookie` {#@TypeSpec.Http.cookie}\n\nSpecify this property is to be sent or received in the cookie.\r\n\r\n```typespec\r\n@TypeSpec.Http.cookie(cookieNameOrOptions?: valueof string | TypeSpec.Http.CookieOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name                | Type                                            | Description                                                                                                                                                                                       |\r\n| ------------------- | ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| cookieNameOrOptions | `valueof string \\| TypeSpec.Http.CookieOptions` | Optional name of the cookie in the cookie or cookie options.<br />By default the cookie name will be the property name converted from camelCase to snake_case. (e.g. `authToken` -> `auth_token`) |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(@cookie token: string): {\r\n  data: string[];\r\n};\r\nop create(\r\n  @cookie({\r\n    name: \"auth_token\",\r\n  })\r\n  data: string[],\r\n): void;\r\n```\r\n\r\n##### Implicit header name\r\n\r\n```typespec\r\nop read(): {\r\n  @cookie authToken: string;\r\n}; // headerName: auth_token\r\nop update(@cookie AuthToken: string): void; // headerName: auth_token\r\n```\n\n### `@delete` {#@TypeSpec.Http.delete}\n\nSpecify the HTTP verb for the target operation to be `DELETE`.\r\n\r\n```typespec\r\n@TypeSpec.Http.delete\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@delete op set(petId: string): void;\r\n```\n\n### `@get` {#@TypeSpec.Http.get}\n\nSpecify the HTTP verb for the target operation to be `GET`.\r\n\r\n```typespec\r\n@TypeSpec.Http.get\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@get op read(): string;\r\n```\n\n### `@head` {#@TypeSpec.Http.head}\n\nSpecify the HTTP verb for the target operation to be `HEAD`.\r\n\r\n```typespec\r\n@TypeSpec.Http.head\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@head op ping(petId: string): void;\r\n```\n\n### `@header` {#@TypeSpec.Http.header}\n\nSpecify this property is to be sent or received as an HTTP header.\r\n\r\n```typespec\r\n@TypeSpec.Http.header(headerNameOrOptions?: valueof string | TypeSpec.Http.HeaderOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name                | Type                                            | Description                                                                                                                                                                                                 |\r\n| ------------------- | ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| headerNameOrOptions | `valueof string \\| TypeSpec.Http.HeaderOptions` | Optional name of the header when sent over HTTP or header options.<br />By default the header name will be the property name converted from camelCase to kebab-case. (e.g. `contentType` -> `content-type`) |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(@header accept: string): {\r\n  @header(\"ETag\") eTag: string;\r\n};\r\nop create(\r\n  @header({\r\n    name: \"X-Color\",\r\n    format: \"csv\",\r\n  })\r\n  colors: string[],\r\n): void;\r\n```\r\n\r\n##### Implicit header name\r\n\r\n```typespec\r\nop read(): {\r\n  @header contentType: string;\r\n}; // headerName: content-type\r\nop update(@header ifMatch: string): void; // headerName: if-match\r\n```\n\n### `@multipartBody` {#@TypeSpec.Http.multipartBody}\n\n```typespec\r\n@TypeSpec.Http.multipartBody\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nop upload(\r\n  @header `content-type`: \"multipart/form-data\",\r\n  @multipartBody body: {\r\n    fullName: HttpPart<string>;\r\n    headShots: HttpPart<Image>[];\r\n  },\r\n): void;\r\n```\n\n### `@patch` {#@TypeSpec.Http.patch}\n\nSpecify the HTTP verb for the target operation to be `PATCH`.\r\n\r\n```typespec\r\n@TypeSpec.Http.patch(options?: valueof TypeSpec.Http.PatchOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                 | Description                      |\r\n| ------- | -------------------------------------------------------------------- | -------------------------------- |\r\n| options | [valueof `PatchOptions`](./data-types.md#TypeSpec.Http.PatchOptions) | Options for the PATCH operation. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@patch op update(pet: Pet): void;\r\n```\r\n\r\n```typespec\r\n// Disable implicit optionality, making the body of the PATCH operation use the\r\n// optionality as defined in the `Pet` model.\r\n@patch(#{ implicitOptionality: false })\r\nop update(pet: Pet): void;\r\n```\n\n### `@path` {#@TypeSpec.Http.path}\n\nExplicitly specify that this property is to be interpolated as a path parameter.\r\n\r\n```typespec\r\n@TypeSpec.Http.path(paramNameOrOptions?: valueof string | TypeSpec.Http.PathOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name               | Type                                          | Description                                                    |\r\n| ------------------ | --------------------------------------------- | -------------------------------------------------------------- |\r\n| paramNameOrOptions | `valueof string \\| TypeSpec.Http.PathOptions` | Optional name of the parameter in the uri template or options. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@route(\"/read/{explicit}/things/{implicit}\")\r\nop read(@path explicit: string, implicit: string): void;\r\n```\n\n### `@post` {#@TypeSpec.Http.post}\n\nSpecify the HTTP verb for the target operation to be `POST`.\r\n\r\n```typespec\r\n@TypeSpec.Http.post\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@post op create(pet: Pet): void;\r\n```\n\n### `@put` {#@TypeSpec.Http.put}\n\nSpecify the HTTP verb for the target operation to be `PUT`.\r\n\r\n```typespec\r\n@TypeSpec.Http.put\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@put op set(pet: Pet): void;\r\n```\n\n### `@query` {#@TypeSpec.Http.query}\n\nSpecify this property is to be sent as a query parameter.\r\n\r\n```typespec\r\n@TypeSpec.Http.query(queryNameOrOptions?: valueof string | TypeSpec.Http.QueryOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name               | Type                                           | Description                                                                     |\r\n| ------------------ | ---------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| queryNameOrOptions | `valueof string \\| TypeSpec.Http.QueryOptions` | Optional name of the query when included in the url or query parameter options. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(@query select: string, @query(\"order-by\") orderBy: string): void;\r\nop list(@query(#{ name: \"id\", explode: true }) ids: string[]): void;\r\n```\n\n### `@route` {#@TypeSpec.Http.route}\n\nDefines the relative route URI template for the target operation as defined by [RFC 6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)\r\n\r\n`@route` can only be applied to operations, namespaces, and interfaces.\r\n\r\n```typespec\r\n@TypeSpec.Http.route(path: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n\r\n| Name | Type             | Description |\r\n| ---- | ---------------- | ----------- |\r\n| path | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n##### Simple path parameter\r\n\r\n```typespec\r\n@route(\"/widgets/{id}\") op getWidget(@path id: string): Widget;\r\n```\r\n\r\n##### Reserved characters\r\n\r\n```typespec\r\n@route(\"/files{+path}\") op getFile(@path path: string): bytes;\r\n```\r\n\r\n##### Query parameter\r\n\r\n```typespec\r\n@route(\"/files\") op list(select?: string, filter?: string): Files[];\r\n@route(\"/files{?select,filter}\") op listFullUriTemplate(select?: string, filter?: string): Files[];\r\n```\n\n### `@server` {#@TypeSpec.Http.server}\n\nSpecify an endpoint for this service. Multiple `@server` decorators can be used to specify multiple endpoints.\r\n\r\n```typespec\r\n@TypeSpec.Http.server(url: valueof string, description?: valueof string, parameters?: Record<unknown>)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name        | Type              | Description                                             |\r\n| ----------- | ----------------- | ------------------------------------------------------- |\r\n| url         | `valueof string`  | Server endpoint                                         |\r\n| description | `valueof string`  | Description of the endpoint                             |\r\n| parameters  | `Record<unknown>` | Optional set of parameters used to interpolate the url. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\n@server(\"https://example.com\")\r\nnamespace PetStore;\r\n```\r\n\r\n##### With a description\r\n\r\n```typespec\r\n@service\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n```\r\n\r\n##### Parameterized\r\n\r\n```typespec\r\n@server(\"https://{region}.foo.com\", \"Regional endpoint\", {\r\n  @doc(\"Region name\")\r\n  region?: string = \"westus\",\r\n})\r\n```\r\n\r\n##### Multiple\r\n\r\n```typespec\r\n@service\r\n@server(\"https://example.com\", \"Standard endpoint\")\r\n@server(\r\n  \"https://{project}.private.example.com\",\r\n  \"Private project endpoint\",\r\n  {\r\n    project: string,\r\n  }\r\n)\r\nnamespace PetStore;\r\n```\n\n### `@sharedRoute` {#@TypeSpec.Http.sharedRoute}\n\n`@sharedRoute` marks the operation as sharing a route path with other operations.\r\n\r\nWhen an operation is marked with `@sharedRoute`, it enables other operations to share the same\r\nroute path as long as those operations are also marked with `@sharedRoute`.\r\n\r\n`@sharedRoute` can only be applied directly to operations.\r\n\r\n```typespec\r\n@sharedRoute\r\n@route(\"/widgets\")\r\nop getWidget(@path id: string): Widget;\r\n```\r\n\r\n```typespec\r\n@TypeSpec.Http.sharedRoute\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@statusCode` {#@TypeSpec.Http.statusCode}\n\nSpecify the status code for this response. Property type must be a status code integer or a union of status code integer.\r\n\r\n```typespec\r\n@TypeSpec.Http.statusCode\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(): {\r\n  @statusCode _: 200;\r\n  @body pet: Pet;\r\n};\r\nop create(): {\r\n  @statusCode _: 201 | 202;\r\n};\r\n```\n\n### `@useAuth` {#@TypeSpec.Http.useAuth}\n\nSpecify authentication for a whole service or specific methods. See the [documentation in the Http library](https://typespec.io/docs/libraries/http/authentication) for full details.\r\n\r\n```typespec\r\n@TypeSpec.Http.useAuth(auth: {} | Union | {}[])\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n\r\n| Name | Type                  | Description                                                                                                                                                     |\r\n| ---- | --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| auth | `{} \\| Union \\| {}[]` | Authentication configuration. Can be a single security scheme, a union(either option is valid authentication) or a tuple (must use all authentication together) |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\n@useAuth(BasicAuth)\r\nnamespace PetStore;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#openapi3#openapi.md\n- document_title: OpenAPI v3 emitter\n- document_link: https://typespec.io/docs/emitters/openapi3/openapi\n- document_content: # emitters#openapi3#openapi.md\n\n# OpenAPI v3 emitter\n\nThe OpenAPI emitter translates TypeSpec language elements into their equivalent OpenAPI expressions. This guide explains how TypeSpec constructs are mapped to OpenAPI components.\r\n\r\n**Note**: The below documentation generally refers to the behavior of the OpenAPI v3 emitter when using OpenAPI version 3.0. Emitter output for version 3.1 may be slightly different according to additional features supported in 3.1 but not in 3.0.\n\n## Server Details\n\nWhen your TypeSpec file includes an [(HTTP) `@server` decorator](../../libraries/http/reference/decorators.md#@TypeSpec.Http.server), the OpenAPI emitter will generate a `servers` object in the resulting OpenAPI document. This object contains the server URL, description, and any variables defined in the decorator.\r\n\r\nYou can apply multiple `@server` decorators to create multiple entries in the `servers` array:\r\n\r\n```typespec\r\n@server(\"https://api.example.com/v1\", \"Primary production endpoint\")\r\n@server(\"https://api-dev.example.com/v1\", \"Development endpoint\")\r\nnamespace MyService;\r\n```\n\n## Operations\n\nEach TypeSpec operation is converted into an OpenAPI operation.\n\n### HTTP Method\n\nYou can explicitly specify the HTTP method using one of the [(HTTP) decorators][http-verb-decorators]:\r\n\r\n- `@get`\r\n- `@post`\r\n- `@put`\r\n- `@patch`\r\n- `@delete`\r\n\r\nIf you don't specify a method, the emitter will infer it from the operation name and signature.\r\n\r\n```typespec\r\n// Explicitly declared as GET /{id}\r\n@get\r\nop getUser(@path id: string): User;\r\n\r\n// Explicitly declared as POST /\r\n@post\r\nop createUser(user: User): User;\r\n\r\n// Automatically detected as GET /{id}\r\nop getUser(@path id: string): User;\r\n\r\n// Automatically detected as POST /\r\nop createUser(user: User): User;\r\n```\n\n### Operation Path\n\nThe path for an operation comes from the [(HTTP) `@route` decorator][http-route-decorator]. You can apply `@route` to:\r\n\r\n- Individual operations\r\n- Interfaces (groups of operations)\r\n- Namespaces\r\n\r\nWhen you apply routes to multiple levels, they're combined to form the complete path:\r\n\r\n```typespec\r\n@route(\"/api\")\r\nnamespace MyService {\r\n  @route(\"/users\")\r\n  interface Users {\r\n    // Results in GET /api/users/{id}\r\n    @route(\"/{id}\")\r\n    @get\r\n    getUser(@path id: string): User;\r\n  }\r\n}\r\n```\r\n\r\n[http-verb-decorators]: ../../libraries/http/reference/decorators.md\r\n[http-route-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.route\r\n\r\nThe [OpenAPI Operation object][openapi-operation-object] fields are populated as described in the following sections.\r\n\r\n[openapi-operation-object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operationObject\n\n### Description\n\nThe operation's description comes from the documentation of the TypeSpec operation.\r\n\r\nDocumentation is provided either by a documentation comment or by the [(built-in) `@doc` decorator][doc-decorator] (the two are equivalent):\r\n\r\n```typespec\r\n/**\r\n * Retrieves a user by their unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n\r\n@doc(\"Retrieves a user by their unique identifier.\")\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nIf no documentation is provided, the description field is omitted.\r\n\r\n[doc-decorator]: ../../standard-library/built-in-decorators.md#@doc\n\n### Summary\n\nThe operation's summary comes from the [(built-in) `@summary` decorator][summary-decorator]:\r\n\r\n```typespec\r\n/**\r\n * Retrieves a user by their unique identifier.\r\n */\r\n@summary(\"Get a User by ID.\")\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nIf no `@summary` is provided, the summary field is omitted.\r\n\r\n[summary-decorator]: ../../standard-library/built-in-decorators.md#@summary\n\n### Operation ID\n\nThe operation ID can be explicitly set using the [(OpenAPI) `@operationId` decorator][openapi-operation-decorator]:\r\n\r\n```typespec\r\n@operationId(\"getUserById\")\r\nop getUser(id: string): User;\r\n```\r\n\r\nIf not explicitly defined, the operation ID defaults to:\r\n\r\n- The operation name (when the operation is not in an interface)\r\n- The interface name followed by the operation name (when in an interface)\r\n\r\n[openapi-operation-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.operationId\n\n### Parameters and Request Body\n\nTypeSpec operation parameters map to OpenAPI parameters and request body.\r\n\r\n#### Parameter Location\r\n\r\nYou specify where a parameter appears using these [(HTTP) decorators][http-parameter-decorators]:\r\n\r\n- `@query` - Query parameter in the URL\r\n- `@header` - HTTP header parameter\r\n- `@path` - Path parameter in the URL\r\n\r\nParameters without these decorators are assumed to be in the request body.\r\n\r\n```typespec\r\nop createUser(\r\n  // The parameter name is transformed to look like an HTTP header, so the parameter `contentType` maps\r\n  // to the `content-type` header\r\n  @header contentType: string,\r\n\r\n  @query include: string,\r\n  @path id: string,\r\n\r\n  // The request body will be a JSON object `{ \"user\": <User> }`\r\n  user: User, // This goes in the request body\r\n): User;\r\n```\r\n\r\n#### Request Body\r\n\r\nYou can explicitly mark a parameter as the request body using the [(HTTP) `@body` decorator][http-body-decorator]:\r\n\r\n```typespec\r\n// The request body will be a JSON object that _only_ contains the User at the top level.\r\nop createUser(@body user: User): User;\r\n```\r\n\r\nIf `@body` is not used, all parameters not marked with `@header`, `@query`, or `@path` form the request body, which is marked as required. To make the request body optional, declare it with an optional property and the `@body` decorator:\r\n\r\n```typespec\r\nop updateUser(@path id: string, @body user?: User): User;\r\n```\r\n\r\n[http-parameter-decorators]: ../../libraries/http/reference/decorators.md\r\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\r\n\r\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\r\n\r\n```typespec\r\n/**\r\n * Retrieves the User by their unique identifier.\r\n *\r\n * @param id The user's unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nThe content type for request bodies follows the [default content-type resolution logic](../..\n\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\r\n\r\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\r\n\r\n```typespec\r\n/**\r\n * Retrieves the User by their unique identifier.\r\n *\r\n * @param id The user's unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nThe content type for request bodies follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\r\n\r\nFor more advanced parameter configuration, see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\n\n### Responses\n\nstatus code is 200, the body will be just a JSON User at the top level.\r\n  @body user: User;\r\n}\r\n\r\nmodel NotFound {\r\n  @statusCode code: 404;\r\n\r\n  // If the status code is 404, the body will be a JSON object `{ \"message\": <string> }`\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | NotFound;\r\n```\r\n\r\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\r\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\r\n\r\nThe content type for responses follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\r\n\r\nFor more advanced response configuration, see see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\n\nThe operation's return type(s) translate into OpenAPI responses.\r\n\r\n#### Status Codes\r\n\r\nYou can specify a status code using the [(HTTP) `@statusCode` decorator][http-statuscode-decorator] on a property in the return type:\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode\r\n  code: 200;\r\n\r\n  body: User;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse;\r\n```\r\n\r\nYou can define multiple response types to handle different status codes:\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode\r\n  code: 200;\r\n\r\n  user: User;\r\n}\r\n\r\nmodel UserNotFoundResponse {\r\n  @statusCode\r\n  code: 404;\r\n\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | UserNotFoundResponse;\r\n```\r\n\r\n#### Error Responses\r\n\r\nUse the [(built-in) `@error` decorator][error-decorator] to indicate an error response, which becomes the \"default\" response in OpenAPI. To indicate that an operation returns a successful response or an error, simply use the error response type in a union with a non-error type:\r\n\r\n```typespec\r\n@error\r\nmodel ErrorResponse {\r\n  @statusCode\r\n  code: 404 | 500;\r\n\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): User | ErrorResponse;\r\n```\r\n\r\n#### Response Body\r\n\r\nThe response body can be explicitly marked with the `@body` decorator. Otherwise, any properties not marked with `@statusCode` or `@header` form the response body.\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode code: 200;\r\n\r\n  // If the status code is 200, the body will be just a JSON User at the top level.\r\n  @body user: User;\r\n}\r\n\r\nmodel NotFound {\r\n  @statusCode code: 404;\r\n\r\n  // If the status code is 404, the body will be a JSON object `{ \"message\": <string> }`\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | NotFound;\r\n```\r\n\r\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\r\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\n\n### Tags\n\nUse the [(built-in) `@tag` decorator][tag-decorator] to apply tag groups to operations that will be represented in the generated OpenAPI and OpenAPI-based documentation tools such as Swagger UI:\r\n\r\n```typespec\r\n@tag(\"Users\")\r\nop getUser(id: string): User;\r\n\r\n// Or at interface/namespace level\r\n@tag(\"Users\")\r\ninterface UserOperations {\r\n  getUser(id: string): User;\r\n  createUser(@body user: User): User;\r\n}\r\n```\r\n\r\nTags from operations, interfaces, and enclosing namespaces are combined.\r\n\r\n[tag-decorator]: ../../standard-library/built-in-decorators.md#@tag\n\n### Deprecated\n\nMark an operation as deprecated using the (built-in) `#deprecated` directive.\r\n\r\n```typespec\r\n#deprecated \"Use getUser instead\"\r\nop fetchUser(id: string): User;\r\n```\r\n\r\nThis sets the `deprecated` field to `true` in the OpenAPI operation.\n\n### External Documentation\n\nAdd external documentation links using the [(OpenAPI) `@externalDocs` decorator](../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.externalDocs):\r\n\r\n```typespec\r\n@externalDocs(\"https://example.com/docs/users\", \"Additional user documentation\")\r\nop getUser(id: string): User;\r\n```\r\n\r\nThe external documentation links are specific to the OpenAPI emitter and will not be used by any other emitters unless they are designed to interoperate with OpenAPI.\n\n### Specification Extensions\n\nAdd custom OpenAPI extensions for your use cases using the [(OpenAPI) `@extension` decorator][openapi-extension-decorator].\r\n\r\n```typespec\r\n@extension(\"x-ms-pageable\", #{ nextLinkName: \"nextLink\" })\r\nop listUsers(): UserList;\r\n```\r\n\r\nThe first argument to `@extension` becomes a key in the operation object, and the second argument is any JSON/YAML-like value. This decorator may be used to add arbitrary customization/extension to many OpenAPI constructs including schemas for TypeSpec types, operations, etc.\r\n\r\n[openapi-extension-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.extension\n\n## Models and Enums\n\nTypeSpec models and enums convert to OpenAPI schemas.\n\n### Schema Location\n\nModels are handled differently based on how they're defined:\r\n\r\n- **Named models**: defined in `components/schemas` section.\r\n- **Inline models**: defined inline where used.\r\n- **Template instances**: treated as inline unless they have a [(built-in) `@friendlyName` decorator][friendlyname], which causes them to be treated as named models.\r\n\r\n[friendlyname]: ../../standard-library/built-in-decorators.md#@friendlyName\n\n### Type Mapping\n\nThis table shows how TypeSpec types map to OpenAPI/JSON Schema types:\r\n\r\n| TypeSpec type    | OpenAPI `type`/`format`           | Notes                                                                     |\r\n| ---------------- | --------------------------------- | ------------------------------------------------------------------------- |\r\n| `int32`          | `type: integer, format: int32`    |                                                                           |\r\n| `int64`          | `type: integer, format: int64`    |                                                                           |\r\n| `float32`        | `type: number, format: float`     |                                                                           |\r\n| `float64`        | `type: number, format: double`    |                                                                           |\r\n| `string`         | `type: string`                    |                                                                           |\r\n| `bytes`          | `type: string, format: byte`      | for content-type == 'application/json' or 'text/plain'                    |\r\n| `bytes`          | `type: string, format: binary`    | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `boolean`        | `type: boolean`                   |                                                                           |\r\n| `plainDate`      | `type: string, format: date`      |                                                                           |\r\n| `utcDateTime`    | `type: string, format: date-time` | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `offsetDateTime` | `type: string, format: date-time` | RFC 3339 date with timezone offset                                        |\n\n### Data Validation Decorators\n\nThe tables below show how various built-in decorators add validation constraints to model properties:\r\n\r\n**For numeric types:**\r\n\r\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Example                      |\r\n| ------------------ | -------- | --------------------------- | ---------------------------- |\r\n| `@minValue(value)` | built-in | `minimum: value`            | `@minValue(0) age: int32;`   |\r\n| `@maxValue(value)` | built-in | `maximum: value`            | `@maxValue(120) age: int32;` |\r\n\r\n**For string types:**\r\n\r\n| Decorator           | Library  | OpenAPI/JSON Schema keyword | Example                                 |\r\n| ------------------- | -------- | --------------------------- | --------------------------------------- |\r\n| `@format(name)`     | built-in | `format: name`              | `@format(\"email\") email: string;`       |\r\n| `@minLength(value)` | built-in | `minLength: value`          | `@minLength(8) password: string;`       |\r\n| `@maxLength(value)` | built-in | `maxLength: value`          | `@maxLength(50) name: string;`          |\r\n| `@pattern(regex)`   | built-in | `pattern: regex`            | `@pattern(\"^[A-Z]{2}$\") state: string;` |\r\n| `@secret`           | built-in | `format: password`          | `@secret password: string;`             |\r\n\r\n**For array types:**\r\n\r\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Example                         |\r\n| ------------------ | -------- | --------------------------- | ------------------------------- |\r\n| `@minItems(value)` | built-in | `minItems: value`           | `@minItems(1) tags: string[];`  |\r\n| `@maxItems(value)` | built-in | `maxItems: value`           | `@maxItems(10) tags: string[];` |\n\n### Using External References\n\nThe [`@useRef` decorator](./reference/decorators.md#@TypeSpec.OpenAPI.useRef) configures a TypeSpec model with a reference to an external schema that will be used in place of references to that model's schema:\r\n\r\n```typespec\r\n// Whenever the OpenAPI emitter would try to reference the Sku model's schema, it will reference the below\r\n// external schema instead.\r\n@useRef(\"common.json#/components/schemas/Sku\")\r\nmodel Sku {\r\n  name: string;\r\n  tier: string;\r\n}\r\n```\n\n### Enums\n\nTypeSpec enums and unions convert to OpenAPI enum schemas. You can define enums in two ways:\r\n\r\n**TypeSpec enum declaration:**\r\n\r\n```typespec\r\nenum Color {\r\n  Red: \"red\",\r\n  Blue: \"blue\",\r\n  Green: \"green\",\r\n}\r\n```\r\n\r\n**Union of literal values:**\r\n\r\n```typespec\r\nmodel Settings {\r\n  // `status` can be any of the following strings.\r\n  status: \"Running\" | \"Stopped\" | \"Failed\";\r\n}\r\n```\r\n\r\nBoth approaches result in an OpenAPI schema with a type of `string` and an `enum` array containing the specified values.\n\n## Model Composition\n\nTypeSpec offers several ways to compose models.\n\n### Spread Operator\n\nThe spread operator copies properties from one model to another without creating a semantic relationship:\r\n\r\n```typespec\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n  state: string;\r\n}\r\n\r\nmodel UserProfile {\r\n  name: string;\r\n\r\n  // Copy all the properties of Address into this model as if they were declared here.\r\n  ...Address;\r\n\r\n  email: string;\r\n}\r\n```\r\n\r\nIn OpenAPI, the result is a flat schema named `UserProfile` with the properties of `Address` declared inline.\n\n### Extends Keyword\n\nThe `extends` keyword creates an inheritance relationship:\r\n\r\n```typespec\r\nmodel Pet {\r\n  name: string;\r\n  age: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  breed: string;\r\n}\r\n```\r\n\r\nIn OpenAPI, this creates a schema `Dog` that references the schema `Pet` using `allOf`.\r\n\r\n#### Discriminated Union with Extends\r\n\r\nYou can create discriminated type hierarchies using the `@discriminator` decorator:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  kind: \"dog\"; // Must be a literal string value\r\n  breed: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  kind: \"cat\"; // Must be a literal string value\r\n  whiskerCount: int32;\r\n}\r\n```\r\n\r\nThis creates a discriminator object in the OpenAPI schema with a mapping from discriminator values to schemas.\n\n### Is Keyword\n\nThe `is` keyword creates a new model with the same shape as another model:\r\n\r\n```typespec\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n}\r\n\r\nmodel ShippingDetails is Address {\r\n  zipCode: string; // Additional property\r\n}\r\n```\r\n\r\nIn OpenAPI, `ShippingDetails` is an independent schema with all properties from `Address` plus `zipCode`.\n\n### Unions\n\nUnions represent values that could be one of several types:\r\n\r\n**Union type alias:**\r\n\r\n```typespec\r\nalias PetType = Dog | Cat | Hamster;\r\n```\r\n\r\n**Named union declaration:**\r\n\r\n```typespec\r\nunion PetType {\r\n  dog: Dog,\r\n  cat: Cat,\r\n  hamster: Hamster,\r\n}\r\n```\r\n\r\nBy default, unions emit as `anyOf` in OpenAPI. You can use the [`@oneOf` decorator](./reference/decorators.md#@TypeSpec.OpenAPI.oneOf) on a named union declaration to emit it as `oneOf` instead:\r\n\r\n```typespec\r\n@oneOf\r\nunion PetType {\r\n  dog: Dog,\r\n  cat: Cat,\r\n  hamster: Hamster,\r\n}\r\n```\n\n## Encoding and Formats\n\nThe `@encode` decorator lets you control how TypeSpec types are serialized. The general pattern is:\r\n\r\n```typespec\r\n@encode(\"<encoding name>\", encodingTargetType) property: trueType;\r\n```\r\n\r\nWhere:\r\n\r\n- `\"<encoding name>\"`: The format or method of encoding (e.g., `\"base64\"`, `\"rfc3339\"`, `\"unixTimestamp\"`)\r\n- `encodingTargetType`: The type to encode to and decode from (e.g., `int32`, `string`)\r\n- `trueType`: The \"true\" semantic data type of the property (e.g., `duration`, `utcDateTime`)\r\n\r\nThe emitter follows these rules to determine the OpenAPI format:\r\n\r\n1. For date/time types:\r\n\r\n   - `@encode(\"rfc3339\", string) _: utcDateTime`  `type: string, format: date-time`\r\n   - `@encode(\"rfc7231\", string) _: utcDateTime`  `type: string, format: http-date`\r\n   - `@encode(\"unixTimestamp\", int32) _: utcDateTime`  `type: integer, format: unixtime`\r\n\r\n2. For other types, the format comes from either the encoding name or the `encodingTargetType`'s format.\r\n\r\nThis table summarizes common encodings:\r\n\r\n| TypeSpec with encoding                           | OpenAPI 3 result                  |\r\n| ------------------------------------------------ | --------------------------------- |\r\n| `@encode(\"seconds\", int32) _: duration`          | `type: integer, format: int32`    |\r\n| `@encode(\"ISO8601\") _: duration`                 | `type: number, format: duration`  |\r\n| `@encode(\"unixTimestamp\", int64) _: utcDateTime` | `type: integer, format: unixtime` |\r\n| `@encode(\"rfc3339\") _: utcDateTime`              | `type: string, format: date-time` |\n\n## Security Definitions\n\nUse the [(HTTP) `@useAuth` decorator][http-useauth-decorator] to define authentication and security schemes for your API.\r\n\r\nFor example, to define an authentication/authorization scheme based on Microsoft Entra ID:\r\n\r\n```typespec\r\n@useAuth(EntraIDToken)\r\nnamespace Contoso.WidgetManager;\r\n\r\n/** Microsoft Entra ID OAuth2 Flow */\r\nmodel EntraIDToken\r\n  is OAuth2Auth<[\r\n    {\r\n      type: OAuth2FlowType.authorizationCode;\r\n      authorizationUrl: \"https://api.example.com/oauth2/authorize\";\r\n      tokenUrl: \"https://api.example.com/oauth2/token\";\r\n      scopes: [\"https://management.azure.com/read\", \"https://management.azure.com/write\"];\r\n    }\r\n  ]>;\r\n```\r\n\r\nAuthentication/authorization is a complex and highly configurable feature. See the [`@useAuth` decorator documentation for more information][http-useauth-decorator].\r\n\r\n[http-useauth-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.useAuth\n", "latency": 13.479464054107666, "response_length": 1213}
{"query": "title: Notice of update of services returning bytes\n\nquestion: Latest upgrade of TypeSpec changed the default interpretation of a body of `bytes` without an explicit content type to assume `application/octet-stream` from previously being a json string of base64 encoded data\n```\nop getFile(): bytes;\n```\nThere were 3 services that add this pattern and the swagger was just updated to reflect the behavior:\n- OpenAI.Assistant\n- Microsoft.App.DynamicSessions\n- AzureOpenAI/inference\n![alt text](image-7.png)\nCreating this post as a notice and pinging service teams affected to get confirmation that the spec was actually incorrect before. If it was indeed correct before (those apis returned base64 json string and not the raw file) then we can go back and add the explicit `@header contentType: \"application/json\"` to revert back.\nTypeSpec Engineering Weidong Xu not sure where to find the service owner to ping if anyone knows and can add them to this post", "ground_truth": "Context for Java SDK update (PR not merged) on this (affect \"azure-ai-openai\" and \"azure-ai-openai-assistants\")\nhttps://github.com/Azure/azure-sdk-for-java/pull/44730#issuecomment-2742522605\nWould appeciate input from service about the expected content-type 2 `getFileContent` API.", "response": "The latest upgrade of TypeSpec has changed the default interpretation of a `bytes` body without an explicit content type to assume `application/octet-stream`. Previously, it was interpreted as a JSON string of base64 encoded data. This change aligns with the documented behavior of `bytes` in TypeSpec, where `bytes` are serialized as base64 in contexts requiring string encoding (e.g., JSON model properties or `text/plain` payloads) but are transmitted as raw binary data in `application/octet-stream` contexts.\n\nTo revert to the previous behavior (interpreting `bytes` as a base64 JSON string), you can explicitly specify the content type using the `@header contentType: \"application/json\"` decorator. This ensures the emitter respects the intended serialization format.\n\nAffected services, such as OpenAI.Assistant, Microsoft.App.DynamicSessions, and AzureOpenAI/inference, should confirm whether the previous specification was incorrect. If the APIs indeed returned base64 JSON strings before, adding the explicit content type decorator will restore the original behavior.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#http#encoding.md\n- document_title: Encoding of types\n- document_link: https://typespec.io/docs/libraries/http/encoding\n- document_content: # libraries#http#encoding.md\n\n# Encoding of types\n\nThis document describe how the http library interpret TypeSpec built-in types and how to configure\n\n## `bytes`\n\n**Default behavior:**\r\n\r\n- `bytes` are serialized as `base64` when used in any context that requires they be encoded to a string (such as in a model property that is serialized as JSON, or if transmitted as a string in a `\"text/plain\"` payload).\r\n- In the context of a binary payload (`\"application/octet-stream\"`) or an [HTTP File](./operations.md#handling-files), `bytes` are not encoded. They represent the body of the request, response, or multipart field or the file's exact contents.\r\n\r\n:::note\r\nThis behavior is only a specification and MUST be respected by the emitter. The http library DOES NOT automatically apply the `@encode(\"base64\")` when used inside a JSON model.\r\n:::\r\n\r\nUse `@encode` to configure\r\n\r\n```tsp\r\nmodel Pet {\r\n  icon: bytes; // Serialize as base64\r\n  @encode(BytesKnownEncoding.base64url) // Serialize as base64url\r\n  other: bytes;\r\n}\r\n\r\nop read(): Pet;\r\n\r\nop download(): bytes; // Return application/octet-stream\r\nop upload(@body data: bytes): void; // Accept application/octet-stream\r\n```\n\n## `utcDatetime` and `offsetDateTime`\n\n**Default behavior:**\r\n\r\n- Encoded as `rfc7231` when used in a header\r\n- Encoded as `rfc3339` otherwise.\r\n\r\n:::note\r\nThis behavior is only a specification and MUST be respected by the emitter. The http library DOES NOT automatically apply the `@encode(\"rfc7231\")` on `utcDatetime` and `offsetDateTime` when used in a header.\r\n:::\r\n\r\nUse `@encode` to configure.\r\n\r\n<table>\r\n<tr><td>TypeSpec</td><td>Example payload</td></tr>\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\nmodel User {\r\n  // Headers\r\n  @header(\"Created-At\") createdAtHeader: utcDateTime;\r\n\r\n  @header(\"Created-At-Rfc3339\")\r\n  @encode(DateTimeKnownEncoding.rfc3339)\r\n  createdAtHeaderRfc3339Encoding: utcDateTime;\r\n\r\n  // In Json payload\r\n  createdAt: utcDateTime; // rfc3339\r\n\r\n  updatedAt: offsetDateTime; // rfc3339\r\n\r\n  @encode(DateTimeKnownEncoding.rfc7231)\r\n  createdAtPretty: utcDateTime; // rfc7231\r\n\r\n  @encode(DateTimeKnownEncoding.rfc7231)\r\n  updatedAtPretty: offsetDateTime; // rfc7231\r\n\r\n  @encode(DateTimeKnownEncoding.unixTimestamp, int32)\r\n  createdAtUnix: utcDateTime; // unixTime in seconds\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nCreated-At: Wed, 12 Oct 2022 07:20:50 GMT\r\nCreated-At-Rfc3339: 2022-10-12T07:20:50.52Z\r\n```\r\n\r\n```json\r\n{\r\n  \"createdAt\": \"2022-10-12T07:20:50.52Z\",\r\n  \"updatedAt\": \"2022-10-25T07:20:50.52+07:00\",\r\n  \"createdAtPretty\": \"Wed, 12 Oct 2022 07:20:50 GMT\",\r\n  \"updatedAtPretty\": \"Tue, 25 Oct 2022 00:20:50 GMT\",\r\n  \"createdAtUnix\": 1493938410\r\n}\r\n```\r\n\r\n</td>\r\n</tr>\r\n</table>\n\n## `duration`\n\n**Default behavior:**\r\n\r\n- Encoded as `ISO8601`\r\n\r\nUse `@encode` to configure.\r\n\r\n<table>\r\n<tr><td>TypeSpec</td><td>Example payload</td></tr>\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\nmodel User {\r\n  runtime: duration; // ISO8601\r\n\r\n  @encode(DurationKnownEncoding.seconds, int32)\r\n  runtimeInSecondsInt: duration; // in seconds as an int32\r\n\r\n  @encode(DurationKnownEncoding.seconds, float32)\r\n  runtimeInSecondsFloat: duration; // in seconds as a float32\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```json\r\n{\r\n  \"runtime\": \"PT5M5S\",\r\n  \"runtimeInSecondsInt\": \"305\",\r\n  \"runtimeInSecondsFloat\": \"305.0\"\r\n}\r\n```\r\n\r\n</td>\r\n</tr>\r\n</table>\n\n## Numeric types ( `int64`, `decimal128`, `float64`, etc.)\n\nBy default numeric types are serialized as a JSON number. However for large types like `int64` or `decimal128` that cannot be represented in certain languages like JavaScript it is recommended to serialize them as string over the wire.\r\n\r\n<table>\r\n<tr><td>TypeSpec</td><td>Example payload</td></tr>\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\nmodel User {\r\n  id: int64; // JSON number\r\n\r\n  @encode(string)\r\n  idAsString: int64; // JSON string\r\n\r\n  viaSalar: decimalString;\r\n}\r\n\r\n@encode(string)\r\nscalar decimalString extends decimal128;\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```json\r\n{\r\n  \"id\": 1234567890123456789012345678901234567890,\r\n  \"idAsString\": \"1234567890123456789012345678901234567890\",\r\n  \"viaSalar\": \"1.3\"\r\n}\r\n```\r\n\r\n</td>\r\n</tr>\r\n</table>\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-openapi.md\n- document_title: no-openapi\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi\n- document_content: # libraries#azure-core#rules#no-openapi.md\n\n# no-openapi\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-openapi\r\n```\r\n\r\nAzure services should not be using decorators from the OpenAPIs libraries(`@azure-tools/openapi`, `@azure-tools/typespec-autorest` or `@azure-tools/openapi3`) in their spec.\r\nUsing those decorators is usually a sign that the spec is either not following the correct Azure or trying to match exactly a particular OpenAPI spec which should be a non-goal.\r\n\r\nThose decorators are only meant to be read by the openapi emitters which means this might achieve the correct OpenAPI output but other emitters(client SDK, service, etc.) will not be able to understand them and will see a broken representation of the spec.\n\n## Decorators and their alternatives\n\n|\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              | Use versioning library for `version` and `@service` for title                                                                                                   |\n\n| OpenAPI Decorator                    | Alternative                                                                                                                                                     |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `@example`                           | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-examples\", `       | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-client-flatten\", ` | TCGC [`@flattenProperty`](../../typespec-client-generator-core/reference/decorators#@Azure.ClientGenerator.Core.flattenProperty)                                |\r\n| `@extension(\"x-ms-mutability\", `     | Use [`@visibility` decorator](https://typespec.io/docs/next/standard-library/built-in-decorators#@visibility)                                                   |\r\n| `@extension(\"x-ms-enum\", `           | [Enum extensibility doc](https://azure.github.io/typespec-azure/docs/next/troubleshoot/enum-not-extensible)                                                     |\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              |\n\n## Exceptions\n\n- `@extension(\"x-ms-identifiers\"` is allowed as this right now has no alternative and is an ARM requirement that is not used by any other emitter.\n\n## Examples\n\n### `@extension(\"x-ms-enum\"`\n\n####  Incorrect\r\n\r\n```tsp\r\n@extension(\r\n  \"x-ms-enum\",\r\n  {\r\n    name: \"PetKind\",\r\n    modelAsString: true,\r\n  }\r\n)\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n\n### `@extension(\"x-ms-mutability\"`\n\n####  Incorrect\r\n\r\n```tsp\r\nmodel Pet {\r\n  @extension(\"x-ms-mutability\", [\"read\", \"create\"])\r\n  name: string;\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\nmodel Pet {\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  name: string;\r\n}\r\n```\n\n### `@operationId`\n\n####  Incorrect\r\n\r\n```tsp\r\n@operationId(\"Pet_Get\")\r\nop getPet(): Pet;\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\ninterface Pet {\r\n  get(): Pet;\r\n}\r\n```\n", "latency": 11.382152557373047, "response_length": 1077}
{"query": "title: Type Spec review for Data plane API specs\n\nquestion: Hi TypeSpec Discussion, do we need review from type spec team before we could merge data plane API spec PR on github specs repo?", "ground_truth": "All data plane API specs must be reviewed by the API Stewardship board.  Please create a release plan and then you can schedule a review.  [What is a release plan?](https://eng.ms/docs/products/azure-developer-experience/plan/release-plan)", "response": "Yes, it is recommended to have a review from the TypeSpec team before merging data-plane API spec PRs into the GitHub specs repository. The TypeSpec migration process emphasizes human inspection, correction, and optimization of the generated TypeSpec specifications to ensure they conform to the service API and pass validation checks. Additionally, the TypeSpec team provides guidance, office hours, and a discussion channel for addressing questions and scheduling reviews. This ensures the specifications meet the required standards and follow best practices.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n", "latency": 10.857388257980347, "response_length": 561}
{"query": "title: Naming of JS/TS emitters\n\nquestion: We need consistency and accuracy in our naming of client and server emitters for JS/TS for our 1.0-RC release. The client currently has 'ts' in the name and the server has 'javascript' in the name. Do these emitters actually generate TypeScript or is it just JavaScript?\nI know TS is syntactic sugar on top of JS, but I believe the distinction will matter to 3P devs who may rely on TypeScript type checking.", "ground_truth": "The renaming of the emitters to use js aligns with the broader trend where the distinction between JavaScript and TypeScript is becoming less important. Most developers expect JavaScript libraries to include TypeScript definitions, and using js in the name, even for TypeScript code, shouldn't cause confusion, especially since tools are available to strip TypeScript annotations. Both client and server emitters are now using js in their names for consistency.", "response": "The distinction between 'TypeScript' and 'JavaScript' emitters is important for clarity and developer expectations. Based on the provided context, the emitters generate TypeScript interfaces and models for type-safe development, but the actual output files are JavaScript. For example, the `@typespec/http-server-js` emitter generates TypeScript interfaces for models and service operations, but the router and other components are output as JavaScript files. Similarly, the client emitter for JavaScript (`@typespec/http-client-js`) generates JavaScript SDKs with optional TypeScript type definitions. Therefore, the naming should reflect the primary output format (JavaScript) while acknowledging the availability of TypeScript types where applicable. For consistency, consider renaming the emitters to 'javascript-client' and 'javascript-server' while clarifying in documentation that TypeScript types are included.", "context": "- document_dir: typespec_docs\n- document_filename: emitters#servers#http-server-js#project.md\n- document_title: About Generated Projects\n- document_link: https://typespec.io/docs/emitters/servers/http-server-js/project\n- document_content: # emitters#servers#http-server-js#project.md\n\n# About Generated Projects\n\n**This package is highly experimental and may be subject to breaking changes and bugs.** Please expect that your code may need to be updated as this package evolves, and please report any issues you encounter.\n\n## Functionality and generated code\n\nThe emitter generates a few major components:\n\n### Router\n\nThe highest-level component that your code interacts with directly is the router implementation.\r\n`@typespec/http-server-js` generates a static router that you can bind to an implementation of an HTTP server.\r\n\r\nThe router is generated in the `http/router.js` module within the output directory. Each service will have its own\r\nrouter implementation named after the service. For example, given a service namespace named `Todo`, the router module\r\nwill export a function `createTodoRouter`. This function creates an instance of a router that dispatches methods within\r\nthe `Todo` service.\r\n\r\n```ts\r\nimport { createTodoRouter } from \"../tsp-output/@typespec/http-server-js/http/router.js\";\r\n\r\nconst router = createTodoRouter(users, todoItems, attachments);\r\n```\r\n\r\nAs arguments, the `createTodoRouter` function expects implementations of the underlying service interfaces. These\r\ninterfaces are explained further in the next section.\r\n\r\nOnce the router is created, it is bound to an instance of the HTTP server. The router's `dispatch` method implements the\r\nNode.js event handler signature for the `request` event on a Node.js HTTP server.\r\n\r\n```ts\r\nconst server = http.createServer();\r\n\r\nserver.on(\"request\", router.dispatch);\r\n\r\nserver.listen(8080, () => {\r\n  console.log(\"Server listening on http://localhost:8080\");\r\n});\r\n```\r\n\r\nAlternatively, the router can be used with Express.js instead of the Node.js HTTP server directly. If the `express`\r\nfeature is enabled in the emitter options, the router will expose an `expressMiddleware` property that implements the\r\nExpress.js middleware interface.\r\n\r\n```ts\r\nimport express from \"express\";\r\n\r\nconst app = express();\r\n\r\napp.use(router.expressMiddleware);\r\n\r\napp.listen(8080, () => {\r\n  console.log(\"Server listening on http://localhost:8080\");\r\n});\r\n```\n\n### Service interfaces\n\nThe emitter generates interfaces for each collection of service methods that exists in the service namespace.\r\nImplementations of these interfaces are required to instantiate the router. When the router processes an HTTP request,\r\nit will call the appropriate method on the service implementation after determining the route and method.\r\n\r\nFor example, given the following TypeSpec namespace `Users` within the `Todo` service:\r\n\r\n```tsp\r\nnamespace Users {\r\n  @route(\"/users\")\r\n  @post\r\n  op create(\r\n    user: User,\r\n  ): WithStandardErrors<UserCreatedResponse | UserExistsResponse | InvalidUserResponse>;\r\n}\r\n```\r\n\r\nThe emitter will generate a corresponding interface `Users` within the module `models/all/todo/index.js` in the output\r\ndirectory.\r\n\r\n```ts\r\n/** An interface representing the operations defined in the 'Todo.Users' namespace. */\r\nexport interface Users<Context = unknown> {\r\n  create(\r\n    ctx: Context,\r\n    user: User,\r\n  ): Promise<\r\n    | UserCreatedResponse\r\n    | UserExistsResponse\r\n    | InvalidUserResponse\r\n    | Standard4XxResponse\r\n    | Standard5XxResponse\r\n  >;\r\n}\r\n```\r\n\r\nAn object implementing this `Users` interface must be passed to the router when it is created. The `Context` type\r\nparameter represents the underlying protocol or framework-specific context that the service implementation may inspect.\r\nIf you need to access the HTTP request or response objects directly in the implementation of the service methods, you\r\nmust use the `HttpContext` type as the `Context` argument when implementing the service interface. Otherwise, it is safe\r\nto use the default `unknown` argument.\r\n\r\n```ts\r\nimport { HttpContext } from \"../tsp-output/@typespec/http-server-js/helpers/router.js\";\r\nimport { Users } from \"../tsp-output/@typespec/http-server-js/models/all/todo/index.js\";\r\n\r\nexport const users: Users<HttpContext> = {\r\n  async create(ctx, user) {\r\n    // Implementation\r\n  },\r\n};\r\n```\n\n### Models\n\nThe emitter generates TypeScript interfaces that represent the model types used in the service operations. This allows\r\nthe service implementation to interact with the data structures carried over the HTTP protocol in a type-safe manner.\n\n### Operation functions\n\nWhile your code should never need to interact with these functions directly, the emitter generates a function per HTTP\r\noperation that handles the parsing and validation of the request contents. This allows the service implementation to be\r\nwritten in terms of ordinary TypeScript types and values rather than raw HTTP request and response objects. In general:\r\n\r\n- The Node.js HTTP server or Express.js application (your code) calls the router (generated code), which determines\r\n  which service operation function (generated code) to call based on the route, method, and other HTTP metadata in the\r\n  case of shared routes.\r\n- The operation function (generated code) deserializes the request body, query parameters, and headers into TypeScript\r\n  types, and may perform request validation.\r\n- The operation function (generated code) calls the service implementation (your code) with the deserialized request\r\n  data.\r\n- The service implementation (your code) returns a result or throws an error.\r\n- The operation function (generated code) responds to the HTTP request on your behalf, converting the result or error\r\n  into HTTP response data.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#clients#introduction.mdx\n- document_title: Client Emitters\n- document_link: https://typespec.io/docs/emitters/clients/introduction\n- document_content: # emitters#clients#introduction.mdx\n\n# Client Emitters\n\nimport { Aside, Steps } from \"@astrojs/starlight/components\";\n\n## How to Use Emitters to Generate HTTP Clients from TypeSpec\n\n### Introduction\n\nThis guide will walk you through the process of using different client emitters (JavaScript, Python, Java, C#) to generate HTTP clients from TypeSpec. Please note that all client emitters are currently in **preview** and are subject to changes in future versions.\r\n\r\nBy following this guide, you will learn:\r\n\r\n1. How to set up client emitters in `package.json`.\r\n2. Update the client emitter configurations in `tspconfig.yaml`.\r\n3. How to generate HTTP clients for each specific programming language.\n\n## Location of All Client Emitters\n\nThe client emitters are defined in the `package.json` file within your project.\r\n\r\n| **Emitter Name**             | **Language** | **Version**                                                    |\r\n| ---------------------------- | ------------ | -------------------------------------------------------------- |\r\n| @typespec/http-client-js     | JavaScript   | ![](https://img.shields.io/npm/v/@typespec/http-client-js)     |\r\n| @typespec/http-client-python | Python       | ![](https://img.shields.io/npm/v/@typespec/http-client-python) |\r\n| @typespec/http-client-java   | Java         | ![](https://img.shields.io/npm/v/@typespec/http-client-java)   |\r\n| @typespec/http-client-csharp | C#           | ![](https://img.shields.io/npm/v/@typespec/http-client-csharp) |\r\n\r\nBelow is an example of the `package.json` snippet where client emitters are defined:\r\n\r\n```json\r\n  \"dependencies\": {\r\n    \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\",\r\n    \"@typespec/http-client-java\": \"^0.1.9\",\r\n    \"@typespec/http-client-python\": \"^0.6.6\",\r\n    \"@typespec/http-client-js\": \"^0.38.1\",\r\n  }\r\n```\n\n## Client Emitter Settings\n\nThis part provides an overview of the common and language-specific settings for each client emitter. These settings are stored in the `tspconfig.yaml` file.\n\n### Common Configuration Options\n\nThe below option applies to all client emitters.\r\n\r\n- `emitter-output-dir`: Defines where the generated SDK files will be stored.\n\n### JavaScript Client Emitter Settings\n\nJavaScript generally requires minimal configuration. However, it is recommended to provide `packageDetails` for package metadata, which is used in `package.json` and `README.md` files.\r\n\r\n#### packageDetails\r\n\r\nProvide the metadata for `package.json`, `README.md` information.\r\n\r\n| Property    | Description                                                            |\r\n| ----------- | ---------------------------------------------------------------------- |\r\n| name        | Package name used in `package.json`                                    |\r\n| description | Package description used in `package.json` file                        |\r\n| version     | Detailed version for your package, the default value is `1.0.0-beta.1` |\r\n\r\nExample configuration:\r\n\r\n```yaml\r\npackageDetails:\r\n  name: \"${your_package_name}\"\r\n  version: 1.0.0\r\n```\n\n### Java Client Emitter Settings\n\n#### Prerequisites\r\n\r\nBefore using the Java client emitter, ensure the following dependencies are installed:\r\n\r\n- **Java 17 or later** - [Download here](https://docs.microsoft.com/java/openjdk/download)  \r\n  _(Verify installation with `java --version`)_\r\n- **Maven** - [Download here](https://maven.apache.org/download.cgi)  \r\n  _(Verify installation with `mvn --version`)_\n\n### C# Client Emitter Settings\n\nBefore using the C# client emitter, ensure that the [.NET 8.0 SDK](https://dotnet.microsoft.com/en-us/download/dotnet/8.0) (or higher) is installed.\r\nFull configuration options can be found in the [C# Client Emitter README](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md#configuration)\n\n## JavaScript Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-js\": \"^0.38.1\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-js\"\r\noptions:\r\n  \"@typespec/http-client-js\":\r\n    emitter-output-dir: \"{project-root}/clients/javascript\"\r\n    packageDetails:\r\n      name: \"your_package_name\"\r\n      version: 1.0.0\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the JavaScript client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Python Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-python\": \"^0.6.6\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-python\"\r\noptions:\r\n  \"@typespec/http-client-python\":\r\n    emitter-output-dir: \"{project-root}/clients/python\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Python client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Java Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-java\": \"^0.1.9\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-java\"\r\noptions:\r\n  \"@typespec/http-client-java\":\r\n    emitter-output-dir: \"{project-root}/clients/java\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the Java client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## C# Client Emitter Example\n\n### Step 1: Install Dependencies\n\nAdd the following dependencies to your `package.json` file:\r\n\r\n```json\r\n\"dependencies\": {\r\n  \"@typespec/http-client-csharp\": \"^0.1.9-alpha.20250113.2\"\r\n}\r\n```\r\n\r\nRun the following command to install the dependencies:\r\n\r\n```bash\r\ntsp install\r\n```\n\n### Step 2: Update Configuration\n\nUpdate your `tspconfig.yaml` file with the following configuration:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-csharp\"\r\noptions:\r\n  \"@typespec/http-client-csharp\":\r\n    emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n```\n\n### Step 3: Generate Client\n\nRun the following command to generate the C# client:\r\n\r\n```bash\r\ntsp compile {path to main.tsp}/main.tsp\r\n```\n\n## Running Language-Specific Emitters in CLI\n\n<Steps>\r\n\r\n1. Ensure that your package.json file is correctly configured to include the necessary dependencies for running the emitters\r\n\r\n2. Update the tspconfig.yaml file for properly configured for the language-specific emitter.\r\n\r\n   ```yaml\r\n   emit:\r\n     - \"@typespec/http-client-csharp\"\r\n     - \"@typespec/http-client-java\"\r\n     - \"@typespec/http-client-python\"\r\n     - \"@typespec/http-client-js\"\r\n   options:\r\n     \"@typespec/http-client-csharp\":\r\n       emitter-output-dir: \"{project-root}/clients/dotnet\"\r\n     \"@typespec/http-client-java\":\r\n       emitter-output-dir: \"{project-root}/clients/java\"\r\n     \"@typespec/http-client-python\":\r\n       emitter-output-dir: \"{project-root}/clients/python\"\r\n     \"@typespec/http-client-js\":\r\n       emitter-output-dir: \"{project-root}/clients/javascript\"\r\n   ```\r\n\r\n3. Once the package.json and tspconfig.yaml files are updated, you need to install all required dependencies by running the following command in the project root:\r\n\r\n   ```bash\r\n   tsp install\r\n   ```\r\n\r\n4. Run the emitter to compile your TypeScript code into the desired language. Use the following command to trigger the emitter and compile your project:\r\n\r\n   ```bash\r\n   tsp compile {path to main.tsp}/main.tsp\r\n   ```\r\n\r\n</Steps>\n\n## Disclaimer\n\n<Aside>\r\n\r\n**All client emitters are in preview**. These emitters are actively being developed and may experience changes or updates that could affect their functionality. Please follow the official documentation for the latest updates.\r\n\r\n- [TypeSpec C# emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-csharp/readme.md)\r\n- [TypeSpec Python emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-python/README.md)\r\n- [TypeSpec Java emitter library](https://github.com/microsoft/typespec/blob/main/packages/http-client-java/README.md)\r\n- [TypeSpec JS emitter library](https://github.com/Azure/autorest.typescript/blob/main/packages/typespec-ts/README.md)\r\n\r\n</Aside>\n", "latency": 11.184712409973145, "response_length": 918}
{"query": "title: Support for @includeInapplicableMetadataInPayload decorator\n\nquestion: After pulling the latest changes, I been getting errors regarding \"@includeInapplicableMetadataInPayload(false)\" decorator not being supported anymore.\nIs it not possible to make use of the decorator? If I removed the decorator from the model ts file, it changes the expected model definition for the API path on swagger.", "ground_truth": "The decorator was moved to a private namespace in the March 2025 TypeSpec release, which may cause breaking changes if it's removed. The recommendation is to consider using existing Resource models like TrackedResource<T> to avoid this. If the spec is on the main branch, it should already have the necessary updates. Make sure to pull the latest changes and update the local compiler to avoid issues.", "response": "The `@includeInapplicableMetadataInPayload` decorator is still supported in TypeSpec, but its behavior has changed. By default, metadata properties (e.g., `@path`, `@query`, `@statusCode`, `@header`) that are deemed inapplicable in a given context (e.g., `@path` in a response) are included in the payload unless explicitly excluded using `@includeInapplicableMetadataInPayload(false)`. If you remove the decorator, the metadata will be included in the payload, which could alter the expected model definition in Swagger or other emitters.\n\nTo resolve your issue, you can:\n\n1. **Reintroduce the decorator**: Use `@includeInapplicableMetadataInPayload(false)` to exclude inapplicable metadata from the payload.\n\n2. **Adjust your model**: If removing the decorator changes the expected model definition in Swagger, you may need to update your TypeSpec model to align with the desired API behavior.\n\nFor example:\n```typescript\nmodel User {\n  name: string;\n  @path id: string;\n  @visibility(Lifecycle.Create) password: string;\n}\n\n@route(\"/users\")\ninterface Users {\n  @post create(...User): User;\n}\n```\n\nThis approach ensures that metadata properties are handled correctly based on their applicability and visibility.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#http#operations.md\n- document_title: Operations\n- document_link: https://typespec.io/docs/libraries/http/operations\n- document_content: # libraries#http#operations.md\n\n# Operations\n\n## Operation verb\n\n**Default behavior:**\r\n\r\n- If `@post` operation has a request body\r\n- `@get` otherwise\r\n\r\n**Configure:**\r\n\r\nYou can use one of the [verb decorators](./reference/decorators.md): `@get`, `@put`, etc.\n\n## Route\n\nAn operation route can be specified using the `@route` decorator.\r\n\r\n```typespec\r\n@route(\"/pets\") op list(): Pet[];\r\n```\r\n\r\nRoute path parameters are declared using `{}`. Providing `@path` on the model property with the matching name is optional.\r\n\r\n```typespec\r\n@route(\"/pets/{petId}\") op get(petId: string): Pet;\r\n// or explicit @path\r\n@route(\"/pets/{petId}\") op get(@path petId: string): Pet;\r\n```\r\n\r\nRoute can be specified on a parent namespace or interface. In that case all the operations, interfaces and namespaces underneath will be prefixed with it.\r\n\r\n```typespec\r\n@route(\"/store\")\r\nnamespace PetStore {\r\n  op hello(): void; // `/store`\r\n  @route(\"ping\") op ping(): void; // `/store/ping`\r\n\r\n  @route(\"/pets\")\r\n  interface Pets {\r\n    list(): Pet[]; // `/store/pets`\r\n    @route(\"{petId}\") read(petId: string): Pet; // `/store/pets/{petId}`\r\n  }\r\n}\r\n```\n\n## Path and query parameters\n\nModel properties and parameters which should be passed as path and query parameters use the `@path` and `@query` parameters respectively. Let's modify our list operation to support pagination, and add a read operation to our Pets resource:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): Pet[];\r\n  op read(@path petId: int32): Pet;\r\n}\r\n```\r\n\r\nPath parameters are appended to the URL unless a substitution with that parameter name exists on the resource path. For example, we might define a sub-resource using the following TypeSpec. Note how the path parameter for our sub-resource's list operation corresponds to the substitution in the URL.\r\n\r\n```typespec\r\n@route(\"/pets/{petId}/toys\")\r\nnamespace PetToys {\r\n  op list(@path petId: int32): Toy[];\r\n}\r\n```\n\n## Request & response bodies\n\nRequest and response bodies can be declared explicitly using the `@body` decorator. Let's add an endpoint to create a pet. Let's also use this decorator for the responses, although this doesn't change anything about the API.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[];\r\n  };\r\n  op read(@path petId: int32): {\r\n    @body pet: Pet;\r\n  };\r\n  @post\r\n  op create(@body pet: Pet): {};\r\n}\r\n```\r\n\r\nNote that in the absence of explicit `@body`:\r\n\r\n1. The set of parameters that are not marked @header, @query, or @path form the request body.\r\n2. The set of properties of the return model that are not marked @header or @statusCode form the response body.\r\n3. If the return type is not a model, then it defines the response body.\r\n\r\nThis is how we were able to return Pet and Pet[] bodies without using @body for list and read. We can actually write\r\ncreate in the same terse style by spreading the Pet object into the parameter list like this:\r\n\r\nSee also [metadata](./operations.md#metadata) for more advanced details.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @post\r\n  op create(...Pet): {};\r\n}\r\n```\n\n## Headers\n\nModel properties and parameters that should be passed in a header use the `@header` decorator. The decorator takes the header name as a parameter. If a header name is not provided, it is inferred from the property or parameter name. Let's add `etag` support to our pet store's read operation.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[];\r\n  };\r\n  op read(@path petId: int32, @header ifMatch?: string): {\r\n    @header eTag: string;\r\n    @body pet: Pet;\r\n  };\r\n  @post\r\n  op create(@body pet: Pet): {};\r\n}\r\n```\n\n## Status codes\n\n**Default behavior:**\r\n\r\n- `4xx,5xx` if response is marked with `@error`\r\n- `200` otherwise\r\n\r\n**Configure:**\r\n\r\nUse the `@statusCode` decorator on a property to declare a status code for a response. Generally, setting this to just `int32` isn't particularly useful. Instead, use number literal types to create a discriminated union of response types. Let's add status codes to our responses, and add a 404 response to our read endpoint.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @error\r\n  model Error {\r\n    code: string;\r\n  }\r\n\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[]; // statusCode: 200 Implicit\r\n  };\r\n  op read(@path petId: int32, @header ifMatch?: string): {\r\n    @statusCode statusCode: 200;\r\n    @header eTag: string;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n  };\r\n  op create(@body pet: Pet): {\r\n    @statusCode statusCode: 204;\r\n  } | Error; //statusCode: 4xx,5xx as Error use `@error` decorator\r\n}\r\n```\n\n## Content type\n\n[See the documentation of Content-Types](./content-types.md).\n\n## Built-in response shapes\n\nSince status codes are so common for REST APIs, TypeSpec comes with some built-in types for common status codes so you don't need to declare status codes so frequently.\r\n\r\nThere is also a `Body<T>` type, which can be used as a shorthand for { @body body: T } when an explicit body is required.\r\n\r\nLets update our sample one last time to use these built-in types:\r\n\r\n```typespec\r\nmodel ETag {\r\n  @header eTag: string;\r\n}\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): OkResponse & Body<Pet[]>;\r\n  op read(@path petId: int32, @header ifMatch?: string): (OkResponse &\r\n    Body<Pet> &\r\n    ETag) | NotFoundResponse;\r\n  @post\r\n  op create(...Pet): NoContentResponse;\r\n}\r\n```\r\n\r\nNote that the default status code is 200 for non-empty bodies and 204 for empty bodies. Similarly, explicit `Body<T>` is not required when T is known to be a model. So the following terser form is equivalent:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): Pet[];\r\n  op read(@path petId: int32, @header ifMatch?: string): (Pet & ETag) | NotFoundResponse;\r\n  @post\r\n  op create(...Pet): {};\r\n}\r\n```\r\n\r\nFinally, another common style is to make helper response types that are\r\nshared across a larger service definition. In this style, you can be\r\nentirely explicit while also keeping operation definitions concise.\r\n\r\nFor example, we could write :\r\n\r\n```typespec\r\nmodel ListResponse<T> {\r\n  ...OkResponse;\r\n  ...Body<T[]>;\r\n}\r\n\r\nmodel ReadSuccessResponse<T> {\r\n  ...OkResponse;\r\n  ...ETag;\r\n  ...Body<T>;\r\n}\r\n\r\nalias ReadResponse<T> = ReadSuccessResponse<T> | NotFoundResponse;\r\n\r\nmodel CreateResponse {\r\n  ...NoContentResponse;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): ListResponse<Pet>;\r\n  op read(@path petId: int32, @header ifMatch?: string): ReadResponse<Pet>;\r\n  @post\r\n  op create(...Pet): CreateResponse;\r\n}\r\n```\n\n## Handling files\n\n`@typespec/http` provides a special model [`TypeSpec.Http.File`](../http/reference/data-types.md#file-typespechttpfile) for handling file uploads and downloads in HTTP operations. When working with files, emitters need to implement special handling due to their binary nature.\r\n\r\nFor more information about HTTP file bodies and how to configure them, see [the documentation on Files][http-files].\r\n\r\n[http-files][./files.md]\n\n### Basic File Handling\n\nWhen the model `Http.File` (or any model that extends `Http.File`) is the _exact_ body of an HTTP request, emitters **must** treat this model with special care:\r\n\r\n- The `contentType` property should be used as the value for the `Content-Type` header in requests and vice-versa for responses.\r\n- The `filename` property should be used in the `Content-Disposition` header in responses and vice-versa for multipart requests (`filename` cannot be sent in a non-multipart HTTP request because `Content-Disposition` is only valid for responses and multipart requests).\r\n- The file content should be treated as the raw body of the request/response without any additional parsing.\r\n\r\nSee [`isHttpFile`](../http/reference/js-api/functions/isHttpFile.md) for a helper that emitters/libraries can use to detect instances of `Http.File`.\n\n### Examples\n\n#### Uploading and downloading files\r\n\r\n```typespec\r\n// Uploading and downloading\r\n@route(\"/files\")\r\ninterface Files {\r\n  @post\r\n  upload(@body file: Http.File): {\r\n    @statusCode statusCode: 201;\r\n  };\r\n\r\n  download(@path fileId: string): Http.File;\r\n}\r\n```\r\n\r\n#### Custom file types\r\n\r\nIf you want to declare specific types of files that are accepted, but still treated as binary files, declare the content types by extending the `Http.File` model and overriding the `contentType` field.\r\n\r\n```typespec\r\n// Custom file type for images\r\nmodel ImageFile extends Http.File {\r\n  contentType: \"image/jpeg\" | \"image/png\" | \"image/gif\";\r\n}\r\n\r\n@route(\"/images\")\r\ninterface Images {\r\n  @post\r\n  upload(@body image: ImageFile): {\r\n    @statusCode statusCode: 201;\r\n  };\r\n\r\n  download(@path imageId: string): ImageFile;\r\n}\r\n```\n\n## Automatic visibility\n\nThe `@typespec/rest` library understands [Lifecycle Visibility](../../language-basics/visibility.md#lifecycle-visibility) and provides functionality for emitters to apply visibility transforms based on whether a model represents a request or response and on HTTP method usage as detailed in the table below.\r\n\r\nSee [handling visibility and metadata](../../extending-typespec/emitter-metadata-handling.md) for details on how to incorporate this information into an emitter implementation.\r\n\r\n| Modifier         | Visible in           |\r\n| ---------------- | -------------------- |\r\n| Lifecycle.Read   | Any response         |\r\n| Lifecycle.Query  | GET or HEAD request  |\r\n| Lifecycle.Create | POST or PUT request  |\r\n| Lifecycle.Update | PATCH or PUT request |\r\n| Lifecycle.Delete | DELETE request       |\r\n\r\nThis allows a single logical TypeSpec model to be used as in the following example:\r\n\r\n```typespec\r\nmodel User {\r\n  name: string;\r\n  @visibility(Lifecycle.Read) id: string;\r\n  @visibility(Lifecycle.Create) password: string;\r\n}\r\n\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(@path id: string, ...User): User;\r\n  @get get(@path id: string): User;\r\n}\r\n```\r\n\r\nThere is a single logical user entity represented by the single TypeSpec type `User`, but the HTTP payload for this entity varies based on context. When returned in a response, the `id` property is included, but when sent in a request, it is not. Similarly, the `password` property is only included in create requests, but not present in responses.\r\n\r\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(Lifecycle.Read)` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas.\n\nincluded in create requests, but not present in responses.\r\n\r\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(Lifecycle.Read)` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas. For example, `@visibility(Lifecycle.Create)` applied to a model property of a type named Widget will generate a `WidgetCreate` schema.\r\n\r\nAnother emitter such as one generating client code can see and preserve a single logical type and deal with these HTTP payload differences by means other than type proliferation.\r\n\r\nModeling with logical entities rather than HTTP-specific shapes also keeps the TypeSpec spec decoupled from HTTP and REST and can allow the same spec to be used with multiple protocols.\n\n## Metadata\n\nin terms of the logical entity:\r\n\r\n```typespec\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(...User): User;\r\n}\r\n```\r\n\r\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\r\n\r\n```\r\nPOST /Users/TypeSpecFan42 HTTP/1.1\r\nContent-Type: application/json\r\n{\r\n  \"name\": \"TypeSpec Fan\",\r\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\r\n}\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\n{\r\n  name: \"TypeSpec Fan\",\r\n  id: \"TypeSpecFan42\r\n}\r\n```\n\nThe properties that designate content for the HTTP envelope (`@header`, `@path`, `@query`, `@statusCode`) rather than the content in an HTTP payload are often called \"metadata\".\r\n\r\nMetadata is determined to be applicable or inapplicable based on the context that it is used:\r\n\r\n| Context       | Applicability       |\r\n| ------------- | ------------------- |\r\n| `@query`      | request only        |\r\n| `@path`       | request only        |\r\n| `@statusCode` | response only       |\r\n| `@header`     | request or response |\r\n\r\nAdditionally metadata that appears in an array element type always inapplicable.\r\n\r\nWhen metadata is deemed \"inapplicable\", for example, if a `@path` property is seen in a response, it becomes part of the payload instead unless the [@includeInapplicableMetadataInPayload](./reference/decorators.md#@TypeSpec.Http.includeInapplicableMetadataInPayload) decorator is used and given a value of `false`.\r\n\r\nThe handling of metadata applicability furthers the goal of keeping a single logical model in TypeSpec. For example, this defines a logical `User` entity that has a name, ID and password, but further annotates that the ID is sent in the HTTP path and the HTTP body in responses. Also, using automatic visibility as before, we further indicate that the password is only present in create requests.\r\n\r\n```typespec\r\nmodel User {\r\n  name: string;\r\n  @path id: string;\r\n  @visibility(Lifecycle.Create) password: string;\r\n}\r\n```\r\n\r\nThen, we can write operations in terms of the logical entity:\r\n\r\n```typespec\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(...User): User;\r\n}\r\n```\r\n\r\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\r\n\r\n```\r\nPOST /Users/TypeSpecFan42 HTTP/1.1\r\nContent-Type: application/json\r\n{\r\n  \"name\": \"TypeSpec Fan\",\r\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\r\n}\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\n{\n\n### Visibility vs. Metadata applicability\n\nMetadata properties are filtered based on visibility as [described above](#automatic-visibility). This is done independently before applicability is considered. If a a metadata property is not visible then it is neither part of the envelope nor the HTTP payload, irrespective of its applicability.\n\n### Nested metadata\n\nMetadata properties are not required to be top-level. They can also be nested deeper in a parameter or response model type. For example:\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: {\r\n    @header example: string;\r\n  };\r\n  name: string;\r\n}\r\n```\r\n\r\nNote that nesting in this sense does not require the use of anonymous models. This is equivalent:\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: Headers;\r\n  name: string;\r\n}\r\nmodel Headers {\r\n  @header example: string;\r\n}\r\n```\r\n\r\nIn the event that this nesting introduces duplication, then the least nested property with a given name is preferred and the duplicate metadata properties are ignored.\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: {\r\n    @header example: string; // preferred\r\n    more: {\r\n      @header example: string; // ignored\r\n    };\r\n  };\r\n}\r\n```\n\n## Emitter resources\n\nSee [Handling metadata and visibility in emitters for REST API](../../extending-typespec/emitter-metadata-handling.md) for information on how to handle metadata applicability and automatic visibility in a custom emitter.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#breakingchange.md\n- document_title: Resolving Swagger Breaking Change Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\n- document_content: # migrate-swagger#faq#breakingchange.md\n\n# Resolving Swagger Breaking Change Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Migrate ARM Specs\n\n### Changing the Names of Request Payload Parameters\n\nFor operations with non-empty request bodies (PUT, POST, PATCH), the TypeSpec operation templates provide a default name for the\r\nrequest parameter corresponding to the request payload. You can use augment decorators to make changes to this parameter, and other parts of the operation signature.\r\n\r\nThe following sections show how to do this for each operation template.\r\n\r\n#### CreateOrUpdate (PUT) APIs\r\n\r\nGiven a PUT operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  createOrUpdate is ArmResourceCreateOrReplaceAsync<Widget>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `resource` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.createOrUpdate::parameters.resource, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PUT operation template.\r\n\r\n#### Update (PATCH) APIs\r\n\r\nGiven a PATCH operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  update is ArmResourcePatchAsync<Widget, WidgetProperties>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `properties` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.update::parameters.properties, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PATCH operation template.\n\n### Action (POST) APIs\n\nGiven a POST operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  mungeWidget is ArmResourceActionAsync<Widget, MungeRequest, MungeResponse>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `body` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.mungeWidget::parameters.body, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ POST operation template.\n\n### Adding Request Query or Header Parameters\n\nThe `Parameters` template parameter allows you to specify additional parameters after the operation path (for example, query and header parameters) in the form of a model, with each model property corresponding to a parameter. You may use intersection to combine multiple separate parameters.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.StandardListQueryParameters\r\n>;\r\n\r\n// intersecting individual parameters\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.TopQueryParameter & Azure.Core.SkipQueryParameter\r\n>;\r\n```\n\n### Changing Response Types\n\nThe `Response` parameter allows you to specify non-error responses to the operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Response = MyCustomCollectionType>;\r\n```\n\n### Changing Error Types\n\nThe `Error` parameter allows you to change the default error type used in an operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Error = MyCustomError>;\r\n```\n\n### Converting Synchronous Operations to LROs\n\nusing the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation. It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op doStuff is ArmResourceActionAsync<Resource, ActionRequest, ActionResponse>;\r\n\r\n  // with no request body\r\n  op doStuffNoRequest is ArmResourceActionAsync<Resource, void, ActionResponse>;\r\n\r\n  // with no response body\r\n  op doStuffCommand is ArmResourceActionAsync<Resource, ActionRequest, void>;\r\n  ```\r\n\r\n#### Templates for Async DELETE Operations\r\n\r\n- `ArmResourceDeleteWithoutOKAsync` is a DELETE operation that uses no request body, will return a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op delete is ArmResourceDeleteWithoutOKAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourceDeleteAsync`iis a DELETE operation that uses no request body, and return a `200` response in the case of a successful synchronous delete, a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmResourceDeleteAsync<Resource>;\r\n  ```\n\nYou can generally choose an asynchronous operation template that matches your operation.\r\n\r\n#### Templates for Async PUT Operations\r\n\r\n- `ArmCreateOrReplaceAsync` is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Location` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrReplaceAsync<Resource>;\r\n  ```\r\n\r\n- `ArmCreateOrUpdateAsync`is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Azure-AsyncOperation` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrUpdateAsync<Resource>;\r\n  ```\r\n\r\n#### Templates for Async PATCH Operations\r\n\r\n- `ArmTagsPatchAsync` is a PATCH operation that only allows changing the resource tags (the minimum for Azure Resource Manager).\r\n\r\n  ```tsp\r\n  op update is ArmTagsPatchAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourcePatchAsync`is a PATCH operation that uses the visibility settings to select properties for the PATCH request body(any property with no visibility setting, or including visibility \"update\"). It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation.\n", "latency": 10.126732110977173, "response_length": 1212}
{"query": "title: How do I remove a parameter?\n\nquestion: Hi! I'm converting my Go SDK that's a brown-field service to generate with typespec, and I need to remove an optional parameter. I'm struggling to figure out how to do it though.\nI've tried changing the access, but it fails to generate:\n![alt text](image-8.png)\n![alt text](image-9.png)\nI also tried changing the visibility:\n![alt text](image-10.png)\n![alt text](image-12.png)\nI'm pretty new to typespec, so I don't know all the decorators. What's the recommended way to get a parameter not to generate in the SDK? Thank you!", "ground_truth": "Currently, TCGC does not support excluding parameters from SDK generation. The best approach for now is to either mark the entire operation or model as internal access or use the `@access` decorator to make parameters private. However, TCGCs `@override` decorator, while useful, doesn't currently support removing parameters and is primarily intended for option bags. There is no active GitHub issue for this specific use case, but one could be filed.", "response": "To remove an optional parameter from generating in the SDK, you can use the `@access` decorator with `Access.internal`. This will hide the parameter from the generated SDK. For example:\n\n```typespec\n@access(Access.internal)\nmodel MyModel {\n  @access(Access.internal)\n  optionalParam?: string;\n}\n```\n\nThis approach ensures that the parameter is not included in the SDK generation while still being part of the TypeSpec definition. If you want to apply this change specifically for certain languages, you can use the `scope` parameter in the `@access` decorator, such as `@access(Access.internal, \"!java\")` to exclude it for Java but include it for other languages.", "context": "- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n", "latency": 9.577551364898682, "response_length": 663}
{"query": "title: Annotate same model with SubscriptionLocationResource and ResourceGroupLocationResource\n\nquestion: 1.We have added a new SubscriptionLocationResource named \"ValidatedSolutionRecipe\", as per the typespec docs to our RP - Microsoft.AzureStackHCI. Here is the typespec for this resource\n2.This is a proxy resource and the URL path for this resource looks like \"/subscriptions/921d26b3-c14d-4efc-b56e-93a2439e028c/providers/Microsoft.AzureStackHCI/locations/eastus/validatedSolutionRecipes/10.2502.0?api-version=2023-12-01-preview\"\nAs above API is a subscription level API, the clients of the API need to have subscription level RBAC. Due to security requirements, we need to have a similar API, but at resource group scope.\n1.From the typespec docs and our prototyping, we see that we can achieve this by havning a ResourceGroupLocationResource.\n2.However, same model in typespec can't be annotated with both SubscriptionLocationResource and ResourceGroupLocationResource. When we do so, the generated swagger only has either subscription level paths or resourcegroup level paths, depending on which annotation is first on the model.\n3.Thus, to work around this, we had to introduce a new resource type with an undesirable name - \"ResourceGroupValidatedSolutionRecipe\".\nBut it is the same resource. Just because of the limitation of not being able to support both SubscriptionLocationResource and ResourceGroupLocationResource, we have to create a new model with an undesirable name - \"ResourceGroupValidatedSolutionRecipe\".\nPlease help us and let us know how can we utilize the model with same name (i.e. the same resource type) for both of the above APIs.", "ground_truth": "Youre essentially dealing with two distinct resources in ARM due to their different sets of operations at the subscription and resource group levels. While they might have identical properties, ARM requires them to be treated as separate resource types, and thus, they need separate registrations and operations.\nTo simplify the model and avoid confusion for customers, you could potentially use a custom operation or adjust your approach for handling these two resource types. If both locations expose the same GET operation and are largely the same resource, using a single model might be possible with custom operation handling. However, ARM likely wont allow this without separate registrations due to the operational differences.\nIn SDKs, this could create confusion, as the variance between the two APIs might not be intuitive. Its important to consider customer use cases, such as whether they need to transfer resources between locations or share code between these two types. A shared type could work if the operations align, but it's crucial to decide whether the benefits of exposing this as a single resource outweigh the potential complexity.", "response": "Currently, TypeSpec does not support annotating the same model with both `SubscriptionLocationResource` and `ResourceGroupLocationResource`. This limitation arises because TypeSpec generates paths based on the first annotation applied to the model, and it cannot simultaneously generate paths for both subscription-level and resource-group-level APIs. \n\nTo work around this limitation, you can define two separate models, each annotated with the respective resource type (`SubscriptionLocationResource` and `ResourceGroupLocationResource`). While this approach requires creating two models, it ensures that the generated Swagger includes paths for both scopes. Unfortunately, this means you will need to use distinct names for the models, such as `ValidatedSolutionRecipe` for subscription-level and `ResourceGroupValidatedSolutionRecipe` for resource-group-level.\n\nIf you want to avoid undesirable naming conventions, you can consider submitting feedback or feature requests to the TypeSpec team to support dual annotations for models in future versions.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-type.md\n- document_title: ARM Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type\n- document_content: # howtos#arm#resource-type.md\n\n# ARM Resource Types\n\n## Introductions\n\nIntroduction\r\nResources are the basic building blocks of Azure. When a customer interacts with Azure through the Control Plane (ARM), they generally will be reading (GET), writing (PUT/PATCH), deleting (DELETE) or performing actions upon (POST) one or more resources. Each resource is managed by a particular Resource Provider, so we uniquely identify a resource by its 'fully-qualified type'. Some well-known examples of types are Microsoft.Compute/virtualMachines, or Microsoft.Network/networkSecurityGroups/securityRules. See Resource Ids for a more in-depth breakdown of the id and associated fields.\r\n\r\nIn order to give customers a consistent API when working with many different Resource Providers, and to allow ARM to understand and manage resources programmatically, ARM requires each RP to follow a set of contracts for resource management, defined in the ARM RPC.\n\n## ARM Resource Terminology\n\nThe most important distinction between resources is between _Tracked_ and _Proxy_ resources. Tracked resources are resources in which all of the metadata is maintained in Azure Resource Manager. Tracked Resources can be targeted to specific regions, and are generally the best choice for most top-level resources. Azure Resource Manager maintains data about Tracked Resources, and generally will handle many implementation details or operations on the resource. See [RPC: Resource API Reference](https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md) for further information on the contract for Tracked Resources.\r\n\r\nProxy resources are resources in which only a portion of resource metadata is tracked in ARM. Generally, these model resources maintained on other systems, or that resource-providers want to track themselves. Generally, resource providers must implement most of the operations for Proxy resources. Tenant, Extension, and child resources are usually modeled as Proxy resources.\r\n\r\nThere is a good discussion on making the choice between Tracked and Proxy Resources in the armwiki discussion [Tracked vs Proxy Resources](https://armwiki.azurewebsites.net/rp_onboarding/tracked_vs_proxy_resources.html)\n\n## Choosing a Resource Type\n\n- The large majority of resources have their metadata tracked by ARM, can be assigned to regions, and are contained inside a resource group in a subscription, for ease of management and billing. These are called [Tracked Resources](#tracked-resources).\r\n- Some resources may need to have scope across an entire customer tenant, or may need to have a single instance across all customer subscriptions. These are called [tenant resources](#tenant-resources).\r\n- Some kinds of resources may augment or alter the functionality of resources or resource containers provided by other resource-providers. For example, policy or RBAC rules may be applied to any resource or resource container. These resources are called [extension resources](#extension-resource).\r\n- Some resources are complex and naturally break down into one or more components that are separately configurable, but an integral part of the larger resource (for example, a virtual network resource may contain many separately configurable subnets). These component resources are called [child resources](#child-resource).\r\n- Rarely, some resources may need to apply across a subscription, or have a single instance in a customer subscription, these are called [subscription-based resources](#subscription-based-resource).\r\n- Rarer still, some resources may need to apply across a specific region, or have a single instance in a region, these are called [location-based resources](#location-based-resource).\r\n- In some cases, there can only be one instance of a resource at a specific scope - this is rare, but happens most frequently in tenant, child, and location resources. In typespec, you will need to specify that the resource is a singleton, and the resource manager tools will automatically apply the correct pattern for singleton resources (using the recommended resource name 'default')\n\n## Modeling Resources in TypeSpec\n\nResources are modeled in TypeSpec by choosing a _base resource type_, defining _rp-specific properties_, and optionally mixing in _standard envelope properties_. Later sections document [how to model resource operations](./resource-operations.md). The following sections discuss usage of each of the base resource types. Later sections discuss [designing rp-specific properties](#designing-resource-specific-properties) and [adding standard ARM envelope properties](#adding-optional-standard-envelope-properties).\n\n### Tracked Resources\n\nTracked resources use the `TrackedResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tracked Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Tenant Resources\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@tenantResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tenant Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Extension Resource\n\nExtension resources use the `ExtensionResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is ExtensionResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Extension Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Child Resource\n\nChild resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@parentResource(EmployeeResource)\r\nmodel JobResource is ProxyResource<JobProperties> {\r\n  /** The job name */\r\n  @segment(\"jobs\")\r\n  @key(\"jobName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@parentResource`: designates the model type for the parent of this child resource. The resource identifier for this resource will be prepended with the resource identity of the parent.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Child Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Subscription-based Resource\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@subscriptionResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@subscriptionResource`: designates this resource as being a cross-subscription resource, with scope across all resource groups in the subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Subscription Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Location-based Resource\n\nLocation-based resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@locationResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@locationResource`: designates this resource as being a cross-location resource, with scope across a location within a subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Location Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Singleton Resource\n\nSingleton resources can use any resource base type, but most often use `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@singleton\r\n@tenantResource\r\nmodel EmployeeAgreementResource is ProxyResource<EmployeeAgreementProperties> {\r\n  /** The default employee agreement, applying to all employees. */\r\n  @segment(\"employeeAgreements\")\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@singleton`: indicates that there can only be one of the resources in the resource container (in this case, only one instance in the customer tenant).\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource. For a singleton, the name value will always be the same.\r\n`@segment(employeeAGreements)`: provides the resource type name for this resource.\r\n`@key`: provides the parameter name for the name of the resource in operations that use this resource - this will not be a settable value for singleton resources.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Singleton Resources [in the Singleton sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/arm-scenarios/singleton/main.tsp#L29).\n\n## Designing Resource-specific Properties\n\nEach resource model consists of two distinct parts\r\n\r\n- An outer _envelope_ of information that provides metadata for optional standardized ARM functionality, like entity-tags and managed identities, and is processed by Azure Resource Manager.\r\n- An inner set of properties that are specific to the resource and are defined by the resource provider.\r\n\r\nModifying the ARM envelope is discussed in later sections on [mixing in standard ARM envelope add-ons](#adding-optional-standard-envelope-properties).\r\n\r\nThe inner _rp-specific property bag_ consists of all of the properties that the RP needs to manage about the resource. Properties should be completely specified, should not duplicate properties from the _ARM envelope_, and may consist of simple types, arrays, or other complex properties.\r\n\r\nHere is an example of a property bag for the `EmployeeResource` resource.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n\r\nunion EmployeeProvisioningState {\r\n  string,\r\n\r\n  /** The resource create request has been accepted */\r\n  Accepted: \"Accepted\",\r\n\r\n  /** The resource is being provisioned */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is updating */\r\n  Updating: \"Updating\",\r\n\r\n  /** Resource has been created. */\r\n  Succeeded: \"Succeeded\",\r\n\r\n  /** Resource creation failed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\n\nfailed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n\r\nmodel EmployeeProperties {\r\n  /** The current title of the employee */\r\n  title: string;\r\n\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  level: EmployeeLevel;\r\n\r\n  @visibility(Lifecycle.Read)\r\n  employeeId: int32;\r\n\r\n  biography?: string = \"No biography provided\";\r\n  colleagues: EmployeeResourceId[];\r\n  employmentHistory: Job[];\r\n\r\n  @visibility(Lifecycle.Create)\r\n  password: Password;\r\n\r\n  provisioningState?: EmployeeProvisioningState;\r\n}\r\n```\r\n\r\n`EmployeeProperties` specifies the employee metadata that the RP needs to track and manage. Notice that the model uses built-in scalar types like `string` and `int32`, new types built from scalar types with added constraints, like `Password` and `EmployeeLevel`, enumerations of values, like `EmployeeProvisioningState`, and complex types. The individual components of this model are described below.\r\n\r\nNote that _documentation comments on all models and model properties are required when specs are checked in_. Here they are omitted for clarity. The TypeSpec compiler and TypeSpec IDE tooling will emit warning diagnostics if you emit required documentation, and about most of the ARM rules described in this document.\n\n### The `provisioningState` Property for Tracked Resources\n\nAll Tracked Resources are required to implement a 'provisioningState' property in their rp-specific property bag. This is used by ARM and some ARM clients to track the provisioning state of a resource as it is created and deleted. At minimum, the provisioning state must contain the standard terminal values that ARM is looking for. There are contained in the `ResourceProvisioningState` enumeration in the Azure.ResourceManager library. If RPs have other provisioning states they would like to track, they can define their own provisioning state enum, and mix in the value, as shown in the sample above, or they may simply use the standard provisioning state as shown in the sample below:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  ...ResourceProvisioningState;\r\n}\r\n```\r\n\r\nNote that this example uses the spread operator `...`, which allows you to simply include the properties from a source model in the target model you are constructing. This has the effect of copying the properties of the source model and their decorations into the target model, without creating any nominal inheritance relationship.\r\n\r\nAlternately, this is also equivalent:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  /** The status of the last provisioning operation performed on the resource. */\r\n  @visibility(Lifecycle.Read)\r\n  provisioningState?: ResourceProvisioningState;\r\n}\r\n```\n\n### Required and Optional properties and Property Defaults\n\nIn the examples, note that some model properties use the optional operator `?` after the property name, like `biography?` and some do not, like `title`. Property names using the `?` are optional properties, which may or may not be provided in the request body for CreateOrUpdate (PUT) requests. Property names without the `?` are required properties, which must be provided in PUT requests. The exception is that properties that have 'readOnly' visibility do not appear in requests, but may be required or optional in responses.\r\n\r\nAlso note that optional properties may specify defaults, as with `biography?: string = \"No biography provided\"`. The default indicates the value that will be recorded on the server if no value is sent by the client.\n\n### Defining Custom Types\n\nIn the sample, new constrained scalar types and new complex model types are defined and used inside the _rp-specific property bag_. TypeSpec allows you to define custom types for use in your specification.\r\n\r\nYou will often want to define scalar types or properties that have constraints. For example, numeric values may be constrained to have a certain minimum or maximum, strign values may be constrained to follow a particular regex pattern, and so on. Whenever these constrained types are used in your spec, the constraints will be transmitted to the usage.\r\n\r\nThe example creates a numeric type with minimum and maximum constraints:\r\n\r\n```typespec\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n```\r\n\r\nThis defines 'EmployeeLevel' as an integer value between 50 and 70. The example also defines a complex type used in an array:\r\n\r\n```typespec\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n```\r\n\r\nMode details on what to consider when using complex types in an array are discussed in the section on [modeling arrays of complex types](#modeling-arrays-of-complex-types).\n\n### Using Resource identifiers\n\nIt is often the case that resources need to reference other resources to provide specific pieces of functionality. For example, resources may need to reference a storage account to use for storing user data, or a NIC to attach to a Network. The `Azure.ResourceManager` library defines a `ResourceIdentifier` template that allows you to easily represent references to resources in your API. The template allows you to specify one or more acceptable resource types, automatically designating the value as a resource reference, and providing the appropriate pattern validation - which helps in generating better code, better ARM templates, and better documentation for your API.\r\n\r\n```typespec\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\nscalar NetworkInterfaceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/networkInterfaces\",\r\n    },\r\n    {\r\n      type: \"Microsoft.ClassicNetwork/networkInterfaces\",\r\n    }\r\n  ]>;\r\n```\r\n\r\nThe `NetworkInterfaceId example shows how to allow multiple resource types in a reference.\n\n### Property Visibility and Other Constraints\n\nThe sample uses the `@visibility` decorator to indicate how the resource definition is used in requests to PUT and PATCH operations, and in responses to PUT, PATCH, GET, and LIST operations.\r\n\r\nThis table shows how visibility is used to determine whether a property is used in requests and responses:\r\n\r\n| Visibility           | In Create Request? | In Patch Request/ Updateable in PUT | In Responses | Sample                                         |\r\n| -------------------- | ------------------ | ----------------------------------- | ------------ | ---------------------------------------------- |\r\n| None                 | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create, update | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create         | Yes                | No                                  | Yes          | resource location                              |\r\n| read, update         | No                 | Yes                                 | Yes          | Properties only settable after creation (keys) |\r\n| create, update       | Yes                | Yes                                 | No           | Secrets (e.g. password)                        |\r\n| read                 | No                 | No                                  | Yes          | Calculated properties, e.g. provisioningState  |\r\n| update               | No                 | Yes                                 | No           | Secrets (e.g. keys)                            |\r\n| create               | Yes                | No                                  | No           | Secrets (e.g. user-defined password)           |\n\n### Modeling Arrays of Complex Types\n\nFinally, when your _rp-specific property bag_ contains an array of complex properties, there are a few important considerations:\r\n\r\n- The complex properties in an array must have a key property - this means a property named 'name' or 'id' that uniquely identifies the property in the array. The TypeSpec tools will emit a diagnostic if you omit this.\r\n- ARM resources must be fully loaded in memory, so there are limits to the size of arrays in the properties of a resource. If your array is not strictly bounded, you should consider modeling the array property as a [child resource](#child-resource)\r\n- Updating the contents of arrays can be difficult, and result in data loss under simultaneous updates, especially as Json-Merge-Patch is not widely supported in ARM update operations. If users will frequently need to update the contents of arrays, you should consider modeling as a [child resource](#child-resource).\n\n## Adding Optional Standard Envelope Properties\n\nIn addition to the resource-specific property bag, a resource may configure on or more standard ARM features through the use of standard properties in the _ARM Envelope_. Standard features configured in the envelope include:\r\n\r\n- **Managed Identity**: Associating a managed identity with the resource to authorize actions taken by this resource on other resources.\r\n- **SKU**: A standard mechanism for configuring levels of service for a resource.\r\n- **Plan**: A standard mechanism for configuring MarketPlace billing plans for a resource.\r\n- **ETags**: A standard mechanism for managing concurrent operations over the resource.\r\n- **ResourceKind**: A standard mechanism for specifying a type of user experience in the portal.\n\n### Managed Identity\n\nStandard configuration for ARM support of both SystemAssigned and UserAssigned Managed Service Identity (MSI)\r\n\r\n- If a resource allows both generated (SystemAssigned) and user-assigned (UserAssigned) Managed Identity, use the spread (...) operator to include the standard ManagedServiceIdentity envelope property. This will allow users to manage any ManagedServiceIdentity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedServiceIdentity;\r\n  }\r\n  ```\r\n\r\n- If a resource allows only generated (SystemAssigned) Managed Identity, use the spread operator (...) to include the `ManagedSystemAssignedIdentity` standard envelope property in the resource definition. This will allow users to manage the SystemAssigned identity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedSystemAssignedIdentity;\r\n  }\r\n  ```\r\n\r\nFor more information, see [Managed Service Identity Support](https://eng.ms/docs/products/arm/rpaas/msisupport)\n\n### SKU\n\nStandard support for setting a SKU-based service level for a resource. To enable SKU support, add the `ResourceSku` enevelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceSku;\r\n}\r\n```\r\n\r\nFor more information, see [SKU Support](https://eng.ms/docs/products/arm/rpaas/skusupport)\n\n### ETags\n\nIndicator that entity-tag operation concurrency support is enabled for this resource. To enable ETags, add the `EntityTag` envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...EntityTag;\r\n}\r\n```\r\n\r\nFor more information, and limitations on RPaaS concurrency support, see [RPaaS ETag Support](https://eng.ms/docs/products/arm/rpaas/etags)\n\n### Plan\n\nSupport for marketplace billing configuration for the resource. To enable `Plan` support, add the `ResourcePlan` standard envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourcePlan;\r\n}\r\n```\r\n\r\nSee [MarketPlace Third Party Billing SUpport](https://eng.ms/docs/products/arm/rpaas/custom_billing)\n\n### ResourceKind\n\nSupport for certain kinds of portal user experiences based on the kind of resource. To include 'Kind' in the resource defintion, add the `ResourceKind` standard envelope property.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceKind;\r\n}\r\n```\r\n\r\nFor more information on user experiences in the Azure Portal, see [Portal Support](https://eng.ms/docs/products/arm/rpaas/portal/gettingstarted)\n\n### ManagedBy\n\nSupport for management of this resource by other resources. To add 'ManagedBy' support to the resource, add the `ManagedBy` envelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ManagedBy;\r\n}\r\n```\r\n\r\nFor more information on supporting 'ManagedBy', see [ManagedBy API Contract](https://eng.ms/docs/products/arm/api_contracts/managedby)\n\n## Reference\n\n[Fundamentals - ARM Wiki](https://armwiki.azurewebsites.net/fundamentals/overview.html)\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n", "latency": 16.055344104766846, "response_length": 1055}
{"query": "title: How to restrict importing typespec files in main based off of versions.\n\nquestion: Hi Team,\nWe have 2 imports in our main.tsp to include other resource type tsp files, however we do not want to include one of the resourcetype to the new api version we want to introduce.  Is there a way to do conditional imports based off of version in main?\nThank you in advance!", "ground_truth": "no, you have to mark the models/types and everything that you want to remove with the `@removed` decorator using the versioning library\nif you are in preview version I think also the policy is to only have a single preview version in the spec repo at the timme now so you could also just delete it", "response": "To restrict importing TypeSpec files in your `main.tsp` based on API versions, you can use the `@versioned` decorator provided by the `@typespec/versioning` library. This allows you to define different versions of your API and conditionally include models, operations, or namespaces for specific versions. However, TypeSpec does not support conditional imports directly. Instead, you can organize your code using namespaces and version-specific decorators like `@added` to manage version-specific resources.\n\nHeres how you can achieve this:\n\n1. **Add the Versioning Library**:\n   - Install the `@typespec/versioning` library by adding it to your `package.json` and running `tsp install`.\n\n2. **Define API Versions**:\n   - Use the `@versioned` decorator to define supported versions in your `main.tsp` file:\n     ```tsp\n     import \"@typespec/versioning\";\n     using Versioning;\n\n     @versioned(Versions)\n     namespace MyAPI;\n\n     enum Versions {\n       v1: \"1.0\",\n       v2: \"2.0\",\n     }\n     ```\n\n3. **Use the `@added` Decorator**:\n   - Apply the `@added` decorator to models, operations, or namespaces to include them only in specific versions:\n     ```tsp\n     @added(Versions.v2)\n     model NewResource {\n       id: int32;\n       name: string;\n     }\n     ```\n\n4. **Organize Code by Namespace**:\n   - Place version-specific resources in separate namespaces or files and use the `@added` decorator to control their inclusion.\n\nBy following this approach, you can effectively manage version-specific resources without needing conditional imports. The TypeSpec compiler will generate separate OpenAPI specifications for each version, ensuring proper versioning and compatibility.", "context": "- document_dir: typespec_docs\n- document_filename: extending-typespec#writing-scaffolding-template.md\n- document_title: Scaffolding templates\n- document_link: https://typespec.io/docs/extending-typespec/writing-scaffolding-template\n- document_content: # extending-typespec#writing-scaffolding-template.md\n\n# Scaffolding templates\n\nTypeSpec offers a scaffolding feature through the `tsp init` command.\r\n\r\n```bash\r\ntsp init <templateUrl>\r\n```\n\n## Setting a minimum TypeSpec version\n\nIf your template requires a feature that was introduced in a later version of TypeSpec, you can specify this in the template. This will alert the user that the template may not function as expected and ask them to confirm if they wish to proceed.\r\n\r\nYou can set the `compilerVersion` in each template configuration. The value should be the minimum semver version required.\r\n\r\n```json\r\n{\r\n  \"compilerVersion\": \"0.51.0\"\r\n}\r\n```\n\n## Basics of a scaffolding template\n\nA scaffolding template is a `json` document that can be hosted either locally or online. The document's root is a dictionary, allowing for multiple templates to be hosted in the same location.\r\n\r\nEach template must include:\r\n\r\n- key: The template's key\r\n- title: A user-friendly name for the template\r\n- description: A detailed description of the template.\r\n\r\nHere's an example:\r\n\r\n```json\r\n{\r\n  \"templateKey1\": {\r\n    \"title\": \"Template #1\",\r\n    \"description\": \"Create a project representing #1\"\r\n  },\r\n  \"templateKey2\": {\r\n    \"title\": \"Template #2\",\r\n    \"description\": \"Create a project representing #2\"\r\n  }\r\n}\r\n```\n\n## Including libraries\n\nYou can include a list of TypeSpec libraries. These will be automatically added to the `package.json` and imported in `main.tsp`.\r\n\r\n```json\r\n{\r\n  \"rest\": {\r\n    \"title\": \"REST API\",\r\n    \"description\": \"Create a new project representing a REST API\",\r\n    \"libraries\": [\"/rest\", \"@typespec/openapi3\"]\r\n  }\r\n}\r\n```\n\n## Adding new files\n\nThe initializer can generate additional files (either .typespec or other types). The template includes a list of files to copy and interpolate values. Each file requires the following properties:\r\n\r\n- `path`: The absolute or relative path (relative to the template file) to the file\r\n- `destination`: The file's relative path, relative to the project root.\r\n\r\n```json\r\n{\r\n  \"rest\": {\r\n    \"title\": \"REST API\",\r\n    \"description\": \"Create a new project representing a REST API\",\r\n    \"files\": [{ \"path\": \"./models.tsp\", \"destination\": \"./models.tsp\" }]\r\n  }\r\n}\r\n```\r\n\r\nIn models.tsp\r\n\r\n```typespec\r\nmodel {{parameters.ModelName}} {\r\n\r\n}\r\n```\n\n### Interpolating values\n\nThe template can interpolate values in the files. The available values are anything in the template configuration, referenced as is. For example:\r\n\r\n- To reference a parameter, use `{{parameters.ModelName}}`\r\n- To reference the template title, use `{{title}}`\r\n\r\nAdditionally, the following values and functions are available:\r\n\r\n| Name                                  | Description                                                                       |\r\n| ------------------------------------- | --------------------------------------------------------------------------------- |\r\n| `directory`                           | The full directory path where the project should be initialized.                  |\r\n| `folderName`                          | The name of the folder where the project should be initialized.                   |\r\n| `name`                                | The name of the project.                                                          |\r\n| `libraries`                           | The list of libraries to include.                                                 |\r\n| `templateUri`                         | The path from where this template was loaded.                                     |\r\n| Functions                             |                                                                                   |\r\n| `toLowerCase(value: string)`          | Converts a string to lower case.                                                  |\r\n| `normalizePackageName(value: string)` | Normalizes the package name. It replaces `.` with `-` and converts to lower case. |\r\n| `casing.pascalCase(value: string)`    | Converts a string to PascalCase.                                                  |\r\n| `casing.camelCase(value: string)`     | Converts a string to camelCase.                                                   |\r\n| `casing.kebabCase(value: string)`     | Converts a string to kebab-case.                                                  |\n\n## Requesting additional user input\n\nWhen generating files, you may need additional input from the user, such as the model name. The template includes a map of inputs that will be prompted to the user during initialization.\r\n\r\n```json\r\n{\r\n  \"rest\": {\r\n    \"title\": \"REST API\",\r\n    \"description\": \"Create a new project representing a REST API\",\r\n    \"inputs\": {\r\n      \"modelName\": {\r\n        \"type\": \"text\",\r\n        \"description\": \"Name of the first model\"\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nSupported input types:\r\n\r\n- `text`: Requests a raw text value.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n", "latency": 16.822195291519165, "response_length": 1685}
{"query": "title: Brownfield TypeSpec migration\n\nquestion: Hi, Is there a timeframe for existing brownfield RPs to move from OpenAPI swagger to TypeSpec.  Is it possible to mix TypeSpec with handwritten swagger and migrate in phases. Say for example migrate one resource type at a time to minimize risk.", "ground_truth": "Migration to TypeSpec for existing services is not yet mandatory, but it is suggested, and teams should be planning for it in Bromine and Krypton\nServices must wholly switch to TypeSpec, there is no allowed mixing of hand-written and generated swagger\nServicesmust conform to a single, unified api-version for their service, servicesthat currently use different api-versions for parts of their service are going to need to plan for conformance -this either means SDK splitting or version uniformity.  Teams that use this 'different api-versions for different resources in the same sdk' pattern are not good candidates for conversion at the moment\nIn generally, the more compliant your service is to the RPC and best practices, the easier conversion will be\nThere is documentation on converting here: [Getting started | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started/)\nWe highly encourage you do the migration. Any problem related to https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started/, don't hesitate to reach out to me.", "response": "There is no specific timeframe mentioned for migrating existing brownfield RPs from OpenAPI Swagger to TypeSpec. However, the migration process can be done incrementally to minimize risk. You can migrate one resource type at a time, as TypeSpec allows modularization of models and operations into separate files for easier maintenance. This phased approach can help ensure smooth transitions and reduce the impact of potential issues during migration.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#lintdiff.md\n- document_title: Resolving Swagger Lint Diff Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/lintdiff\n- document_content: # migrate-swagger#faq#lintdiff.md\n\n# Resolving Swagger Lint Diff Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Resolving Swagger LintDiff Violations\n\n### `VisibilityChanged` for `nextLink` and `value` properties\n\nThe issue is that some older specifications marked these values as read only. This has no real impact on the API or client generation, but it is easy to mitigate for the whole specification. To fix, simply add the following augment decorator statements to the `main.tsp` file.\r\n\r\n```tsp\r\n@@visibility(Azure.Core.Page.value, \"read\");\r\n@@visibility(Azure.Core.Page.nextLink, \"read\");\r\n```\n\n### `ProvisioningStateMustBeReadOnly`\n\nThis violation is caused by a problem with the mechanism that ARM Api validation uses to determine if a [property is read-only. You can work around the issue by setting the `use-read-only-status-schema` configuration setting in `azure/tools/typespec-autorest` options to `true` in your `tspConfig.yaml` configuration file:\r\n\r\n```yml title=tspconfig.yaml\r\nemit:\r\n  - \"@azure-tools/typespec-autorest\"\r\noptions:\r\n  \"@azure-tools/typespec-autorest\":\r\n    use-read-only-status-schema: true\r\n```\n\n### `LroLocationHeader`\n\nThis violation occurs when your spec uses an LRO operation template that follows the older version of LRO standards. Tof fix the issue, you would change the operation template to match the latest recommendation.\r\n\r\n#### PUT Operations\r\n\r\n```tsp\r\n// LRO PUT template with required headers and no 200 response\r\nop createOrUpdate is ArmResourceCreateOrReplaceAsync<MyResource>;\r\n```\r\n\r\n#### PATCH Operations\r\n\r\n```tsp\r\n// LRO PATCH template with required headers, response codes, and lro options\r\nop update is ArmResourcePatchAsync<MyResource, MyResourceProperties>;\r\n```\n\n### POST(Action) Operations\n\n```tsp\r\n// LRO POST (Action) template with required headers, response codes, and lro options\r\nop doAction is ArmResourceActionAsync<MyResource, RequestModel, ResponseModel>;\r\n```\n\n### DELETE Operations\n\n```tsp\r\n// LRO delete template with required headers and no 200 response\r\nop delete is ArmResourceDeleteWithoutOKAsync<MyResource>;\r\n```\n", "latency": 8.801524877548218, "response_length": 451}
{"query": "title: Multi-level inheritance in TSP\n\nquestion: Hi I have this hierarchy in Model:\nJobProperties --> ChildJobProperties --> RecoveryChildJobProperties:\nBase\n![alt text](image-18.png)\nLevel1 inheritance:\n![alt text](image-19.png)\nThis yields an error, as in Level1 derived Ive set a value on the objectType discriminator field, and then setting a value again in L2 derived object.\n![alt text](image-20.png)\nIve tried a lot of variants:\n- have 2 disciminators first in base, second introduced in Level1\n- Use diff values in discriminator in all levels\n-etc\nNothing seems to work. So whats the right way for multi-level inheritance with discriminators ?", "ground_truth": "TypeSpec does not currently support multi-level inheritance with multiple discriminators, as this pattern is incompatible with its type system. Azure SDKs specifically advise against using this pattern.\nIf your goal is property reuse, consider spreading base properties instead of using inheritance. However, if you need different job types (like Job, ChildJob, and RecoveryJob), the recommended approach is to use a base model like Job that does not specify a \"kind\" and then use discriminators for the derived types like ChildJob and RecoveryJob, which would specify a kind property. This avoids the need for nested inheritance.\nNested discriminated inheritance is not supported and will not be added to TypeSpec in the near future.", "response": "To implement multi-level inheritance with discriminators in TypeSpec, you should use the `@discriminator` decorator at the base level and ensure that each derived model specifies a unique literal value for the discriminator property. This approach avoids conflicts and ensures proper mapping in OpenAPI.\n\nHeres an example:\n\n```typespec\n@discriminator(\"objectType\")\nmodel JobProperties {\n  objectType: string;\n}\n\nmodel ChildJobProperties extends JobProperties {\n  objectType: \"childJob\";\n}\n\nmodel RecoveryChildJobProperties extends ChildJobProperties {\n  objectType: \"recoveryChildJob\";\n}\n```\n\nIn this example:\n1. The `@discriminator(\"objectType\")` decorator is applied to the base model `JobProperties`.\n2. Each derived model (`ChildJobProperties` and `RecoveryChildJobProperties`) specifies a unique literal value for the `objectType` property.\n\nThis ensures that the OpenAPI emitter generates a proper discriminator mapping without errors. Avoid setting multiple discriminators at different levels or using conflicting values for the same discriminator property.", "context": "- document_dir: typespec_docs\n- document_filename: emitters#openapi3#openapi.md\n- document_title: OpenAPI v3 emitter\n- document_link: https://typespec.io/docs/emitters/openapi3/openapi\n- document_content: # emitters#openapi3#openapi.md\n\n# OpenAPI v3 emitter\n\nThe OpenAPI emitter translates TypeSpec language elements into their equivalent OpenAPI expressions. This guide explains how TypeSpec constructs are mapped to OpenAPI components.\r\n\r\n**Note**: The below documentation generally refers to the behavior of the OpenAPI v3 emitter when using OpenAPI version 3.0. Emitter output for version 3.1 may be slightly different according to additional features supported in 3.1 but not in 3.0.\n\n## Server Details\n\nWhen your TypeSpec file includes an [(HTTP) `@server` decorator](../../libraries/http/reference/decorators.md#@TypeSpec.Http.server), the OpenAPI emitter will generate a `servers` object in the resulting OpenAPI document. This object contains the server URL, description, and any variables defined in the decorator.\r\n\r\nYou can apply multiple `@server` decorators to create multiple entries in the `servers` array:\r\n\r\n```typespec\r\n@server(\"https://api.example.com/v1\", \"Primary production endpoint\")\r\n@server(\"https://api-dev.example.com/v1\", \"Development endpoint\")\r\nnamespace MyService;\r\n```\n\n## Operations\n\nEach TypeSpec operation is converted into an OpenAPI operation.\n\n### HTTP Method\n\nYou can explicitly specify the HTTP method using one of the [(HTTP) decorators][http-verb-decorators]:\r\n\r\n- `@get`\r\n- `@post`\r\n- `@put`\r\n- `@patch`\r\n- `@delete`\r\n\r\nIf you don't specify a method, the emitter will infer it from the operation name and signature.\r\n\r\n```typespec\r\n// Explicitly declared as GET /{id}\r\n@get\r\nop getUser(@path id: string): User;\r\n\r\n// Explicitly declared as POST /\r\n@post\r\nop createUser(user: User): User;\r\n\r\n// Automatically detected as GET /{id}\r\nop getUser(@path id: string): User;\r\n\r\n// Automatically detected as POST /\r\nop createUser(user: User): User;\r\n```\n\n### Operation Path\n\nThe path for an operation comes from the [(HTTP) `@route` decorator][http-route-decorator]. You can apply `@route` to:\r\n\r\n- Individual operations\r\n- Interfaces (groups of operations)\r\n- Namespaces\r\n\r\nWhen you apply routes to multiple levels, they're combined to form the complete path:\r\n\r\n```typespec\r\n@route(\"/api\")\r\nnamespace MyService {\r\n  @route(\"/users\")\r\n  interface Users {\r\n    // Results in GET /api/users/{id}\r\n    @route(\"/{id}\")\r\n    @get\r\n    getUser(@path id: string): User;\r\n  }\r\n}\r\n```\r\n\r\n[http-verb-decorators]: ../../libraries/http/reference/decorators.md\r\n[http-route-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.route\r\n\r\nThe [OpenAPI Operation object][openapi-operation-object] fields are populated as described in the following sections.\r\n\r\n[openapi-operation-object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operationObject\n\n### Description\n\nThe operation's description comes from the documentation of the TypeSpec operation.\r\n\r\nDocumentation is provided either by a documentation comment or by the [(built-in) `@doc` decorator][doc-decorator] (the two are equivalent):\r\n\r\n```typespec\r\n/**\r\n * Retrieves a user by their unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n\r\n@doc(\"Retrieves a user by their unique identifier.\")\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nIf no documentation is provided, the description field is omitted.\r\n\r\n[doc-decorator]: ../../standard-library/built-in-decorators.md#@doc\n\n### Summary\n\nThe operation's summary comes from the [(built-in) `@summary` decorator][summary-decorator]:\r\n\r\n```typespec\r\n/**\r\n * Retrieves a user by their unique identifier.\r\n */\r\n@summary(\"Get a User by ID.\")\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nIf no `@summary` is provided, the summary field is omitted.\r\n\r\n[summary-decorator]: ../../standard-library/built-in-decorators.md#@summary\n\n### Operation ID\n\nThe operation ID can be explicitly set using the [(OpenAPI) `@operationId` decorator][openapi-operation-decorator]:\r\n\r\n```typespec\r\n@operationId(\"getUserById\")\r\nop getUser(id: string): User;\r\n```\r\n\r\nIf not explicitly defined, the operation ID defaults to:\r\n\r\n- The operation name (when the operation is not in an interface)\r\n- The interface name followed by the operation name (when in an interface)\r\n\r\n[openapi-operation-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.operationId\n\n### Parameters and Request Body\n\nTypeSpec operation parameters map to OpenAPI parameters and request body.\r\n\r\n#### Parameter Location\r\n\r\nYou specify where a parameter appears using these [(HTTP) decorators][http-parameter-decorators]:\r\n\r\n- `@query` - Query parameter in the URL\r\n- `@header` - HTTP header parameter\r\n- `@path` - Path parameter in the URL\r\n\r\nParameters without these decorators are assumed to be in the request body.\r\n\r\n```typespec\r\nop createUser(\r\n  // The parameter name is transformed to look like an HTTP header, so the parameter `contentType` maps\r\n  // to the `content-type` header\r\n  @header contentType: string,\r\n\r\n  @query include: string,\r\n  @path id: string,\r\n\r\n  // The request body will be a JSON object `{ \"user\": <User> }`\r\n  user: User, // This goes in the request body\r\n): User;\r\n```\r\n\r\n#### Request Body\r\n\r\nYou can explicitly mark a parameter as the request body using the [(HTTP) `@body` decorator][http-body-decorator]:\r\n\r\n```typespec\r\n// The request body will be a JSON object that _only_ contains the User at the top level.\r\nop createUser(@body user: User): User;\r\n```\r\n\r\nIf `@body` is not used, all parameters not marked with `@header`, `@query`, or `@path` form the request body, which is marked as required. To make the request body optional, declare it with an optional property and the `@body` decorator:\r\n\r\n```typespec\r\nop updateUser(@path id: string, @body user?: User): User;\r\n```\r\n\r\n[http-parameter-decorators]: ../../libraries/http/reference/decorators.md\r\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\r\n\r\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\r\n\r\n```typespec\r\n/**\r\n * Retrieves the User by their unique identifier.\r\n *\r\n * @param id The user's unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nThe content type for request bodies follows the [default content-type resolution logic](../..\n\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\r\n\r\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\r\n\r\n```typespec\r\n/**\r\n * Retrieves the User by their unique identifier.\r\n *\r\n * @param id The user's unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nThe content type for request bodies follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\r\n\r\nFor more advanced parameter configuration, see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\n\n### Responses\n\nstatus code is 200, the body will be just a JSON User at the top level.\r\n  @body user: User;\r\n}\r\n\r\nmodel NotFound {\r\n  @statusCode code: 404;\r\n\r\n  // If the status code is 404, the body will be a JSON object `{ \"message\": <string> }`\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | NotFound;\r\n```\r\n\r\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\r\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\r\n\r\nThe content type for responses follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\r\n\r\nFor more advanced response configuration, see see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\n\nThe operation's return type(s) translate into OpenAPI responses.\r\n\r\n#### Status Codes\r\n\r\nYou can specify a status code using the [(HTTP) `@statusCode` decorator][http-statuscode-decorator] on a property in the return type:\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode\r\n  code: 200;\r\n\r\n  body: User;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse;\r\n```\r\n\r\nYou can define multiple response types to handle different status codes:\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode\r\n  code: 200;\r\n\r\n  user: User;\r\n}\r\n\r\nmodel UserNotFoundResponse {\r\n  @statusCode\r\n  code: 404;\r\n\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | UserNotFoundResponse;\r\n```\r\n\r\n#### Error Responses\r\n\r\nUse the [(built-in) `@error` decorator][error-decorator] to indicate an error response, which becomes the \"default\" response in OpenAPI. To indicate that an operation returns a successful response or an error, simply use the error response type in a union with a non-error type:\r\n\r\n```typespec\r\n@error\r\nmodel ErrorResponse {\r\n  @statusCode\r\n  code: 404 | 500;\r\n\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): User | ErrorResponse;\r\n```\r\n\r\n#### Response Body\r\n\r\nThe response body can be explicitly marked with the `@body` decorator. Otherwise, any properties not marked with `@statusCode` or `@header` form the response body.\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode code: 200;\r\n\r\n  // If the status code is 200, the body will be just a JSON User at the top level.\r\n  @body user: User;\r\n}\r\n\r\nmodel NotFound {\r\n  @statusCode code: 404;\r\n\r\n  // If the status code is 404, the body will be a JSON object `{ \"message\": <string> }`\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | NotFound;\r\n```\r\n\r\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\r\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\n\n### Tags\n\nUse the [(built-in) `@tag` decorator][tag-decorator] to apply tag groups to operations that will be represented in the generated OpenAPI and OpenAPI-based documentation tools such as Swagger UI:\r\n\r\n```typespec\r\n@tag(\"Users\")\r\nop getUser(id: string): User;\r\n\r\n// Or at interface/namespace level\r\n@tag(\"Users\")\r\ninterface UserOperations {\r\n  getUser(id: string): User;\r\n  createUser(@body user: User): User;\r\n}\r\n```\r\n\r\nTags from operations, interfaces, and enclosing namespaces are combined.\r\n\r\n[tag-decorator]: ../../standard-library/built-in-decorators.md#@tag\n\n### Deprecated\n\nMark an operation as deprecated using the (built-in) `#deprecated` directive.\r\n\r\n```typespec\r\n#deprecated \"Use getUser instead\"\r\nop fetchUser(id: string): User;\r\n```\r\n\r\nThis sets the `deprecated` field to `true` in the OpenAPI operation.\n\n### External Documentation\n\nAdd external documentation links using the [(OpenAPI) `@externalDocs` decorator](../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.externalDocs):\r\n\r\n```typespec\r\n@externalDocs(\"https://example.com/docs/users\", \"Additional user documentation\")\r\nop getUser(id: string): User;\r\n```\r\n\r\nThe external documentation links are specific to the OpenAPI emitter and will not be used by any other emitters unless they are designed to interoperate with OpenAPI.\n\n### Specification Extensions\n\nAdd custom OpenAPI extensions for your use cases using the [(OpenAPI) `@extension` decorator][openapi-extension-decorator].\r\n\r\n```typespec\r\n@extension(\"x-ms-pageable\", #{ nextLinkName: \"nextLink\" })\r\nop listUsers(): UserList;\r\n```\r\n\r\nThe first argument to `@extension` becomes a key in the operation object, and the second argument is any JSON/YAML-like value. This decorator may be used to add arbitrary customization/extension to many OpenAPI constructs including schemas for TypeSpec types, operations, etc.\r\n\r\n[openapi-extension-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.extension\n\n## Models and Enums\n\nTypeSpec models and enums convert to OpenAPI schemas.\n\n### Schema Location\n\nModels are handled differently based on how they're defined:\r\n\r\n- **Named models**: defined in `components/schemas` section.\r\n- **Inline models**: defined inline where used.\r\n- **Template instances**: treated as inline unless they have a [(built-in) `@friendlyName` decorator][friendlyname], which causes them to be treated as named models.\r\n\r\n[friendlyname]: ../../standard-library/built-in-decorators.md#@friendlyName\n\n### Type Mapping\n\nThis table shows how TypeSpec types map to OpenAPI/JSON Schema types:\r\n\r\n| TypeSpec type    | OpenAPI `type`/`format`           | Notes                                                                     |\r\n| ---------------- | --------------------------------- | ------------------------------------------------------------------------- |\r\n| `int32`          | `type: integer, format: int32`    |                                                                           |\r\n| `int64`          | `type: integer, format: int64`    |                                                                           |\r\n| `float32`        | `type: number, format: float`     |                                                                           |\r\n| `float64`        | `type: number, format: double`    |                                                                           |\r\n| `string`         | `type: string`                    |                                                                           |\r\n| `bytes`          | `type: string, format: byte`      | for content-type == 'application/json' or 'text/plain'                    |\r\n| `bytes`          | `type: string, format: binary`    | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `boolean`        | `type: boolean`                   |                                                                           |\r\n| `plainDate`      | `type: string, format: date`      |                                                                           |\r\n| `utcDateTime`    | `type: string, format: date-time` | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `offsetDateTime` | `type: string, format: date-time` | RFC 3339 date with timezone offset                                        |\n\n### Data Validation Decorators\n\nThe tables below show how various built-in decorators add validation constraints to model properties:\r\n\r\n**For numeric types:**\r\n\r\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Example                      |\r\n| ------------------ | -------- | --------------------------- | ---------------------------- |\r\n| `@minValue(value)` | built-in | `minimum: value`            | `@minValue(0) age: int32;`   |\r\n| `@maxValue(value)` | built-in | `maximum: value`            | `@maxValue(120) age: int32;` |\r\n\r\n**For string types:**\r\n\r\n| Decorator           | Library  | OpenAPI/JSON Schema keyword | Example                                 |\r\n| ------------------- | -------- | --------------------------- | --------------------------------------- |\r\n| `@format(name)`     | built-in | `format: name`              | `@format(\"email\") email: string;`       |\r\n| `@minLength(value)` | built-in | `minLength: value`          | `@minLength(8) password: string;`       |\r\n| `@maxLength(value)` | built-in | `maxLength: value`          | `@maxLength(50) name: string;`          |\r\n| `@pattern(regex)`   | built-in | `pattern: regex`            | `@pattern(\"^[A-Z]{2}$\") state: string;` |\r\n| `@secret`           | built-in | `format: password`          | `@secret password: string;`             |\r\n\r\n**For array types:**\r\n\r\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Example                         |\r\n| ------------------ | -------- | --------------------------- | ------------------------------- |\r\n| `@minItems(value)` | built-in | `minItems: value`           | `@minItems(1) tags: string[];`  |\r\n| `@maxItems(value)` | built-in | `maxItems: value`           | `@maxItems(10) tags: string[];` |\n\n### Using External References\n\nThe [`@useRef` decorator](./reference/decorators.md#@TypeSpec.OpenAPI.useRef) configures a TypeSpec model with a reference to an external schema that will be used in place of references to that model's schema:\r\n\r\n```typespec\r\n// Whenever the OpenAPI emitter would try to reference the Sku model's schema, it will reference the below\r\n// external schema instead.\r\n@useRef(\"common.json#/components/schemas/Sku\")\r\nmodel Sku {\r\n  name: string;\r\n  tier: string;\r\n}\r\n```\n\n### Enums\n\nTypeSpec enums and unions convert to OpenAPI enum schemas. You can define enums in two ways:\r\n\r\n**TypeSpec enum declaration:**\r\n\r\n```typespec\r\nenum Color {\r\n  Red: \"red\",\r\n  Blue: \"blue\",\r\n  Green: \"green\",\r\n}\r\n```\r\n\r\n**Union of literal values:**\r\n\r\n```typespec\r\nmodel Settings {\r\n  // `status` can be any of the following strings.\r\n  status: \"Running\" | \"Stopped\" | \"Failed\";\r\n}\r\n```\r\n\r\nBoth approaches result in an OpenAPI schema with a type of `string` and an `enum` array containing the specified values.\n\n## Model Composition\n\nTypeSpec offers several ways to compose models.\n\n### Spread Operator\n\nThe spread operator copies properties from one model to another without creating a semantic relationship:\r\n\r\n```typespec\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n  state: string;\r\n}\r\n\r\nmodel UserProfile {\r\n  name: string;\r\n\r\n  // Copy all the properties of Address into this model as if they were declared here.\r\n  ...Address;\r\n\r\n  email: string;\r\n}\r\n```\r\n\r\nIn OpenAPI, the result is a flat schema named `UserProfile` with the properties of `Address` declared inline.\n\n### Extends Keyword\n\nThe `extends` keyword creates an inheritance relationship:\r\n\r\n```typespec\r\nmodel Pet {\r\n  name: string;\r\n  age: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  breed: string;\r\n}\r\n```\r\n\r\nIn OpenAPI, this creates a schema `Dog` that references the schema `Pet` using `allOf`.\r\n\r\n#### Discriminated Union with Extends\r\n\r\nYou can create discriminated type hierarchies using the `@discriminator` decorator:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  kind: \"dog\"; // Must be a literal string value\r\n  breed: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  kind: \"cat\"; // Must be a literal string value\r\n  whiskerCount: int32;\r\n}\r\n```\r\n\r\nThis creates a discriminator object in the OpenAPI schema with a mapping from discriminator values to schemas.\n\n### Is Keyword\n\nThe `is` keyword creates a new model with the same shape as another model:\r\n\r\n```typespec\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n}\r\n\r\nmodel ShippingDetails is Address {\r\n  zipCode: string; // Additional property\r\n}\r\n```\r\n\r\nIn OpenAPI, `ShippingDetails` is an independent schema with all properties from `Address` plus `zipCode`.\n\n### Unions\n\nUnions represent values that could be one of several types:\r\n\r\n**Union type alias:**\r\n\r\n```typespec\r\nalias PetType = Dog | Cat | Hamster;\r\n```\r\n\r\n**Named union declaration:**\r\n\r\n```typespec\r\nunion PetType {\r\n  dog: Dog,\r\n  cat: Cat,\r\n  hamster: Hamster,\r\n}\r\n```\r\n\r\nBy default, unions emit as `anyOf` in OpenAPI. You can use the [`@oneOf` decorator](./reference/decorators.md#@TypeSpec.OpenAPI.oneOf) on a named union declaration to emit it as `oneOf` instead:\r\n\r\n```typespec\r\n@oneOf\r\nunion PetType {\r\n  dog: Dog,\r\n  cat: Cat,\r\n  hamster: Hamster,\r\n}\r\n```\n\n## Encoding and Formats\n\nThe `@encode` decorator lets you control how TypeSpec types are serialized. The general pattern is:\r\n\r\n```typespec\r\n@encode(\"<encoding name>\", encodingTargetType) property: trueType;\r\n```\r\n\r\nWhere:\r\n\r\n- `\"<encoding name>\"`: The format or method of encoding (e.g., `\"base64\"`, `\"rfc3339\"`, `\"unixTimestamp\"`)\r\n- `encodingTargetType`: The type to encode to and decode from (e.g., `int32`, `string`)\r\n- `trueType`: The \"true\" semantic data type of the property (e.g., `duration`, `utcDateTime`)\r\n\r\nThe emitter follows these rules to determine the OpenAPI format:\r\n\r\n1. For date/time types:\r\n\r\n   - `@encode(\"rfc3339\", string) _: utcDateTime`  `type: string, format: date-time`\r\n   - `@encode(\"rfc7231\", string) _: utcDateTime`  `type: string, format: http-date`\r\n   - `@encode(\"unixTimestamp\", int32) _: utcDateTime`  `type: integer, format: unixtime`\r\n\r\n2. For other types, the format comes from either the encoding name or the `encodingTargetType`'s format.\r\n\r\nThis table summarizes common encodings:\r\n\r\n| TypeSpec with encoding                           | OpenAPI 3 result                  |\r\n| ------------------------------------------------ | --------------------------------- |\r\n| `@encode(\"seconds\", int32) _: duration`          | `type: integer, format: int32`    |\r\n| `@encode(\"ISO8601\") _: duration`                 | `type: number, format: duration`  |\r\n| `@encode(\"unixTimestamp\", int64) _: utcDateTime` | `type: integer, format: unixtime` |\r\n| `@encode(\"rfc3339\") _: utcDateTime`              | `type: string, format: date-time` |\n\n## Security Definitions\n\nUse the [(HTTP) `@useAuth` decorator][http-useauth-decorator] to define authentication and security schemes for your API.\r\n\r\nFor example, to define an authentication/authorization scheme based on Microsoft Entra ID:\r\n\r\n```typespec\r\n@useAuth(EntraIDToken)\r\nnamespace Contoso.WidgetManager;\r\n\r\n/** Microsoft Entra ID OAuth2 Flow */\r\nmodel EntraIDToken\r\n  is OAuth2Auth<[\r\n    {\r\n      type: OAuth2FlowType.authorizationCode;\r\n      authorizationUrl: \"https://api.example.com/oauth2/authorize\";\r\n      tokenUrl: \"https://api.example.com/oauth2/token\";\r\n      scopes: [\"https://management.azure.com/read\", \"https://management.azure.com/write\"];\r\n    }\r\n  ]>;\r\n```\r\n\r\nAuthentication/authorization is a complex and highly configurable feature. See the [`@useAuth` decorator documentation for more information][http-useauth-decorator].\r\n\r\n[http-useauth-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.useAuth\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#07types.mdx\n- document_title: Generated Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/07types\n- document_content: # howtos#generate-client-libraries#07types.mdx\n\n# Generated Types\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents what type definitions in TypeSpec are generated as in emitted libraries\n\n## Namespace\n\nThe namespace for models, enums, and unions will follow the namespace they belong to. You can use `@clientNamespace` to override it if needed.\n\n### Model in namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in sub namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nnamespace Container {\r\n  model Foo {\r\n    prop: string;\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in namespace with renaming\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\n@clientNamespace(\"Service.Container\")\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Client Documentation\n\nThe `@clientDoc` decorator lets you add documentation that will appear in generated client libraries. This is useful for providing additional context, examples, or implementation notes that are only relevant for SDK consumers.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@doc(\"This internal model is the base class for shapes\")\r\n@clientDoc(\r\n  \"Base class for all shape objects that can be drawn on a canvas\",\r\n  DocumentationMode.replace\r\n)\r\nmodel Shape {\r\n  @doc(\"The coordinates of the shape\")\r\n  @clientDoc(\r\n    \"The x,y coordinates where the shape will be positioned on the canvas\",\r\n    DocumentationMode.replace\r\n  )\r\n  position: Point;\r\n}\r\n\r\n@doc(\"A two-dimensional point\")\r\n@clientDoc(\"Represents a position in a 2D coordinate system\", DocumentationMode.replace)\r\nmodel Point {\r\n  @doc(\"X coordinate\")\r\n  @clientDoc(\"The horizontal position (increases moving right)\", DocumentationMode.replace)\r\n  x: float32;\r\n\r\n  @doc(\"Y coordinate\")\r\n  @clientDoc(\"The vertical position (increases moving down)\", DocumentationMode.replace)\r\n  y: float32;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nclass Point(_model_base.Model):\r\n    \"\"\"Represents a position in a 2D coordinate system.\r\n\r\n    :param x: The horizontal position (increases moving right)\r\n    :type x: float\r\n    :param y: The vertical position (increases moving down)\r\n    :type y: float\r\n    \"\"\"\r\n\r\n    x: float = rest_field()\r\n    \"\"\"The horizontal position (increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\n\non the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\r\n     * The x,y coordinates where the shape will be positioned on the canvas.\r\n     */\r\n    private Point position;\r\n\r\n    /**\r\n     * Get the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @return the position value.\r\n     */\r\n    public Point getPosition() {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Set the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @param position the position value to set.\r\n     * @return the Shape object itself.\r\n     */\r\n    public Shape setPosition(Point position) {\r\n        this.position = position;\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system.\r\n */\r\n@Fluent\r\npublic final class Point {\r\n    /**\r\n     * The horizontal position (increases moving right).\r\n     */\r\n    private float x;\r\n\r\n    /**\r\n     * The vertical position (increases moving down).\r\n     */\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\n\n*/\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get the y property: The vertical position (increases moving down).\r\n     *\r\n     * @return the y value.\r\n     */\r\n    public float getY() {\r\n        return this.y;\r\n    }\r\n\r\n    /**\r\n     * Set the y property: The vertical position (increases moving down).\r\n     *\r\n     * @param y the y value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setY(float y) {\r\n        this.y = y;\r\n        return this;\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// Shape - Base class for all shape objects that can be drawn on a canvas\r\ntype Shape struct {\r\n\t// Position - The x,y coordinates where the shape will be positioned on the canvas\r\n\tPosition *Point\r\n}\r\n\r\n// Point - Represents a position in a 2D coordinate system\r\ntype Point struct {\r\n\t// X - The horizontal position (increases moving right)\r\n\tX *float32\r\n\r\n\t// Y - The vertical position (increases moving down)\r\n\tY *float32\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nThe `@clientDoc` decorator can be used on everything that the `@doc` decorator can be applied to.\r\n\r\nWhen both `@doc` and `@clientDoc` are present, TCGC outputs the final documentation depending on the mode that you called `@clientDoc` with.\r\nIf called with `replace`, `@clientDoc` replaces `@doc` completely. If called with `append`, `@clientDoc` is appended onto `@doc`.\n\n(increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n/// <summary>\r\n/// Base class for all shape objects that can be drawn on a canvas\r\n/// </summary>\r\npublic partial class Shape\r\n{\r\n    /// <summary>\r\n    /// The x,y coordinates where the shape will be positioned on the canvas\r\n    /// </summary>\r\n    public Point Position { get; set; }\r\n}\r\n\r\n/// <summary>\r\n/// Represents a position in a 2D coordinate system\r\n/// </summary>\r\npublic partial class Point\r\n{\r\n    /// <summary>\r\n    /// The horizontal position (increases moving right)\r\n    /// </summary>\r\n    public float X { get; set; }\r\n\r\n    /// <summary>\r\n    /// The vertical position (increases moving down)\r\n    /// </summary>\r\n    public float Y { get; set; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas\r\n */\r\nexport interface Shape {\r\n  /**\r\n   * The x,y coordinates where the shape will be positioned on the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\n\n## Models\n\n### Flattening\n\n:::caution\r\nFlattening is NOT a recommended pattern, and you shouldn't use it unless told by SDK architects.\r\n:::\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Properties {\r\n  name: string;\r\n}\r\n\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Properties;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"prop\",\r\n      \"serializedName\": \"prop\",\r\n      \"flatten\": true,\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"model\",\r\n        \"name\": \"Properties\",\r\n        \"properties\": [\r\n          {\r\n            \"kind\": \"property\",\r\n            \"name\": \"name\",\r\n            \"serializedName\": \"name\",\r\n            \"flatten\": false,\r\n            \"optional\": false,\r\n            \"type\": {\r\n              \"kind\": \"string\",\r\n              \"encode\": \"string\"\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will do dynamic flattening, exposing the non-flattening syntax, and dynamically accepting the flattened access.\r\n\r\n```python\r\nclass Properties(_model_base.Model):\r\n    name: str = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\nclass Foo(_model_base.Model):\r\n    properties: \"_models.Properties\" = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\n    __flattened_items = [\"properties\"]\r\n\r\nprint(f.properties.name)  # Non-flattened access is preferred experience\r\nprint(f.name)  # Flattened access is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\n\nreturn null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\r\n                    if (property0.NameEquals(\"name\"u8))\r\n                    {\r\n                        name = property0.Value.GetString();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Foo(name);\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// Please note that this feature is not supported right now, and the model will be generated un-flattened.\r\n// Please comment and follow work status on: https://github.com/Azure/autorest.typescript/issues/2164\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nIn Java, `@flattenProperty` have no effect on generated libraries.\r\n\r\n```java\r\n@Fluent\r\npublic final class Properties {\r\n    public Properties();\r\n    public String getName();\r\n    public Properties setName(String name);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\naccess is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\r\n\r\npublic partial class Foo : IUtf8JsonSerializable, IJsonModel<Foo>\r\n{\r\n    void IJsonModel<Foo>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\r\n    {\r\n        var format = options.Format == \"W\" ? ((IPersistableModel<Foo>)this).GetFormatFromOptions(options) : options.Format;\r\n        if (format != \"J\")\r\n        {\r\n            throw new FormatException($\"The model {nameof(Foo)} does not support writing '{format}' format.\");\r\n        }\r\n\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"properties\"u8);\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"name\"u8);\r\n        writer.WriteStringValue(Name);\r\n        writer.WriteEndObject();\r\n        writer.WriteEndObject();\r\n    }\r\n\r\n    internal static Foo DeserializeFoo(JsonElement element, ModelReaderWriterOptions options = null)\r\n    {\r\n        options ??= ModelSerializationExtensions.WireOptions;\r\n\r\n        if (element.ValueKind == JsonValueKind.Null)\r\n        {\r\n            return null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\n\n### Models with additional properties\n\n#### Additional properties of any type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nRecommend usage:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<unknown>;\r\n}\r\n```\r\n\r\nOther usages:\r\n\r\n```typespec\r\nmodel Animal extends Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal is Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"any\"\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\n\npublic IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, BinaryData> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, BinaryData> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of nullable type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | null>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\n\n[\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\r\n    \"properties\": [\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"category\",\r\n        \"serializedName\": \"category\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      },\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"value\",\r\n        \"serializedName\": \"value\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"any\"\r\n        }\r\n      }\r\n    ],\r\n    \"additionalProperties\": undefined\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom typing import Any\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nclass AnimalProperty(_model_base.Model):\r\n\r\n    category: str = rest_field()\r\n    value: Any = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...\n\nAnimal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for both legacy and non legacy\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, Object> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, Object> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of specific type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\n\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\n\ncategory: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for non-legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal {\r\n  name: string;\r\n  kind: string;\r\n  additionalProperties: Record<string, AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, AnimalProperty> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, AnimalProperty> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of union type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | int32>;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n  ...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\n\n...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"union\",\r\n    \"name\": \"AnimalAdditionalProperty\",\r\n    \"generatedName\": true,\r\n    \"values\": [\r\n      {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      },\r\n      {\r\n        \"kind\": \"int32\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\n\nfalse,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"alert\"] = None\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, String> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, String> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n= AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\nThe `C#` generated code is the same as if the type is `unknown`:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\nFor typespec with additional properties of primitive types:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n}\r\n```\r\n\r\nThe `C#` generated code still has the specified type in `AdditionalProperties` property:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\n\n### Discriminator\n\nSiamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\r\nexport interface CatOutputParent {\r\n  kind: string;\r\n}\r\n\r\nexport interface SiameseOutput extends CatOutputParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface RagdollOutput extends CatOutputParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type CatOutput = CatOutputParent | SiameseOutput | RagdollOutput;\r\n\r\n// Modular models\r\n/** model interface Cat */\r\nexport interface Cat {\r\n  kind: string;\r\n}\r\n\r\n/** Alias for CatUnion */\r\nexport type CatUnion = Siamese | Ragdoll | Cat;\r\n\r\n/** model interface Siamese */\r\nexport interface Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n/** model interface Ragdoll */\r\nexport interface Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic class Cat implements JsonSerializable<Cat> {\r\n    public Cat();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Ragdoll extends Cat {\r\n    public Ragdoll();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Siamese extends Cat {\r\n    public Siamese();\r\n    public String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\n\n\"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      // the same instance of the model Siamese as we have above in `discriminatedSubtype` property\r\n    },\r\n    {\r\n      // the same instance of the model Ragdoll as we have above in `discriminatedSubtype` property\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_discriminator, rest_field\r\n\r\nclass Cat(_model_base.Model):\r\n    kind: str = rest_discriminator(name=\"kind\")\r\n\r\nclass Siamese(Cat):\r\n    kind: Literal[\"siamese\"] = rest_discriminator(name=\"kind\")\r\n\r\nclass Ragdoll(Cat):\r\n    kind: Literal[\"ragdoll\"] = rest_discriminator(name=\"kind\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nIn .Net generated code, the discriminator property will be generated as internal by default, but configurable to be public.\r\n\r\n```csharp\r\npublic abstract partial class Cat\r\n{\r\n  protected Cat()\r\n  {\r\n  }\r\n\r\n  internal string Kind { get; set; }\r\n}\r\n\r\npublic partial class Siamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\n\nTypeSpec uses `@discriminator` decorator to add a discriminator to a model.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nTypeSpec now has two ways to represent a discriminated set.\r\n\r\n1. Use model\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: string;\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\nThe type of the discriminator property could be an enum (extensible or fixed):\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: CatKind;\r\n}\r\n\r\nunion CatKind {\r\n  string,\r\n  Siamese: \"siamese\",\r\n  Ragdoll: \"ragdoll\",\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: CatKind.Siamese;\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: CatKind.Ragdoll;\r\n}\r\n```\r\n\r\n2. Use union\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nunion Cat {\r\n  Siamese,\r\n  Ragdoll,\r\n}\r\n\r\nmodel Siamese {}\r\n\r\nmodel Ragdoll {}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nTCGC currently only supports the discriminated set based on models, discriminated union is not supported yet.\r\n\r\nThis is a brief structure of the models in a discriminated set in the output of TCGC.\r\n\r\n```json\r\n{\r\n  \"models\": [\r\n    {\r\n      \"kind\": \"model\",\r\n      \"name\": \"Cat\",\r\n      \"properties\": [\r\n        {\r\n          \"kind\": \"property\",\r\n          \"name\": \"kind\",\r\n          \"type\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"discriminator\": true\r\n        }\r\n      ],\r\n      \"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\n\npublic String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Cat.\r\nfunc (c *Cat) GetCat() *Cat { return c }\r\n\r\ntype Ragdoll struct {\r\n\t// CONSTANT; undefinedField has constant value \"ragdoll\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Ragdoll.\r\nfunc (e *Ragdoll) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n\r\ntype Siamese struct {\r\n\t// CONSTANT; undefinedField has constant value \"siamese\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Siamese.\r\nfunc (e *Siamese) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Nullable\n\n\"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"union\",\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Bar\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"string\",\r\n                    \"encode\": \"string\"\r\n                  }\r\n                }\r\n              ]\r\n            },\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Baz\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"int32\",\r\n                    \"encode\": \"int32\"\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\n\nTypeSpec uses `| null` to represent nullable types. Nullability is handled differently in languages, but emitter authors will find information\r\nabout nullability by inspecting the type of a property.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Foo {\r\n  basicNullableProperty: string | null;\r\n  modelNullableProperty: Bar | null;\r\n  unionNullableProperty: Bar | Baz | null;\r\n  enumNullableProperty: LR | null;\r\n}\r\n\r\nmodel Bar {\r\n  prop: string;\r\n}\r\n\r\nmodel Baz {\r\n  prop: int32;\r\n}\r\n\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nA nullable type has kind `nullable` and property `valueType`. The kind of the type tells you the property is nullable, while the `valueType` tells you the underlying type you want to generate.\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"basicNullableProperty\",\r\n      \"serializedName\": \"basicNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"modelNullableProperty\",\r\n      \"serializedName\": \"modelNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Bar\",\r\n          \"properties\": [\r\n            {\r\n              \"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\n\n}\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"left\",\r\n              \"value\": \"left\"\r\n            },\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"right\",\r\n              \"value\": \"right\"\r\n            }\r\n          ],\r\n          \"isFixed\": true,\r\n          \"isUnionAsEnum\": false\r\n        }\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython treat nullable as optional. If you actually want to send the value `null` to the service without the property being ignored, you can send in `corehttp.serialization.NULL`. Python does not restrict you from setting any property to this value.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Bar(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass Baz(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n\r\nclass Foo(_model_base.Model):\r\n  basicNullableProperty: Optional[str] = rest_field()\r\n  modelNullableProperty: Optional[\"_models.Bar\"] = rest_field()\r\n  unionNullableProperty: Optional[Union[\"_models.Bar\", \"_models.Baz\"]] = rest_field()\r\n  enumNullableProperty: Optional[\"LR\"] = rest_field()\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Unions\n\n### Union of literals with same type\n\nAll emitters will generate their version of a closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enum by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\nSerialization/deserialization will respect the value defined, in this case it is \"left\" for `LR.Left` and \"right\" for `LR.Right` respectively.\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of literals with same type\n\nThis is union defined inline at point of usage.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetHorizontals\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates this as a union of literals, not as enum. We also don't generate a closed set of literals.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  horizontal: Union[Literal[\"left\"] | Literal[\"right\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetHorizontal Horizontal;\r\n}\r\npublic enum WidgetHorizontal\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetHorizontal {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of basic type and literals of that type\n\nEach language will generate their version of an open enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion Colors {\r\n  string,\r\n  red: \"red\",\r\n  blue: \"blue\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Colors\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates open enum again here.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Colors(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  RED = \"red\"\r\n  BLUE = \"blue\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct Colors : IEquatable<Colors>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static Colors Red { get; } = new Colors(RedValue);\r\n  public static Colors Blue { get; } = new Colors(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Colors = string | \"red\" | \"blue\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Colors extends ExpandableStringEnum<Colors> {\r\n    public static final Colors RED = fromString(\"red\");\r\n    public static final Colors BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of basic type and literals of that type\n\nThis is union defined inline at point of usage which include the base type as an option.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetColors\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a union of literals again.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  color: Union[Literal[\"red\"] | Literal[\"blue\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetColor Color;\r\n}\r\npublic readonly partial struct WidgetColor : IEquatable<WidgetColor>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static WidgetColor Red { get; } = new WidgetColor(RedValue);\r\n  public static WidgetColor Blue { get; } = new WidgetColor(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class WidgetColor extends ExpandableStringEnum<Colors> {\r\n    public static final Color RED = fromString(\"red\");\r\n    public static final Color BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of other union/enum, basic type and literals of that type\n\n\"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a single open enum.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass ProvisioningState(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  INPROGRESS = \"InProgress\"\r\n  SUCCEEDED = \"Succeeded\"\r\n  FAILED = \"Failed\"\r\n  CANCELED = \"Canceled\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct ProvisioningState : IEquatable<ProvisioningState>\r\n{\r\n  private const string SucceededValue = \"Succeeded\";\r\n  private const string FailedValue = \"Failed\";\r\n  private const string CanceledValue = \"Canceled\";\r\n  private const string InProgressValue = \"InProgress\";\r\n\r\n  public static ProvisioningState Succeeded { get; } = new ProvisioningState(SucceededValue);\r\n  public static ProvisioningState Failed { get; } = new ProvisioningState(FailedValue);\r\n  public static ProvisioningState Canceled { get; } = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n} = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class ProvisioningState extends ExpandableStringEnum<ProvisioningState> {\r\n    public static final ProvisioningState INPROGRESS = fromString(\"InProgress\");\r\n    public static final ProvisioningState SUCCEEDED = fromString(\"Succeeded\");\r\n    public static final ProvisioningState FAILED = fromString(\"Failed\");\r\n    public static final ProvisioningState CANCELED = fromString(\"Canceled\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-resource-manager\";\r\n\r\nunion ProvisioningState {\r\n  string,\r\n  \"InProgress\",\r\n  Azure.ResourceManager.ResourceProvisioningState,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"InProgress\",\r\n      \"value\": \"InProgress\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Succeeded\",\r\n      \"value\": \"Succeeded\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Failed\",\r\n      \"value\": \"Failed\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Canceled\",\r\n      \"value\": \"Canceled\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"string\"\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"InProgress\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"ResourceProvisioningState\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\n\n### Union of other unions of literals with same type\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nunion Orientation {\r\n  LR,\r\n  UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\n\ntrue,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\nexport type Orientation = LR | UD;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of other unions of literals with same type\n\n],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nSince this is inline, Python will generate this as a single union of all possible literal values.\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype WidgetOrientation = \"left\" | \"right\" | \"up\" | \"down\" | str\r\n\r\nmodel Widget:\r\n  orientation: WidgetOrientation\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetOrientation Orientation;\r\n}\r\npublic enum WidgetOrientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  orientation: LR | UD;\r\n}\r\n\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetOrientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nmodel Widget {\r\n  orientation: LR | UD;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\n\n### Union with multiple types\n\nThese are unions where the values don't share same type.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Shirt {\r\n  sizing: 32 | 34 | int32 | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ShirtSizings\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 32,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 34,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"small\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"medium\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"string\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will generate this as a union since these entries don't share the same type\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype ShirtSizing = Literal[32] | Literal[34] | int | Literal[\"small\"] | Literal[\"medium\"] | str\r\n\r\nmodel Shirt:\r\n  sizing: ShirtSizing\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Shirt\r\n{\r\n  public BinaryData Shirt;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Shirt {\r\n  sizing: 32 | 34 | number | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Shirt {\r\n    private BinaryData sizing;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Enums\n\n### Standard\n\nStandard enums will be generated as closed enums.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enums by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Versioning Enums\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@versioned(Versions)\r\n@service\r\nnamespace Service;\r\n\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Versions\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v1\",\r\n      \"value\": \"v1\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v2\",\r\n      \"value\": \"v2\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false,\r\n  \"usage\": 8\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```\n\n# Python does not generate the enum used for versioning\n\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// CSharp does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// JS does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V1(\"v1\"),\r\n    V2(\"v2\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Spread\n\nSpreading enums will return the resultant enum as a new single closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n\r\nenum UD {\r\n  up,\r\n  down,\r\n}\r\n\r\nenum Orientation {\r\n  ...LR,\r\n  ...UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates one open enum, because Python never generates an enum as fully closed.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Orientation = \"left\" | \"right\" | \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Scalars\n\n### Encoding\n\nWe will take the `@encode` decorator into account, determining how we serialize inputted scalars to send over the wire.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(DateTimeKnownEncoding.rfc3339)\r\n  prop: utcDateTime;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"utcDateTime\",\r\n    \"encode\": \"rfc3339\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"rfc3339\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// Internal implementation\r\nutf8JsonWriter.WriteStringValue(Prop.ToString());\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\",\r\n    this.value == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.value));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nWhen you specify an encoding type, say that you want to encode an integer as a string, that will also be represented in our generated SDKs.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(string)\r\n  prop: int64;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n\"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\", Objects.toString(this.value, null));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n", "latency": 12.654181957244873, "response_length": 1065}
{"query": "title: Customize path parameter\n\nquestion: Use this Employee example, the only change I made is adding a path parameter to listByResourceGroup like\n```\nlistByResourceGroup is ArmResourceListByParent<Employee,\nParameters = {\n/** doc */\n@path\n@segment(\"locations\")\nlocation: string;\n}>;\n```\nNow you will see the route becomes /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContosoProviderHub/locations/{location}/employees\nPlease correct me if I'm wrong:\nI assume the resource type for this route is Microsoft.ContosoProviderHub/locations/employees, which is different from the other operations, whose resource type is Microsoft.ContosoProviderHub/employees\nI assume getArmResources will return all of the operations including listByResourceGroup for resource model Employee right? Something like\n```\noperations:\n- resourceType: \"Microsoft.ContosoProviderHub/employees\"\noperations: [get, update, delete, ...]\n- resourceType: \"Microsoft.ContosoProviderHub/locations/employees\"\noperations: [listByResourceGroup]\n```\nIf that is the case, we implicitly add a new resource with another resource type, I feel like that not what TypeSpec should do.\nCurrently, .net SDK's behavior (swagger input) is listByResourceGroup operation doesn't belongs to Employee resource model.", "ground_truth": "The issue reported arises from the current behavior in Swagger, where resource relationships are determined by \"guessing\" based on route lengths. The goal with TypeSpec is to allow explicit user input to define resource hierarchies, thus avoiding the guessing mechanism. The specific problem involves an operation that doesn't clearly fit into any resource model, and it's being speculated as a resource operation when it could be more like a list resource operation.\nTo resolve this, the user is asking for getArmResources (or resolveAzureResources) to retrieve the explicit resource information from the user, allowing the system to better understand and handle the relationships between resources and operations.\nAn issue has been opened on GitHub to address this need, which you can track [here](https://github.com/Azure/typespec-azure/issues/2043).", "response": "Your assumptions and concerns are valid. By adding a path parameter `location` to the `listByResourceGroup` operation, the route `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContosoProviderHub/locations/{location}/employees` indeed implies a new resource type `Microsoft.ContosoProviderHub/locations/employees`. This is distinct from the original resource type `Microsoft.ContosoProviderHub/employees`.\n\nIn TypeSpec, operations like `listByResourceGroup` are tied to the resource model they operate on. However, introducing a new path parameter like `location` effectively creates a new hierarchical resource type. This can lead to the implicit creation of a new resource type, which might not align with the intended design of your API.\n\nRegarding `getArmResources`, it would list all operations, including `listByResourceGroup`, for the `Employee` resource model. However, the `listByResourceGroup` operation would now be associated with the new resource type `Microsoft.ContosoProviderHub/locations/employees`.\n\nIf the intent is not to create a new resource type but to filter employees by location, consider using a query parameter instead of a path parameter. This approach avoids introducing a new resource type and keeps the `listByResourceGroup` operation consistent with the original `Employee` resource model.", "context": "- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-resource-manager#step02.md\n- document_title: 3. Defining the Resources\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step02\n- document_content: # getstarted#azure-resource-manager#step02.md\n\n# 3. Defining the Resources\n\nAn ARM resource provider is composed of resources. The TypeSpec Azure Resource Manager library makes it much easier to define the structure and endpoints of such resources.\r\n\r\nThere are three essential components of a resource defined with TypeSpec:\r\n\r\n- A model type representing the resource, derived from one of the [base resource types](#base-resource-types)\r\n- A model type defining the properties of the resource type\r\n- An interface that defines the operations that can be performed on the resource type, usually a combination of [recommended and required Operations](../../howtos/ARM/resource-operations.md#recommended-and-required-operations) and [resource actions](../../howtos/ARM/resource-operations.md#resource-actions-post)\r\n\r\n> Read the [TypeSpec tutorial](https://github.com/Microsoft/typespec/blob/main/docs/tutorial.md) to learn the basics about TypeSpec model types and interfaces.\n\n## 1. **Define a model representing the `properties` of the ARM resource**\n\nEach resource type must have a properties type which defines its custom properties. This type will be exposed as the `properties` property of the resource type.\r\n\r\n```typespec\r\n/** The properties of User */\r\nmodel UserProperties {\r\n  /** The user's full name */\r\n  fullName: string;\r\n\r\n  /** The user's email address */\r\n  emailAddress: string;\r\n}\r\n```\n\n## 2. **Define a model representing the resource type**\n\nResource types are defined as plain models which pull in a standard resource type using the `is` keyword.\r\n\r\nYou define a resource type, you need the following:\r\n\r\n- A property model type which defines the resource type's custom properties as we described in step 1\r\n- A `name` parameter definition. You should use `ResourceNameParameter` model which automatically populate the following decorators with camel cased name for `@key` and pluralized name for `@segment` as values. You can override these values via `ResourceNameParameter`'s optional template parameter.\r\n  - `@key`: Specifies the parameter name for this resource type in the service URI hierarchy\r\n  - `@segment`: Specifies the name of the resource \"collection\", the URI segment that comes just before the parameter name which identifies the resource type\r\n\r\nHere we define a tracked resource called `User`:\r\n\r\n```typespec\r\n/** A User Resource */\r\nmodel User is TrackedResource<UserProperties> {\r\n  ...ResourceNameParameter<User>;\r\n}\r\n```\n\n## 3. **Define an interface with operations for the resource type**\n\n```typespec\r\n@armResourceOperations\r\ninterface Users {\r\n  get is ArmResourceRead<User>;\r\n  create is ArmResourceCreateOrReplaceAsync<User>;\r\n  update is ArmCustomPatchSync<\r\n    User,\r\n    Azure.ResourceManager.Foundations.ResourceUpdateModel<User, UserProperties>\r\n  >;\r\n  delete is ArmResourceDeleteSync<User>;\r\n  listByResourceGroup is ArmResourceListByParent<User>;\r\n  listBySubscription is ArmListBySubscription<User>;\r\n}\r\n```\r\n\r\nThis uses operation templates defined in the `Azure.ResourceManager` namespace to define the operations over your resource. For operations like `create (PUT)`, `update (PATCH)` and `delete (DELETE)` there are both asynchronous (long-running) and synchronous (operation completes in the same http request) versions of the operation templates.\r\n\r\nThe interface above creates the following operations for your service:\r\n\r\n| Method & Path                                                                                                        | Description                     |\r\n| -------------------------------------------------------------------------------------------------------------------- | ------------------------------- |\r\n| `GET /subscriptions/{subscriptionId}/providers/Contoso.Users/users`                                                  | list all User by subscription   |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users`               | list all User by resource group |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                        |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | create item                     |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                      |\r\n|\n\nall User by resource group |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                        |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | create item                     |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                      |\r\n| `DELETE /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}` | delete item                     |\r\n\r\n#### Base Resource Types\r\n\r\nHere are the base resource types you can use when defining your own ARM resources:\r\n\r\n| Name                             | Description                                                                            |\r\n| -------------------------------- | -------------------------------------------------------------------------------------- |\r\n| `TrackedResource<TProperties>`   | Defines a normal ARM resource where `TProperties` is the model of the `properties`     |\r\n| `ProxyResource<TProperties>`     | Defines a proxy ARM resource where `TProperties` is the model of the `properties`      |\r\n| `ExtensionResource<TProperties>` | Defines an extension ARM resource where `TProperties` is the model of the `properties` |\n\n### Alternate (Legacy) Syntax for Operations\n\nAlternately, you can use interface templates, which define a set of operations in your resource operations interface. Interface templates are convenient if you want to conform to standard\r\npractices, but are less flexible than operation templates.\r\n\r\nTo specify the standard set of TrackedResource operations for your resource, you can use the following code:\r\n\r\n```typespec\r\n@armResourceOperations\r\ninterface Users extends TrackedResourceOperations<User, UserProperties> {}\r\n```\r\n\r\nThis will now produce all the endpoints(`get`, `post`, `put`, `patch` and `delete`, listByResourceGroup, listBySubscription) for a resource called `Users` and the `operations` endpoint for the service:\r\n\r\n| Method & Path                                                                                                        | Description                          |\r\n| -------------------------------------------------------------------------------------------------------------------- | ------------------------------------ |\r\n| `GET /providers/Contoso.Users/operations`                                                                            | List all operations for your service |\r\n| `GET /subscriptions/{subscriptionId}/providers/Contoso.Users/users`                                                  | list all User by subscription        |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users`               | list all User by resource group      |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                             |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | insert item                          |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                           |\r\n|\n\ngroup      |\r\n| `GET /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | get item                             |\r\n| `PUT /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`    | insert item                          |\r\n| `PATCH /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}`  | patch item                           |\r\n| `DELETE /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Contoso.Users/users/{userName}` | delete item                          |\r\n\r\n#### Base Resource Types\r\n\r\nHere are the base resource types you can use when defining your own ARM resources:\r\n\r\n| Name                             | Description                                                                            |\r\n| -------------------------------- | -------------------------------------------------------------------------------------- |\r\n| `TrackedResource<TProperties>`   | Defines a normal ARM resource where `TProperties` is the model of the `properties`     |\r\n| `ProxyResource<TProperties>`     | Defines a proxy ARM resource where `TProperties` is the model of the `properties`      |\r\n| `ExtensionResource<TProperties>` | Defines an extension ARM resource where `TProperties` is the model of the `properties` |\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-operations.md\n- document_title: ARM Resource Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations\n- document_content: # howtos#arm#resource-operations.md\n\n# ARM Resource Operations\n\n## Recommended and Required Operations\n\n### TrackedResource\n\n| Operation             | Recommended | Required | TypeSpec Representation                                          |\r\n| --------------------- | ----------- | -------- | ---------------------------------------------------------------- |\r\n| GET                   | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                              |\r\n| CreateOrUpdate (PUT)  | Yes         | Yes      | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`    |\r\n| Tags Update (PATCH)   | No          | Yes\\*    | `update is ArmResourceTagsPatchSync<Resource>;`                  |\r\n| Full Update (PATCH)   | Yes         | No\\*     | `update is ArmCustomPatchSync<Resource, PatchRequest>;`          |\r\n| Delete                | Yes         | Yes      | `delete is ArmResourceDeleteSync<Resource>;`                     |\r\n| List by ResourceGroup | Yes         | Yes      | `listByResourceGroup is ArmResourceListByParent<Resource>;`      |\r\n| List by Subscription  | Yes         | Yes      | `listBySubscription is ArmResourceListBySubscription<Resource>;` |\r\n\r\n\\* Arm requires that, at minimum, a TrackedResource can update Tags. A Full PATCH of all updateable resource properties is preferred.\n\n### Proxy Resource\n\n| Operation            | Recommended | Required | TypeSpec Representation                                       |\r\n| -------------------- | ----------- | -------- | ------------------------------------------------------------- |\r\n| GET                  | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                           |\r\n| CreateOrUpdate (PUT) | Yes         | No\\*     | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;` |\r\n| Update (PATCH)       | Yes         | No       | `update is ArmCustomPatchSync<Resource, PatchRequest>;`       |\r\n| Delete               | Yes         | No\\*     | `delete is ArmResourceDeleteSync<Resource>;`                  |\r\n| List by Parent       | Yes         | Yes      | `listByParent is ArmResourceListByParent<Resource>;`          |\r\n\r\n\\* Note that, if a resource implements Create, it is highly recommended that it implement delete as well, and vice-versa.\n\n## TypeSpec Operation Templates and Interface Templates\n\nTypeSpec provide operation templates that describe the request and response of standard resource operations. A description of the options available for each resource template, and how to choose which one is described in the sections below.\n\n### Synchronous and Asynchronous APIs\n\nCreateOrUpdate (PUT), Update (Patch), Delete, and Action (POST) operations over a resource may\n\n### Determining Which Resource Properties Appear in Lifecycle Operations\n\nBy default, any property that occurs in your resource model will also appear in the response to GET, PUT, PATCH, and LIST operations, and in the request for PUT and PATCH operations. This does not work for all properties. Some properties are calculated by the service and cannot be directly set by PUT or PATCH (provisioningState, modification date, etc.). Some properties can only be set when creating a resource, but always appear in responses (e.g. 'location'). Some properties can only be set when updating the resource, and appear in responses. Some properties (rarely) may be settable when updating the resource via PUT or PATCH. To allow using a common resource model, but applying these `views` of resources to determine how the resource appear in request and responses, TypeSpec provides the visibility framework. You can see a complete representation of available visibilities in the table [on Property Visibility and Other Constraints](./resource-type.md#property-visibility-and-other-constraints). The sections below outline some common scenarios for designing properties with your operations in mind.\r\n\r\n#### Properties That Are Never Directly Set by the User\r\n\r\nIt is common to have properties that are calculated by the service or otherwise not directly set by the user, examples include timestamps, dates, values that are only set by specific actions (on/off, enabled/disabled, provisioningState). You want to make sure that these properties are marked so that they will appear in responses and not requests. this is done using the `@visibility(Lifecycle.Read)` decorator instance:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Read)\r\nprovisioningState: ProvisioningState;\r\n```\n\n### Resource Get Operations\n\nGet is the operation to retrieve a single resource TypeSpec provides a single operation template for GET:\r\n\r\n```typespec\r\nop get is ArmResourceRead<MyResource>;\r\n```\r\n\r\n- **get**: The name of the operation passed on to clients.\r\n- **Resource**: A reference to your resource type.\n\n### Resource CreateOrUpdate Operations (PUT)\n\nThe CreateOrUpdate operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\n- Simple resources may have synchronous PUT operations. If a resource may need to perform additional checks, creation of other dependent resources, or the like, it is best to use an Asynchronous API.\r\n- Asynchronous operations for PUT occur when the RP needs to perform additional validaton actions, create other resources, or perform other tasks as part of resource creation or update that can cause the operation to take longer than the length of a single request/response.\r\n\r\n| Operation        | TypeSpec                                                          |\r\n| ---------------- | ----------------------------------------------------------------- |\r\n| Synchronous PUT  | `createOrUpdate is ArmResourceCreateOrReplaceSync<ResourceType>`  |\r\n| Asynchronous PUT | `createOrUpdate is ArmResourceCreateOrReplaceAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `createOrUpdate` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being created (or updated)\n\n### Resource Update Operations (PATCH)\n\nPATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\r\nThe ArmCustomPatch\\* templates take the resource type and your custom PATCH request type as parameters.\n\nARM Requires that all `Tracked` resources implement PATCH for ARM tags, which are contained in the envelope of every `TrackedResource`. ARM recommends that you also allow PATCH of other envelope properties and resource-specific properties. Unless marked with a specific visibility, any property in your rp-specific properties will be automatically included in the PATCH schema.\r\n\r\nTypeSpec Provides both Synchronous and Asynchronous PATCH Operations, and allows you to specify a PATCH for Resource tags only, a PATCH for all updateable properties, or a custom patch. Generally, you should choose the patch for all updateable properties, unless you have a very good reason for choosing another PATCH operation.\r\n\r\n| Operation Description      | TypeSpec                                                                                                                                   |\r\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Sync TagsOnly PATCH        | `update is ArmTagsPatchSync<ResourceType>`                                                                                                 |\r\n| Async TagsOnly PATCH       | `update is ArmTagsPatchAsync<ResourceType>`                                                                                                |\r\n| Sync All Properties PATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\n\n### Resource Delete Operations (DELETE)\n\nThe Delete operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\nSimple resources may have synchronous DELETE operations. If a resource needs to clean up other resources or do other validations as part of delete, the delete operation may need to be asynchronous.\r\n\r\n| Operation           | TypeSpec                                                  |\r\n| ------------------- | --------------------------------------------------------- |\r\n| Synchronous Delete  | `delete is ArmResourceDeleteSync<ResourceType>`           |\r\n| Asynchronous Delete | `delete is ArmResourceDeleteWithoutOkAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `delete` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being deleted.\n\n### Resource List Operations (GET)\n\nArm Resource list operations return a list of Tracked or Proxy Resources at a particular scope.\r\n\r\n- All resources _should_ include a list operation at its immediate parent scope\r\n  - For **Tenant Resources**, this is at the tenant scope\r\n  - For **Extension Resources**, this is at the scope of resources they are extending\r\n  - For **Tracked Resources**, this is at the resource group scope.\r\n  - For **Child Resources**, this is at the scope of the resource parent.\r\n- Tracked resources _must_ include a list operation at the Subscription level.\r\n\r\n| Operation          | TypeSpec                                                            |\r\n| ------------------ | ------------------------------------------------------------------- |\r\n| ListByParent       | `listByWidget is ArmResourceListByParent<ResourceType>`             |\r\n| ListBySubscription | `listBySubscription is ArmResourceListBySubscription<ResourceType>` |\n\n### Resource Actions (POST)\n\nCustom actions define any operations over resources outside the simple CRUDL (Create< Read, Update, Delete, List) or lifecycle operations described above. Any operation that returns data that is not made up of resources, performs a prescriptive state change on the resource (cycling power, upgrading, etc.), or any operation that does not fit into the operations described above should be modelled as a _resource action_. Examples of resource actions include:\r\n\r\n- Operations that manage credentials associated with a resource\r\n- Operations that calculate statistics about resources\r\n- Operations that make specific state changes to resources (power cycle, upgrade, etc.)\r\n\r\n#### Actions that take input and output\r\n\r\nOperations that manage credentials are a good example fo this category. TypeSpec defines synchronous and asynchronous templates for actions that consume and produce information.\r\n\r\n| Operation                    | TypeSpec                                                                       |\r\n| ---------------------------- | ------------------------------------------------------------------------------ |\r\n| Synchronous Resource Action  | `updateCredentials is ArmResourceActionSync<ResourceType, Request, Response>`  |\r\n| Asynchronous Resource Action | `updateCredentials is ArmResourceActionAsync<ResourceType, Request, Response>` |\r\n\r\nParameters to the template are the ResourceType, the model for the operation Request body, and the model for the operation Response body.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- |\n\nbody.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- | ------------------------------------------------------------------------------------- |\r\n| Synchronous NoContent Action  | `updateCredentials is ArmResourceActionNoContentSync<ResourceType, Request>`          |\r\n| Asynchronous NoContent Action | `updateCredentials is ArmResourceActionNoResponseContentAsync<ResourceType, Request>` |\r\n\r\nParameters to the template are the ResourceType and the model for the operation Request body.\n\n### Actions that take no input but produce output (data retrieval actions)\n\nSome operations return data or paged lists of data. TypeSpec does not yet provide templates for these kinds of actions, but here are two templates that you could reuse in your own specification, described in the next section of the document:\r\n\r\n- [Synchronous Resource List Actions](#synchronous-list-action)\r\n- [Asynchronous List Action](#asynchronous-list-action)\n\n### Check Name Operations\n\nSome services provide operations to check name availability, either location-specific (locally) or globally, especially if a resource name must be globally unique (such as when an exposed endpoint uses the resource name in the url).\r\n\r\n| Operation                      | TypeSpec                                                                                             |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------- |\r\n| Global Name Availability Check | `checkGlobalName is checkGlobalNameAvailability<TRequest, TResponse, TAdditionalParams>`             |\r\n| Local Name Availability Check  | `checkLocalName is checkLocalNameAvailability<TRequest, TResponse, TAdditionalParams>`               |\r\n| Custom Name Availability Check | `customNameCheck is checkNameAvailability<TScopeParameters, TRequest, TResponse, TAdditionalParams>` |\r\n\r\n`checkGlobalNameAvailability` and `checkLocalNameAvailability` have default values that allow them to be used without specifying any template parameters. `checkNameAvailability` requires the `TScopeParameters` template parameter, which describes the parameters which define the scope of the name check request. For reference, the following table shows the `TScopeParameters` for the standard templates:\r\n\r\n| Operation                      | Scope Parameters                                                       |\r\n| ------------------------------ | ---------------------------------------------------------------------- |\r\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\r\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\n\n## Writing Custom Operations\n\nTypeSpec operation templates provide a simple mechanism for producing the most common operation patterns in ARM, using best practices and conforming to ARM RPC guidelines. However, sometimes a service has special requirements for operations that fall outside these boundaries. The `Azure.ResourceManager.Foundations` namespace provides lower level building blocks that can be used to produce operations and operation templates.\r\n\r\nThe building blocks are described in the sections below:\n\n### ARM Response Types\n\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\r\n\r\n| Model                               | Code | Description                                   |\r\n| ----------------------------------- | ---- | --------------------------------------------- |\r\n| `ArmResponse<T>`                    | 200  | Base Arm 200 response.                        |\r\n| `ArmResourceUpdatedResponse<T>`     | 200  | Resource updated (PUT) response.              |\r\n| `ArmResourceCreatedResponse<T>`     | 201  | Resource created response for an lro.         |\r\n| `ArmResourceCreatedSyncResponse<T>` | 201  | Resource created synchronously.               |\r\n| `ArmAcceptedResponse`               | 202  | Base Arm Accepted response.                   |\r\n| `ArmNoContentResponse`              | 204  | Base Arm No Content response.                 |\r\n| `ArmDeletedResponse`                | 200  | Resource deleted response.                    |\r\n| `ArmDeleteAcceptedResponse`         | 202  | Resource deletion in progress response.       |\r\n| `ResourceListResult<T>`             | 200  | Return a list of resource with ARM pagination |\r\n| `ErrorResponse`                     | x    | Error response                                |\n\n### Common Operation Parameters\n\nThere are a number of model types which specify common parameters which are used in resource type operations:\r\n\r\n| Model                           | In           | Description                                                 |\r\n| ------------------------------- | ------------ | ----------------------------------------------------------- |\r\n| `ApiVersionParameter`           | query        | api-version parameter                                       |\r\n| `SubscriptionIdParameter`       | path         | Subscription ID path parameter                              |\r\n| `ResourceGroupNameParameter`    | path         | Resource Group Name path parameter                          |\r\n| `ResourceInstanceParameters<T>` | path & query | Identity parameters for a resource, with api-version        |\r\n| `ResourceParentParameters<T>`   | path & query | Identity Parameters for listing by parent, with api-version |\r\n| `ResourceUriParameter`          | path         | Resource uri path parameter for Extension resources         |\r\n| `OperationIdParameter`          | path         | Operation Id path parameter                                 |\n\n### Synchronous List Action\n\nHere is a sample template for resource list actions that return synchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionSync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionSync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n\n### Asynchronous List Action\n\nHere is a sample template for resource list actions that return asynchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionAsync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ArmAcceptedResponse | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionAsync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#http#operations.md\n- document_title: Operations\n- document_link: https://typespec.io/docs/libraries/http/operations\n- document_content: # libraries#http#operations.md\n\n# Operations\n\n## Operation verb\n\n**Default behavior:**\r\n\r\n- If `@post` operation has a request body\r\n- `@get` otherwise\r\n\r\n**Configure:**\r\n\r\nYou can use one of the [verb decorators](./reference/decorators.md): `@get`, `@put`, etc.\n\n## Route\n\nAn operation route can be specified using the `@route` decorator.\r\n\r\n```typespec\r\n@route(\"/pets\") op list(): Pet[];\r\n```\r\n\r\nRoute path parameters are declared using `{}`. Providing `@path` on the model property with the matching name is optional.\r\n\r\n```typespec\r\n@route(\"/pets/{petId}\") op get(petId: string): Pet;\r\n// or explicit @path\r\n@route(\"/pets/{petId}\") op get(@path petId: string): Pet;\r\n```\r\n\r\nRoute can be specified on a parent namespace or interface. In that case all the operations, interfaces and namespaces underneath will be prefixed with it.\r\n\r\n```typespec\r\n@route(\"/store\")\r\nnamespace PetStore {\r\n  op hello(): void; // `/store`\r\n  @route(\"ping\") op ping(): void; // `/store/ping`\r\n\r\n  @route(\"/pets\")\r\n  interface Pets {\r\n    list(): Pet[]; // `/store/pets`\r\n    @route(\"{petId}\") read(petId: string): Pet; // `/store/pets/{petId}`\r\n  }\r\n}\r\n```\n\n## Path and query parameters\n\nModel properties and parameters which should be passed as path and query parameters use the `@path` and `@query` parameters respectively. Let's modify our list operation to support pagination, and add a read operation to our Pets resource:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): Pet[];\r\n  op read(@path petId: int32): Pet;\r\n}\r\n```\r\n\r\nPath parameters are appended to the URL unless a substitution with that parameter name exists on the resource path. For example, we might define a sub-resource using the following TypeSpec. Note how the path parameter for our sub-resource's list operation corresponds to the substitution in the URL.\r\n\r\n```typespec\r\n@route(\"/pets/{petId}/toys\")\r\nnamespace PetToys {\r\n  op list(@path petId: int32): Toy[];\r\n}\r\n```\n\n## Request & response bodies\n\nRequest and response bodies can be declared explicitly using the `@body` decorator. Let's add an endpoint to create a pet. Let's also use this decorator for the responses, although this doesn't change anything about the API.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[];\r\n  };\r\n  op read(@path petId: int32): {\r\n    @body pet: Pet;\r\n  };\r\n  @post\r\n  op create(@body pet: Pet): {};\r\n}\r\n```\r\n\r\nNote that in the absence of explicit `@body`:\r\n\r\n1. The set of parameters that are not marked @header, @query, or @path form the request body.\r\n2. The set of properties of the return model that are not marked @header or @statusCode form the response body.\r\n3. If the return type is not a model, then it defines the response body.\r\n\r\nThis is how we were able to return Pet and Pet[] bodies without using @body for list and read. We can actually write\r\ncreate in the same terse style by spreading the Pet object into the parameter list like this:\r\n\r\nSee also [metadata](./operations.md#metadata) for more advanced details.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @post\r\n  op create(...Pet): {};\r\n}\r\n```\n\n## Headers\n\nModel properties and parameters that should be passed in a header use the `@header` decorator. The decorator takes the header name as a parameter. If a header name is not provided, it is inferred from the property or parameter name. Let's add `etag` support to our pet store's read operation.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[];\r\n  };\r\n  op read(@path petId: int32, @header ifMatch?: string): {\r\n    @header eTag: string;\r\n    @body pet: Pet;\r\n  };\r\n  @post\r\n  op create(@body pet: Pet): {};\r\n}\r\n```\n\n## Status codes\n\n**Default behavior:**\r\n\r\n- `4xx,5xx` if response is marked with `@error`\r\n- `200` otherwise\r\n\r\n**Configure:**\r\n\r\nUse the `@statusCode` decorator on a property to declare a status code for a response. Generally, setting this to just `int32` isn't particularly useful. Instead, use number literal types to create a discriminated union of response types. Let's add status codes to our responses, and add a 404 response to our read endpoint.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @error\r\n  model Error {\r\n    code: string;\r\n  }\r\n\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[]; // statusCode: 200 Implicit\r\n  };\r\n  op read(@path petId: int32, @header ifMatch?: string): {\r\n    @statusCode statusCode: 200;\r\n    @header eTag: string;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n  };\r\n  op create(@body pet: Pet): {\r\n    @statusCode statusCode: 204;\r\n  } | Error; //statusCode: 4xx,5xx as Error use `@error` decorator\r\n}\r\n```\n\n## Content type\n\n[See the documentation of Content-Types](./content-types.md).\n\n## Built-in response shapes\n\nSince status codes are so common for REST APIs, TypeSpec comes with some built-in types for common status codes so you don't need to declare status codes so frequently.\r\n\r\nThere is also a `Body<T>` type, which can be used as a shorthand for { @body body: T } when an explicit body is required.\r\n\r\nLets update our sample one last time to use these built-in types:\r\n\r\n```typespec\r\nmodel ETag {\r\n  @header eTag: string;\r\n}\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): OkResponse & Body<Pet[]>;\r\n  op read(@path petId: int32, @header ifMatch?: string): (OkResponse &\r\n    Body<Pet> &\r\n    ETag) | NotFoundResponse;\r\n  @post\r\n  op create(...Pet): NoContentResponse;\r\n}\r\n```\r\n\r\nNote that the default status code is 200 for non-empty bodies and 204 for empty bodies. Similarly, explicit `Body<T>` is not required when T is known to be a model. So the following terser form is equivalent:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): Pet[];\r\n  op read(@path petId: int32, @header ifMatch?: string): (Pet & ETag) | NotFoundResponse;\r\n  @post\r\n  op create(...Pet): {};\r\n}\r\n```\r\n\r\nFinally, another common style is to make helper response types that are\r\nshared across a larger service definition. In this style, you can be\r\nentirely explicit while also keeping operation definitions concise.\r\n\r\nFor example, we could write :\r\n\r\n```typespec\r\nmodel ListResponse<T> {\r\n  ...OkResponse;\r\n  ...Body<T[]>;\r\n}\r\n\r\nmodel ReadSuccessResponse<T> {\r\n  ...OkResponse;\r\n  ...ETag;\r\n  ...Body<T>;\r\n}\r\n\r\nalias ReadResponse<T> = ReadSuccessResponse<T> | NotFoundResponse;\r\n\r\nmodel CreateResponse {\r\n  ...NoContentResponse;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): ListResponse<Pet>;\r\n  op read(@path petId: int32, @header ifMatch?: string): ReadResponse<Pet>;\r\n  @post\r\n  op create(...Pet): CreateResponse;\r\n}\r\n```\n\n## Handling files\n\n`@typespec/http` provides a special model [`TypeSpec.Http.File`](../http/reference/data-types.md#file-typespechttpfile) for handling file uploads and downloads in HTTP operations. When working with files, emitters need to implement special handling due to their binary nature.\r\n\r\nFor more information about HTTP file bodies and how to configure them, see [the documentation on Files][http-files].\r\n\r\n[http-files][./files.md]\n\n### Basic File Handling\n\nWhen the model `Http.File` (or any model that extends `Http.File`) is the _exact_ body of an HTTP request, emitters **must** treat this model with special care:\r\n\r\n- The `contentType` property should be used as the value for the `Content-Type` header in requests and vice-versa for responses.\r\n- The `filename` property should be used in the `Content-Disposition` header in responses and vice-versa for multipart requests (`filename` cannot be sent in a non-multipart HTTP request because `Content-Disposition` is only valid for responses and multipart requests).\r\n- The file content should be treated as the raw body of the request/response without any additional parsing.\r\n\r\nSee [`isHttpFile`](../http/reference/js-api/functions/isHttpFile.md) for a helper that emitters/libraries can use to detect instances of `Http.File`.\n\n### Examples\n\n#### Uploading and downloading files\r\n\r\n```typespec\r\n// Uploading and downloading\r\n@route(\"/files\")\r\ninterface Files {\r\n  @post\r\n  upload(@body file: Http.File): {\r\n    @statusCode statusCode: 201;\r\n  };\r\n\r\n  download(@path fileId: string): Http.File;\r\n}\r\n```\r\n\r\n#### Custom file types\r\n\r\nIf you want to declare specific types of files that are accepted, but still treated as binary files, declare the content types by extending the `Http.File` model and overriding the `contentType` field.\r\n\r\n```typespec\r\n// Custom file type for images\r\nmodel ImageFile extends Http.File {\r\n  contentType: \"image/jpeg\" | \"image/png\" | \"image/gif\";\r\n}\r\n\r\n@route(\"/images\")\r\ninterface Images {\r\n  @post\r\n  upload(@body image: ImageFile): {\r\n    @statusCode statusCode: 201;\r\n  };\r\n\r\n  download(@path imageId: string): ImageFile;\r\n}\r\n```\n\n## Automatic visibility\n\nThe `@typespec/rest` library understands [Lifecycle Visibility](../../language-basics/visibility.md#lifecycle-visibility) and provides functionality for emitters to apply visibility transforms based on whether a model represents a request or response and on HTTP method usage as detailed in the table below.\r\n\r\nSee [handling visibility and metadata](../../extending-typespec/emitter-metadata-handling.md) for details on how to incorporate this information into an emitter implementation.\r\n\r\n| Modifier         | Visible in           |\r\n| ---------------- | -------------------- |\r\n| Lifecycle.Read   | Any response         |\r\n| Lifecycle.Query  | GET or HEAD request  |\r\n| Lifecycle.Create | POST or PUT request  |\r\n| Lifecycle.Update | PATCH or PUT request |\r\n| Lifecycle.Delete | DELETE request       |\r\n\r\nThis allows a single logical TypeSpec model to be used as in the following example:\r\n\r\n```typespec\r\nmodel User {\r\n  name: string;\r\n  @visibility(Lifecycle.Read) id: string;\r\n  @visibility(Lifecycle.Create) password: string;\r\n}\r\n\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(@path id: string, ...User): User;\r\n  @get get(@path id: string): User;\r\n}\r\n```\r\n\r\nThere is a single logical user entity represented by the single TypeSpec type `User`, but the HTTP payload for this entity varies based on context. When returned in a response, the `id` property is included, but when sent in a request, it is not. Similarly, the `password` property is only included in create requests, but not present in responses.\r\n\r\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(Lifecycle.Read)` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas.\n\nincluded in create requests, but not present in responses.\r\n\r\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(Lifecycle.Read)` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas. For example, `@visibility(Lifecycle.Create)` applied to a model property of a type named Widget will generate a `WidgetCreate` schema.\r\n\r\nAnother emitter such as one generating client code can see and preserve a single logical type and deal with these HTTP payload differences by means other than type proliferation.\r\n\r\nModeling with logical entities rather than HTTP-specific shapes also keeps the TypeSpec spec decoupled from HTTP and REST and can allow the same spec to be used with multiple protocols.\n\n## Metadata\n\nin terms of the logical entity:\r\n\r\n```typespec\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(...User): User;\r\n}\r\n```\r\n\r\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\r\n\r\n```\r\nPOST /Users/TypeSpecFan42 HTTP/1.1\r\nContent-Type: application/json\r\n{\r\n  \"name\": \"TypeSpec Fan\",\r\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\r\n}\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\n{\r\n  name: \"TypeSpec Fan\",\r\n  id: \"TypeSpecFan42\r\n}\r\n```\n\nThe properties that designate content for the HTTP envelope (`@header`, `@path`, `@query`, `@statusCode`) rather than the content in an HTTP payload are often called \"metadata\".\r\n\r\nMetadata is determined to be applicable or inapplicable based on the context that it is used:\r\n\r\n| Context       | Applicability       |\r\n| ------------- | ------------------- |\r\n| `@query`      | request only        |\r\n| `@path`       | request only        |\r\n| `@statusCode` | response only       |\r\n| `@header`     | request or response |\r\n\r\nAdditionally metadata that appears in an array element type always inapplicable.\r\n\r\nWhen metadata is deemed \"inapplicable\", for example, if a `@path` property is seen in a response, it becomes part of the payload instead unless the [@includeInapplicableMetadataInPayload](./reference/decorators.md#@TypeSpec.Http.includeInapplicableMetadataInPayload) decorator is used and given a value of `false`.\r\n\r\nThe handling of metadata applicability furthers the goal of keeping a single logical model in TypeSpec. For example, this defines a logical `User` entity that has a name, ID and password, but further annotates that the ID is sent in the HTTP path and the HTTP body in responses. Also, using automatic visibility as before, we further indicate that the password is only present in create requests.\r\n\r\n```typespec\r\nmodel User {\r\n  name: string;\r\n  @path id: string;\r\n  @visibility(Lifecycle.Create) password: string;\r\n}\r\n```\r\n\r\nThen, we can write operations in terms of the logical entity:\r\n\r\n```typespec\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(...User): User;\r\n}\r\n```\r\n\r\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\r\n\r\n```\r\nPOST /Users/TypeSpecFan42 HTTP/1.1\r\nContent-Type: application/json\r\n{\r\n  \"name\": \"TypeSpec Fan\",\r\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\r\n}\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\n{\n\n### Visibility vs. Metadata applicability\n\nMetadata properties are filtered based on visibility as [described above](#automatic-visibility). This is done independently before applicability is considered. If a a metadata property is not visible then it is neither part of the envelope nor the HTTP payload, irrespective of its applicability.\n\n### Nested metadata\n\nMetadata properties are not required to be top-level. They can also be nested deeper in a parameter or response model type. For example:\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: {\r\n    @header example: string;\r\n  };\r\n  name: string;\r\n}\r\n```\r\n\r\nNote that nesting in this sense does not require the use of anonymous models. This is equivalent:\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: Headers;\r\n  name: string;\r\n}\r\nmodel Headers {\r\n  @header example: string;\r\n}\r\n```\r\n\r\nIn the event that this nesting introduces duplication, then the least nested property with a given name is preferred and the duplicate metadata properties are ignored.\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: {\r\n    @header example: string; // preferred\r\n    more: {\r\n      @header example: string; // ignored\r\n    };\r\n  };\r\n}\r\n```\n\n## Emitter resources\n\nSee [Handling metadata and visibility in emitters for REST API](../../extending-typespec/emitter-metadata-handling.md) for information on how to handle metadata applicability and automatic visibility in a custom emitter.\n", "latency": 11.373355865478516, "response_length": 1362}
{"query": "title: Enforcing scope restrictions for extension resources\n\nquestion: Hi\nTypeSpec Discussion\n,\nWe are building a new extension resource under a new RP - Microsoft.StorageDataRP and require this resource to be strictly scoped to:\n/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}\nWe would like requests with any other scope to be blocked by ARM/RPaaS and not reach our RP.\nWhat is the recommended approach to enforce this restriction?\nNote: Our RP is hosted on RPaaS.\nCurrently, I have modeled the extension resource as shown below, but I am unable to enforce the scope restriction:\n```\n@@path(ResourceUriParameter.resourceUri, \"scope\");\n@@Azure.ResourceManager.CommonTypes.Private.armCommonParameter(\nResourceUriParameter.resourceUri,\n\"ScopeParameter\",\nAzure.ResourceManager.CommonTypes.Versions.v5\n);\n@@doc(Azure.ResourceManager.ResourceUriParameter.resourceUri,\n\"The scope of the operation or resource. Valid scopes is: resource (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}'\"\n);\n@doc(\"A MountPoint is a tracked ARM resource modeled as a sub-resource of a Storage Account\")\nmodel MountPoint is ExtensionResource<MountPointProperties, false> {\n@doc(\"The name of the mount point\")\n@pattern(\"^[a-zA-Z0-9-]{3,24}$\")\n@key(\"mountpointName\")\n@segment(\"mountPoints\")\n@path\nname: string;\n}\n```", "ground_truth": "The issue of assigning resource types for extension resources is recognized, and while its currently in the backlog, a possible solution is to use extension resources in TypeSpec. This allows you to attach resources to others, but restrictions on which resources can be used might require customizations.\nRather than customizing in TypeSpec itself, client SDK customizations are suggested. This would involve validating or parameterizing the resource IDs of the extended resources. For direct REST calls in UserRP, you would still need to handle these checks at the RP level if necessary.\nYou can refer to the documentation on extension resources in TypeSpec for more details on how to approach this. The team is encouraged to avoid extensive customizations in favor of maintaining the TypeSpec approach, but if needed, SDK-level customizations can provide flexibility.", "response": "To enforce the scope restriction for your extension resource so that it is strictly scoped to `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}`, you need to ensure that the resource is modeled as an `ExtensionResource` and that the `ResourceUriParameter` is used correctly. Additionally, ARM/RPaaS will enforce the scope restriction based on the resource type and its parent resource. Here's how you can refine your TypeSpec model:\n\n1. **Ensure Proper Use of `ExtensionResource`**:\n   Your resource is already modeled as an `ExtensionResource`, which is correct for resources that extend other resources (in this case, a storage account).\n\n2. **Define the Parent Scope**:\n   Use the `ResourceUriParameter` to define the parent scope explicitly. This parameter ensures that the resource is tied to the correct parent resource type.\n\n3. **Validate Scope in ARM**:\n   ARM will automatically enforce the scope restriction based on the parent resource type (`Microsoft.Storage/storageAccounts`). Ensure that your resource operations (e.g., `createOrUpdate`, `delete`) are defined with the correct parent scope.\n\nHeres an updated example of your TypeSpec model:\n\n```typespec\n@@path(ResourceUriParameter.resourceUri, \"scope\");\n@@Azure.ResourceManager.CommonTypes.Private.armCommonParameter(\n  ResourceUriParameter.resourceUri,\n  \"ScopeParameter\",\n  Azure.ResourceManager.CommonTypes.Versions.v5\n);\n@@doc(Azure.ResourceManager.ResourceUriParameter.resourceUri,\n  \"The scope of the operation or resource. Valid scope is: resource (format: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Storage/storageAccounts/{accountName}')\"\n);\n\n@doc(\"A MountPoint is a tracked ARM resource modeled as a sub-resource of a Storage Account\")\nmodel MountPoint is ExtensionResource<MountPointProperties, false> {\n  @doc(\"The name of the mount point\")\n  @pattern(\"^[a-zA-Z0-9-]{3,24}$\")\n  @key(\"mountpointName\")\n  @segment(\"mountPoints\")\n  @path\n  name: string;\n}\n```\n\n4. **Define Operations**:\n   Ensure that operations like `createOrUpdate` and `delete` are scoped to the parent resource. For example:\n\n```typespec\n@armResourceOperations(MountPoint)\ninterface MountPointOperations {\n  createOrUpdate is ArmResourceCreateOrReplaceAsync<MountPoint>;\n  delete is ArmResourceDeleteSync<MountPoint>;\n}\n```\n\nBy following these steps, ARM/RPaaS will enforce the scope restriction, and requests with invalid scopes will not reach your RP.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-type.md\n- document_title: ARM Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type\n- document_content: # howtos#arm#resource-type.md\n\n# ARM Resource Types\n\n## Introductions\n\nIntroduction\r\nResources are the basic building blocks of Azure. When a customer interacts with Azure through the Control Plane (ARM), they generally will be reading (GET), writing (PUT/PATCH), deleting (DELETE) or performing actions upon (POST) one or more resources. Each resource is managed by a particular Resource Provider, so we uniquely identify a resource by its 'fully-qualified type'. Some well-known examples of types are Microsoft.Compute/virtualMachines, or Microsoft.Network/networkSecurityGroups/securityRules. See Resource Ids for a more in-depth breakdown of the id and associated fields.\r\n\r\nIn order to give customers a consistent API when working with many different Resource Providers, and to allow ARM to understand and manage resources programmatically, ARM requires each RP to follow a set of contracts for resource management, defined in the ARM RPC.\n\n## ARM Resource Terminology\n\nThe most important distinction between resources is between _Tracked_ and _Proxy_ resources. Tracked resources are resources in which all of the metadata is maintained in Azure Resource Manager. Tracked Resources can be targeted to specific regions, and are generally the best choice for most top-level resources. Azure Resource Manager maintains data about Tracked Resources, and generally will handle many implementation details or operations on the resource. See [RPC: Resource API Reference](https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md) for further information on the contract for Tracked Resources.\r\n\r\nProxy resources are resources in which only a portion of resource metadata is tracked in ARM. Generally, these model resources maintained on other systems, or that resource-providers want to track themselves. Generally, resource providers must implement most of the operations for Proxy resources. Tenant, Extension, and child resources are usually modeled as Proxy resources.\r\n\r\nThere is a good discussion on making the choice between Tracked and Proxy Resources in the armwiki discussion [Tracked vs Proxy Resources](https://armwiki.azurewebsites.net/rp_onboarding/tracked_vs_proxy_resources.html)\n\n## Choosing a Resource Type\n\n- The large majority of resources have their metadata tracked by ARM, can be assigned to regions, and are contained inside a resource group in a subscription, for ease of management and billing. These are called [Tracked Resources](#tracked-resources).\r\n- Some resources may need to have scope across an entire customer tenant, or may need to have a single instance across all customer subscriptions. These are called [tenant resources](#tenant-resources).\r\n- Some kinds of resources may augment or alter the functionality of resources or resource containers provided by other resource-providers. For example, policy or RBAC rules may be applied to any resource or resource container. These resources are called [extension resources](#extension-resource).\r\n- Some resources are complex and naturally break down into one or more components that are separately configurable, but an integral part of the larger resource (for example, a virtual network resource may contain many separately configurable subnets). These component resources are called [child resources](#child-resource).\r\n- Rarely, some resources may need to apply across a subscription, or have a single instance in a customer subscription, these are called [subscription-based resources](#subscription-based-resource).\r\n- Rarer still, some resources may need to apply across a specific region, or have a single instance in a region, these are called [location-based resources](#location-based-resource).\r\n- In some cases, there can only be one instance of a resource at a specific scope - this is rare, but happens most frequently in tenant, child, and location resources. In typespec, you will need to specify that the resource is a singleton, and the resource manager tools will automatically apply the correct pattern for singleton resources (using the recommended resource name 'default')\n\n## Modeling Resources in TypeSpec\n\nResources are modeled in TypeSpec by choosing a _base resource type_, defining _rp-specific properties_, and optionally mixing in _standard envelope properties_. Later sections document [how to model resource operations](./resource-operations.md). The following sections discuss usage of each of the base resource types. Later sections discuss [designing rp-specific properties](#designing-resource-specific-properties) and [adding standard ARM envelope properties](#adding-optional-standard-envelope-properties).\n\n### Tracked Resources\n\nTracked resources use the `TrackedResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tracked Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Tenant Resources\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@tenantResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tenant Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Extension Resource\n\nExtension resources use the `ExtensionResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is ExtensionResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Extension Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Child Resource\n\nChild resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@parentResource(EmployeeResource)\r\nmodel JobResource is ProxyResource<JobProperties> {\r\n  /** The job name */\r\n  @segment(\"jobs\")\r\n  @key(\"jobName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@parentResource`: designates the model type for the parent of this child resource. The resource identifier for this resource will be prepended with the resource identity of the parent.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Child Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Subscription-based Resource\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@subscriptionResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@subscriptionResource`: designates this resource as being a cross-subscription resource, with scope across all resource groups in the subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Subscription Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Location-based Resource\n\nLocation-based resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@locationResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@locationResource`: designates this resource as being a cross-location resource, with scope across a location within a subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Location Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Singleton Resource\n\nSingleton resources can use any resource base type, but most often use `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@singleton\r\n@tenantResource\r\nmodel EmployeeAgreementResource is ProxyResource<EmployeeAgreementProperties> {\r\n  /** The default employee agreement, applying to all employees. */\r\n  @segment(\"employeeAgreements\")\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@singleton`: indicates that there can only be one of the resources in the resource container (in this case, only one instance in the customer tenant).\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource. For a singleton, the name value will always be the same.\r\n`@segment(employeeAGreements)`: provides the resource type name for this resource.\r\n`@key`: provides the parameter name for the name of the resource in operations that use this resource - this will not be a settable value for singleton resources.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Singleton Resources [in the Singleton sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/arm-scenarios/singleton/main.tsp#L29).\n\n## Designing Resource-specific Properties\n\nEach resource model consists of two distinct parts\r\n\r\n- An outer _envelope_ of information that provides metadata for optional standardized ARM functionality, like entity-tags and managed identities, and is processed by Azure Resource Manager.\r\n- An inner set of properties that are specific to the resource and are defined by the resource provider.\r\n\r\nModifying the ARM envelope is discussed in later sections on [mixing in standard ARM envelope add-ons](#adding-optional-standard-envelope-properties).\r\n\r\nThe inner _rp-specific property bag_ consists of all of the properties that the RP needs to manage about the resource. Properties should be completely specified, should not duplicate properties from the _ARM envelope_, and may consist of simple types, arrays, or other complex properties.\r\n\r\nHere is an example of a property bag for the `EmployeeResource` resource.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n\r\nunion EmployeeProvisioningState {\r\n  string,\r\n\r\n  /** The resource create request has been accepted */\r\n  Accepted: \"Accepted\",\r\n\r\n  /** The resource is being provisioned */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is updating */\r\n  Updating: \"Updating\",\r\n\r\n  /** Resource has been created. */\r\n  Succeeded: \"Succeeded\",\r\n\r\n  /** Resource creation failed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\n\nfailed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n\r\nmodel EmployeeProperties {\r\n  /** The current title of the employee */\r\n  title: string;\r\n\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  level: EmployeeLevel;\r\n\r\n  @visibility(Lifecycle.Read)\r\n  employeeId: int32;\r\n\r\n  biography?: string = \"No biography provided\";\r\n  colleagues: EmployeeResourceId[];\r\n  employmentHistory: Job[];\r\n\r\n  @visibility(Lifecycle.Create)\r\n  password: Password;\r\n\r\n  provisioningState?: EmployeeProvisioningState;\r\n}\r\n```\r\n\r\n`EmployeeProperties` specifies the employee metadata that the RP needs to track and manage. Notice that the model uses built-in scalar types like `string` and `int32`, new types built from scalar types with added constraints, like `Password` and `EmployeeLevel`, enumerations of values, like `EmployeeProvisioningState`, and complex types. The individual components of this model are described below.\r\n\r\nNote that _documentation comments on all models and model properties are required when specs are checked in_. Here they are omitted for clarity. The TypeSpec compiler and TypeSpec IDE tooling will emit warning diagnostics if you emit required documentation, and about most of the ARM rules described in this document.\n\n### The `provisioningState` Property for Tracked Resources\n\nAll Tracked Resources are required to implement a 'provisioningState' property in their rp-specific property bag. This is used by ARM and some ARM clients to track the provisioning state of a resource as it is created and deleted. At minimum, the provisioning state must contain the standard terminal values that ARM is looking for. There are contained in the `ResourceProvisioningState` enumeration in the Azure.ResourceManager library. If RPs have other provisioning states they would like to track, they can define their own provisioning state enum, and mix in the value, as shown in the sample above, or they may simply use the standard provisioning state as shown in the sample below:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  ...ResourceProvisioningState;\r\n}\r\n```\r\n\r\nNote that this example uses the spread operator `...`, which allows you to simply include the properties from a source model in the target model you are constructing. This has the effect of copying the properties of the source model and their decorations into the target model, without creating any nominal inheritance relationship.\r\n\r\nAlternately, this is also equivalent:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  /** The status of the last provisioning operation performed on the resource. */\r\n  @visibility(Lifecycle.Read)\r\n  provisioningState?: ResourceProvisioningState;\r\n}\r\n```\n\n### Required and Optional properties and Property Defaults\n\nIn the examples, note that some model properties use the optional operator `?` after the property name, like `biography?` and some do not, like `title`. Property names using the `?` are optional properties, which may or may not be provided in the request body for CreateOrUpdate (PUT) requests. Property names without the `?` are required properties, which must be provided in PUT requests. The exception is that properties that have 'readOnly' visibility do not appear in requests, but may be required or optional in responses.\r\n\r\nAlso note that optional properties may specify defaults, as with `biography?: string = \"No biography provided\"`. The default indicates the value that will be recorded on the server if no value is sent by the client.\n\n### Defining Custom Types\n\nIn the sample, new constrained scalar types and new complex model types are defined and used inside the _rp-specific property bag_. TypeSpec allows you to define custom types for use in your specification.\r\n\r\nYou will often want to define scalar types or properties that have constraints. For example, numeric values may be constrained to have a certain minimum or maximum, strign values may be constrained to follow a particular regex pattern, and so on. Whenever these constrained types are used in your spec, the constraints will be transmitted to the usage.\r\n\r\nThe example creates a numeric type with minimum and maximum constraints:\r\n\r\n```typespec\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n```\r\n\r\nThis defines 'EmployeeLevel' as an integer value between 50 and 70. The example also defines a complex type used in an array:\r\n\r\n```typespec\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n```\r\n\r\nMode details on what to consider when using complex types in an array are discussed in the section on [modeling arrays of complex types](#modeling-arrays-of-complex-types).\n\n### Using Resource identifiers\n\nIt is often the case that resources need to reference other resources to provide specific pieces of functionality. For example, resources may need to reference a storage account to use for storing user data, or a NIC to attach to a Network. The `Azure.ResourceManager` library defines a `ResourceIdentifier` template that allows you to easily represent references to resources in your API. The template allows you to specify one or more acceptable resource types, automatically designating the value as a resource reference, and providing the appropriate pattern validation - which helps in generating better code, better ARM templates, and better documentation for your API.\r\n\r\n```typespec\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\nscalar NetworkInterfaceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/networkInterfaces\",\r\n    },\r\n    {\r\n      type: \"Microsoft.ClassicNetwork/networkInterfaces\",\r\n    }\r\n  ]>;\r\n```\r\n\r\nThe `NetworkInterfaceId example shows how to allow multiple resource types in a reference.\n\n### Property Visibility and Other Constraints\n\nThe sample uses the `@visibility` decorator to indicate how the resource definition is used in requests to PUT and PATCH operations, and in responses to PUT, PATCH, GET, and LIST operations.\r\n\r\nThis table shows how visibility is used to determine whether a property is used in requests and responses:\r\n\r\n| Visibility           | In Create Request? | In Patch Request/ Updateable in PUT | In Responses | Sample                                         |\r\n| -------------------- | ------------------ | ----------------------------------- | ------------ | ---------------------------------------------- |\r\n| None                 | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create, update | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create         | Yes                | No                                  | Yes          | resource location                              |\r\n| read, update         | No                 | Yes                                 | Yes          | Properties only settable after creation (keys) |\r\n| create, update       | Yes                | Yes                                 | No           | Secrets (e.g. password)                        |\r\n| read                 | No                 | No                                  | Yes          | Calculated properties, e.g. provisioningState  |\r\n| update               | No                 | Yes                                 | No           | Secrets (e.g. keys)                            |\r\n| create               | Yes                | No                                  | No           | Secrets (e.g. user-defined password)           |\n\n### Modeling Arrays of Complex Types\n\nFinally, when your _rp-specific property bag_ contains an array of complex properties, there are a few important considerations:\r\n\r\n- The complex properties in an array must have a key property - this means a property named 'name' or 'id' that uniquely identifies the property in the array. The TypeSpec tools will emit a diagnostic if you omit this.\r\n- ARM resources must be fully loaded in memory, so there are limits to the size of arrays in the properties of a resource. If your array is not strictly bounded, you should consider modeling the array property as a [child resource](#child-resource)\r\n- Updating the contents of arrays can be difficult, and result in data loss under simultaneous updates, especially as Json-Merge-Patch is not widely supported in ARM update operations. If users will frequently need to update the contents of arrays, you should consider modeling as a [child resource](#child-resource).\n\n## Adding Optional Standard Envelope Properties\n\nIn addition to the resource-specific property bag, a resource may configure on or more standard ARM features through the use of standard properties in the _ARM Envelope_. Standard features configured in the envelope include:\r\n\r\n- **Managed Identity**: Associating a managed identity with the resource to authorize actions taken by this resource on other resources.\r\n- **SKU**: A standard mechanism for configuring levels of service for a resource.\r\n- **Plan**: A standard mechanism for configuring MarketPlace billing plans for a resource.\r\n- **ETags**: A standard mechanism for managing concurrent operations over the resource.\r\n- **ResourceKind**: A standard mechanism for specifying a type of user experience in the portal.\n\n### Managed Identity\n\nStandard configuration for ARM support of both SystemAssigned and UserAssigned Managed Service Identity (MSI)\r\n\r\n- If a resource allows both generated (SystemAssigned) and user-assigned (UserAssigned) Managed Identity, use the spread (...) operator to include the standard ManagedServiceIdentity envelope property. This will allow users to manage any ManagedServiceIdentity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedServiceIdentity;\r\n  }\r\n  ```\r\n\r\n- If a resource allows only generated (SystemAssigned) Managed Identity, use the spread operator (...) to include the `ManagedSystemAssignedIdentity` standard envelope property in the resource definition. This will allow users to manage the SystemAssigned identity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedSystemAssignedIdentity;\r\n  }\r\n  ```\r\n\r\nFor more information, see [Managed Service Identity Support](https://eng.ms/docs/products/arm/rpaas/msisupport)\n\n### SKU\n\nStandard support for setting a SKU-based service level for a resource. To enable SKU support, add the `ResourceSku` enevelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceSku;\r\n}\r\n```\r\n\r\nFor more information, see [SKU Support](https://eng.ms/docs/products/arm/rpaas/skusupport)\n\n### ETags\n\nIndicator that entity-tag operation concurrency support is enabled for this resource. To enable ETags, add the `EntityTag` envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...EntityTag;\r\n}\r\n```\r\n\r\nFor more information, and limitations on RPaaS concurrency support, see [RPaaS ETag Support](https://eng.ms/docs/products/arm/rpaas/etags)\n\n### Plan\n\nSupport for marketplace billing configuration for the resource. To enable `Plan` support, add the `ResourcePlan` standard envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourcePlan;\r\n}\r\n```\r\n\r\nSee [MarketPlace Third Party Billing SUpport](https://eng.ms/docs/products/arm/rpaas/custom_billing)\n\n### ResourceKind\n\nSupport for certain kinds of portal user experiences based on the kind of resource. To include 'Kind' in the resource defintion, add the `ResourceKind` standard envelope property.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceKind;\r\n}\r\n```\r\n\r\nFor more information on user experiences in the Azure Portal, see [Portal Support](https://eng.ms/docs/products/arm/rpaas/portal/gettingstarted)\n\n### ManagedBy\n\nSupport for management of this resource by other resources. To add 'ManagedBy' support to the resource, add the `ManagedBy` envelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ManagedBy;\r\n}\r\n```\r\n\r\nFor more information on supporting 'ManagedBy', see [ManagedBy API Contract](https://eng.ms/docs/products/arm/api_contracts/managedby)\n\n## Reference\n\n[Fundamentals - ARM Wiki](https://armwiki.azurewebsites.net/fundamentals/overview.html)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-operations.md\n- document_title: ARM Resource Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations\n- document_content: # howtos#arm#resource-operations.md\n\n# ARM Resource Operations\n\n## Recommended and Required Operations\n\n### TrackedResource\n\n| Operation             | Recommended | Required | TypeSpec Representation                                          |\r\n| --------------------- | ----------- | -------- | ---------------------------------------------------------------- |\r\n| GET                   | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                              |\r\n| CreateOrUpdate (PUT)  | Yes         | Yes      | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`    |\r\n| Tags Update (PATCH)   | No          | Yes\\*    | `update is ArmResourceTagsPatchSync<Resource>;`                  |\r\n| Full Update (PATCH)   | Yes         | No\\*     | `update is ArmCustomPatchSync<Resource, PatchRequest>;`          |\r\n| Delete                | Yes         | Yes      | `delete is ArmResourceDeleteSync<Resource>;`                     |\r\n| List by ResourceGroup | Yes         | Yes      | `listByResourceGroup is ArmResourceListByParent<Resource>;`      |\r\n| List by Subscription  | Yes         | Yes      | `listBySubscription is ArmResourceListBySubscription<Resource>;` |\r\n\r\n\\* Arm requires that, at minimum, a TrackedResource can update Tags. A Full PATCH of all updateable resource properties is preferred.\n\n### Proxy Resource\n\n| Operation            | Recommended | Required | TypeSpec Representation                                       |\r\n| -------------------- | ----------- | -------- | ------------------------------------------------------------- |\r\n| GET                  | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                           |\r\n| CreateOrUpdate (PUT) | Yes         | No\\*     | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;` |\r\n| Update (PATCH)       | Yes         | No       | `update is ArmCustomPatchSync<Resource, PatchRequest>;`       |\r\n| Delete               | Yes         | No\\*     | `delete is ArmResourceDeleteSync<Resource>;`                  |\r\n| List by Parent       | Yes         | Yes      | `listByParent is ArmResourceListByParent<Resource>;`          |\r\n\r\n\\* Note that, if a resource implements Create, it is highly recommended that it implement delete as well, and vice-versa.\n\n## TypeSpec Operation Templates and Interface Templates\n\nTypeSpec provide operation templates that describe the request and response of standard resource operations. A description of the options available for each resource template, and how to choose which one is described in the sections below.\n\n### Synchronous and Asynchronous APIs\n\nCreateOrUpdate (PUT), Update (Patch), Delete, and Action (POST) operations over a resource may\n\n### Determining Which Resource Properties Appear in Lifecycle Operations\n\nBy default, any property that occurs in your resource model will also appear in the response to GET, PUT, PATCH, and LIST operations, and in the request for PUT and PATCH operations. This does not work for all properties. Some properties are calculated by the service and cannot be directly set by PUT or PATCH (provisioningState, modification date, etc.). Some properties can only be set when creating a resource, but always appear in responses (e.g. 'location'). Some properties can only be set when updating the resource, and appear in responses. Some properties (rarely) may be settable when updating the resource via PUT or PATCH. To allow using a common resource model, but applying these `views` of resources to determine how the resource appear in request and responses, TypeSpec provides the visibility framework. You can see a complete representation of available visibilities in the table [on Property Visibility and Other Constraints](./resource-type.md#property-visibility-and-other-constraints). The sections below outline some common scenarios for designing properties with your operations in mind.\r\n\r\n#### Properties That Are Never Directly Set by the User\r\n\r\nIt is common to have properties that are calculated by the service or otherwise not directly set by the user, examples include timestamps, dates, values that are only set by specific actions (on/off, enabled/disabled, provisioningState). You want to make sure that these properties are marked so that they will appear in responses and not requests. this is done using the `@visibility(Lifecycle.Read)` decorator instance:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Read)\r\nprovisioningState: ProvisioningState;\r\n```\n\n### Resource Get Operations\n\nGet is the operation to retrieve a single resource TypeSpec provides a single operation template for GET:\r\n\r\n```typespec\r\nop get is ArmResourceRead<MyResource>;\r\n```\r\n\r\n- **get**: The name of the operation passed on to clients.\r\n- **Resource**: A reference to your resource type.\n\n### Resource CreateOrUpdate Operations (PUT)\n\nThe CreateOrUpdate operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\n- Simple resources may have synchronous PUT operations. If a resource may need to perform additional checks, creation of other dependent resources, or the like, it is best to use an Asynchronous API.\r\n- Asynchronous operations for PUT occur when the RP needs to perform additional validaton actions, create other resources, or perform other tasks as part of resource creation or update that can cause the operation to take longer than the length of a single request/response.\r\n\r\n| Operation        | TypeSpec                                                          |\r\n| ---------------- | ----------------------------------------------------------------- |\r\n| Synchronous PUT  | `createOrUpdate is ArmResourceCreateOrReplaceSync<ResourceType>`  |\r\n| Asynchronous PUT | `createOrUpdate is ArmResourceCreateOrReplaceAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `createOrUpdate` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being created (or updated)\n\n### Resource Update Operations (PATCH)\n\nPATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\r\nThe ArmCustomPatch\\* templates take the resource type and your custom PATCH request type as parameters.\n\nARM Requires that all `Tracked` resources implement PATCH for ARM tags, which are contained in the envelope of every `TrackedResource`. ARM recommends that you also allow PATCH of other envelope properties and resource-specific properties. Unless marked with a specific visibility, any property in your rp-specific properties will be automatically included in the PATCH schema.\r\n\r\nTypeSpec Provides both Synchronous and Asynchronous PATCH Operations, and allows you to specify a PATCH for Resource tags only, a PATCH for all updateable properties, or a custom patch. Generally, you should choose the patch for all updateable properties, unless you have a very good reason for choosing another PATCH operation.\r\n\r\n| Operation Description      | TypeSpec                                                                                                                                   |\r\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Sync TagsOnly PATCH        | `update is ArmTagsPatchSync<ResourceType>`                                                                                                 |\r\n| Async TagsOnly PATCH       | `update is ArmTagsPatchAsync<ResourceType>`                                                                                                |\r\n| Sync All Properties PATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\n\n### Resource Delete Operations (DELETE)\n\nThe Delete operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\nSimple resources may have synchronous DELETE operations. If a resource needs to clean up other resources or do other validations as part of delete, the delete operation may need to be asynchronous.\r\n\r\n| Operation           | TypeSpec                                                  |\r\n| ------------------- | --------------------------------------------------------- |\r\n| Synchronous Delete  | `delete is ArmResourceDeleteSync<ResourceType>`           |\r\n| Asynchronous Delete | `delete is ArmResourceDeleteWithoutOkAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `delete` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being deleted.\n\n### Resource List Operations (GET)\n\nArm Resource list operations return a list of Tracked or Proxy Resources at a particular scope.\r\n\r\n- All resources _should_ include a list operation at its immediate parent scope\r\n  - For **Tenant Resources**, this is at the tenant scope\r\n  - For **Extension Resources**, this is at the scope of resources they are extending\r\n  - For **Tracked Resources**, this is at the resource group scope.\r\n  - For **Child Resources**, this is at the scope of the resource parent.\r\n- Tracked resources _must_ include a list operation at the Subscription level.\r\n\r\n| Operation          | TypeSpec                                                            |\r\n| ------------------ | ------------------------------------------------------------------- |\r\n| ListByParent       | `listByWidget is ArmResourceListByParent<ResourceType>`             |\r\n| ListBySubscription | `listBySubscription is ArmResourceListBySubscription<ResourceType>` |\n\n### Resource Actions (POST)\n\nCustom actions define any operations over resources outside the simple CRUDL (Create< Read, Update, Delete, List) or lifecycle operations described above. Any operation that returns data that is not made up of resources, performs a prescriptive state change on the resource (cycling power, upgrading, etc.), or any operation that does not fit into the operations described above should be modelled as a _resource action_. Examples of resource actions include:\r\n\r\n- Operations that manage credentials associated with a resource\r\n- Operations that calculate statistics about resources\r\n- Operations that make specific state changes to resources (power cycle, upgrade, etc.)\r\n\r\n#### Actions that take input and output\r\n\r\nOperations that manage credentials are a good example fo this category. TypeSpec defines synchronous and asynchronous templates for actions that consume and produce information.\r\n\r\n| Operation                    | TypeSpec                                                                       |\r\n| ---------------------------- | ------------------------------------------------------------------------------ |\r\n| Synchronous Resource Action  | `updateCredentials is ArmResourceActionSync<ResourceType, Request, Response>`  |\r\n| Asynchronous Resource Action | `updateCredentials is ArmResourceActionAsync<ResourceType, Request, Response>` |\r\n\r\nParameters to the template are the ResourceType, the model for the operation Request body, and the model for the operation Response body.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- |\n\nbody.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- | ------------------------------------------------------------------------------------- |\r\n| Synchronous NoContent Action  | `updateCredentials is ArmResourceActionNoContentSync<ResourceType, Request>`          |\r\n| Asynchronous NoContent Action | `updateCredentials is ArmResourceActionNoResponseContentAsync<ResourceType, Request>` |\r\n\r\nParameters to the template are the ResourceType and the model for the operation Request body.\n\n### Actions that take no input but produce output (data retrieval actions)\n\nSome operations return data or paged lists of data. TypeSpec does not yet provide templates for these kinds of actions, but here are two templates that you could reuse in your own specification, described in the next section of the document:\r\n\r\n- [Synchronous Resource List Actions](#synchronous-list-action)\r\n- [Asynchronous List Action](#asynchronous-list-action)\n\n### Check Name Operations\n\nSome services provide operations to check name availability, either location-specific (locally) or globally, especially if a resource name must be globally unique (such as when an exposed endpoint uses the resource name in the url).\r\n\r\n| Operation                      | TypeSpec                                                                                             |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------- |\r\n| Global Name Availability Check | `checkGlobalName is checkGlobalNameAvailability<TRequest, TResponse, TAdditionalParams>`             |\r\n| Local Name Availability Check  | `checkLocalName is checkLocalNameAvailability<TRequest, TResponse, TAdditionalParams>`               |\r\n| Custom Name Availability Check | `customNameCheck is checkNameAvailability<TScopeParameters, TRequest, TResponse, TAdditionalParams>` |\r\n\r\n`checkGlobalNameAvailability` and `checkLocalNameAvailability` have default values that allow them to be used without specifying any template parameters. `checkNameAvailability` requires the `TScopeParameters` template parameter, which describes the parameters which define the scope of the name check request. For reference, the following table shows the `TScopeParameters` for the standard templates:\r\n\r\n| Operation                      | Scope Parameters                                                       |\r\n| ------------------------------ | ---------------------------------------------------------------------- |\r\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\r\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\n\n## Writing Custom Operations\n\nTypeSpec operation templates provide a simple mechanism for producing the most common operation patterns in ARM, using best practices and conforming to ARM RPC guidelines. However, sometimes a service has special requirements for operations that fall outside these boundaries. The `Azure.ResourceManager.Foundations` namespace provides lower level building blocks that can be used to produce operations and operation templates.\r\n\r\nThe building blocks are described in the sections below:\n\n### ARM Response Types\n\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\r\n\r\n| Model                               | Code | Description                                   |\r\n| ----------------------------------- | ---- | --------------------------------------------- |\r\n| `ArmResponse<T>`                    | 200  | Base Arm 200 response.                        |\r\n| `ArmResourceUpdatedResponse<T>`     | 200  | Resource updated (PUT) response.              |\r\n| `ArmResourceCreatedResponse<T>`     | 201  | Resource created response for an lro.         |\r\n| `ArmResourceCreatedSyncResponse<T>` | 201  | Resource created synchronously.               |\r\n| `ArmAcceptedResponse`               | 202  | Base Arm Accepted response.                   |\r\n| `ArmNoContentResponse`              | 204  | Base Arm No Content response.                 |\r\n| `ArmDeletedResponse`                | 200  | Resource deleted response.                    |\r\n| `ArmDeleteAcceptedResponse`         | 202  | Resource deletion in progress response.       |\r\n| `ResourceListResult<T>`             | 200  | Return a list of resource with ARM pagination |\r\n| `ErrorResponse`                     | x    | Error response                                |\n\n### Common Operation Parameters\n\nThere are a number of model types which specify common parameters which are used in resource type operations:\r\n\r\n| Model                           | In           | Description                                                 |\r\n| ------------------------------- | ------------ | ----------------------------------------------------------- |\r\n| `ApiVersionParameter`           | query        | api-version parameter                                       |\r\n| `SubscriptionIdParameter`       | path         | Subscription ID path parameter                              |\r\n| `ResourceGroupNameParameter`    | path         | Resource Group Name path parameter                          |\r\n| `ResourceInstanceParameters<T>` | path & query | Identity parameters for a resource, with api-version        |\r\n| `ResourceParentParameters<T>`   | path & query | Identity Parameters for listing by parent, with api-version |\r\n| `ResourceUriParameter`          | path         | Resource uri path parameter for Extension resources         |\r\n| `OperationIdParameter`          | path         | Operation Id path parameter                                 |\n\n### Synchronous List Action\n\nHere is a sample template for resource list actions that return synchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionSync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionSync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n\n### Asynchronous List Action\n\nHere is a sample template for resource list actions that return asynchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionAsync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ArmAcceptedResponse | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionAsync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-resource-manager#reference#data-types.md\n- document_title: Data types\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types\n- document_content: # libraries#azure-resource-manager#reference#data-types.md\n\n# Data types\n\n## Azure.ResourceManager\n\n### `ArmAcceptedLroResponse` {#Azure.ResourceManager.ArmAcceptedLroResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmAcceptedLroResponse<Description, LroHeaders>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name        | Description                                                                        |\r\n| ----------- | ---------------------------------------------------------------------------------- |\r\n| Description | The description of the response status (defaults to `Resource operation accepted`) |\r\n| LroHeaders  | Optional. The lro headers that appear in the Accepted response                     |\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `202` | The status code. |\n\n### `ArmAcceptedResponse` {#Azure.ResourceManager.ArmAcceptedResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmAcceptedResponse<Message, ExtraHeaders>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name         | Description                                                                        |\r\n| ------------ | ---------------------------------------------------------------------------------- |\r\n| Message      | The description of the response status (defaults to `Resource operation accepted`) |\r\n| ExtraHeaders | Additional headers in the response. Default includes Retry-After header            |\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `202` | The status code. |\n\n### `ArmAsyncOperationHeader` {#Azure.ResourceManager.ArmAsyncOperationHeader}\n\nThe standard header for asynchronous operation polling\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmAsyncOperationHeader<StatusMonitor, UrlValue, FinalResult>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name          | Description                                       |\r\n| ------------- | ------------------------------------------------- |\r\n| StatusMonitor | The status monitor type for lro polling           |\r\n| UrlValue      | The value type of the Azure-AsyncOperation header |\r\n| FinalResult   | The logical final result of the operation         |\r\n\r\n#### Properties\r\n\r\n| Name                 | Type       | Description                  |\r\n| -------------------- | ---------- | ---------------------------- |\r\n| azureAsyncOperation? | `UrlValue` | A link to the status monitor |\n\n### `ArmCombinedLroHeaders` {#Azure.ResourceManager.ArmCombinedLroHeaders}\n\nProvide Both Azure-AsyncOperation and Location headers\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmCombinedLroHeaders<StatusMonitor, FinalResult, PollingUrlValue, FinalUrlValue>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name            | Description                                                                       |\r\n| --------------- | --------------------------------------------------------------------------------- |\r\n| StatusMonitor   | The type of the polling StatusMonitor when following the Azure-AsyncOperation url |\r\n| FinalResult     | The type of the logical result when following the location header                 |\r\n| PollingUrlValue | The value type of the link to the status monitor                                  |\r\n| FinalUrlValue   | The value type fo the link to the final result                                    |\r\n\r\n#### Properties\r\n\r\n| Name                 | Type              | Description                                                                                         |\r\n| -------------------- | ----------------- | --------------------------------------------------------------------------------------------------- |\r\n| azureAsyncOperation? | `PollingUrlValue` | A link to the status monitor                                                                        |\r\n| location?            | `FinalUrlValue`   | The Location header contains the URL where the status of the long running operation can be checked. |\n\n### `ArmCreatedResponse` {#Azure.ResourceManager.ArmCreatedResponse}\n\nThe Azure Resource Manager 201 response for a resource\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmCreatedResponse<ResponseBody, ExtraHeaders>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name         | Description                                                             |\r\n| ------------ | ----------------------------------------------------------------------- |\r\n| ResponseBody | The contents of the response body                                       |\r\n| ExtraHeaders | Additional headers in the response. Default includes Retry-After header |\r\n\r\n#### Properties\r\n\r\n| Name       | Type           | Description      |\r\n| ---------- | -------------- | ---------------- |\r\n| statusCode | `201`          | The status code. |\r\n| body       | `ResponseBody` |                  |\n\n### `ArmDeleteAcceptedLroResponse` {#Azure.ResourceManager.ArmDeleteAcceptedLroResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmDeleteAcceptedLroResponse<LroHeaders>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description                                                           |\r\n| ---------- | --------------------------------------------------------------------- |\r\n| LroHeaders | Optional. Allows overriding the Lro headers returned in the response. |\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `202` | The status code. |\n\n### `ArmDeleteAcceptedResponse` {#Azure.ResourceManager.ArmDeleteAcceptedResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmDeleteAcceptedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type    | Description                                                                                              |\r\n| ----------- | ------- | -------------------------------------------------------------------------------------------------------- |\r\n| statusCode  | `202`   | The status code.                                                                                         |\r\n| retryAfter? | `int32` | The Retry-After header can indicate how long the client should wait before polling the operation status. |\n\n### `ArmDeletedNoContentResponse` {#Azure.ResourceManager.ArmDeletedNoContentResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmDeletedNoContentResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `204` | The status code. |\n\n### `ArmDeletedResponse` {#Azure.ResourceManager.ArmDeletedResponse}\n\nThe response for synchronous delete of a resource\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmDeletedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `200` | The status code. |\n\n### `ArmLocationResource` {#Azure.ResourceManager.ArmLocationResource}\n\nTemplate for ARM location resources. Use the parameter to specify\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmLocationResource<BaseType>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description |\r\n| -------- | ----------- |\r\n| BaseType |             |\r\n\r\n#### Properties\r\n\r\n| Name     | Type                 | Description                   |\r\n| -------- | -------------------- | ----------------------------- |\r\n| location | `Core.azureLocation` | The name of the Azure region. |\n\n### `ArmLroLocationHeader` {#Azure.ResourceManager.ArmLroLocationHeader}\n\nThe default header for lro PUT and DELETE polling\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmLroLocationHeader<LroPollingOptions, FinalResult, UrlValue>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name              | Description                                                     |\r\n| ----------------- | --------------------------------------------------------------- |\r\n| LroPollingOptions | The polling options when polling the url in the location header |\r\n| FinalResult       | The ultimate final result of the logical operation              |\r\n| UrlValue          | The value type for the location header                          |\r\n\r\n#### Properties\r\n\r\n| Name      | Type       | Description                                                                                         |\r\n| --------- | ---------- | --------------------------------------------------------------------------------------------------- |\r\n| location? | `UrlValue` | The Location header contains the URL where the status of the long running operation can be checked. |\n\n### `ArmNoContentResponse` {#Azure.ResourceManager.ArmNoContentResponse}\n\nStandard Azure Resource Manager NoContent (204) response\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmNoContentResponse<Message>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name    | Description                                                                             |\r\n| ------- | --------------------------------------------------------------------------------------- |\r\n| Message | The description of the response status (defaults to `Operation completed successfully`) |\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `204` | The status code. |\n\n### `ArmOperationStatus` {#Azure.ResourceManager.ArmOperationStatus}\n\nStandard Azure Resource Manager operation status response\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmOperationStatus<Properties, StatusValues>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name         | Description                                    |\r\n| ------------ | ---------------------------------------------- |\r\n| Properties   | Optional resource-specific properties          |\r\n| StatusValues | The set of allowed values for operation status |\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                                                           | Description                                                                                                      |\r\n| ---------------- | ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------- |\r\n| properties?      | `Properties`                                                                   | RP-specific properties for the operationStatus resource, only appears when operation ended with Succeeded status |\r\n| status           | `StatusValues`                                                                 | The operation status                                                                                             |\r\n| id               | `string`                                                                       | The unique identifier for the operationStatus resource                                                           |\r\n| name?            | `string`                                                                       | The name of the operationStatus resource                                                                         |\r\n| startTime?       | `utcDateTime`                                                                  | Operation start time                                                                                             |\n\n|\r\n| name?            | `string`                                                                       | The name of the operationStatus resource                                                                         |\r\n| startTime?       | `utcDateTime`                                                                  | Operation start time                                                                                             |\r\n| endTime?         | `utcDateTime`                                                                  | Operation complete time                                                                                          |\r\n| percentComplete? | `float64`                                                                      | The progress made toward completing the operation                                                                |\r\n| error?           | [`ErrorDetail`](./data-types.md#Azure.ResourceManager.CommonTypes.ErrorDetail) | Errors that occurred if the operation ended with Canceled or Failed status                                       |\n\n### `ArmResourceCreatedResponse` {#Azure.ResourceManager.ArmResourceCreatedResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description                                                |\r\n| ---------- | ---------------------------------------------------------- |\r\n| Resource   | The resource being updated                                 |\r\n| LroHeaders | Optional. The lro headers returned with a Created response |\r\n\r\n#### Properties\r\n\r\n| Name       | Type       | Description      |\r\n| ---------- | ---------- | ---------------- |\r\n| statusCode | `201`      | The status code. |\r\n| body       | `Resource` |                  |\n\n### `ArmResourceCreatedSyncResponse` {#Azure.ResourceManager.ArmResourceCreatedSyncResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmResourceCreatedSyncResponse<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                |\r\n| -------- | -------------------------- |\r\n| Resource | The resource being updated |\r\n\r\n#### Properties\r\n\r\n| Name       | Type       | Description      |\r\n| ---------- | ---------- | ---------------- |\r\n| statusCode | `201`      | The status code. |\r\n| body       | `Resource` |                  |\n\n### `ArmResourceExistsResponse` {#Azure.ResourceManager.ArmResourceExistsResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmResourceExistsResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `204` | The status code. |\n\n### `ArmResourceNotFoundResponse` {#Azure.ResourceManager.ArmResourceNotFoundResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmResourceNotFoundResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `404` | The status code. |\n\n### `ArmResourceUpdatedResponse` {#Azure.ResourceManager.ArmResourceUpdatedResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmResourceUpdatedResponse<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                |\r\n| -------- | -------------------------- |\r\n| Resource | The resource being updated |\r\n\r\n#### Properties\r\n\r\n| Name       | Type       | Description      |\r\n| ---------- | ---------- | ---------------- |\r\n| statusCode | `200`      | The status code. |\r\n| body       | `Resource` |                  |\n\n### `ArmResponse` {#Azure.ResourceManager.ArmResponse}\n\nThe Azure Resource Manager synchronous OK response\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmResponse<ResponseBody>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name         | Description                       |\r\n| ------------ | --------------------------------- |\r\n| ResponseBody | The contents of the response body |\r\n\r\n#### Properties\r\n\r\n| Name       | Type           | Description      |\r\n| ---------- | -------------- | ---------------- |\r\n| statusCode | `200`          | The status code. |\r\n| body       | `ResponseBody` |                  |\n\n### `AvailabilityZonesProperty` {#Azure.ResourceManager.AvailabilityZonesProperty}\n\nModel representing the standard `zones` envelope property for a resource.\r\nSpread this model into a resource Model if the resource supports ARM `zones`.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.AvailabilityZonesProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typescript\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  ...AvailabilityZonesProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name   | Type       | Description             |\r\n| ------ | ---------- | ----------------------- |\r\n| zones? | `string[]` | The availability zones. |\n\n### `DefaultProvisioningStateProperty` {#Azure.ResourceManager.DefaultProvisioningStateProperty}\n\nStandard resource provisioning state model. If you do not have any custom provisioning state,\r\nyou can spread this model directly into your resource property model.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.DefaultProvisioningStateProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel FooProperties {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...DefaultProvisioningStateProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name               | Type                                                                                           | Description                             |\r\n| ------------------ | ---------------------------------------------------------------------------------------------- | --------------------------------------- |\r\n| provisioningState? | [`ResourceProvisioningState`](./data-types.md#Azure.ResourceManager.ResourceProvisioningState) | The provisioning state of the resource. |\n\n### `EncryptionProperty` {#Azure.ResourceManager.EncryptionProperty}\n\nModel used only to spread in the `encryption` envelope property for a resource.\r\nAll encryption configuration for a resource.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.EncryptionProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  ...Encryption;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type                                                                         | Description                                  |\r\n| ---------- | ---------------------------------------------------------------------------- | -------------------------------------------- |\r\n| encryption | [`Encryption`](./data-types.md#Azure.ResourceManager.CommonTypes.Encryption) | All encryption configuration for a resource. |\n\n### `EntityTagProperty` {#Azure.ResourceManager.EntityTagProperty}\n\nModel used only to spread in the standard `eTag` envelope property for a resource\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.EntityTagProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...EntityTagProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type     | Description                                                                                                                                                                                                                                                                                                                                                         |\r\n| ----- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| eTag? | `string` | If eTag is provided in the response body, it may also be provided as a header per the normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. |\n\n### `ExtendedLocationProperty` {#Azure.ResourceManager.ExtendedLocationProperty}\n\nModel representing the standard `extendedLocation` envelope property for a resource.\r\nSpread this model into a Resource Model, if the resource supports extended locations\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ExtendedLocationProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Employee is TrackedResource<EmployeeProperties> {\r\n  ...ResourceNameParameter<Employee>;\r\n  ...ExtendedLocationProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name              | Type                                                                                     | Description |\r\n| ----------------- | ---------------------------------------------------------------------------------------- | ----------- |\r\n| extendedLocation? | [`ExtendedLocation`](./data-types.md#Azure.ResourceManager.CommonTypes.ExtendedLocation) |             |\n\n### `ExtensionResource` {#Azure.ResourceManager.ExtensionResource}\n\nConcrete extension resource types can be created by aliasing this type using a specific property type.\r\n\r\nSee more details on [different Azure Resource Manager resource type here.](https://azure.github.io/typespec-azure/docs/howtos/ARM/resource-type)\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ExtensionResource<Properties, PropertiesOptional>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name               | Description                                                                                                                                    |\r\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Properties         | A model containing the provider-specific properties for this resource                                                                          |\r\n| PropertiesOptional | A boolean flag indicating whether the resource `Properties` field is marked as optional or required. Default true is optional and recommended. |\r\n\r\n#### Properties\r\n\r\n| Name        | Type         | Description |\r\n| ----------- | ------------ | ----------- |\r\n| properties? | `Properties` |             |\n\n### `KeysOf` {#Azure.ResourceManager.KeysOf}\n\nExtracts the key (path) parameters from a resource and its parents\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.KeysOf<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                             |\r\n| -------- | --------------------------------------- |\r\n| Resource | The resource to extract properties from |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `LocationParameter` {#Azure.ResourceManager.LocationParameter}\n\nDEPRECATED - DO NOT USE\r\nThe default location parameter type.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.LocationParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type     | Description        |\r\n| -------- | -------- | ------------------ |\r\n| location | `string` | The location name. |\n\n### `LocationResourceParameter` {#Azure.ResourceManager.LocationResourceParameter}\n\nThe default location parameter type.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.LocationResourceParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type                 | Description                   |\r\n| -------- | -------------------- | ----------------------------- |\r\n| location | `Core.azureLocation` | The name of the Azure region. |\n\n### `ManagedByProperty` {#Azure.ResourceManager.ManagedByProperty}\n\nModel representing the standard `managedBy` envelope property for a resource.\r\nSpread this model into a resource model if the resource is managed by another entity.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ManagedByProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...ManagedByProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type     | Description                                                                                                                                                                                                                                                                                        |\r\n| ---------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| managedBy? | `string` | The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another Azure resource. If this is present, complete mode deployment will not delete the resource if it is removed from the template since it is managed by another resource. |\n\n### `ManagedServiceIdentityProperty` {#Azure.ResourceManager.ManagedServiceIdentityProperty}\n\nModel representing the standard `ManagedServiceIdentity` envelope property for a resource.\r\nSpread this model into a resource model if the resource supports both system-assigned and user-assigned managed identities.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ManagedServiceIdentityProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  ...ResourceNameParameter<Foo>;\r\n  ...ManagedServiceIdentityProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name      | Type                                                                                                 | Description                                               |\r\n| --------- | ---------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |\r\n| identity? | [`ManagedServiceIdentity`](./data-types.md#Azure.ResourceManager.CommonTypes.ManagedServiceIdentity) | The managed service identities assigned to this resource. |\n\n### `ManagedSystemAssignedIdentityProperty` {#Azure.ResourceManager.ManagedSystemAssignedIdentityProperty}\n\nModel representing the standard `SystemAssignedServiceIdentity` envelope property for a resource.\r\nSpread this model into a resource model if the resource supports system-assigned managed identities\r\nbut does not support user-assigned managed identities.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ManagedSystemAssignedIdentityProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  ...ResourceNameParameter<Foo>;\r\n  ...ManagedSystemAssignedIdentityProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name      | Type                                                                                                               | Description                                               |\r\n| --------- | ------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------- |\r\n| identity? | [`SystemAssignedServiceIdentity`](./data-types.md#Azure.ResourceManager.CommonTypes.SystemAssignedServiceIdentity) | The managed service identities assigned to this resource. |\n\n### `ParentKeysOf` {#Azure.ResourceManager.ParentKeysOf}\n\nExtracts the key (path) parameters from the parent(s) of the given resource\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ParentKeysOf<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                             |\r\n| -------- | --------------------------------------- |\r\n| Resource | The resource to extract properties from |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `ProviderNamespace` {#Azure.ResourceManager.ProviderNamespace}\n\nModel describing the provider namespace.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ProviderNamespace<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                             |\r\n| -------- | --------------------------------------- |\r\n| Resource | The resource provided by the namespace. |\r\n\r\n#### Properties\r\n\r\n| Name     | Type                             | Description |\r\n| -------- | -------------------------------- | ----------- |\r\n| provider | `\"Microsoft.ThisWillBeReplaced\"` |             |\n\n### `ProxyResource` {#Azure.ResourceManager.ProxyResource}\n\nConcrete proxy resource types can be created by aliasing this type using a specific property type.\r\n\r\nSee more details on [different Azure Resource Manager resource type here.](https://azure.github.io/typespec-azure/docs/howtos/ARM/resource-type)\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ProxyResource<Properties, PropertiesOptional>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name               | Description                                                                                                                                    |\r\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Properties         | A model containing the provider-specific properties for this resource                                                                          |\r\n| PropertiesOptional | A boolean flag indicating whether the resource `Properties` field is marked as optional or required. Default true is optional and recommended. |\r\n\r\n#### Properties\r\n\r\n| Name        | Type         | Description |\r\n| ----------- | ------------ | ----------- |\r\n| properties? | `Properties` |             |\n\n### `ResourceGroupLocationResource` {#Azure.ResourceManager.ResourceGroupLocationResource}\n\nThe location resource for resourceGroup-based locations. This can be used as a parent\r\nresource for resource types that are homed in a resourceGroup-based location.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceGroupLocationResource\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type                 | Description                   |\r\n| -------- | -------------------- | ----------------------------- |\r\n| location | `Core.azureLocation` | The name of the Azure region. |\n\n### `ResourceInstanceParameters` {#Azure.ResourceManager.ResourceInstanceParameters}\n\nThe dynamic parameters of a resource instance - pass in the proper base type to indicate\r\nwhere the resource is based. The default is in a resource group\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceInstanceParameters<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                              |\r\n| -------------- | -------------------------------------------------------- |\r\n| Resource       | The resource to get parameters for                       |\r\n| BaseParameters | The parameters representing the base Uri of the resource |\r\n\r\n#### Properties\r\n\r\n| Name     | Type                             | Description |\r\n| -------- | -------------------------------- | ----------- |\r\n| provider | `\"Microsoft.ThisWillBeReplaced\"` |             |\n\n### `ResourceKindProperty` {#Azure.ResourceManager.ResourceKindProperty}\n\nModel representing the standard `kind` envelope property for a resource.\r\nSpread this model into a resource model if the resource support ARM `kind`.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceKindProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...ResourceKindProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type     | Description                                                                                                                                                                                                                           |\r\n| ----- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| kind? | `string` | Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type. If supported, the resource provider must validate and persist this value. |\n\n### `ResourceListCustomResult` {#Azure.ResourceManager.ResourceListCustomResult}\n\nPaged response containing results\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceListCustomResult<Result>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name   | Description                                           |\r\n| ------ | ----------------------------------------------------- |\r\n| Result | The type of the values returned in the paged response |\r\n\r\n#### Properties\r\n\r\n| Name      | Type             | Description                        |\r\n| --------- | ---------------- | ---------------------------------- |\r\n| value     | `Array<Element>` | The items on this page             |\r\n| nextLink? | `string`         | The link to the next page of items |\n\n### `ResourceListResult` {#Azure.ResourceManager.ResourceListResult}\n\nPaged response containing resources\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceListResult<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                                                                |\r\n| -------- | -------------------------------------------------------------------------- |\r\n| Resource | The type of the values returned in the paged response (must be a resource) |\r\n\r\n#### Properties\r\n\r\n| Name      | Type                             | Description |\r\n| --------- | -------------------------------- | ----------- |\r\n| value     | `Array<Element>`                 |             |\r\n| nextLink? | `TypeSpec.Rest.ResourceLocation` |             |\n\n### `ResourceNameParameter` {#Azure.ResourceManager.ResourceNameParameter}\n\nSpread this model into ARM resource models to specify resource name parameter for its operations. If `Resource` parameter\r\nis specified, the resource name will be properly camel cased and pluralized for `@key` and `@segment`\r\nautomatically. You can also apply explicit override with `KeyName` and `SegmentName` template parameters.\r\n\r\nFor additional decorators such as\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceNameParameter<Resource, KeyName, SegmentName, NamePattern, Type>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name        | Description                                                                                              |\r\n| ----------- | -------------------------------------------------------------------------------------------------------- |\r\n| Resource    | The ARM resource this name parameter is applying to.                                                     |\r\n| KeyName     | Override default key name of the resource.                                                               |\r\n| SegmentName | Override default segment name of the resource.                                                           |\r\n| NamePattern | The RegEx pattern of the name. Default is `^[a-zA-Z0-9-]{3,24}$`.                                        |\r\n| Type        | The type of the name property. Default type is string. However you can pass an union with string values. |\r\n\r\n#### Properties\r\n\r\n| Name | Type   | Description |\r\n| ---- | ------ | ----------- |\r\n| name | `Type` |             |\n\n### `ResourceParentParameters` {#Azure.ResourceManager.ResourceParentParameters}\n\nThe dynamic parameters of a list call for a resource instance - pass in the proper base type to indicate\r\nwhere the list should take place. The default is in a resource group\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceParentParameters<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                              |\r\n| -------------- | -------------------------------------------------------- |\r\n| Resource       | The resource to get parameters for                       |\r\n| BaseParameters | The parameters representing the base Uri of the resource |\r\n\r\n#### Properties\r\n\r\n| Name     | Type                             | Description |\r\n| -------- | -------------------------------- | ----------- |\r\n| provider | `\"Microsoft.ThisWillBeReplaced\"` |             |\n\n### `ResourcePlanProperty` {#Azure.ResourceManager.ResourcePlanProperty}\n\nModel representing the standard `plan` envelope property for a resource.\r\nSpread this model into a resource Model if the resource supports ARM `plan`.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourcePlanProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...ResourcePlanProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type                                                             | Description                   |\r\n| ----- | ---------------------------------------------------------------- | ----------------------------- |\r\n| plan? | [`Plan`](./data-types.md#Azure.ResourceManager.CommonTypes.Plan) | Details of the resource plan. |\n\n### `ResourceSkuProperty` {#Azure.ResourceManager.ResourceSkuProperty}\n\nModel representing the standard `sku` envelope property for a resource.\r\nSpread this model into a resource model if the resource supports standard ARM `sku`.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceSkuProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...ResourceSkuProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type                                                           | Description                                             |\r\n| ---- | -------------------------------------------------------------- | ------------------------------------------------------- |\r\n| sku? | [`Sku`](./data-types.md#Azure.ResourceManager.CommonTypes.Sku) | The SKU (Stock Keeping Unit) assigned to this resource. |\n\n### `ResourceUriParameter` {#Azure.ResourceManager.ResourceUriParameter}\n\nThe default resourceUri parameter type.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceUriParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type     | Description                                                            |\r\n| ----------- | -------- | ---------------------------------------------------------------------- |\r\n| resourceUri | `string` | The fully qualified Azure Resource manager identifier of the resource. |\n\n### `SubscriptionActionScope` {#Azure.ResourceManager.SubscriptionActionScope}\n\nTemplate used by ArmProviderAction templates.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.SubscriptionActionScope\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type     | Description            |\r\n| ---- | -------- | ---------------------- |\r\n| name | `string` | Symbolic name of scope |\n\n### `SubscriptionLocationResource` {#Azure.ResourceManager.SubscriptionLocationResource}\n\nThe location resource for subscription-based locations. This can be used as a parent\r\nresource for resource types that are homed in a subscription-based location.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.SubscriptionLocationResource\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type                 | Description                   |\r\n| -------- | -------------------- | ----------------------------- |\r\n| location | `Core.azureLocation` | The name of the Azure region. |\n\n### `TenantActionScope` {#Azure.ResourceManager.TenantActionScope}\n\nTemplate used by ArmTenantAction templates.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.TenantActionScope\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type     | Description            |\r\n| ---- | -------- | ---------------------- |\r\n| name | `string` | Symbolic name of scope |\n\n### `TenantLocationResource` {#Azure.ResourceManager.TenantLocationResource}\n\nThe location resource for tenant-based locations. This can be used as a parent\r\nresource for resource types that are homed in a tenant-based location.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.TenantLocationResource\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type                 | Description                   |\r\n| -------- | -------------------- | ----------------------------- |\r\n| location | `Core.azureLocation` | The name of the Azure region. |\n\n### `TrackedResource` {#Azure.ResourceManager.TrackedResource}\n\nConcrete tracked resource types can be created by aliasing this type using a specific property type.\r\n\r\nSee more details on [different Azure Resource Manager resource type here.](https://azure.github.io/typespec-azure/docs/howtos/ARM/resource-type)\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.TrackedResource<Properties, PropertiesOptional>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name               | Description                                                                                                                                    |\r\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Properties         | A model containing the provider-specific properties for this resource                                                                          |\r\n| PropertiesOptional | A boolean flag indicating whether the resource `Properties` field is marked as optional or required. Default true is optional and recommended. |\r\n\r\n#### Properties\r\n\r\n| Name        | Type         | Description |\r\n| ----------- | ------------ | ----------- |\r\n| properties? | `Properties` |             |\n", "latency": 31.421327829360962, "response_length": 2522}
{"query": "title: Date-times in TypeSpec\n\nquestion: https://typespec.io/docs/language-basics/built-in-types/#date-and-time-types isn't clear on the actual string formats of date-times. It seems to imply that `utcDateTime` use either RFC3339 or ISO8601 by the format (note: those two are not equivalent but close; REST API Guidelines recommend RFC3339), and `offsetDateTime` is RFC1123-like. The month isn't abbreviated though, maybe that's not strictly required. But the presence of \"utc\" or \"offset\" can't be all that dictates RFC1123 vs. RFC3339, can it? After all, either of those RFCs support GMT/UTC or offset TZs.", "ground_truth": "In TypeSpec, utcDateTime and offsetDateTime are conceptual types and do not enforce a specific serialization format. The actual serialization is determined by the emitter (e.g., OpenAPI, language SDK emitters). By default, emitters serialize date-time values in the body using RFC3339, and in headers using RFC1123 (technically RFC7231).\nTo override these defaults, you can use the @encode decorator to explicitly specify the format.\nWhile these defaults align with common HTTP and Azure service practices, the documentation does not clearly surface this behavior, making it harder for developers to understand or discover. The community is working to improve the documentation to clarify the defaults per emitter and protocol.", "response": "In TypeSpec, the `utcDateTime` and `offsetDateTime` types are both serialized as strings in OpenAPI with the `date-time` format. By default, both types follow the RFC 3339 standard for date-time representation. However, TypeSpec allows customization of the encoding format using the `@encode` decorator. For example:\n\n- `utcDateTime` can be encoded as RFC 3339 (`@encode(\"rfc3339\", string)`) or as a Unix timestamp (`@encode(\"unixTimestamp\", int32)`).\n- `offsetDateTime` can also use RFC 3339 or other formats like RFC 7231 (`@encode(\"rfc7231\", string)`).\n\nThe distinction between `utcDateTime` and `offsetDateTime` lies in their semantic meaning:\n- `utcDateTime` represents an instant in Coordinated Universal Time (UTC).\n- `offsetDateTime` represents a date-time with a specific time zone offset.\n\nBoth RFC 3339 and RFC 7231 support UTC and offset time zones, but the choice of format depends on the specific encoding applied. Without explicit encoding, the default is RFC 3339 for both types.", "context": "- document_dir: typespec_docs\n- document_filename: standard-library#built-in-data-types.md\n- document_title: Built-in Data types\n- document_link: https://typespec.io/docs/standard-library/built-in-data-types\n- document_content: # standard-library#built-in-data-types.md\n\n# Built-in Data types\n\n## TypeSpec\n\n### `Array` {#Array}\n\n```typespec\r\nmodel Array<Element>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Element | The type of the array elements |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `Create` {#Create}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Create\" resource lifecycle phase.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Create` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Create<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model has only the `name` field.\r\nmodel CreateDog is Create<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `CreateOrUpdate` {#CreateOrUpdate}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Create\" or \"Update\" resource lifecycle phases.\r\n\r\nThe \"CreateOrUpdate\" lifecycle phase is used by default for properties passed as parameters to operations\r\nthat can create _or_ update data, like HTTP PUT operations.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Create` or `Lifecycle.Update` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel CreateOrUpdate<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create)\r\n  immutableSecret: string;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model will have the `immutableSecret`, `secretName`, and `name` fields, but not the `id` field.\r\nmodel CreateOrUpdateDog is CreateOrUpdate<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `DefaultKeyVisibility` {#DefaultKeyVisibility}\n\nApplies a visibility setting to a collection of properties.\r\n```typespec\r\nmodel DefaultKeyVisibility<Source, Visibility>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose properties are spread. |\r\n| Visibility | The visibility to apply to all properties. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `Delete` {#Delete}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Delete\" resource lifecycle phase.\r\n\r\nThe \"Delete\" lifecycle phase is used for properties passed as parameters to operations\r\nthat delete data, like HTTP DELETE operations.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Delete` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Delete<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // Set when the Dog is removed from our data store. This happens when the\r\n  // Dog is re-homed to a new owner.\r\n  @visibility(Lifecycle.Delete)\r\n  nextOwner: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model will have the `nextOwner` and `name` fields, but not the `id` field.\r\nmodel DeleteDog is Delete<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `DiscriminatedOptions` {#DiscriminatedOptions}\n\nOptions for `@discriminated` decorator.\r\n```typespec\r\nmodel DiscriminatedOptions\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| envelope? | `\"object\" \\| \"none\"` | How is the discriminated union serialized. |\r\n| discriminatorPropertyName? | [`string`](#string) | Name of the discriminator property |\r\n| envelopePropertyName? | [`string`](#string) | Name of the property envelopping the data |\n\n### `ExampleOptions` {#ExampleOptions}\n\nOptions for example decorators\r\n```typespec\r\nmodel ExampleOptions\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| title? | [`string`](#string) | The title of the example |\r\n| description? | [`string`](#string) | Description of the example |\n\n### `OmitDefaults` {#OmitDefaults}\n\nRepresents a collection of properties with default values omitted.\r\n```typespec\r\nmodel OmitDefaults<Source>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose spread property defaults are all omitted. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `OmitProperties` {#OmitProperties}\n\nRepresents a collection of omitted properties.\r\n```typespec\r\nmodel OmitProperties<Source, Keys>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose properties are spread. |\r\n| Keys | The property keys to omit. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `OperationExample` {#OperationExample}\n\nOperation example configuration.\r\n```typespec\r\nmodel OperationExample\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| parameters? | `unknown` | Example request body. |\r\n| returnType? | `unknown` | Example response body. |\n\n### `OptionalProperties` {#OptionalProperties}\n\nRepresents a collection of optional properties.\r\n```typespec\r\nmodel OptionalProperties<Source>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose spread properties are all optional. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `PickProperties` {#PickProperties}\n\nRepresents a collection of properties with only the specified keys included.\r\n```typespec\r\nmodel PickProperties<Source, Keys>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose properties are spread. |\r\n| Keys | The property keys to include. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `Query` {#Query}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Query\" resource lifecycle phase.\r\n\r\nThe \"Query\" lifecycle phase is used for properties passed as parameters to operations\r\nthat read data, like HTTP GET or HEAD operations. This should not be confused for\r\nthe `@query` decorator, which specifies that the property is transmitted in the\r\nquery string of an HTTP request.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Query` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Query<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  // When getting information for a Dog, you can set this field to true to include\r\n  // some extra information about the Dog's pedigree that is normally not returned.\r\n  // Alternatively, you could just use a separate option parameter to get this\r\n  // information.\r\n  @visibility(Lifecycle.Query)\r\n  includePedigree?: boolean;\r\n\r\n  name: string;\r\n\r\n  // Only included if `includePedigree` is set to true in the request.\r\n  @visibility(Lifecycle.Read)\r\n  pedigree?: string;\r\n}\r\n\r\n// This model will have the `includePedigree` and `name` fields, but not `id` or `pedigree`.\r\nmodel QueryDog is Query<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `Read` {#Read}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Read\" resource lifecycle phase.\r\n\r\nThe \"Read\" lifecycle phase is used for properties returned by operations that read data, like\r\nHTTP GET operations.\r\n\r\nThis transformation is recursive, and will include only properties that have the\r\n`Lifecycle.Read` visibility modifier.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Read<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model has the `id` and `name` fields, but not `secretName`.\r\nmodel ReadDog is Read<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `Record` {#Record}\n\n```typespec\r\nmodel Record<Element>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Element | The type of the properties |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `ServiceOptions` {#ServiceOptions}\n\nService options.\r\n```typespec\r\nmodel ServiceOptions\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| title? | [`string`](#string) | Title of the service. |\r\n| version? | [`string`](#string) | Version of the service. |\n\n### `Update` {#Update}\n\nA copy of the input model `T` with only the properties that are visible during the\r\n\"Update\" resource lifecycle phase.\r\n\r\nThe \"Update\" lifecycle phase is used for properties passed as parameters to operations\r\nthat update data, like HTTP PATCH operations.\r\n\r\nThis transformation will include only the properties that have the `Lifecycle.Update`\r\nvisibility modifier, and the types of all properties will be replaced with the\r\nequivalent `CreateOrUpdate` transformation.\r\n\r\nIf a `NameTemplate` is provided, the new model will be named according to the template.\r\nThe template uses the same syntax as the `@friendlyName` decorator.\r\n```typespec\r\nmodel Update<T, NameTemplate>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| T | The model to transform. |\r\n| NameTemplate | The name template to use for the new model.<br /><br />* |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n  @visibility(Lifecycle.Read)\r\n  id: int32;\r\n\r\n  @visibility(Lifecycle.Create, Lifecycle.Update)\r\n  secretName: string;\r\n\r\n  name: string;\r\n}\r\n\r\n// This model will have the `secretName` and `name` fields, but not the `id` field.\r\nmodel UpdateDog is Update<Dog>;\r\n```\r\n\r\n#### Properties\r\nNone\n\n### `UpdateableProperties` {#UpdateableProperties}\n\nRepresents a collection of updateable properties.\r\n```typespec\r\nmodel UpdateableProperties<Source>\r\n```\r\n\r\n#### Template Parameters\r\n| Name | Description |\r\n|------|-------------|\r\n| Source | An object whose spread properties are all updateable. |\r\n\r\n\r\n#### Properties\r\nNone\n\n### `VisibilityFilter` {#VisibilityFilter}\n\nA visibility filter, used to specify which properties should be included when\r\nusing the `withVisibilityFilter` decorator.\r\n\r\nThe filter matches any property with ALL of the following:\r\n- If the `any` key is present, the property must have at least one of the specified visibilities.\r\n- If the `all` key is present, the property must have all of the specified visibilities.\r\n- If the `none` key is present, the property must have none of the specified visibilities.\r\n```typespec\r\nmodel VisibilityFilter\r\n```\r\n\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| any? | `EnumMember[]` |  |\r\n| all? | `EnumMember[]` |  |\r\n| none? | `EnumMember[]` |  |\n\n### `ArrayEncoding` {#ArrayEncoding}\n\nEncoding for serializing arrays\r\n```typespec\r\nenum ArrayEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| pipeDelimited |  | Each values of the array is separated by a \\| |\r\n| spaceDelimited |  | Each values of the array is separated by a <space> |\n\n### `BytesKnownEncoding` {#BytesKnownEncoding}\n\nKnown encoding to use on bytes\r\n```typespec\r\nenum BytesKnownEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| base64 | `\"base64\"` | Encode to Base64 |\r\n| base64url | `\"base64url\"` | Encode to Base64 Url |\n\n### `DateTimeKnownEncoding` {#DateTimeKnownEncoding}\n\nKnown encoding to use on utcDateTime or offsetDateTime\r\n```typespec\r\nenum DateTimeKnownEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| rfc3339 | `\"rfc3339\"` | RFC 3339 standard. https://www.ietf.org/rfc/rfc3339.txt<br />Encode to string. |\r\n| rfc7231 | `\"rfc7231\"` | RFC 7231 standard. https://www.ietf.org/rfc/rfc7231.txt<br />Encode to string. |\r\n| unixTimestamp | `\"unixTimestamp\"` | Encode a datetime to a unix timestamp.<br />Unix timestamps are represented as an integer number of seconds since the Unix epoch and usually encoded as an int32. |\n\n### `DurationKnownEncoding` {#DurationKnownEncoding}\n\nKnown encoding to use on duration\r\n```typespec\r\nenum DurationKnownEncoding\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| ISO8601 | `\"ISO8601\"` | ISO8601 duration |\r\n| seconds | `\"seconds\"` | Encode to integer or float |\n\n### `Lifecycle` {#Lifecycle}\n\nA visibility class for resource lifecycle phases.\r\n\r\nThese visibilities control whether a property is visible during the various phases of a resource's lifecycle.\r\n```typespec\r\nenum Lifecycle\r\n```\r\n\r\n| Name | Value | Description |\r\n|------|-------|-------------|\r\n| Create |  | The property is visible when a resource is being created. |\r\n| Read |  | The property is visible when a resource is being read. |\r\n| Update |  | The property is visible when a resource is being updated. |\r\n| Delete |  | The property is visible when a resource is being deleted. |\r\n| Query |  | The property is visible when a resource is being queried.<br /><br />In HTTP APIs, this visibility applies to parameters of GET or HEAD operations. |\r\n#### Examples\r\n\r\n```typespec\r\nmodel Dog {\r\n @visibility(Lifecycle.Read)\r\n id: int32;\r\n\r\n @visibility(Lifecycle.Create, Lifecycle.Update)\r\n secretName: string;\r\n\r\n name: string;\r\n}\r\n```\r\n\r\nIn this example, the `id` property is only visible during the read phase, and the `secretName` property is only visible\r\nduring the create and update phases. This means that the server will return the `id` property when returning a `Dog`,\r\nbut the client will not be able to set or update it. In contrast, the `secretName` property can be set when creating\r\nor updating a `Dog`, but the server will never return it. The `name` property has no visibility modifiers and is\r\ntherefore visible in all phases.\n\n### `boolean` {#boolean}\n\nBoolean with `true` and `false` values.\r\n```typespec\r\nscalar boolean\r\n```\n\n### `bytes` {#bytes}\n\nRepresent a byte array\r\n```typespec\r\nscalar bytes\r\n```\n\n### `decimal` {#decimal}\n\nA decimal number with any length and precision. This represent any `decimal` value possible.\r\nIt is commonly represented as `BigDecimal` in some languages.\r\n```typespec\r\nscalar decimal\r\n```\n\n### `decimal128` {#decimal128}\n\nA 128-bit decimal number.\r\n```typespec\r\nscalar decimal128\r\n```\n\n### `duration` {#duration}\n\nA duration/time period. e.g 5s, 10h\r\n```typespec\r\nscalar duration\r\n```\n\n### `float` {#float}\n\nA number with decimal value\r\n```typespec\r\nscalar float\r\n```\n\n### `float32` {#float32}\n\nA 32 bit floating point number. (`1.5 x 10^45` to `3.4 x 10^38`)\r\n```typespec\r\nscalar float32\r\n```\n\n### `float64` {#float64}\n\nA 64 bit floating point number. (`5.0  10^324` to `1.7  10^308`)\r\n```typespec\r\nscalar float64\r\n```\n\n### `int16` {#int16}\n\nA 16-bit integer. (`-32,768` to `32,767`)\r\n```typespec\r\nscalar int16\r\n```\n\n### `int32` {#int32}\n\nA 32-bit integer. (`-2,147,483,648` to `2,147,483,647`)\r\n```typespec\r\nscalar int32\r\n```\n\n### `int64` {#int64}\n\nA 64-bit integer. (`-9,223,372,036,854,775,808` to `9,223,372,036,854,775,807`)\r\n```typespec\r\nscalar int64\r\n```\n\n### `int8` {#int8}\n\nA 8-bit integer. (`-128` to `127`)\r\n```typespec\r\nscalar int8\r\n```\n\n### `integer` {#integer}\n\nA whole number. This represent any `integer` value possible.\r\nIt is commonly represented as `BigInteger` in some languages.\r\n```typespec\r\nscalar integer\r\n```\n\n### `numeric` {#numeric}\n\nA numeric type\r\n```typespec\r\nscalar numeric\r\n```\n\n### `offsetDateTime` {#offsetDateTime}\n\nA date and time in a particular time zone, e.g. \"April 10th at 3:00am in PST\"\r\n```typespec\r\nscalar offsetDateTime\r\n```\n\n### `plainDate` {#plainDate}\n\nA date on a calendar without a time zone, e.g. \"April 10th\"\r\n```typespec\r\nscalar plainDate\r\n```\n\n### `plainTime` {#plainTime}\n\nA time on a clock without a time zone, e.g. \"3:00 am\"\r\n```typespec\r\nscalar plainTime\r\n```\n\n### `safeint` {#safeint}\n\nAn integer that can be serialized to JSON (`9007199254740991 ((2^53  1))` to `9007199254740991 (2^53  1)` )\r\n```typespec\r\nscalar safeint\r\n```\n\n### `string` {#string}\n\nA sequence of textual characters.\r\n```typespec\r\nscalar string\r\n```\n\n### `uint16` {#uint16}\n\nA 16-bit unsigned integer (`0` to `65,535`)\r\n```typespec\r\nscalar uint16\r\n```\n\n### `uint32` {#uint32}\n\nA 32-bit unsigned integer (`0` to `4,294,967,295`)\r\n```typespec\r\nscalar uint32\r\n```\n\n### `uint64` {#uint64}\n\nA 64-bit unsigned integer (`0` to `18,446,744,073,709,551,615`)\r\n```typespec\r\nscalar uint64\r\n```\n\n### `uint8` {#uint8}\n\nA 8-bit unsigned integer (`0` to `255`)\r\n```typespec\r\nscalar uint8\r\n```\n\n### `unixTimestamp32` {#unixTimestamp32}\n\nRepresent a 32-bit unix timestamp datetime with 1s of granularity.\r\nIt measures time by the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970.\r\n```typespec\r\nscalar unixTimestamp32\r\n```\n\n### `url` {#url}\n\nRepresent a URL string as described by https://url.spec.whatwg.org/\r\n```typespec\r\nscalar url\r\n```\n\n### `utcDateTime` {#utcDateTime}\n\nAn instant in coordinated universal time (UTC)\"\r\n```typespec\r\nscalar utcDateTime\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#openapi3#openapi.md\n- document_title: OpenAPI v3 emitter\n- document_link: https://typespec.io/docs/emitters/openapi3/openapi\n- document_content: # emitters#openapi3#openapi.md\n\n# OpenAPI v3 emitter\n\nThe OpenAPI emitter translates TypeSpec language elements into their equivalent OpenAPI expressions. This guide explains how TypeSpec constructs are mapped to OpenAPI components.\r\n\r\n**Note**: The below documentation generally refers to the behavior of the OpenAPI v3 emitter when using OpenAPI version 3.0. Emitter output for version 3.1 may be slightly different according to additional features supported in 3.1 but not in 3.0.\n\n## Server Details\n\nWhen your TypeSpec file includes an [(HTTP) `@server` decorator](../../libraries/http/reference/decorators.md#@TypeSpec.Http.server), the OpenAPI emitter will generate a `servers` object in the resulting OpenAPI document. This object contains the server URL, description, and any variables defined in the decorator.\r\n\r\nYou can apply multiple `@server` decorators to create multiple entries in the `servers` array:\r\n\r\n```typespec\r\n@server(\"https://api.example.com/v1\", \"Primary production endpoint\")\r\n@server(\"https://api-dev.example.com/v1\", \"Development endpoint\")\r\nnamespace MyService;\r\n```\n\n## Operations\n\nEach TypeSpec operation is converted into an OpenAPI operation.\n\n### HTTP Method\n\nYou can explicitly specify the HTTP method using one of the [(HTTP) decorators][http-verb-decorators]:\r\n\r\n- `@get`\r\n- `@post`\r\n- `@put`\r\n- `@patch`\r\n- `@delete`\r\n\r\nIf you don't specify a method, the emitter will infer it from the operation name and signature.\r\n\r\n```typespec\r\n// Explicitly declared as GET /{id}\r\n@get\r\nop getUser(@path id: string): User;\r\n\r\n// Explicitly declared as POST /\r\n@post\r\nop createUser(user: User): User;\r\n\r\n// Automatically detected as GET /{id}\r\nop getUser(@path id: string): User;\r\n\r\n// Automatically detected as POST /\r\nop createUser(user: User): User;\r\n```\n\n### Operation Path\n\nThe path for an operation comes from the [(HTTP) `@route` decorator][http-route-decorator]. You can apply `@route` to:\r\n\r\n- Individual operations\r\n- Interfaces (groups of operations)\r\n- Namespaces\r\n\r\nWhen you apply routes to multiple levels, they're combined to form the complete path:\r\n\r\n```typespec\r\n@route(\"/api\")\r\nnamespace MyService {\r\n  @route(\"/users\")\r\n  interface Users {\r\n    // Results in GET /api/users/{id}\r\n    @route(\"/{id}\")\r\n    @get\r\n    getUser(@path id: string): User;\r\n  }\r\n}\r\n```\r\n\r\n[http-verb-decorators]: ../../libraries/http/reference/decorators.md\r\n[http-route-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.route\r\n\r\nThe [OpenAPI Operation object][openapi-operation-object] fields are populated as described in the following sections.\r\n\r\n[openapi-operation-object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operationObject\n\n### Description\n\nThe operation's description comes from the documentation of the TypeSpec operation.\r\n\r\nDocumentation is provided either by a documentation comment or by the [(built-in) `@doc` decorator][doc-decorator] (the two are equivalent):\r\n\r\n```typespec\r\n/**\r\n * Retrieves a user by their unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n\r\n@doc(\"Retrieves a user by their unique identifier.\")\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nIf no documentation is provided, the description field is omitted.\r\n\r\n[doc-decorator]: ../../standard-library/built-in-decorators.md#@doc\n\n### Summary\n\nThe operation's summary comes from the [(built-in) `@summary` decorator][summary-decorator]:\r\n\r\n```typespec\r\n/**\r\n * Retrieves a user by their unique identifier.\r\n */\r\n@summary(\"Get a User by ID.\")\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nIf no `@summary` is provided, the summary field is omitted.\r\n\r\n[summary-decorator]: ../../standard-library/built-in-decorators.md#@summary\n\n### Operation ID\n\nThe operation ID can be explicitly set using the [(OpenAPI) `@operationId` decorator][openapi-operation-decorator]:\r\n\r\n```typespec\r\n@operationId(\"getUserById\")\r\nop getUser(id: string): User;\r\n```\r\n\r\nIf not explicitly defined, the operation ID defaults to:\r\n\r\n- The operation name (when the operation is not in an interface)\r\n- The interface name followed by the operation name (when in an interface)\r\n\r\n[openapi-operation-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.operationId\n\n### Parameters and Request Body\n\nTypeSpec operation parameters map to OpenAPI parameters and request body.\r\n\r\n#### Parameter Location\r\n\r\nYou specify where a parameter appears using these [(HTTP) decorators][http-parameter-decorators]:\r\n\r\n- `@query` - Query parameter in the URL\r\n- `@header` - HTTP header parameter\r\n- `@path` - Path parameter in the URL\r\n\r\nParameters without these decorators are assumed to be in the request body.\r\n\r\n```typespec\r\nop createUser(\r\n  // The parameter name is transformed to look like an HTTP header, so the parameter `contentType` maps\r\n  // to the `content-type` header\r\n  @header contentType: string,\r\n\r\n  @query include: string,\r\n  @path id: string,\r\n\r\n  // The request body will be a JSON object `{ \"user\": <User> }`\r\n  user: User, // This goes in the request body\r\n): User;\r\n```\r\n\r\n#### Request Body\r\n\r\nYou can explicitly mark a parameter as the request body using the [(HTTP) `@body` decorator][http-body-decorator]:\r\n\r\n```typespec\r\n// The request body will be a JSON object that _only_ contains the User at the top level.\r\nop createUser(@body user: User): User;\r\n```\r\n\r\nIf `@body` is not used, all parameters not marked with `@header`, `@query`, or `@path` form the request body, which is marked as required. To make the request body optional, declare it with an optional property and the `@body` decorator:\r\n\r\n```typespec\r\nop updateUser(@path id: string, @body user?: User): User;\r\n```\r\n\r\n[http-parameter-decorators]: ../../libraries/http/reference/decorators.md\r\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\r\n\r\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\r\n\r\n```typespec\r\n/**\r\n * Retrieves the User by their unique identifier.\r\n *\r\n * @param id The user's unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nThe content type for request bodies follows the [default content-type resolution logic](../..\n\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\r\n\r\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\r\n\r\n```typespec\r\n/**\r\n * Retrieves the User by their unique identifier.\r\n *\r\n * @param id The user's unique identifier.\r\n */\r\nop getUser(@path id: string): User;\r\n```\r\n\r\nThe content type for request bodies follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\r\n\r\nFor more advanced parameter configuration, see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\n\n### Responses\n\nstatus code is 200, the body will be just a JSON User at the top level.\r\n  @body user: User;\r\n}\r\n\r\nmodel NotFound {\r\n  @statusCode code: 404;\r\n\r\n  // If the status code is 404, the body will be a JSON object `{ \"message\": <string> }`\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | NotFound;\r\n```\r\n\r\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\r\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\r\n\r\nThe content type for responses follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\r\n\r\nFor more advanced response configuration, see see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\n\nThe operation's return type(s) translate into OpenAPI responses.\r\n\r\n#### Status Codes\r\n\r\nYou can specify a status code using the [(HTTP) `@statusCode` decorator][http-statuscode-decorator] on a property in the return type:\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode\r\n  code: 200;\r\n\r\n  body: User;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse;\r\n```\r\n\r\nYou can define multiple response types to handle different status codes:\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode\r\n  code: 200;\r\n\r\n  user: User;\r\n}\r\n\r\nmodel UserNotFoundResponse {\r\n  @statusCode\r\n  code: 404;\r\n\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | UserNotFoundResponse;\r\n```\r\n\r\n#### Error Responses\r\n\r\nUse the [(built-in) `@error` decorator][error-decorator] to indicate an error response, which becomes the \"default\" response in OpenAPI. To indicate that an operation returns a successful response or an error, simply use the error response type in a union with a non-error type:\r\n\r\n```typespec\r\n@error\r\nmodel ErrorResponse {\r\n  @statusCode\r\n  code: 404 | 500;\r\n\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): User | ErrorResponse;\r\n```\r\n\r\n#### Response Body\r\n\r\nThe response body can be explicitly marked with the `@body` decorator. Otherwise, any properties not marked with `@statusCode` or `@header` form the response body.\r\n\r\n```typespec\r\nmodel UserResponse {\r\n  @statusCode code: 200;\r\n\r\n  // If the status code is 200, the body will be just a JSON User at the top level.\r\n  @body user: User;\r\n}\r\n\r\nmodel NotFound {\r\n  @statusCode code: 404;\r\n\r\n  // If the status code is 404, the body will be a JSON object `{ \"message\": <string> }`\r\n  message: string;\r\n}\r\n\r\nop getUser(@path id: string): UserResponse | NotFound;\r\n```\r\n\r\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\r\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\n\n### Tags\n\nUse the [(built-in) `@tag` decorator][tag-decorator] to apply tag groups to operations that will be represented in the generated OpenAPI and OpenAPI-based documentation tools such as Swagger UI:\r\n\r\n```typespec\r\n@tag(\"Users\")\r\nop getUser(id: string): User;\r\n\r\n// Or at interface/namespace level\r\n@tag(\"Users\")\r\ninterface UserOperations {\r\n  getUser(id: string): User;\r\n  createUser(@body user: User): User;\r\n}\r\n```\r\n\r\nTags from operations, interfaces, and enclosing namespaces are combined.\r\n\r\n[tag-decorator]: ../../standard-library/built-in-decorators.md#@tag\n\n### Deprecated\n\nMark an operation as deprecated using the (built-in) `#deprecated` directive.\r\n\r\n```typespec\r\n#deprecated \"Use getUser instead\"\r\nop fetchUser(id: string): User;\r\n```\r\n\r\nThis sets the `deprecated` field to `true` in the OpenAPI operation.\n\n### External Documentation\n\nAdd external documentation links using the [(OpenAPI) `@externalDocs` decorator](../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.externalDocs):\r\n\r\n```typespec\r\n@externalDocs(\"https://example.com/docs/users\", \"Additional user documentation\")\r\nop getUser(id: string): User;\r\n```\r\n\r\nThe external documentation links are specific to the OpenAPI emitter and will not be used by any other emitters unless they are designed to interoperate with OpenAPI.\n\n### Specification Extensions\n\nAdd custom OpenAPI extensions for your use cases using the [(OpenAPI) `@extension` decorator][openapi-extension-decorator].\r\n\r\n```typespec\r\n@extension(\"x-ms-pageable\", #{ nextLinkName: \"nextLink\" })\r\nop listUsers(): UserList;\r\n```\r\n\r\nThe first argument to `@extension` becomes a key in the operation object, and the second argument is any JSON/YAML-like value. This decorator may be used to add arbitrary customization/extension to many OpenAPI constructs including schemas for TypeSpec types, operations, etc.\r\n\r\n[openapi-extension-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.extension\n\n## Models and Enums\n\nTypeSpec models and enums convert to OpenAPI schemas.\n\n### Schema Location\n\nModels are handled differently based on how they're defined:\r\n\r\n- **Named models**: defined in `components/schemas` section.\r\n- **Inline models**: defined inline where used.\r\n- **Template instances**: treated as inline unless they have a [(built-in) `@friendlyName` decorator][friendlyname], which causes them to be treated as named models.\r\n\r\n[friendlyname]: ../../standard-library/built-in-decorators.md#@friendlyName\n\n### Type Mapping\n\nThis table shows how TypeSpec types map to OpenAPI/JSON Schema types:\r\n\r\n| TypeSpec type    | OpenAPI `type`/`format`           | Notes                                                                     |\r\n| ---------------- | --------------------------------- | ------------------------------------------------------------------------- |\r\n| `int32`          | `type: integer, format: int32`    |                                                                           |\r\n| `int64`          | `type: integer, format: int64`    |                                                                           |\r\n| `float32`        | `type: number, format: float`     |                                                                           |\r\n| `float64`        | `type: number, format: double`    |                                                                           |\r\n| `string`         | `type: string`                    |                                                                           |\r\n| `bytes`          | `type: string, format: byte`      | for content-type == 'application/json' or 'text/plain'                    |\r\n| `bytes`          | `type: string, format: binary`    | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `boolean`        | `type: boolean`                   |                                                                           |\r\n| `plainDate`      | `type: string, format: date`      |                                                                           |\r\n| `utcDateTime`    | `type: string, format: date-time` | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `offsetDateTime` | `type: string, format: date-time` | RFC 3339 date with timezone offset                                        |\n\n### Data Validation Decorators\n\nThe tables below show how various built-in decorators add validation constraints to model properties:\r\n\r\n**For numeric types:**\r\n\r\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Example                      |\r\n| ------------------ | -------- | --------------------------- | ---------------------------- |\r\n| `@minValue(value)` | built-in | `minimum: value`            | `@minValue(0) age: int32;`   |\r\n| `@maxValue(value)` | built-in | `maximum: value`            | `@maxValue(120) age: int32;` |\r\n\r\n**For string types:**\r\n\r\n| Decorator           | Library  | OpenAPI/JSON Schema keyword | Example                                 |\r\n| ------------------- | -------- | --------------------------- | --------------------------------------- |\r\n| `@format(name)`     | built-in | `format: name`              | `@format(\"email\") email: string;`       |\r\n| `@minLength(value)` | built-in | `minLength: value`          | `@minLength(8) password: string;`       |\r\n| `@maxLength(value)` | built-in | `maxLength: value`          | `@maxLength(50) name: string;`          |\r\n| `@pattern(regex)`   | built-in | `pattern: regex`            | `@pattern(\"^[A-Z]{2}$\") state: string;` |\r\n| `@secret`           | built-in | `format: password`          | `@secret password: string;`             |\r\n\r\n**For array types:**\r\n\r\n| Decorator          | Library  | OpenAPI/JSON Schema keyword | Example                         |\r\n| ------------------ | -------- | --------------------------- | ------------------------------- |\r\n| `@minItems(value)` | built-in | `minItems: value`           | `@minItems(1) tags: string[];`  |\r\n| `@maxItems(value)` | built-in | `maxItems: value`           | `@maxItems(10) tags: string[];` |\n\n### Using External References\n\nThe [`@useRef` decorator](./reference/decorators.md#@TypeSpec.OpenAPI.useRef) configures a TypeSpec model with a reference to an external schema that will be used in place of references to that model's schema:\r\n\r\n```typespec\r\n// Whenever the OpenAPI emitter would try to reference the Sku model's schema, it will reference the below\r\n// external schema instead.\r\n@useRef(\"common.json#/components/schemas/Sku\")\r\nmodel Sku {\r\n  name: string;\r\n  tier: string;\r\n}\r\n```\n\n### Enums\n\nTypeSpec enums and unions convert to OpenAPI enum schemas. You can define enums in two ways:\r\n\r\n**TypeSpec enum declaration:**\r\n\r\n```typespec\r\nenum Color {\r\n  Red: \"red\",\r\n  Blue: \"blue\",\r\n  Green: \"green\",\r\n}\r\n```\r\n\r\n**Union of literal values:**\r\n\r\n```typespec\r\nmodel Settings {\r\n  // `status` can be any of the following strings.\r\n  status: \"Running\" | \"Stopped\" | \"Failed\";\r\n}\r\n```\r\n\r\nBoth approaches result in an OpenAPI schema with a type of `string` and an `enum` array containing the specified values.\n\n## Model Composition\n\nTypeSpec offers several ways to compose models.\n\n### Spread Operator\n\nThe spread operator copies properties from one model to another without creating a semantic relationship:\r\n\r\n```typespec\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n  state: string;\r\n}\r\n\r\nmodel UserProfile {\r\n  name: string;\r\n\r\n  // Copy all the properties of Address into this model as if they were declared here.\r\n  ...Address;\r\n\r\n  email: string;\r\n}\r\n```\r\n\r\nIn OpenAPI, the result is a flat schema named `UserProfile` with the properties of `Address` declared inline.\n\n### Extends Keyword\n\nThe `extends` keyword creates an inheritance relationship:\r\n\r\n```typespec\r\nmodel Pet {\r\n  name: string;\r\n  age: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  breed: string;\r\n}\r\n```\r\n\r\nIn OpenAPI, this creates a schema `Dog` that references the schema `Pet` using `allOf`.\r\n\r\n#### Discriminated Union with Extends\r\n\r\nYou can create discriminated type hierarchies using the `@discriminator` decorator:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  kind: \"dog\"; // Must be a literal string value\r\n  breed: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  kind: \"cat\"; // Must be a literal string value\r\n  whiskerCount: int32;\r\n}\r\n```\r\n\r\nThis creates a discriminator object in the OpenAPI schema with a mapping from discriminator values to schemas.\n\n### Is Keyword\n\nThe `is` keyword creates a new model with the same shape as another model:\r\n\r\n```typespec\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n}\r\n\r\nmodel ShippingDetails is Address {\r\n  zipCode: string; // Additional property\r\n}\r\n```\r\n\r\nIn OpenAPI, `ShippingDetails` is an independent schema with all properties from `Address` plus `zipCode`.\n\n### Unions\n\nUnions represent values that could be one of several types:\r\n\r\n**Union type alias:**\r\n\r\n```typespec\r\nalias PetType = Dog | Cat | Hamster;\r\n```\r\n\r\n**Named union declaration:**\r\n\r\n```typespec\r\nunion PetType {\r\n  dog: Dog,\r\n  cat: Cat,\r\n  hamster: Hamster,\r\n}\r\n```\r\n\r\nBy default, unions emit as `anyOf` in OpenAPI. You can use the [`@oneOf` decorator](./reference/decorators.md#@TypeSpec.OpenAPI.oneOf) on a named union declaration to emit it as `oneOf` instead:\r\n\r\n```typespec\r\n@oneOf\r\nunion PetType {\r\n  dog: Dog,\r\n  cat: Cat,\r\n  hamster: Hamster,\r\n}\r\n```\n\n## Encoding and Formats\n\nThe `@encode` decorator lets you control how TypeSpec types are serialized. The general pattern is:\r\n\r\n```typespec\r\n@encode(\"<encoding name>\", encodingTargetType) property: trueType;\r\n```\r\n\r\nWhere:\r\n\r\n- `\"<encoding name>\"`: The format or method of encoding (e.g., `\"base64\"`, `\"rfc3339\"`, `\"unixTimestamp\"`)\r\n- `encodingTargetType`: The type to encode to and decode from (e.g., `int32`, `string`)\r\n- `trueType`: The \"true\" semantic data type of the property (e.g., `duration`, `utcDateTime`)\r\n\r\nThe emitter follows these rules to determine the OpenAPI format:\r\n\r\n1. For date/time types:\r\n\r\n   - `@encode(\"rfc3339\", string) _: utcDateTime`  `type: string, format: date-time`\r\n   - `@encode(\"rfc7231\", string) _: utcDateTime`  `type: string, format: http-date`\r\n   - `@encode(\"unixTimestamp\", int32) _: utcDateTime`  `type: integer, format: unixtime`\r\n\r\n2. For other types, the format comes from either the encoding name or the `encodingTargetType`'s format.\r\n\r\nThis table summarizes common encodings:\r\n\r\n| TypeSpec with encoding                           | OpenAPI 3 result                  |\r\n| ------------------------------------------------ | --------------------------------- |\r\n| `@encode(\"seconds\", int32) _: duration`          | `type: integer, format: int32`    |\r\n| `@encode(\"ISO8601\") _: duration`                 | `type: number, format: duration`  |\r\n| `@encode(\"unixTimestamp\", int64) _: utcDateTime` | `type: integer, format: unixtime` |\r\n| `@encode(\"rfc3339\") _: utcDateTime`              | `type: string, format: date-time` |\n\n## Security Definitions\n\nUse the [(HTTP) `@useAuth` decorator][http-useauth-decorator] to define authentication and security schemes for your API.\r\n\r\nFor example, to define an authentication/authorization scheme based on Microsoft Entra ID:\r\n\r\n```typespec\r\n@useAuth(EntraIDToken)\r\nnamespace Contoso.WidgetManager;\r\n\r\n/** Microsoft Entra ID OAuth2 Flow */\r\nmodel EntraIDToken\r\n  is OAuth2Auth<[\r\n    {\r\n      type: OAuth2FlowType.authorizationCode;\r\n      authorizationUrl: \"https://api.example.com/oauth2/authorize\";\r\n      tokenUrl: \"https://api.example.com/oauth2/token\";\r\n      scopes: [\"https://management.azure.com/read\", \"https://management.azure.com/write\"];\r\n    }\r\n  ]>;\r\n```\r\n\r\nAuthentication/authorization is a complex and highly configurable feature. See the [`@useAuth` decorator documentation for more information][http-useauth-decorator].\r\n\r\n[http-useauth-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.useAuth\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n", "latency": 14.772231817245483, "response_length": 995}
{"query": "title: Suppress Typespec Compiler Error?\n\nquestion: Hello,\nI am in the process of converting our existing API specs to Typespec, and we have a few properties in a model that can't be patchable. However, when trying to compile, I get this error. Is there a way to suppress this error so I can get compilation? I was working with Mark Cowlishaw but I think he is OOF today:\n- error @azure-tools/typespec-azure-resource-manager/patch-envelope: The Resource PATCH request for resource 'ScalingPlan' is missing envelope properties:  [identity, managedBy, plan, sku]. Since these properties are supported in the resource, they must also be updatable via PATCH.\n> 2947 | model ScalingPlanPatch {", "ground_truth": "You should just be able to suppress this.  If you will point at the pr with the corresponding typespec-validation error, I can show where this is (generally you would just need to put the suppression on the PATCH operation)\nAhh, I see why I wasn't able to get this into a playground - you actuallky need to suppress this on the PATCH request model,  as in this playground", "response": "To suppress the compiler error related to the `@azure-tools/typespec-azure-resource-manager/patch-envelope` rule, you can use the `#suppress` directive in your TypeSpec code. This directive allows you to suppress specific linting rules by providing the error code and a reason for suppression. Here's an example:\n\n```tsp\n#suppress \"@azure-tools/typespec-azure-resource-manager/patch-envelope\" \"Certain properties are intentionally not patchable.\"\nmodel ScalingPlanPatch {\n  // Your model definition here\n}\n```\n\nThis will suppress the error and allow your code to compile. However, ensure that suppressing the rule aligns with your API design requirements and has been reviewed or approved by your team.", "context": "- document_dir: typespec_azure_docs\n- document_filename: troubleshoot#suppresswarnings.md\n- document_title: How to suppress warnings\n- document_link: https://azure.github.io/typespec-azure/docs/troubleshoot/suppresswarnings\n- document_content: # troubleshoot#suppresswarnings.md\n\n# How to suppress warnings\n\nThis article helps you to suppress warning messages generated by TypeSpec and libraries.\n\n## Symptoms\n\nTypeSpec core and libraries could generate and output warning messages based on linting rules.\n\n## Cause\n\nThese linting rules are introduced to ensure high-quality specs being generated. Sometimes they are used to call out areas needs developer attention to meet library or organization guidelines.\n\n## Workaround\n\nSome of the rules after review can be suppressed to get clean compile outputs using `#suppress ErrCode ReasonMsg` statement. The error code is the string reported in compiler output.\r\n\r\nFor example:\r\n\r\n```tsp\r\n#suppress \"@azure-tools/typespec-providerhub/no-identifier-property-in-array-item\" \"Error items have no unique identifier.\"\r\n/** An array of details about specific errors that led to this reported error. */\r\ndetails: Error[];\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#arm-rules.md\n- document_title: ARM Rules, TypeSpec Linting, and Suppression\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\n- document_content: # howtos#arm#arm-rules.md\n\n# ARM Rules, TypeSpec Linting, and Suppression\n\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\r\n\r\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\n\n## ARM RPC Rules\n\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\r\n\r\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\n\n## Detecting and Suppressing Rule Violations at Design Time\n\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\r\n\r\nHere is an example of a linter warning:\r\n\r\n```bash\r\nDiagnostics were reported during compilation:\r\n\r\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\r\n> 38 |   /** Gets the Zero Trust URL for this resource */\r\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n> 39 |   @post\r\n     | ^^^^^^^\r\n> 40 |   getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nFound 1 warning.\r\n\r\n```\r\n\r\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\r\n\r\n```typespec\r\n  #suppress \"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\" \"This is a sample suppression.\"\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\r\n\r\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\r\n\r\n```typespec\r\n  @armResourceAction(ZeroTrustResource)\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-resource-manager#reference#linter.md\n- document_title: Linter usage\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/linter\n- document_content: # libraries#azure-resource-manager#reference#linter.md\n\n# Linter usage\n\n## Usage\n\nAdd the following in `tspconfig.yaml`:\r\n\r\n```yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-resource-manager/all\"\r\n```\n\n## RuleSets\n\nAvailable ruleSets:\r\n\r\n- `@azure-tools/typespec-azure-resource-manager/all`\n\n## Rules\n\n| `@armResourceAction` should not be used with `@segment`.                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-duplicate-property`                                                                                   | Warn about duplicate properties in resources.                                                                                                                                                                                                         |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-envelope-property`                                                                            | Check for invalid resource envelope properties.                                                                                                                                                                                                       |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-version-format`                                                                               | Check for valid versions.                                                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-key-invalid-chars`                                                                                    | Arm resource key must contain only alphanumeric characters.                                                                                                                                                                                           |\r\n|\n\n|\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-operation`                                                                                            | Validate ARM Resource operations.                                                                                                                                                                                                                     |\r\n| `@azure-tools/typespec-azure-resource-manager/no-resource-delete-operation`                                                                                      | Check for resources that must have a delete operation.                                                                                                                                                                                                |\r\n| `@azure-tools/typespec-azure-resource-manager/empty-updateable-properties`                                                                                       | Should have updateable properties.                                                                                                                                                                                                                    |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-interface-requires-decorator`                                                                         | Each resource interface must have an @armResourceOperations decorator.                                                                                                                                                                                |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-action-verb`](/libraries/azure-resource-manager/rules/arm-resource-invalid-action-verb.md)   |\n\n| Name                                                                                                                                                             | Description                                                                                                                                                                                                                                           |\r\n| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-no-record`](/libraries/azure-resource-manager/rules/arm-no-record.md)                                         | Don't use Record types for ARM resources.                                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-common-types-version`                                                                                          | Specify the ARM common-types version using @armCommonTypesVersion.                                                                                                                                                                                    |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-delete-operation-response-codes`](/libraries/azure-resource-manager/rules/delete-operation-response-codes.md) | Ensure delete operations have the appropriate status codes.\n\n| Each resource interface must have an @armResourceOperations decorator.                                                                                                                                                                                |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-resource-invalid-action-verb`](/libraries/azure-resource-manager/rules/arm-resource-invalid-action-verb.md)   | Actions must be HTTP Post or Get operations.                                                                                                                                                                                                          |\r\n| `@azure-tools/typespec-azure-resource-manager/improper-subscription-list-operation`                                                                              | Tenant and Extension resources should not define a list by subscription operation.                                                                                                                                                                    |\r\n| [`@azure-tools/typespec-azure-resource-manager/lro-location-header`](/libraries/azure-resource-manager/rules/lro-location-header.md)                             | A 202 response should include a Location response header.                                                                                                                                                                                             |\r\n| [`@azure-tools/typespec-azure-resource-manager/missing-x-ms-identifiers`](/libraries/azure-resource-manager/rules/missing-x-ms-identifiers.md)                   | Array properties should describe their identifying properties with x-ms-identifiers. Decorate the property with @OpenAPI.extension(\"x-ms-identifiers\", #[id-prop]) where \"id-prop\" is a list of the names of identifying properties in the item type. |\r\n|\n\n|\r\n| [`@azure-tools/typespec-azure-resource-manager/missing-x-ms-identifiers`](/libraries/azure-resource-manager/rules/missing-x-ms-identifiers.md)                   | Array properties should describe their identifying properties with x-ms-identifiers. Decorate the property with @OpenAPI.extension(\"x-ms-identifiers\", #[id-prop]) where \"id-prop\" is a list of the names of identifying properties in the item type. |\r\n| [`@azure-tools/typespec-azure-resource-manager/no-response-body`](/libraries/azure-resource-manager/rules/no-response-body.md)                                   | Check that the body is empty for 202 and 204 responses, and not empty for other success (2xx) responses.                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/missing-operations-endpoint`                                                                                       | Check for missing Operations interface.                                                                                                                                                                                                               |\r\n| `@azure-tools/typespec-azure-resource-manager/patch-envelope`                                                                                                    | Patch envelope properties should match the resource properties.                                                                                                                                                                                       |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-patch`                                                                                                |\n\n|\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-key-invalid-chars`                                                                                    | Arm resource key must contain only alphanumeric characters.                                                                                                                                                                                           |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-resource-name-pattern`](/libraries/azure-resource-manager/rules/resource-name-pattern.md)                     | The resource name parameter should be defined with a 'pattern' restriction.                                                                                                                                                                           |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-operation-response`                                                                                   | [RPC 008]: PUT, GET, PATCH & LIST must return the same resource schema.                                                                                                                                                                               |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-path-segment-invalid-chars`                                                                           | Arm resource name must contain only alphanumeric characters.                                                                                                                                                                                          |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-provisioning-state`                                                                                   |\n\n|\r\n| [`@azure-tools/typespec-azure-resource-manager/unsupported-type`](/libraries/azure-resource-manager/rules/unsupported-type.md)                                   | Check for unsupported ARM types.                                                                                                                                                                                                                      |\r\n| [`@azure-tools/typespec-azure-resource-manager/no-empty-model`](/libraries/azure-resource-manager/rules/no-empty-model.md)                                       | ARM Properties with type:object that don't reference a model definition are not allowed. ARM doesn't allow generic type definitions as this leads to bad customer experience.                                                                         |\n\n| Arm resource name must contain only alphanumeric characters.                                                                                                                                                                                          |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-provisioning-state`                                                                                   | Check for properly configured provisioningState property.                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-custom-resource-usage-discourage`                                                                              | Verify the usage of @customAzureResource decorator.                                                                                                                                                                                                   |\r\n| `@azure-tools/typespec-azure-resource-manager/beyond-nesting-levels`                                                                                             | Tracked Resources must use 3 or fewer levels of nesting.                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-operation`                                                                                            | Validate ARM Resource operations.                                                                                                                                                                                                                     |\r\n|\n\n|\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-delete-operation-response-codes`](/libraries/azure-resource-manager/rules/delete-operation-response-codes.md) | Ensure delete operations have the appropriate status codes.                                                                                                                                                                                           |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-put-operation-response-codes`](/libraries/azure-resource-manager/rules/put-operation-response-codes.md)       | Ensure put operations have the appropriate status codes.                                                                                                                                                                                              |\r\n| [`@azure-tools/typespec-azure-resource-manager/arm-post-operation-response-codes`](/libraries/azure-resource-manager/rules/post-operation-response-codes.md)     | Ensure post operations have the appropriate status codes.                                                                                                                                                                                             |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-action-no-segment`                                                                                    | `@armResourceAction` should not be used with `@segment`.                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-duplicate-property`                                                                                   |\n\n| Patch envelope properties should match the resource properties.                                                                                                                                                                                       |\r\n| `@azure-tools/typespec-azure-resource-manager/arm-resource-patch`                                                                                                | Validate ARM PATCH operations.                                                                                                                                                                                                                        |\r\n| `@azure-tools/typespec-azure-resource-manager/resource-name`                                                                                                     | Check the resource name.                                                                                                                                                                                                                              |\r\n| `@azure-tools/typespec-azure-resource-manager/retry-after`                                                                                                       | Check if retry-after header appears in response body.                                                                                                                                                                                                 |\r\n| [`@azure-tools/typespec-azure-resource-manager/unsupported-type`](/libraries/azure-resource-manager/rules/unsupported-type.md)                                   | Check for unsupported ARM types.                                                                                                                                                                                                                      |\r\n|\n", "latency": 12.455350875854492, "response_length": 702}
{"query": "title: SDK automation checks with multi-directory TSP projects\n\nquestion: Key Vault's Administration library has multiple subservices, which are kept in separate TSP directories (PR link). Each of these directories references a Common directory with some shared definitions. The SDK automation checks have been failing because they're not resolving imports across directories.\nThis type of error seems consistent with using tsp-client to generate when additionalDirectories aren't included. Is that the issue here? If so, how can we get these checks to work with our directory setup?", "ground_truth": "Hi McCoy Patio I have identified that the failure was resolved by adding the missing `additionalDirectories`. tsp-client already supports `additionalDirectories`.\nThe Python SDK can now be successfully generated in the latest build. However, the Java and .NET SDKs are still failing, likely due to custom code. There might also be issues with the JavaScript code generation.\nMary Gao is currently assisting with troubleshooting the JavaScript issue, while the Go SDK is also under investigation.\nPlease let me know if you need any additional details or further assistance.", "response": "Yes, the issue you're encountering with SDK automation checks failing to resolve imports across directories is likely due to the `tsp-client` tool not including the `additionalDirectories` parameter in its configuration. When working with multi-directory TypeSpec (TSP) projects, such as your Key Vault Administration library setup, you need to ensure that all necessary directories are specified in the `tsp-location.yaml` file under the `additionalDirectories` property. This ensures that all required files, including shared definitions in the Common directory, are synced and available during the generation process.\n\nTo resolve this issue, update your `tsp-location.yaml` file to include the `additionalDirectories` property with paths to the Common directory and any other relevant directories. For example:\n\n```yaml\ndirectory: specification/keyvault/Administration\ncommit: <commit-sha>\nrepo: Azure/azure-rest-api-specs\nadditionalDirectories:\n  - specification/keyvault/Common\n```\n\nAfter updating the configuration, rerun the `tsp-client sync` and `tsp-client generate` commands to ensure all necessary files are included and the imports are resolved correctly.", "context": "- document_dir: typespec_docs\n- document_filename: language-basics#imports.md\n- document_title: Imports\n- document_link: https://typespec.io/docs/language-basics/imports\n- document_content: # language-basics#imports.md\n\n# Imports\n\nImports are used to include files or libraries into your TypeSpec program. When compiling a TypeSpec file, you specify the path to your root TypeSpec file, typically named \"main.tsp\". From this root file, any imported files are added to your program. If a directory is imported, TypeSpec will search for a `main.tsp` file within that directory.\r\n\r\nThe path specified in the import must either start with `\"./\"` or `\"../\"`, or be an absolute path. The path should either point to a directory, or have an extension of either \".tsp\" or \".js\". The examples below illustrate how to use imports to assemble a TypeSpec program from multiple files:\n\n## Importing a TypeSpec file\n\n```typespec\r\nimport \"./models/foo.tsp\";\r\n```\n\n## Importing a JavaScript file\n\n```typespec\r\nimport \"./decorators.js\";\r\n```\n\n## Importing a library\n\nThe import value can be the name of one of the package dependencies.\r\n\r\n```typespec\r\nimport \"/rest\";\r\n```\r\n\r\n```json\r\n// ./node_modules/@typespec/rest/package.json\r\n{\r\n  \"exports\": {\r\n    \".\": { \"typespec\": \"./lib/main.tsp\" }\r\n  }\r\n}\r\n```\r\n\r\nThis results in `./node_modules/@typespec/rest/lib/main.tsp` being imported.\n\n### Package resolution algorithm\n\nWhen trying to import a package TypeSpec follows the following logic\r\n\r\n1. Parse the package name from the import specificier into `pkgName` and `subPath` (e.g. `@scope/lib/named` => pkgName: `@scope/lib` subpath: `named` )\r\n1. Look to see if `pkgName` is itself(Containing package)\r\n1. Otherwise lookup for a parent folder with a `node_modules/${pkgName}` sub folder\r\n1. Reading the `package.json` of the package\r\n   a. If `exports` is defined respect the [ESM logic](https://github.com/nodejs/node/blob/main/doc/api/esm.md) to resolve the `typespec` condition(TypeSpec will not respect the `default` condition)\r\n   b. If `exports` is not found or for back compat the `.` export is missing the `typespec` condition fallback to checking `tspMain` or `main`\n\n## Importing a directory\n\nIf the import value is a directory, TypeSpec will check if that directory is a Node package and follow the npm package [lookup logic](#importing-a-library), or if the directory contains a `main.tsp` file.\r\n\r\n```typespec\r\nimport \"./models\"; // equivalent to `import \"./models/main.tsp\";\r\n```\r\n\r\n```typespec\r\nimport \"./path/to/local/module\"; // Assuming this path is a TypeSpec package, it will load it using the tspMain file.\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#04-common-parameters.md\n- document_title: Common Parameters\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/04-common-parameters\n- document_content: # getting-started#getting-started-rest#04-common-parameters.md\n\n# Common Parameters\n\n## Introduction\n\nIn this section, we'll focus on reusing common parameters in your REST API. Common parameters are parameters that are used across multiple operations. By defining these parameters once and reusing them, we can make our API more consistent, easier to read, and easier to maintain.\n\n## Creating a Common Parameters Model\n\nLet's start by defining a model for common parameters. This model will include parameters that will be used across all Pet Store operations.\n\n### Example: Defining Common Parameters\n\nFor the sake of demonstration, we're going to require each API call in our Pet Store service to include a request ID, a locale, and a client version. Let's define a model for these common parameters, which we'll label `requestID`, `locale`, and `clientVersion`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@header` decorator is used to indicate that `requestID` and `clientVersion` are header parameters.\r\n- The `@query` decorator is used to indicate that `locale` is a query parameter.\n\n## Reusing Common Parameters Across Multiple Operations\n\nNow that we have defined our common parameters model, let's reuse it across multiple operations in our API.\n\n### Example: Reusing Common Parameters in Operations\n\nPet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  // highlight-next-line\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  };\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `CommonParameters` model is reused across multiple operations using the [spread operator](../../../language-basics/models/#spread) `(...)`, which tells the TypeSpec compiler to expand the model definition inline.\r\n- This approach ensures that the common parameters are consistently applied to all relevant operations, making the API more maintainable and reducing redundancy.\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  // highlight-next-line\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  // highlight-next-line\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  // highlight-next-line\r\n  op createPet(@body pet: Pet, ...CommonParameters): {\r\n    @statusCode statusCode: 201;\r\n    @body newPet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 202;\r\n    @body acceptedPet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 400;\r\n    @body error: ValidationError;\r\n  };\r\n\r\n  @put\r\n  // highlight-next-line\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  // highlight-next-line\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  };\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\n\n### Example: OpenAPI Specification for Common Parameters\n\nname: request-id\r\n      in: header\r\n      required: true\r\n      schema:\r\n        type: string\r\n    // highlight-end\r\n  schemas:\r\n    NotFoundError:\r\n      type: object\r\n      properties:\r\n        code:\r\n          type: string\r\n          example: \"NOT_FOUND\"\r\n        message:\r\n          type: string\r\n```\r\n\r\nIn this example:\r\n\r\n- **Parameters Section**: The `deletePet` operation includes the `petId` path parameter and the common parameters (`requestID`, `locale`, and `clientVersion`). The common parameters are referenced using `$ref` to ensure they are consistently defined and reused across multiple operations.\r\n- **Components Section**: The common parameters are defined under the `components` section, ensuring they are reusable and maintainable. Each parameter is specified with its name, location (`in` indicating header or query), whether it is required, and its schema.\n\nLet's take a closer look at how the common parameters model with the `spread` operator is represented in the generated OpenAPI specification by looking at the `deletePet` operation:\r\n\r\n```yaml\r\n#### Generated OpenAPI Specification:\r\n\r\npaths:\r\n  /pets/{petId}:\r\n    delete:\r\n      operationId: Pets_deletePet\r\n      parameters:\r\n        - name: petId\r\n          in: path\r\n          required: true\r\n          schema:\r\n            type: integer\r\n            format: int32\r\n        // highlight-start\r\n        - $ref: \"#/components/parameters/CommonParameters.requestID\"\r\n        - $ref: \"#/components/parameters/CommonParameters.locale\"\r\n        - $ref: \"#/components/parameters/CommonParameters.clientVersion\"\r\n        // highlight-end\r\n      responses:\r\n        \"204\":\r\n          description: \"There is no content to send for this request, but the headers may be useful.\"\r\n        \"404\":\r\n          description: \"Not Found\"\r\n          content:\r\n            application/json:\r\n              schema:\r\n                $ref: \"#/components/schemas/NotFoundError\"\r\ncomponents:\r\n  parameters:\r\n    // highlight-start\r\n    CommonParameters.clientVersion:\r\n      name: client-version\r\n      in: header\r\n      required: false\r\n      schema:\r\n        type: string\r\n    CommonParameters.locale:\r\n      name: locale\r\n      in: query\r\n      required: false\r\n      schema:\r\n        type: string\r\n    CommonParameters.requestID:\r\n      name: request-id\r\n      in: header\r\n      required: true\r\n      schema:\r\n        type: string\r\n    // highlight-end\r\n  schemas:\r\n    NotFoundError:\r\n      type: object\r\n      properties:\r\n        code:\r\n          type: string\r\n          example: \"NOT_FOUND\"\r\n        message:\r\n          type: string\r\n```\r\n\r\nIn this example:\r\n\r\n- **Parameters Section**: The `deletePet` operation includes the `petId` path parameter and the common parameters (`requestID`, `locale`, and `clientVersion`).\n\n### Benefits\n\n1. **Consistency**: Ensures that common parameters are applied consistently across all relevant operations.\r\n2. **Maintainability**: Changes to common parameters need to be made only once in the `CommonParameters` model, reducing redundancy and potential errors.\r\n3. **Clarity**: The generated OpenAPI specification clearly shows which parameters are required for each operation, improving the documentation and usability of the API.\n\n## Conclusion\n\nIn this section, we focused on reusing common parameters in your REST API. By defining a common parameters model and reusing it across multiple operations, we can make our API more consistent, easier to read, and easier to maintain.\r\n\r\nNext, we'll learn how to add authentication to our REST API.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-with-tsp-client#intro_tsp_client.md\n- document_title: Usage\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/intro_tsp_client\n- document_content: # howtos#generate-with-tsp-client#intro_tsp_client.md\n\n# Usage\n\n:::info\r\n**Short link:** [aka.ms/azsdk/tsp-client](https://aka.ms/azsdk/tsp-client)\r\n:::\r\n\r\n`tsp-client` is a simple command line tool to facilitate generating client libraries from TypeSpec.\n\n## Installation\n\n```bash\r\nnpm install -g @azure-tools/typespec-client-generator-cli\r\n```\n\n## Prerequisites\n\nUsers working with a repository that already accepts this tool can continue to the [Usage](#usage) section.\r\n\r\nRepo owners should follow the steps in the [tsp-client repo setup](./repo_setup.md) doc.\n\n## Usage\n\n```bash\r\ntsp-client < command > [options]\r\n```\n\n## Commands\n\nUse one of the supported commands to get started generating clients from a TypeSpec project.\r\n\r\nThis tool will default to using your current working directory to generate clients in and will\r\nuse it to look for relevant configuration files. To specify a different output directory, use\r\nthe `-o` or `--output-dir` option.\r\n\r\nTo see supported commands, run:\r\n\r\n```bash\r\ntsp-client --help\r\n```\r\n\r\nTo see supported parameters and options for a specific command, run:\r\n\r\n```bash\r\ntsp-client < command > --help\r\n```\r\n\r\nExample using the `init` command:\r\n\r\n```bash\r\ntsp-client init --help\r\n```\n\n### init\n\nInitialize the client library directory using a tspconfig.yaml. When running this command pass in a path to a local or the URL of a remote tspconfig.yaml with the `-c` or `--tsp-config` flag. If remote, the tspconfig.yaml must include the specific commit in the path. (See example below)\r\n\r\nThe `init` command generates a directory structure following the standard pattern used across Azure SDK language repositories, creates a [tsp-location.yaml](#tsp-locationyaml) file to control generation, and performs an initial generation of the client library. If you want to skip client library generation, then pass the `--skip-sync-and-generate` flag.\r\n\r\n:::caution\r\nThis command should be run from the root of the repository. Example repository root: `azure-sdk-for-python/`\r\n:::\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client init -c https://github.com/Azure/azure-rest-api-specs/blob/dee71463cbde1d416c47cf544e34f7966a94ddcb/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n```\n\n### update\n\nThe `update` command will look for a [tsp-location.yaml](#tsp-locationyaml) file in your current directory to sync a TypeSpec project and generate a client library. The update flow calls the `sync` and `generate` commands internally, so if you need to separate these steps, use the `sync` and `generate` commands separately instead.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client update\r\n```\n\n### sync\n\nSync a TypeSpec project with the parameters specified in tsp-location.yaml.\r\n\r\nBy default the `sync` command will look for a tsp-location.yaml to get the project details and sync them to a temporary directory called `TempTypeSpecFiles`. Alternately, you can pass in the `--local-spec-repo` flag with the path to your local TypeSpec project to pull those files into your temporary directory.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client sync\r\n```\n\n### generate\n\nGenerate a client library from a TypeSpec project. The `generate` command should be run after the `sync` command. `generate` relies on the existence of the `TempTypeSpecFiles` directory created by the `sync` command and on an `emitter-package.json` file checked into your repository at the following path: `<repo root>/eng/emitter-package.json`. The `emitter-package.json` file is used to install project dependencies and get the appropriate emitter package.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate\r\n```\n\n### convert\n\nConvert an existing swagger specification to a TypeSpec project. This command should only be run once to get started working on a TypeSpec project. TypeSpec projects will need to be optimized manually and fully reviewed after conversion. When using this command a path or url to a swagger README file is required through the `--swagger-readme` flag. By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client convert -o ./Contoso.WidgetManager --swagger-readme < path-to > /readme.md\r\n```\n\n### compare\n\nCompares two Swagger definitions to identify the relevant differences between them. This command is useful when comparing an existing Swagger definition with a TypeSpec generated one. The `compare` command requires two parameters: `--lhs` which will typically be the original hand-authored Swagger and `--rhs` which will usually be the folder containing your TypeSpec. The command will generate the Swagger and compare the two definitions. The command will ignore differences in the Swagger that don't\r\ncorrespond to differences in the service, allowing you to focus only on differences that are relevant.\n\n### sort-swagger\n\nSort an existing swagger specification to be the same content order with TypeSpec generated swagger. This will allow you to easily compare and identify differences between the existing swagger and TypeSpec generated one. You should run this command on existing swagger files and check them in prior to creating converted TypeSpec PRs.\n\n### generate-config-files\n\n\"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"0.4.0-alpha.20250110.1\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\"\r\n  }\r\n}\r\n```\r\n\r\nIf you need to override dependencies for your emitter-package.json you can create a json file to explicitly list the package and corresponding version you want to override. This will add an `overrides` section in your emitter-package.json that will be used during `npm install` or `npm ci`. [See npm overrides doc.](https://docs.npmjs.com/cli/v10/configuring-npm/package-json?v=true#overrides)\r\n\r\nExample json file with package overrides:\r\n\r\n```json\r\n{\r\n  \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\",\r\n  \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n}\r\n```\r\n\r\nExample command specifying overrides:\r\n\r\n```bash\r\ntsp-client generate-config-files --overrides my_overrides.json --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample `emitter-package.json` generated using overrides:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"~0.64.0\"\r\n  },\r\n  \"overrides\": {\r\n    \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n  }\r\n}\r\n```\n\nThis command generates the default configuration files used by tsp-client. Run this command to generate the `emitter-package.json` and `emitter-package-lock.json` under the **eng/** directory of your current repository.\r\n\r\n**Required: Use the `--package-json` flag to specify the path to the package.json file of the emitter you will use to generate client libraries.**\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample using the `azure-sdk-for-js` and the `@azure-tools/typespec-ts` emitter:\r\n\r\nThe `--package-json` flag should be the relative or absolute path to repo clone of the @azure-tools/typespec-ts package.\r\n\r\n```bash\r\nazure-sdk-for-js > tsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nTo be explicit about specifying dependencies you'd like pinned, add a new field in the package.json file of your emitter called `\"azure-sdk/emitter-package-json-pinning\"` with a list of the dependencies you want to be forwarded to the emitter-package.json. These dependencies must be specified in your package.json's devDependencies in order for the tool to assign the correct version.\r\n\r\n:::info\r\nIf the `azure-sdk/emitter-package-json-pinning` field is missing from the package.json file, the tool will default to pinning the packages listed under `peerDependencies`.\r\n:::\r\n\r\nExample package.json using `\"azure-sdk/emitter-package-json-pinning\"`:\r\n\r\n```json\r\n{\r\n  \"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\n\n### generate-lock-file\n\nGenerate an emitter-package-lock.json under the eng/ directory based on existing `<repo-root>/eng/emitter-package.json`.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-lock-file\r\n```\n\n## Important concepts\n\n### Per project setup\n\nEach project will need to have a configuration file called tsp-location.yaml that will tell the tool where to find the TypeSpec project.\r\n\r\n#### tsp-location.yaml\r\n\r\nThis file is created through the `tsp-client init` command or you can manually create it under the project directory to run other commands supported by this tool.\r\n\r\n:::info\r\nThis file should live under the project directory for each service.\r\n:::\r\n\r\nThe file has the following properties:\r\n\r\n| Property                                                        | Description                                                                                                                                                                                                                                                                                           | IsRequired            |\r\n| --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |\r\n| <a id=\"directory-anchor\"></a> directory                         | The top level directory where the main.tsp for the service lives. This should be relative to the spec repo root such as `specification/cognitiveservices/OpenAI.Inference`                                                                                                                            | true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. |\n\n| true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. | false: default = null |\r\n| <a id=\"commit-anchor\"></a> commit                               | The commit sha for the version of the typespec files you want to generate off of. This allows us to have idempotence on generation until we opt into pointing at a later version.                                                                                                                     | true                  |\r\n| <a id=\"repo-anchor\"></a> repo                                   | The repo this spec lives in. This should be either `Azure/azure-rest-api-specs` or `Azure/azure-rest-api-specs-pr`. Note that pr will work locally but not in CI until we add another change to handle token based auth.                                                                              | true                  |\r\n| <a id=\"entrypointFile-anchor\"></a> entrypointFile               | A specific entrypoint file used to compile the TypeSpec project. NOTE: This option should only be used with a non-standard entrypoint file name. DO NOT use this option with standard entrypoints: `client.tsp` or `main.tsp`.                                                                        | false                 |\r\n\r\nExample:\r\n\r\n```yml title=tsp-location.yaml\r\ndirectory: specification/contosowidgetmanager/Contoso.WidgetManager\r\ncommit: 431eb865a581da2cd7b9e953ae52cb146f31c2a6\r\nrepo: Azure/azure-rest-api-specs\r\nadditionalDirectories:\r\n  - specification/contosowidgetmanager/Contoso.WidgetManager.Shared/\r\n```\n", "latency": 10.817585706710815, "response_length": 1167}
{"query": "title: Non-specs repo client\n\nquestion: To generate a client (test-proxy) from TypeSpec that is not in the azure-rest-api-specs repo, should we use tsp-client still or just tsp? Both https://aka.ms/typespec and https://aka.ms/typespec/azure both document tsp and I don't remember where I even installed tsp-client. Where are its docs and what I can do with tsp-location.yaml?", "ground_truth": "The tsp-client uses the emitter-package.json file to determine which emitter to use, based on the dependencies listed under \"dependency.\" The emitter options, such as the @azure-tools/typespec-rust emitter, are specified in the tspconfig.yaml file, and additional dependencies should be added in the emitter-package.json file.\nIf errors occur related to missing dependencies, its important to ensure that the necessary TypeSpec modules are listed under \"devDependencies\" in the emitter-package.json of the SDK repository. Dependencies should not be added to the tools repo's package.json file, but rather in the respective emitter-package.json file.\nThe issue encountered with the @azure-tools/typespec-rust emitter crashing appears to be a bug related to an unimplemented feature (model property kind header NYI), and a report should be filed for this. Additionally, it's noted that dependencies must be installed using npm install within the TempTypeSpecFiles directory to avoid errors related to missing imports.", "response": "To generate a client (test-proxy) from TypeSpec that is not in the `azure-rest-api-specs` repository, you should use the `tsp-client` tool. This tool is specifically designed to facilitate generating client libraries from TypeSpec projects, regardless of whether they are in the `azure-rest-api-specs` repository or elsewhere. The `tsp-client` tool provides commands such as `init`, `update`, `sync`, and `generate`, which are useful for managing TypeSpec projects and generating client libraries.\n\nThe `tsp-location.yaml` file is a configuration file that specifies the location of the TypeSpec project, including properties like the directory, commit SHA, repository, and entrypoint file. This file is essential for running commands like `sync` and `generate` with `tsp-client`. You can create this file manually or use the `tsp-client init` command to generate it automatically.\n\nFor more details on `tsp-client` usage and its commands, refer to the documentation linked below.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-with-tsp-client#intro_tsp_client.md\n- document_title: Usage\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/intro_tsp_client\n- document_content: # howtos#generate-with-tsp-client#intro_tsp_client.md\n\n# Usage\n\n:::info\r\n**Short link:** [aka.ms/azsdk/tsp-client](https://aka.ms/azsdk/tsp-client)\r\n:::\r\n\r\n`tsp-client` is a simple command line tool to facilitate generating client libraries from TypeSpec.\n\n## Installation\n\n```bash\r\nnpm install -g @azure-tools/typespec-client-generator-cli\r\n```\n\n## Prerequisites\n\nUsers working with a repository that already accepts this tool can continue to the [Usage](#usage) section.\r\n\r\nRepo owners should follow the steps in the [tsp-client repo setup](./repo_setup.md) doc.\n\n## Usage\n\n```bash\r\ntsp-client < command > [options]\r\n```\n\n## Commands\n\nUse one of the supported commands to get started generating clients from a TypeSpec project.\r\n\r\nThis tool will default to using your current working directory to generate clients in and will\r\nuse it to look for relevant configuration files. To specify a different output directory, use\r\nthe `-o` or `--output-dir` option.\r\n\r\nTo see supported commands, run:\r\n\r\n```bash\r\ntsp-client --help\r\n```\r\n\r\nTo see supported parameters and options for a specific command, run:\r\n\r\n```bash\r\ntsp-client < command > --help\r\n```\r\n\r\nExample using the `init` command:\r\n\r\n```bash\r\ntsp-client init --help\r\n```\n\n### init\n\nInitialize the client library directory using a tspconfig.yaml. When running this command pass in a path to a local or the URL of a remote tspconfig.yaml with the `-c` or `--tsp-config` flag. If remote, the tspconfig.yaml must include the specific commit in the path. (See example below)\r\n\r\nThe `init` command generates a directory structure following the standard pattern used across Azure SDK language repositories, creates a [tsp-location.yaml](#tsp-locationyaml) file to control generation, and performs an initial generation of the client library. If you want to skip client library generation, then pass the `--skip-sync-and-generate` flag.\r\n\r\n:::caution\r\nThis command should be run from the root of the repository. Example repository root: `azure-sdk-for-python/`\r\n:::\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client init -c https://github.com/Azure/azure-rest-api-specs/blob/dee71463cbde1d416c47cf544e34f7966a94ddcb/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n```\n\n### update\n\nThe `update` command will look for a [tsp-location.yaml](#tsp-locationyaml) file in your current directory to sync a TypeSpec project and generate a client library. The update flow calls the `sync` and `generate` commands internally, so if you need to separate these steps, use the `sync` and `generate` commands separately instead.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client update\r\n```\n\n### sync\n\nSync a TypeSpec project with the parameters specified in tsp-location.yaml.\r\n\r\nBy default the `sync` command will look for a tsp-location.yaml to get the project details and sync them to a temporary directory called `TempTypeSpecFiles`. Alternately, you can pass in the `--local-spec-repo` flag with the path to your local TypeSpec project to pull those files into your temporary directory.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client sync\r\n```\n\n### generate\n\nGenerate a client library from a TypeSpec project. The `generate` command should be run after the `sync` command. `generate` relies on the existence of the `TempTypeSpecFiles` directory created by the `sync` command and on an `emitter-package.json` file checked into your repository at the following path: `<repo root>/eng/emitter-package.json`. The `emitter-package.json` file is used to install project dependencies and get the appropriate emitter package.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate\r\n```\n\n### convert\n\nConvert an existing swagger specification to a TypeSpec project. This command should only be run once to get started working on a TypeSpec project. TypeSpec projects will need to be optimized manually and fully reviewed after conversion. When using this command a path or url to a swagger README file is required through the `--swagger-readme` flag. By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client convert -o ./Contoso.WidgetManager --swagger-readme < path-to > /readme.md\r\n```\n\n### compare\n\nCompares two Swagger definitions to identify the relevant differences between them. This command is useful when comparing an existing Swagger definition with a TypeSpec generated one. The `compare` command requires two parameters: `--lhs` which will typically be the original hand-authored Swagger and `--rhs` which will usually be the folder containing your TypeSpec. The command will generate the Swagger and compare the two definitions. The command will ignore differences in the Swagger that don't\r\ncorrespond to differences in the service, allowing you to focus only on differences that are relevant.\n\n### sort-swagger\n\nSort an existing swagger specification to be the same content order with TypeSpec generated swagger. This will allow you to easily compare and identify differences between the existing swagger and TypeSpec generated one. You should run this command on existing swagger files and check them in prior to creating converted TypeSpec PRs.\n\n### generate-config-files\n\n\"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"0.4.0-alpha.20250110.1\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\"\r\n  }\r\n}\r\n```\r\n\r\nIf you need to override dependencies for your emitter-package.json you can create a json file to explicitly list the package and corresponding version you want to override. This will add an `overrides` section in your emitter-package.json that will be used during `npm install` or `npm ci`. [See npm overrides doc.](https://docs.npmjs.com/cli/v10/configuring-npm/package-json?v=true#overrides)\r\n\r\nExample json file with package overrides:\r\n\r\n```json\r\n{\r\n  \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\",\r\n  \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n}\r\n```\r\n\r\nExample command specifying overrides:\r\n\r\n```bash\r\ntsp-client generate-config-files --overrides my_overrides.json --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample `emitter-package.json` generated using overrides:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"~0.64.0\"\r\n  },\r\n  \"overrides\": {\r\n    \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n  }\r\n}\r\n```\n\nThis command generates the default configuration files used by tsp-client. Run this command to generate the `emitter-package.json` and `emitter-package-lock.json` under the **eng/** directory of your current repository.\r\n\r\n**Required: Use the `--package-json` flag to specify the path to the package.json file of the emitter you will use to generate client libraries.**\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample using the `azure-sdk-for-js` and the `@azure-tools/typespec-ts` emitter:\r\n\r\nThe `--package-json` flag should be the relative or absolute path to repo clone of the @azure-tools/typespec-ts package.\r\n\r\n```bash\r\nazure-sdk-for-js > tsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nTo be explicit about specifying dependencies you'd like pinned, add a new field in the package.json file of your emitter called `\"azure-sdk/emitter-package-json-pinning\"` with a list of the dependencies you want to be forwarded to the emitter-package.json. These dependencies must be specified in your package.json's devDependencies in order for the tool to assign the correct version.\r\n\r\n:::info\r\nIf the `azure-sdk/emitter-package-json-pinning` field is missing from the package.json file, the tool will default to pinning the packages listed under `peerDependencies`.\r\n:::\r\n\r\nExample package.json using `\"azure-sdk/emitter-package-json-pinning\"`:\r\n\r\n```json\r\n{\r\n  \"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\n\n### generate-lock-file\n\nGenerate an emitter-package-lock.json under the eng/ directory based on existing `<repo-root>/eng/emitter-package.json`.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-lock-file\r\n```\n\n## Important concepts\n\n### Per project setup\n\nEach project will need to have a configuration file called tsp-location.yaml that will tell the tool where to find the TypeSpec project.\r\n\r\n#### tsp-location.yaml\r\n\r\nThis file is created through the `tsp-client init` command or you can manually create it under the project directory to run other commands supported by this tool.\r\n\r\n:::info\r\nThis file should live under the project directory for each service.\r\n:::\r\n\r\nThe file has the following properties:\r\n\r\n| Property                                                        | Description                                                                                                                                                                                                                                                                                           | IsRequired            |\r\n| --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |\r\n| <a id=\"directory-anchor\"></a> directory                         | The top level directory where the main.tsp for the service lives. This should be relative to the spec repo root such as `specification/cognitiveservices/OpenAI.Inference`                                                                                                                            | true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. |\n\n| true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. | false: default = null |\r\n| <a id=\"commit-anchor\"></a> commit                               | The commit sha for the version of the typespec files you want to generate off of. This allows us to have idempotence on generation until we opt into pointing at a later version.                                                                                                                     | true                  |\r\n| <a id=\"repo-anchor\"></a> repo                                   | The repo this spec lives in. This should be either `Azure/azure-rest-api-specs` or `Azure/azure-rest-api-specs-pr`. Note that pr will work locally but not in CI until we add another change to handle token based auth.                                                                              | true                  |\r\n| <a id=\"entrypointFile-anchor\"></a> entrypointFile               | A specific entrypoint file used to compile the TypeSpec project. NOTE: This option should only be used with a non-standard entrypoint file name. DO NOT use this option with standard entrypoints: `client.tsp` or `main.tsp`.                                                                        | false                 |\r\n\r\nExample:\r\n\r\n```yml title=tsp-location.yaml\r\ndirectory: specification/contosowidgetmanager/Contoso.WidgetManager\r\ncommit: 431eb865a581da2cd7b9e953ae52cb146f31c2a6\r\nrepo: Azure/azure-rest-api-specs\r\nadditionalDirectories:\r\n  - specification/contosowidgetmanager/Contoso.WidgetManager.Shared/\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: getstarted#installation.md\n- document_title: Installation\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/installation\n- document_content: # getstarted#installation.md\n\n# Installation\n\n## Try TypeSpec without installing anything\n\nYou can try TypeSpec on the web without installing anything.\r\n\r\n- [TypeSpec playground](https://aka.ms/trytypespec)\r\n- [TypeSpec playground for Azure services](https://azure.github.io/typespec-azure/playground)\n\n## Installing TypeSpec core toolset\n\nSee https://typespec.io/docs to install the base requirements for working with TypeSpec:\r\n\r\n- NodeJS\r\n- Typespec CLI\r\n- VSCode or VS extension\n\n## Create an Azure TypeSpec project\n\n[See next doc](./createproject.md)\n\n## Additional tooling\n\n- `tsp-client`: A CLI tool that provides several commands to help during the TypeSpec development process, such as converting a swagger specification to a TypeSpec project, providing a simple interface to generate client libraries within the `azure-sdk-for-<language>` repositories, and more. For more information on the CLI tool, see the [tsp-client usage](https://aka.ms/azsdk/tsp-client) documentation\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#00howtogen.mdx\n- document_title: How to generate client libraries\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/00howtogen\n- document_content: # howtos#generate-client-libraries#00howtogen.mdx\n\n# How to generate client libraries\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page outlines the steps to build a client library based on your TypeSpec specification. It provides a guide for the whole process from initial API design to the release of SDKs. please visit https://aka.ms/azsdk/dpcodegen.\r\n\r\nThe best documentation on how to generate can be found using those links:\r\n\r\n- https://aka.ms/azsdk/dpcodegen/net\r\n- https://aka.ms/azsdk/dpcodegen/python\r\n- https://aka.ms/azsdk/dpcodegen/java\r\n- https://aka.ms/azsdk/rlc/js\r\n- https://aka.ms/azsdk/dpcodegen/js (do not use unless told to do so by the archboard)\r\n\r\nAt a glance, add your emitter name to your `package.json`, along with the right options in the `tspconfig.yaml`.\r\n\r\n> **NOTE:** Generating all languages from the same folder may be complicated due to the preview status of the emitters and TypeSpec libraries, such as `typespec-azure-core` and `typespec-azure-resource-manager`.\r\n> It is recommended to have a unique language emitter in each `package.json` to avoid conflicts until all emitters and the TypeSpec libraries reach their first stable release.\r\n\r\nModify your `package.json` to include the necessary dependencies for the language emitter(s). Remember to run `npm install` after making changes to the file:\r\n\r\n```json\r\n{\r\n  \"name\": \"clients\",\r\n  \"dependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/rest\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@azure-tools/typespec-azure-core\": \"latest\",\r\n    \"@azure-tools/typespec-autorest\": \"latest\",\r\n    \"@azure-tools/typespec-python\": \"latest\",\r\n    \"@azure-tools/typespec-java\": \"latest\",\r\n    \"@azure-tools/typespec-csharp\": \"latest\",\r\n    \"@azure-tools/typespec-ts\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\r\n\r\nAlways update your `tspconfig.yaml` file rather than passing options through the command line.\r\n\r\n```yaml\r\nemit:\r\n  # Emitter for Swagger files with Autorest Extensions\r\n  - \"@azure-tools/typespec-autorest\"\n\n\"latest\",\r\n    \"@azure-tools/typespec-autorest\": \"latest\",\r\n    \"@azure-tools/typespec-python\": \"latest\",\r\n    \"@azure-tools/typespec-java\": \"latest\",\r\n    \"@azure-tools/typespec-csharp\": \"latest\",\r\n    \"@azure-tools/typespec-ts\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\r\n\r\nAlways update your `tspconfig.yaml` file rather than passing options through the command line.\r\n\r\n```yaml\r\nemit:\r\n  # Emitter for Swagger files with Autorest Extensions\r\n  - \"@azure-tools/typespec-autorest\"\r\n  # add \"@azure-tools/typespec-python\" to your package.json to generate Python code\r\n  - \"@azure-tools/typespec-python\"\r\n  # add \"@azure-tools/typespec-java\" to your package.json to generate Java code\r\n  - \"@azure-tools/typespec-java\"\r\n  # add \"@azure-tools/typespec-csharp\" to your package.json to generate C# code\r\n  - \"@azure-tools/typespec-csharp\"\r\n  # add \"@azure-tools/typespec-ts\" to your package.json to generate Typescript code\r\n  - \"@azure-tools/typespec-ts\"\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-java\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-csharp\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-ts\":\r\n    flavor: azure\r\n```\r\n\r\nSeveral language repositories utilize the `tsp-client` tool to simplify generating client libraries. For more information on the tool, see [Getting started with `tsp-client`](<./../Generating with tsp-client/tsp_client.md>).\n", "latency": 13.914636135101318, "response_length": 980}
{"query": "title: Operation Name 'import' not allowed?\n\nquestion: Hello,\nOur previous API specs had an operation Name import, but when I try to use it in typespec it defaults to the language use of the word import instead. Is there a way around this?\n![alt text](image-25.png)", "ground_truth": "I think you might be able to escape it: [Identifiers | TypeSpec](https://typespec.io/docs/language-basics/identifiers/#reserved-identifiers)", "response": "In TypeSpec, the word 'import' is reserved for importing files, libraries, or directories into your program. This means you cannot use 'import' as an operation name because it conflicts with the reserved keyword. To work around this, you can rename the operation to something else, such as 'importData' or 'importResource', to avoid the conflict. Alternatively, you can use a namespace to encapsulate the operation, but the operation name itself must still not be 'import'.", "context": "- document_dir: typespec_docs\n- document_filename: language-basics#imports.md\n- document_title: Imports\n- document_link: https://typespec.io/docs/language-basics/imports\n- document_content: # language-basics#imports.md\n\n# Imports\n\nImports are used to include files or libraries into your TypeSpec program. When compiling a TypeSpec file, you specify the path to your root TypeSpec file, typically named \"main.tsp\". From this root file, any imported files are added to your program. If a directory is imported, TypeSpec will search for a `main.tsp` file within that directory.\r\n\r\nThe path specified in the import must either start with `\"./\"` or `\"../\"`, or be an absolute path. The path should either point to a directory, or have an extension of either \".tsp\" or \".js\". The examples below illustrate how to use imports to assemble a TypeSpec program from multiple files:\n\n## Importing a TypeSpec file\n\n```typespec\r\nimport \"./models/foo.tsp\";\r\n```\n\n## Importing a JavaScript file\n\n```typespec\r\nimport \"./decorators.js\";\r\n```\n\n## Importing a library\n\nThe import value can be the name of one of the package dependencies.\r\n\r\n```typespec\r\nimport \"/rest\";\r\n```\r\n\r\n```json\r\n// ./node_modules/@typespec/rest/package.json\r\n{\r\n  \"exports\": {\r\n    \".\": { \"typespec\": \"./lib/main.tsp\" }\r\n  }\r\n}\r\n```\r\n\r\nThis results in `./node_modules/@typespec/rest/lib/main.tsp` being imported.\n\n### Package resolution algorithm\n\nWhen trying to import a package TypeSpec follows the following logic\r\n\r\n1. Parse the package name from the import specificier into `pkgName` and `subPath` (e.g. `@scope/lib/named` => pkgName: `@scope/lib` subpath: `named` )\r\n1. Look to see if `pkgName` is itself(Containing package)\r\n1. Otherwise lookup for a parent folder with a `node_modules/${pkgName}` sub folder\r\n1. Reading the `package.json` of the package\r\n   a. If `exports` is defined respect the [ESM logic](https://github.com/nodejs/node/blob/main/doc/api/esm.md) to resolve the `typespec` condition(TypeSpec will not respect the `default` condition)\r\n   b. If `exports` is not found or for back compat the `.` export is missing the `typespec` condition fallback to checking `tspMain` or `main`\n\n## Importing a directory\n\nIf the import value is a directory, TypeSpec will check if that directory is a Node package and follow the npm package [lookup logic](#importing-a-library), or if the directory contains a `main.tsp` file.\r\n\r\n```typespec\r\nimport \"./models\"; // equivalent to `import \"./models/main.tsp\";\r\n```\r\n\r\n```typespec\r\nimport \"./path/to/local/module\"; // Assuming this path is a TypeSpec package, it will load it using the tspMain file.\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#protobuf#reference#data-types.md\n- document_title: Data types\n- document_link: https://typespec.io/docs/emitters/protobuf/reference/data-types\n- document_content: # emitters#protobuf#reference#data-types.md\n\n# Data types\n\n## TypeSpec.Protobuf\n\n### `Extern` {#TypeSpec.Protobuf.Extern}\n\nA model that represents an external Protobuf reference. This type can be used to import and utilize Protobuf\r\ndeclarations that are not declared in TypeSpec within TypeSpec sources. When the emitter encounters an `Extern`, it\r\nwill insert an `import` statement for the corresponding `Path` and refer to the type by `Name`.\r\n\r\n#### Usage\r\n\r\nIf you have a file called `test.proto` that declares a package named `test` and a message named `Widget`, you can\r\nuse the `Extern` type to declare a model in TypeSpec that refers to your external definition of `test.Widget`. See\r\nthe example below.\r\n\r\nWhen the TypeSpec definition of `Widget` is encountered, the Protobuf emitter will represent it as a reference to\r\n`test.Widget` and insert an import for it, rather than attempt to convert the model to an equivalent message.\r\n\r\n```typespec\r\nmodel TypeSpec.Protobuf.Extern<Path, Name>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name | Description                                                                              |\r\n| ---- | ---------------------------------------------------------------------------------------- |\r\n| Path | the relative path to a `.proto` file to import                                           |\r\n| Name | the fully-qualified reference to the type this model represents within the `.proto` file |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Widget is Extern<\"path/to/test.proto\", \"test.Widget\">;\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type    | Description |\r\n| -------- | ------- | ----------- |\r\n| \\_extern | `never` |             |\n\n### `Map` {#TypeSpec.Protobuf.Map}\n\nA type representing a Protobuf `map`. Instances of this type in models will be converted to the built-in `map` type\r\nin Protobuf.\r\n\r\nThe key type of a Protobuf `map` must be any integral type or `string`. The value type can be any type other than\r\nanother `Map`.\r\n\r\n```typespec\r\nmodel TypeSpec.Protobuf.Map<Key, Value>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name  | Description                                      |\r\n| ----- | ------------------------------------------------ |\r\n| Key   | the key type (any integral type or string)       |\r\n| Value | the value type (any type other than another map) |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `PackageDetails` {#TypeSpec.Protobuf.PackageDetails}\n\nDetails applied to a package definition by the [`@package`](./decorators#\r\n\r\n```typespec\r\nmodel TypeSpec.Protobuf.PackageDetails\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type                                   | Description                                                                                                                                                                                                                                           |\r\n| -------- | -------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| name?    | `string`                               | The package's name.<br /><br />By default, the package's name is constructed from the namespace it is applied to.                                                                                                                                     |\r\n| options? | `Record<string \\| boolean \\| numeric>` | The package's top-level options.<br /><br />See the [Protobuf Language Guide - Options](https://protobuf.dev/programming-guides/proto3/#options) for more information.<br /><br />Currently, only string, boolean, and numeric options are supported. |\n\n### `StreamMode` {#TypeSpec.Protobuf.StreamMode}\n\nThe streaming mode of an operation. One of:\r\n\r\n- `Duplex`: both the input and output of the operation are streaming.\r\n- `In`: the input of the operation is streaming.\r\n- `Out`: the output of the operation is streaming.\r\n- `None`: neither the input nor the output are streaming.\r\n\r\nSee the [`@stream`](./decorators#\r\n\r\n```typespec\r\nenum TypeSpec.Protobuf.StreamMode\r\n```\r\n\r\n| Name   | Value | Description                                                                                                                                                     |\r\n| ------ | ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Duplex |       | Both the input and output of the operation are streaming. Both the client and service will stream messages to each<br />other until the connections are closed. |\r\n| In     |       | The input of the operation is streaming. The client will send a stream of events; and, once the stream is closed,<br />the service will respond with a message. |\r\n| Out    |       | The output of the operation is streaming. The client will send a message to the service, and the service will send<br />a stream of events back to the client.  |\r\n| None   |       | Neither the input nor the output are streaming. This is the default mode of an operation without the `@stream`<br />decorator.                                  |\n\n### `fixed32` {#TypeSpec.Protobuf.fixed32}\n\nAn unsigned 32-bit integer that will use the `fixed32` encoding when used in a Protobuf message.\r\n\r\n#### Protobuf binary format\r\n\r\nAlways four bytes. More efficient than `uint32` if values are often greater than 2<sup>28</sup>.\r\n\r\n```typespec\r\nscalar TypeSpec.Protobuf.fixed32\r\n```\n\n### `fixed64` {#TypeSpec.Protobuf.fixed64}\n\nAn unsigned 64-bit integer that will use the `fixed64` encoding when used in a Protobuf message.\r\n\r\n#### Protobuf binary format\r\n\r\nAlways eight bytes. More efficient than `uint64` if values are often greater than 2<sup>56</sup>.\r\n\r\n```typespec\r\nscalar TypeSpec.Protobuf.fixed64\r\n```\n\n### `sfixed32` {#TypeSpec.Protobuf.sfixed32}\n\nA signed 32-bit integer that will use the `sfixed32` encoding when used in a Protobuf message.\r\n\r\n#### Protobuf binary format\r\n\r\nAlways four bytes.\r\n\r\n```typespec\r\nscalar TypeSpec.Protobuf.sfixed32\r\n```\n\n### `sfixed64` {#TypeSpec.Protobuf.sfixed64}\n\nA signed 64-bit integer that will use the `sfixed64` encoding when used in a Protobuf message.\r\n\r\n#### Protobuf binary format\r\n\r\nAlways eight bytes.\r\n\r\n```typespec\r\nscalar TypeSpec.Protobuf.sfixed64\r\n```\n\n### `sint32` {#TypeSpec.Protobuf.sint32}\n\nA signed 32-bit integer that will use the `sint32` encoding when used in a Protobuf message.\r\n\r\n#### Protobuf binary format\r\n\r\nUses variable-length encoding. These more efficiently encode negative numbers than regular int32s.\r\n\r\n```typespec\r\nscalar TypeSpec.Protobuf.sint32\r\n```\n\n### `sint64` {#TypeSpec.Protobuf.sint64}\n\nA signed 64-bit integer that will use the `sint64` encoding when used in a Protobuf message.\r\n\r\n#### Protobuf binary format\r\n\r\nUses variable-length encoding. These more efficiently encode negative numbers than regular `int64s`.\r\n\r\n```typespec\r\nscalar TypeSpec.Protobuf.sint64\r\n```\n\n## TypeSpec.Protobuf.WellKnown\n\n### `Any` {#TypeSpec.Protobuf.WellKnown.Any}\n\nAny value.\r\n\r\nThis model references `google.protobuf.Any` from `google/protobuf/any.proto`.\r\n\r\n```typespec\r\nmodel TypeSpec.Protobuf.WellKnown.Any\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type    | Description |\r\n| -------- | ------- | ----------- |\r\n| \\_extern | `never` |             |\n\n### `Empty` {#TypeSpec.Protobuf.WellKnown.Empty}\n\nAn empty message.\r\n\r\nThis model references `google.protobuf.Empty` from `google/protobuf/empty.proto`.\r\n\r\n```typespec\r\nmodel TypeSpec.Protobuf.WellKnown.Empty\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type    | Description |\r\n| -------- | ------- | ----------- |\r\n| \\_extern | `never` |             |\n\n### `LatLng` {#TypeSpec.Protobuf.WellKnown.LatLng}\n\nA latitude and longitude.\r\n\r\nThis model references `google.type.LatLng` from `google/type/latlng.proto`.\r\n\r\n```typespec\r\nmodel TypeSpec.Protobuf.WellKnown.LatLng\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type    | Description |\r\n| -------- | ------- | ----------- |\r\n| \\_extern | `never` |             |\n\n### `Timestamp` {#TypeSpec.Protobuf.WellKnown.Timestamp}\n\nA timestamp.\r\n\r\nThis model references `google.protobuf.Timestamp` from `google/protobuf/timestamp.proto`.\r\n\r\n```typespec\r\nmodel TypeSpec.Protobuf.WellKnown.Timestamp\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type    | Description |\r\n| -------- | ------- | ----------- |\r\n| \\_extern | `never` |             |\n", "latency": 7.093063592910767, "response_length": 473}
{"query": "title: Allowing \"breaking changes\" for brownfield conversion\n\nquestion: Hello, I'm converting a brownfield service (Key Vault) to TypeSpec. Because we can't match the original Swaggers exactly, there are errors reported in \"Swagger BreakingChange\" checks for each KV subservice;  we've confirmed that these changes are not actually breaking and will be a necessary part of the TSP migration.\nMike Kistler, Jeffrey Richter, is there a process to bypass migration-related breaking changes? Mike Harder informed me that there's a label for benign, approved changes -- should we add this to our PRs? Below are links to each.\nAdministration; Certificates; Keys; Secrets", "ground_truth": "The conversation discusses applying the appropriate \"BreakingChange-Approved\" label for changes to the typespec, including handling suppression requests for unsupported unixtime formats. For unixtime, it's agreed that legacy specifications can continue using it, but new specifications should avoid it. Suppressions for unixtime should be added to the readme.md, and approvals for these suppressions should be handled by the SDK team. The review of these suppressions can be requested through a specific channel.", "response": "Yes, there is a process to bypass migration-related breaking changes when converting a brownfield service to TypeSpec. You can use a specific label for approved, benign changes to indicate that the reported breaking changes are not actually breaking and are necessary for the migration. This approach is commonly used during TypeSpec migrations to handle discrepancies between the original Swagger definitions and the new TypeSpec implementation. Ensure that your team has reviewed and approved these changes as non-breaking before applying the label to your PRs.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#faq#breakingchange.md\n- document_title: Resolving Swagger Breaking Change Violations\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\n- document_content: # migrate-swagger#faq#breakingchange.md\n\n# Resolving Swagger Breaking Change Violations\n\nThe Swagger Converter will not be able to accurately represent every part of every API in TypeSpec. This document\r\noutlines some common changes you might need to make to a converted TypeSpec to make it conform to your existing service API and  \r\npass check-in validations.\n\n## Migrate ARM Specs\n\n### Changing the Names of Request Payload Parameters\n\nFor operations with non-empty request bodies (PUT, POST, PATCH), the TypeSpec operation templates provide a default name for the\r\nrequest parameter corresponding to the request payload. You can use augment decorators to make changes to this parameter, and other parts of the operation signature.\r\n\r\nThe following sections show how to do this for each operation template.\r\n\r\n#### CreateOrUpdate (PUT) APIs\r\n\r\nGiven a PUT operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  createOrUpdate is ArmResourceCreateOrReplaceAsync<Widget>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `resource` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.createOrUpdate::parameters.resource, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PUT operation template.\r\n\r\n#### Update (PATCH) APIs\r\n\r\nGiven a PATCH operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  update is ArmResourcePatchAsync<Widget, WidgetProperties>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `properties` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.update::parameters.properties, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ PATCH operation template.\n\n### Action (POST) APIs\n\nGiven a POST operation, for example:\r\n\r\n```tsp\r\ninterface Widgets {\r\n  mungeWidget is ArmResourceActionAsync<Widget, MungeRequest, MungeResponse>;\r\n}\r\n```\r\n\r\nThe name of the request body parameter is `body` so you can change the name in clients using an augment decorator\r\n\r\n```tsp\r\n@@clientName(Widgets.mungeWidget::parameters.body, \"<desired-request-body-parameter-name>\");\r\n```\r\n\r\nNote that this works for _any_ POST operation template.\n\n### Adding Request Query or Header Parameters\n\nThe `Parameters` template parameter allows you to specify additional parameters after the operation path (for example, query and header parameters) in the form of a model, with each model property corresponding to a parameter. You may use intersection to combine multiple separate parameters.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.StandardListQueryParameters\r\n>;\r\n\r\n// intersecting individual parameters\r\nop listBySubscription is ArmListBySubscription<\r\n  Widget,\r\n  Parameters = Azure.Core.TopQueryParameter & Azure.Core.SkipQueryParameter\r\n>;\r\n```\n\n### Changing Response Types\n\nThe `Response` parameter allows you to specify non-error responses to the operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Response = MyCustomCollectionType>;\r\n```\n\n### Changing Error Types\n\nThe `Error` parameter allows you to change the default error type used in an operation.\r\n\r\n```tsp\r\n// all list query params\r\nop listBySubscription is ArmListBySubscription<Widget, Error = MyCustomError>;\r\n```\n\n### Converting Synchronous Operations to LROs\n\nusing the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation. It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op doStuff is ArmResourceActionAsync<Resource, ActionRequest, ActionResponse>;\r\n\r\n  // with no request body\r\n  op doStuffNoRequest is ArmResourceActionAsync<Resource, void, ActionResponse>;\r\n\r\n  // with no response body\r\n  op doStuffCommand is ArmResourceActionAsync<Resource, ActionRequest, void>;\r\n  ```\r\n\r\n#### Templates for Async DELETE Operations\r\n\r\n- `ArmResourceDeleteWithoutOKAsync` is a DELETE operation that uses no request body, will return a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op delete is ArmResourceDeleteWithoutOKAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourceDeleteAsync`iis a DELETE operation that uses no request body, and return a `200` response in the case of a successful synchronous delete, a `202` response in the case of an Asynchronous delete operation, and a `204` response in case the resource does not exist.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmResourceDeleteAsync<Resource>;\r\n  ```\n\nYou can generally choose an asynchronous operation template that matches your operation.\r\n\r\n#### Templates for Async PUT Operations\r\n\r\n- `ArmCreateOrReplaceAsync` is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Location` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrReplaceAsync<Resource>;\r\n  ```\r\n\r\n- `ArmCreateOrUpdateAsync`is a PUT operation that uses the 'resource' definition in the request body, and return a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains 'Azure-AsyncOperation` LRO header.\r\n\r\n  ```tsp\r\n  op createOrUpdate is ArmCreateOrUpdateAsync<Resource>;\r\n  ```\r\n\r\n#### Templates for Async PATCH Operations\r\n\r\n- `ArmTagsPatchAsync` is a PATCH operation that only allows changing the resource tags (the minimum for Azure Resource Manager).\r\n\r\n  ```tsp\r\n  op update is ArmTagsPatchAsync<Resource>;\r\n  ```\r\n\r\n- `ArmResourcePatchAsync`is a PATCH operation that uses the visibility settings to select properties for the PATCH request body(any property with no visibility setting, or including visibility \"update\"). It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\r\n\r\n  ```tsp\r\n  op update is ArmResourcePatchAsync<Resource, ResourceProperties>;\r\n  ```\r\n\r\n- `ArmCustomPatchAsync`is a PATCH operation that allows you to customize the PATCH request body.\r\n\r\n  ```tsp\r\n  op update is ArmCustomPatchAsync<Resource, PatchRequestBody>;\r\n  ```\r\n\r\n#### Templates for Async POST (Action) Operations\r\n\r\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#checklists#migrate-dp-tips.md\n- document_title: Migrate data-plane specs\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\n- document_content: # migrate-swagger#checklists#migrate-dp-tips.md\n\n# Migrate data-plane specs\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\n\n## Initial pass through checklist\n\nwherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  color: WidgetColor;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n **DO** use `union` instead of `enum` to define Azure enums. See: [Defining enums for Azure services][no-enum]. Example:\r\n\r\n```tsp\r\n/** The color of a widget. */\r\nunion WidgetColor {\r\n  string,\r\n\r\n  /** Red Widget Color */\r\n  Red: \"Red\",\r\n\r\n  /** Green Widget Color */\r\n  Green: \"Green\",\r\n\r\n  /** Blue Widget Color */\r\n  Blue: \"Blue\",\r\n}\r\n```\r\n\r\n **DON'T** import or use templates from the `@azure-tools/typespec-azure-resource-manager` library in a data-plane specification\r\n\r\n **DO** make client customizations in a `client.tsp` file\r\n\r\n **DON'T** import or use `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\r\n\r\n **DO** run `tsp compile .` on your specification and address all warnings\n\n **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\r\n\r\n **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\r\n\r\n```yaml title=tspconfig.yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-rulesets/data-plane\"\r\n```\r\n\r\n **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\r\n\r\n **DO** use the built-in [url][url-type] for endpoint specification. Example:\r\n\r\n```tsp\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    /**\r\n      * Supported Widget Services endpoints (protocol and hostname, for example:\r\n      * https://westus.api.widget.contoso.com).\r\n      */\r\n    endpoint: url,\r\n  }\r\n)\r\n```\r\n\r\n **DO** ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]\r\n\r\n **DO** ensure you have versioning (`@versioned`) enabled over your service definition. See: [Versioning][versioning]\r\n\r\n **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\r\n\r\n **DO** review all enum definitions and add documentation over each value. See: [Documentation in TypeSpec][docs]\r\n\r\n **DON'T** suppress documentation warnings\r\n\r\n **DO** use the [standard Typespec Azure operation templates and data-types][standard-templates] wherever possible. Standard operation templates should be used as much as possible\r\n\r\n **DO** review model definitions and add the `@resource` decorator over models that represent resources in your service and the `@key` decorator for the resource identifier property on the model. Example:\r\n\r\n```tsp\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\n\n## Additional considerations\n\n **DO** ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\r\n\r\n **DO** run `npm ci` to get a clean install of the package.json dependencies\r\n\r\n **DON'T** modify the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\r\n\r\n **DON'T** add your own package.json or package-lock.json files in your project directory\r\n\r\n **DON'T** add multiple tspconfig.yaml files for your service specification\r\n\r\n **DO** consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\r\n\r\n<!-- LINKS -->\r\n\r\n[tspconfig]: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\r\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\r\n[docs]: https://typespec.io/docs/language-basics/documentation\r\n[standard-templates]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference\r\n[ci-fix]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md\r\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\r\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n", "latency": 7.89075231552124, "response_length": 563}
{"query": "title: Unions - `modelAsString:true` hinders RPaaS validation. How to resolve this?\n\nquestion: Hi\nTypeSpec Discussion\n, I'm working on a new swagger for our Resource Provider using RPaaS and while testing we realized that RPaaS isn't validating our properties which are modeled as union with string literals. Any value passed by the user for the enum fields are accepted and saved.\nWe raised this question to the RPaaS team (https://portal.microsofticm.com/imp/v5/incidents/details/577866916/summary) and they responded saying \"since the enum has modelAsString : true, they are treated as normal string and not validated\". They suggested to make \"modelAsString: false\" so that RPaaS validations can be kicked in.\nTo resolve this issue, I tried the following approaches -\nConverting union to enum - This doesn't pass TypeSpec CI validations (Azure services should not use the enum keyword. Extensible enums should be defined as unions with \"string\" as an accepted variant)\nSuppressing the warning \"@azure-tools/typespec-azure-core/no-enum\" - But the Typespec validation still fails.\nUsing union without the string literal and suppressing the warning as mentioned below - This approach works and the CI validation also succeeds, but we wanted to understand if this is the right approach?\nNote - This is the snippet for Private Preview of the feature, post that we might have to add other values to the union as well.\n```typescript\n@doc(\"The state of the connector\")\nunion State {\n@doc(\"Whether the connector is enabled\")\nEnabled: \"Enabled\",\n@doc(\"Whether the connector is disabled\")\nDisabled: \"Disabled\",\n}\n```\nCould someone please help understand if we should go ahead with approach #3 and whether we would be able to add new values to the union later? If not, what is the recommended approach such that \"modelAsString: false\" is present and RPaaS validations work.\nOther alternative we have is for the UserRP to validate the enum values (but since most of the other validations are already done by RPaaS, we would want this to be handled by them).\nThanks!", "ground_truth": "In this conversation, the discussion revolves around using enums and unions in TypeSpec for API validation, especially when considering backward compatibility across API versions. The main point is that using modelAsString: true allows for flexibility and avoids breaking changes when new enum values are added in future versions. This is crucial because closed enums will cause a breaking change if new values are added, even in a new API version.\nIf modelAsString: false is used, adding new enum values would be a breaking change, as the enum is closed. The recommendation is to use unions (which are extensible) instead of enums, as unions allow for future expansion without breaking previous versions of the API.\nIf validation is required on the RPaaS side, a custom validation extension could be implemented, ensuring that any new values are handled appropriately. It's also advised to keep the enum open for future versions, and not make it closed unless absolutely necessary, as it could lead to issues when adding new values in later versions.\nFor older API versions, if a new enum value is introduced, it should be handled carefully to avoid issues with ARM, which requires resources to be compatible across API versions. In practice, this means either ignoring the new field in older versions or returning a default/empty value, depending on the specific requirements.", "response": "The recommended approach to resolve the issue is to use an extensible union by adding the base scalar type (`string`) to the union. This ensures compliance with TypeSpec validation rules and allows RPaaS to validate the values properly. Additionally, this approach aligns with Azure's preference for extensible enums to avoid breaking changes when new values are added.\n\nHere is the corrected snippet:\n```typescript\n@doc(\"The state of the connector\")\nunion State {\n  @doc(\"Whether the connector is enabled\")\n  Enabled: \"Enabled\",\n  @doc(\"Whether the connector is disabled\")\n  Disabled: \"Disabled\",\n  string,\n}\n```\n\nThis approach ensures that the union is extensible and avoids the `@azure-tools/typespec-azure-core/no-closed-literal-union` validation error. You will also be able to add new values to the union later without breaking changes.", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#07types.mdx\n- document_title: Generated Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/07types\n- document_content: # howtos#generate-client-libraries#07types.mdx\n\n# Generated Types\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents what type definitions in TypeSpec are generated as in emitted libraries\n\n## Namespace\n\nThe namespace for models, enums, and unions will follow the namespace they belong to. You can use `@clientNamespace` to override it if needed.\n\n### Model in namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in sub namespace\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\nnamespace Container {\r\n  model Foo {\r\n    prop: string;\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Model in namespace with renaming\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nnamespace Service;\r\n\r\n@clientNamespace(\"Service.Container\")\r\nmodel Foo {\r\n  prop: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom service.container.models import Foo\r\n\r\nfoo = Foo(prop=\"hello\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\r\n\r\n```java\r\nimport service.container.models.Foo;\r\n\r\nFoo foo = new Foo(\"hello\");\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Client Documentation\n\nThe `@clientDoc` decorator lets you add documentation that will appear in generated client libraries. This is useful for providing additional context, examples, or implementation notes that are only relevant for SDK consumers.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@doc(\"This internal model is the base class for shapes\")\r\n@clientDoc(\r\n  \"Base class for all shape objects that can be drawn on a canvas\",\r\n  DocumentationMode.replace\r\n)\r\nmodel Shape {\r\n  @doc(\"The coordinates of the shape\")\r\n  @clientDoc(\r\n    \"The x,y coordinates where the shape will be positioned on the canvas\",\r\n    DocumentationMode.replace\r\n  )\r\n  position: Point;\r\n}\r\n\r\n@doc(\"A two-dimensional point\")\r\n@clientDoc(\"Represents a position in a 2D coordinate system\", DocumentationMode.replace)\r\nmodel Point {\r\n  @doc(\"X coordinate\")\r\n  @clientDoc(\"The horizontal position (increases moving right)\", DocumentationMode.replace)\r\n  x: float32;\r\n\r\n  @doc(\"Y coordinate\")\r\n  @clientDoc(\"The vertical position (increases moving down)\", DocumentationMode.replace)\r\n  y: float32;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nclass Point(_model_base.Model):\r\n    \"\"\"Represents a position in a 2D coordinate system.\r\n\r\n    :param x: The horizontal position (increases moving right)\r\n    :type x: float\r\n    :param y: The vertical position (increases moving down)\r\n    :type y: float\r\n    \"\"\"\r\n\r\n    x: float = rest_field()\r\n    \"\"\"The horizontal position (increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\n\non the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\r\n     * The x,y coordinates where the shape will be positioned on the canvas.\r\n     */\r\n    private Point position;\r\n\r\n    /**\r\n     * Get the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @return the position value.\r\n     */\r\n    public Point getPosition() {\r\n        return this.position;\r\n    }\r\n\r\n    /**\r\n     * Set the position property: The x,y coordinates where the shape will be positioned on the canvas.\r\n     *\r\n     * @param position the position value to set.\r\n     * @return the Shape object itself.\r\n     */\r\n    public Shape setPosition(Point position) {\r\n        this.position = position;\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system.\r\n */\r\n@Fluent\r\npublic final class Point {\r\n    /**\r\n     * The horizontal position (increases moving right).\r\n     */\r\n    private float x;\r\n\r\n    /**\r\n     * The vertical position (increases moving down).\r\n     */\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\n\n*/\r\n    private float y;\r\n\r\n    /**\r\n     * Get the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @return the x value.\r\n     */\r\n    public float getX() {\r\n        return this.x;\r\n    }\r\n\r\n    /**\r\n     * Set the x property: The horizontal position (increases moving right).\r\n     *\r\n     * @param x the x value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setX(float x) {\r\n        this.x = x;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Get the y property: The vertical position (increases moving down).\r\n     *\r\n     * @return the y value.\r\n     */\r\n    public float getY() {\r\n        return this.y;\r\n    }\r\n\r\n    /**\r\n     * Set the y property: The vertical position (increases moving down).\r\n     *\r\n     * @param y the y value to set.\r\n     * @return the Point object itself.\r\n     */\r\n    public Point setY(float y) {\r\n        this.y = y;\r\n        return this;\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// Shape - Base class for all shape objects that can be drawn on a canvas\r\ntype Shape struct {\r\n\t// Position - The x,y coordinates where the shape will be positioned on the canvas\r\n\tPosition *Point\r\n}\r\n\r\n// Point - Represents a position in a 2D coordinate system\r\ntype Point struct {\r\n\t// X - The horizontal position (increases moving right)\r\n\tX *float32\r\n\r\n\t// Y - The vertical position (increases moving down)\r\n\tY *float32\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nThe `@clientDoc` decorator can be used on everything that the `@doc` decorator can be applied to.\r\n\r\nWhen both `@doc` and `@clientDoc` are present, TCGC outputs the final documentation depending on the mode that you called `@clientDoc` with.\r\nIf called with `replace`, `@clientDoc` replaces `@doc` completely. If called with `append`, `@clientDoc` is appended onto `@doc`.\n\n(increases moving right).\"\"\"\r\n    y: float = rest_field()\r\n    \"\"\"The vertical position (increases moving down).\"\"\"\r\n\r\nclass Shape(_model_base.Model):\r\n    \"\"\"Base class for all shape objects that can be drawn on a canvas.\r\n\r\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\r\n    :type position: Point\r\n    \"\"\"\r\n\r\n    position: Point = rest_field()\r\n    \"\"\"The x,y coordinates where the shape will be positioned on the canvas.\"\"\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n/// <summary>\r\n/// Base class for all shape objects that can be drawn on a canvas\r\n/// </summary>\r\npublic partial class Shape\r\n{\r\n    /// <summary>\r\n    /// The x,y coordinates where the shape will be positioned on the canvas\r\n    /// </summary>\r\n    public Point Position { get; set; }\r\n}\r\n\r\n/// <summary>\r\n/// Represents a position in a 2D coordinate system\r\n/// </summary>\r\npublic partial class Point\r\n{\r\n    /// <summary>\r\n    /// The horizontal position (increases moving right)\r\n    /// </summary>\r\n    public float X { get; set; }\r\n\r\n    /// <summary>\r\n    /// The vertical position (increases moving down)\r\n    /// </summary>\r\n    public float Y { get; set; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas\r\n */\r\nexport interface Shape {\r\n  /**\r\n   * The x,y coordinates where the shape will be positioned on the canvas\r\n   */\r\n  position: Point;\r\n}\r\n\r\n/**\r\n * Represents a position in a 2D coordinate system\r\n */\r\nexport interface Point {\r\n  /**\r\n   * The horizontal position (increases moving right)\r\n   */\r\n  x: number;\r\n\r\n  /**\r\n   * The vertical position (increases moving down)\r\n   */\r\n  y: number;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n/**\r\n * Base class for all shape objects that can be drawn on a canvas.\r\n */\r\n@Fluent\r\npublic final class Shape {\r\n    /**\n\n## Models\n\n### Flattening\n\n:::caution\r\nFlattening is NOT a recommended pattern, and you shouldn't use it unless told by SDK architects.\r\n:::\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Properties {\r\n  name: string;\r\n}\r\n\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Properties;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"prop\",\r\n      \"serializedName\": \"prop\",\r\n      \"flatten\": true,\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"model\",\r\n        \"name\": \"Properties\",\r\n        \"properties\": [\r\n          {\r\n            \"kind\": \"property\",\r\n            \"name\": \"name\",\r\n            \"serializedName\": \"name\",\r\n            \"flatten\": false,\r\n            \"optional\": false,\r\n            \"type\": {\r\n              \"kind\": \"string\",\r\n              \"encode\": \"string\"\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will do dynamic flattening, exposing the non-flattening syntax, and dynamically accepting the flattened access.\r\n\r\n```python\r\nclass Properties(_model_base.Model):\r\n    name: str = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\nclass Foo(_model_base.Model):\r\n    properties: \"_models.Properties\" = rest_field()\r\n    \"\"\"Required.\"\"\"\r\n\r\n    __flattened_items = [\"properties\"]\r\n\r\nprint(f.properties.name)  # Non-flattened access is preferred experience\r\nprint(f.name)  # Flattened access is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\n\nreturn null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\r\n                    if (property0.NameEquals(\"name\"u8))\r\n                    {\r\n                        name = property0.Value.GetString();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return new Foo(name);\r\n    }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// Please note that this feature is not supported right now, and the model will be generated un-flattened.\r\n// Please comment and follow work status on: https://github.com/Azure/autorest.typescript/issues/2164\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nIn Java, `@flattenProperty` have no effect on generated libraries.\r\n\r\n```java\r\n@Fluent\r\npublic final class Properties {\r\n    public Properties();\r\n    public String getName();\r\n    public Properties setName(String name);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\naccess is dynamically supported, but not documented\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nCSharp will generate the model with properties being flattened. During serialization/deserialization, the model will be serialized/deserialized as a non-flattened model.\r\n\r\n```csharp\r\npublic partial class Foo\r\n{\r\n    public Foo(string name)\r\n    {\r\n        Argument.AssertNotNull(name, nameof(name));\r\n\r\n        Name = name;\r\n    }\r\n\r\n    public string Name { get; set; }\r\n}\r\n\r\npublic partial class Foo : IUtf8JsonSerializable, IJsonModel<Foo>\r\n{\r\n    void IJsonModel<Foo>.Write(Utf8JsonWriter writer, ModelReaderWriterOptions options)\r\n    {\r\n        var format = options.Format == \"W\" ? ((IPersistableModel<Foo>)this).GetFormatFromOptions(options) : options.Format;\r\n        if (format != \"J\")\r\n        {\r\n            throw new FormatException($\"The model {nameof(Foo)} does not support writing '{format}' format.\");\r\n        }\r\n\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"properties\"u8);\r\n        writer.WriteStartObject();\r\n        writer.WritePropertyName(\"name\"u8);\r\n        writer.WriteStringValue(Name);\r\n        writer.WriteEndObject();\r\n        writer.WriteEndObject();\r\n    }\r\n\r\n    internal static Foo DeserializeFoo(JsonElement element, ModelReaderWriterOptions options = null)\r\n    {\r\n        options ??= ModelSerializationExtensions.WireOptions;\r\n\r\n        if (element.ValueKind == JsonValueKind.Null)\r\n        {\r\n            return null;\r\n        }\r\n        string name = default;\r\n        foreach (var property in element.EnumerateObject())\r\n        {\r\n            if (property.NameEquals(\"properties\"u8))\r\n            {\r\n                if (property.Value.ValueKind == JsonValueKind.Null)\r\n                {\r\n                    property.ThrowNonNullablePropertyIsNull();\r\n                    continue;\r\n                }\r\n                foreach (var property0 in property.Value.EnumerateObject())\r\n                {\n\n### Models with additional properties\n\n#### Additional properties of any type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nRecommend usage:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<unknown>;\r\n}\r\n```\r\n\r\nOther usages:\r\n\r\n```typespec\r\nmodel Animal extends Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal is Record<unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"any\"\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\n\npublic IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, BinaryData> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, BinaryData> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of nullable type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | null>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\n\n[\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\r\n    \"properties\": [\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"category\",\r\n        \"serializedName\": \"category\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      },\r\n      {\r\n        \"kind\": \"property\",\r\n        \"name\": \"value\",\r\n        \"serializedName\": \"value\",\r\n        \"optional\": false,\r\n        \"type\": {\r\n          \"kind\": \"any\"\r\n        }\r\n      }\r\n    ],\r\n    \"additionalProperties\": undefined\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom typing import Any\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nclass AnimalProperty(_model_base.Model):\r\n\r\n    category: str = rest_field()\r\n    value: Any = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...\n\nAnimal : IJsonModel<Animal> {\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalOutput extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for both legacy and non legacy\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, Object> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, Object> additionalProperties);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of specific type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\n\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"model\",\r\n    \"name\": \"AnimalProperty\",\n\ncategory: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for non-legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal {\r\n  name: string;\r\n  kind: string;\r\n  additionalProperties: Record<string, AnimalProperty>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, AnimalProperty> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, AnimalProperty> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\n#### Additional properties of union type\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string | int32>;\r\n}\r\n```\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n  ...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\n\n...Record<int32>;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Animal\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"name\",\r\n      \"serializedName\": \"name\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"kind\",\r\n      \"serializedName\": \"kind\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"union\",\r\n    \"name\": \"AnimalAdditionalProperty\",\r\n    \"generatedName\": true,\r\n    \"values\": [\r\n      {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      },\r\n      {\r\n        \"kind\": \"int32\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"age\"] = 5\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | number> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\n\nfalse,\r\n      \"type\": {\r\n        \"kind\": \"string\",\r\n        \"encode\": \"string\"\r\n      }\r\n    }\r\n  ],\r\n  \"additionalProperties\": {\r\n    \"kind\": \"nullable\",\r\n    \"valueType\": {\r\n      \"kind\": \"string\",\r\n      \"encode\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython models are designed to support adding any additional properties.\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_field\r\n\r\nclass Animal(_model_base.Model):\r\n\r\n    name: str = rest_field()\r\n    kind: str = rest_field()\r\n\r\nanimal = Animal(name=\"Tom\", kind=\"Cat\")\r\nanimal[\"friend\"] = \"Jerry\"\r\nanimal[\"alert\"] = None\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input and output\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy and non-legacy clients\r\nexport interface Animal extends Record<string, string | null> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n@Fluent\r\npublic final class Animal implements JsonSerializable<Animal> {\r\n    public Animal(String name, String kind);\r\n    public String getName();\r\n    public String getKind();\r\n    public Map<String, String> getAdditionalProperties();\r\n    public Animal setAdditionalProperties(Map<String, String> additionalProperties);\r\n}\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n= AnimalProperty(category=\"relationship\", value=\"Jerry\")\r\nanimal[\"age\"] = AnimalProperty(category=\"attribute\", value=5)\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nDue to currently there is no way to know whether a Json could be correctly mapped into the specified type in `.Net`, we currently generate any non-primitive value type in additional properties property as `BinaryData`.\r\n\r\nFor typespec:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<AnimalProperty>;\r\n}\r\n```\r\n\r\nThe `C#` generated code is the same as if the type is `unknown`:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, BinaryData> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\nFor typespec with additional properties of primitive types:\r\n\r\n```typespec\r\nmodel Animal {\r\n  name: string;\r\n  kind: string;\r\n  ...Record<string>;\r\n}\r\n```\r\n\r\nThe `C#` generated code still has the specified type in `AdditionalProperties` property:\r\n\r\n```csharp\r\npublic partial class Animal : IJsonModel<Animal>\r\n{\r\n    public Animal(string name, string kind);\r\n\r\n    public string Name { get; }\r\n    public string Kind { get; }\r\n\r\n    public IDictionary<string, string> AdditionalProperties { get; }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: unknown;\r\n}\r\nexport interface Animal extends Record<string, unknown> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// RLC output\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\r\n  kind: string;\r\n}\r\n\r\n// Modular for legacy clients\r\nexport interface AnimalProperty {\r\n  category: string;\r\n  value: any;\r\n}\r\nexport interface Animal extends Record<string, any> {\r\n  name: string;\n\n### Discriminator\n\nSiamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\r\nexport interface CatOutputParent {\r\n  kind: string;\r\n}\r\n\r\nexport interface SiameseOutput extends CatOutputParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface RagdollOutput extends CatOutputParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type CatOutput = CatOutputParent | SiameseOutput | RagdollOutput;\r\n\r\n// Modular models\r\n/** model interface Cat */\r\nexport interface Cat {\r\n  kind: string;\r\n}\r\n\r\n/** Alias for CatUnion */\r\nexport type CatUnion = Siamese | Ragdoll | Cat;\r\n\r\n/** model interface Siamese */\r\nexport interface Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n/** model interface Ragdoll */\r\nexport interface Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic class Cat implements JsonSerializable<Cat> {\r\n    public Cat();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Ragdoll extends Cat {\r\n    public Ragdoll();\r\n    public String getKind();\r\n}\r\n\r\npublic final class Siamese extends Cat {\r\n    public Siamese();\r\n    public String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\n\n\"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      // the same instance of the model Siamese as we have above in `discriminatedSubtype` property\r\n    },\r\n    {\r\n      // the same instance of the model Ragdoll as we have above in `discriminatedSubtype` property\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom .. import _model_base\r\nfrom .._model_base import rest_discriminator, rest_field\r\n\r\nclass Cat(_model_base.Model):\r\n    kind: str = rest_discriminator(name=\"kind\")\r\n\r\nclass Siamese(Cat):\r\n    kind: Literal[\"siamese\"] = rest_discriminator(name=\"kind\")\r\n\r\nclass Ragdoll(Cat):\r\n    kind: Literal[\"ragdoll\"] = rest_discriminator(name=\"kind\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nIn .Net generated code, the discriminator property will be generated as internal by default, but configurable to be public.\r\n\r\n```csharp\r\npublic abstract partial class Cat\r\n{\r\n  protected Cat()\r\n  {\r\n  }\r\n\r\n  internal string Kind { get; set; }\r\n}\r\n\r\npublic partial class Siamese : Cat\r\n{\r\n  public Siamese() : base()\r\n  {\r\n    Kind = \"siamese\";\r\n  }\r\n}\r\n\r\npublic partial class Ragdoll : Cat\r\n{\r\n  public Ragdoll() : base()\r\n  {\r\n    Kind = \"ragdoll\";\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```ts\r\n// RLC input models\r\nexport interface Siamese extends CatParent {\r\n  kind: \"siamese\";\r\n}\r\n\r\nexport interface Ragdoll extends CatParent {\r\n  kind: \"ragdoll\";\r\n}\r\n\r\nexport type Cat = CatParent | Siamese | Ragdoll;\r\n\r\n// RLC output models\n\nTypeSpec uses `@discriminator` decorator to add a discriminator to a model.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\nTypeSpec now has two ways to represent a discriminated set.\r\n\r\n1. Use model\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: string;\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: \"siamese\";\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: \"ragdoll\";\r\n}\r\n```\r\n\r\nThe type of the discriminator property could be an enum (extensible or fixed):\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Cat {\r\n  kind: CatKind;\r\n}\r\n\r\nunion CatKind {\r\n  string,\r\n  Siamese: \"siamese\",\r\n  Ragdoll: \"ragdoll\",\r\n}\r\n\r\nmodel Siamese extends Cat {\r\n  kind: CatKind.Siamese;\r\n}\r\n\r\nmodel Ragdoll extends Cat {\r\n  kind: CatKind.Ragdoll;\r\n}\r\n```\r\n\r\n2. Use union\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nunion Cat {\r\n  Siamese,\r\n  Ragdoll,\r\n}\r\n\r\nmodel Siamese {}\r\n\r\nmodel Ragdoll {}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nTCGC currently only supports the discriminated set based on models, discriminated union is not supported yet.\r\n\r\nThis is a brief structure of the models in a discriminated set in the output of TCGC.\r\n\r\n```json\r\n{\r\n  \"models\": [\r\n    {\r\n      \"kind\": \"model\",\r\n      \"name\": \"Cat\",\r\n      \"properties\": [\r\n        {\r\n          \"kind\": \"property\",\r\n          \"name\": \"kind\",\r\n          \"type\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"discriminator\": true\r\n        }\r\n      ],\r\n      \"discriminatorProperty\": {\r\n        // the same instance of the property in the properties list here\r\n      },\r\n      \"discriminatedSubtype\": {\r\n        \"siamese\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Siamese\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"siamese\"\r\n        },\r\n        \"ragdoll\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Ragdoll\",\r\n          \"properties\": [],\r\n          \"discriminatorValue\": \"ragdoll\"\r\n        }\r\n      }\r\n    },\r\n    {\n\npublic String getKind();\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n<ClientTabItem lang=\"go\">\r\n\r\n```go\r\n// CatClassification provides polymorphic access to related types.\r\n// Call the interface's GetCat() method to access the common type.\r\n// Use a type switch to determine the concrete type.  The possible types are:\r\n// - *Cat, *Ragdoll, *Siamese\r\ntype CatClassification interface {\r\n\t// GetCat returns the Cat content of the underlying type.\r\n\tGetCat() *Cat\r\n}\r\n\r\ntype Cat struct {\r\n\t// REQUIRED\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Cat.\r\nfunc (c *Cat) GetCat() *Cat { return c }\r\n\r\ntype Ragdoll struct {\r\n\t// CONSTANT; undefinedField has constant value \"ragdoll\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Ragdoll.\r\nfunc (e *Ragdoll) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n\r\ntype Siamese struct {\r\n\t// CONSTANT; undefinedField has constant value \"siamese\", any specified value is ignored.\r\n\tKind *string\r\n}\r\n\r\n// GetCat implements the CatClassification interface for type Siamese.\r\nfunc (e *Siamese) GetCat() *Cat {\r\n\treturn &Cat{\r\n\t\tKind:     e.Kind,\r\n\t}\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Nullable\n\n\"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"union\",\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Bar\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"string\",\r\n                    \"encode\": \"string\"\r\n                  }\r\n                }\r\n              ]\r\n            },\r\n            {\r\n              \"kind\": \"model\",\r\n              \"name\": \"Baz\",\r\n              \"properties\": [\r\n                {\r\n                  \"kind\": \"property\",\r\n                  \"name\": \"prop\",\r\n                  \"serializedName\": \"prop\",\r\n                  \"optional\": false,\r\n                  \"type\": {\r\n                    \"kind\": \"int32\",\r\n                    \"encode\": \"int32\"\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\n\nTypeSpec uses `| null` to represent nullable types. Nullability is handled differently in languages, but emitter authors will find information\r\nabout nullability by inspecting the type of a property.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Foo {\r\n  basicNullableProperty: string | null;\r\n  modelNullableProperty: Bar | null;\r\n  unionNullableProperty: Bar | Baz | null;\r\n  enumNullableProperty: LR | null;\r\n}\r\n\r\nmodel Bar {\r\n  prop: string;\r\n}\r\n\r\nmodel Baz {\r\n  prop: int32;\r\n}\r\n\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\nA nullable type has kind `nullable` and property `valueType`. The kind of the type tells you the property is nullable, while the `valueType` tells you the underlying type you want to generate.\r\n\r\n```json\r\n{\r\n  \"kind\": \"model\",\r\n  \"name\": \"Foo\",\r\n  \"properties\": [\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"basicNullableProperty\",\r\n      \"serializedName\": \"basicNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"string\",\r\n          \"encode\": \"string\"\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"modelNullableProperty\",\r\n      \"serializedName\": \"modelNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"model\",\r\n          \"name\": \"Bar\",\r\n          \"properties\": [\r\n            {\r\n              \"kind\": \"property\",\r\n              \"name\": \"prop\",\r\n              \"serializedName\": \"prop\",\r\n              \"optional\": false,\r\n              \"type\": {\r\n                \"kind\": \"string\",\r\n                \"encode\": \"string\"\r\n              }\r\n            }\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"unionNullableProperty\",\r\n      \"serializedName\": \"unionNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\n\n}\r\n          ]\r\n        }\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"property\",\r\n      \"name\": \"enumNullableProperty\",\r\n      \"serializedName\": \"enumNullableProperty\",\r\n      \"optional\": false,\r\n      \"type\": {\r\n        \"kind\": \"nullable\",\r\n        \"valueType\": {\r\n          \"kind\": \"enum\",\r\n          \"name\": \"LR\",\r\n          \"generatedName\": false,\r\n          \"valueType\": {\r\n            \"kind\": \"string\"\r\n          },\r\n          \"values\": [\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"left\",\r\n              \"value\": \"left\"\r\n            },\r\n            {\r\n              \"kind\": \"enumvalue\",\r\n              \"name\": \"right\",\r\n              \"value\": \"right\"\r\n            }\r\n          ],\r\n          \"isFixed\": true,\r\n          \"isUnionAsEnum\": false\r\n        }\r\n      }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython treat nullable as optional. If you actually want to send the value `null` to the service without the property being ignored, you can send in `corehttp.serialization.NULL`. Python does not restrict you from setting any property to this value.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Bar(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass Baz(_model_base.Model):\r\n  prop: Optional[str] = rest_field()\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n\r\nclass Foo(_model_base.Model):\r\n  basicNullableProperty: Optional[str] = rest_field()\r\n  modelNullableProperty: Optional[\"_models.Bar\"] = rest_field()\r\n  unionNullableProperty: Optional[Union[\"_models.Bar\", \"_models.Baz\"]] = rest_field()\r\n  enumNullableProperty: Optional[\"LR\"] = rest_field()\r\n\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\nTODO\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Unions\n\n### Union of literals with same type\n\nAll emitters will generate their version of a closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enum by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\nSerialization/deserialization will respect the value defined, in this case it is \"left\" for `LR.Left` and \"right\" for `LR.Right` respectively.\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of literals with same type\n\nThis is union defined inline at point of usage.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetHorizontals\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates this as a union of literals, not as enum. We also don't generate a closed set of literals.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  horizontal: Union[Literal[\"left\"] | Literal[\"right\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetHorizontal Horizontal;\r\n}\r\npublic enum WidgetHorizontal\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  horizontal: \"left\" | \"right\";\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetHorizontal {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of basic type and literals of that type\n\nEach language will generate their version of an open enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion Colors {\r\n  string,\r\n  red: \"red\",\r\n  blue: \"blue\",\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Colors\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates open enum again here.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Colors(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  RED = \"red\"\r\n  BLUE = \"blue\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct Colors : IEquatable<Colors>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static Colors Red { get; } = new Colors(RedValue);\r\n  public static Colors Blue { get; } = new Colors(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Colors = string | \"red\" | \"blue\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Colors extends ExpandableStringEnum<Colors> {\r\n    public static final Colors RED = fromString(\"red\");\r\n    public static final Colors BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of basic type and literals of that type\n\nThis is union defined inline at point of usage which include the base type as an option.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetColors\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"red\",\r\n      \"value\": \"red\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"blue\",\r\n      \"value\": \"blue\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a union of literals again.\r\n\r\n```python\r\nfrom typing import Literal, Union\r\n\r\nmodel Widget:\r\n  color: Union[Literal[\"red\"] | Literal[\"blue\"] | str]\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetColor Color;\r\n}\r\npublic readonly partial struct WidgetColor : IEquatable<WidgetColor>\r\n{\r\n  private const string RedValue = \"red\";\r\n  private const string BlueValue = \"blue\";\r\n  public static WidgetColor Red { get; } = new WidgetColor(RedValue);\r\n  public static WidgetColor Blue { get; } = new WidgetColor(BlueValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  color: \"red\" | \"blue\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class WidgetColor extends ExpandableStringEnum<Colors> {\r\n    public static final Color RED = fromString(\"red\");\r\n    public static final Color BLUE = fromString(\"blue\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Union of other union/enum, basic type and literals of that type\n\n\"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates a single open enum.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass ProvisioningState(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  INPROGRESS = \"InProgress\"\r\n  SUCCEEDED = \"Succeeded\"\r\n  FAILED = \"Failed\"\r\n  CANCELED = \"Canceled\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic readonly partial struct ProvisioningState : IEquatable<ProvisioningState>\r\n{\r\n  private const string SucceededValue = \"Succeeded\";\r\n  private const string FailedValue = \"Failed\";\r\n  private const string CanceledValue = \"Canceled\";\r\n  private const string InProgressValue = \"InProgress\";\r\n\r\n  public static ProvisioningState Succeeded { get; } = new ProvisioningState(SucceededValue);\r\n  public static ProvisioningState Failed { get; } = new ProvisioningState(FailedValue);\r\n  public static ProvisioningState Canceled { get; } = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n} = new ProvisioningState(CanceledValue);\r\n  public static ProvisioningState InProgress { get; } = new ProvisioningState(InProgressValue);\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type ResourceProvisioningState = \"Succeeded\" | \"Failed\" | \"Canceled\";\r\n// NOTE: extensible enum design may change in JS\r\nexport type ProvisioningState = string | \"InProgress\" | ResourceProvisioningState;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class ProvisioningState extends ExpandableStringEnum<ProvisioningState> {\r\n    public static final ProvisioningState INPROGRESS = fromString(\"InProgress\");\r\n    public static final ProvisioningState SUCCEEDED = fromString(\"Succeeded\");\r\n    public static final ProvisioningState FAILED = fromString(\"Failed\");\r\n    public static final ProvisioningState CANCELED = fromString(\"Canceled\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nimport \"@azure-tools/typespec-azure-resource-manager\";\r\n\r\nunion ProvisioningState {\r\n  string,\r\n  \"InProgress\",\r\n  Azure.ResourceManager.ResourceProvisioningState,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"InProgress\",\r\n      \"value\": \"InProgress\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Succeeded\",\r\n      \"value\": \"Succeeded\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Failed\",\r\n      \"value\": \"Failed\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"Canceled\",\r\n      \"value\": \"Canceled\"\r\n    }\r\n  ],\r\n  \"isFixed\": false,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ProvisioningState\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"string\"\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"InProgress\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"ResourceProvisioningState\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Succeeded\",\r\n          \"value\": \"Succeeded\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Failed\",\r\n          \"value\": \"Failed\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"Canceled\",\r\n          \"value\": \"Canceled\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": false\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\n\n### Union of other unions of literals with same type\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nunion Orientation {\r\n  LR,\r\n  UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\n\ntrue,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\nexport type Orientation = LR | UD;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Inline union of other unions of literals with same type\n\n],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nSince this is inline, Python will generate this as a single union of all possible literal values.\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype WidgetOrientation = \"left\" | \"right\" | \"up\" | \"down\" | str\r\n\r\nmodel Widget:\r\n  orientation: WidgetOrientation\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Widget\r\n{\r\n  public WidgetOrientation Orientation;\r\n}\r\npublic enum WidgetOrientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Widget {\r\n  orientation: LR | UD;\r\n}\r\n\r\nexport type LR = \"left\" | \"right\";\r\nexport type UD = \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum WidgetOrientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nunion LR {\r\n  left: \"left\",\r\n  right: \"right\",\r\n}\r\n\r\nunion UD {\r\n  up: \"up\",\r\n  down: \"down\",\r\n}\r\n\r\nmodel Widget {\r\n  orientation: LR | UD;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\nFor union of other union or enum. TCGC will do the flatten according to the flag.\r\n\r\nWith `flatten-union-as-enum` flagged `true`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": true\r\n}\r\n```\r\n\r\nWith `flatten-union-as-enum` flagged `false`:\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"WidgetOrientations\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"LR\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"left\",\r\n          \"value\": \"left\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"right\",\r\n          \"value\": \"right\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\r\n    },\r\n    {\r\n      \"kind\": \"enum\",\r\n      \"name\": \"UD\",\r\n      \"generatedName\": false,\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      },\r\n      \"values\": [\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"up\",\r\n          \"value\": \"up\"\r\n        },\r\n        {\r\n          \"kind\": \"enumvalue\",\r\n          \"name\": \"down\",\r\n          \"value\": \"down\"\r\n        }\r\n      ],\r\n      \"isFixed\": true,\r\n      \"isUnionAsEnum\": true\n\n### Union with multiple types\n\nThese are unions where the values don't share same type.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nmodel Shirt {\r\n  sizing: 32 | 34 | int32 | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"union\",\r\n  \"name\": \"ShirtSizings\",\r\n  \"generatedName\": true,\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 32,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": 34,\r\n      \"valueType\": {\r\n        \"kind\": \"int32\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"small\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"constant\",\r\n      \"value\": \"medium\",\r\n      \"valueType\": {\r\n        \"kind\": \"string\"\r\n      }\r\n    },\r\n    {\r\n      \"kind\": \"string\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython will generate this as a union since these entries don't share the same type\r\n\r\n```python\r\nfrom typing import Literal\r\n\r\ntype ShirtSizing = Literal[32] | Literal[34] | int | Literal[\"small\"] | Literal[\"medium\"] | str\r\n\r\nmodel Shirt:\r\n  sizing: ShirtSizing\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic partial class Shirt\r\n{\r\n  public BinaryData Shirt;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport interface Shirt {\r\n  sizing: 32 | 34 | number | \"small\" | \"medium\" | string;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic final class Shirt {\r\n    private BinaryData sizing;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Enums\n\n### Standard\n\nStandard enums will be generated as closed enums.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"LR\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython never generates closed enums by design. We will always permit users to pass in additional values.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass LR(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum LR\r\n{\r\n  Left,\r\n  Right\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type LR = \"left\" | \"right\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum LR {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Versioning Enums\n\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\n@versioned(Versions)\r\n@service\r\nnamespace Service;\r\n\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Versions\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v1\",\r\n      \"value\": \"v1\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"v2\",\r\n      \"value\": \"v2\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false,\r\n  \"usage\": 8\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```\n\n# Python does not generate the enum used for versioning\n\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// CSharp does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\n// JS does not generate the enum used for versioning\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V1(\"v1\"),\r\n    V2(\"v2\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n### Spread\n\nSpreading enums will return the resultant enum as a new single closed enum.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```typespec\r\nenum LR {\r\n  left,\r\n  right,\r\n}\r\n\r\nenum UD {\r\n  up,\r\n  down,\r\n}\r\n\r\nenum Orientation {\r\n  ...LR,\r\n  ...UD,\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"enum\",\r\n  \"name\": \"Orientation\",\r\n  \"generatedName\": false,\r\n  \"valueType\": {\r\n    \"kind\": \"string\"\r\n  },\r\n  \"values\": [\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"left\",\r\n      \"value\": \"left\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"right\",\r\n      \"value\": \"right\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"up\",\r\n      \"value\": \"up\"\r\n    },\r\n    {\r\n      \"kind\": \"enumvalue\",\r\n      \"name\": \"down\",\r\n      \"value\": \"down\"\r\n    }\r\n  ],\r\n  \"isFixed\": true,\r\n  \"isUnionAsEnum\": false\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\nPython generates one open enum, because Python never generates an enum as fully closed.\r\n\r\n```python\r\nfrom enum import Enum\r\nfrom corehttp.utils import CaseInsensitiveEnumMeta\r\n\r\nclass Orientation(str, Enum, metaclass=CaseInsensitiveEnumMeta):\r\n  LEFT = \"left\"\r\n  RIGHT = \"right\"\r\n  UP = \"up\"\r\n  DOWN = \"down\"\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\npublic enum Orientation\r\n{\r\n  Left,\r\n  Right,\r\n  Up,\r\n  Down\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nexport type Orientation = \"left\" | \"right\" | \"up\" | \"down\";\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\npublic enum Orientation {\r\n   LEFT(\"left\"),\r\n   RIGHT(\"right\"),\r\n   UP(\"up\"),\r\n   DOWN(\"down\");\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n\n## Scalars\n\n### Encoding\n\nWe will take the `@encode` decorator into account, determining how we serialize inputted scalars to send over the wire.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(DateTimeKnownEncoding.rfc3339)\r\n  prop: utcDateTime;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"utcDateTime\",\r\n    \"encode\": \"rfc3339\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"rfc3339\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\n// Internal implementation\r\nutf8JsonWriter.WriteStringValue(Prop.ToString());\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\",\r\n    this.value == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.value));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\r\n\r\nWhen you specify an encoding type, say that you want to encode an integer as a string, that will also be represented in our generated SDKs.\r\n\r\n<ClientTabs>\r\n<ClientTabItem lang=\"typespec\" >\r\n\r\n```tsp\r\nmodel Test {\r\n  @encode(string)\r\n  prop: int64;\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"tcgc\">\r\n\r\n```json\r\n{\r\n  \"kind\": \"property\",\r\n  \"name\": \"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\n\n\"prop\",\r\n  \"type\": {\r\n    \"kind\": \"int64\",\r\n    \"encode\": \"string\",\r\n    \"wireType\": {\r\n      \"kind\": \"string\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"python\">\r\n\r\n```python\r\nserialized_prop = json.dumps(prop, cls=SdkJSONEncoder, format=\"string\")\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"csharp\" >\r\n\r\n```csharp\r\nTODO\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"typescript\" >\r\n\r\n```typescript\r\nTODO;\r\n```\r\n\r\n</ClientTabItem>\r\n<ClientTabItem lang=\"java\" >\r\n\r\n```java\r\n// Internal implementation\r\njsonWriter.writeStringField(\"prop\", Objects.toString(this.value, null));\r\n```\r\n\r\n</ClientTabItem>\r\n</ClientTabs>\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-closed-literal-union.md\n- document_title: no-closed-literal-union\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-closed-literal-union\n- document_content: # libraries#azure-core#rules#no-closed-literal-union.md\n\n# no-closed-literal-union\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-closed-literal-union\r\n```\r\n\r\nAzure services favor extensible enums to avoid breaking changes as new enum values are added. When using a union of only string or numeric literals it is the equivalent to a closed enum.\r\nAdding the base scalar(`string`, `int32`, `int64`, etc.) as a variant to the union makes it extensible.\r\n\r\n####  Incorrect\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"cat\",\r\n  Dog: \"dog\",\r\n}\r\n```\r\n\r\n```tsp\r\nmodel Pet {\r\n  kind: \"cat\" | \"dog\";\r\n}\r\n```\r\n\r\n####  Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\r\n\r\n```tsp\r\nmodel Pet {\r\n  kind: \"cat\" | \"dog\" | string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#reference#linter.md\n- document_title: Linter usage\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/linter\n- document_content: # libraries#azure-core#reference#linter.md\n\n# Linter usage\n\n## Usage\n\nAdd the following in `tspconfig.yaml`:\r\n\r\n```yaml\r\nlinter:\r\n  extends:\r\n    - \"@azure-tools/typespec-azure-core/all\"\r\n```\n\n## RuleSets\n\nAvailable ruleSets:\r\n\r\n- `@azure-tools/typespec-azure-core/all`\r\n- `@azure-tools/typespec-azure-core/canonical-versioning`\n\n## Rules\n\n| Don't use generic types. Use more specific types instead.                                                                                            |\r\n| [`@azure-tools/typespec-azure-core/no-nullable`](/libraries/azure-core/rules/no-nullable.md)                                     | Use `?` for optional properties.                                                                                                                     |\r\n| `@azure-tools/typespec-azure-core/no-offsetdatetime`                                                                             | Prefer using `utcDateTime` when representing a datetime unless an offset is necessary.                                                               |\r\n| `@azure-tools/typespec-azure-core/no-response-body`                                                                              | Ensure that the body is set correctly for the response type.                                                                                         |\r\n| `@azure-tools/typespec-azure-core/no-rpc-path-params`                                                                            | Operations defined using RpcOperation should not have path parameters.                                                                               |\r\n| `@azure-tools/typespec-azure-core/no-openapi`                                                                                    | Azure specs should not be using decorators from @typespec/openapi or @azure-tools/typespec-autorest                                                  |\r\n| [`@azure-tools/typespec-azure-core/no-header-explode`](/libraries/azure-core/rules/no-header-explode.md)                         | It is recommended to serialize header parameter without explode: true                                                                                |\r\n| [`@azure-tools/typespec-azure-core/no-format`]\n\n| Azure specs should not be using decorators from @typespec/openapi or @azure-tools/typespec-autorest                                                  |\r\n| [`@azure-tools/typespec-azure-core/no-header-explode`](/libraries/azure-core/rules/no-header-explode.md)                         | It is recommended to serialize header parameter without explode: true                                                                                |\r\n| [`@azure-tools/typespec-azure-core/no-format`](/libraries/azure-core/rules/prevent-format.md)                                    | Azure services should not use the `@format` decorator.                                                                                               |\r\n| `@azure-tools/typespec-azure-core/no-multiple-discriminator`                                                                     | Classes should have at most one discriminator.                                                                                                       |\r\n| `@azure-tools/typespec-azure-core/no-rest-library-interfaces`                                                                    | Resource interfaces from the TypeSpec.Rest.Resource library are incompatible with Azure.Core.                                                        |\r\n| `@azure-tools/typespec-azure-core/no-unknown`                                                                                    | Azure services must not have properties of type `unknown`.                                                                                           |\r\n| [`@azure-tools/typespec-azure-core/bad-record-type`](/libraries/azure-core/rules/bad-record-type.md)                             | Identify bad record definitions.                                                                                                                     |\r\n|\n\n| Use the BYOS pattern recommended for Azure Services.                                                                                                 |\r\n| [`@azure-tools/typespec-azure-core/casing-style`](/libraries/azure-core/rules/casing-style.md)                                   | Ensure proper casing style.                                                                                                                          |\r\n| `@azure-tools/typespec-azure-core/composition-over-inheritance`                                                                  | Check that if a model is used in an operation and has derived models that it has a discriminator or recommend to use composition via spread or `is`. |\r\n| `@azure-tools/typespec-azure-core/known-encoding`                                                                                | Check for supported encodings.                                                                                                                       |\r\n| `@azure-tools/typespec-azure-core/long-running-polling-operation-required`                                                       | Long-running operations should have a linked polling operation.                                                                                      |\r\n| [`@azure-tools/typespec-azure-core/no-closed-literal-union`](/libraries/azure-core/rules/no-closed-literal-union.md)             | Unions of literals should include the base scalar type to mark them as open enum.                                                                    |\r\n| [`@azure-tools/typespec-azure-core/no-enum`](/libraries/azure-core/rules/no-enum.md)                                             | Azure services should not use enums.                                                                                                                 |\r\n|\n\n| Azure services should use the versioning library.                                                                                                    |\r\n| `@azure-tools/typespec-azure-core/friendly-name`                                                                                 | Ensures that @friendlyName is used as intended.                                                                                                      |\r\n| [`@azure-tools/typespec-azure-core/no-private-usage`](/libraries/azure-core/rules/no-private-usage.md)                           | Verify that elements inside Private namespace are not referenced.                                                                                    |\r\n| [`@azure-tools/typespec-azure-core/no-legacy-usage`](/libraries/azure-core/rules/no-legacy-usage.md)                             | Linter warning against using elements from the Legacy namespace                                                                                      |\r\n| [`@azure-tools/typespec-azure-core/no-query-explode`](/libraries/azure-core/rules/no-query-explode.md)                           | It is recommended to serialize query parameter without explode: true                                                                                 |\n\n| Name                                                                                                                             | Description                                                                                                                                          |\r\n| -------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| [`@azure-tools/typespec-azure-core/operation-missing-api-version`](/libraries/azure-core/rules/operation-missing-api-version.md) | Operations need an api version parameter.                                                                                                            |\r\n| [`@azure-tools/typespec-azure-core/auth-required`](/libraries/azure-core/rules/auth-required.md)                                 | Enforce service authentication.                                                                                                                      |\r\n| `@azure-tools/typespec-azure-core/request-body-problem`                                                                          | Request body should not be of raw array type.                                                                                                        |\r\n| `@azure-tools/typespec-azure-core/byos`                                                                                          | Use the BYOS pattern recommended for Azure Services.                                                                                                 |\r\n| [`@azure-tools/typespec-azure-core/casing-style`](/libraries/azure-core/rules/casing-style.md)                                   | Ensure proper casing style.                                                                                                                          |\r\n|\n\n| Warning for RPC body problems.                                                                                                                       |\r\n| [`@azure-tools/typespec-azure-core/spread-discriminated-model`](/libraries/azure-core/rules/spread-discriminated-model.md)       | Check a model with a discriminator has not been used in composition.                                                                                 |\r\n| `@azure-tools/typespec-azure-core/use-standard-names`                                                                            | Use recommended names for operations.                                                                                                                |\r\n| [`@azure-tools/typespec-azure-core/use-standard-operations`](/libraries/azure-core/rules/use-standard-operations.md)             | Operations should be defined using a signature from the Azure.Core namespace.                                                                        |\r\n| [`@azure-tools/typespec-azure-core/no-string-discriminator`](/libraries/azure-core/rules/no-string-discriminator.md)             | Azure services discriminated models should define the discriminated property as an extensible union.                                                 |\r\n| [`@azure-tools/typespec-azure-core/require-versioned`](/libraries/azure-core/rules/require-versioned.md)                         | Azure services should use the versioning library.                                                                                                    |\r\n| `@azure-tools/typespec-azure-core/friendly-name`                                                                                 | Ensures that @friendlyName is used as intended.                                                                                                      |\r\n| [`@azure-tools/typespec-azure-core/no-private-usage`]\n\n| Azure services must not have properties of type `unknown`.                                                                                           |\r\n| [`@azure-tools/typespec-azure-core/bad-record-type`](/libraries/azure-core/rules/bad-record-type.md)                             | Identify bad record definitions.                                                                                                                     |\r\n| `@azure-tools/typespec-azure-core/documentation-required`                                                                        | Require documentation over enums, models, and operations.                                                                                            |\r\n| `@azure-tools/typespec-azure-core/key-visibility-required`                                                                       | Key properties need to have a Lifecycle visibility setting.                                                                                          |\r\n| `@azure-tools/typespec-azure-core/response-schema-problem`                                                                       | Warn about operations having multiple non-error response schemas.                                                                                    |\r\n| `@azure-tools/typespec-azure-core/rpc-operation-request-body`                                                                    | Warning for RPC body problems.                                                                                                                       |\r\n| [`@azure-tools/typespec-azure-core/spread-discriminated-model`](/libraries/azure-core/rules/spread-discriminated-model.md)       | Check a model with a discriminator has not been used in composition.                                                                                 |\r\n|\n\n| Unions of literals should include the base scalar type to mark them as open enum.                                                                    |\r\n| [`@azure-tools/typespec-azure-core/no-enum`](/libraries/azure-core/rules/no-enum.md)                                             | Azure services should not use enums.                                                                                                                 |\r\n| `@azure-tools/typespec-azure-core/no-error-status-codes`                                                                         | Recommend using the error response defined by Azure REST API guidelines.                                                                             |\r\n| `@azure-tools/typespec-azure-core/no-explicit-routes-resource-ops`                                                               | The @route decorator should not be used on standard resource operation signatures.                                                                   |\r\n| [`@azure-tools/typespec-azure-core/non-breaking-versioning`](/libraries/azure-core/rules/non-breaking-versioning.md)             | Check that only backward compatible versioning change are done to a service.                                                                         |\r\n| [`@azure-tools/typespec-azure-core/no-generic-numeric`](/libraries/azure-core/rules/no-generic-numeric.md)                       | Don't use generic types. Use more specific types instead.                                                                                            |\r\n| [`@azure-tools/typespec-azure-core/no-nullable`](/libraries/azure-core/rules/no-nullable.md)                                     | Use `?` for optional properties.                                                                                                                     |\r\n|\n", "latency": 13.679405212402344, "response_length": 842}
{"query": "title: Polymorphism and ARM Patch Sync\n\nquestion: We have some polymorphic discriminator properties in our typespec. One of the examples beloe\n```\n// Polymorphic Source\n@discriminator(\"type\")\n@doc(\"The type of backing data source\")\nmodel Source {\n@doc(\"Type of the Storage Connector  Bucket. Not mutable once the Storage Connector is created.\")\ntype?: SourceType;\n}\n// Bucket source extends source\n@doc(\"The properties of the backing data store.\")\nmodel BucketSource extends Source {\n@visibility(\"read\")\ntype: SourceType.Bucket;\n@doc(\"Details for how to connect to the backing data store.\")\nconnection: Connection;\n@doc(\"Details for how to authenticate to the backing data store.\")\nauthProperties: AuthProperties;\n@doc(\"The host to use when computing the signature for requests to the backing data store. If not provided, defaults to what is provided in the endpoint for the connection.\")\nhostOverride?: string;\n}\n// The actual connector properties\n@doc(\"Details of the Storage Connector.\")\nmodel ConnectorProperties {\n@visibility(\"read\", \"create\")\n@doc(\"System-generated identifier for the Storage Connector. Not a valid input parameter when creating.\")\nuniqueId?: string;\n@doc(\"State  Enabled or Disabled. Whether or not the Storage Connector should start as enabled (default: Enabled) (While set to false on the Storage Connector, all data plane requests using this Storage Connector fail, and this Storage Connector is not billed if it would be otherwise.)\")\nstate?: State = State.Enabled;\n@visibility(\"read\", \"create\")\n@doc(\"System-generated creation time for the Storage Connector. Not a valid input parameter when creating.\")\ncreationTime?: string;\n@doc(\"Arbitrary description of this Storage Connector. Max 250 characters.\")\n@maxLength(250)\ndescription?: string;\n@doc(\"Information about how to communicate with and authenticate to the backing data store.\")\nsource: Source;\n@visibility(\"read\")\n@doc(\"The status of the last operation.\")\nprovisioningState?: ProvisioningState;\n}\n// Conenctor resource as tarcked resource\n@doc(\"A Connector is a tracked ARM resource modeled as a sub-resource of a Storage Account\")\nmodel Connector is TrackedResource<ConnectorProperties> {\n@doc(\"The name of the connector\")\n@pattern(\"^[a-zA-Z0-9-]{3,24}$\")\n@key(\"connectorName\")\n@segment(\"connectors\")\n@path\nname: string;\n}\n```\nWhen adding a update patch method for this resource -\n```\n@armResourceOperations(Connector)\ninterface Connectors {\n@doc(\"Get the specified Storage Connector.\")\nget is ArmResourceRead<Connector>;\n@doc(\"Create or update a Storage Connector.\")\ncreateOrReplace is ArmResourceCreateOrReplaceAsync<Connector>;\n@doc(\"Update a Storage Connector.\")\nupdate is ArmCustomPatchAsync<\nConnector,\nConnectorProperties\n>;\n}\n```\nWe see an error from swagger Lint DIff validation stating that all properties of a patch resoucre should be optional.\nTypespec does nota low to have optional discriminator values\nIs there a way we can model this in typespec for patch api?", "ground_truth": "In this conversation, the main focus is on handling polymorphic properties and patch resource models in TypeSpec for ARM, specifically related to suppressing LintDiff errors. The issue arises because Swagger LintDiff validation requires all properties of a PATCH resource to be optional, which conflicts with the need to model required polymorphic properties in a patch.\nTo address this, it's agreed that suppressing the LintDiff error is the right approach for now, as the pace of change is slow. The specific error to suppress is related to the requirement that all PATCH resource properties should be optional, and the suppression rule needs to be applied to that specific path in the model.\nAdditionally, a PR was reviewed and updated to use a more specific suppression path for the patch parameters, and it was approved with the appropriate labels.", "response": "In TypeSpec, discriminator properties are required to be non-optional, which can conflict with the requirement for all properties in a PATCH resource to be optional. To address this issue, you can use the `@patchOptions` decorator with the `implicitOptionality` property set to `false`. This disables the implicit transformation that makes all properties deeply optional in PATCH operations, allowing you to retain the required discriminator property while still modeling the PATCH operation correctly. Here's an example:\n\n```typespec\n@armResourceOperations(Connector)\ninterface Connectors {\n  @doc(\"Update a Storage Connector.\")\n  @patchOptions({ implicitOptionality: false })\n  update is ArmCustomPatchAsync<Connector, ConnectorProperties>;\n}\n```\n\nThis approach ensures compliance with TypeSpec's constraints while addressing the Swagger Lint Diff validation error.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#http#reference#data-types.md\n- document_title: Data types\n- document_link: https://typespec.io/docs/libraries/http/reference/data-types\n- document_content: # libraries#http#reference#data-types.md\n\n# Data types\n\n## TypeSpec.Http\n\n### `AcceptedResponse` {#TypeSpec.Http.AcceptedResponse}\n\nThe request has been accepted for processing, but processing has not yet completed.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.AcceptedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `202` | The status code. |\n\n### `ApiKeyAuth` {#TypeSpec.Http.ApiKeyAuth}\n\nAn API key is a token that a client provides when making API calls. The key can be sent in the query string:\r\n\r\n```\r\nGET /something?api_key=abcdef12345\r\n```\r\n\r\nor as a request header\r\n\r\n```\r\nGET /something HTTP/1.1\r\nX-API-Key: abcdef12345\r\n```\r\n\r\nor as a cookie\r\n\r\n```\r\nGET /something HTTP/1.1\r\nCookie: X-API-KEY=abcdef12345\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ApiKeyAuth<Location, Name>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                 |\r\n| -------- | --------------------------- |\r\n| Location | The location of the API key |\r\n| Name     | The name of the API key     |\r\n\r\n#### Properties\r\n\r\n| Name | Type                            | Description |\r\n| ---- | ------------------------------- | ----------- |\r\n| type | `TypeSpec.Http.AuthType.apiKey` |             |\r\n| in   | `Location`                      |             |\r\n| name | `Name`                          |             |\n\n### `AuthorizationCodeFlow` {#TypeSpec.Http.AuthorizationCodeFlow}\n\nAuthorization Code flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.AuthorizationCodeFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                             | Description                       |\r\n| ---------------- | ------------------------------------------------ | --------------------------------- |\r\n| type             | `TypeSpec.Http.OAuth2FlowType.authorizationCode` | authorization code flow           |\r\n| authorizationUrl | `string`                                         | the authorization URL             |\r\n| tokenUrl         | `string`                                         | the token URL                     |\r\n| refreshUrl?      | `string`                                         | the refresh URL                   |\r\n| scopes?          | `string[]`                                       | list of scopes for the credential |\n\n### `BadRequestResponse` {#TypeSpec.Http.BadRequestResponse}\n\nThe server could not understand the request due to invalid syntax.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.BadRequestResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `400` | The status code. |\n\n### `BasicAuth` {#TypeSpec.Http.BasicAuth}\n\nBasic authentication is a simple authentication scheme built into the HTTP protocol.\r\nThe client sends HTTP requests with the Authorization header that contains the word Basic word followed by a space and a base64-encoded string username:password.\r\nFor example, to authorize as demo / `p@55w0rd` the client would send\r\n\r\n```\r\nAuthorization: Basic ZGVtbzpwQDU1dzByZA==\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.BasicAuth\r\n```\r\n\r\n#### Properties\r\n\r\n| Name   | Type                          | Description         |\r\n| ------ | ----------------------------- | ------------------- |\r\n| type   | `TypeSpec.Http.AuthType.http` | Http authentication |\r\n| scheme | `\"Basic\"`                     | basic auth scheme   |\n\n### `BearerAuth` {#TypeSpec.Http.BearerAuth}\n\nBearer authentication (also called token authentication) is an HTTP authentication scheme that involves security tokens called bearer tokens.\r\nThe name Bearer authentication can be understood as give access to the bearer of this token. The bearer token is a cryptic string, usually generated by the server in response to a login request.\r\nThe client must send this token in the Authorization header when making requests to protected resources:\r\n\r\n```\r\nAuthorization: Bearer <token>\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.BearerAuth\r\n```\r\n\r\n#### Properties\r\n\r\n| Name   | Type                          | Description         |\r\n| ------ | ----------------------------- | ------------------- |\r\n| type   | `TypeSpec.Http.AuthType.http` | Http authentication |\r\n| scheme | `\"Bearer\"`                    | bearer auth scheme  |\n\n### `Body` {#TypeSpec.Http.Body}\n\nDefines a model with a single property of the given type, marked with `@body`.\r\n\r\nThis can be useful in situations where you cannot use a bare type as the body\r\nand it is awkward to add a property.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.Body<Type>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name | Description                              |\r\n| ---- | ---------------------------------------- |\r\n| Type | The type of the model's `body` property. |\r\n\r\n#### Properties\r\n\r\n| Name | Type   | Description |\r\n| ---- | ------ | ----------- |\r\n| body | `Type` |             |\n\n### `ClientCredentialsFlow` {#TypeSpec.Http.ClientCredentialsFlow}\n\nClient credentials flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ClientCredentialsFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type                                             | Description                       |\r\n| ----------- | ------------------------------------------------ | --------------------------------- |\r\n| type        | `TypeSpec.Http.OAuth2FlowType.clientCredentials` | client credential flow            |\r\n| tokenUrl    | `string`                                         | the token URL                     |\r\n| refreshUrl? | `string`                                         | the refresh URL                   |\r\n| scopes?     | `string[]`                                       | list of scopes for the credential |\n\n### `ConflictResponse` {#TypeSpec.Http.ConflictResponse}\n\nThe request conflicts with the current state of the server.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ConflictResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `409` | The status code. |\n\n### `CookieOptions` {#TypeSpec.Http.CookieOptions}\n\nCookie Options.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.CookieOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type     | Description         |\r\n| ----- | -------- | ------------------- |\r\n| name? | `string` | Name in the cookie. |\n\n### `CreatedResponse` {#TypeSpec.Http.CreatedResponse}\n\nThe request has succeeded and a new resource has been created as a result.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.CreatedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `201` | The status code. |\n\n### `File` {#TypeSpec.Http.File}\n\nbelow for more information.\r\n\r\nNOTE: The `filename` and `contentType` fields are optional. Furthermore, the default location of `filename`\r\n(`Content-Disposition: <disposition>; filename=<filename>`) is only valid in HTTP responses and multipart payloads. If\r\nyou wish to send the `filename` in a request, you must use HTTP metadata decorators to describe the location of the\r\n`filename` field. You can combine the metadata decorators with `@visibility` to control when the `filename` location\r\nis overridden, as shown in the examples below.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.File<ContentType, Contents>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name        | Description                                                                                    |\r\n| ----------- | ---------------------------------------------------------------------------------------------- |\r\n| ContentType | The allowed media (MIME) types of the file contents.                                           |\r\n| Contents    | The type of the file contents. This can be `string`, `bytes`, or any scalar that extends them. |\r\n\r\n#### Examples\r\n\r\n```tsp\r\n// Download a file\r\n@get op download(): File;\r\n\r\n// Upload a file\r\n@post op upload(@bodyRoot file: File): void;\r\n```\r\n\r\n```tsp\r\n// Upload and download files in a multipart payload\r\nop multipartFormDataUpload(\r\n  @multipartBody fields: {\r\n    files: HttpPart<File>[];\r\n  },\r\n): void;\r\n\r\nop multipartFormDataDownload(): {\r\n  @multipartBody formFields: {\r\n    files: HttpPart<File>[];\r\n  };\r\n};\r\n```\r\n\r\n```tsp\r\n// Declare a custom type of text file, where the filename goes in the path\r\n// in requests.\r\nmodel SpecFile extends File<\"application/json\" | \"application/yaml\", string> {\r\n  // Provide a header that contains the name of the file when created or updated\r\n  @header(\"x-filename\")\r\n  @path\r\n  filename: string;\r\n}\r\n\r\n@get op downloadSpec(@path name: string): SpecFile;\r\n\r\n@post op uploadSpec(@bodyRoot spec: SpecFile): void;\r\n```\r\n\r\n```tsp\n\nA file in an HTTP request, response, or multipart payload.\r\n\r\nFiles have a special meaning that the HTTP library understands. When the body of an HTTP request, response,\r\nor multipart payload is _effectively_ an instance of `TypeSpec.Http.File` or any type that extends it, the\r\noperation is treated as a file upload or download.\r\n\r\nWhen using file bodies, the fields of the file model are defined to come from particular locations by default:\r\n\r\n- `contentType`: The `Content-Type` header of the request, response, or multipart payload (CANNOT be overridden or changed).\r\n- `contents`: The body of the request, response, or multipart payload (CANNOT be overridden or changed).\r\n- `filename`: The `filename` parameter value of the `Content-Disposition` header of the response or multipart payload\r\n  (MAY be overridden or changed).\r\n\r\nA File may be used as a normal structured JSON object in a request or response, if the request specifies an explicit\r\n`Content-Type` header. In this case, the entire File model is serialized as if it were any other model. In a JSON payload,\r\nit will have a structure like:\r\n\r\n```\r\n{\r\n  \"contentType\": <string?>,\r\n  \"filename\": <string?>,\r\n  \"contents\": <string, base64>\r\n}\r\n```\r\n\r\nThe `contentType` _within_ the file defines what media types the data inside the file can be, but if the specification\r\ndefines a `Content-Type` for the payload as HTTP metadata, that `Content-Type` metadata defines _how the file is\r\nserialized_. See the examples below for more information.\r\n\r\nNOTE: The `filename` and `contentType` fields are optional. Furthermore, the default location of `filename`\r\n(`Content-Disposition: <disposition>; filename=<filename>`) is only valid in HTTP responses and multipart payloads. If\r\nyou wish to send the `filename` in a request, you must use HTTP metadata decorators to describe the location of the\r\n`filename` field. You can combine the metadata decorators with `@visibility` to control when the `filename` location\n\n{\r\n    files: HttpPart<File>[];\r\n  };\r\n};\r\n```\r\n\r\n```tsp\r\n// Declare a custom type of text file, where the filename goes in the path\r\n// in requests.\r\nmodel SpecFile extends File<\"application/json\" | \"application/yaml\", string> {\r\n  // Provide a header that contains the name of the file when created or updated\r\n  @header(\"x-filename\")\r\n  @path\r\n  filename: string;\r\n}\r\n\r\n@get op downloadSpec(@path name: string): SpecFile;\r\n\r\n@post op uploadSpec(@bodyRoot spec: SpecFile): void;\r\n```\r\n\r\n```tsp\r\n// Declare a custom type of binary file\r\nmodel ImageFile extends File {\r\n  contentType: \"image/png\" | \"image/jpeg\";\r\n  @path filename: string;\r\n}\r\n\r\n@get op downloadImage(@path name: string): ImageFile;\r\n\r\n@post op uploadImage(@bodyRoot image: ImageFile): void;\r\n```\r\n\r\n````tsp\r\n// Use a File as a structured JSON object. The HTTP library will warn you that the File will be serialized as JSON,\r\n// so you should suppress the warning if it's really what you want instead of a binary file upload/download.\r\n\r\n// The response body is a JSON object like `{\"contentType\":<string?>,\"filename\":<string?>,\"contents\":<string>}`\r\n@get op downloadTextFileJson(): {\r\n  @header contentType: \"application/json\",\r\n  @body file: File<\"text/plain\", string>,\r\n};\r\n\r\n// The request body is a JSON object like `{\"contentType\":<string?>,\"filename\":<string?>,\"contents\":<base64>}`\r\n@post op uploadBinaryFileJson(\r\n  @header contentType: \"application/json\",\r\n  @body file: File<\"image/png\", bytes>,\r\n): void;\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| contentType? | `ContentType` | The allowed media (MIME) types of the file contents.<br /><br />In file bodies, this value comes from the `Content-Type` header of the request or response. In JSON bodies,<br />this value is serialized as a field in the response.<br /><br />NOTE: this is not _necessarily_ the same as the `Content-Type` header of the request or response, but<br />it will be for file bodies.\n\n): void;\r\n\r\n#### Properties\r\n| Name | Type | Description |\r\n|------|------|-------------|\r\n| contentType? | `ContentType` | The allowed media (MIME) types of the file contents.<br /><br />In file bodies, this value comes from the `Content-Type` header of the request or response. In JSON bodies,<br />this value is serialized as a field in the response.<br /><br />NOTE: this is not _necessarily_ the same as the `Content-Type` header of the request or response, but<br />it will be for file bodies. It may be different if the file is serialized as a JSON object. It always refers to the<br />_contents_ of the file, and not necessarily the way the file itself is transmitted or serialized. |\r\n| filename? | `string` | The name of the file, if any.<br /><br />In file bodies, this value comes from the `filename` parameter of the `Content-Disposition` header of the response<br />or multipart payload. In JSON bodies, this value is serialized as a field in the response.<br /><br />NOTE: By default, `filename` cannot be sent in request payloads and can only be sent in responses and multipart<br />payloads, as the `Content-Disposition` header is not valid in requests. If you want to send the `filename` in a request,<br />you must extend the `File` model and override the `filename` property with a different location defined by HTTP metadata<br />decorators. |\r\n| contents | `Contents` | The contents of the file.<br /><br />In file bodies, this value comes from the body of the request, response, or multipart payload. In JSON bodies,<br />this value is serialized as a field in the response. |\n\n### `ForbiddenResponse` {#TypeSpec.Http.ForbiddenResponse}\n\nAccess is forbidden.\r\n```typespec\r\nmodel TypeSpec.Http.ForbiddenResponse\r\n````\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `403` | The status code. |\n\n### `HeaderOptions` {#TypeSpec.Http.HeaderOptions}\n\nHeader options.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.HeaderOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\r\n| -------- | --------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| name?    | `string`  | Name of the header when sent over HTTP.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\r\n| explode? | `boolean` | Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)<br /><br />\\| Style \\| Explode \\| Primitive value = 5 \\|\n\n|\r\n| explode? | `boolean` | Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)<br /><br />\\| Style \\| Explode \\| Primitive value = 5 \\| Array = [3, 4, 5] \\| Object = {\"role\": \"admin\", \"firstName\": \"Alex\"} \\|<br />\\| ------ \\| ------- \\| ------------------- \\| ----------------- \\| ----------------------------------------------- \\|<br />\\| simple \\| false \\| `5   ` \\| `3,4,5` \\| `role,admin,firstName,Alex` \\|<br />\\| simple \\| true \\| `5` \\| `3,4,5` \\| `role=admin,firstName=Alex` \\| |\n\n### `HttpPart` {#TypeSpec.Http.HttpPart}\n\n```typespec\r\nmodel TypeSpec.Http.HttpPart<Type, Options>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name    | Description |\r\n| ------- | ----------- |\r\n| Type    |             |\r\n| Options |             |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `HttpPartOptions` {#TypeSpec.Http.HttpPartOptions}\n\n```typespec\r\nmodel TypeSpec.Http.HttpPartOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type     | Description                                 |\r\n| ----- | -------- | ------------------------------------------- |\r\n| name? | `string` | Name of the part when using the array form. |\n\n### `ImplicitFlow` {#TypeSpec.Http.ImplicitFlow}\n\nImplicit flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.ImplicitFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                    | Description                       |\r\n| ---------------- | --------------------------------------- | --------------------------------- |\r\n| type             | `TypeSpec.Http.OAuth2FlowType.implicit` | implicit flow                     |\r\n| authorizationUrl | `string`                                | the authorization URL             |\r\n| refreshUrl?      | `string`                                | the refresh URL                   |\r\n| scopes?          | `string[]`                              | list of scopes for the credential |\n\n### `Link` {#TypeSpec.Http.Link}\n\n```typespec\r\nmodel TypeSpec.Http.Link\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type              | Description |\r\n| ----------- | ----------------- | ----------- |\r\n| target      | `url`             |             |\r\n| rel         | `string`          |             |\r\n| attributes? | `Record<unknown>` |             |\n\n### `LocationHeader` {#TypeSpec.Http.LocationHeader}\n\nThe Location header contains the URL where the status of the long running operation can be checked.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.LocationHeader\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type     | Description                                                                                         |\r\n| -------- | -------- | --------------------------------------------------------------------------------------------------- |\r\n| location | `string` | The Location header contains the URL where the status of the long running operation can be checked. |\n\n### `MovedResponse` {#TypeSpec.Http.MovedResponse}\n\nThe URL of the requested resource has been changed permanently. The new URL is given in the response.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.MovedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type     | Description                                                                                         |\r\n| ---------- | -------- | --------------------------------------------------------------------------------------------------- |\r\n| statusCode | `301`    | The status code.                                                                                    |\r\n| location   | `string` | The Location header contains the URL where the status of the long running operation can be checked. |\n\n### `NoAuth` {#TypeSpec.Http.NoAuth}\n\nThis authentication option signifies that API is not secured at all.\r\nIt might be useful when overriding authentication on interface of operation level.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NoAuth\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type                            | Description |\r\n| ---- | ------------------------------- | ----------- |\r\n| type | `TypeSpec.Http.AuthType.noAuth` |             |\n\n### `NoContentResponse` {#TypeSpec.Http.NoContentResponse}\n\nThere is no content to send for this request, but the headers may be useful.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NoContentResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `204` | The status code. |\n\n### `NotFoundResponse` {#TypeSpec.Http.NotFoundResponse}\n\nThe server cannot find the requested resource.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NotFoundResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `404` | The status code. |\n\n### `NotModifiedResponse` {#TypeSpec.Http.NotModifiedResponse}\n\nThe client has made a conditional request and the resource has not been modified.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.NotModifiedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `304` | The status code. |\n\n### `OAuth2Auth` {#TypeSpec.Http.OAuth2Auth}\n\nOAuth 2.0 is an authorization protocol that gives an API client limited access to user data on a web server.\r\n\r\nOAuth relies on authentication scenarios called flows, which allow the resource owner (user) to share the protected content from the resource server without sharing their credentials.\r\nFor that purpose, an OAuth 2.0 server issues access tokens that the client applications can use to access protected resources on behalf of the resource owner.\r\nFor more information about OAuth 2.0, see oauth.net and RFC 6749.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.OAuth2Auth<Flows, Scopes>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name   | Description                                                                                                                                      |\r\n| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Flows  | The list of supported OAuth2 flows                                                                                                               |\r\n| Scopes | The list of OAuth2 scopes, which are common for every flow from `Flows`. This list is combined with the scopes defined in specific OAuth2 flows. |\r\n\r\n#### Properties\r\n\r\n| Name          | Type                            | Description |\r\n| ------------- | ------------------------------- | ----------- |\r\n| type          | `TypeSpec.Http.AuthType.oauth2` |             |\r\n| flows         | `Flows`                         |             |\r\n| defaultScopes | `Scopes`                        |             |\n\n### `OkResponse` {#TypeSpec.Http.OkResponse}\n\nThe request has succeeded.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.OkResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `200` | The status code. |\n\n### `OpenIdConnectAuth` {#TypeSpec.Http.OpenIdConnectAuth}\n\nOpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0 protocol and supported by some OAuth 2.0 providers, such as Google and Azure Active Directory.\r\nIt defines a sign-in flow that enables a client application to authenticate a user, and to obtain information (or \"claims\") about that user, such as the user name, email, and so on.\r\nUser identity information is encoded in a secure JSON Web Token (JWT), called ID token.\r\nOpenID Connect defines a discovery mechanism, called OpenID Connect Discovery, where an OpenID server publishes its metadata at a well-known URL, typically\r\n\r\n```http\r\nhttps://server.com/.well-known/openid-configuration\r\n```\r\n\r\n```typespec\r\nmodel TypeSpec.Http.OpenIdConnectAuth<ConnectUrl>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description |\r\n| ---------- | ----------- |\r\n| ConnectUrl |             |\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                   | Description                                                 |\r\n| ---------------- | -------------------------------------- | ----------------------------------------------------------- |\r\n| type             | `TypeSpec.Http.AuthType.openIdConnect` | Auth type                                                   |\r\n| openIdConnectUrl | `ConnectUrl`                           | Connect url. It can be specified relative to the server URL |\n\n### `PasswordFlow` {#TypeSpec.Http.PasswordFlow}\n\nResource Owner Password flow\r\n\r\n```typespec\r\nmodel TypeSpec.Http.PasswordFlow\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type                                    | Description                       |\r\n| ----------- | --------------------------------------- | --------------------------------- |\r\n| type        | `TypeSpec.Http.OAuth2FlowType.password` | password flow                     |\r\n| tokenUrl    | `string`                                | the token URL                     |\r\n| refreshUrl? | `string`                                | the refresh URL                   |\r\n| scopes?     | `string[]`                              | list of scopes for the credential |\n\n### `PatchOptions` {#TypeSpec.Http.PatchOptions}\n\nOptions for PATCH operations.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.PatchOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name                 | Type      | Description                                                                                                       |\r\n| -------------------- | --------- | ----------------------------------------------------------------------------------------------------------------- |\r\n| implicitOptionality? | `boolean` | If set to `false`, disables the implicit transform that makes the body of a<br />PATCH operation deeply optional. |\n\n### `PathOptions` {#TypeSpec.Http.PathOptions}\n\n```typespec\r\nmodel TypeSpec.Http.PathOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name           | Type                                                      | Description                                                                                                                                                                                                                                  |\r\n| -------------- | --------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| name?          | `string`                                                  | Name of the parameter in the uri template.                                                                                                                                                                                                   |\r\n| explode?       | `boolean`                                                 | When interpolating this parameter in the case of array or object expand each value using the given style.<br />Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3) |\r\n| style?         | `\"simple\" \\| \"label\" \\| \"matrix\" \\| \"fragment\" \\| \"path\"` | Different interpolating styles for the path parameter.<br />- `simple`: No special encoding.<br />- `label`: Using `.` separator.<br />- `matrix`: `;` as separator.<br />- `fragment`: `#` as separator.<br />- `path`: `/` as separator.   |\r\n| allowReserved? | `boolean`                                                 | When interpolating this parameter do not encode reserved characters.<br />Equivalent of adding `+` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)                                      |\n\n### `PlainData` {#TypeSpec.Http.PlainData}\n\nProduces a new model with the same properties as T, but with `@query`,\r\n`@header`, `@body`, and `@path` decorators removed from all properties.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.PlainData<Data>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name | Description                            |\r\n| ---- | -------------------------------------- |\r\n| Data | The model to spread as the plain data. |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `QueryOptions` {#TypeSpec.Http.QueryOptions}\n\nQuery parameter options.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.QueryOptions\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type      | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| -------- | --------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| name?    | `string`  | Name of the query when included in the url.\n\n|\r\n| name?    | `string`  | Name of the query when included in the url.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\r\n| explode? | `boolean` | If true send each value in the array/object as a separate query parameter.<br />Equivalent of adding `*` in the path parameter as per [RFC-6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)<br /><br />\\| Style \\| Explode \\| Uri Template \\| Primitive value id = 5 \\| Array id = [3, 4, 5] \\| Object id = {\"role\": \"admin\", \"firstName\": \"Alex\"} \\|<br />\\| ------ \\| ------- \\| -------------- \\| ---------------------- \\| ----------------------- \\| -------------------------------------------------- \\|<br />\\| simple \\| false \\| `/users{?id}` \\| `/users?id=5` \\| `/users?id=3,4,5` \\| `/users?id=role,admin,firstName,Alex` \\|<br />\\| simple \\| true \\| `/users{?id*}` \\| `/users?id=5` \\| `/users?id=3&id=4&id=5` \\| `/users?role=admin&firstName=Alex` \\| |\n\n### `Response` {#TypeSpec.Http.Response}\n\nDescribes an HTTP response.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.Response<Status>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name   | Description                      |\r\n| ------ | -------------------------------- |\r\n| Status | The status code of the response. |\r\n\r\n#### Properties\r\n\r\n| Name       | Type     | Description |\r\n| ---------- | -------- | ----------- |\r\n| statusCode | `Status` |             |\n\n### `UnauthorizedResponse` {#TypeSpec.Http.UnauthorizedResponse}\n\nAccess is unauthorized.\r\n\r\n```typespec\r\nmodel TypeSpec.Http.UnauthorizedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `401` | The status code. |\n\n### `ApiKeyLocation` {#TypeSpec.Http.ApiKeyLocation}\n\nDescribes the location of the API key\r\n\r\n```typespec\r\nenum TypeSpec.Http.ApiKeyLocation\r\n```\r\n\r\n| Name   | Value | Description                  |\r\n| ------ | ----- | ---------------------------- |\r\n| header |       | API key is a header value    |\r\n| query  |       | API key is a query parameter |\r\n| cookie |       | API key is found in a cookie |\n\n### `AuthType` {#TypeSpec.Http.AuthType}\n\nAuthentication type\r\n\r\n```typespec\r\nenum TypeSpec.Http.AuthType\r\n```\r\n\r\n| Name          | Value | Description    |\r\n| ------------- | ----- | -------------- |\r\n| http          |       | HTTP           |\r\n| apiKey        |       | API key        |\r\n| oauth2        |       | OAuth2         |\r\n| openIdConnect |       | OpenID connect |\r\n| noAuth        |       | Empty auth     |\n\n### `OAuth2FlowType` {#TypeSpec.Http.OAuth2FlowType}\n\nDescribes the OAuth2 flow type\r\n\r\n```typespec\r\nenum TypeSpec.Http.OAuth2FlowType\r\n```\r\n\r\n| Name              | Value | Description             |\r\n| ----------------- | ----- | ----------------------- |\r\n| authorizationCode |       | authorization code flow |\r\n| implicit          |       | implicit flow           |\r\n| password          |       | password flow           |\r\n| clientCredentials |       | client credential flow  |\n\n### `LinkHeader` {#TypeSpec.Http.LinkHeader}\n\n```typespec\r\nscalar TypeSpec.Http.LinkHeader\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-operations.md\n- document_title: ARM Resource Operations\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations\n- document_content: # howtos#arm#resource-operations.md\n\n# ARM Resource Operations\n\n## Recommended and Required Operations\n\n### TrackedResource\n\n| Operation             | Recommended | Required | TypeSpec Representation                                          |\r\n| --------------------- | ----------- | -------- | ---------------------------------------------------------------- |\r\n| GET                   | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                              |\r\n| CreateOrUpdate (PUT)  | Yes         | Yes      | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;`    |\r\n| Tags Update (PATCH)   | No          | Yes\\*    | `update is ArmResourceTagsPatchSync<Resource>;`                  |\r\n| Full Update (PATCH)   | Yes         | No\\*     | `update is ArmCustomPatchSync<Resource, PatchRequest>;`          |\r\n| Delete                | Yes         | Yes      | `delete is ArmResourceDeleteSync<Resource>;`                     |\r\n| List by ResourceGroup | Yes         | Yes      | `listByResourceGroup is ArmResourceListByParent<Resource>;`      |\r\n| List by Subscription  | Yes         | Yes      | `listBySubscription is ArmResourceListBySubscription<Resource>;` |\r\n\r\n\\* Arm requires that, at minimum, a TrackedResource can update Tags. A Full PATCH of all updateable resource properties is preferred.\n\n### Proxy Resource\n\n| Operation            | Recommended | Required | TypeSpec Representation                                       |\r\n| -------------------- | ----------- | -------- | ------------------------------------------------------------- |\r\n| GET                  | Yes         | Yes      | `get is ArmResourceRead<Resource>;`                           |\r\n| CreateOrUpdate (PUT) | Yes         | No\\*     | `createOrUpdate is ArmResourceCreateOrUpdateAsync<Resource>;` |\r\n| Update (PATCH)       | Yes         | No       | `update is ArmCustomPatchSync<Resource, PatchRequest>;`       |\r\n| Delete               | Yes         | No\\*     | `delete is ArmResourceDeleteSync<Resource>;`                  |\r\n| List by Parent       | Yes         | Yes      | `listByParent is ArmResourceListByParent<Resource>;`          |\r\n\r\n\\* Note that, if a resource implements Create, it is highly recommended that it implement delete as well, and vice-versa.\n\n## TypeSpec Operation Templates and Interface Templates\n\nTypeSpec provide operation templates that describe the request and response of standard resource operations. A description of the options available for each resource template, and how to choose which one is described in the sections below.\n\n### Synchronous and Asynchronous APIs\n\nCreateOrUpdate (PUT), Update (Patch), Delete, and Action (POST) operations over a resource may\n\n### Determining Which Resource Properties Appear in Lifecycle Operations\n\nBy default, any property that occurs in your resource model will also appear in the response to GET, PUT, PATCH, and LIST operations, and in the request for PUT and PATCH operations. This does not work for all properties. Some properties are calculated by the service and cannot be directly set by PUT or PATCH (provisioningState, modification date, etc.). Some properties can only be set when creating a resource, but always appear in responses (e.g. 'location'). Some properties can only be set when updating the resource, and appear in responses. Some properties (rarely) may be settable when updating the resource via PUT or PATCH. To allow using a common resource model, but applying these `views` of resources to determine how the resource appear in request and responses, TypeSpec provides the visibility framework. You can see a complete representation of available visibilities in the table [on Property Visibility and Other Constraints](./resource-type.md#property-visibility-and-other-constraints). The sections below outline some common scenarios for designing properties with your operations in mind.\r\n\r\n#### Properties That Are Never Directly Set by the User\r\n\r\nIt is common to have properties that are calculated by the service or otherwise not directly set by the user, examples include timestamps, dates, values that are only set by specific actions (on/off, enabled/disabled, provisioningState). You want to make sure that these properties are marked so that they will appear in responses and not requests. this is done using the `@visibility(Lifecycle.Read)` decorator instance:\r\n\r\n```typespec\r\n@visibility(Lifecycle.Read)\r\nprovisioningState: ProvisioningState;\r\n```\n\n### Resource Get Operations\n\nGet is the operation to retrieve a single resource TypeSpec provides a single operation template for GET:\r\n\r\n```typespec\r\nop get is ArmResourceRead<MyResource>;\r\n```\r\n\r\n- **get**: The name of the operation passed on to clients.\r\n- **Resource**: A reference to your resource type.\n\n### Resource CreateOrUpdate Operations (PUT)\n\nThe CreateOrUpdate operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\n- Simple resources may have synchronous PUT operations. If a resource may need to perform additional checks, creation of other dependent resources, or the like, it is best to use an Asynchronous API.\r\n- Asynchronous operations for PUT occur when the RP needs to perform additional validaton actions, create other resources, or perform other tasks as part of resource creation or update that can cause the operation to take longer than the length of a single request/response.\r\n\r\n| Operation        | TypeSpec                                                          |\r\n| ---------------- | ----------------------------------------------------------------- |\r\n| Synchronous PUT  | `createOrUpdate is ArmResourceCreateOrReplaceSync<ResourceType>`  |\r\n| Asynchronous PUT | `createOrUpdate is ArmResourceCreateOrReplaceAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `createOrUpdate` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being created (or updated)\n\n### Resource Update Operations (PATCH)\n\nPATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\r\nThe ArmCustomPatch\\* templates take the resource type and your custom PATCH request type as parameters.\n\nARM Requires that all `Tracked` resources implement PATCH for ARM tags, which are contained in the envelope of every `TrackedResource`. ARM recommends that you also allow PATCH of other envelope properties and resource-specific properties. Unless marked with a specific visibility, any property in your rp-specific properties will be automatically included in the PATCH schema.\r\n\r\nTypeSpec Provides both Synchronous and Asynchronous PATCH Operations, and allows you to specify a PATCH for Resource tags only, a PATCH for all updateable properties, or a custom patch. Generally, you should choose the patch for all updateable properties, unless you have a very good reason for choosing another PATCH operation.\r\n\r\n| Operation Description      | TypeSpec                                                                                                                                   |\r\n| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| Sync TagsOnly PATCH        | `update is ArmTagsPatchSync<ResourceType>`                                                                                                 |\r\n| Async TagsOnly PATCH       | `update is ArmTagsPatchAsync<ResourceType>`                                                                                                |\r\n| Sync All Properties PATCH  | `update is ArmCustomPatchSync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>`  |\r\n| Async All Properties PATCH | `update is ArmCustomPatchAsync<ResourceType, Azure.ResourceManager.Foundations.ResourceUpdateModel<ResourceType, ResourcePropertiesType>>` |\r\n\r\nThe ArmResourcePatch\\* templates take the resource type and the resource properties type as parameters.\r\nThe ArmTagsPatch\\* templates take the resource type as a parameter.\n\n### Resource Delete Operations (DELETE)\n\nThe Delete operation may be synchronous (The operation may always complete before a response is returned) or asynchronous (an initial response may be returned before the operation fully completes).\r\n\r\nSimple resources may have synchronous DELETE operations. If a resource needs to clean up other resources or do other validations as part of delete, the delete operation may need to be asynchronous.\r\n\r\n| Operation           | TypeSpec                                                  |\r\n| ------------------- | --------------------------------------------------------- |\r\n| Synchronous Delete  | `delete is ArmResourceDeleteSync<ResourceType>`           |\r\n| Asynchronous Delete | `delete is ArmResourceDeleteWithoutOkAsync<ResourceType>` |\r\n\r\nIn the TypeSpec in the table `delete` is the name of the operation, which will be passed on to clients, and `ResourceType` is the type of the resource being deleted.\n\n### Resource List Operations (GET)\n\nArm Resource list operations return a list of Tracked or Proxy Resources at a particular scope.\r\n\r\n- All resources _should_ include a list operation at its immediate parent scope\r\n  - For **Tenant Resources**, this is at the tenant scope\r\n  - For **Extension Resources**, this is at the scope of resources they are extending\r\n  - For **Tracked Resources**, this is at the resource group scope.\r\n  - For **Child Resources**, this is at the scope of the resource parent.\r\n- Tracked resources _must_ include a list operation at the Subscription level.\r\n\r\n| Operation          | TypeSpec                                                            |\r\n| ------------------ | ------------------------------------------------------------------- |\r\n| ListByParent       | `listByWidget is ArmResourceListByParent<ResourceType>`             |\r\n| ListBySubscription | `listBySubscription is ArmResourceListBySubscription<ResourceType>` |\n\n### Resource Actions (POST)\n\nCustom actions define any operations over resources outside the simple CRUDL (Create< Read, Update, Delete, List) or lifecycle operations described above. Any operation that returns data that is not made up of resources, performs a prescriptive state change on the resource (cycling power, upgrading, etc.), or any operation that does not fit into the operations described above should be modelled as a _resource action_. Examples of resource actions include:\r\n\r\n- Operations that manage credentials associated with a resource\r\n- Operations that calculate statistics about resources\r\n- Operations that make specific state changes to resources (power cycle, upgrade, etc.)\r\n\r\n#### Actions that take input and output\r\n\r\nOperations that manage credentials are a good example fo this category. TypeSpec defines synchronous and asynchronous templates for actions that consume and produce information.\r\n\r\n| Operation                    | TypeSpec                                                                       |\r\n| ---------------------------- | ------------------------------------------------------------------------------ |\r\n| Synchronous Resource Action  | `updateCredentials is ArmResourceActionSync<ResourceType, Request, Response>`  |\r\n| Asynchronous Resource Action | `updateCredentials is ArmResourceActionAsync<ResourceType, Request, Response>` |\r\n\r\nParameters to the template are the ResourceType, the model for the operation Request body, and the model for the operation Response body.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- |\n\nbody.\r\n\r\n#### Actions that take input but produce no output (state changing actions)\r\n\r\nOperations that make state changes will often take some user configuration, and will return a seccess code or an error code depending on success or failure. TypeSpec defines synchronous and asynchronous operation templates for state changing actions.\r\n\r\n| Operation                     | TypeSpec                                                                              |\r\n| ----------------------------- | ------------------------------------------------------------------------------------- |\r\n| Synchronous NoContent Action  | `updateCredentials is ArmResourceActionNoContentSync<ResourceType, Request>`          |\r\n| Asynchronous NoContent Action | `updateCredentials is ArmResourceActionNoResponseContentAsync<ResourceType, Request>` |\r\n\r\nParameters to the template are the ResourceType and the model for the operation Request body.\n\n### Actions that take no input but produce output (data retrieval actions)\n\nSome operations return data or paged lists of data. TypeSpec does not yet provide templates for these kinds of actions, but here are two templates that you could reuse in your own specification, described in the next section of the document:\r\n\r\n- [Synchronous Resource List Actions](#synchronous-list-action)\r\n- [Asynchronous List Action](#asynchronous-list-action)\n\n### Check Name Operations\n\nSome services provide operations to check name availability, either location-specific (locally) or globally, especially if a resource name must be globally unique (such as when an exposed endpoint uses the resource name in the url).\r\n\r\n| Operation                      | TypeSpec                                                                                             |\r\n| ------------------------------ | ---------------------------------------------------------------------------------------------------- |\r\n| Global Name Availability Check | `checkGlobalName is checkGlobalNameAvailability<TRequest, TResponse, TAdditionalParams>`             |\r\n| Local Name Availability Check  | `checkLocalName is checkLocalNameAvailability<TRequest, TResponse, TAdditionalParams>`               |\r\n| Custom Name Availability Check | `customNameCheck is checkNameAvailability<TScopeParameters, TRequest, TResponse, TAdditionalParams>` |\r\n\r\n`checkGlobalNameAvailability` and `checkLocalNameAvailability` have default values that allow them to be used without specifying any template parameters. `checkNameAvailability` requires the `TScopeParameters` template parameter, which describes the parameters which define the scope of the name check request. For reference, the following table shows the `TScopeParameters` for the standard templates:\r\n\r\n| Operation                      | Scope Parameters                                                       |\r\n| ------------------------------ | ---------------------------------------------------------------------- |\r\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\r\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\n\n## Writing Custom Operations\n\nTypeSpec operation templates provide a simple mechanism for producing the most common operation patterns in ARM, using best practices and conforming to ARM RPC guidelines. However, sometimes a service has special requirements for operations that fall outside these boundaries. The `Azure.ResourceManager.Foundations` namespace provides lower level building blocks that can be used to produce operations and operation templates.\r\n\r\nThe building blocks are described in the sections below:\n\n### ARM Response Types\n\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\r\n\r\n| Model                               | Code | Description                                   |\r\n| ----------------------------------- | ---- | --------------------------------------------- |\r\n| `ArmResponse<T>`                    | 200  | Base Arm 200 response.                        |\r\n| `ArmResourceUpdatedResponse<T>`     | 200  | Resource updated (PUT) response.              |\r\n| `ArmResourceCreatedResponse<T>`     | 201  | Resource created response for an lro.         |\r\n| `ArmResourceCreatedSyncResponse<T>` | 201  | Resource created synchronously.               |\r\n| `ArmAcceptedResponse`               | 202  | Base Arm Accepted response.                   |\r\n| `ArmNoContentResponse`              | 204  | Base Arm No Content response.                 |\r\n| `ArmDeletedResponse`                | 200  | Resource deleted response.                    |\r\n| `ArmDeleteAcceptedResponse`         | 202  | Resource deletion in progress response.       |\r\n| `ResourceListResult<T>`             | 200  | Return a list of resource with ARM pagination |\r\n| `ErrorResponse`                     | x    | Error response                                |\n\n### Common Operation Parameters\n\nThere are a number of model types which specify common parameters which are used in resource type operations:\r\n\r\n| Model                           | In           | Description                                                 |\r\n| ------------------------------- | ------------ | ----------------------------------------------------------- |\r\n| `ApiVersionParameter`           | query        | api-version parameter                                       |\r\n| `SubscriptionIdParameter`       | path         | Subscription ID path parameter                              |\r\n| `ResourceGroupNameParameter`    | path         | Resource Group Name path parameter                          |\r\n| `ResourceInstanceParameters<T>` | path & query | Identity parameters for a resource, with api-version        |\r\n| `ResourceParentParameters<T>`   | path & query | Identity Parameters for listing by parent, with api-version |\r\n| `ResourceUriParameter`          | path         | Resource uri path parameter for Extension resources         |\r\n| `OperationIdParameter`          | path         | Operation Id path parameter                                 |\n\n### Synchronous List Action\n\nHere is a sample template for resource list actions that return synchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionSync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionSync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n\n### Asynchronous List Action\n\nHere is a sample template for resource list actions that return asynchronously, using the common building blocks.\r\n\r\n```typespec\r\n// Template definition\r\n@autoRoute\r\n@armResourceAction(TResource)\r\n@post\r\nop ArmResourceListActionAsync<TResource extends ArmResource, TResponse extends object>(\r\n  ...ResourceInstanceParameters<TResource, TBaseParameters>,\r\n): ArmResponse<TResponse> | ArmAcceptedResponse | ErrorResponse;\r\n\r\n// Usage\r\n\r\n// The model for each data record\r\nmodel Widget {\r\n  name: string;\r\n  color: string;\r\n}\r\n@armResourceOperations(MyResource)\r\ninterface MyResourceOperations {\r\n  // ResourceListResult<T> produces a Pageable list of T\r\n  listWidgets is ArmResourceListActionAsync<MyResource, ResourceListResult<Widget>>;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-type.md\n- document_title: ARM Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type\n- document_content: # howtos#arm#resource-type.md\n\n# ARM Resource Types\n\n## Introductions\n\nIntroduction\r\nResources are the basic building blocks of Azure. When a customer interacts with Azure through the Control Plane (ARM), they generally will be reading (GET), writing (PUT/PATCH), deleting (DELETE) or performing actions upon (POST) one or more resources. Each resource is managed by a particular Resource Provider, so we uniquely identify a resource by its 'fully-qualified type'. Some well-known examples of types are Microsoft.Compute/virtualMachines, or Microsoft.Network/networkSecurityGroups/securityRules. See Resource Ids for a more in-depth breakdown of the id and associated fields.\r\n\r\nIn order to give customers a consistent API when working with many different Resource Providers, and to allow ARM to understand and manage resources programmatically, ARM requires each RP to follow a set of contracts for resource management, defined in the ARM RPC.\n\n## ARM Resource Terminology\n\nThe most important distinction between resources is between _Tracked_ and _Proxy_ resources. Tracked resources are resources in which all of the metadata is maintained in Azure Resource Manager. Tracked Resources can be targeted to specific regions, and are generally the best choice for most top-level resources. Azure Resource Manager maintains data about Tracked Resources, and generally will handle many implementation details or operations on the resource. See [RPC: Resource API Reference](https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md) for further information on the contract for Tracked Resources.\r\n\r\nProxy resources are resources in which only a portion of resource metadata is tracked in ARM. Generally, these model resources maintained on other systems, or that resource-providers want to track themselves. Generally, resource providers must implement most of the operations for Proxy resources. Tenant, Extension, and child resources are usually modeled as Proxy resources.\r\n\r\nThere is a good discussion on making the choice between Tracked and Proxy Resources in the armwiki discussion [Tracked vs Proxy Resources](https://armwiki.azurewebsites.net/rp_onboarding/tracked_vs_proxy_resources.html)\n\n## Choosing a Resource Type\n\n- The large majority of resources have their metadata tracked by ARM, can be assigned to regions, and are contained inside a resource group in a subscription, for ease of management and billing. These are called [Tracked Resources](#tracked-resources).\r\n- Some resources may need to have scope across an entire customer tenant, or may need to have a single instance across all customer subscriptions. These are called [tenant resources](#tenant-resources).\r\n- Some kinds of resources may augment or alter the functionality of resources or resource containers provided by other resource-providers. For example, policy or RBAC rules may be applied to any resource or resource container. These resources are called [extension resources](#extension-resource).\r\n- Some resources are complex and naturally break down into one or more components that are separately configurable, but an integral part of the larger resource (for example, a virtual network resource may contain many separately configurable subnets). These component resources are called [child resources](#child-resource).\r\n- Rarely, some resources may need to apply across a subscription, or have a single instance in a customer subscription, these are called [subscription-based resources](#subscription-based-resource).\r\n- Rarer still, some resources may need to apply across a specific region, or have a single instance in a region, these are called [location-based resources](#location-based-resource).\r\n- In some cases, there can only be one instance of a resource at a specific scope - this is rare, but happens most frequently in tenant, child, and location resources. In typespec, you will need to specify that the resource is a singleton, and the resource manager tools will automatically apply the correct pattern for singleton resources (using the recommended resource name 'default')\n\n## Modeling Resources in TypeSpec\n\nResources are modeled in TypeSpec by choosing a _base resource type_, defining _rp-specific properties_, and optionally mixing in _standard envelope properties_. Later sections document [how to model resource operations](./resource-operations.md). The following sections discuss usage of each of the base resource types. Later sections discuss [designing rp-specific properties](#designing-resource-specific-properties) and [adding standard ARM envelope properties](#adding-optional-standard-envelope-properties).\n\n### Tracked Resources\n\nTracked resources use the `TrackedResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tracked Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Tenant Resources\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@tenantResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tenant Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Extension Resource\n\nExtension resources use the `ExtensionResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is ExtensionResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Extension Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Child Resource\n\nChild resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@parentResource(EmployeeResource)\r\nmodel JobResource is ProxyResource<JobProperties> {\r\n  /** The job name */\r\n  @segment(\"jobs\")\r\n  @key(\"jobName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@parentResource`: designates the model type for the parent of this child resource. The resource identifier for this resource will be prepended with the resource identity of the parent.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Child Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Subscription-based Resource\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@subscriptionResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@subscriptionResource`: designates this resource as being a cross-subscription resource, with scope across all resource groups in the subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Subscription Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Location-based Resource\n\nLocation-based resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@locationResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@locationResource`: designates this resource as being a cross-location resource, with scope across a location within a subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Location Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Singleton Resource\n\nSingleton resources can use any resource base type, but most often use `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@singleton\r\n@tenantResource\r\nmodel EmployeeAgreementResource is ProxyResource<EmployeeAgreementProperties> {\r\n  /** The default employee agreement, applying to all employees. */\r\n  @segment(\"employeeAgreements\")\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@singleton`: indicates that there can only be one of the resources in the resource container (in this case, only one instance in the customer tenant).\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource. For a singleton, the name value will always be the same.\r\n`@segment(employeeAGreements)`: provides the resource type name for this resource.\r\n`@key`: provides the parameter name for the name of the resource in operations that use this resource - this will not be a settable value for singleton resources.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Singleton Resources [in the Singleton sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/arm-scenarios/singleton/main.tsp#L29).\n\n## Designing Resource-specific Properties\n\nEach resource model consists of two distinct parts\r\n\r\n- An outer _envelope_ of information that provides metadata for optional standardized ARM functionality, like entity-tags and managed identities, and is processed by Azure Resource Manager.\r\n- An inner set of properties that are specific to the resource and are defined by the resource provider.\r\n\r\nModifying the ARM envelope is discussed in later sections on [mixing in standard ARM envelope add-ons](#adding-optional-standard-envelope-properties).\r\n\r\nThe inner _rp-specific property bag_ consists of all of the properties that the RP needs to manage about the resource. Properties should be completely specified, should not duplicate properties from the _ARM envelope_, and may consist of simple types, arrays, or other complex properties.\r\n\r\nHere is an example of a property bag for the `EmployeeResource` resource.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n\r\nunion EmployeeProvisioningState {\r\n  string,\r\n\r\n  /** The resource create request has been accepted */\r\n  Accepted: \"Accepted\",\r\n\r\n  /** The resource is being provisioned */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is updating */\r\n  Updating: \"Updating\",\r\n\r\n  /** Resource has been created. */\r\n  Succeeded: \"Succeeded\",\r\n\r\n  /** Resource creation failed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\n\nfailed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n\r\nmodel EmployeeProperties {\r\n  /** The current title of the employee */\r\n  title: string;\r\n\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  level: EmployeeLevel;\r\n\r\n  @visibility(Lifecycle.Read)\r\n  employeeId: int32;\r\n\r\n  biography?: string = \"No biography provided\";\r\n  colleagues: EmployeeResourceId[];\r\n  employmentHistory: Job[];\r\n\r\n  @visibility(Lifecycle.Create)\r\n  password: Password;\r\n\r\n  provisioningState?: EmployeeProvisioningState;\r\n}\r\n```\r\n\r\n`EmployeeProperties` specifies the employee metadata that the RP needs to track and manage. Notice that the model uses built-in scalar types like `string` and `int32`, new types built from scalar types with added constraints, like `Password` and `EmployeeLevel`, enumerations of values, like `EmployeeProvisioningState`, and complex types. The individual components of this model are described below.\r\n\r\nNote that _documentation comments on all models and model properties are required when specs are checked in_. Here they are omitted for clarity. The TypeSpec compiler and TypeSpec IDE tooling will emit warning diagnostics if you emit required documentation, and about most of the ARM rules described in this document.\n\n### The `provisioningState` Property for Tracked Resources\n\nAll Tracked Resources are required to implement a 'provisioningState' property in their rp-specific property bag. This is used by ARM and some ARM clients to track the provisioning state of a resource as it is created and deleted. At minimum, the provisioning state must contain the standard terminal values that ARM is looking for. There are contained in the `ResourceProvisioningState` enumeration in the Azure.ResourceManager library. If RPs have other provisioning states they would like to track, they can define their own provisioning state enum, and mix in the value, as shown in the sample above, or they may simply use the standard provisioning state as shown in the sample below:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  ...ResourceProvisioningState;\r\n}\r\n```\r\n\r\nNote that this example uses the spread operator `...`, which allows you to simply include the properties from a source model in the target model you are constructing. This has the effect of copying the properties of the source model and their decorations into the target model, without creating any nominal inheritance relationship.\r\n\r\nAlternately, this is also equivalent:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  /** The status of the last provisioning operation performed on the resource. */\r\n  @visibility(Lifecycle.Read)\r\n  provisioningState?: ResourceProvisioningState;\r\n}\r\n```\n\n### Required and Optional properties and Property Defaults\n\nIn the examples, note that some model properties use the optional operator `?` after the property name, like `biography?` and some do not, like `title`. Property names using the `?` are optional properties, which may or may not be provided in the request body for CreateOrUpdate (PUT) requests. Property names without the `?` are required properties, which must be provided in PUT requests. The exception is that properties that have 'readOnly' visibility do not appear in requests, but may be required or optional in responses.\r\n\r\nAlso note that optional properties may specify defaults, as with `biography?: string = \"No biography provided\"`. The default indicates the value that will be recorded on the server if no value is sent by the client.\n\n### Defining Custom Types\n\nIn the sample, new constrained scalar types and new complex model types are defined and used inside the _rp-specific property bag_. TypeSpec allows you to define custom types for use in your specification.\r\n\r\nYou will often want to define scalar types or properties that have constraints. For example, numeric values may be constrained to have a certain minimum or maximum, strign values may be constrained to follow a particular regex pattern, and so on. Whenever these constrained types are used in your spec, the constraints will be transmitted to the usage.\r\n\r\nThe example creates a numeric type with minimum and maximum constraints:\r\n\r\n```typespec\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n```\r\n\r\nThis defines 'EmployeeLevel' as an integer value between 50 and 70. The example also defines a complex type used in an array:\r\n\r\n```typespec\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n```\r\n\r\nMode details on what to consider when using complex types in an array are discussed in the section on [modeling arrays of complex types](#modeling-arrays-of-complex-types).\n\n### Using Resource identifiers\n\nIt is often the case that resources need to reference other resources to provide specific pieces of functionality. For example, resources may need to reference a storage account to use for storing user data, or a NIC to attach to a Network. The `Azure.ResourceManager` library defines a `ResourceIdentifier` template that allows you to easily represent references to resources in your API. The template allows you to specify one or more acceptable resource types, automatically designating the value as a resource reference, and providing the appropriate pattern validation - which helps in generating better code, better ARM templates, and better documentation for your API.\r\n\r\n```typespec\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\nscalar NetworkInterfaceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/networkInterfaces\",\r\n    },\r\n    {\r\n      type: \"Microsoft.ClassicNetwork/networkInterfaces\",\r\n    }\r\n  ]>;\r\n```\r\n\r\nThe `NetworkInterfaceId example shows how to allow multiple resource types in a reference.\n\n### Property Visibility and Other Constraints\n\nThe sample uses the `@visibility` decorator to indicate how the resource definition is used in requests to PUT and PATCH operations, and in responses to PUT, PATCH, GET, and LIST operations.\r\n\r\nThis table shows how visibility is used to determine whether a property is used in requests and responses:\r\n\r\n| Visibility           | In Create Request? | In Patch Request/ Updateable in PUT | In Responses | Sample                                         |\r\n| -------------------- | ------------------ | ----------------------------------- | ------------ | ---------------------------------------------- |\r\n| None                 | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create, update | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create         | Yes                | No                                  | Yes          | resource location                              |\r\n| read, update         | No                 | Yes                                 | Yes          | Properties only settable after creation (keys) |\r\n| create, update       | Yes                | Yes                                 | No           | Secrets (e.g. password)                        |\r\n| read                 | No                 | No                                  | Yes          | Calculated properties, e.g. provisioningState  |\r\n| update               | No                 | Yes                                 | No           | Secrets (e.g. keys)                            |\r\n| create               | Yes                | No                                  | No           | Secrets (e.g. user-defined password)           |\n\n### Modeling Arrays of Complex Types\n\nFinally, when your _rp-specific property bag_ contains an array of complex properties, there are a few important considerations:\r\n\r\n- The complex properties in an array must have a key property - this means a property named 'name' or 'id' that uniquely identifies the property in the array. The TypeSpec tools will emit a diagnostic if you omit this.\r\n- ARM resources must be fully loaded in memory, so there are limits to the size of arrays in the properties of a resource. If your array is not strictly bounded, you should consider modeling the array property as a [child resource](#child-resource)\r\n- Updating the contents of arrays can be difficult, and result in data loss under simultaneous updates, especially as Json-Merge-Patch is not widely supported in ARM update operations. If users will frequently need to update the contents of arrays, you should consider modeling as a [child resource](#child-resource).\n\n## Adding Optional Standard Envelope Properties\n\nIn addition to the resource-specific property bag, a resource may configure on or more standard ARM features through the use of standard properties in the _ARM Envelope_. Standard features configured in the envelope include:\r\n\r\n- **Managed Identity**: Associating a managed identity with the resource to authorize actions taken by this resource on other resources.\r\n- **SKU**: A standard mechanism for configuring levels of service for a resource.\r\n- **Plan**: A standard mechanism for configuring MarketPlace billing plans for a resource.\r\n- **ETags**: A standard mechanism for managing concurrent operations over the resource.\r\n- **ResourceKind**: A standard mechanism for specifying a type of user experience in the portal.\n\n### Managed Identity\n\nStandard configuration for ARM support of both SystemAssigned and UserAssigned Managed Service Identity (MSI)\r\n\r\n- If a resource allows both generated (SystemAssigned) and user-assigned (UserAssigned) Managed Identity, use the spread (...) operator to include the standard ManagedServiceIdentity envelope property. This will allow users to manage any ManagedServiceIdentity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedServiceIdentity;\r\n  }\r\n  ```\r\n\r\n- If a resource allows only generated (SystemAssigned) Managed Identity, use the spread operator (...) to include the `ManagedSystemAssignedIdentity` standard envelope property in the resource definition. This will allow users to manage the SystemAssigned identity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedSystemAssignedIdentity;\r\n  }\r\n  ```\r\n\r\nFor more information, see [Managed Service Identity Support](https://eng.ms/docs/products/arm/rpaas/msisupport)\n\n### SKU\n\nStandard support for setting a SKU-based service level for a resource. To enable SKU support, add the `ResourceSku` enevelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceSku;\r\n}\r\n```\r\n\r\nFor more information, see [SKU Support](https://eng.ms/docs/products/arm/rpaas/skusupport)\n\n### ETags\n\nIndicator that entity-tag operation concurrency support is enabled for this resource. To enable ETags, add the `EntityTag` envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...EntityTag;\r\n}\r\n```\r\n\r\nFor more information, and limitations on RPaaS concurrency support, see [RPaaS ETag Support](https://eng.ms/docs/products/arm/rpaas/etags)\n\n### Plan\n\nSupport for marketplace billing configuration for the resource. To enable `Plan` support, add the `ResourcePlan` standard envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourcePlan;\r\n}\r\n```\r\n\r\nSee [MarketPlace Third Party Billing SUpport](https://eng.ms/docs/products/arm/rpaas/custom_billing)\n\n### ResourceKind\n\nSupport for certain kinds of portal user experiences based on the kind of resource. To include 'Kind' in the resource defintion, add the `ResourceKind` standard envelope property.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceKind;\r\n}\r\n```\r\n\r\nFor more information on user experiences in the Azure Portal, see [Portal Support](https://eng.ms/docs/products/arm/rpaas/portal/gettingstarted)\n\n### ManagedBy\n\nSupport for management of this resource by other resources. To add 'ManagedBy' support to the resource, add the `ManagedBy` envelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ManagedBy;\r\n}\r\n```\r\n\r\nFor more information on supporting 'ManagedBy', see [ManagedBy API Contract](https://eng.ms/docs/products/arm/api_contracts/managedby)\n\n## Reference\n\n[Fundamentals - ARM Wiki](https://armwiki.azurewebsites.net/fundamentals/overview.html)\n", "latency": 19.659929513931274, "response_length": 867}
{"query": "title: Generate typespec for a specific version of the API\n\nquestion: Hey Folks,\nI'm adding a new version to my API. The new version has some changes amongst which one change is to make a required property optional. Running a vanilla tsp compile . seems to be compiling old and new version. This is causing a validation failure in the PR. Wondering if there is a way to tsp compile and provide a specific version so that a new specification is created just for the new version and old version is not updated.", "ground_truth": "TypeSpec specs are inherently multi-version.  You use the version library to encode the changes from the last version to the current version, see: [10. Versioning | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10/)\nYou need to make sure both that `@typespec/versioning` is in your package.json and you have imported it in your spec.  If you are targeting one of the azure-rest-api-specs repos, the package.json at the root of the repo already includes the package", "response": "To generate a specification for a specific version of your API without affecting other versions, you can use the `@versioned` decorator provided by the `@typespec/versioning` library. This decorator allows you to define multiple versions of your API and ensures that separate OpenAPI specifications are generated for each version. Here's how you can achieve this:\n\n1. **Define Versions**: Use the `@versioned` decorator to specify the versions supported by your API. For example:\n\n```tsp\nimport \"@typespec/versioning\";\nusing Versioning;\n\n@versioned(Versions)\nnamespace MyAPI;\n\nenum Versions {\n  v1: \"1.0\",\n  v2: \"2.0\",\n}\n```\n\n2. **Version-Specific Changes**: Use the `@added` decorator to specify changes that are specific to a particular version. For example, if a property is optional in version 2:\n\n```tsp\nmodel MyModel {\n  requiredProperty: string;\n\n  @added(Versions.v2)\n  optionalProperty?: string;\n}\n```\n\n3. **Compile Specific Version**: When you run `tsp compile`, the TypeSpec compiler will generate separate OpenAPI specifications for each version defined in the `Versions` enum. These specifications will be placed in the output directory, such as:\n\n```\n- tsp-output/\n  - @typespec/\n    - openapi3/\n      - openapi.1.0.yaml\n      - openapi.2.0.yaml\n```\n\nThis ensures that the new version's specification is created without modifying the old version's specification.\n\nIf you are encountering validation failures, ensure that the version-specific changes are correctly annotated with the `@added` decorator and that the `@versioned` decorator is properly applied to your namespace.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n", "latency": 12.74192476272583, "response_length": 1590}
{"query": "title: Setting up TypeSpec tsp cli in order to run \"tsp compile .\" command\n\nquestion: [Read the docs](https://armwiki.azurewebsites.net/rpliteonboarding/typespecGettingStarted.html)\nTried to install the tsp cli using npm install -g @typespec/rest @typespec/openapi3 @azure-tools/typespec-azure-core @azure-tools/typespec-autores and then ran the tsp command, got this error in the screenshot. Could I be missing a setup step?\n![alt text](image-26.png)\nI see these folders go installed globally too and this path is in my environment variables too\n![alt text](image-28.png)![alt text](image-27.png)", "ground_truth": "The user faced issues with installing TypeSpec packages globally, which is not recommended when working within the Azure REST API specs repository. The correct approach is to use npx to ensure that the locally installed packages in the repository are used, as the repository has a specific package.json that pins the required versions. The TypeSpec compiler can be installed globally to access the tsp command, but other TypeSpec packages should not be installed globally to avoid conflicts. The documentation may be inconsistent, and it is suggested to follow the Azure-specific docs in the azure-rest-api-specs repo for proper setup. The discussion also highlights the difference between core TypeSpec documentation, which is for a broad audience, and Azure-specific documentation for internal use.", "response": "It seems you may have missed a critical setup step for installing the TypeSpec CLI. To run the `tsp compile .` command successfully, you need to install the TypeSpec compiler globally using the command `npm install -g @typespec/compiler`. This is the core CLI tool required to compile TypeSpec projects. After installation, verify the setup by running `tsp --version` to ensure the CLI is correctly installed and accessible. Additionally, ensure that your Node.js version is at least 20.0.0 and npm version is 7.0.0 or higher, as these are the minimum requirements for TypeSpec.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n", "latency": 7.841452360153198, "response_length": 578}
