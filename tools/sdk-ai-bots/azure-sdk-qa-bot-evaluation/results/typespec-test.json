[
    {
        "testcase": "Updating from `@typespec/compiler@^0.65.0` -> `1.2.0`. Changes to `@service` decorator.",
        "expected": "All the other options where never available and just silently dropped. If you meant to have this in the openapi document you should use @info from openapi library",
        "actual": "You're correct that starting with TypeSpec 1.x, the `@service` decorator only supports the `title` field (and possibly `summary`), whereas older versions allowed you to provide a full OpenAPI info object (including `termsOfService`, `contact`, `license`, etc.). This change was intentional to streamline the TypeSpec core API surface, and other OpenAPI metadata is now expected to be set via the `@TypeSpec.OpenAPI.info` decorator instead.\n\n**How to migrate your info metadata:**\n\n1. **Set the title using `@service`:**\n```typespec\n@service(#{ title: \"Azure OpenAI Service\" })\n```\n\n2. **Set the other info using `@TypeSpec.OpenAPI.info`:**\nFirst, make sure you import the OpenAPI library:\n```typespec\nimport \"@typespec/openapi3\";\n```\nThen decorate your namespace:\n```typespec\n@service(#{ title: \"Azure OpenAI Service\" })\n@TypeSpec.OpenAPI.info(#{\n  termsOfService: \"https://openai.com/policies/terms-of-use\",\n  contact: #{\n    name: \"OpenAI Support\",\n    url: \"https://help.openai.com\"\n  },\n  license: #{\n    name: \"MIT\",\n    url: \"https://github.com/openai/openai-openapi/blob/master/LICENSE\"\n  }\n})\nnamespace Azure.OpenAI;\n```\nThis approach is now the standard way to add OpenAPI metadata beyond the title in TypeSpec 1.x and later.\n\n**Summary:**\n- Use `@service` for the service title.\n- Use `@TypeSpec.OpenAPI.info` for other OpenAPI info fields.\n\nThis is fully supported and will result in the correct OpenAPI output.\n",
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_threshold": 3.0,
        "similarity_result": "pass",
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_threshold": 3.0,
        "groundedness_result": "pass",
        "overall_score": 5.0
    },
    {
        "testcase": "Swagger LintDiff - Analyze Code failing in PR",
        "expected": "The error message points to the problem:\n```\nNo affected swaggers found in specModel for /home/runner/work/azure-rest-api-specs-pr/azure-rest-api-specs-pr/before/specification/azuredatatransfer/resource-manager/Private.AzureDataTransfer/stable/2025-05-21/azuredatatransfer.json\n```\nThis means, the file in the error message was not reachable, either directly or via a reference, from your readme.md.  Either add the file to your readme.md, or delete the file.",
        "actual": "Disclaimer: I do not have access to your PR's detailed logs or the images referenced. My guidance is based on the error message you pasted and standard TypeSpec/Azure migration workflows.\n\n**Why is LintDiff failing with `No affected swaggers found in specModel`?**\n\nThis error typically means that the LintDiff tool cannot find a Swagger (OpenAPI) file in the `before` state that matches the path of a Swagger file in your `after` state. This often happens when:\n- The Swagger file path has changed between branches (e.g., you moved or renamed the file as part of migration to TypeSpec).\n- The `readme.md` was updated to reference a new Swagger generated from TypeSpec, but the old Swagger file was removed or the mapping between before/after states is broken.\n- The changed file list does not match what the LintDiff script expects, often due to a missing, renamed, or moved Swagger file.\n\n**How to Fix:**\n1. **Ensure file paths match:**\n   - If you migrated from a hand-authored Swagger to a TypeSpec-generated Swagger, make sure the new generated Swagger has the same path and file name as the old one, or that you update the `readme.md` and PR so LintDiff can correctly compare the old and new versions.\n   - If you changed the file name, you may need to add/remove both the old and new files in your PR.\n2. **Check `readme.md` references:**\n   - Under the latest tag in `readme.md`, make sure the `input-file` points to the Swagger generated from TypeSpec.\n   - If the generated Swagger file changed names, delete the old Swagger file(s) that are no longer referenced in `readme.md`.\n3. **Validate your migration process:**\n   - Follow the official migration process: generate Swagger from TypeSpec, update `readme.md`, and ensure the old and new Swagger files are both present in the correct locations for LintDiff to compare.\n   - See the [migration docs](https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started) for a step-by-step checklist.\n4. **Check your PR file list:**\n   - The PR should contain both the TypeSpec files, the newly generated Swagger file(s), and the removal (if applicable) of old Swagger files.\n\n**If you are sure your files are correct but LintDiff still fails:**\n- There may be a mapping issue or a bug in the tooling. In that case, reach out to the [TypeSpec Discussion Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) or file an issue on the [typespec-azure repo](https://github.com/Azure/typespec-azure/issues) with details about your file changes and the error message.\n\n**Summary:**\n- Double-check file paths, names, and `readme.md` references for your Swagger files.\n- Make sure old and new files are present and properly referenced for LintDiff.\n- Remove any Swagger files that are no longer referenced.\n- See migration and troubleshooting docs for more help.\n\nIf you share the exact before/after file names and your `readme.md` changes, I can provide more precise guidance.",
        "similarity": 3.0,
        "gpt_similarity": 3.0,
        "similarity_threshold": 3.0,
        "similarity_result": "pass",
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_threshold": 3.0,
        "groundedness_result": "pass",
        "overall_score": 3.8
    },
    {
        "testcase": "Best replacement for char in TypeSpec?",
        "expected": "it is usually simpler and more explicit to add maxLength and minLength constraints to the custom scalar, [like this](https://typespec.io/playground/?e=%40typespec%2Fopenapi3&c=QG1heExlbmd0aCgxKQ0KQG1pbssPc2NhbGFyIGNoYXIgZXh0ZW5kcyBzdHJpbmc7DQo%3D&options=%7B%7D&vs=%7B%7D), rather than using the pattern decorator\n```\n@maxLength(1)\n@minLength(1)\nscalar char extends string;\n```",
        "actual": "TypeSpec does not have a built-in `char` (character) type like C# or Java. In most REST and OpenAPI scenarios, a single character is typically represented as a `string` with a length constraint. The recommended approach in TypeSpec is to use `string` with a `@minLength(1)` and `@maxLength(1)` decorator to indicate a single character.\n\nExample:\n\n```typespec\nmodel Example {\n  // Represents a single character\n  @minLength(1)\n  @maxLength(1)\n  letter: string;\n}\n```\n\nThis will generate an OpenAPI schema equivalent to `type: string, minLength: 1, maxLength: 1`, which is the standard way to model a single character in OpenAPI as well. If you need to further restrict allowed characters (e.g., to a specific set), you can also use the `@pattern` decorator.\n\n**Summary:** Use `string` with `@minLength(1)` and `@maxLength(1)` to represent a `char` in TypeSpec.",
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_threshold": 3.0,
        "similarity_result": "pass",
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_threshold": 3.0,
        "groundedness_result": "pass",
        "overall_score": 5.0
    },
    {
        "testcase": "TypeSpec Versioning Generic Question",
        "expected": "It is generally recommended that you have only one active preview api, but this has to be balanced with ARM retention requirements for preview APIs.  For APIs that are not public to customers,  I don't see any need for them to remain once your tests no longer use those api versions",
        "actual": "You can safely remove previous (unused) preview API versions from your TypeSpec files, including from your main.tsp, as long as you are not supporting those versions in your backend and there are no customers using them. This is now the recommended practice for Azure services: only keep the latest preview version in your TypeSpec repo, unless you have a public preview with active customers or a GA version that must be retained for backward compatibility. \n\nFrom the Azure Versioning Guidelines and TypeSpec best practices:\n- **Do** remove retired API versions from the azure-rest-api-specs repo.\n- **Do** retire all prior preview API versions 90 days after a new preview or GA is released.\n- **Do** ensure that only actively supported versions are listed in your TypeSpec version enum and in your main.tsp.\n- For private preview specs, you can remove older versions immediately if there are no customers using them and you are not required to retain them for public preview or GA support.\n\nRegarding the use of @added and @removed decorators:\n- These decorators are essential when you need to make changes to models, properties, or operations across versions. As you introduce a new version, you should annotate any new fields with @added(Versions.new_version), and annotate any removed fields with @removed(Versions.new_version).\n- You do NOT need to keep the @added/@removed history for versions you are deleting from your TypeSpec files. Only the currently supported versions need to be annotated for the differences that exist between them.\n- When you remove a property in the newest version, that is a breaking change. This is why a new API version is required for such changes. As long as the prior versions continue to support the property (and your backend honors this), you are following the correct process. Removing a property in the latest version and retaining it in previous versions is allowed as long as versioning is used properly.\n\n**Summary guidance:**\n- Remove all unused/retired preview versions from your Versions enum and TypeSpec files.\n- Use @added/@removed only for fields/properties that differ between the remaining, actively supported versions.\n- Removing a field in the newest version is a breaking change for that version, but is safe as long as prior versions are still supported for existing clients (if any).\n- For private preview, you are not required to keep old versions or keep history in your TypeSpec repo.\n\nIf you have published a public preview or GA, you must follow the 90-day retention and retirement guidelines for previous versions. Otherwise, you can clean up your TypeSpec files and keep only the versions that are truly in use.\n\nYou do NOT need to keep @added/@removed decorators for versions you have deleted from the repo. Just annotate for differences between the versions that remain.",
        "similarity": 3.0,
        "gpt_similarity": 3.0,
        "similarity_threshold": 3.0,
        "similarity_result": "pass",
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_threshold": 3.0,
        "groundedness_result": "pass",
        "overall_score": 3.8
    },
    {
        "testcase": "TypeSpec Avocado failing even with labels tag",
        "expected": "Your PR is merged, so I can't see the status checks anymore.  My guess is you confused the intermediate check \"Swagger Avocado - Analyze Code\" with the final required check \"Swagger Avocado\".",
        "actual": "Disclaimer: I cannot access the full PR details or pipeline logs directly, so my answer is based on the error messages and the current Azure TypeSpec/Swagger/Avocado workflow knowledge.\n\nYour PR is failing with Avocado errors of type `MISSING_APIS_IN_DEFAULT_TAG`, which indicates that certain API paths generated from your TypeSpec are not included in the `default` tag in your `readme.md`. Normally, if you apply the `Approved-Avocado` label to your PR, the Avocado check should be considered suppressed and should not block your PR, especially for known false positives like route renames, moves, or versioning issues. This is the standard workaround when Avocado has not yet caught up to certain TypeSpec/Swagger patterns (like with the `@renamedFrom` decorator or versioning).\n\nIf the check is still running and blocking your PR even after adding the `Approved-Avocado` label, it is likely due to one of these situations:\n1. The label is misspelled or not applied to the correct PR (make sure it's exactly `Approved-Avocado`).\n2. The CI workflow may not be configured to recognize the label for this specific error (there are occasional delays or sync issues between the labeling and the pipeline triggers).\n3. There may be an infrastructure bug, or the check ran before the label was applied. In this case, try re-running the failed check after the label is set.\n\n**Action items:**\n- Double-check the label spelling and presence on your PR.\n- If the label is correct, try re-running the Avocado check in the GitHub UI.\n- If the error persists, comment in your PR referencing this as a false positive and tag a repo admin or reach out via the [API Spec Review FAQ](https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ) for manual override or further assistance.\n\nYou are not required to \"fix\" these Avocado errors for issues that are recognized as false positives due to TypeSpec migration/versioning, as long as the `Approved-Avocado` label is present and recognized by the pipeline.",
        "similarity": 3.0,
        "gpt_similarity": 3.0,
        "similarity_threshold": 3.0,
        "similarity_result": "pass",
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_threshold": 3.0,
        "groundedness_result": "pass",
        "overall_score": 3.8
    },
    {
        "testcase": "Define Proxy object with 200/202 Http response",
        "expected": "You shouldn't.  PUT operations should return 200 and 201, per the RPC.  There are some templates that allow overriding the default responses, but this would only be appropriate for older APIs.  Newer APIs should not define such operations.",
        "actual": "To define a PUT API for an ARM proxy resource (such as a ProxyResource) in TypeSpec that returns a 200 or 202 HTTP response, you need to follow ARM and Azure REST guidelines. However, for proxy resources, the correct status codes for a PUT operation are 200 (OK) or 201 (Created) for synchronous or asynchronous completion, respectively. Returning 202 (Accepted) for a PUT is **deprecated and not allowed** for new resource types\u2014202 should not be used for PUT, only for POST actions (as per ARM guidance).\n\nFor a PUT on a ProxyResource:\n- Use 200 for successful update.\n- Use 201 for successful creation (not typical for proxy objects).\n- Do **not** use 202 for PUT (even for proxy objects), as ARM no longer supports this pattern for new APIs ([see reference below](https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/async-api-reference.md)).\n\nA typical TypeSpec definition for a PUT operation on a proxy resource would look like this:\n\n```typespec\nimport \"@azure-tools/typespec-azure-resource-manager\";\n\n// Define your proxy resource model\nmodel MyProxyResource is ProxyResource<MyProxyResourceProperties> {}\nmodel MyProxyResourceProperties {\n  // ...properties...\n}\n\n// Use the standard ARM template for PUT\n@put\nop createOrUpdate is ArmResourceCreateOrReplaceSync<MyProxyResource>;\n```\n\nThis will generate a PUT operation that returns 200 or 201 as required by ARM guidelines. If your resource is long-running, use `ArmResourceCreateOrReplaceAsync`, which will handle 200 and 201 with appropriate LRO headers. You should not configure the PUT operation to return 202.\n\nIf you want to allow 202 (Accepted) for an asynchronous operation, it should be modeled for POST action operations only (not for PUT). For actions, you can use `ArmResourceActionAsync`.\n\n**Summary:** For a proxy object PUT, return 200/201, not 202. Use the provided ARM resource templates in TypeSpec for compliance.",
        "similarity": 3.0,
        "gpt_similarity": 3.0,
        "similarity_threshold": 3.0,
        "similarity_result": "pass",
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_threshold": 3.0,
        "groundedness_result": "pass",
        "overall_score": 3.8
    },
    {
        "testcase": "Generating Examples in typespec/swagger",
        "expected": "For Problem 1,  The 'title' field in the example file determines the name of the example in the 'x-ms-examples' extension, file names have nothing to do with it.  TypeSpec and tsv have no preference for the names of example files, as long as they are in the configured example directory.  It is possible, however, for an example to be dropped if it shares the same 'title'  and 'operation Id'  with another example file.\nFor Problem 2, oav generate-examples is a best-effort tool to help you get started generating examples from Swagger.  You may need to further edit the examples after generation.\nFor Problem 3, The source of truth for your examples, is the \"examples\" folder alongside your TSP sources.  tsp compile copies these examples alongside your generated swagger.\nFor Problem 4,  'location' is required in any tracked resource, so a set of values with one resource would have this property.",
        "actual": "Let's address each of your problems in the context of TypeSpec and Azure Swagger/TypeSpec workflows:\n\n**Problem 1: Example Naming Differences (oav vs tsv)**\n- `oav generate-examples` and `npx tsv` may produce or expect different example naming conventions (e.g., `_Gen` suffix). `oav` appends `_Gen` to distinguish auto-generated examples, while TypeSpec and the Azure guidelines prefer examples named exactly after the `operationId` (e.g., `Operations_List_MinimumSet`).\n- **Best Practice:** Rename your example files and references to match the `operationId` without the `_Gen` suffix. This will help maintain consistency, especially when emitting from TypeSpec.\n\n**Problem 2: npx tsv Removes _Gen Examples**\n- This happens because TypeSpec expects examples to match the `operationId` (without `_Gen`). When you run `tsv`, it re-generates `x-ms-examples` using the source examples. Any extra entries (like `..._Gen`) are considered stale and are removed.\n- **Solution:** Store your canonical example files in your TypeSpec folder under `examples/` with names matching the `operationId`. When generating with TypeSpec, only those matching examples will be copied to the Swagger output.\n\n**Problem 3: Synchronizing Examples (TypeSpec & Swagger)**\n- The source of truth for examples should be the `examples/` folder in your TypeSpec project. When you run `tsp compile` or `npx tsv`, these are copied to the corresponding location in the Swagger directory. Do NOT edit the examples directly in the Swagger folder.\n- **Workflow:**\n  1. Place and edit example JSON files under `TypeSpec/examples/`, named after their `operationId`.\n  2. Run `tsp compile .` or `npx tsv` to regenerate the OpenAPI and copy examples to the Swagger folder.\n  3. Review and commit changes from the TypeSpec folder, not from the Swagger output.\n\n**Problem 4: oav Adds Unexpected Properties (e.g., location)**\n- The `oav` tool auto-generates examples and may include properties (like `location`) based on schema defaults or required fields. These may not always reflect your desired minimal example.\n- **Solution:** After generating with `oav`, manually edit the generated examples to ensure only the minimum required properties are present and the values are meaningful. The Azure guidelines expect that examples are human-reviewed and provide realistic, customer-relevant data.\n\n**Summary Recommendations:**\n- Use TypeSpec's `examples/` folder as the single source of truth for examples. Ensure naming matches `operationId` (no `_Gen`).\n- Always review and update examples for accuracy and minimal/maximal sets after any auto-generation.\n- Regenerate OpenAPI/Swagger via TypeSpec (`tsp compile` or `npx tsv`) to keep Swagger in sync.\n- If you need to bulk rename or clean up examples, do so in the TypeSpec `examples/` folder and recompile.\n\n**References:**\n- [x-ms-examples example files](https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/x-ms-examples): Explains the example structure and workflow.\n- [Examples Source and Destination](https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation): Describes how examples are synchronized between TypeSpec and Swagger folders.\n- [Duplicate Example files for Typespec and other for Swagger. By design?](#): Clarifies that Swagger examples are copied from TypeSpec and should not be edited directly.",
        "similarity": 3.0,
        "gpt_similarity": 3.0,
        "similarity_threshold": 3.0,
        "similarity_result": "pass",
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_threshold": 3.0,
        "groundedness_result": "pass",
        "overall_score": 3.8
    },
    {
        "testcase": "How to create an Example for a typespec model?",
        "expected": "Here is some documentation on generating required examples: [x-ms-examples example files | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/x-ms-examples/).\nNote that the examples that are required for specs at this point are operation examples (which include examples of model serialization in the operations that include those models).  The workflow is:\nDesign your API in TypeSpec\nGenerate an OpenApi doc by compiling your spec\nRun oav to generate examples for each of the operations (oav generates syntactically valid examples with the 'operationId'  and 'title' fields filled in)\nGo through the examples, replace values to make the examples more useful as documentation, and feel free to add  any examples for important scenarios that might be difficult to understand otherwise, or remove redundant examples (although you will need at least one per operation)\nCopy the examples into the `examples/<api-version>/` folder inside your typespec directory and the OpenApi emitter will automatically associate the examples with  the appropriate operatiosn through the 'operationId' in the example file,  using the 'title' field as the title of the example.",
        "actual": "You are correct: in Azure TypeSpec, you should **not** use the `@example()` decorator on models. The Azure API guidelines and the TypeSpec linter (`@azure-tools/typespec-azure-core/no-openapi`) specifically prohibit using `@example()` (or `@extension(\"x-ms-examples\")`) on models or operations directly. Instead, Azure uses a system of example JSON files that are linked to operations by their `operationId`.\n\n**Key points:**\n- The `@example()` decorator in the Azure TypeSpec ecosystem is only valid on operations, not on models.\n- Models themselves do not have `operationId`s; only operations do. Examples are attached to operations, and any example data for a model is shown within the context of an operation's request or response.\n- The required workflow is:\n  1. Define your API and models in TypeSpec.\n  2. Compile to OpenAPI.\n  3. Use the `oav` tool to generate operation-level example JSON files (these will include serialized representations of your models in context).\n  4. Edit these examples for quality and coverage, then place them in the `examples/<api-version>/` folder. The example files must have `operationId` and `title` fields so the OpenAPI emitter can associate them with the correct operation.\n- There is **no mechanism to associate examples directly with models**. All model examples are shown via the operations that use them.\n\n**In summary:**\n- Do not use `@example()` on models. Provide operation-level examples as JSON files, linked via `operationId`.\n- Models do not have `operationId`s and therefore cannot have directly attached examples in the Azure API/TypeSpec workflow.\n\nIf you want to illustrate model usage, do so by ensuring your operation examples include clear, meaningful instances of those models in the request/response bodies.",
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_threshold": 3.0,
        "similarity_result": "pass",
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_threshold": 3.0,
        "groundedness_result": "pass",
        "overall_score": 5.0
    },
    {
        "testcase": "How to version a spread property (ManagedServiceIdentityProperty)?",
        "expected": "You can do it using an extension decorator [like this](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D&c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCv8Axf8Axf8Axf8Axf8AxfgAxTTxAMV95gG4QegBuusB0yDoAvXkAMhtb2RlbCBFbXBsb3llZSBpcyBUcmFja2Vk6ACCPMgcUHJvcGVydGllcz7lAekuLukApuQCm1BhcmFtZXRlcskxPjvGJuYAxGRT5gK1SWRlbnRpdHnHT3k75ACrQEBhZGRlZCjIOy5pxyYs6QJdLvQA6CnnAp%2FIOCBwxlZpZeUCnu4A3cdyxBzoAqlBZ2Ugb2YgZcg%2F5QHZYWdlPzogaW50MzI76AINQ2l0edIqY2l0eT86IHN0cuUED8csUHJvZmls01lAZW5jb2RlKCJiYXNlNjR1cmwi5AHBcMYwPzogYnl0ZXPJSFRoZSBzdGF0dXPES3RoZSBsYXN0IOQAxWF0aW9u5QQiICBAdmlzaWJpbGl0eShMaWZlY3ljbOQCQWFkx13EIOUEsVN0YXTEZ%2BUCDMwU5QGEyHPMMuUAgOUAymHpAjbFd0Bscm%2FEO3VzCnVu5AMT0VTlAWTmARrpA1PEX8hHIGNyZcQncmVxdWVzdCBoYXMgYmVlbiBhY2NlcHRlZMRnICBBxw46ICLICyLWUGnEQOQAtOkAwchE7ACcOiAizA%2FaTHVwZGF0xE%2FFQ1XHDjogIsgLyjvpBcvpAMTmANxk5wGiU3VjY2VlZOUAxckM0z%2FFNuQBTWZhaWzJPkbFDTogIsYJ3Dh3YXMgY2FuY2XKPkPHD%2BQGI8cL%2FwFAIGRlbGXpAYBExA3mAPnICyLpBF7pA3dtb3bqAcrpA3lNb3ZlUscV6ANyxHNtb3bEaGZyb20gbG9j5gC8xW7EE%2FEDUMszdG%2FPMXRvyi%2F3AJVzcG9uc%2BsE7OYAlscW7ACX7gNsxT7FZMZ85gLuzW5pbnRlcmbkB0JP6AOUcyBleHRlbmRz9ggELsspe%2BQE%2BGFybcgjyhvLWegAzeYEs2dldOQBp0HKNeQD5%2B4FceYCe09y5QKn5QHWyy9Dxx1SZXBsYWNlQXN5bmPOP%2BUC98g3Q3VzdG9tUGF0Y2hTxCoKICAg6QCTLMUO9gDnRm91buQDJuQFuMgc5gCRTeQBhMZJ0EvKEOoFqsUZPgogIOUAneYCmu8A1OUCl2VXaXRob3V0T2vzANRsaXN0QnnIMEdyb3Vwz0RMxSJQYXJlbnTUPFN1YnNjcmlw5QJ5xjvGM8wZzDnoBmAgc2FtcGzrA2ZhY8VEdGhhdOYCY%2BkGI3RvIGRpZmZl5ACE7wLmxSnuALJBxUjlAZbIdyzsA3HIDeYC6PMAkkhFQUTqBkzEfmNoZWNr6gCqZXhpc3RlbuYIJyDGHkXJFO8CWM0d7AEJfQo%3D&e=%40azure-tools%2Ftypespec-autorest&vs=%7B%7D):\n```\n/** Contoso Resource Provider management API. */\n@armProviderNamespace\n@service(#{ title: \"ContosoProviderHubClient\" })\n@versioned(Versions)\nnamespace Microsoft.ContosoProviderHub;\n/** Contoso API versions */\nenum Versions {\n/** 2021-10-01-preview version */\n@useDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)\n@armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\n`2021-10-01-preview`,\n/** 2021-10-01-preview version */\n@useDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)\n@armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\n`2024-10-01-preview`,\n}\n/** A ContosoProviderHub resource */\nmodel Employee is TrackedResource<EmployeeProperties> {\n...ResourceNameParameter<Employee>;\n...ManagedServiceIdentityProperty;\n}\n@@added(Employee.identity, Versions.`2024-10-01-preview`);\n/** Employee properties */\nmodel EmployeeProperties {\n/** Age of employee */\nage?: int32;\n/** City of employee */\ncity?: string;\n/** Profile of employee */\n@encode(\"base64url\")\nprofile?: bytes;\n/** The status of the last operation. */\n@visibility(Lifecycle.Read)\nprovisioningState?: ProvisioningState;\n}\n/** The provisioning state of a resource. */\n@lroStatus\nunion ProvisioningState {\nstring,\n/** The resource create request has been accepted */\nAccepted: \"Accepted\",\n/** The resource is being provisioned */\nProvisioning: \"Provisioning\",\n/** The resource is updating */\nUpdating: \"Updating\",\n/** Resource has been created. */\nSucceeded: \"Succeeded\",\n/** Resource creation failed. */\nFailed: \"Failed\",\n/** Resource creation was canceled. */\nCanceled: \"Canceled\",\n/** The resource is being deleted */\nDeleting: \"Deleting\",\n}\n/** Employee move request */\nmodel MoveRequest {\n/** The moving from location */\nfrom: string;\n/** The moving to location */\nto: string;\n}\n/** Employee move response */\nmodel MoveResponse {\n/** The status of the move */\nmovingStatus: string;\n}\ninterface Operations extends Azure.ResourceManager.Operations {}\n@armResourceOperations\ninterface Employees {\nget is ArmResourceRead<Employee>;\ncreateOrUpdate is ArmResourceCreateOrReplaceAsync<Employee>;\nupdate is ArmCustomPatchSync<\nEmployee,\nAzure.ResourceManager.Foundations.ResourceUpdateModel<\nEmployee,\nEmployeeProperties\n>\n>;\ndelete is ArmResourceDeleteWithoutOkAsync<Employee>;\nlistByResourceGroup is ArmResourceListByParent<Employee>;\nlistBySubscription is ArmListBySubscription<Employee>;\n/** A sample resource action that move employee to different location */\nmove is ArmResourceActionSync<Employee, MoveRequest, MoveResponse>;\n/** A sample HEAD operation to check resource existence */\ncheckExistence is ArmResourceCheckExistence<Employee>;\n}\n```",
        "actual": "To introduce the `ManagedServiceIdentityProperty` (MSI) to your resource model in a non-breaking way, you must only add it in a new API version. Adding a new property to an existing version is considered a breaking change by Azure guidelines, as clients using the old version may not expect the new field.\n\n**Correct Versioning Approach:**\n- Add the `...Azure.ResourceManager.ManagedServiceIdentityProperty;` (or `identity?: Foundations.ManagedServiceIdentity;`) property only in a new version of your model (e.g., `2025-05-04-preview`).\n- Do **not** add this property to any of your previous API versions.\n- This ensures that existing clients using previous API versions are not impacted by the new property.\n\n**TypeSpec Example:**\n\n```tsp\n// In your new versioned namespace\ndecorator @versioned(version: string);\n\n@versioned(\"2025-05-04-preview\")\nmodel MyTrackedResource extends TrackedResource {\n  // ... other properties\n  identity?: Foundations.ManagedServiceIdentity;\n}\n```\n\n**Why Not Just Add It?**\nThe Azure API Guidelines explicitly state that adding new fields to a resource schema is a breaking change and must only be done in a new API version. This is to avoid breaking existing clients who may not expect or understand the new field.\n\n**Summary:**\n- Only introduce the MSI property in your new API version.\n- Do not change existing versions.\n- This approach is in full compliance with Azure API and Resource Provider guidelines.",
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_threshold": 3.0,
        "similarity_result": "pass",
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_threshold": 3.0,
        "groundedness_result": "pass",
        "overall_score": 5.0
    },
    {
        "average_score": 4.3333333333333333,
        "total_evals": 9,
        "similarity_pass_rate": 9,
        "groundedness_pass_rate": 8
    }
]