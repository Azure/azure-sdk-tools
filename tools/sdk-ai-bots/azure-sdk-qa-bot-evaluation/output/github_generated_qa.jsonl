{"query": "title: Want to change @JsonProperty property in the java model which is being created from TypeSpec.\n\nquestion: So basically as the title suggests. I looked up some decorators docs to see if I can use those to modify what property is being set in @JsonProperty in the Java file for various fields. But the example used was of console.log. The only way I found to set some metadata to the decorators was through stateMap or stateSet which uses key. But I don't think any key is required in my scenario. Is there any way to change @JsonProperty from the field name when creating a model ?", "ground_truth": "I am not sure whether I get the question.\nI assume you are talking about a property with name e.g. \"foo\" in TypeSpec, but you want @JsonProperty(\"bar\") instead for it.\nThere is an @encodedName decorator that modifies the \"wire name\" (the name of the property in the JSON payload).\nE.g. https://github.com/Azure/typespec-azure/blob/main/packages/azure-http-specs/specs/client/naming/main.tsp#L37-L38\nIt means, when serialize/de-serialize for \"application/json\" content-type, use \"wireName\" as JSON property name, instead of \"defaultName\".\nNote that the latest version of the http-client-java emitter no longer use Jackson (hence no @JsonProperty).", "response": "Sorry, I can't answer this question. To assist you, I need more information about your TypeSpec model or the specific decorators you are using to generate the Java model. Please clarify how you are using TypeSpec to create the Java model and how you intend to modify the @JsonProperty annotations.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#typespec-client-generator-core#reference#decorators.md\n- document_title: Decorators\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\n- document_content: # libraries#typespec-client-generator-core#reference#decorators.md\n\n# Decorators\n\n## Azure.ClientGenerator.Core\n\n### `@access` {#@Azure.ClientGenerator.Core.access}\n\n|\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Set access\r\n\r\n```typespec\r\n// Access.internal\r\n@access(Access.internal)\r\nmodel ModelToHide {\r\n  prop: string;\r\n}\r\n// Access.internal\r\n@access(Access.internal)\r\nop test: void;\r\n```\r\n\r\n##### Access propagation\r\n\r\n```typespec\r\n// Access.internal\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Access.internal\r\n@discriminator(\"sharktype\")\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Access.internal\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Access.internal\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Access.internal\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n// Access.internal\r\n@get\r\n@access(Access.internal)\r\nop getModel(): Fish;\r\n```\r\n\r\n##### Access influence from operation\r\n\r\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\n\nOverride access for operations, models, enums and model property.\r\nWhen setting access for namespaces,\r\nthe access info will be propagated to the models and operations defined in the namespace.\r\nIf the model has an access override, the model override takes precedence.\r\nWhen setting access for an operation,\r\nit will influence the access info for models/enums that are used by this operation.\r\nModels/enums that are used in any operations with `@access(Access.public)` will be set to access \"public\"\r\nModels/enums that are only used in operations with `@access(Access.internal)` will be set to access \"internal\".\r\nThe access info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override access should not be narrow than the access calculated by operation,\r\nand different override access should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\nModel property's access will default to public unless there is an override.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.access(value: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty | Model | Operation | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember`     | The access info you want to set for this model or operation.                                                                                                                                           |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to.\n\n```typespec\r\n// Access.internal\r\nmodel Test1 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func1\")\r\nop func1(@body body: Test1): void;\r\n\r\n// Access.public\r\nmodel Test2 {}\r\n\r\n// Access.public\r\n@route(\"/func2\")\r\nop func2(@body body: Test2): void;\r\n\r\n// Access.public\r\nmodel Test3 {}\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func3\")\r\nop func3(@body body: Test3): void;\r\n\r\n// Access.public\r\nmodel Test4 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func4\")\r\nop func4(@body body: Test4): void;\r\n\r\n// Access.public\r\n@route(\"/func5\")\r\nop func5(@body body: Test4): void;\r\n\r\n// Access.public\r\nmodel Test5 {}\r\n\r\n// Access.internal\r\n@access(Access.internal)\r\n@route(\"/func6\")\r\nop func6(@body body: Test5): void;\r\n\r\n// Access.public\r\n@route(\"/func7\")\r\nop func7(@body body: Test5): void;\r\n\r\n// Access.public\r\n@access(Access.public)\r\n@route(\"/func8\")\r\nop func8(@body body: Test5): void;\r\n```\n\n### `@alternateType` {#@Azure.ClientGenerator.Core.alternateType}\n\nSet an alternate type for a model property, Scalar, or function parameter. Note that `@encode` will be overridden by the one defined in alternate type.\r\nWhen the source type is `Scalar`, the alternate type must be `Scalar`.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.alternateType(alternate: unknown, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\nThe source type to which the alternate type will be applied.\r\n`ModelProperty | Scalar`\r\n\r\n#### Parameters\r\n\r\n| Name      | Type             | Description                                                                                                                                                                                            |\r\n| --------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| alternate | `unknown`        | The alternate type to apply to the target.                                                                                                                                                             |\r\n| scope     | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  date: utcDateTime;\r\n}\r\n@@alternateType(Foo.date, string);\r\n```\r\n\r\n```typespec\r\nscalar storageDateTime extends utcDataTime;\r\n@@alternateType(storageDateTime, string, \"python\");\r\n```\r\n\r\n```typespec\r\nop test(@param @alternateType(string) date: utcDateTime): void;\r\n```\r\n\r\n```typespec\r\nmodel Test {\r\n  @alternateType(unknown)\r\n  thumbprint?: string;\r\n\r\n  @alternateType(AzureLocation[], \"csharp\")\r\n  locations: string[];\r\n}\r\n```\n\n### `@apiVersion` {#@Azure.ClientGenerator.Core.apiVersion}\n\nUse to override default assumptions on whether a parameter is an api-version parameter or not.\r\nBy default, we do matches with the `api-version` or `apiversion` string in the parameter name. Since api versions are\r\na client parameter, we will also elevate this parameter up onto the client.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.apiVersion(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | If true, we will treat this parameter as an api-version parameter. If false, we will not. Default is true.                                                                                             |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nnamespace Contoso;\r\n\r\nop test(\r\n  @apiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\n\n### `@client` {#@Azure.ClientGenerator.Core.client}\n\nCreate a ClientGenerator.Core client out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.client(value?: Model, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `Model`          | Optional configuration for the service.                                                                                                                                                                |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Basic client setting\r\n\r\n```typespec\r\n@client\r\nnamespace MyService {\r\n\r\n}\r\n```\r\n\r\n##### Setting with other service\r\n\r\n```typespec\r\nnamespace MyService {\r\n\r\n}\r\n\r\n@client({\r\n  service: MyService,\r\n})\r\ninterface MyInterface {}\r\n```\r\n\r\n##### Changing client name if you don't want <Interface/Namespace>Client\r\n\r\n```typespec\r\n@client({\r\n  client: MySpecialClient,\r\n})\r\ninterface MyInterface {}\r\n```\n\n### `@clientApiVersions` {#@Azure.ClientGenerator.Core.clientApiVersions}\n\nSpecify additional API versions that the client can support. These versions should include those defined by the service's versioning configuration.\r\nThis decorator is useful for extending the API version enum exposed by the client.\r\nIt is particularly beneficial when generating a complete API version enum without requiring the entire specification to be annotated with versioning decorators, as the generation process does not depend on versioning details.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientApiVersions(value: Enum, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| value | `Enum`           |             |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\n@versioned(Versions)\r\nnamespace Contoso {\r\n  enum Versions {\r\n    v4,\r\n    v5,\r\n  }\r\n}\r\n\r\n// client.tsp\r\n\r\nenum ClientApiVersions {\r\n  v1,\r\n  v2,\r\n  v3,\r\n  ...Contoso.Versions,\r\n}\r\n\r\n@@clientApiVersions(Contoso, ClientApiVersions);\r\n```\n\n### `@clientDoc` {#@Azure.ClientGenerator.Core.clientDoc}\n\nOverride documentation for a type in client libraries. This allows you to\r\nprovide client-specific documentation that differs from the service-definition documentation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientDoc(documentation: valueof string, mode: EnumMember, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name          | Type             | Description                                                                                                                                                                                            |\r\n| ------------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| documentation | `valueof string` | The client-specific documentation to apply                                                                                                                                                             |\r\n| mode          | `EnumMember`     | Specifies how to apply the documentation (append or replace)                                                                                                                                           |\r\n| scope         | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n\nnegation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Replacing documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"This is client-specific documentation\", DocumentationMode.replace)\r\nop myOperation(): void;\r\n```\r\n\r\n##### Appending documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation.\")\r\n@clientDoc(\"This additional note is for client libraries only.\", DocumentationMode.append)\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Language-specific documentation\r\n\r\n```typespec\r\n@doc(\"This is service documentation\")\r\n@clientDoc(\"Python-specific documentation\", DocumentationMode.replace, \"python\")\r\n@clientDoc(\"JavaScript-specific documentation\", DocumentationMode.replace, \"javascript\")\r\nop myOperation(): void;\r\n```\n\n### `@clientInitialization` {#@Azure.ClientGenerator.Core.clientInitialization}\n\nCustomize the client initialization way.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientInitialization(options: Azure.ClientGenerator.Core.ClientInitializationOptions, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                                                    | Description                                                                                                                                                                                            |\r\n| ------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| options | [`ClientInitializationOptions`](./data-types.md#Azure.ClientGenerator.Core.ClientInitializationOptions) |                                                                                                                                                                                                        |\r\n| scope   | `valueof string`                                                                                        | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\n\n/>You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\nop download(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blobName: string;\r\n}\r\n\r\n@@clientInitialization(MyService, {parameters: MyServiceClientOptions})\r\n// The generated client will have `blobName` on its initialization method. We will also\r\n// elevate the existing `blobName` parameter from method level to client level.\r\n```\n\n### `@clientName` {#@Azure.ClientGenerator.Core.clientName}\n\nChanges the name of a method, parameter, property, or model generated in the client SDK\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientName(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientName(\"nameInClient\")\r\nop nameInService: void;\r\n```\r\n\r\n```typespec\r\n@clientName(\"nameForJava\", \"java\")\r\n@clientName(\"name_for_python\", \"python\")\r\n@clientName(\"nameForCsharp\", \"csharp\")\r\n@clientName(\"nameForJavascript\", \"javascript\")\r\nop nameInService: void;\r\n```\n\n### `@clientNamespace` {#@Azure.ClientGenerator.Core.clientNamespace}\n\nChanges the namespace of a client, model, enum or union generated in the client SDK.\r\nBy default, the client namespace for them will follow the TypeSpec namespace.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.clientNamespace(rename: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Model | Enum | Union`\r\n\r\n#### Parameters\r\n\r\n| Name   | Type             | Description                                                                                                                                                                                            |\r\n| ------ | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| rename | `valueof string` | The rename you want applied to the object                                                                                                                                                              |\r\n| scope  | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoClient\")\r\nnamespace Contoso;\r\n```\r\n\r\n```typespec\r\n@clientNamespace(\"ContosoJava\", \"java\")\r\n@clientNamespace(\"ContosoPython\", \"python\")\r\n@clientNamespace(\"ContosoCSharp\", \"csharp\")\r\n@clientNamespace(\"ContosoJavascript\", \"javascript\")\r\nnamespace Contoso;\r\n```\n\n### `@convenientAPI` {#@Azure.ClientGenerator.Core.convenientAPI}\n\nWhether you want to generate an operation as a convenient operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.convenientAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as convenience method or not.                                                                                                                                        |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@convenientAPI(false)\r\nop test: void;\r\n```\n\n### `@deserializeEmptyStringAsNull` {#@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull}\n\nIndicates that a model property of type `string` or a `Scalar` type derived from `string` should be deserialized as `null` when its value is an empty string (`\"\"`).\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.deserializeEmptyStringAsNull(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n\r\nmodel MyModel {\r\n  scalar stringlike extends string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: string;\r\n\r\n  @deserializeEmptyStringAsNull\r\n  prop: stringlike;\r\n}\r\n```\n\n### `@flattenProperty` {#@Azure.ClientGenerator.Core.flattenProperty}\n\n:::caution\r\n**Deprecated**: @flattenProperty decorator is not recommended to use.\r\n:::\r\n\r\nSet whether a model property should be flattened or not.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.flattenProperty(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo {\r\n  @flattenProperty\r\n  prop: Bar;\r\n}\r\nmodel Bar {}\r\n```\n\n### `@operationGroup` {#@Azure.ClientGenerator.Core.operationGroup}\n\nCreate a ClientGenerator.Core operation group out of a namespace or interface\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.operationGroup(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationGroup\r\ninterface MyInterface {}\r\n```\n\n### `@override` {#@Azure.ClientGenerator.Core.override}\n\nMyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization, \"csharp\")\r\n\r\n// method signature is now `op myOperation(params: Params)` just for csharp\r\n```\n\nOverride the default client method generated by TCGC from your service definition\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.override(override: Operation, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n: The original service definition\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name     | Type             | Description                                                                                                                                                                                            |\r\n| -------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| override | `Operation`      | : The override method definition that specifies the exact client method you want                                                                                                                       |\r\n| scope    | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\n\r\nop myOperationCustomization(params: MyService.Params): void;\r\n\r\n@@override(MyService.myOperation, myOperationCustomization);\r\n\r\n// method signature is now `op myOperation(params: Params)`\r\n```\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nmodel Params {\r\n foo: string;\r\n bar: string;\r\n}\r\nop myOperation(...Params): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\n\n### `@paramAlias` {#@Azure.ClientGenerator.Core.paramAlias}\n\nAlias the name of a client parameter to a different name. This permits you to have a different name for the parameter in client initialization then on individual methods and still refer to the same parameter.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.paramAlias(paramAlias: valueof string, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name       | Type             | Description                                                                                                                                                                                            |\r\n| ---------- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| paramAlias | `valueof string` |                                                                                                                                                                                                        |\r\n| scope      | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n// main.tsp\r\nnamespace MyService;\r\n\r\nop upload(blobName: string): void;\r\n\r\n// client.tsp\r\nnamespace MyCustomizations;\r\nmodel MyServiceClientOptions {\r\n  blob: string;\r\n}\r\n\r\n@@clientInitialization(MyService, MyServiceClientOptions)\r\n@@paramAlias(MyServiceClientOptions.blob, \"blobName\")\r\n\r\n// The generated client will have `blobName` on it. We will also\r\n// elevate the existing `blob` parameter to the client level.\r\n```\n\n### `@protocolAPI` {#@Azure.ClientGenerator.Core.protocolAPI}\n\nWhether you want to generate an operation as a protocol operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.protocolAPI(value?: valueof boolean, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description                                                                                                                                                                                            |\r\n| ----- | ----------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `valueof boolean` | Whether to generate the operation as protocol or not.                                                                                                                                                  |\r\n| scope | `valueof string`  | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@protocolAPI(false)\r\nop test: void;\r\n```\n\n### `@responseAsBool` {#@Azure.ClientGenerator.Core.responseAsBool}\n\nIndicates that a HEAD operation should be modeled as Response<bool>. 404 will not raise an error, instead the service method will return `false`. 2xx will return `true`. Everything else will still raise an error.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.responseAsBool(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description |\r\n| ----- | ---------------- | ----------- |\r\n| scope | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@responseAsBool\r\n@head\r\nop headOperation(): void;\r\n```\n\n### `@scope` {#@Azure.ClientGenerator.Core.scope}\n\nTo define the client scope of an operation.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.scope(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@scope(\"!csharp\")\r\nop test: void;\r\n```\n\n### `@usage` {#@Azure.ClientGenerator.Core.usage}\n\nOverride usage for models/enums.\r\nA model/enum's default usage info is always calculated by the operations that use it.\r\nYou could use this decorator to override the default usage info.\r\nWhen setting usage for namespaces,\r\nthe usage info will be propagated to the models defined in the namespace.\r\nIf the model has an usage override, the model override takes precedence.\r\nFor example, with operation definition `op test(): OutputModel`,\r\nthe model `OutputModel` has default usage `Usage.output`.\r\nAfter adding decorator `@@usage(OutputModel, Usage.input | Usage.output)`,\r\nthe final usage result for `OutputModel` is `Usage.input | Usage.output`.\r\nThe usage info for models will be propagated to models' properties,\r\nparent models, discriminated sub models.\r\nThe override usage should not be narrow than the usage calculated by operation,\r\nand different override usage should not conflict with each other,\r\notherwise a warning will be added to diagnostics list.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.usage(value: EnumMember | Union, scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model | Enum | Union | Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type                  | Description                                                                                                                                                                                            |\r\n| ----- | --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to.\n\n|\r\n| value | `EnumMember \\| Union` | The usage info you want to set for this model.                                                                                                                                                         |\r\n| scope | `valueof string`      | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n##### Expand usage for model\r\n\r\n```typespec\r\nop test(): OutputModel;\r\n\r\n// usage result for `OutputModel` is `Usage.input | Usage.output`\r\n@usage(Usage.input)\r\nmodel OutputModel {\r\n  prop: string;\r\n}\r\n```\r\n\r\n##### Propagation of usage\r\n\r\n```typespec\r\n// Usage.output\r\n@discriminator(\"kind\")\r\nmodel Fish {\r\n  age: int32;\r\n}\r\n\r\n// Usage.input | Usage.output\r\n@discriminator(\"sharktype\")\r\n@usage(Usage.input)\r\nmodel Shark extends Fish {\r\n  kind: \"shark\";\r\n  origin: Origin;\r\n}\r\n\r\n// Usage.output\r\nmodel Salmon extends Fish {\r\n  kind: \"salmon\";\r\n}\r\n\r\n// Usage.output\r\nmodel SawShark extends Shark {\r\n  sharktype: \"saw\";\r\n}\r\n\r\n// Usage.output\r\nmodel Origin {\r\n  country: string;\r\n  city: string;\r\n  manufacture: string;\r\n}\r\n\r\n@get\r\nop getModel(): Fish;\r\n```\n\n### `@useSystemTextJsonConverter` {#@Azure.ClientGenerator.Core.useSystemTextJsonConverter}\n\nWhether a model needs the custom JSON converter, this is only used for backward compatibility for csharp.\r\n\r\n```typespec\r\n@Azure.ClientGenerator.Core.useSystemTextJsonConverter(scope?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type             | Description                                                                                                                                                                                            |\r\n| ----- | ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\r\n| scope | `valueof string` | The language scope you want this decorator to apply to. If not specified, will apply to all language emitters.<br />You can use \"!\" to specify negation such as \"!(java, python)\" or \"!java, !python\". |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@useSystemTextJsonConverter\r\nmodel MyModel {\r\n  prop: string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#code-generation-javascript.md\n- document_title: Code Generation - JavaScript\n- document_link: https://typespec.io/docs/getting-started/code-generation-javascript\n- document_content: # getting-started#code-generation-javascript.md\n\n# Code Generation - JavaScript\n\n<!-- cspell:ignore myproject -->\n\n# Getting started with TypeSpec server code generation for JavaScript\n\nTypeSpec's code generation capabilities allow you to rapidly build a working API service starting from a TypeSpec definition. This guide walks you through the entire process, from installation to creating and customizing your generated service using the JavaScript server emitter.\n\n## Prerequisites\n\n- Node.js and NPM (required for both TypeSpec and JavaScript server code generation)\r\n- Basic familiarity with TypeSpec\r\n- Basic knowledge of JavaScript/TypeScript and Express.js\n\n## 1. Installing TypeSpec\n\n```bash\r\nnpm install -g @typespec/compiler@latest\r\n```\r\n\r\nThis installs the TypeSpec compiler globally on your system, making the `tsp` command available.\n\n## 2. Creating a TypeSpec project\n\n1. Create and navigate to your project directory:\r\n\r\n```bash\r\nmkdir myproject\r\ncd myproject\r\n```\r\n\r\n2. Initialize a new TypeSpec project:\r\n\r\n```bash\r\ntsp init\r\n```\r\n\r\n3. Select the appropriate template when prompted:\r\n\r\n   - Choose \"Generic REST API\" to create a standard REST API\r\n   - Enter a project name or accept the default\r\n   - Select \"JavaScript Server Stubs\" from the emitter options\r\n\r\n4. After initialization completes, your project structure will include:\r\n\r\n   - `main.tsp` - Your TypeSpec definition file with a sample service\r\n   - `tspconfig.yaml` - Configuration for your emitters\r\n   - `package.json` - Project dependencies\n\n## 3. Understanding the default TypeSpec service\n\nThe `main.tsp` file contains a default \"Widget Service\" example that defines:\r\n\r\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing TypeSpec.Http;\r\n@service(#{ title: \"Widget Service\" })\r\nnamespace DemoService;\r\n\r\nmodel Widget {\r\n  id: string;\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\nmodel WidgetList {\r\n  items: Widget[];\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\nmodel AnalyzeResult {\r\n  id: string;\r\n  analysis: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  /** List widgets */\r\n  @get list(): WidgetList | Error;\r\n  /** Read widgets */\r\n  @get read(@path id: string): Widget | Error;\r\n  /** Create a widget */\r\n  @post create(@body body: Widget): Widget | Error;\r\n  /** Update a widget */\r\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\r\n  /** Delete a widget */\r\n  @delete delete(@path id: string): void | Error;\r\n\r\n  /** Analyze a widget */\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): AnalyzeResult | Error;\r\n}\r\n```\r\n\r\nThis defines:\r\n\r\n- A `Widget` model with properties for id, weight, and color\r\n- A REST API with standard CRUD operations (list, read, create, update, delete)\r\n- A special `analyze` operation for widgets\r\n\r\nThe `tspconfig.yaml` file configures your emitters:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/openapi3\"\r\n  - \"@typespec/http-server-js\"\r\noptions:\r\n  \"@typespec/openapi3\":\r\n    emitter-output-dir: \"{output-dir}/schema\"\r\n    openapi-versions:\r\n      - 3.1.0\r\n  \"@typespec/http-server-js\":\r\n    emitter-output-dir: \"{output-dir}/server/generated\"\r\n```\r\n\r\nThis configuration:\r\n\r\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\r\n- Generates JavaScript server code in the `tsp-output/server/generated` directory\n\n## 4. Scaffolding your service\n\nThe next step is to generate the server code from your TypeSpec definition. This process is called \"scaffolding\".\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nThe console will display information about what it generated and where it placed the files, including:\r\n\r\n- The location of your generated project\r\n- How to run the project\r\n\r\nWhen scaffolding is finished, you'll see output similar to the following:\r\n\r\n```\r\n[hsjs] Project is ready to run. Use `npm start` to launch the server.\r\n[hsjs] A debug configuration has been created for Visual Studio Code.\r\n[hsjs] Try `code tsp-output/server/generated` to open the project and press F5 to start debugging.\r\n[hsjs] The newly-generated route controllers in 'tsp-output/server/generated/src/controllers' are ready to be implemented.\r\n[hsjs] Done.\r\n```\n\n## 5. Running your service\n\nNavigate to your generated project directory and start the server:\r\n\r\n```bash\r\ncd tsp-output/server/generated\r\nnpm run start\r\n```\r\n\r\nOnce the server is up and running, you can access the Swagger UI by navigating to `http://localhost:3000/.api-docs` in your browser.\r\n\r\nYou should see a Swagger UI interface that lists all the available API endpoints, allowing you to test them directly from your browser:\r\n\r\n![Swagger UI Example](../images/swaggerui-screenshot.png)\r\n\r\nThis UI allows you to:\r\n\r\n- View all available API endpoints\r\n- Test API operations directly\r\n- See request and response formats\n\n## 6. Understanding the generated code\n\nThe generated code is organized into two main categories:\n\n### Regenerated implementation (don't modify directly)\n\nLocated in the `src/generated` directory, these files will be regenerated whenever you recompile your TypeSpec definition. If you modify these files, your modifications will be overwritten every time you run `tsp compile`. Your code may need to import and use methods or types from these files, but **do not** modify them as your modifications will not be preserved.\r\n\r\n- **Helpers**: Located in `src/generated/helpers`, these files contain common implementation used by the generated code.\r\n\r\n  - Example: `helpers/router.ts` contains common types and implementation for the generated router.\r\n  - Your code may need to import and use methods/types from these helpers, but you never need to modify them.\r\n\r\n- **HTTP Infrastructure**: Located in `src/generated/http`, these files define the HTTP implementation layer for the server.\r\n\r\n  - Example: `http/router.ts` contains the implementation of the service router that dispatches requests to the route handlers.\r\n  - Example: `http/operations/server-raw.ts` contains the individual route handlers that handle parsing types from requests and serializing them to responses.\r\n  - These files handle the HTTP infrastructure. Your code will create an instance of the router in `http/router.ts`, but otherwise does not need to interact with this code directly.\r\n\r\n- **Data Models and Operation Interfaces**: Located in `src/generated/models`, these files define the data types that represent the API types defined in the TypeSpec specification.\r\n\r\n  - Example: `models/all/demo-service.ts` contains the interfaces that represent the `Widget` data type and the `Widgets` operations interface.\r\n  - Your code will import and use these types to define implementations of the route controllers that define the business logic of your service.\n\n### User implementation\n\nThese files are not regenerated automatically when your specification is recompiled. They are generated once by the scaffolding tool, but the scaffolding tool will not overwrite them if they already exist because they are intended to be modified according to your needs. If you want to regenerate a scaffolded file that is in this category, you must delete it first, and then the scaffolding tool will replace it the next time it is run.\r\n\r\nThese files are all located in the output directory `tsp-output/server/generated`, but none of them are located within the `src/generated` folder of the emitter output directory.\r\n\r\n- **Project files**: these files define the structure of the project, its dependencies, and build scripts\r\n\r\n  - Examples: `package.json`, `tsconfig.json`, `.vscode/` which all define the project structure.\r\n  - You can customize these files to your liking, for example by adding new dependencies or changing TypeScript config settings.\r\n\r\n- **Route controllers**: Implementations of the operation interfaces that define the business logic layer.\r\n\r\n  - Example: `src/controllers/widgets.ts` contains the scaffolded implementation of the `Widgets` interface.\r\n  - These controllers are passed in to the router and define the business logic of your app.\r\n  - The scaffolding system generates \"mock\" implementations that either return made-up values or throw `NotImplementedError`.\r\n  - These files **are not overwritten** when you recompile, so you can edit them to add the correct logic for your service.\r\n\r\n- **Server entrypoint**: Located in `src/index.ts`, this file defines the entrypoint of the server process.\r\n\r\n  - This file creates an Express app and an instance of the generated router, then binds them together and starts the Express app.\r\n  - You can change this file to add middleware, custom routes, etc. to the express app as needed.\n\n## 7. Understanding the middleware and routing system\n\nThe generated JavaScript server uses a router that provides an Express.js middleware. It is added to the express app with `app.use(router.expressMiddleware)`. The generated router is created with instances of the route controllers, and Express will call the router as part of its middleware chain:\r\n\r\n1. Express receives a request and passes it through the middleware chain.\r\n2. When/if the generated router middleware is reached, it checks if the request matches one of its routes. If it does, it processes the request and then calls your business logic implementation defined by the route controller in `src/controllers` that was passed to the router when it was created.\r\n3. If the route does not match, the router sends the request to the next middleware in the chain.\r\n\r\nThe router is bound to the Express app in `src/index.ts` by the scaffolded server code. The entrypoint file:\r\n\r\n- Sets up Express middleware (SwaggerUI, logging, etc.).\r\n- Adds the router middleware.\r\n- Binds the app to a Node HTTP server and listens for incoming requests.\r\n\r\nYou can customize the entrypoint to add your own middleware, custom routes, etc.\n\n## 8. Adding your business logic\n\n1. Locate the route controller implementation files for your service (e.g., `tsp-output/server/generated/src/controllers/widgets.ts`).\r\n\r\n2. Update the implementation methods with your actual business logic. For example:\r\n\r\n```javascript\r\n// Replace the mock implementation with your actual business logic\r\nasync list(ctx: HttpContext): Promise<WidgetList | Error> {\r\n  // In a real application, you would call a database or execute some logic to construct the correct response.\r\n  return {\r\n    items: [\r\n      {\r\n        id: \"mock-string\",\r\n        weight: 42,\r\n        color: \"red\",\r\n      }\r\n    ],\r\n  };\r\n}\r\n```\r\n\r\n3. The implementation file won't be overwritten when you recompile your TypeSpec, preserving your business logic.\n\n## 9. Evolving your API\n\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\r\n\r\n1. Modify your TypeSpec definition (e.g., add new models or operations)\r\n\r\n2. Recompile to update the generated code:\r\n\r\n```bash\r\ntsp compile .\r\n```\r\n\r\nThis updates the generated files (routes, interfaces, models) but preserves your implementation files.\r\n\r\n3. If you've added entirely new resources that require new implementation files:\r\n\r\n```bash\r\nnpx hsjs-scaffold\r\n```\r\n\r\nRunning the scaffolding command again will create any new files that don't already exist, but won't update files that you may have modified.\r\n\r\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\r\n\r\n```typespec\r\n@route(\"/categories\")\r\n@tag(\"Categories\")\r\ninterface Categories {\r\n  /** List categories */\r\n  @get list(): CategoryList | Error;\r\n  // More operations...\r\n}\r\n```\r\n\r\nWhen you run the scaffolding step again:\r\n\r\n- It will create new files for the new `Categories` interface (`src/controllers/categories.ts`).\r\n- It won't overwrite your existing `widgets.ts` with your custom business logic.\r\n- This allows you to incrementally add new resources without losing your existing implementations.\r\n\r\nNOTE: You will need to either delete the entrypoint `src/index.ts` and allow it to be scaffolded again (which will overwrite any modifications you have made to the entrypoint) or modify it to add an instance of the `Categories` controller to the router, otherwise the router will be missing an implementation of `Categories`!\n\n## Next steps\n\n- Add authentication middleware to your service\r\n- Implement data validation and error handling\r\n- Connect your implementation to a database (like MongoDB, PostgreSQL, etc.)\r\n- Deploy your service to a cloud provider\n\n## Additional resources\n\n- [TypeSpec Documentation](https://typespec.io/docs/)\r\n- [TypeSpec Community](https://typespec.io/community/)\r\n- [GitHub Repository](https://github.com/microsoft/typespec)\r\n- [Express.js Documentation](https://expressjs.com/)\n", "latency": 5.6512086391448975, "response_length": 297}
{"query": "title: Any plans to support description and external docs for the tag decorator?\n\nquestion: I've been using Redoc to render an OpenApi spec, and it would be nice if typespec could output the additional tag properties to the generated spec.\nCurrently, the tag decorator accepts only a `string`, but OAS 3 supports `description` and `externalDocs` in the root tag array (both are optional).\nAre there any plans to support those properties? I noticed the decorator is exported from the standard library, so it may have other use cases I'm unaware of, but it would be a nice addition for this specific use case.", "ground_truth": "We have an issue [#2220](https://github.com/microsoft/typespec/issues/2220). I believe someone was going to work on it soon.", "response": "Yes, TypeSpec supports adding `description` and `externalDocs` to tags in the OpenAPI specification using the `@tagMetadata` decorator. This decorator allows you to specify additional metadata for tags, including a description and external documentation. Here's an example:\n\n```typespec\n@service\n@tagMetadata(\n  \"Tag Name\",\n  #{\n    description: \"Tag description\",\n    externalDocs: #{ url: \"https://example.com\", description: \"More info.\" },\n    `x-custom`: \"string\",\n  }\n)\nnamespace PetStore {\n}\n```\n\nThis will generate the corresponding OpenAPI tag metadata with the `description` and `externalDocs` properties. You can use this feature to enhance the tags in your OpenAPI specification for better documentation and usability.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#openapi#reference#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/libraries/openapi/reference/decorators\n- document_content: # libraries#openapi#reference#decorators.md\n\n# Decorators\n\n## TypeSpec.OpenAPI\n\n### `@defaultResponse` {#@TypeSpec.OpenAPI.defaultResponse}\n\nSpecify that this model is to be treated as the OpenAPI `default` response.\r\nThis differs from the compiler built-in `@error` decorator as this does not necessarily represent an error.\r\n\r\n```typespec\r\n@TypeSpec.OpenAPI.defaultResponse\r\n```\r\n\r\n#### Target\r\n\r\n`Model`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@defaultResponse\r\nmodel PetStoreResponse is object;\r\n\r\nop listPets(): Pet[] | PetStoreResponse;\r\n```\n\n### `@extension` {#@TypeSpec.OpenAPI.extension}\n\nAttach some custom data to the OpenAPI element generated from this type.\r\n\r\n```typespec\r\n@TypeSpec.OpenAPI.extension(key: valueof string, value: valueof unknown)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name  | Type              | Description      |\r\n| ----- | ----------------- | ---------------- |\r\n| key   | `valueof string`  | Extension key.   |\r\n| value | `valueof unknown` | Extension value. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@extension(\"x-custom\", \"My value\")\r\n@extension(\"x-pageable\", #{ nextLink: \"x-next-link\" })\r\nop read(): string;\r\n```\n\n### `@externalDocs` {#@TypeSpec.OpenAPI.externalDocs}\n\nSpecify the OpenAPI `externalDocs` property for this type.\r\n\r\n```typespec\r\n@TypeSpec.OpenAPI.externalDocs(url: valueof string, description?: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`unknown`\r\n\r\n#### Parameters\r\n\r\n| Name        | Type             | Description             |\r\n| ----------- | ---------------- | ----------------------- |\r\n| url         | `valueof string` | Url to the docs         |\r\n| description | `valueof string` | Description of the docs |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@externalDocs(\r\n  \"https://example.com/detailed.md\",\r\n  \"Detailed information on how to use this operation\"\r\n)\r\nop listPets(): Pet[];\r\n```\n\n### `@info` {#@TypeSpec.OpenAPI.info}\n\nSpecify OpenAPI additional information.\r\nThe service `title` and `version` are already specified using `@service`.\r\n\r\n```typespec\r\n@TypeSpec.OpenAPI.info(additionalInfo: valueof TypeSpec.OpenAPI.AdditionalInfo)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name           | Type                                                                        | Description            |\r\n| -------------- | --------------------------------------------------------------------------- | ---------------------- |\r\n| additionalInfo | [valueof `AdditionalInfo`](./data-types.md#TypeSpec.OpenAPI.AdditionalInfo) | Additional information |\n\n### `@operationId` {#@TypeSpec.OpenAPI.operationId}\n\nSpecify the OpenAPI `operationId` property for this operation.\r\n\r\n```typespec\r\n@TypeSpec.OpenAPI.operationId(operationId: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name        | Type             | Description         |\r\n| ----------- | ---------------- | ------------------- |\r\n| operationId | `valueof string` | Operation id value. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@operationId(\"download\")\r\nop read(): string;\r\n```\n\n### `@tagMetadata` {#@TypeSpec.OpenAPI.tagMetadata}\n\nSpecify OpenAPI additional information.\r\n\r\n```typespec\r\n@TypeSpec.OpenAPI.tagMetadata(name: valueof string, tagMetadata: valueof TypeSpec.OpenAPI.TagMetadata)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name        | Type                                                                  | Description            |\r\n| ----------- | --------------------------------------------------------------------- | ---------------------- |\r\n| name        | `valueof string`                                                      | tag name               |\r\n| tagMetadata | [valueof `TagMetadata`](./data-types.md#TypeSpec.OpenAPI.TagMetadata) | Additional information |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\n@tagMetadata(\r\n  \"Tag Name\",\r\n  #{\r\n    description: \"Tag description\",\r\n    externalDocs: #{ url: \"https://example.com\", description: \"More info.\", `x-custom`: \"string\" },\r\n    `x-custom`: \"string\",\r\n  }\r\n)\r\nnamespace PetStore {\r\n\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#openapi#reference#data-types.md\n- document_title: Data types\n- document_link: https://typespec.io/docs/libraries/openapi/reference/data-types\n- document_content: # libraries#openapi#reference#data-types.md\n\n# Data types\n\n## TypeSpec.OpenAPI\n\n### `AdditionalInfo` {#TypeSpec.OpenAPI.AdditionalInfo}\n\nAPI.                                                                                      |\r\n| license?        | [`License`](./data-types.md#TypeSpec.OpenAPI.License) | The license information for the exposed API.                                                                                      |\r\n|                 | `unknown`                                             | Additional properties                                                                                                             |\n\nAdditional information for the OpenAPI document.\r\n\r\n```typespec\r\nmodel TypeSpec.OpenAPI.AdditionalInfo\r\n```\r\n\r\n#### Properties\r\n\r\n| Name            | Type                                                  | Description                                                                                                                       |\r\n| --------------- | ----------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |\r\n| title?          | `string`                                              | The title of the API. Overrides the `@service` title.                                                                             |\r\n| summary?        | `string`                                              | A short summary of the API. Overrides the `@summary` provided on the service namespace.                                           |\r\n| version?        | `string`                                              | The version of the OpenAPI document (which is distinct from the OpenAPI Specification version or the API implementation version). |\r\n| termsOfService? | `url`                                                 | A URL to the Terms of Service for the API. MUST be in the format of a URL.                                                        |\r\n| contact?        | [`Contact`](./data-types.md#TypeSpec.OpenAPI.Contact) | The contact information for the exposed API.                                                                                      |\r\n| license?        | [`License`](./data-types.md#TypeSpec.OpenAPI.License) | The license information for the exposed API.                                                                                      |\r\n|                 | `unknown`                                             | Additional properties\n\n### `Contact` {#TypeSpec.OpenAPI.Contact}\n\nContact information for the exposed API.\r\n\r\n```typespec\r\nmodel TypeSpec.OpenAPI.Contact\r\n```\r\n\r\n#### Properties\r\n\r\n| Name   | Type      | Description                                                                                      |\r\n| ------ | --------- | ------------------------------------------------------------------------------------------------ |\r\n| name?  | `string`  | The identifying name of the contact person/organization.                                         |\r\n| url?   | `url`     | The URL pointing to the contact information. MUST be in the format of a URL.                     |\r\n| email? | `string`  | The email address of the contact person/organization. MUST be in the format of an email address. |\r\n|        | `unknown` | Additional properties                                                                            |\n\n### `ExternalDocs` {#TypeSpec.OpenAPI.ExternalDocs}\n\nExternal Docs information.\r\n\r\n```typespec\r\nmodel TypeSpec.OpenAPI.ExternalDocs\r\n```\r\n\r\n#### Properties\r\n\r\n| Name         | Type      | Description           |\r\n| ------------ | --------- | --------------------- |\r\n| url          | `string`  | Documentation url     |\r\n| description? | `string`  | Optional description  |\r\n|              | `unknown` | Additional properties |\n\n### `License` {#TypeSpec.OpenAPI.License}\n\nLicense information for the exposed API.\r\n\r\n```typespec\r\nmodel TypeSpec.OpenAPI.License\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type      | Description                                                            |\r\n| ---- | --------- | ---------------------------------------------------------------------- |\r\n| name | `string`  | The license name used for the API.                                     |\r\n| url? | `url`     | A URL to the license used for the API. MUST be in the format of a URL. |\r\n|      | `unknown` | Additional properties                                                  |\n\n### `TagMetadata` {#TypeSpec.OpenAPI.TagMetadata}\n\nMetadata to a single tag that is used by operations.\r\n\r\n```typespec\r\nmodel TypeSpec.OpenAPI.TagMetadata\r\n```\r\n\r\n#### Properties\r\n\r\n| Name          | Type                                                            | Description                              |\r\n| ------------- | --------------------------------------------------------------- | ---------------------------------------- |\r\n| description?  | `string`                                                        | A description of the API.                |\r\n| externalDocs? | [`ExternalDocs`](./data-types.md#TypeSpec.OpenAPI.ExternalDocs) | An external Docs information of the API. |\r\n|               | `unknown`                                                       | Additional properties                    |\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n", "latency": 15.181089162826538, "response_length": 729}
{"query": "title: Better example tooling\n\nquestion: Many API developer portals (such as [readme.com](https://readme.com/)) make heavy use of examples, and it's a huge boon to have compile-type checking on them. But writing them is a bit hard.\nI can think of two main places examples can come from:\nPayload first: you already have some JSON (for example, if you're documenting an existing API) and you want to make sure your TypeSpec definition conforms.\nIn this case, the migration from e.g. `{\"my array\": []}` to `#{`my array`: #[]}` makes this super tedious in bulk (see [Value blocks for simplifying defining nested values #3931](https://github.com/microsoft/typespec/discussions/3931)). It would be a huge help if there was a CLI command that could take arbitrary JSON and spit out equivalent \"value\"s.\nModel first: you have a TypeSpec model and are trying to write a definition for it. Unfortunately, there is no templating of the example decorator, so while there is realtime method validation, intellisense gives you no help (asides from general string matching) in defining the example:\n![alt text](image.png)\nIt would be great if the type of @example : example could be an inferred T instead of just unknown.\nAnd even after you have examples, the differing tooltip and error messages between different ways of specifying an example is really confusing and sometimes incredibly verbose [[Playground]](https://typespec.io/playground?c=Y29uc3QgZm9vZ29vZDEgOiBGb28gPSAje0JhcjrFB3o6ICLFHSJ9fTsNCs0xMiA6IMQqxjhCYXJ91jwy0zwz1iszzytiYfUAl2TFMcQd0jD%2FAJbJO%2FAAlmJh7wCVySrnAJUNCkBleGFtcGxlKOgBMinSFDLTFDPMFPMA9jTEYc845ADd0hPQXuQAntZd6QC%2ByF1tb2RlbOUBSnsNCiAg7AEiOw0KfcshxBvHJHogOiBzdHJpbmfEJA%3D%3D&e=%40typespec%2Fopenapi3&options=%7B%7D). So much so, I'm not sure I have a concrete \"ask\" (except [#4544](https://github.com/microsoft/typespec/issues/4544) and [#4545](https://github.com/microsoft/typespec/issues/4545)).\nThese thoughts are based on the work migrating the Sefaria spec; they have hundreds of examples which (see [#3866](https://github.com/microsoft/typespec/issues/3866)) were manually migrated.", "ground_truth": "The main issue discussed revolves around improving the handling of examples in API documentation, particularly when migrating JSON data into TypeSpec definitions. There are two primary scenarios:\nPayload First: Migrating existing JSON to TypeSpec models is tedious, especially with the need to manually add # for nested values. A CLI tool that automatically converts JSON to equivalent \"value\"s would be very helpful.\nModel First: When creating examples for TypeSpec models, there is no templating for the @example decorator, which makes defining examples harder. It would be beneficial if the type for @example could be inferred instead of being unknown, and the differing error messages and tooltips can be confusing.\nA key issue is that when converting an example like @example({\"Baz\": \"Hello\"}) into TypeSpec format, it is not enough to just add the #. The property Baz needs to be correctly recognized and mapped to the model type. This issue has been filed under issues [#4612](https://github.com/microsoft/typespec/issues/4612) and [#4613](https://github.com/microsoft/typespec/issues/4613).\nThe overall goal is to streamline the process of creating and validating examples, making it easier for developers to generate and maintain accurate API documentation.", "response": "Sorry, I can't answer this question. To provide guidance, I need more information about the specific tooling or features you are looking for in TypeSpec, such as whether you are asking about automating JSON-to-TypeSpec conversion, improving example validation, or addressing specific error messages.", "context": "- document_dir: typespec_azure_docs\n- document_filename: migrate-swagger#01-get-started.md\n- document_title: Getting started with TypeSpec migration\n- document_link: https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\n- document_content: # migrate-swagger#01-get-started.md\n\n# Getting started with TypeSpec migration\n\nWe have created a swagger to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane swaggers. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\r\n\r\n**_Important!_** Because TypeSpec is more expressive than Swagger and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\n\n## Steps of running the tool\n\n- Ensure [Node.js](https://nodejs.org/en/download/) 18.3 LTS or later is installed.\r\n- Install [`@azure-tools/typespec-client-generator-cli`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-cli):\n\n### Update existing swagger files\n\n- Run the tool to sort existing swagger so you can easily compare with TypeSpec generated swagger. Please note this functionality has been added in version 0.10.0. Please update to latest if you don't see this command option.\r\n\r\n  ```shell\r\n  tsp-client sort-swagger [path to existing swagger]\r\n  ```\r\n\r\n- Please check in the updated swaggers in separate PR prior submitting TypeSpec. This will allow you and reviewers to easily see any changes introduced by the TypeSpec conversion.\n\n### Generate TypeSpec with converter\n\n- Install dependencies\r\n\r\n  - If you are starting from a scratch folder:\r\n\r\n    ```shell\r\n    npm install @azure-tools/typespec-client-generator-cli\r\n    ```\r\n\r\n    **_Important!_** If it's not your first time install `@azure-tools/typespec-client-generator-cli`, update by\r\n\r\n    ```shell\r\n    npm update @autorest/openapi-to-typespec\r\n    ```\r\n\r\n  - If you are starting from [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs):\r\n    ```shell\r\n    npm install # Run at root\r\n    ```\r\n\r\n- Run the tool from the directory you would like to output your files.\r\n\r\n  - Convert a **data-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md]\r\n    ```\r\n\r\n  - Convert a **control-plane** specification:\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm\r\n    ```\r\n\r\n  - Convert a **control-plane** specification to fully compatible output:\r\n\r\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\n    ```shell\r\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\r\n    ```\r\n\r\n- Review generated TypeSpec\r\n- Layout [the TypeSpec project folders appropriately](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\r\n- Leverage standard `tspconfig.yaml` ([Template projects](https://github.com/microsoft/typespec/tree/main/eng/feeds)) and make appropriate output file name changes.\r\n- Ensure it compiles successfully locally\n\n### Review and adjust the TypeSpec\n\nThis is the probably most critical step of the conversion. As you have pre-sorted the swagger files in the first step, you would see the delta introduced in swagger.\r\n\r\n- Review and make appropriate changes to ensure minimal changes for swagger.You can check the migration Tips for commonly asked questions and solutions.\r\n- Run the `compare` command to see the differences between the original swagger and the TypeSpec-generated one. This command performs an expansion and transformation that will help eliminate diffs in the actual Swagger that don't matter, either because the constructs are functionally equivalent or because we have determined that a potential diff does not represent a functional difference in the REST API (it might impact SDKs, but there are other tools for that).\r\n\r\n  ```shell\r\n  tsp-client compare --lhs [path to hand-authored Swagger(s)] --rhs [path to TypeSpec project] --compile-tsp\r\n  ```\r\n\r\n  For more info on this command and its options, see the [README](https://github.com/tjprescott/openapi-diff/blob/main/README.md) for the underlying tool. `tsp-client compare` is simply a wrapper around this tool.\r\n\r\n  Once run, you can use a visual diff tool to compare `output/lhs.json` and `output/rhs.json` to visually see the differences that matter in the transformed Swagger and can use that to trace back to the TypeSpec to make the necessary changes. You can also look at `output/diff.json` to the differences as individual JSON objects. These may be easier to read than the visual diff and may contain additional details on why a diff matters.\r\n\r\n- Review any custom operation template introduced. The goal is to use the built-in templates from `Azure.Core` and `Azure.Resource.Manager`.\r\n- Review any #FixMe generated by the converter\r\n- Review any warnings\r\n- Avoid large monolithic files. We recommend modularize models and operations into separate files for easy maintenance.\n\n### Create Spec PR with new TypeSpec project\n\n- Review CI checks such as breaking changes and other failures.\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\r\n- Schedule review meetings with TypeSpec team.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: handbook#formatter.md\n- document_title: Formatter\n- document_link: https://typespec.io/docs/handbook/formatter\n- document_content: # handbook#formatter.md\n\n# Formatter\n\nTypeSpec comes with a built-in formatter. The formatter can be used in different ways:\r\n\r\n- [Via the cli](#via-the-cli)\r\n- Via the VS Code/vs extension\r\n- As a `prettier` plugin\n\n## Via the cli\n\nFormat all TypeSpec files:\r\n\r\n```bash\r\ntsp format \"**/*.tsp\"\r\n```\r\n\r\nCheck file formatting without modifying them, useful for CI enforcement.\r\n\r\n```bash\r\ntsp format --check \"**/*.tsp\"\r\n```\n\n## Via the VS Code or VS extension\n\nWhen you use the extensions for VS Code or Visual Studio, the tsp formatter becomes automatically accessible.\r\n\r\nIf you're working within a TypeSpec file, you can format the document using the default keyboard shortcut for formatting, `alt+shift+F`.\n\n### Configuration - Prettier\n\nIf a prettier config (`.prettierrc.yaml`, `.prettierrc.json`, etc.) is present in the project, the formatter will use the configuration from there.\r\nBy default this will then use the typespec style guide without any explicit option.\r\n\r\n:::note\r\nThis only affect the formatting, when using `tab` key to indent it will still use the editor's configuration, so recommend setting one of the configuration below.\r\n:::\n\n### Configuration - VS Code\n\nFor VS Code to respect the TypeSpec standard style set the following options style\r\n\r\n```json title=.vscode/settings.json\r\n{\r\n  [\"typespec\"]: {\r\n    \"editor.detectIndentation\": false,\r\n    \"editor.insertSpaces\": true,\r\n    \"editor.tabSize\": 2,\r\n  }\r\n}\r\n```\n\n### Configuration - EditorConfig\n\nIf using `.editorconfig` with the editor config extension\r\n\r\n```ini title=.editorconfig\r\n[*.tsp]\r\nindent_size = 2\r\nindent_style = space\r\n```\n\n## Via prettier\n\nThe tsp formatter is essentially a `prettier` plugin. If you already have a `prettier` configuration set up for other languages, it can be quite handy to simply integrate TypeSpec into this existing pipeline.\r\n\r\nIn your `prettier` config file, add:\r\n\r\n```yaml title=.prettier.yaml\r\nplugins:\r\n  - \"./node_modules/@typespec/prettier-plugin-typespec\"\r\noverrides: [{ \"files\": \"*.tsp\", \"options\": { \"parser\": \"typespec\" } }]\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: typespec-getting-started.md\n- document_title: What is TypeSpec?\n- document_link: https://azure.github.io/typespec-azure/docs/typespec-getting-started\n- document_content: # typespec-getting-started.md\n\n# What is TypeSpec?\n\nTypeSpec (Compact API Definition Language) is a typescript-like language for defining APIs. TypeSpec is designed for code reuse,\r\nand for Azure services, there are Azure service extensions for TypeSpec that provide high level building blocks you should use to build\r\nyour service. These libraries also contain rules that encourage following established patterns for Azure APIs. Using these building blocks\r\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\r\nservices, and will produce good API documentation, good SDKs, and good CLIs.\r\nTypeSpec can emit the following artifacts for your service:\r\n\r\n- OpenAPI3 specs\r\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\r\n\r\nFor more information on the TypeSpec language and core libraries, see [Getting started with TypeSpec](https://typespec.io/docs)\n\n## Setting up TypeSpec and compile first project\n\n### Install TypeSpec\n\nThere are two simple options for getting TypeSpec up and running in your environment:\r\n\r\n- [Install directly from npm](https://github.com/microsoft/typespec#using-node--npm)\r\n\r\n- Use the [TypeSpec docker images](https://github.com/microsoft/typespec/blob/main/docs/docker.md)\n\n### Create a new TypeSpec Azure project\n\n- Run `tsp init` command with Azure template URL `https://aka.ms/typespec/azure-init` to create a new TypeSpec Azure project for ARM or Data-plane service APIs. This will initialize an empty TypeSpec project with correct npm package references and emitter settings for Azure services.\r\n\r\n- Run `tsp compile` in the project folder will compile the TypeSpec project and emit output in `tsp-output` folder.\r\n\r\nOnce TypeSpec project has been create, the [TypeSpec language tutorial](https://typespec.io/docs) provides a good overview of the basics of the language.\n\n## Getting Started for Azure Management Plane Services\n\nUse the resources in this section for creating Azure ARM rest API specs. For ProviderHub User RP specs and service implementation, please follow the steps in the next section.\r\n\r\n- Documentation\r\n  - [TypeSpec Azure ARM library](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/README.md)\n\n## Getting Started for Azure Data Plane Services\n\n- Documentation\r\n  - [Getting started with TypeSpec for REST APIs](https://github.com/microsoft/typespec/blob/main/README.md#getting-started)\r\n  - [TypeSpec language tutorial](https://typespec.io/docs)\r\n  - [TypeSpec Swagger Cheat Sheet](https://github.com/microsoft/typespec/blob/main/docs/typespec-for-openapi-dev.md)\r\n- Samples\r\n  - [Petstore Sample using Low-level Http APIs](https://github.com/microsoft/typespec/tree/main/packages/samples/petstore)\r\n  - [Petstore Sample using High-level Resource APis](https://github.com/microsoft/typespec/tree/main/packages/samples/rest/petstore)\r\n  - You can also browse the [Samples package](https://github.com/microsoft/typespec/tree/main/packages/samples)\r\n- Video Walkthroughs\r\n  - [Getting Started with TypeSpec](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/Ee5JOjqLOFFDstWe6yB0r20BXozakjHy7w2adGxQi5ztJg?e=QgqqhQ)\n\n## How to Get Help\n\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\r\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\r\n  - For bugs, please include:\r\n    - A high-level description of the bug\r\n    - Expected and Actual Results\r\n    - Repro steps, including any TypeSpec code that you used\r\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](#troubleshooting-vscode-tooling-and-filing-issues)\n\n### Troubleshooting VSCode Tooling and Filing Issues\n\nIf you run into a problem with the TypeSpec-specific tooling in VS Code, please try to capture the issue, and include any log information. If IntelliSense, syntax highlighting or other language features don't appear to be working:\r\n\r\n- Ensure that 'TypeSpec' is the selected language format for your document (this should happen automatically if your file uses the .tsp suffix)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310539-4e9bfbb9-1366-4b6f-a490-875e9bd68669.png)\r\n- Choose Output from the View menu to see the output of the language server (View -> Output)\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310719-4bca242f-f11c-484c-91c7-6914fcf7fe3a.png)\r\n- Capture any output, including stack traces, and include in your [github issue](https://github.com/azure/typespec-azure/issues).\r\n  ![image](https://user-images.githubusercontent.com/1054056/144310907-ec945f54-0fd8-40a4-936c-60669f4a052f.png)\r\n- Restart VS Code to restart the language server\n\n## More Information About TypeSpec\n\nSome additional sources:\r\n\r\n- Recordings\r\n  - [TypeSpec lunch-and-learn for ARM in Stream Channel](https://msit.microsoftstream.com/channel/97c90840-98dc-b478-19e5-f1ecdab7312b)\r\n  - [TypeSpec lunch-and-learn for Azure SDK](https://microsoft-my.sharepoint.com/:v:/r/personal/scotk_microsoft_com/Documents/Recordings/Lunch%20Learning%20Series%20_%20Mark%20Cowlishaw%20-%20TypeSpec%20Walkthrough-20211117_120334-Meeting%20Recording.mp4?csf=1&web=1&e=27IgaX)\n", "latency": 5.153051376342773, "response_length": 299}
{"query": "title: Query about key decorator @key\n\nquestion: Hi,\nI want to know the usage of key decorator(@key).\nI have tried to add @key to 'id' property in my model and compiled with 2 emitters below. But the result is the same with model without @key. So it seems @key doesn't take effect in my case, why?\n@azure-tools/typespec-ts\n@typespec/openapi3\n`model MyCalculationOutput {\n@key\nid: string;\nprocessDate: plainDate;\nresult: string;\n}\n@get\n@route(\"/$calculation\")\nop calculation(): MyCalculationOutput[] ;`\nThanks\nThe background is: The 'calculation' method returns a list of records. I want this list of records could be presented as a dictionary/map of records with the 'id' of each record used as the dictionary/map key", "ground_truth": "Key conceptually flags the fields which identify the resource, but doesn't imply any special behavior for that type within an array. You can maybe get what you want by doing:\n```\nop calculation(): Record<MyCalculationOutput>\n```", "response": "Sorry, I can't answer this question. To provide guidance on the usage of the @key decorator and its impact on emitters, I need more information about the specific behavior or documentation of the @key decorator in TypeSpec. Could you clarify its intended functionality or provide additional details?", "context": "- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-core#rules#no-openapi.md\n- document_title: no-openapi\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi\n- document_content: # libraries#azure-core#rules#no-openapi.md\n\n# no-openapi\n\n```text title=\"Full name\"\r\n@azure-tools/typespec-azure-core/no-openapi\r\n```\r\n\r\nAzure services should not be using decorators from the OpenAPIs libraries(`@azure-tools/openapi`, `@azure-tools/typespec-autorest` or `@azure-tools/openapi3`) in their spec.\r\nUsing those decorators is usually a sign that the spec is either not following the correct Azure or trying to match exactly a particular OpenAPI spec which should be a non-goal.\r\n\r\nThose decorators are only meant to be read by the openapi emitters which means this might achieve the correct OpenAPI output but other emitters(client SDK, service, etc.) will not be able to understand them and will see a broken representation of the spec.\n\n## Decorators and their alternatives\n\n|\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              | Use versioning library for `version` and `@service` for title                                                                                                   |\n\n| OpenAPI Decorator                    | Alternative                                                                                                                                                     |\r\n| ------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `@example`                           | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-examples\", `       | [See examples doc](../../../migrate-swagger/faq/x-ms-examples.md)                                                                                               |\r\n| `@extension(\"x-ms-client-flatten\", ` | TCGC [`@flattenProperty`](../../typespec-client-generator-core/reference/decorators#@Azure.ClientGenerator.Core.flattenProperty)                                |\r\n| `@extension(\"x-ms-mutability\", `     | Use [`@visibility` decorator](https://typespec.io/docs/next/standard-library/built-in-decorators#@visibility)                                                   |\r\n| `@extension(\"x-ms-enum\", `           | [Enum extensibility doc](https://azure.github.io/typespec-azure/docs/next/troubleshoot/enum-not-extensible)                                                     |\r\n| `@operationId`                       | Name your interface and operation accordingly                                                                                                                   |\r\n| `@useRef`                            | This should not be used, define the types correctly in TypeSpec. For ARM common types read the [Arm docs](../../../getstarted/azure-resource-manager/step00.md) |\r\n| `@info`                              |\n\n## Exceptions\n\n- `@extension(\"x-ms-identifiers\"` is allowed as this right now has no alternative and is an ARM requirement that is not used by any other emitter.\n\n## Examples\n\n### `@extension(\"x-ms-enum\"`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\n@extension(\r\n  \"x-ms-enum\",\r\n  {\r\n    name: \"PetKind\",\r\n    modelAsString: true,\r\n  }\r\n)\r\nenum PetKind {\r\n  Cat,\r\n  Dog,\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nunion PetKind {\r\n  Cat: \"Cat\",\r\n  Dog: \"Dog\",\r\n  string,\r\n}\r\n```\n\n### `@extension(\"x-ms-mutability\"`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\nmodel Pet {\r\n  @extension(\"x-ms-mutability\", [\"read\", \"create\"])\r\n  name: string;\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nmodel Pet {\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  name: string;\r\n}\r\n```\n\n### `@operationId`\n\n#### ❌ Incorrect\r\n\r\n```tsp\r\n@operationId(\"Pet_Get\")\r\nop getPet(): Pet;\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\ninterface Pet {\r\n  get(): Pet;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/language-basics/decorators\n- document_content: # language-basics#decorators.md\n\n# Decorators\n\nDecorators in TypeSpec allow developers to attach metadata to types within a TypeSpec program. They can also be used to compute types based on their inputs. Decorators form the core of TypeSpec's extensibility, providing the flexibility to describe a wide variety of APIs and associated metadata such as documentation, constraints, samples, and more.\r\n\r\nThe vast majority of TypeSpec declarations may be decorated, including [namespaces](./namespaces.md), [interfaces](./interfaces.md), [operations](./operations.md) and their parameters, [scalars](./scalars.md), and [models](./models.md) and their members. In general, any declaration that creates a Type can be decorated. Notably, [aliases](./alias.md) cannot be decorated, as they do not create new Types, nor can any type expressions such as unions that use the `|` syntax or anonymous models, as they are not declarations.\r\n\r\nDecorators are defined using JavaScript functions that are exported from a standard ECMAScript module. When a JavaScript file is imported, TypeSpec will look for any exported functions prefixed with `$`, and make them available as decorators within the TypeSpec syntax. When a decorated declaration is evaluated by TypeSpec, the decorator function is invoked, passing along a reference to the current compilation, an object representing the type it is attached to, and any arguments the user provided to the decorator.\n\n## Applying decorators\n\nDecorators are referenced using the `@` prefix and must be placed before the entity they are decorating. Arguments can be provided by using parentheses, similar to function calls in many programming languages, e.g., `@myDec1(\"hi\", { a: string })`.\r\n\r\nHere's an example of declaring and then using a decorator:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {\r\n  @validate(false)\r\n  name: string;\r\n}\r\n```\r\n\r\nIf no arguments are provided, the parentheses can be omitted.\r\n\r\n```typespec\r\n@mark\r\nmodel Dog {}\r\n```\n\n## Augmenting decorators\n\nDecorators can also be applied from a different location by referring to the type being decorated. For this, you can declare an augment decorator using the `@@` prefix. The first argument of an augment decorator is the type reference that should be decorated. As the augment decorator is a statement, it must end with a semicolon (`;`).\r\n\r\n```typespec\r\nmodel Dog {}\r\n\r\n@@tag(Dog, \"Sample\");\r\n```\r\n\r\nThis is equivalent to:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {}\r\n```\r\n\r\nExample: decorating a model property to indicate that it is read-only\r\n\r\n```typespec\r\nmodel Dog {\r\n  name: string;\r\n}\r\n\r\n@@visibility(Dog.name, Lifecycle.Read);\r\n```\n\n## Creating decorators\n\nFor more information on creating decorators, see [Creating Decorators](../extending-typespec/create-decorators.md).\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n", "latency": 5.622574329376221, "response_length": 299}
{"query": "title: Can't generate multiple services imported in the main.tsp\n\nquestion: Have been stuck for a while on this problem: every time I'm trying to emit a yaml file by running npx tsp compile  . I get generated a yaml file only for the last imported service. Here's my tspconfig.yaml :\n```\n- \"@typespec/openapi3\"\noptions:\n\"@typespec/openapi3\":\n\"output-file\": \"openapi.yaml\"\n```\nI don't know if it has anything to do with it but I also was getting warnings during compilation ln terminal: No namespace with '@service' was found, but Namespace 'AdminService' contains routes. Did you mean to annotate this with '@service'?  which I found unreasonable, since I have service decorators everywhere, and added #suppress \"@typespec/http/no-service-found\" \"\" to supress it. Here's the repository I'm having issues with.", "ground_truth": "The problem was caused by a conflict between the global and local versions of the TypeSpec compiler. Once the user reinstalled the template and corrected the setup, the issue was resolved, and all services could be compiled into the YAML file as expected. The incorrect usage of using was also clarified, with the suggestion to nest namespaces properly under the main service (e.g., `namespace ECommerce.AuthService;`).", "response": "Sorry, I can't answer this question. To assist you further, I need more details about your TypeSpec project structure, including the contents of your `main.tsp` file and how you are importing multiple services. Additionally, sharing the repository link or specific examples of your service definitions and decorators would help clarify the issue.", "context": "- document_dir: typespec_docs\n- document_filename: introduction#installation.mdx\n- document_title: Installation\n- document_link: https://typespec.io/docs/introduction/installation\n- document_content: # introduction#installation.mdx\n\n# Installation\n\nimport { Aside, Badge, Tabs, TabItem, FileTree, Steps } from \"@astrojs/starlight/components\";\n\n## Install TypeSpec\n\nTypeSpec can be used in two ways:\r\n\r\n- Npm package for use with [Node.js](https://nodejs.org/)\r\n- A standalone executable without any additional dependencies. <Badge text=\"Experimental\" variant=\"caution\" />\r\n\r\n<Tabs>\r\n  <TabItem label=\"Node.JS\">\r\n\r\n<Steps>\r\n\r\n1. Install [Node.js LTS](https://nodejs.org/en/download/)\r\n\r\n2. Install the TypeSpec CLI\r\n\r\n   ```bash\r\n   npm install -g @typespec/compiler\r\n   ```\r\n\r\n</Steps>\r\n\r\n[See package manager doc](../handbook/package-manager.md) for more information on package managers.\r\n\r\n  </TabItem>\r\n  <TabItem label=\"Standalone (Experimental)\">\r\n\r\n<Aside type=\"caution\">The standalone CLI is currently experimental.</Aside>\r\n\r\nTo install, paste this into a terminal:\r\n\r\n<Tabs>\r\n  <TabItem label=\"macOS\">\r\n  \r\n```bash\r\ncurl -fsSL https://typespec.io/install.sh | bash\r\n```\r\n\r\n  </TabItem>\r\n  <TabItem label=\"Windows\">\r\n\r\n```bash\r\npowershell -c \"irm typespec.io/install.ps1|iex\"\r\n```\r\n\r\n  </TabItem>\r\n  <TabItem label=\"Linux\">\r\n  \r\n```bash\r\ncurl -fsSL https://typespec.io/install.sh | bash\r\n```\r\n\r\n  </TabItem>\r\n</Tabs>\r\n\r\n  </TabItem>\r\n</Tabs>\n\n## Install the VS and VS Code extensions\n\nTypeSpec provides extensions for the following editors:\r\n\r\n- [Visual Studio Code](./editor/vscode.md)\r\n- [Visual Studio](./editor/vs.md)\n\n## Create a new TypeSpec project\n\n<Tabs>\r\n  <TabItem label=\"CLI\">\r\n\r\n<Steps>\r\n\r\n1. Create a new TypeSpec project.\r\n\r\n   ```bash\r\n   tsp init\r\n   ```\r\n\r\n   This will prompt you with a few questions. Pick the `Generic REST API` template, your project name, and make sure the `@typespec/http` and `@typespec/openapi3` libraries are selected.\r\n\r\n2. Run a build to generate the OpenAPI specification output file.\r\n\r\n   ```bash\r\n   tsp compile .\r\n   ```\r\n\r\n</Steps>\r\n  </TabItem>\r\n  <TabItem label=\"VS Code\">\r\n\r\n<Steps>\r\n\r\n1. Invoke the command `>TypeSpec: Create TypeSpec Project` to create TypeSpec project, or click `Create TypeSpec Project` button from the Primary Sidebar of Explorer.\r\n2. Follow Quick Picks to select root folder of your project, pick the `Generic REST API` template, input your project name, make sure the `@typespec/http` and `@typespec/openapi3` libraries are selected, then return to launch project scaffolding.\r\n\r\n</Steps>\r\n\r\n![vscode_project_scaffolding.gif](https://raw.githubusercontent.com/microsoft/typespec/main/website/src/content/docs/docs/images/vscode_project_scaffolding.gif)\r\n\r\n  </TabItem>\r\n</Tabs>\r\n\r\nYou should now have a basic TypeSpec project setup with a structure looking like this:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: The entry point for your TypeSpec build. This file typically contains the main definitions for your models, services, and operations.\r\n- **tspconfig.yaml**: Configuration file for the TypeSpec compiler, specifying options and settings for the build process.\r\n- **package.json**: Contains metadata about the project, including dependencies, scripts, and other project-related information.\r\n- **node_modules/**: Directory where npm installs the project's dependencies.\r\n- **tsp-output/**: Directory where the TypeSpec compiler outputs generated files.\n\ntypically contains the main definitions for your models, services, and operations.\r\n- **tspconfig.yaml**: Configuration file for the TypeSpec compiler, specifying options and settings for the build process.\r\n- **package.json**: Contains metadata about the project, including dependencies, scripts, and other project-related information.\r\n- **node_modules/**: Directory where npm installs the project's dependencies.\r\n- **tsp-output/**: Directory where the TypeSpec compiler outputs generated files.\r\n- **openapi.yaml**: The generated OpenAPI specification file for your API, detailing the API's endpoints, models, and operations. The output can vary based on the target format specified in the `tspconfig.yaml` file.\r\n\r\nYou can also run `tsp compile . --watch` to automatically compile changes on save.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-with-tsp-client#intro_tsp_client.md\n- document_title: Usage\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/intro_tsp_client\n- document_content: # howtos#generate-with-tsp-client#intro_tsp_client.md\n\n# Usage\n\n:::info\r\n**Short link:** [aka.ms/azsdk/tsp-client](https://aka.ms/azsdk/tsp-client)\r\n:::\r\n\r\n`tsp-client` is a simple command line tool to facilitate generating client libraries from TypeSpec.\n\n## Installation\n\n```bash\r\nnpm install -g @azure-tools/typespec-client-generator-cli\r\n```\n\n## Prerequisites\n\nUsers working with a repository that already accepts this tool can continue to the [Usage](#usage) section.\r\n\r\nRepo owners should follow the steps in the [tsp-client repo setup](./repo_setup.md) doc.\n\n## Usage\n\n```bash\r\ntsp-client < command > [options]\r\n```\n\n## Commands\n\nUse one of the supported commands to get started generating clients from a TypeSpec project.\r\n\r\nThis tool will default to using your current working directory to generate clients in and will\r\nuse it to look for relevant configuration files. To specify a different output directory, use\r\nthe `-o` or `--output-dir` option.\r\n\r\nTo see supported commands, run:\r\n\r\n```bash\r\ntsp-client --help\r\n```\r\n\r\nTo see supported parameters and options for a specific command, run:\r\n\r\n```bash\r\ntsp-client < command > --help\r\n```\r\n\r\nExample using the `init` command:\r\n\r\n```bash\r\ntsp-client init --help\r\n```\n\n### init\n\nInitialize the client library directory using a tspconfig.yaml. When running this command pass in a path to a local or the URL of a remote tspconfig.yaml with the `-c` or `--tsp-config` flag. If remote, the tspconfig.yaml must include the specific commit in the path. (See example below)\r\n\r\nThe `init` command generates a directory structure following the standard pattern used across Azure SDK language repositories, creates a [tsp-location.yaml](#tsp-locationyaml) file to control generation, and performs an initial generation of the client library. If you want to skip client library generation, then pass the `--skip-sync-and-generate` flag.\r\n\r\n:::caution\r\nThis command should be run from the root of the repository. Example repository root: `azure-sdk-for-python/`\r\n:::\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client init -c https://github.com/Azure/azure-rest-api-specs/blob/dee71463cbde1d416c47cf544e34f7966a94ddcb/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\r\n```\n\n### update\n\nThe `update` command will look for a [tsp-location.yaml](#tsp-locationyaml) file in your current directory to sync a TypeSpec project and generate a client library. The update flow calls the `sync` and `generate` commands internally, so if you need to separate these steps, use the `sync` and `generate` commands separately instead.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client update\r\n```\n\n### sync\n\nSync a TypeSpec project with the parameters specified in tsp-location.yaml.\r\n\r\nBy default the `sync` command will look for a tsp-location.yaml to get the project details and sync them to a temporary directory called `TempTypeSpecFiles`. Alternately, you can pass in the `--local-spec-repo` flag with the path to your local TypeSpec project to pull those files into your temporary directory.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client sync\r\n```\n\n### generate\n\nGenerate a client library from a TypeSpec project. The `generate` command should be run after the `sync` command. `generate` relies on the existence of the `TempTypeSpecFiles` directory created by the `sync` command and on an `emitter-package.json` file checked into your repository at the following path: `<repo root>/eng/emitter-package.json`. The `emitter-package.json` file is used to install project dependencies and get the appropriate emitter package.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate\r\n```\n\n### convert\n\nConvert an existing swagger specification to a TypeSpec project. This command should only be run once to get started working on a TypeSpec project. TypeSpec projects will need to be optimized manually and fully reviewed after conversion. When using this command a path or url to a swagger README file is required through the `--swagger-readme` flag. By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original swagger. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the swagger.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client convert -o ./Contoso.WidgetManager --swagger-readme < path-to > /readme.md\r\n```\n\n### compare\n\nCompares two Swagger definitions to identify the relevant differences between them. This command is useful when comparing an existing Swagger definition with a TypeSpec generated one. The `compare` command requires two parameters: `--lhs` which will typically be the original hand-authored Swagger and `--rhs` which will usually be the folder containing your TypeSpec. The command will generate the Swagger and compare the two definitions. The command will ignore differences in the Swagger that don't\r\ncorrespond to differences in the service, allowing you to focus only on differences that are relevant.\n\n### sort-swagger\n\nSort an existing swagger specification to be the same content order with TypeSpec generated swagger. This will allow you to easily compare and identify differences between the existing swagger and TypeSpec generated one. You should run this command on existing swagger files and check them in prior to creating converted TypeSpec PRs.\n\n### generate-config-files\n\n\"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"0.4.0-alpha.20250110.1\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\"\r\n  }\r\n}\r\n```\r\n\r\nIf you need to override dependencies for your emitter-package.json you can create a json file to explicitly list the package and corresponding version you want to override. This will add an `overrides` section in your emitter-package.json that will be used during `npm install` or `npm ci`. [See npm overrides doc.](https://docs.npmjs.com/cli/v10/configuring-npm/package-json?v=true#overrides)\r\n\r\nExample json file with package overrides:\r\n\r\n```json\r\n{\r\n  \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\",\r\n  \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n}\r\n```\r\n\r\nExample command specifying overrides:\r\n\r\n```bash\r\ntsp-client generate-config-files --overrides my_overrides.json --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample `emitter-package.json` generated using overrides:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\r\n  \"dependencies\": {\r\n    \"@azure-tools/typespec-foo\": \"https://<dev-feed-url>/typespec-foo-0.4.0-alpha.20250110.1.tgz\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"~0.64.0\"\r\n  },\r\n  \"overrides\": {\r\n    \"@azure-tools/generator-foo\": \"https://<dev-feed-url>/generator-foo-1.3.0-alpha.20250110.1.tgz\"\r\n  }\r\n}\r\n```\n\nThis command generates the default configuration files used by tsp-client. Run this command to generate the `emitter-package.json` and `emitter-package-lock.json` under the **eng/** directory of your current repository.\r\n\r\n**Required: Use the `--package-json` flag to specify the path to the package.json file of the emitter you will use to generate client libraries.**\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nExample using the `azure-sdk-for-js` and the `@azure-tools/typespec-ts` emitter:\r\n\r\nThe `--package-json` flag should be the relative or absolute path to repo clone of the @azure-tools/typespec-ts package.\r\n\r\n```bash\r\nazure-sdk-for-js > tsp-client generate-config-files --package-json < path-to-emitter-repo-clone > /package.json\r\n```\r\n\r\nTo be explicit about specifying dependencies you'd like pinned, add a new field in the package.json file of your emitter called `\"azure-sdk/emitter-package-json-pinning\"` with a list of the dependencies you want to be forwarded to the emitter-package.json. These dependencies must be specified in your package.json's devDependencies in order for the tool to assign the correct version.\r\n\r\n:::info\r\nIf the `azure-sdk/emitter-package-json-pinning` field is missing from the package.json file, the tool will default to pinning the packages listed under `peerDependencies`.\r\n:::\r\n\r\nExample package.json using `\"azure-sdk/emitter-package-json-pinning\"`:\r\n\r\n```json\r\n{\r\n  \"name\": \"@azure-tools/typespec-foo\",\r\n  \"version\": \"0.4.0-alpha.20250110.1\",\r\n  ...\r\n  \"dependencies\": {\r\n    \"@azure-tools/generator-foo\": \"0.3.0\",\r\n    \"@typespec/http-client-foo\": \"1.2.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"0.64.0\",\r\n    \"rimraf\": \"^6.0\",\r\n  },\r\n  \"azure-sdk/emitter-package-json-pinning\": [\r\n    \"@typespec/compiler\"\r\n  ]\r\n}\r\n```\r\n\r\nExample `emitter-package.json` generated from the package.json shown above:\r\n\r\n```json\r\n{\r\n  \"main\": \"dist/src/index.js\",\n\n### generate-lock-file\n\nGenerate an emitter-package-lock.json under the eng/ directory based on existing `<repo-root>/eng/emitter-package.json`.\r\n\r\nExample:\r\n\r\n```bash\r\ntsp-client generate-lock-file\r\n```\n\n## Important concepts\n\n### Per project setup\n\nEach project will need to have a configuration file called tsp-location.yaml that will tell the tool where to find the TypeSpec project.\r\n\r\n#### tsp-location.yaml\r\n\r\nThis file is created through the `tsp-client init` command or you can manually create it under the project directory to run other commands supported by this tool.\r\n\r\n:::info\r\nThis file should live under the project directory for each service.\r\n:::\r\n\r\nThe file has the following properties:\r\n\r\n| Property                                                        | Description                                                                                                                                                                                                                                                                                           | IsRequired            |\r\n| --------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------- |\r\n| <a id=\"directory-anchor\"></a> directory                         | The top level directory where the main.tsp for the service lives. This should be relative to the spec repo root such as `specification/cognitiveservices/OpenAI.Inference`                                                                                                                            | true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. |\n\n| true                  |\r\n| <a id=\"additionalDirectories-anchor\"></a> additionalDirectories | Sometimes a typespec file will use a relative import that might not be under the main directory. In this case a single `directory` will not be enough to pull down all necessary files. To support this you can specify additional directories as a list to sync so that all needed files are synced. | false: default = null |\r\n| <a id=\"commit-anchor\"></a> commit                               | The commit sha for the version of the typespec files you want to generate off of. This allows us to have idempotence on generation until we opt into pointing at a later version.                                                                                                                     | true                  |\r\n| <a id=\"repo-anchor\"></a> repo                                   | The repo this spec lives in. This should be either `Azure/azure-rest-api-specs` or `Azure/azure-rest-api-specs-pr`. Note that pr will work locally but not in CI until we add another change to handle token based auth.                                                                              | true                  |\r\n| <a id=\"entrypointFile-anchor\"></a> entrypointFile               | A specific entrypoint file used to compile the TypeSpec project. NOTE: This option should only be used with a non-standard entrypoint file name. DO NOT use this option with standard entrypoints: `client.tsp` or `main.tsp`.                                                                        | false                 |\r\n\r\nExample:\r\n\r\n```yml title=tsp-location.yaml\r\ndirectory: specification/contosowidgetmanager/Contoso.WidgetManager\r\ncommit: 431eb865a581da2cd7b9e953ae52cb146f31c2a6\r\nrepo: Azure/azure-rest-api-specs\r\nadditionalDirectories:\r\n  - specification/contosowidgetmanager/Contoso.WidgetManager.Shared/\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#rest-api-publish#buildpipelines.md\n- document_title: Using Build Pipelines with TypeSpec\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/rest-api-publish/buildpipelines\n- document_content: # howtos#rest-api-publish#buildpipelines.md\n\n# Using Build Pipelines with TypeSpec\n\nThis doc will help you get started with using TypeSpec in your build pipelines in your own repository. [See here for more how to use in the azure-rest-api-specs repo](./checking-in-api-specs-guide.md)\n\n## Table of Contents\n\n1. [Introduction](#introduction)\r\n1. [Azure DevOps Pipelines](#azure-devops-pipelines)\n\n## Introduction\n\n### Dependencies\n\nIn order to build TypeSpec in your build pipeline, you will need to ensure that the following are available or are automatically installed by your project:\r\n\r\n1. NodeJS 22.x LTS (Recommended)\r\n2. TypeSpec compilation tools (via npm package)\n\n## Azure DevOps Pipelines\n\nDepending on your project, you may need to add NodeJS and install NPM packages for TypeSpec.\r\nThe following Azure Devops Pipeline tasks can be modified and added to your pipeline yaml file if you do not already utilize NodeJS in your project.\r\n\r\n```yaml title=\".azure-pipelines.yml\"\n\n# Install NodeJS\n\n- task: NodeTool@0\r\n  inputs:\r\n    versionSpec: \"22.x\"\r\n    checkLatest: false\n\n# Install dependencies\n\n- script: npm install\r\n  workingDir: path/to/typespec/project # This is where package.json lives for your TypeSpec project\n\n# Build\n\n- script: npx tsp compile .\r\n  workingDir: path/to/typespec/project # This is where package.json lives for your TypeSpec project\r\n```\r\n\r\nThis is sufficient if you are building via a csproj file which triggers the tsp compile and finds the tsp compiler itself.\r\n\r\nYou may also need to add additional steps to compile your typespec files separately. An example of a basic pipeline is provided below.\n\n### Example Pipeline Configuration\n\nNote: This example assumes that your TypeSpec folder is at the root of your repository.\r\n\r\n```yaml title=\".azure-pipelines.yml\"\r\ntrigger:\r\n  - main\r\npool:\r\n  vmImage: ubuntu-latest\r\nsteps:\r\n  - task: NodeTool@0\r\n    inputs:\r\n      versionSpec: \"18.17.0\"\r\n  - script: npm install\r\n  - script: npx tsp compile .\r\n  - task: PublishPipelineArtifact@1\r\n    displayName: Publish TypeSpec Output Folder\r\n    inputs:\r\n      targetPath: \"tsp-output\"\r\n      artifact: \"tsp-output\"\r\n      publishLocation: \"pipeline\"\r\n```\n", "latency": 4.924995183944702, "response_length": 346}
{"query": "title: How to emit option\n\nquestion: Hey 👋\nI have an existing protobuf definition which I want to port to typespec, but I don't see how I can implement option:\n```\n// name/backstage/service_options.proto file\nsyntax = \"proto3\";\npackage name.backstage;\nimport \"google/protobuf/descriptor.proto\";\noption go_package = \"github.com/name/repo/proto/gen/go/name/backstage\";\noption java_package = \"com.name.backstage\";\nextend google.protobuf.ServiceOptions {\n// Used to fill the spec.owner field in a backstage file\noptional string owner = 51001;\n// Used to fill the system field in a backstage file\noptional string system = 51002;\n}\n// somewhere in proto files\nimport \"name/backstage/service_options.proto\";\nservice DemoService {\noption (name.backstage.owner) = \"team/demo-team\";\nrpc GetData(GetDataRequest) returns (GetDataResponse) {\noption (google.api.http) = {\nget: \"/v1/api-name/{param}/data\"\n};\n}\n}\n```\nUsing using google http annotations is our strict requirement and I can't find a way to do it with typespec.\nhttps://docs.solo.io/gloo-edge/latest/reference/api/github.com/solo-io/solo-kit/api/external/google/api/http.proto.sk/", "ground_truth": "The answer is this feature request [#4090](https://github.com/microsoft/typespec/issues/4090)", "response": "Sorry, I can't answer this question. To assist you, I need more information about how you want to implement options in TypeSpec or if you are looking for specific decorators or configurations to replicate the behavior of Protobuf options.", "context": "- document_dir: typespec_docs\n- document_filename: emitters#protobuf#reference#emitter.md\n- document_title: Emitter usage\n- document_link: https://typespec.io/docs/emitters/protobuf/reference/emitter\n- document_content: # emitters#protobuf#reference#emitter.md\n\n# Emitter usage\n\n## Usage\n\n1. Via the command line\r\n\r\n```bash\r\ntsp compile . --emit=@typespec/protobuf\r\n```\r\n\r\n2. Via the config\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/protobuf\"\r\n```\r\n\r\nThe config can be extended with options as follows:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/protobuf\"\r\noptions:\r\n  \"@typespec/protobuf\":\r\n    option: value\r\n```\n\n## Emitter options\n\n### `emitter-output-dir`\n\n**Type:** `absolutePath`\r\n\r\nDefines the emitter output directory. Defaults to `{output-dir}/@typespec/protobuf`\r\nSee [Configuring output directory for more info](https://typespec.io/docs/handbook/configuration/configuration/#configuring-output-directory)\n\n### `noEmit`\n\n**Type:** `boolean`\r\n\r\nIf set to `true`, this emitter will not write any files. It will still validate the TypeSpec sources to ensure they are compatible with Protobuf, but the files will simply not be written to the output directory.\n\n### `omit-unreachable-types`\n\n**Type:** `boolean`\r\n\r\nBy default, the emitter will create `message` declarations for any models in a namespace decorated with `@package` that have an `@field` decorator on every property. If this option is set to true, this behavior will be disabled, and only messages that are explicitly decorated with `@message` or that are reachable from a service operation will be emitted.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#protobuf#guide.md\n- document_title: Guide\n- document_link: https://typespec.io/docs/emitters/protobuf/guide\n- document_content: # emitters#protobuf#guide.md\n\n# Guide\n\nTypeSpec includes a built-in emitter (`/protobuf`) that can generate Protocol Buffers specifications from TypeSpec sources. The Protobuf files generated can then be used to create gRPC services or any other tools that are compatible with Protocol Buffers.\r\n\r\n**Please note**: The Protobuf emitter is designed to work with Protocol Buffers 3 (proto3) syntax. Ensure that your workflow (including `protoc` version) supports proto3 to make full use of this emitter.\n\n## Fundamental Concepts\n\nThe Protobuf emitter allows you to write TypeSpec and transform it into corresponding Protocol Buffers for use with systems that support Protobuf (like gRPC). To successfully convert your TypeSpec models and interfaces to Protobuf, they must comply with certain rules and limitations.\n\n### Packages\n\nA protobuf package is established by the [`TypeSpec.Protobuf.package` decorator][protobuf-package], which is applied to a TypeSpec namespace. Essentially, a package defines a `.proto` file, and all contents within the decorated namespace are emitted into a single file.\r\n\r\nConsider the following TypeSpec namespace, which results in a Protobuf file named `main.proto` containing the contents of the `Test` namespace, converted into Protobuf.\r\n\r\n```typespec\r\n@package\r\nnamespace Test {\r\n// ...\r\n\r\n}\r\n```\r\n\r\nYou can specify package names using the optional `PackageDetails` argument with the `@package` decorator. The following TypeSpec namespace will create a file `com/example/test.proto` that includes the line `package com.example.test;`:\r\n\r\n```typespec\r\n@package({\r\n  name: \"com.example.test\",\r\n})\r\nnamespace Test {\r\n// ...\r\n\r\n}\r\n```\r\n\r\nTypeSpec entities (like models, enums, etc.) are transformed into Protobuf declarations within their closest ancestor that has a package annotation. This means that, unlike in Protobuf, TypeSpec package declarations can be nested as needed.\n\n### Messages\n\nTypeSpec models are translated into Protobuf messages. For instance, the following TypeSpec model:\r\n\r\n```typespec\r\nmodel TestMessage {\r\n  @field(1) n: int32;\r\n}\r\n```\r\n\r\nwill be transformed into the Protobuf message below:\r\n\r\n```protobuf\r\nmessage TestMessage {\r\n  int32 n = 1;\r\n}\r\n```\r\n\r\nModels are converted into messages and included in the Protobuf file if they meet any of the following conditions:\r\n\r\n- The model is explicitly annotated with the [`TypeSpec.Protobuf.message` decorator][protobuf-message].\r\n- The model is referenced by any service operation (refer to [Services](#services) below).\r\n- The model is a direct child of a [package namespace](#packages) and every field is annotated with the [`TypeSpec.Protobuf.field` decorator][protobuf-field].\r\n\r\n#### Field Indices\r\n\r\nProtobuf requires manual specification of the offset for each field within a Protobuf message. In TypeSpec, these field indices are specified using the [`TypeSpec.Protobuf.field` decorator][protobuf-field]. To be converted into a Protobuf message, all fields within a model must have an attached `@field` decorator.\r\n\r\nThe following TypeSpec model:\r\n\r\n```typespec\r\nmodel TestMessage {\r\n  @field(1) n: int32;\r\n}\r\n```\r\n\r\nwill be transformed into the Protobuf message below:\r\n\r\n```protobuf\r\nmessage TestMessage {\r\n  int32 n = 1;\r\n}\r\n```\n\n### Services\n\nTypeSpec defines a \"service\" using the [`TypeSpec.service` decorator][native-service], but the Protobuf \"service\" concept is different and is denoted by the [`TypeSpec.Protobuf.service` decorator][protobuf-service].\r\n\r\nWhen using the Protobuf emitter, a Protobuf service designation is applied to an interface within a package. For example, the following TypeSpec:\r\n\r\n```typespec\r\n@package\r\nnamespace Example {\r\n  @Protobuf.service\r\n  interface Test {\r\n    // ...\r\n  }\r\n}\r\n```\r\n\r\nwill generate the following Protobuf file (named `example.proto`):\r\n\r\n```protobuf\r\nsyntax = \"proto3\";\r\n\r\npackage example;\r\n\r\nservice Test {\r\n  // ...\r\n}\r\n```\r\n\r\n#### Operations\r\n\r\nWithin a [service interface](#services), TypeSpec operations are represented as Protobuf service methods. Each operation in the service interface is converted into an equivalent Protobuf method declaration. For instance, the following specification:\r\n\r\n```typespec\r\nmodel Input {\r\n  @field(1) exampleField: string;\r\n}\r\n\r\nmodel Output {\r\n  @field(1) parsed: uint32;\r\n}\r\n\r\n@Protobuf.service\r\ninterface Example {\r\n  testOperation(...Input): Output;\r\n}\r\n```\r\n\r\nResults in the following `.proto` file:\r\n\r\n```protobuf\r\nmessage Input {\r\n  string exampleField = 1;\r\n}\r\n\r\nmessage Output {\r\n  uint32 parsed = 1;\r\n}\r\n\r\nservice Example {\r\n  rpc TestOperation(Input) returns (Output);\r\n}\r\n```\r\n\r\n#### Streams\r\n\r\nThe Protobuf emitter supports the declaration of an operation's streaming mode using the [`TypeSpec.Protobuf.stream` decorator][protobuf-stream]. The streaming mode is defined using the [`StreamMode`][protobuf-stream-mode] enum. An operation can have one of four streaming modes:\r\n\r\n- `None`: This is the default mode, indicating that neither the request nor the response are streamed.\r\n\r\n  Example: `rpc Example(In) returns (Out);`\r\n\r\n- `In`: This mode indicates that the request is streamed, but the response is received synchronously.\r\n\r\n  Example: `rpc Example(stream In) returns (Out);`\n\ndecorator][protobuf-stream]. The streaming mode is defined using the [`StreamMode`][protobuf-stream-mode] enum. An operation can have one of four streaming modes:\r\n\r\n- `None`: This is the default mode, indicating that neither the request nor the response are streamed.\r\n\r\n  Example: `rpc Example(In) returns (Out);`\r\n\r\n- `In`: This mode indicates that the request is streamed, but the response is received synchronously.\r\n\r\n  Example: `rpc Example(stream In) returns (Out);`\r\n\r\n- `Out`: This mode indicates that the request is sent synchronously, but the response is streamed.\r\n\r\n  Example: `rpc Example(In) returns (stream Out);`\r\n\r\n- `Duplex`: This mode indicates that both the request and response are streamed.\r\n\r\n  Example: `rpc Example(stream In) returns (stream Out);`\r\n\r\n[native-service]: ../../../standard-library/built-in-decorators/#@service\r\n[protobuf-service]: ../reference/decorators/#@TypeSpec.Protobuf.service\r\n[protobuf-package]: ../reference/decorators/#@TypeSpec.Protobuf.package\r\n[protobuf-field]: ../reference/decorators/#@TypeSpec.Protobuf.field\r\n[protobuf-stream]: ../reference/decorators/#@TypeSpec.Protobuf.stream\r\n[protobuf-stream-mode]: ../reference/data-types/#TypeSpec.Protobuf.StreamMode\r\n[protobuf-message]: ../reference/decorators/#@TypeSpec.Protobuf.message\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n", "latency": 4.414231777191162, "response_length": 238}
{"query": "title: How to DRYup commonly-used extension annotations?\n\nquestion: Hey folks. I'm working on hooking up our TypeSpec -> OpenAPI pipeline to generating SDKs with Speakeasy. As part of that, we have to add extension annotations to all of our endpoints that respond with paginated results, e.g.:\n```\n// All operations must have a summary.\n@summary(\"List all alert definitions\")\n@extension(\"x-speakeasy-pagination\", {\ntype: \"url\",\noutputs: {\nnextUrl: \"$.pageInfo.next\",\n}\n})\nop list(@query skipToken?: string, @query pageSize?: int32): {\n@statusCode _: 200;\n@bodyRoot alertDefinitions: {\nalertDefinitions: Definition[];\npageInfo?: PageInfo;\n};\n};\n```\nI'd like to make it so that teams don't have to remember or copypasta this extension annotation and others like it.\nI know that I can at least replace \"x-speakeasy-pagination\" with a string constant, but because object constants are typed, I can't pass one in here as the second argument to extension.\n```\nArgument of type '#{type: \"url\", ref: \"$.pageInfo.next\"}' is not assignable to parameter of type 'unknown'TypeSpec(invalid-argument)\n```\nI was actually sort of surprised by this, but I am new to TypeScript as well.\nI'd appreciate any guidance here. Thank you.", "ground_truth": "I think the answer here is to create a custom decorator that does this for me. :)", "response": "To avoid repetitive extension annotations like `@extension(\"x-speakeasy-pagination\", {...})` across multiple endpoints, you can encapsulate the logic into a reusable decorator by creating a custom TypeSpec library. This approach allows you to define a decorator that automatically applies the desired extension annotation with predefined values. Here's how you can achieve this:\n\n### Steps to Create a Custom Decorator\n\n1. **Set Up a TypeSpec Library**:\n   Use the `tsp init --template library-ts` command to create a new TypeSpec library.\n\n2. **Define the Custom Decorator**:\n   In your library's `src/lib.ts` file, define a decorator that applies the extension annotation. For example:\n\n   ```typescript\n   import { createTypeSpecLibrary, DecoratorContext, Operation } from \"@typespec/compiler\";\n\n   export const $lib = createTypeSpecLibrary({\n     name: \"paginationDecoratorLibrary\",\n     diagnostics: {},\n   });\n\n   export function $pagination(context: DecoratorContext, target: Operation) {\n     context.call(\"extension\", target, \"x-speakeasy-pagination\", {\n       type: \"url\",\n       outputs: {\n         nextUrl: \"$.pageInfo.next\",\n       },\n     });\n   }\n   ```\n\n3. **Register the Decorator**:\n   Ensure the decorator is accessible by importing it in your `lib/main.tsp` file:\n\n   ```typespec\n   import \"../dist/index.js\";\n\n   namespace PaginationDecoratorLibrary;\n   @decorator\n   decorator pagination(target: Operation);\n   ```\n\n4. **Use the Decorator in Your TypeSpec Code**:\n   Replace the repetitive `@extension` annotation with your custom `@pagination` decorator:\n\n   ```typespec\n   import \"paginationDecoratorLibrary\";\n   using PaginationDecoratorLibrary;\n\n   @summary(\"List all alert definitions\")\n   @pagination\n   op list(@query skipToken?: string, @query pageSize?: int32): {\n     @statusCode _: 200;\n     @bodyRoot alertDefinitions: {\n       alertDefinitions: Definition[];\n       pageInfo?: PageInfo;\n     };\n   };\n   ```\n\nThis approach ensures consistency and reduces the risk of errors caused by manual copy-pasting. Teams can simply apply the `@pagination` decorator without worrying about the underlying implementation.", "context": "- document_dir: typespec_docs\n- document_filename: extending-typespec#basics.md\n- document_title: Creating a TypeSpec Library\n- document_link: https://typespec.io/docs/extending-typespec/basics\n- document_content: # extending-typespec#basics.md\n\n# Creating a TypeSpec Library\n\nA TypeSpec library is a package that includes TypeSpec types, decorators, emitters or linters. These libraries are [npm packages](https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry) with some additional TypeSpec-specific metadata and conventions. This guide will walk you through the process of creating a new TypeSpec library, adding types to it, and distributing it on the public npm registry. Further sections will delve into the specifics of creating [decorators](create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md).\r\n\r\nWhile this guide assumes that you'll be using [TypeScript](https://typescriptlang.org) to develop your library, you can skip the TypeScript-related steps if you prefer to use plain JavaScript.\n\n## Prerequisites\n\nYou'll need to have both Node and npm installed. If you're planning to develop multiple libraries simultaneously, it's recommended to set up a monorepo to simplify the development process. TypeSpec itself uses [pnpm](https://pnpm.io/).\n\n## Setting up with templates\n\nYou can use the following templates:\r\n\r\n```bash\n\n# Create a TypeSpec library (Decorators & Linters) with TypeScript enabled.\n\ntsp init --template library-ts\n\n# Create a TypeSpec emitter with TypeScript enabled.\n\ntsp init --template emitter-ts\r\n```\n\n## Standard package structure\n\nHere's a high-level overview of what a TypeSpec package typically contains. Each of these files will be explained in more detail in the following sections.\r\n\r\n- **dist/index.js** - The main file for your Node library\r\n- **lib/main.tsp** - The main file for your TypeSpec types (optional)\r\n- **src/index.ts** - The main file for your Node library in TypeScript\r\n- **src/lib.ts** - The file that defines your TypeSpec library\r\n- **package.json** - Metadata about your TypeSpec package\n\n## Step 1: Initial setup\n\nYou can skip this step if you've used one of the templates above.\n\n### a. Initialize your package directory & package.json\n\nRun the following commands:\r\n\r\n```bash\r\nmkdir myLibrary\r\ncd myLibrary\r\nnpm init\r\n```\r\n\r\nAfter completing the wizard, you'll have a package.json file that defines your TypeSpec library.\r\n\r\nUnlike Node libraries which support CommonJS (cjs), TypeSpec libraries must be ECMAScript Modules. To specify this, open your `package.json` and add the following top-level configuration key:\r\n\r\n```jsonc\r\n  \"type\": \"module\"\r\n```\n\n### b. Install TypeSpec dependencies\n\nRun the following command:\r\n\r\n```bash\r\nnpm install --save-peer @typespec/compiler\r\n```\r\n\r\nYou might need to install other dependencies from the TypeSpec standard library. For example, if you want to use the metadata found in `@typespec/openapi`, you'll need to install that as well.\r\n\r\nRefer to the [dependency section](#step-3-defining-dependencies) for more information on defining your dependencies.\n\n### c. Define your main files\n\nYour package.json needs to refer to two main files: your Node module main file, and your TypeSpec main. The Node module main file is specified by the `\"main\"` key in your package.json file, and it defines the entry point for your library when it's used as a Node library. This must reference a JS file. The TypeSpec main defines the entry point for your library when it's used from a TypeSpec program, and it can reference either a JS file (when your library doesn't contain any TypeSpec types) or a TypeSpec file.\r\n\r\n```jsonc\r\n  \"main\": \"dist/src/index.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"typespec\": \"./lib/main.tsp\"\r\n    },\r\n    // Additional named export are possible\r\n    \"./experimental\": {\r\n      \"typespec\": \"./lib/experimental.tsp\"\r\n    },\r\n    // Wildcard export as well\r\n    \"./lib/*\": {\r\n      \"typespec\": \"./lib/*.tsp\"\r\n    }\r\n  }\r\n```\n\n### d. Install and initialize TypeScript\n\nRun the following commands:\r\n\r\n```bash\r\nnpm install -D typescript\r\nnpx tsc --init --strict\r\n```\r\n\r\nThis will create a `tsconfig.json` file. You'll need to make a few changes to this file. Open `tsconfig.json` and set the following settings:\r\n\r\n```jsonc\r\n\"module\": \"Node16\",           // This and next setting tells TypeScript to use the new ESM import system to resolve types.\r\n\"moduleResolution\": \"Node16\",\r\n\"target\": \"es2019\",\r\n\"rootDir\": \".\",\r\n\"outDir\": \"./dist\",\r\n\"sourceMap\": true,\r\n```\n\n### e. Create `lib.ts`\n\nOpen `./src/lib.ts` and create your library definition that registers your library with the TypeSpec compiler and defines any diagnostics your library will emit. Make sure to export the library definition as `$lib`.\r\n\r\n:::caution\r\nIf `$lib` is not accessible from your library package (for example, `import {$lib} from \"my-library\";`), some features such as linting and emitter option validation will not be available.\r\n:::\r\n\r\nFor example:\r\n\r\n```typescript\r\nimport { createTypeSpecLibrary } from \"@typespec/compiler\";\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"myLibrary\",\r\n  diagnostics: {},\r\n} as const);\r\n\r\n// Optional but convenient, these are meant to be used locally in your library.\r\nexport const { reportDiagnostic, createDiagnostic } = $lib;\r\n```\r\n\r\nDiagnostics are used for linters and decorators, which are covered in subsequent topics.\n\n### f. Create `index.ts`\n\nOpen `./src/index.ts` and import your library definition:\r\n\r\n```typescript\r\n// Re-export $lib so the compiler can access it and register your library correctly.\r\nexport { $lib } from \"./lib.js\";\r\n```\n\n### g. Build TypeScript\n\nTypeSpec can only import JavaScript files, so any changes made to TypeScript sources need to be compiled before they are visible to TypeSpec. To do this, run `npx tsc -p .` in your library's root directory. If you want to re-run the TypeScript compiler whenever files are changed, you can run `npx tsc -p . --watch`.\r\n\r\nAlternatively, you can add these as scripts in your `package.json` to make them easier to invoke. Consider adding the following:\r\n\r\n```jsonc\r\n  \"scripts\": {\r\n    \"clean\": \"rimraf ./dist ./temp\",\r\n    \"build\": \"tsc -p .\",\r\n    \"watch\": \"tsc -p . --watch\",\r\n    \"test\": \"node --test ./dist/test/**/*.test.js\", // Node 22+\r\n    \"test\": \"node --test ./dist/test/\"              // Node 18, 20\r\n  }\r\n```\r\n\r\nYou can then run `npm run build` or `npm run watch` to build or watch your library.\n\n### h. Add your main TypeSpec file\n\nOpen `./lib/main.tsp` and import your JS entrypoint. This ensures that when TypeSpec imports your library, the code to define the library is run. When we add decorators in later topics, this import will ensure those get exposed as well.\r\n\r\n```typespec\r\nimport \"../dist/index.js\";\r\n```\n\n## Step 2: Adding TypeSpec types to your library\n\nOpen `./lib/main.tsp` and add any types you want to be available when users import this library. It's strongly recommended to put these types in a namespace that corresponds with the library name. For example, your `./lib/main.tsp` file might look like:\r\n\r\n```typespec\r\nimport \"../dist/index.js\";\r\n\r\nnamespace MyLibrary;\r\nmodel Person {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n```\n\n## Step 3: Defining dependencies\n\nWhen defining dependencies in a TypeSpec library, follow these rules:\r\n\r\n- Use `peerDependencies` for all TypeSpec libraries (and the compiler) that you use in your own library or emitter.\r\n- Use `devDependencies` for other TypeSpec libraries that are only used in tests.\r\n- Use `dependencies` or `devDependencies` for any other packages, depending on whether they're used in library code or in test/dev scripts.\r\n\r\nTypeSpec libraries are defined using `peerDependencies` to avoid having multiple versions of the compiler or library running at the same time.\r\n\r\n**Example**\r\n\r\n```jsonc\r\n{\r\n  \"dependencies\": {\r\n    \"yaml\": \"~2.3.1\", // This is a regular package this library/emitter will use\r\n  },\r\n  \"peerDependencies\": {\r\n    // These are all TypeSpec libraries this library/emitter depends on\r\n    \"@typespec/compiler\": \"~0.43.0\",\r\n    \"@typespec/http\": \"~0.43.1\",\r\n    \"@typespec/openapi\": \"~0.43.0\",\r\n  },\r\n  \"devDependencies\": {\r\n    // This TypeSpec library is only used in the tests but is not required to use this library.\r\n    \"@typespec/versioning\": \"~0.43.0\",\r\n    // TypeScript is only used during development\r\n    \"typescript\": \"~5.0.2\",\r\n  },\r\n}\r\n```\n\n## Step 4: Testing your TypeSpec library\n\nTypeSpec provides a testing framework to assist in testing libraries. The examples here are shown using Node.js's built-in test framework (available in Node 20+), but any other JS test framework can be used that will provide more advanced features like vitest, which is used in this project.\n\n### a. Add devDependencies\n\nEnsure that you have the following in your `package.json`:\r\n\r\n```json\r\n\"devDependencies\": {\r\n  \"@types/node\": \"~18.11.9\",\r\n  \"source-map-support\": \"^0.5.21\"\r\n}\r\n```\r\n\r\nAlso add a `vitest.config.ts` file at the root of your project.\r\n\r\n```ts\r\nimport { defineConfig, mergeConfig } from \"vitest/config\";\r\n\r\nexport default defineConfig({\r\n  test: {\r\n    environment: \"node\",\r\n    // testTimeout: 10000, // Uncomment to increase the default timeout\r\n    isolate: false, // Your test shouldn't have side effects to this will improve performance.\r\n  },\r\n});\r\n```\n\n### b. Define the testing library\n\nThe first step is to define how your library can be loaded from the test framework. This will allow your library to be reused by other library tests.\r\n\r\n1. Create a new file `./src/testing/index.ts` with the following content\r\n\r\n```ts\r\nimport { createTestLibrary, findTestPackageRoot } from \"@typespec/compiler/testing\";\r\n\r\nexport const MyTestLibrary = createTestLibrary({\r\n  name: \"<name-of-npm-pkg>\",\r\n  // Set this to the absolute path to the root of the package. (e.g. in this case this file would be compiled to ./dist/src/testing/index.js)\r\n  packageRoot: await findTestPackageRoot(import.meta.url),\r\n});\r\n```\r\n\r\n2. Add an `exports` for the `testing` endpoint to `package.json` (update with correct paths)\r\n\r\n```jsonc\r\n{\r\n  // ...\r\n  \"main\": \"dist/src/index.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"default\": \"./dist/src/index.js\",\r\n      \"types\": \"./dist/src/index.d.ts\",\r\n    },\r\n    \"./testing\": {\r\n      \"default\": \"./dist/src/testing/index.js\",\r\n      \"types\": \"./dist/src/testing/index.d.ts\",\r\n    },\r\n  },\r\n}\r\n```\n\n### c. Define the test host and test runner for your library\n\nDefine some of the test framework base pieces that will be used in the tests. There are 2 functions:\r\n\r\n- `createTestHost`: This is a lower-level API that provides a virtual file system.\r\n- `createTestRunner`: This is a wrapper on top of the test host that will automatically add a `main.tsp` file and automatically import libraries.\r\n\r\nCreate a new file `test/test-host.js` (change `test` to be your test folder)\r\n\r\n```ts\r\nimport { createTestHost, createTestWrapper } from \"@typespec/compiler/testing\";\r\nimport { RestTestLibrary } from \"@typespec/rest/testing\";\r\nimport { MyTestLibrary } from \"../src/testing/index.js\";\r\n\r\nexport async function createMyTestHost() {\r\n  return createTestHost({\r\n    libraries: [RestTestLibrary, MyTestLibrary], // Add other libraries you depend on in your tests\r\n  });\r\n}\r\nexport async function createMyTestRunner() {\r\n  const host = await createMyTestHost();\r\n  return createTestWrapper(host, { autoUsings: [\"My\"] });\r\n}\r\n```\n\n### d. Write tests\n\nAfter setting up that infrastructure you can start writing tests. By default Node.js will run all files matching these patterns:\r\n\r\n```\r\n**/*.test.?(c|m)js\r\n**/*-test.?(c|m)js\r\n**/*_test.?(c|m)js\r\n**/test-*.?(c|m)js\r\n**/test.?(c|m)js\r\n**/test/**/*.?(c|m)js\r\n```\r\n\r\n[See nodejs doc](https://nodejs.org/api/test.html)\r\n\r\n```ts\r\nimport { createMyTestRunner } from \"./test-host.js\";\r\nimport { describe, beforeEach, it } from \"node:test\";\r\n\r\ndescribe(\"my library\", () => {\r\n  let runner: BasicTestRunner;\r\n\r\n  beforeEach(async () => {\r\n    runner = await createMyTestRunner();\r\n  });\r\n\r\n  // Check everything works fine\r\n  it(\"does this\", async () => {\r\n    const { Foo } = await runner.compile(`\r\n      @test model Foo {}\r\n    `);\r\n    strictEqual(Foo.kind, \"Model\");\r\n  });\r\n\r\n  // Check diagnostics are emitted\r\n  it(\"errors\", async () => {\r\n    const diagnostics = await runner.diagnose(`\r\n       model Bar {}\r\n    `);\r\n    expectDiagnostics(diagnostics, { code: \"...\", message: \"...\" });\r\n  });\r\n});\r\n```\r\n\r\n#### e. `@test` decorator\r\n\r\nThe `@test` decorator is a decorator loaded in the test environment. It can be used to collect any decorable type.\r\nWhen using the `compile` method it will return a `Record<string, Type>` which is a map of all the types annotated with the `@test` decorator.\r\n\r\n```ts\r\nconst { Foo, CustomName } = await runner.compile(`\r\n  @test model Foo {}\r\n\r\n  model Bar {\r\n    @test(\"CustomName\") name: string\r\n  }\r\n`);\r\n\r\nFoo; // type of: model Foo {}\r\nCustomName; // type of : Bar.name\r\n```\r\n\r\n#### f. Install VS Code extension for the test framework\r\n\r\nIf you are using VS Code, you can install the [Node test runner](https://marketplace.visualstudio.com/items?itemName=connor4312.nodejs-testing) to run your tests from the editor. This will also allow you to easily debug your tests.\r\n\r\nAfter installing the extension, you should be able to discover, run, and debug your tests from the test explorer.\n\n## Step 5: Publishing your TypeSpec library\n\nTo publish your library to the public npm registry, follow the instructions in the [npm documentation](https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages).\n\n## Step 6: Importing your TypeSpec library\n\nOnce your TypeSpec library is published, users can install and use it just like any of the standard TypeSpec libraries. First, they need to install it:\r\n\r\n```bash\r\nnpm install $packageName\r\n```\r\n\r\nNext, they can import it into their TypeSpec program and use the namespace (if desired):\r\n\r\n```typespec\r\nimport \"MyLibrary\";\r\nusing MyLibrary;\r\n\r\nmodel Employee extends Person {\r\n  job: string;\r\n}\r\n```\n\n## Step 7: Next steps\n\nTypeSpec libraries can contain more than just types. For more details on how to write [decorators](./create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md), refer to the subsequent topics.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#emitters-basics.md\n- document_title: Emitters\n- document_link: https://typespec.io/docs/extending-typespec/emitters-basics\n- document_content: # extending-typespec#emitters-basics.md\n\n# Emitters\n\nTypeSpec emitters are libraries that utilize various TypeSpec compiler APIs to reflect on the TypeSpec compilation process and generate artifacts. The TypeSpec standard library includes emitters for OpenAPI version 3.0, JSON Schema, and Protocol Buffers (Protobuf). However, you might want to emit TypeSpec to a different output format. One of the main advantages of TypeSpec is its ease of use as a single source of truth for all data shapes, and the simplicity of creating an emitter contributes significantly to this.\n\n## Emitter design\n\nTypeSpec is designed to support many protocols and many output formats. It is important that an emitter is designed to select only the part of the TypeSpec spec that makes sense for them. Having emitters designed correctly will allow a user to define multiple layers of their API in a single TypeSpec document, allowing tools to view the entire picture of the service.\r\n\r\nFor example assuming a User wants to emit `openapi3` and `protobuf` but each API has a different set of operations and is split into different namespaces.\r\n\r\nIt is important that there is a way for the openapi3 emitter and protobuf emitter to select only the part of the spec that applies to them. For instance, the protobuf emitter should not try to emit the http service namespace and fail because of missing annotations.\n\n## Getting started\n\nTypeSpec emitters are a unique type of TypeSpec library, so they follow the same initial setup instructions.\r\n\r\nSet up the boilerplate for an emitter using our template:\r\n\r\n```bash\r\ntsp init --template emitter-ts\r\n```\r\n\r\nAlternatively, follow [these steps](./basics.md) to initialize a TypeSpec library.\n\n## $onEmit\n\nA TypeSpec emitter exports a function named `$onEmit` from its main entry point. It takes two arguments:\r\n\r\n- _context_: The current context, including the current program being compiled\r\n- _options_: Custom configuration options selected for this emitter\r\n\r\nFor instance, the following code will write a text file to the output directory:\r\n\r\n```typescript\r\nimport { EmitContext, emitFile, resolvePath } from \"@typespec/compiler\";\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  if (!context.program.compilerOptions.noEmit) {\r\n    await emitFile(context.program, {\r\n      path: resolvePath(context.emitterOutputDir, \"hello.txt\"),\r\n      content: \"Hello world\\n\",\r\n    });\r\n  }\r\n}\r\n```\r\n\r\nYou can now compile a TypeSpec program by passing your library name to --emit, or add it to your `tspconfig.yaml`.\n\n### Custom configuration options\n\nTo provide custom options to your emitter, you need to register the options with the compiler by setting `emitter.options` in your library definition to the JSON schema for the options you want to use. The compiler provides a helper to simplify this:\r\n\r\n- _JSONSchemaType_: Takes a TypeScript interface and returns a type that assists you in filling in the JSON schema for that type.\r\n\r\nThe following example extends the hello world emitter to be configured with a name:\r\n\r\n```ts file=src/internal-lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"MyEmitter\",\r\n  diagnostics: {\r\n    // Add diagnostics here.\r\n  },\r\n  state: {\r\n    // Add state keys here for decorators.\r\n  },\r\n});\r\n```\r\n\r\n```ts file=src/lib.ts\r\nimport {\r\n  JSONSchemaType,\r\n  createTypeSpecLibrary,\r\n  EmitContext,\r\n  resolvePath,\r\n} from \"@typespec/compiler\";\r\nimport { internalLib } from \"./lib.js\";\r\n\r\nexport interface EmitterOptions {\r\n  \"target-name\": string;\r\n}\r\n\r\nconst EmitterOptionsSchema: JSONSchemaType<EmitterOptions> = {\r\n  type: \"object\",\r\n  additionalProperties: false,\r\n  properties: {\r\n    \"target-name\": { type: \"string\", nullable: true },\r\n  },\r\n  required: [],\r\n};\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  internal: internalLib,\r\n  emitter: {\r\n    options: EmitterOptionsSchema,\r\n  },\r\n});\r\n\r\nexport async function $onEmit(context: EmitContext<EmitterOptions>) {\r\n  const outputDir = resolvePath(context.emitterOutputDir, \"hello.txt\");\r\n  const name = context.options.targetName;\r\n  await context.program.host.writeFile(outputDir, `hello ${name}!`);\r\n}\r\n```\n\n### `absolute-path`\n\nSpecify that the value for this option should resolve to an absolute path. e.g. `\"{project-root}/dir\"`.\r\n\r\n:::important\r\nIt is recommended that all options that involve path use this. Using relative path can be confusing for users on as it is not clear what the relative path is relative to. And more importantly relative path if not careful are resolved relative to the `cwd` in Node file system which result in spec only compiling from the the project root.\r\n:::\r\n\r\nExample:\r\n\r\n```js\r\n{\r\n  \"asset-dir\": { type: \"string\", format: \"absolute-path\", nullable: true },\r\n}\r\n```\n\n### Configuration options convention\n\n- Name options `kebab-case`. So it can be inline with the rest of the cli\r\n- Name options should not contain dots (`.`). Using a dot will conflict with using nested configuration values.\r\n- An option called `output-dir` can be created and should override the compiler `output-dir`\r\n\r\n#### Emitter options vs. decorators\r\n\r\nThe general guideline is to use a decorator when the customization is intrinsic to the API itself. In other words, when all uses of the TypeSpec program would use the same configuration. This is not the case for `outputFilename` because different users of the API might want to emit the files in different locations depending on how their code generation pipeline is set up.\n\n## Emitting TypeSpec types to assets on disk\n\nOne of the main tasks of an emitter is to identify types to emit. There are three primary methods:\r\n\r\n1. The [emitter framework](./emitter-framework.md), which simplifies the process of emitting all your TypeSpec types (or a subset, if you prefer).\r\n2. The Semantic Walker, which allows you to easily execute code for every type in the program.\r\n3. Custom traversal, which offers more flexibility than the previous two methods, albeit with some added complexity.\n\n### Emitter Framework\n\nThe emitter framework handles many complex issues for you while offering an easy-to-use API to convert your TypeSpec into source code or other object graphs. Visit the [emitter framework](./emitter-framework.md) page for more information.\n\n### Semantic Walker\n\nThe Semantic Walker visits every type in the TypeSpec program and calls any callbacks you provide for that type. To use it, import `navigateProgram` from `@typespec/compiler`. Starting a walk requires two parameters - the program to walk, and an object with callbacks for each type. For instance, if we want to do something for every model in the program, we could do the following in our `$onEmit` function:\r\n\r\n```typescript\r\nnavigateProgram(program, {\r\n  model(m) {\r\n    // emit m\r\n  },\r\n});\r\n```\r\n\r\nYou can provide a callback for every kind of TypeSpec type. The walker will call your callback pre-order, i.e., it will invoke your callback as soon as it encounters a type for the first time. You can invoke a callback post-order instead by prefixing the type name with `exit`, for example, `exitModel(m)`.\r\n\r\nNote that the semantic walker will visit all types in the program, including built-in TypeSpec types and TypeSpec types defined by any libraries you're using. You must filter out any types you do not intend to emit. Sometimes this can be quite challenging, so a custom traversal may be easier.\n\n### Custom traversal\n\nOften, you'll want to emit specific types, such as types that have a particular decorator or are in a specific namespace. In such cases, it's often easier to write a custom traversal to find and emit those types. Once you have a type, you can access its various fields and emit those types as well if needed.\r\n\r\nFor instance, let's say we want to emit a text file of model names but only if it has an `@emitThis` decorator. We could filter out such models in the Semantic Walker `model` callback, but it's more efficient to implement `@emitThis` such that it keeps a list of all the types it's attached to and iterate that list. We can then traverse into types it references if needed.\r\n\r\nThe following example will emit models with the `@emitThis` decorator and also any models referenced by that model.\r\n\r\n[See creating decorator documentation for more details](./create-decorators.md)\r\n\r\n```typescript\r\nimport { DecoratorContext, Model } from \"@typespec/compiler\";\r\nimport { StateKeys } from \"./lib.js\";\r\n\r\n// Decorator Setup Code\r\n\r\n// @emitThis decorator\r\nexport function $emitThis(context: DecoratorContext, target: Model) {\r\n  context.program.stateSet(StateKeys.emitThis).add(target);\r\n}\r\n\r\nexport async function $onEmit(context: EmitContext) {\r\n  for (const model of program.stateSet(emitThisKey)) {\r\n    emitModel(model);\r\n  }\r\n}\r\n\r\nfunction emitModel(model: Model) {\r\n  // emit this model\r\n  for (const prop of model.properties.values()) {\r\n    // recursively emit models referenced by the parent model\r\n    emitModel(prop.type);\r\n  }\r\n}\r\n```\n\n### Resolving a TypeSpec type\n\nSometimes you might want to access a known TypeSpec type in the type graph, for example, a model that you have defined in your library.\r\n\r\nA helper is provided on the program to do that.\r\n\r\n```ts\r\nprogram.resolveTypeReference(reference: string): Type | undefined;\r\n```\r\n\r\nThe reference must be a valid TypeSpec reference (like you would have it in a TypeSpec document)\r\n\r\n**Example**\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"TypeSpec.string\"); // Resolve TypeSpec string intrinsic type\r\nprogram.resolveTypeReference(\"MyOrg.MyLibrary.MyEnum\"); // Resolve `MyEnum` defined in `MyOrg.MyLibrary` namespace.\r\n```\r\n\r\nError example\r\n\r\n```ts\r\nprogram.resolveTypeReference(\"UnknownModel\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\nprogram.resolveTypeReference(\"model Foo {}\"); // Resolve `[undefined, diagnostics]` where diagnostics is an array of diagnostic explaining why reference is invalid.\r\n```\n\n## Emitting files to disk\n\nSince an emitter is a Node library, you could use standard `fs` APIs to write files. However, this approach has a drawback - your emitter will not work in the browser, and will not work with the test framework that depends on storing emitted files in an in-memory file system.\r\n\r\nInstead, use the compiler's `host` interface to access the file system. This API is equivalent to the Node API but works in a broader range of scenarios.\r\n\r\nTo know where to emit files, the emitter context has an `emitterOutputDir` property that is automatically resolved using the `emitter-output-dir` built-in emitter options. By default, this is set to `{cwd}/tsp-output/{emitter-name}`, but it can be overridden by the user. Do not use the `compilerOptions.outputDir`.\n\n## Dealing with scalars\n\nScalars are types in TypeSpec that are most likely represented by a primitive or built-in data structure in the target language.\r\n\r\nThe recommended logic for emitting a scalar is as follows:\r\n\r\n1. If the scalar is a known scalar (e.g., `int32`), emit the known mapping.\r\n2. Otherwise, check the scalar `baseScalar` and go back to step 1.\r\n   2.1 After resolving which scalar to use, apply any decorators.\r\n\r\n:::note\r\nIf the scalar is generic and doesn't have a mapping (e.g., integer), we recommend substituting it with the next closest mapping (e.g., integer->int64) and emitting a warning.\r\n:::\n\n### Examples\n\n```tsp\r\n@minValue(10)\r\nscalar myInt32 extends int32;\r\n\r\n@minValue(20)\r\nscalar specializedInt32 extends myInt32;\r\n```\r\n\r\n| Scalar             | Expected type | Description                                                                                                                                 |\r\n| ------------------ | ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| `int16`            | `int16`       | Simple case, emitter can know it is an int16                                                                                                |\r\n| `myInt32`          | `int32`       | Emitter doesn't know what myInt32 is. Check baseScalar, sees it is an int32, applies minValue decorator.                                    |\r\n| `specializedInt32` | `int32`       | Emitter doesn't know what specializedInt32 is. Check baseScalar, finds myInt32 knows that it is an int32 now and applies minValue override. |\r\n| `float`            | `float64`     | Emitter knows float but doesn't have a mapping. Emit `float64` and a warning.                                                               |\n\n## Managing Default Values\n\nSeveral TypeSpec types have a `default` property that can be used to specify a default value. For example, the following model has a default value of `true` for the `isActive` property:\r\n\r\n```tsp\r\nmodel User {\r\n  isActive?: boolean = true;\r\n}\r\n```\r\n\r\nThese values can be accessed in the emitter using the `default` property on the `ModelProperty` type.\r\n\r\n```ts\r\nconst modelProp: ModelProperty = ...;   // the isActive ModelProperty type\r\nconst defaultValue = modelProp.default; // value: true\r\n```\r\n\r\nIt's important that emitters handle default values consistently. Default values SHOULD NOT be used as client-side default values. Instead, they should be used to specify a default value for the server-side implementation. For example, if a model property has a default value of `true`, the server-side implementation should use that value if the client does not provide a value. Default values SHOULD be expressed in documentation to properly communicate the server-side default.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n", "latency": 17.110570669174194, "response_length": 2144}
{"query": "title: How to get specified version of Http services with 'getAllHttpServices'\n\nquestion: Hello team,\nCurrently we are using the function 'getAllHttpServices' from '@typespec/http' to extract http services from typespec files. Now we are planning to use the versioning decorators in those typespecs to manage versions. Will add 'api-version' in the emitter options as the target version.\nI just want to check if 'getAllHttpServices' supports getting specified version of http services from those decorated typespecs (by giving any options?). If not, what is the appropriate way achieving that?\nThanks.", "ground_truth": "hello, it seems I find a way for this. Seems I need to call 'createSdkContext' to re-create the context instead of using the passed in default context.", "response": "The `getAllHttpServices` function from `@typespec/http` does not directly support filtering HTTP services by version. To achieve version-specific behavior, you can use the `@typespec/versioning` library and specify the target version in the emitter options using the `api-version` configuration flag. This flag allows you to control which version of the API surface is generated or accessed.\n\nFor example, in your `tspconfig.yaml`, you can specify the target version:\n\n```yaml\ntspconfig.yaml:\noptions:\n  \"@typespec/http\":\n    api-version: \"v2\"\n```\n\nThis configuration ensures that only the HTTP services corresponding to the specified version (`v2` in this case) are included in the generated output. If you need to work programmatically with version-specific services, you can use decorators like `@added`, `@removed`, or `@renamedFrom` to annotate version-specific changes in your TypeSpec definitions.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#versioning#guide.md\n- document_title: Tutorial\n- document_link: https://typespec.io/docs/libraries/versioning/guide\n- document_content: # libraries#versioning#guide.md\n\n# Tutorial\n\n## Implementing versioned APIs\n\nThe primary role of the TypeSpec.Versioning library is to enable API versioning. Let's start with an API that lacks versioning.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nTo introduce versioning to this API, we need to use the `@versioned` decorator on the namespace and define an enum that outlines the supported versions.\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n```\n\n## Declaring versioned dependencies\n\nBoth versioned and unversioned services can declare their dependencies on versioned TypeSpec libraries. This is achieved using the `@useDependency` decorator. For unversioned services, this is declared on the namespace. For versioned services, it's declared on the versioned enum.\r\n\r\nFor example, if our unversioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager Unversioned\" })\r\n@useDependency(Azure.Core.v1_0_Preview_1)\r\nnamespace Contoso.WidgetManager.Unversioned;\r\n```\r\n\r\nIf our versioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n}\r\n```\r\n\r\nLet's say we introduce a new version to our service, and it uses features from a newer version of the Azure.Core library. We can declare that dependency like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.v1_0_Preview_1)\r\n  v1,\r\n\r\n  @useDependency(Azure.Core.v1_0_Preview_2)\r\n  v2,\r\n}\r\n```\n\n## Versioning APIs\n\nreflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    description:\r\n      type: string\r\n  required:\r\n    - id\r\n```\r\n\r\nHowever, the OpenAPI definition for versions 1 and 2 still reflect the original name and the mandatory nature of the property:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\r\n    name:\r\n      type: string\r\n  required:\r\n    - id\r\n    - name\r\n```\r\n\r\nThis is a common pattern with the versioning decorators. The TypeSpec should represent the _current state_ of the API. The decorators indicate the version at which this definition became accurate and, depending on the decorator, the other parameters reflect the previous values to retain that information.\n\nThe versioning library simplifies the process of versioning APIs. Let's start with a basic example. Assume we have a service with a single API that returns a list of widgets. We can define that API like this:\r\n\r\n```typespec\r\nusing Versioning;\r\nusing Rest;\r\nusing Http;\r\n\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  v1,\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: string;\r\n  message?: string;\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\nop list(): Widget[] | Error;\r\n```\r\n\r\nNow, let's suppose that in version 2 of the service, we add a get operation to retrieve a single widget. We can add that like this:\r\n\r\n```typespec\r\nenum Versions {\r\n  v1,\r\n  v2,\r\n}\r\n\r\nmodel Widget {\r\n  @key\r\n  id: string;\r\n\r\n  name: string;\r\n}\r\n\r\n@route(\"/widget\")\r\nop list(): Widget[] | Error;\r\n\r\n@added(Versions.v2)\r\n@route(\"/widget/{id}\")\r\nop get(...Resource.KeysOf<Widget>): Widget | Error;\r\n```\r\n\r\nNow, let's suppose that in version 3 of the service, we realize that `name` is not accurate and that this field should be called `description`. Also, we decide that the description should be optional, not mandatory. We can implement these changes like this:\r\n\r\n```typespec\r\nmodel Widget {\r\n  @key\r\n  widgetId: string;\r\n\r\n  @renamedFrom(Versions.v3, \"name\")\r\n  @madeOptional(Versions.v3)\r\n  description?: string;\r\n}\r\n```\r\n\r\nWe made the change to the actual model property so that it now reflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\r\n\r\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\r\n\r\n```yaml\r\nWidget:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: string\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#09versioning.mdx\n- document_title: Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/09versioning\n- document_content: # howtos#generate-client-libraries#09versioning.mdx\n\n# Versioning\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis doc details what emitters will generate for versioned specs\n\n## Single api Version\n\nIf there is just one api version in the spec, we will generate the api surface area for that one version.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\nstatic ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01\")\r\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\nclient.stable_functionality(stable_model) # call goes through\r\n\r\nwith pytest.expect(ImportError):\r\n  preview_model = models.PreviewModel(preview_functionality=\"not present\")\r\n\r\nwith pytest.expect(AttributeError):\r\n  client.preview_functionality({\"previewFunctionality\": \"not present\"})\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api-version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\n//neither PreviewModel nor PreviewFunctionality will be generated\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\n// neither PreviewModel nor previewFunctionality will be generated\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n# python allows you to override the api version, even if only one version is defined in the spec\n\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01\"\r\n```\r\n\r\n```typescript\r\n// there's no apiVersion defined in the all the operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n## Multiple api versions\n\nThe configuration flag `api-version` allows you to toggle the behavior that our emitters will generate.\r\n\r\nWe will get the versioning information from the `Versions` enum that you pass to the `@versioned` decorator from the `@typespec/versioning` library.\r\n\r\n> NOTE: The ordering of the values in the `Versions` enum is very important. We use this information to determine the order of versions. Our default value will be the **last entry** in the `Versions` list\n\n### Default\n\nBy default our emitters will only generate the surface used by the latest api version if there are multiple defined. This includes generating only the models used in the surface area of the latest api version.\r\n\r\nDocumentation and enums showing the available api versions will still include all of the known api versions, meaning there will be documentation for both the preview and stable releases.\r\n\r\nFor the below example, all languages will generate the api surface of default version `v2023_11_01`. There will be no generation of the operation `previewFunctionality`, and we will also not generate the `PreviewModel` because it's only used in `previewFunctionality`, and therefore is not used in the api surface of `v2023_11_01`.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01\"\n\n### Override to a specific version\n\nYou can override the signature to return the api surface area for a specific api version.\r\n\r\nIn this example, you can see how this change is made in tspconfig.yaml, and we are going to override to return the preview api surface area for our spec. The preview api surface area contains all of the functionality.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=...)\n\n# client's api_version will be \"2023-11-01-preview\"\n\nstable_model = models.StableModel(stable_feature=\"present\")\r\nprint(stable_model)\r\npreview_client.stable_functionality(stable_model) # call goes through\r\n\r\npreview_model = models.PreviewModel(preview_functionality=\"present\")\n\n# the model is generated as part of the api surface\n\npreview_client.preview_functionality(preview_model) # call goes through\r\n\r\n````\r\n\r\n```csharp\r\n// ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n// client's api-version will be \"2023-11-01-preview\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n````\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01_PREVIEW(\"2023-11-01-preview\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2023_11_01_PREVIEW\r\n}\r\n\r\n// Client API\r\nServiceClientClient serviceClientClient = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's api-version will be 2023-11-01-preview\r\n\r\nStableModel stableModel = new StableModel(\"present\");\r\n\r\n// call goes through\r\nserviceClientClient.stableFunctionality(stableModel);\r\n\r\nPreviewModel previewModel = new PreviewModel(\"present\");\r\n// call goes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\n\ngoes through\r\nserviceClientClient.previewFunctionality(previewModel);\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\r\n\r\nwith pytest.expect(ValueError) as ex:\r\n  client.preview_functionality(preview_model)\r\nassert \"preview_functionality is not available in api version 2023-11-01\" in str(ex)\r\n\r\npreview_client = MyServiceClient(endpoint=..., credential=..., api_version=\"2023-11-01-preview\")\r\n\r\npreview_client.preview_functionality(preview_model) # call goes through\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01-preview\". </summary>\r\n    V2023_11_01_Preview = 1,\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's api_version will be \"2023-11-01\"\r\n\r\n//call PreviewFunctionality\r\nPreviewModel previewModel = new PreviewModel(\"<betaFeature>\");\r\nResponse response = client.PreviewFunctionality(previewModel);\r\n\r\n//call StableFunctionality\r\nStableModel stableModel = new StableModel(\"<stableFeature>\");\r\nResponse response = client.StableFunctionality(stableModel);\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01_Preview);\r\nServiceClient client = new ServiceClient(endpoint, options);\r\n//You can specify the service api-version when create client instance. Now client's api_version will be \"2023-11-01-preview\"\r\n```\r\n\r\n```typescript\r\n// there is no apiVersion parameters defined in all operations, TypeScript emitter will ignore it.\r\n```\r\n\r\n```java\r\n\r\n```\r\n\r\n```go\r\n\r\n```\r\n\r\n</ClientTabs>\n\n### Override to return all\n\nYou can also override the signature to return the combined api surface area of all of the separate api versions. Different languages have different support for versioning validation.\r\n\r\nIn the following examples, you can observe how this change is made in `tspconfig.yaml`.\r\n\r\n<ClientTabs>\r\n\r\n<ClientTabItem lang=\"typespec\">\r\n\r\n```yaml title=tspconfig.yaml\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-csharp\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-ts\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-java\":\r\n  api-version: \"2023-11-01-preview\"\r\n  \"@azure-tools/typespec-go\":\r\n  api-version: \"2023-11-01-preview\"\r\n```\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\n\r\nusing Versioning;\r\nusing Http;\r\n\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\n\r\nenum Versions {\r\n  v2023_11_01_preview: \"2023-11-01-preview\",\r\n  v2023_11_01: \"2023-11-01\",\r\n}\r\n\r\nmodel PreviewModel {\r\n  betaFeature: string;\r\n}\r\n\r\nmodel StableModel {\r\n  stableFeature: string;\r\n}\r\n\r\n@added(Versions.v2023_11_01_preview)\r\n@removed(Versions.v2023_11_01)\r\nop previewFunctionality(@body previewModel: PreviewModel): void;\r\n\r\nop stableFunctionality(@body stableModel: StableModel): void;\r\n```\r\n\r\n</ClientTabItem>\r\n\r\n```python\r\nimport pytest\r\nfrom my.service import MyServiceClient, models\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\n\n## Overriding the Client Api Version Parameter\n\nonto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\r\nServiceClient clientWithSpecifiedApiVersion = new ServiceClient(endpoint, options);\r\n//client's version will be \"2023-11-01\"\r\nResponse response = client.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```typescript\r\n// TODO\r\n```\r\n\r\n```java\r\n// ServiceVersion enum\r\npublic enum ServiceServiceVersion implements ServiceVersion {\r\n    V2023_11_01(\"2023-11-01\");\r\n    V2024_04_01(\"2024-04-01\");\r\n\r\n    public static ServiceServiceVersion getLatest() {} // V2024_04_01\r\n}\r\n\r\n// Client API\r\nServiceClientClient client = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    .buildClient();\r\n// client's version will be 2024-04-01\r\n\r\nServiceClientClient clientWithSpecifiedApiVersion = new ServiceClientClientBuilder()\r\n    // other configurations\r\n    // override the api version, even if only one version is defined in the spec\r\n    .serviceVersion(ServiceServiceVersion.V2023_11_01)\r\n    .buildClient();\r\n// client's version will be 2023-11-01\r\n\r\nclient.get(); // version parameter is elevated onto the client\r\n```\r\n\r\n```go\r\n// TODO\r\n```\r\n\r\n</ClientTabs>\n\nBy default, we find api version parameters in specs based off of names. There is special logic we do with api version parameters:\r\n\r\n1. These api version parameters get elevated up to the client level (if the service is versioned)\r\n2. We auto-add api version information to next links when paging\r\n3. We set the client default for these parameters to be the default api version for your service.\r\n\r\nThere are cases where you have an api-versioning parameter without the explicit name `api-version`. In these cases, you can use the `@isApiVersion` decorator to override and explicitly say whether that parameter is an api version param or not.\r\n\r\n<ClientTabs>\r\n\r\n```typespec\r\nimport \"@typespec/versioning\";\r\nimport \"@typespec/http\";\r\nimport \"@azure-tools/typespec-client-generator-core\";\r\nusing Versioning;\r\nusing Http;\r\nusing Azure.ClientGenerator.Core;\r\n@versioned(My.Service.Versions)\r\n@service\r\nnamespace My.Service;\r\nenum Versions {\r\n  v2023_11_01: \"2023-11-01\",\r\n  v2024_04_01: \"2024-04-01\",\r\n}\r\nop get(\r\n  @isApiVersion\r\n  @header(\"x-ms-version\")\r\n  version: string,\r\n): void;\r\n```\r\n\r\n```python\r\nfrom my.service import MyServiceClient\r\n\r\nclient = MyServiceClient(endpoint=..., credential=...)\r\nprint(client.version) # == \"2024-04-01\", since that is the default\r\n\r\nclient_with_specified_api_version = MyServiceClient(endpoint=..., credential=..., version=\"2023-11-01\")\r\nprint(client.version) # == \"2023-11-01\", since we specified\r\n\r\nretval = client.get() # version is elevated onto the client\r\n```\r\n\r\n```csharp\r\n//ServiceVersion enum\r\npublic enum ServiceVersion\r\n{\r\n    /// <summary> Service version \"2023-11-01\". </summary>\r\n    V2023_11_01 = 1,\r\n    /// <summary> Service version \"2024-04-01\". </summary>\r\n    v2024_04_01 = 2,\r\n}\r\n\r\nUri endpoint = new Uri(\"<https://my-service.azure.com>\");\r\n\r\nServiceClient client = new ServiceClient(endpoint);\r\n//client's version will be \"2024-04-01\"\r\nServiceClientOptions options = new ServiceClientOptions(ServiceVersion.V2023_11_01);\n", "latency": 12.356129169464111, "response_length": 904}
{"query": "title: Facing Error error @azure-tools/typespec-azure-resource-manager/template-type-constraint-no-met\n\nquestion: I'm trying to add an extension resource named approvals.\nHere are my changes https://dev.azure.com/msazuredev/VirtualEnclaves/_git/ve-common/commit/2b8213089d00928031792d571aa6fc92cfe57cbc?refName=refs%2Fheads%2Fdrkapoor%2FtypespecChanges. I keep facing this error when i compile the changes, `@azure-tools/typespec-azure-resource-manager/template-type-constraint-no-met`\n![alt text](image-1.png)\nNeeded help figuring out where I'm going wrong. Thanks", "ground_truth": "For question about azure libraries please ask them in the Teams channel or file bug in this repo https://github.com/Azure/typespec-azure.\nThis error tells you the resource you are passing is not an arm resource. It should extend on of the TrackedResource, ProxyResource, etc. See [docs](https://azure.github.io/typespec-azure/docs/howtos/ARM/resource-type)", "response": "Sorry, I can't answer this question. To assist you further, I need more details about the specific TypeSpec code changes you made and the context of the error. Could you provide the relevant code snippet or describe the changes in detail?", "context": "- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#arm-rules.md\n- document_title: ARM Rules, TypeSpec Linting, and Suppression\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\n- document_content: # howtos#arm#arm-rules.md\n\n# ARM Rules, TypeSpec Linting, and Suppression\n\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\r\n\r\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\n\n## ARM RPC Rules\n\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\r\n\r\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\n\n## Detecting and Suppressing Rule Violations at Design Time\n\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\r\n\r\nHere is an example of a linter warning:\r\n\r\n```bash\r\nDiagnostics were reported during compilation:\r\n\r\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\r\n> 38 |   /** Gets the Zero Trust URL for this resource */\r\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n> 39 |   @post\r\n     | ^^^^^^^\r\n> 40 |   getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nFound 1 warning.\r\n\r\n```\r\n\r\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\r\n\r\n```typespec\r\n  #suppress \"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\" \"This is a sample suppression.\"\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\r\n\r\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\r\n\r\n```typespec\r\n  @armResourceAction(ZeroTrustResource)\r\n  /** Gets the MAA URL for this resource */\r\n  @post\r\n  getZeroTrustUrl(...ResourceInstanceParameters<ZeroTrustResource>): ZeroTrustUrl | ErrorResponse;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-resource-manager#rules#arm-no-record.md\n- document_title: arm-no-record\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/rules/arm-no-record\n- document_content: # libraries#azure-resource-manager#rules#arm-no-record.md\n\n# arm-no-record\n\n```text title=- Full name-\r\n@azure-tools/typespec-azure-resource-manager/arm-no-record\r\n```\r\n\r\nARM requires Resource provider teams to define types explicitly. This is to ensure good customer experience in terms of the discoverability of concrete type definitions.\r\n\r\n#### ❌ Incorrect\r\n\r\n```tsp\r\nmodel Address {\r\n  address: Record<string>;\r\n  city: string;\r\n  state: string;\r\n}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n  state: string;\r\n  country: string;\r\n  postalCode: string;\r\n}\r\n```\r\n\r\n#### ❌ Incorrect\r\n\r\n```tsp\r\nmodel Address is Record<string>;\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n  state: string;\r\n  country: string;\r\n  postalCode: string;\r\n}\r\n```\r\n\r\n#### ❌ Incorrect\r\n\r\n```tsp\r\nmodel Address extends Record<string> {}\r\n```\r\n\r\n#### ✅ Correct\r\n\r\n```tsp\r\nmodel Address {\r\n  street: string;\r\n  city: string;\r\n  state: string;\r\n  country: string;\r\n  postalCode: string;\r\n}\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: libraries#azure-resource-manager#reference#data-types.md\n- document_title: Data types\n- document_link: https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types\n- document_content: # libraries#azure-resource-manager#reference#data-types.md\n\n# Data types\n\n## Azure.ResourceManager\n\n### `ArmAcceptedLroResponse` {#Azure.ResourceManager.ArmAcceptedLroResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmAcceptedLroResponse<Description, LroHeaders>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name        | Description                                                                        |\r\n| ----------- | ---------------------------------------------------------------------------------- |\r\n| Description | The description of the response status (defaults to `Resource operation accepted`) |\r\n| LroHeaders  | Optional. The lro headers that appear in the Accepted response                     |\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `202` | The status code. |\n\n### `ArmAcceptedResponse` {#Azure.ResourceManager.ArmAcceptedResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmAcceptedResponse<Message, ExtraHeaders>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name         | Description                                                                        |\r\n| ------------ | ---------------------------------------------------------------------------------- |\r\n| Message      | The description of the response status (defaults to `Resource operation accepted`) |\r\n| ExtraHeaders | Additional headers in the response. Default includes Retry-After header            |\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `202` | The status code. |\n\n### `ArmAsyncOperationHeader` {#Azure.ResourceManager.ArmAsyncOperationHeader}\n\nThe standard header for asynchronous operation polling\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmAsyncOperationHeader<StatusMonitor, UrlValue, FinalResult>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name          | Description                                       |\r\n| ------------- | ------------------------------------------------- |\r\n| StatusMonitor | The status monitor type for lro polling           |\r\n| UrlValue      | The value type of the Azure-AsyncOperation header |\r\n| FinalResult   | The logical final result of the operation         |\r\n\r\n#### Properties\r\n\r\n| Name                 | Type       | Description                  |\r\n| -------------------- | ---------- | ---------------------------- |\r\n| azureAsyncOperation? | `UrlValue` | A link to the status monitor |\n\n### `ArmCombinedLroHeaders` {#Azure.ResourceManager.ArmCombinedLroHeaders}\n\nProvide Both Azure-AsyncOperation and Location headers\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmCombinedLroHeaders<StatusMonitor, FinalResult, PollingUrlValue, FinalUrlValue>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name            | Description                                                                       |\r\n| --------------- | --------------------------------------------------------------------------------- |\r\n| StatusMonitor   | The type of the polling StatusMonitor when following the Azure-AsyncOperation url |\r\n| FinalResult     | The type of the logical result when following the location header                 |\r\n| PollingUrlValue | The value type of the link to the status monitor                                  |\r\n| FinalUrlValue   | The value type fo the link to the final result                                    |\r\n\r\n#### Properties\r\n\r\n| Name                 | Type              | Description                                                                                         |\r\n| -------------------- | ----------------- | --------------------------------------------------------------------------------------------------- |\r\n| azureAsyncOperation? | `PollingUrlValue` | A link to the status monitor                                                                        |\r\n| location?            | `FinalUrlValue`   | The Location header contains the URL where the status of the long running operation can be checked. |\n\n### `ArmCreatedResponse` {#Azure.ResourceManager.ArmCreatedResponse}\n\nThe Azure Resource Manager 201 response for a resource\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmCreatedResponse<ResponseBody, ExtraHeaders>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name         | Description                                                             |\r\n| ------------ | ----------------------------------------------------------------------- |\r\n| ResponseBody | The contents of the response body                                       |\r\n| ExtraHeaders | Additional headers in the response. Default includes Retry-After header |\r\n\r\n#### Properties\r\n\r\n| Name       | Type           | Description      |\r\n| ---------- | -------------- | ---------------- |\r\n| statusCode | `201`          | The status code. |\r\n| body       | `ResponseBody` |                  |\n\n### `ArmDeleteAcceptedLroResponse` {#Azure.ResourceManager.ArmDeleteAcceptedLroResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmDeleteAcceptedLroResponse<LroHeaders>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description                                                           |\r\n| ---------- | --------------------------------------------------------------------- |\r\n| LroHeaders | Optional. Allows overriding the Lro headers returned in the response. |\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `202` | The status code. |\n\n### `ArmDeleteAcceptedResponse` {#Azure.ResourceManager.ArmDeleteAcceptedResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmDeleteAcceptedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type    | Description                                                                                              |\r\n| ----------- | ------- | -------------------------------------------------------------------------------------------------------- |\r\n| statusCode  | `202`   | The status code.                                                                                         |\r\n| retryAfter? | `int32` | The Retry-After header can indicate how long the client should wait before polling the operation status. |\n\n### `ArmDeletedNoContentResponse` {#Azure.ResourceManager.ArmDeletedNoContentResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmDeletedNoContentResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `204` | The status code. |\n\n### `ArmDeletedResponse` {#Azure.ResourceManager.ArmDeletedResponse}\n\nThe response for synchronous delete of a resource\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmDeletedResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `200` | The status code. |\n\n### `ArmLocationResource` {#Azure.ResourceManager.ArmLocationResource}\n\nTemplate for ARM location resources. Use the parameter to specify\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmLocationResource<BaseType>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description |\r\n| -------- | ----------- |\r\n| BaseType |             |\r\n\r\n#### Properties\r\n\r\n| Name     | Type                 | Description                   |\r\n| -------- | -------------------- | ----------------------------- |\r\n| location | `Core.azureLocation` | The name of the Azure region. |\n\n### `ArmLroLocationHeader` {#Azure.ResourceManager.ArmLroLocationHeader}\n\nThe default header for lro PUT and DELETE polling\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmLroLocationHeader<LroPollingOptions, FinalResult, UrlValue>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name              | Description                                                     |\r\n| ----------------- | --------------------------------------------------------------- |\r\n| LroPollingOptions | The polling options when polling the url in the location header |\r\n| FinalResult       | The ultimate final result of the logical operation              |\r\n| UrlValue          | The value type for the location header                          |\r\n\r\n#### Properties\r\n\r\n| Name      | Type       | Description                                                                                         |\r\n| --------- | ---------- | --------------------------------------------------------------------------------------------------- |\r\n| location? | `UrlValue` | The Location header contains the URL where the status of the long running operation can be checked. |\n\n### `ArmNoContentResponse` {#Azure.ResourceManager.ArmNoContentResponse}\n\nStandard Azure Resource Manager NoContent (204) response\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmNoContentResponse<Message>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name    | Description                                                                             |\r\n| ------- | --------------------------------------------------------------------------------------- |\r\n| Message | The description of the response status (defaults to `Operation completed successfully`) |\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `204` | The status code. |\n\n### `ArmOperationStatus` {#Azure.ResourceManager.ArmOperationStatus}\n\nStandard Azure Resource Manager operation status response\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmOperationStatus<Properties, StatusValues>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name         | Description                                    |\r\n| ------------ | ---------------------------------------------- |\r\n| Properties   | Optional resource-specific properties          |\r\n| StatusValues | The set of allowed values for operation status |\r\n\r\n#### Properties\r\n\r\n| Name             | Type                                                                           | Description                                                                                                      |\r\n| ---------------- | ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------- |\r\n| properties?      | `Properties`                                                                   | RP-specific properties for the operationStatus resource, only appears when operation ended with Succeeded status |\r\n| status           | `StatusValues`                                                                 | The operation status                                                                                             |\r\n| id               | `string`                                                                       | The unique identifier for the operationStatus resource                                                           |\r\n| name?            | `string`                                                                       | The name of the operationStatus resource                                                                         |\r\n| startTime?       | `utcDateTime`                                                                  | Operation start time                                                                                             |\n\n|\r\n| name?            | `string`                                                                       | The name of the operationStatus resource                                                                         |\r\n| startTime?       | `utcDateTime`                                                                  | Operation start time                                                                                             |\r\n| endTime?         | `utcDateTime`                                                                  | Operation complete time                                                                                          |\r\n| percentComplete? | `float64`                                                                      | The progress made toward completing the operation                                                                |\r\n| error?           | [`ErrorDetail`](./data-types.md#Azure.ResourceManager.CommonTypes.ErrorDetail) | Errors that occurred if the operation ended with Canceled or Failed status                                       |\n\n### `ArmResourceCreatedResponse` {#Azure.ResourceManager.ArmResourceCreatedResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmResourceCreatedResponse<Resource, LroHeaders>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name       | Description                                                |\r\n| ---------- | ---------------------------------------------------------- |\r\n| Resource   | The resource being updated                                 |\r\n| LroHeaders | Optional. The lro headers returned with a Created response |\r\n\r\n#### Properties\r\n\r\n| Name       | Type       | Description      |\r\n| ---------- | ---------- | ---------------- |\r\n| statusCode | `201`      | The status code. |\r\n| body       | `Resource` |                  |\n\n### `ArmResourceCreatedSyncResponse` {#Azure.ResourceManager.ArmResourceCreatedSyncResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmResourceCreatedSyncResponse<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                |\r\n| -------- | -------------------------- |\r\n| Resource | The resource being updated |\r\n\r\n#### Properties\r\n\r\n| Name       | Type       | Description      |\r\n| ---------- | ---------- | ---------------- |\r\n| statusCode | `201`      | The status code. |\r\n| body       | `Resource` |                  |\n\n### `ArmResourceExistsResponse` {#Azure.ResourceManager.ArmResourceExistsResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmResourceExistsResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `204` | The status code. |\n\n### `ArmResourceNotFoundResponse` {#Azure.ResourceManager.ArmResourceNotFoundResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmResourceNotFoundResponse\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type  | Description      |\r\n| ---------- | ----- | ---------------- |\r\n| statusCode | `404` | The status code. |\n\n### `ArmResourceUpdatedResponse` {#Azure.ResourceManager.ArmResourceUpdatedResponse}\n\n```typespec\r\nmodel Azure.ResourceManager.ArmResourceUpdatedResponse<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                |\r\n| -------- | -------------------------- |\r\n| Resource | The resource being updated |\r\n\r\n#### Properties\r\n\r\n| Name       | Type       | Description      |\r\n| ---------- | ---------- | ---------------- |\r\n| statusCode | `200`      | The status code. |\r\n| body       | `Resource` |                  |\n\n### `ArmResponse` {#Azure.ResourceManager.ArmResponse}\n\nThe Azure Resource Manager synchronous OK response\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ArmResponse<ResponseBody>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name         | Description                       |\r\n| ------------ | --------------------------------- |\r\n| ResponseBody | The contents of the response body |\r\n\r\n#### Properties\r\n\r\n| Name       | Type           | Description      |\r\n| ---------- | -------------- | ---------------- |\r\n| statusCode | `200`          | The status code. |\r\n| body       | `ResponseBody` |                  |\n\n### `AvailabilityZonesProperty` {#Azure.ResourceManager.AvailabilityZonesProperty}\n\nModel representing the standard `zones` envelope property for a resource.\r\nSpread this model into a resource Model if the resource supports ARM `zones`.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.AvailabilityZonesProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typescript\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  ...AvailabilityZonesProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name   | Type       | Description             |\r\n| ------ | ---------- | ----------------------- |\r\n| zones? | `string[]` | The availability zones. |\n\n### `DefaultProvisioningStateProperty` {#Azure.ResourceManager.DefaultProvisioningStateProperty}\n\nStandard resource provisioning state model. If you do not have any custom provisioning state,\r\nyou can spread this model directly into your resource property model.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.DefaultProvisioningStateProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel FooProperties {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...DefaultProvisioningStateProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name               | Type                                                                                           | Description                             |\r\n| ------------------ | ---------------------------------------------------------------------------------------------- | --------------------------------------- |\r\n| provisioningState? | [`ResourceProvisioningState`](./data-types.md#Azure.ResourceManager.ResourceProvisioningState) | The provisioning state of the resource. |\n\n### `EncryptionProperty` {#Azure.ResourceManager.EncryptionProperty}\n\nModel used only to spread in the `encryption` envelope property for a resource.\r\nAll encryption configuration for a resource.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.EncryptionProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  ...Encryption;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type                                                                         | Description                                  |\r\n| ---------- | ---------------------------------------------------------------------------- | -------------------------------------------- |\r\n| encryption | [`Encryption`](./data-types.md#Azure.ResourceManager.CommonTypes.Encryption) | All encryption configuration for a resource. |\n\n### `EntityTagProperty` {#Azure.ResourceManager.EntityTagProperty}\n\nModel used only to spread in the standard `eTag` envelope property for a resource\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.EntityTagProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...EntityTagProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type     | Description                                                                                                                                                                                                                                                                                                                                                         |\r\n| ----- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| eTag? | `string` | If eTag is provided in the response body, it may also be provided as a header per the normal etag convention. Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields. |\n\n### `ExtendedLocationProperty` {#Azure.ResourceManager.ExtendedLocationProperty}\n\nModel representing the standard `extendedLocation` envelope property for a resource.\r\nSpread this model into a Resource Model, if the resource supports extended locations\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ExtendedLocationProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Employee is TrackedResource<EmployeeProperties> {\r\n  ...ResourceNameParameter<Employee>;\r\n  ...ExtendedLocationProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name              | Type                                                                                     | Description |\r\n| ----------------- | ---------------------------------------------------------------------------------------- | ----------- |\r\n| extendedLocation? | [`ExtendedLocation`](./data-types.md#Azure.ResourceManager.CommonTypes.ExtendedLocation) |             |\n\n### `ExtensionResource` {#Azure.ResourceManager.ExtensionResource}\n\nConcrete extension resource types can be created by aliasing this type using a specific property type.\r\n\r\nSee more details on [different Azure Resource Manager resource type here.](https://azure.github.io/typespec-azure/docs/howtos/ARM/resource-type)\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ExtensionResource<Properties, PropertiesOptional>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name               | Description                                                                                                                                    |\r\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Properties         | A model containing the provider-specific properties for this resource                                                                          |\r\n| PropertiesOptional | A boolean flag indicating whether the resource `Properties` field is marked as optional or required. Default true is optional and recommended. |\r\n\r\n#### Properties\r\n\r\n| Name        | Type         | Description |\r\n| ----------- | ------------ | ----------- |\r\n| properties? | `Properties` |             |\n\n### `KeysOf` {#Azure.ResourceManager.KeysOf}\n\nExtracts the key (path) parameters from a resource and its parents\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.KeysOf<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                             |\r\n| -------- | --------------------------------------- |\r\n| Resource | The resource to extract properties from |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `LocationParameter` {#Azure.ResourceManager.LocationParameter}\n\nDEPRECATED - DO NOT USE\r\nThe default location parameter type.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.LocationParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type     | Description        |\r\n| -------- | -------- | ------------------ |\r\n| location | `string` | The location name. |\n\n### `LocationResourceParameter` {#Azure.ResourceManager.LocationResourceParameter}\n\nThe default location parameter type.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.LocationResourceParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type                 | Description                   |\r\n| -------- | -------------------- | ----------------------------- |\r\n| location | `Core.azureLocation` | The name of the Azure region. |\n\n### `ManagedByProperty` {#Azure.ResourceManager.ManagedByProperty}\n\nModel representing the standard `managedBy` envelope property for a resource.\r\nSpread this model into a resource model if the resource is managed by another entity.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ManagedByProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...ManagedByProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name       | Type     | Description                                                                                                                                                                                                                                                                                        |\r\n| ---------- | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| managedBy? | `string` | The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another Azure resource. If this is present, complete mode deployment will not delete the resource if it is removed from the template since it is managed by another resource. |\n\n### `ManagedServiceIdentityProperty` {#Azure.ResourceManager.ManagedServiceIdentityProperty}\n\nModel representing the standard `ManagedServiceIdentity` envelope property for a resource.\r\nSpread this model into a resource model if the resource supports both system-assigned and user-assigned managed identities.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ManagedServiceIdentityProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  ...ResourceNameParameter<Foo>;\r\n  ...ManagedServiceIdentityProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name      | Type                                                                                                 | Description                                               |\r\n| --------- | ---------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |\r\n| identity? | [`ManagedServiceIdentity`](./data-types.md#Azure.ResourceManager.CommonTypes.ManagedServiceIdentity) | The managed service identities assigned to this resource. |\n\n### `ManagedSystemAssignedIdentityProperty` {#Azure.ResourceManager.ManagedSystemAssignedIdentityProperty}\n\nModel representing the standard `SystemAssignedServiceIdentity` envelope property for a resource.\r\nSpread this model into a resource model if the resource supports system-assigned managed identities\r\nbut does not support user-assigned managed identities.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ManagedSystemAssignedIdentityProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  ...ResourceNameParameter<Foo>;\r\n  ...ManagedSystemAssignedIdentityProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name      | Type                                                                                                               | Description                                               |\r\n| --------- | ------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------- |\r\n| identity? | [`SystemAssignedServiceIdentity`](./data-types.md#Azure.ResourceManager.CommonTypes.SystemAssignedServiceIdentity) | The managed service identities assigned to this resource. |\n\n### `ParentKeysOf` {#Azure.ResourceManager.ParentKeysOf}\n\nExtracts the key (path) parameters from the parent(s) of the given resource\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ParentKeysOf<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                             |\r\n| -------- | --------------------------------------- |\r\n| Resource | The resource to extract properties from |\r\n\r\n#### Properties\r\n\r\nNone\n\n### `ProviderNamespace` {#Azure.ResourceManager.ProviderNamespace}\n\nModel describing the provider namespace.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ProviderNamespace<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                             |\r\n| -------- | --------------------------------------- |\r\n| Resource | The resource provided by the namespace. |\r\n\r\n#### Properties\r\n\r\n| Name     | Type                             | Description |\r\n| -------- | -------------------------------- | ----------- |\r\n| provider | `\"Microsoft.ThisWillBeReplaced\"` |             |\n\n### `ProxyResource` {#Azure.ResourceManager.ProxyResource}\n\nConcrete proxy resource types can be created by aliasing this type using a specific property type.\r\n\r\nSee more details on [different Azure Resource Manager resource type here.](https://azure.github.io/typespec-azure/docs/howtos/ARM/resource-type)\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ProxyResource<Properties, PropertiesOptional>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name               | Description                                                                                                                                    |\r\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Properties         | A model containing the provider-specific properties for this resource                                                                          |\r\n| PropertiesOptional | A boolean flag indicating whether the resource `Properties` field is marked as optional or required. Default true is optional and recommended. |\r\n\r\n#### Properties\r\n\r\n| Name        | Type         | Description |\r\n| ----------- | ------------ | ----------- |\r\n| properties? | `Properties` |             |\n\n### `ResourceGroupLocationResource` {#Azure.ResourceManager.ResourceGroupLocationResource}\n\nThe location resource for resourceGroup-based locations. This can be used as a parent\r\nresource for resource types that are homed in a resourceGroup-based location.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceGroupLocationResource\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type                 | Description                   |\r\n| -------- | -------------------- | ----------------------------- |\r\n| location | `Core.azureLocation` | The name of the Azure region. |\n\n### `ResourceInstanceParameters` {#Azure.ResourceManager.ResourceInstanceParameters}\n\nThe dynamic parameters of a resource instance - pass in the proper base type to indicate\r\nwhere the resource is based. The default is in a resource group\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceInstanceParameters<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                              |\r\n| -------------- | -------------------------------------------------------- |\r\n| Resource       | The resource to get parameters for                       |\r\n| BaseParameters | The parameters representing the base Uri of the resource |\r\n\r\n#### Properties\r\n\r\n| Name     | Type                             | Description |\r\n| -------- | -------------------------------- | ----------- |\r\n| provider | `\"Microsoft.ThisWillBeReplaced\"` |             |\n\n### `ResourceKindProperty` {#Azure.ResourceManager.ResourceKindProperty}\n\nModel representing the standard `kind` envelope property for a resource.\r\nSpread this model into a resource model if the resource support ARM `kind`.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceKindProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...ResourceKindProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type     | Description                                                                                                                                                                                                                           |\r\n| ----- | -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| kind? | `string` | Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type. If supported, the resource provider must validate and persist this value. |\n\n### `ResourceListCustomResult` {#Azure.ResourceManager.ResourceListCustomResult}\n\nPaged response containing results\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceListCustomResult<Result>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name   | Description                                           |\r\n| ------ | ----------------------------------------------------- |\r\n| Result | The type of the values returned in the paged response |\r\n\r\n#### Properties\r\n\r\n| Name      | Type             | Description                        |\r\n| --------- | ---------------- | ---------------------------------- |\r\n| value     | `Array<Element>` | The items on this page             |\r\n| nextLink? | `string`         | The link to the next page of items |\n\n### `ResourceListResult` {#Azure.ResourceManager.ResourceListResult}\n\nPaged response containing resources\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceListResult<Resource>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name     | Description                                                                |\r\n| -------- | -------------------------------------------------------------------------- |\r\n| Resource | The type of the values returned in the paged response (must be a resource) |\r\n\r\n#### Properties\r\n\r\n| Name      | Type                             | Description |\r\n| --------- | -------------------------------- | ----------- |\r\n| value     | `Array<Element>`                 |             |\r\n| nextLink? | `TypeSpec.Rest.ResourceLocation` |             |\n\n### `ResourceNameParameter` {#Azure.ResourceManager.ResourceNameParameter}\n\nSpread this model into ARM resource models to specify resource name parameter for its operations. If `Resource` parameter\r\nis specified, the resource name will be properly camel cased and pluralized for `@key` and `@segment`\r\nautomatically. You can also apply explicit override with `KeyName` and `SegmentName` template parameters.\r\n\r\nFor additional decorators such as\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceNameParameter<Resource, KeyName, SegmentName, NamePattern, Type>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name        | Description                                                                                              |\r\n| ----------- | -------------------------------------------------------------------------------------------------------- |\r\n| Resource    | The ARM resource this name parameter is applying to.                                                     |\r\n| KeyName     | Override default key name of the resource.                                                               |\r\n| SegmentName | Override default segment name of the resource.                                                           |\r\n| NamePattern | The RegEx pattern of the name. Default is `^[a-zA-Z0-9-]{3,24}$`.                                        |\r\n| Type        | The type of the name property. Default type is string. However you can pass an union with string values. |\r\n\r\n#### Properties\r\n\r\n| Name | Type   | Description |\r\n| ---- | ------ | ----------- |\r\n| name | `Type` |             |\n\n### `ResourceParentParameters` {#Azure.ResourceManager.ResourceParentParameters}\n\nThe dynamic parameters of a list call for a resource instance - pass in the proper base type to indicate\r\nwhere the list should take place. The default is in a resource group\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceParentParameters<Resource, BaseParameters>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name           | Description                                              |\r\n| -------------- | -------------------------------------------------------- |\r\n| Resource       | The resource to get parameters for                       |\r\n| BaseParameters | The parameters representing the base Uri of the resource |\r\n\r\n#### Properties\r\n\r\n| Name     | Type                             | Description |\r\n| -------- | -------------------------------- | ----------- |\r\n| provider | `\"Microsoft.ThisWillBeReplaced\"` |             |\n\n### `ResourcePlanProperty` {#Azure.ResourceManager.ResourcePlanProperty}\n\nModel representing the standard `plan` envelope property for a resource.\r\nSpread this model into a resource Model if the resource supports ARM `plan`.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourcePlanProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...ResourcePlanProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name  | Type                                                             | Description                   |\r\n| ----- | ---------------------------------------------------------------- | ----------------------------- |\r\n| plan? | [`Plan`](./data-types.md#Azure.ResourceManager.CommonTypes.Plan) | Details of the resource plan. |\n\n### `ResourceSkuProperty` {#Azure.ResourceManager.ResourceSkuProperty}\n\nModel representing the standard `sku` envelope property for a resource.\r\nSpread this model into a resource model if the resource supports standard ARM `sku`.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceSkuProperty\r\n```\r\n\r\n#### Examples\r\n\r\n```typespec\r\nmodel Foo is TrackedResource<FooProperties> {\r\n  // Only have standard Succeeded, Failed, Cancelled states\r\n  ...ResourceSkuProperty;\r\n}\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type                                                           | Description                                             |\r\n| ---- | -------------------------------------------------------------- | ------------------------------------------------------- |\r\n| sku? | [`Sku`](./data-types.md#Azure.ResourceManager.CommonTypes.Sku) | The SKU (Stock Keeping Unit) assigned to this resource. |\n\n### `ResourceUriParameter` {#Azure.ResourceManager.ResourceUriParameter}\n\nThe default resourceUri parameter type.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.ResourceUriParameter\r\n```\r\n\r\n#### Properties\r\n\r\n| Name        | Type     | Description                                                            |\r\n| ----------- | -------- | ---------------------------------------------------------------------- |\r\n| resourceUri | `string` | The fully qualified Azure Resource manager identifier of the resource. |\n\n### `SubscriptionActionScope` {#Azure.ResourceManager.SubscriptionActionScope}\n\nTemplate used by ArmProviderAction templates.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.SubscriptionActionScope\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type     | Description            |\r\n| ---- | -------- | ---------------------- |\r\n| name | `string` | Symbolic name of scope |\n\n### `SubscriptionLocationResource` {#Azure.ResourceManager.SubscriptionLocationResource}\n\nThe location resource for subscription-based locations. This can be used as a parent\r\nresource for resource types that are homed in a subscription-based location.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.SubscriptionLocationResource\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type                 | Description                   |\r\n| -------- | -------------------- | ----------------------------- |\r\n| location | `Core.azureLocation` | The name of the Azure region. |\n\n### `TenantActionScope` {#Azure.ResourceManager.TenantActionScope}\n\nTemplate used by ArmTenantAction templates.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.TenantActionScope\r\n```\r\n\r\n#### Properties\r\n\r\n| Name | Type     | Description            |\r\n| ---- | -------- | ---------------------- |\r\n| name | `string` | Symbolic name of scope |\n\n### `TenantLocationResource` {#Azure.ResourceManager.TenantLocationResource}\n\nThe location resource for tenant-based locations. This can be used as a parent\r\nresource for resource types that are homed in a tenant-based location.\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.TenantLocationResource\r\n```\r\n\r\n#### Properties\r\n\r\n| Name     | Type                 | Description                   |\r\n| -------- | -------------------- | ----------------------------- |\r\n| location | `Core.azureLocation` | The name of the Azure region. |\n\n### `TrackedResource` {#Azure.ResourceManager.TrackedResource}\n\nConcrete tracked resource types can be created by aliasing this type using a specific property type.\r\n\r\nSee more details on [different Azure Resource Manager resource type here.](https://azure.github.io/typespec-azure/docs/howtos/ARM/resource-type)\r\n\r\n```typespec\r\nmodel Azure.ResourceManager.TrackedResource<Properties, PropertiesOptional>\r\n```\r\n\r\n#### Template Parameters\r\n\r\n| Name               | Description                                                                                                                                    |\r\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| Properties         | A model containing the provider-specific properties for this resource                                                                          |\r\n| PropertiesOptional | A boolean flag indicating whether the resource `Properties` field is marked as optional or required. Default true is optional and recommended. |\r\n\r\n#### Properties\r\n\r\n| Name        | Type         | Description |\r\n| ----------- | ------------ | ----------- |\r\n| properties? | `Properties` |             |\n", "latency": 4.794903993606567, "response_length": 238}
{"query": "title: @example for plainDate\n\nquestion: I'm trying out the new `@example` decorator and it works well from what I've seen but for `plainDate`/`offsetDateTime` data types.\nFor example, when I try to provide an example for a date field like this:\n```\nmodel Foo {\n@example(\"2020-12-12\")\nbar: plainDate;\n}\n```\nthe TypeSpec compiler will error with this message:\n```\nerror unassignable: Type '\"2020-12-12\"' is not assignable to type 'plainDate'\n> 21 |   @example(\"2020-12-12\")\n```\nOther date/time related examples are also failing, i.e. `@example(\"2022-09-15T14:15:00+08:00\")` for a `offsetDateTime` property gives the same error.\nWhat is the correct way of providing example date/time values?", "ground_truth": "Oh, I think I found it right after posting 🤦\nThis seems to do the trick:\n```\n@example(plainDate.fromISO(\"2020-12-12\"))\n```", "response": "To provide example values for `plainDate` or `offsetDateTime` types using the `@example` decorator, you need to use the scalar constructor for these types. This ensures the example value is assignable to the type. For instance:\n\n```tsp\n@example(plainDate.fromISO(\"2020-12-12\"))\nmodel Foo {\n  bar: plainDate;\n}\n\n@example(offsetDateTime.fromISO(\"2022-09-15T14:15:00+08:00\"))\nmodel Bar {\n  baz: offsetDateTime;\n}\n```\n\nHere, `plainDate.fromISO` and `offsetDateTime.fromISO` are used to create valid instances of the respective types. This approach ensures compatibility with the TypeSpec compiler and allows the examples to be correctly processed.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: standard-library#examples.md\n- document_title: Examples\n- document_link: https://typespec.io/docs/standard-library/examples\n- document_content: # standard-library#examples.md\n\n# Examples\n\nTypeSpec provide 2 decorators `@example` and `@opExample` to provide some examples for the types and operations.\r\nWith those decorators the examples must be provided as TypeSpec values that should be assignable to the type or operation parameter/return types.\n\n### Type Examples\n\nTo give an example for a type you can use the `@example` decorator. The decorator first argument is the example value it MUST be assignable to the type it is targetting.\r\nAdditionally a title and/or description can be provided in the options.\n\n### Simple primitive types\n\n```tsp\r\n@example(#{ name: \"Max\", age: 3 })\r\nmodel Pet {\r\n  name: string;\r\n  age: int32;\r\n}\r\n```\n\n### Scalar types\n\nFor scalar types the value must be defined with the scalar constructor.\r\nThis allows emitters to render the example in the correct protocol following the encoding of those scalar and the values set by `@encode`.\r\n\r\n```tsp\r\n@example(#{\r\n  id: \"item-1\",\r\n  createdAt: plainDate.fromISO(\"2020-01-01T00:00:00Z\"),\r\n  timeout: duration.fromISO(\"PT1M\"),\r\n})\r\nmodel Item {\r\n  id: string;\r\n  createdAt: utcDateTime;\r\n  @encode(\"seconds\", int32) timeout: duration;\r\n}\r\n```\n\n### Provide title or description\n\n```tsp\r\n@example(#{ name: \"Max\", age: 3 }, #{ title: \"Pet example\", description: \"Simple pet example\" })\r\nmodel Pet {\r\n  name: string;\r\n  age: int32;\r\n}\r\n```\n\n### Multiple examples\n\n```tsp\r\n@example(#{ name: \"Max\", age: 3 }, #{ title: \"Minimal examples\", description: \"Minimal examples\" })\r\n@example(\r\n  #{ name: \"Rex\", age: 8, bark: true },\r\n  #{ title: \"With optional properties\", description: \"Example where the pet barks\" }\r\n)\r\nmodel Pet {\r\n  name: string;\r\n  age: int32;\r\n  bark?: boolean;\r\n}\r\n```\n\n### Define typed examples using `const`\n\n```tsp\r\nconst petExample: Pet = #{ name: \"Max\", age: 3 };\r\n\r\n@example(petExample)\r\nmodel Pet {\r\n  name: string;\r\n  age: int32;\r\n}\r\n```\n\n## Operation examples\n\nOperation example are provided with the `@opExample` decorator. Similar to the `@example` decorator the first argument is the example value however it takes both the `parameters` and `returnType` example.\r\nThe values passed to `parameters` MUST be assignable to the operation parameters and the value passed to `returnType` MUST be assignable to the operation return type.\r\nAdditionally a title and/or description can be provided in the options.\r\n\r\n:::note\r\nOperation example will not validate additional properties as the applicable parameters might depend on the protocol and applied visibility.\r\n:::\n\n### Simple operation parameters\n\n```tsp\r\n@opExample(#{ parameters: #{ name: \"Max\", age: 3 } })\r\nop write(name: string, age: int32): void;\r\n```\n\n### Simple operation return types\n\n```tsp\r\n@opExample(#{ returnType: #{ name: \"Max\", age: 3 } })\r\nop read(): {\r\n  name: string;\r\n  age: int32;\r\n};\r\n```\n\n### Specify title and/or description\n\n```tsp\r\n@opExample(\r\n  #{ parameters: #{ name: \"Max\", age: 3 } },\r\n  #{ title: \"Simple write example\", description: \"Write a pet\" }\r\n)\r\nop write(name: string, age: int32): void;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#xml#guide.md\n- document_title: Guide\n- document_link: https://typespec.io/docs/libraries/xml/guide\n- document_content: # libraries#xml#guide.md\n\n# Guide\n\n## Default encoding of scalars\n\nAs in Json we have some [default handling](https://typespec.io/docs/libraries/http/encoding#bytes) of the common scalars like `utcDateTime`\r\n\r\n| Scalar Type      | Default Encoding  | Encoding name                           |\r\n| ---------------- | ----------------- | --------------------------------------- |\r\n| `utcDateTime`    | `xs:dateTime`     | `TypeSpec.Xml.Encoding.xmlDateTime`     |\r\n| `offsetDateTime` | `xs:dateTime`     | `TypeSpec.Xml.Encoding.xmlDateTime`     |\r\n| `plainDate`      | `xs:date`         | `TypeSpec.Xml.Encoding.xmlDate`         |\r\n| `plainTime`      | `xs:time`         | `TypeSpec.Xml.Encoding.xmlTime`         |\r\n| `duration`       | `xs:duration`     | `TypeSpec.Xml.Encoding.xmlDuration`     |\r\n| `bytes`          | `xs:base64Binary` | `TypeSpec.Xml.Encoding.xmlBase64Binary` |\n\n## Examples\n\n### 1. Array of primitive types\n\n<td>\r\n\r\n```tsp\r\n@encodedName(\"application/xml\", \"ItemsName\")\r\nscalar tag extends string;\r\n\r\n@encodedName(\"application/xml\", \"XmlPet\")\r\nmodel Pet {\r\n  @Xml.unwrapped\r\n  tags: tag[];\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<XmlPet>\r\n  <ItemsName>abc</ItemsName>\r\n  <ItemsName>def</ItemsName>\r\n</XmlPet>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nPet:\r\n  type: \"object\"\r\n  properties:\r\n    tags:\r\n      type: \"array\"\r\n      items:\r\n        type: string\r\n        xml:\r\n          name: tags\r\n  xml:\r\n    name: \"XmlPet\"\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- ----------------------------------------------------  SCENARIO 1.4 ---------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@encodedName(\"application/xml\", \"ItemsName\")\r\nscalar tag extends string;\r\n\r\n@encodedName(\"application/xml\", \"XmlPet\")\r\nmodel Pet {\r\n  @encodedName(\"application/xml\", \"ItemsTags\")\r\n  tags: tag[];\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<XmlPet>\r\n  <ItemsTags>\r\n    <ItemsName>abc</ItemsName>\r\n    <ItemsName>def</ItemsName>\r\n  </ItemsTags>\r\n</XmlPet>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nPet:\r\n  type: \"object\"\r\n  properties:\r\n    tags:\r\n      type: \"array\"\r\n      xml:\r\n        name: \"ItemsTags\"\r\n        wrapped: true\r\n      items:\r\n        type: string\r\n        xml:\r\n          name: ItemsName\r\n  xml:\r\n    name: \"XmlPet\"\r\n```\r\n\r\n</td>\r\n</tr>\r\n<!-- -------------------------------------------------------------------------------------------------------------- -->\r\n\r\n</table>\n\n<table>\r\n<tr>\r\n  <td>TypeSpec</td>\r\n  <td>Xml</td>\r\n  <td>OpenAPI3</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 1.1  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@encodedName(\"application/xml\", \"XmlPet\")\r\nmodel Pet {\r\n  @Xml.unwrapped\r\n  tags: string[];\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<XmlPet>\r\n  <tags>abc</tags>\r\n  <tags>def</tags>\r\n</XmlPet>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nPet:\r\n  type: \"object\"\r\n  properties:\r\n    tags:\r\n      type: \"array\"\r\n      items:\r\n        type: string\r\n        xml:\r\n          name: tags\r\n  xml:\r\n    name: \"XmlPet\"\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- --------------------------------------------------  SCENARIO 1.2 ------------------------------------------------------------ -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@encodedName(\"application/xml\", \"XmlPet\")\r\nmodel Pet {\r\n  @encodedName(\"application/xml\", \"ItemsTags\")\r\n  tags: string[];\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<XmlPet>\r\n  <ItemsTags>\r\n    <string>abc</string>\r\n    <string>def</string>\r\n  </ItemsTags>\r\n</XmlPet>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nPet:\r\n  type: \"object\"\r\n  properties:\r\n    tags:\r\n      type: \"array\"\r\n      xml:\r\n        name: \"ItemsTags\"\r\n        wrapped: true\r\n      items:\r\n        type: string\r\n        xml:\r\n          name: string\r\n  xml:\r\n    name: \"XmlPet\"\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- ----------------------------------------------------  SCENARIO 1.3 ---------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@encodedName(\"application/xml\", \"ItemsName\")\r\nscalar tag extends string;\r\n\r\n@encodedName(\"application/xml\", \"XmlPet\")\r\nmodel Pet {\r\n  @Xml.unwrapped\r\n  tags: tag[];\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<XmlPet>\r\n  <ItemsName>abc</ItemsName>\r\n  <ItemsName>def</ItemsName>\r\n</XmlPet>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nPet:\r\n  type: \"object\"\r\n  properties:\r\n    tags:\r\n      type: \"array\"\r\n      items:\r\n        type: string\r\n        xml:\r\n          name: tags\r\n  xml:\r\n    name: \"XmlPet\"\n\n### 2. Complex array types\n\n<XmlTag>\r\n      <name>string</name>\r\n    </XmlTag>\r\n  </ItemsTags>\r\n</XmlPet>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nTag:\r\n  type: \"object\"\r\n  properties:\r\n    name:\r\n      type: \"string\"\r\n  xml:\r\n    name: \"XmlTag\"\r\nPet:\r\n  type: \"object\"\r\n  properties:\r\n    tags:\r\n      type: \"array\"\r\n      xml:\r\n        name: \"ItemsTags\"\r\n        wrapped: true\r\n      items:\r\n        allOf:\r\n          - $ref: \"#/definitions/Tag\"\r\n        xml:\r\n          name: XmlTag\r\n  xml:\r\n    name: \"XmlPet\"\r\n```\r\n\r\n</td>\r\n</tr>\r\n<!-- -------------------------------------------------------------------------------------------------------------- -->\r\n\r\n</table>\n\n<table>\r\n<tr>\r\n  <td>TypeSpec</td>\r\n  <td>Xml</td>\r\n  <td>OpenAPI3</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 2.1  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@encodedName(\"application/xml\", \"XmlPet\")\r\nmodel Pet {\r\n  @Xml.unwrapped\r\n  tags: Tag[];\r\n}\r\n\r\n@encodedName(\"application/xml\", \"XmlTag\")\r\nmodel Tag {\r\n  name: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<XmlPet>\r\n  <XmlTag>\r\n    <name>string</name>\r\n  </XmlTag>\r\n</XmlPet>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nTag:\r\n  type: \"object\"\r\n  properties:\r\n    name:\r\n      type: \"string\"\r\n  xml:\r\n    name: \"XmlTag\"\r\nPet:\r\n  type: \"object\"\r\n  properties:\r\n    tags:\r\n      type: \"array\"\r\n      items:\r\n        allOf:\r\n          - $ref: \"#/definitions/Tag\"\r\n        xml:\r\n          name: tags\r\n  xml:\r\n    name: \"XmlPet\"\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- --------------------------------------------------  SCENARIO 2.2 ------------------------------------------------------------ -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@encodedName(\"application/xml\", \"XmlPet\")\r\nmodel Pet {\r\n  tags: Tag[];\r\n}\r\n\r\n@encodedName(\"application/xml\", \"XmlTag\")\r\nmodel Tag {\r\n  name: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<XmlPet>\r\n  <XmlTag>\r\n    <name>string</name>\r\n  </XmlTag>\r\n</XmlPet>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nTag:\r\n  type: \"object\"\r\n  properties:\r\n    name:\r\n      type: \"string\"\r\n  xml:\r\n    name: \"XmlTag\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    tags:\r\n      type: array\r\n      items:\r\n        allOf:\r\n          - $ref: \"#/components/schemas/Tag\"\r\n        xml:\r\n          name: XmlTag\r\n      xml:\r\n        wrapped: true\r\n  xml:\r\n    name: XmlPet\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- ----------------------------------------------------  SCENARIO 2.3 ---------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@encodedName(\"application/xml\", \"XmlPet\")\r\nmodel Pet {\r\n  @encodedName(\"application/xml\", \"ItemsTag\")\r\n  @Xml.unwrapped\r\n  tags: Tag[];\r\n}\n\nitems:\r\n        allOf:\r\n          - $ref: \"#/components/schemas/Tag\"\r\n        xml:\r\n          name: XmlTag\r\n      xml:\r\n        wrapped: true\r\n  xml:\r\n    name: XmlPet\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- ----------------------------------------------------  SCENARIO 2.3 ---------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@encodedName(\"application/xml\", \"XmlPet\")\r\nmodel Pet {\r\n  @encodedName(\"application/xml\", \"ItemsTag\")\r\n  @Xml.unwrapped\r\n  tags: Tag[];\r\n}\r\n\r\n@encodedName(\"application/xml\", \"XmlTag\")\r\nmodel Tag {\r\n  name: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<XmlPet>\r\n  <ItemsTag>\r\n    <name>string</name>\r\n  </ItemsTag>\r\n</XmlPet>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nTag:\r\n  type: \"object\"\r\n  properties:\r\n    name:\r\n      type: \"string\"\r\n  xml:\r\n    name: \"XmlTag\"\r\nPet:\r\n  type: \"object\"\r\n  properties:\r\n    tags:\r\n      type: \"array\"\r\n      items:\r\n        allOf:\r\n          - $ref: \"#/definitions/Tag\"\r\n        xml:\r\n          name: ItemsTag\r\n  xml:\r\n    name: \"XmlPet\"\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- ----------------------------------------------------  SCENARIO 2.4 ---------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@encodedName(\"application/xml\", \"XmlPet\")\r\nmodel Pet {\r\n  @encodedName(\"application/xml\", \"ItemsTags\")\r\n  tags: Tag[];\r\n}\r\n\r\n@encodedName(\"application/xml\", \"XmlTag\")\r\nmodel Tag {\r\n  name: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<XmlPet>\r\n  <ItemsTags>\r\n    <XmlTag>\r\n      <name>string</name>\r\n    </XmlTag>\r\n  </ItemsTags>\r\n</XmlPet>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nTag:\r\n  type: \"object\"\r\n  properties:\r\n    name:\r\n      type: \"string\"\r\n  xml:\r\n    name: \"XmlTag\"\r\nPet:\r\n  type: \"object\"\r\n  properties:\r\n    tags:\r\n      type: \"array\"\r\n      xml:\r\n        name: \"ItemsTags\"\r\n        wrapped: true\r\n      items:\r\n        allOf:\r\n          - $ref: \"#/definitions/Tag\"\r\n        xml:\r\n          name: XmlTag\r\n  xml:\r\n    name: \"XmlPet\"\r\n```\r\n\r\n</td>\r\n</tr>\n\n### 3. Nested models\n\n<table>\r\n<tr>\r\n  \r\n  <td>TypeSpec</td>\r\n  <td>Xml</td>\r\n  <td>OpenAPI3</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 3.1  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\nmodel Book {\r\n  author: Author;\r\n}\r\n\r\nmodel Author {\r\n  name: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<Book>\r\n  <author>\r\n    <name>string</name>\r\n  </author>\r\n</Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    author:\r\n      $ref: \"#/components/schemas/Author\"\r\nAuthor:\r\n  type: object\r\n  properties:\r\n    name:\r\n      type: string\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- ---------------------------------------------------  SCENARIO 3.2  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\nmodel Book {\r\n  author: Author;\r\n}\r\n\r\n@encodedName(\"application/xml\", \"XmlAuthor\")\r\nmodel Author {\r\n  name: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<Book>\r\n  <author>\r\n    <name>string</name>\r\n  </author>\r\n</Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    author:\r\n      allOf:\r\n        - $ref: \"#/components/schemas/Author\"\r\n      xml:\r\n        name: \"author\" # Here we have to redefine this name otherwise in OpenAPI semantic the `XmlAuthor` name would be used\r\nAuthor:\r\n  type: object\r\n  properties:\r\n    name:\r\n      type: string\r\n  xml:\r\n    name: \"XmlAuthor\"\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- ---------------------------------------------------  SCENARIO 3.3  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\nmodel Book {\r\n  @encodedName(\"application/xml\", \"xml-author\")\r\n  author: Author;\r\n}\r\n\r\nmodel Author {\r\n  name: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<Book>\r\n  <xml-author>\r\n    <name>string</name>\r\n  </xml-author>\r\n</Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    author:\r\n      allOf:\r\n        - $ref: \"#/components/schemas/Author\"\r\n      xml:\r\n        name: \"xml-author\"\r\nAuthor:\n\n-->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\nmodel Book {\r\n  @encodedName(\"application/xml\", \"xml-author\")\r\n  author: Author;\r\n}\r\n\r\nmodel Author {\r\n  name: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<Book>\r\n  <xml-author>\r\n    <name>string</name>\r\n  </xml-author>\r\n</Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    author:\r\n      allOf:\r\n        - $ref: \"#/components/schemas/Author\"\r\n      xml:\r\n        name: \"xml-author\"\r\nAuthor:\r\n  type: object\r\n  properties:\r\n    name:\r\n      type: string\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- -------------------------------------------------------------------------------------------------------------- -->\r\n\r\n</table>\n\n### 4. Attributes\n\n<table>\r\n<tr>\r\n  \r\n  <td>TypeSpec</td>\r\n  <td>Xml</td>\r\n  <td>OpenAPI3</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 4.1  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\nmodel Book {\r\n  @Xml.attribute\r\n  id: integer;\r\n\r\n  @Xml.name(\"xml-title\")\r\n  title: string;\r\n\r\n  author: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<Book id=\"0\">\r\n  <xml-title>string</xml-title>\r\n  <author>string</author>\r\n</Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: integer\r\n      xml:\r\n        attribute: true\r\n    title:\r\n      type: string\r\n      xml:\r\n        name: \"xml-title\"\r\n    author:\r\n      type: string\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- -------------------------------------------------------------------------------------------------------------- -->\r\n\r\n</table>\n\n### 5. Namespace and prefix (inline form)\n\n<table>\r\n<tr>\r\n  \r\n  <td>TypeSpec</td>\r\n  <td>Xml</td>\r\n  <td>OpenAPI3</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 5.1  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@Xml.ns(\"http://example.com/schema\", \"smp\")\r\nmodel Book {\r\n  id: integer;\r\n  title: string;\r\n  author: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<smp:Book xmlns:smp=\"http://example.com/schema\">\r\n  <id>0</id>\r\n  <title>string</title>\r\n  <author>string</author>\r\n</smp:Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: integer\r\n    title:\r\n      type: string\r\n    author:\r\n      type: string\r\n  xml:\r\n    prefix: \"smp\"\r\n    namespace: \"http://example.com/schema\"\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- ---------------------------------------------------  SCENARIO 5.2  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@Xml.ns(\"http://example.com/schema\", \"smp\")\r\nmodel Book {\r\n  id: integer;\r\n\r\n  @Xml.ns(\"http://example.com/schema\", \"smp\")\r\n  title: string;\r\n\r\n  @Xml.ns(\"http://example.com/ns2\", \"ns2\")\r\n  author: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<smp:Book xmlns:smp=\"http://example.com/schema\" xmlns:sn2=\"http://example.com/ns2\">\r\n  <id>0</id>\r\n  <smp:title>string</smp:title>\r\n  <ns2:author>string</ns2:author>\r\n</smp:Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: integer\r\n    title:\r\n      type: string\r\n       xml:\r\n        prefix: \"smp\"\r\n        namespace: \"http://example.com/schema\"\r\n    author:\r\n      type: string\r\n      xml:\r\n        prefix: \"ns2\"\r\n        namespace: \"http://example.com/ns2\"\r\n  xml:\r\n    prefix: \"smp\"\r\n    namespace: \"http://example.com/schema\"\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- -------------------------------------------------------------------------------------------------------------- -->\r\n\r\n</table>\n\n### 6. Namespace and prefix (normalized form)\n\n<table>\r\n<tr>\r\n  \r\n  <td>TypeSpec</td>\r\n  <td>Xml</td>\r\n  <td>OpenAPI3</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 6.1  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@Xml.nsDeclarations\r\nenum Namespaces {\r\n  smp: \"http://example.com/schema\",\r\n}\r\n\r\n@Xml.ns(Namespaces.smp)\r\nmodel Book {\r\n  id: integer;\r\n  title: string;\r\n  author: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<smp:Book xmlns:smp=\"http://example.com/schema\">\r\n  <id>0</id>\r\n  <title>string</title>\r\n  <author>string</author>\r\n</smp:Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: integer\r\n    title:\r\n      type: string\r\n    author:\r\n      type: string\r\n  xml:\r\n    prefix: \"smp\"\r\n    namespace: \"http://example.com/schema\"\r\nNamespaces:\r\n  type: string\r\n  enum:\r\n    - http://example.com/schema\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- ---------------------------------------------------  SCENARIO 6.2  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\n@Xml.nsDeclarations\r\nenum Namespaces {\r\n  smp: \"http://example.com/schema\",\r\n  ns2: \"http://example.com/ns2\",\r\n}\r\n\r\n@Xml.ns(Namespaces.smp)\r\nmodel Book {\r\n  id: integer;\r\n\r\n  @Xml.ns(Namespaces.smp)\r\n  title: string;\r\n\r\n  @Xml.ns(Namespaces.ns2)\r\n  author: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<smp:Book xmlns:smp=\"http://example.com/schema\" xmlns:sn2=\"http://example.com/ns2\">\r\n  <id>0</id>\r\n  <smp:title>string</smp:title>\r\n  <ns2:author>string</ns2:author>\r\n</smp:Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: integer\r\n    title:\r\n      type: string\r\n       xml:\r\n        prefix: \"smp\"\r\n        namespace: \"http://example.com/schema\"\r\n    author:\r\n      type: string\r\n      xml:\r\n        prefix: \"ns2\"\r\n        namespace: \"http://example.com/ns2\"\r\n  xml:\r\n    prefix: \"smp\"\r\n    namespace: \"http://example.com/schema\"\r\nNamespaces:\r\n  type: string\r\n  enum:\n\n<ns2:author>string</ns2:author>\r\n</smp:Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    id:\r\n      type: integer\r\n    title:\r\n      type: string\r\n       xml:\r\n        prefix: \"smp\"\r\n        namespace: \"http://example.com/schema\"\r\n    author:\r\n      type: string\r\n      xml:\r\n        prefix: \"ns2\"\r\n        namespace: \"http://example.com/ns2\"\r\n  xml:\r\n    prefix: \"smp\"\r\n    namespace: \"http://example.com/schema\"\r\nNamespaces:\r\n  type: string\r\n  enum:\r\n    - http://example.com/schema\r\n    - http://example.com/ns2\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- -------------------------------------------------------------------------------------------------------------- -->\r\n\r\n</table>\n\n### 6. Property setting the text of the node\n\n<table>\r\n<tr>\r\n  \r\n  <td>TypeSpec</td>\r\n  <td>Xml</td>\r\n  <td>OpenAPI3</td>\r\n</tr>\r\n<!-- ---------------------------------------------------  SCENARIO 6.1  ----------------------------------------------------------- -->\r\n<tr>\r\n<td>\r\n\r\n```tsp\r\nmodel BlobName {\r\n  @Xml.attribute language: string;\r\n  @Xml.unwrapped content: string;\r\n}\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```xml\r\n<BlobName language=\"abc\">\r\n  ...content...\r\n</smp:Book>\r\n```\r\n\r\n</td>\r\n<td>\r\n\r\n```yaml\r\nBook:\r\n  type: object\r\n  properties:\r\n    language:\r\n      type: string\r\n      xml:\r\n        attribute: true\r\n    content:\r\n      type: string\r\n```\r\n\r\n</td>\r\n</tr>\r\n\r\n<!-- -------------------------------------------------------------------------------------------------------------- -->\r\n\r\n</table>\n", "latency": 15.31030821800232, "response_length": 643}
{"query": "title: Value marshalling in TypeSpec 0.57^\n\nquestion: I am working on upgrading our TypeSpec version to the latest version and fixing all breaking changes. However, I have a decorator with the alias '$flags'. This is causing conflicts when I apply the suggestion here:\n```\nDeprecated: Parameter name of decorator @function is using legacy marshalling but is accepting null as a type.\nThis will change in the future.\nAdd `export const $flags = {decoratorArgMarshalling: \"new\"}}` to your library to opt-in to the new marshalling behavior.\n> 206 | extern dec function(target: Operation, name?: valueof string | null, isComposable?: valueof boolean);\n```\nDoes the exported constant have to be $flags?", "ground_truth": "Seems to be a limitation we have today filed an issue [#3719](https://github.com/microsoft/typespec/issues/3719)", "response": "No, the exported constant does not have to be named `$flags`. You can use any name for the constant, as long as it is properly exported and contains the required configuration object. The `$flags` alias mentioned in the error message is just an example. You can rename the constant to avoid conflicts with your existing `$flags` alias. For example:\n\n```typescript\nexport const decoratorConfig = { decoratorArgMarshalling: \"new\" };\n```\n\nEnsure that this constant is correctly imported and used in your library to opt into the new marshalling behavior.", "context": "- document_dir: typespec_docs\n- document_filename: language-basics#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/language-basics/decorators\n- document_content: # language-basics#decorators.md\n\n# Decorators\n\nDecorators in TypeSpec allow developers to attach metadata to types within a TypeSpec program. They can also be used to compute types based on their inputs. Decorators form the core of TypeSpec's extensibility, providing the flexibility to describe a wide variety of APIs and associated metadata such as documentation, constraints, samples, and more.\r\n\r\nThe vast majority of TypeSpec declarations may be decorated, including [namespaces](./namespaces.md), [interfaces](./interfaces.md), [operations](./operations.md) and their parameters, [scalars](./scalars.md), and [models](./models.md) and their members. In general, any declaration that creates a Type can be decorated. Notably, [aliases](./alias.md) cannot be decorated, as they do not create new Types, nor can any type expressions such as unions that use the `|` syntax or anonymous models, as they are not declarations.\r\n\r\nDecorators are defined using JavaScript functions that are exported from a standard ECMAScript module. When a JavaScript file is imported, TypeSpec will look for any exported functions prefixed with `$`, and make them available as decorators within the TypeSpec syntax. When a decorated declaration is evaluated by TypeSpec, the decorator function is invoked, passing along a reference to the current compilation, an object representing the type it is attached to, and any arguments the user provided to the decorator.\n\n## Applying decorators\n\nDecorators are referenced using the `@` prefix and must be placed before the entity they are decorating. Arguments can be provided by using parentheses, similar to function calls in many programming languages, e.g., `@myDec1(\"hi\", { a: string })`.\r\n\r\nHere's an example of declaring and then using a decorator:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {\r\n  @validate(false)\r\n  name: string;\r\n}\r\n```\r\n\r\nIf no arguments are provided, the parentheses can be omitted.\r\n\r\n```typespec\r\n@mark\r\nmodel Dog {}\r\n```\n\n## Augmenting decorators\n\nDecorators can also be applied from a different location by referring to the type being decorated. For this, you can declare an augment decorator using the `@@` prefix. The first argument of an augment decorator is the type reference that should be decorated. As the augment decorator is a statement, it must end with a semicolon (`;`).\r\n\r\n```typespec\r\nmodel Dog {}\r\n\r\n@@tag(Dog, \"Sample\");\r\n```\r\n\r\nThis is equivalent to:\r\n\r\n```typespec\r\n@tag(\"Sample\")\r\nmodel Dog {}\r\n```\r\n\r\nExample: decorating a model property to indicate that it is read-only\r\n\r\n```typespec\r\nmodel Dog {\r\n  name: string;\r\n}\r\n\r\n@@visibility(Dog.name, Lifecycle.Read);\r\n```\n\n## Creating decorators\n\nFor more information on creating decorators, see [Creating Decorators](../extending-typespec/create-decorators.md).\n-------------------------\n- document_dir: typespec_docs\n- document_filename: extending-typespec#create-decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/extending-typespec/create-decorators\n- document_content: # extending-typespec#create-decorators.md\n\n# Decorators\n\nTypeSpec decorators are implemented as JavaScript functions. The process of creating a decorator can be divided into two parts:\r\n\r\n1. [Declare the decorator signature in TypeSpec](#declare-the-decorator-signature) (optional but recommended)\r\n2. [Implement the decorator in JavaScript](#javascript-decorator-implementation)\n\n## Declare the decorator signature\n\nWhile this step is optional, it offers significant benefits:\r\n\r\n- It enables type checking for the parameters\r\n- It provides IDE IntelliSense\r\n\r\nYou can declare a decorator signature using the `dec` keyword. Since we're implementing the decorator in JavaScript (the only option currently), we need to use the `extern` modifier as well.\r\n\r\n```typespec\r\nextern dec logType(target: unknown, name: string);\r\n```\n\n## Specifying the decorator target\n\nThe first parameter of the decorator represents the TypeSpec type(s) that the decorator can be applied to.\r\n\r\nYou can specify multiple potential target types using a `union expression`.\r\n\r\n```typespec\r\nusing TypeSpec.Reflection;\r\n\r\nextern dec track(target: Model | Enum);\r\n```\n\n## Optional parameters\n\nYou can mark a decorator parameter as optional using `?`.\r\n\r\n```typespec\r\nextern dec track(target: Model | Enum, name?: valueof string);\r\n```\n\n## Rest parameters\n\nYou can prefix the last parameter of a decorator with `...` to collect all the remaining arguments. The type of this parameter must be an `array expression`.\r\n\r\n```typespec\r\nextern dec track(target: Model | Enum, ...names: valueof string[]);\r\n```\n\n## Value parameters\n\nA decorator parameter can receive [values](../language-basics/values.md) by using the `valueof` operator. For example the parameter `valueof string` expects a string value. Values are provided to the decorator implementation according the [decorator parameter marshalling](#decorator-parameter-marshalling) rules.\r\n\r\n```tsp\r\nextern dec tag(target: unknown, value: valueof string);\r\n\r\n// error: string is not a value\r\n@tag(string)\r\n\r\n// ok, a string literal can be a value\r\n@tag(\"widgets\")\r\n\r\n// ok, passing a value from a const\r\nconst tagName: string = \"widgets\";\r\n@tag(tagName)\r\n```\n\n## JavaScript decorator implementation\n\nDecorators can be implemented in JavaScript in 2 ways:\r\n\r\n1. Prefixing the function name with `$`. e.g `export function $doc(target, name) {...}` **Great to get started/play with decorators**\r\n2. Exporting all decorators for your library using `$decorators` variable. **Recommended**\r\n\r\n```ts\r\nexport const $decorators = {\r\n  // Namespace\r\n  \"MyOrg.MyLib\": {\r\n    doc: docDecoratorFn,\r\n  },\r\n};\r\n```\r\n\r\nA decorator implementation takes the following parameters:\r\n\r\n- `1`: `context` of type `DecoratorContext`\r\n- `2`: `target` The TypeSpec type target. (`Namespace`, `Interface`, etc.)\r\n- `3+`: Any arguments of the decorators.\r\n\r\n```ts\r\n// model.ts\r\nimport type { DecoratorContext, Type } from \"@typespec/compiler\";\r\n\r\nexport function $logType(context: DecoratorContext, target: Type, name: string) {\r\n  console.log(name + \": \" + target.kind);\r\n}\r\n```\r\n\r\nOr in JavaScript:\r\n\r\n```ts\r\n// model.js\r\nexport function $logType(context, target, name) {\r\n  console.log(name + \": \" + target.kind);\r\n}\r\n```\r\n\r\nThe decorator can then be used like this:\r\n\r\n```typespec\r\n// main.tsp\r\nimport \"./model.js\";\r\n\r\n@logType(\"Dog type\")\r\nmodel Dog {\r\n  @logType(\"Name type\")\r\n  name: string;\r\n}\r\n```\n\n### Decorator parameter marshalling\n\nWhen decorators are passed types, the type is passed as-is. When a decorator is passed a TypeSpec value, the decorator receives a JavaScript value with a type that is appropriate for representing that value.\r\n\r\n:::note\r\nThis behavior depends on the value of the `valueMarshalling` [package flag](../extending-typespec/basics.md#f-set-package-flags). This section describes the behavior when `valueMarshalling` is set to `\"new\"`. In a future release this will become the default value marshalling so it is strongly recommended to set this flag. But for now, the default value marshalling is `\"legacy\"` which is described in the next section. In a future release the `valueMarshalling` flag will need to be set to `\"legacy\"` to keep the previous marshalling behavior, but the flag will eventually be removed entirely.\r\n:::\r\n\r\n| TypeSpec value type | Marshalled type in JS             |\r\n| ------------------- | --------------------------------- |\r\n| `string`            | `string`                          |\r\n| `boolean`           | `boolean`                         |\r\n| `numeric`           | `Numeric` or `number` (see below) |\r\n| `null`              | `null`                            |\r\n| enum member         | `EnumMemberValue`                 |\r\n\r\nWhen marshalling numeric values, either the `Numeric` wrapper type is used, or a `number` is passed directly, depending on whether the value can be represented as a JavaScript number without precision loss. In particular, the types `numeric`, `integer`, `decimal`, `float`, `int64`, `uint64`, and `decimal128` are marshalled as a `Numeric` type. All other numeric types are marshalled as `number`.\r\n\r\nWhen marshalling custom scalar subtypes, the marshalling behavior of the known supertype is used. For example, a `scalar customScalar extends numeric` will marshal as a `Numeric`, regardless of any value constraints that might be present.\r\n\r\n#### Legacy value marshalling\n\nalias world = \"world!\";\r\n@doc(\"Hello ${world} \") // receive: \"Hello world!\"\r\n@doc(\"Hello ${123} \") // receive: \"Hello 123\"\r\n@doc(\"Hello ${true} \") // receive: \"Hello true\"\r\nmodel Bar {}\r\n@doc(\"Hello ${Bar} \") // not called error\r\n     ^ String template cannot be serialized as a string.\r\n```\r\n\r\n#### Typescript type Reference\r\n\r\n| TypeSpec Parameter Type      | TypeScript types                             |\r\n| ---------------------------- | -------------------------------------------- |\r\n| `valueof string`             | `string`                                     |\r\n| `valueof numeric`            | `number`                                     |\r\n| `valueof boolean`            | `boolean`                                    |\r\n| `string`                     | `StringLiteral \\| TemplateLiteral \\| Scalar` |\r\n| `Reflection.StringLiteral`   | `StringLiteral`                              |\r\n| `Reflection.TemplateLiteral` | `TemplateLiteral`                            |\n\nnumber without precision loss. In particular, the types `numeric`, `integer`, `decimal`, `float`, `int64`, `uint64`, and `decimal128` are marshalled as a `Numeric` type. All other numeric types are marshalled as `number`.\r\n\r\nWhen marshalling custom scalar subtypes, the marshalling behavior of the known supertype is used. For example, a `scalar customScalar extends numeric` will marshal as a `Numeric`, regardless of any value constraints that might be present.\r\n\r\n#### Legacy value marshalling\r\n\r\nWith legacy value marshalling, TypeSpec strings, numbers, and booleans values are always marshalled as JS values. All other values are marshalled as their corresponding type. For example, `null` is marshalled as `NullType`.\r\n\r\n| TypeSpec Value Type | Marshalled value in JS |\r\n| ------------------- | ---------------------- |\r\n| `string`            | `string`               |\r\n| `numeric`           | `number`               |\r\n| `boolean`           | `boolean`              |\r\n\r\nNote that with legacy marshalling, because JavaScript numbers have limited range and precision, it is possible to define values in TypeSpec that cannot be accurately represented in JavaScript.\r\n\r\n#### String templates and marshalling\r\n\r\nIf a decorator parameter type is `valueof string`, a string template passed to it will also be marshalled as a string.\r\nThe TypeSpec type system will already validate the string template can be serialized as a string.\r\n\r\n```tsp\r\nextern dec doc(target: unknown, name: valueof string);\r\nalias world = \"world!\";\r\n@doc(\"Hello ${world} \") // receive: \"Hello world!\"\r\n@doc(\"Hello ${123} \") // receive: \"Hello 123\"\r\n@doc(\"Hello ${true} \") // receive: \"Hello true\"\r\nmodel Bar {}\r\n@doc(\"Hello ${Bar} \") // not called error\r\n     ^ String template cannot be serialized as a string.\r\n```\r\n\r\n#### Typescript type Reference\r\n\r\n| TypeSpec Parameter Type      | TypeScript types                             |\r\n| ---------------------------- | -------------------------------------------- |\r\n|\n\n### Adding metadata with decorators\n\nDecorators can be used to register some metadata. For this, you can use the `context.program.stateMap` or `context.program.stateSet` to insert data that will be tied to the current execution.\r\n\r\n❌ Do not save the data in a global variable.\r\n\r\n```ts file=decorators.ts\r\nimport type { DecoratorContext, Type } from \"@typespec/compiler\";\r\nimport type { StateKeys } from \"./lib.js\";\r\n\r\n// Create a unique key\r\nconst key = StateKeys.customName;\r\nexport function $customName(context: DecoratorContext, target: Type, name: string) {\r\n  // Keep a mapping between the target and a value.\r\n  context.program.stateMap(key).set(target, name);\r\n\r\n  // Keep an index of a type.\r\n  context.program.stateSet(key).add(target);\r\n}\r\n```\r\n\r\n```ts file=lib.ts\r\nexport const $lib = createTypeSpecLibrary({\r\n  // ...\r\n  state: {\r\n    customName: { description: \"State for the @customName decorator\" },\r\n  },\r\n});\r\n\r\nexport const StateKeys = $lib.stateKeys;\r\n```\n\n### Reporting diagnostic on decorator or arguments\n\nThe decorator context provides the `decoratorTarget` and `getArgumentTarget` helpers.\r\n\r\n```ts\r\nimport type { DecoratorContext, Type } from \"@typespec/compiler\";\r\nimport type { reportDiagnostic } from \"./lib.js\";\r\n\r\nexport function $customName(context: DecoratorContext, target: Type, name: string) {\r\n  reportDiagnostic({\r\n    code: \"custom-name-invalid\",\r\n    target: context.decoratorTarget, // Get location of @customName decorator in TypeSpec document.\r\n  });\r\n  reportDiagnostic({\r\n    code: \"bad-name\",\r\n    target: context.getArgumentTarget(0), // Get location of {name} argument in TypeSpec document.\r\n  });\r\n}\r\n```\n\n## Linking declaration and implementation\n\nDecorator signatures are linked to the implementation of the same name in the same namespace.\r\n\r\n```typespec\r\nimport \"./lib.js\";\r\nextern dec customName(target: Type, name: StringLiteral);\r\n\r\nnamespace MyLib {\r\n  extern dec tableName(target: Type, name: StringLiteral);\r\n}\r\n```\r\n\r\nThis is linked to the following in `lib.js`:\r\n\r\n```ts\r\nexport function $customName(context: DecoratorContext, name: string) {}\r\n\r\nexport function $tableName(context: DecoratorContext, name: string) {}\r\nsetTypeSpecNamespace(\"MyLib\", $tableName);\r\n```\n\n## Troubleshooting\n\n### Extern declaration must have an implementation in JS file\n\nPotential issues:\r\n\r\n- The JS function is not prefixed with `$`. For a decorator called `@decorate`, the JS function must be called `$decorate`.\r\n- The JS function is not in the same namespace as the `extern dec`.\r\n- Is the error only showing in the IDE? Try restarting the TypeSpec server or the IDE.\r\n\r\nYou can use `--trace bind.js.decorator` to log debug information about decorator loading in the JS file, which should help identify the issue.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#templates.md\n- document_title: Templates\n- document_link: https://typespec.io/docs/language-basics/templates\n- document_content: # language-basics#templates.md\n\n# Templates\n\nTemplates are a powerful tool that allow users to customize certain aspects of a type. Similar to generics in other programming languages, templates define template parameters that users can specify when referencing the type.\r\n\r\nTemplates can be applied to:\r\n\r\n- [aliases](./alias.md)\r\n- [models](./models.md)\r\n- [operations](./operations.md)\r\n- [interfaces](./interfaces.md)\r\n\r\n```typespec\r\nmodel Page<Item> {\r\n  size: int32;\r\n  item: Item[];\r\n}\r\n\r\nmodel DogPage {\r\n  ...Page<Dog>;\r\n}\r\n```\n\n## Default values\n\nYou can assign a default value to a template parameter using `= <value>`.\r\n\r\n```typespec\r\nmodel Page<Item = string> {\r\n  size: int32;\r\n  item: Item[];\r\n}\r\n```\n\n## Parameter constraints\n\nYou can impose constraints on template parameters using the `extends` keyword. For details on how validation works, refer to the [type relations](./type-relations.md) documentation.\r\n\r\n```typespec\r\nalias Foo<Type extends string> = Type;\r\n```\r\n\r\nIf you try to instantiate Foo with an argument that does not meet the `string` constraint, you will encounter an error:\r\n\r\n```typespec\r\nalias Bar = Foo<123>;\r\n                ^ Type '123' is not assignable to type 'TypeSpec.string'\r\n```\r\n\r\nA template parameter constraint can also be a model expression:\r\n\r\n```typespec\r\n// Expect Type to be a model with property name: string\r\nalias Foo<Type extends {name: string}> = Type;\r\n```\r\n\r\nDefault values for template parameters must also adhere to the constraint:\r\n\r\n```typespec\r\nalias Foo<Type extends string = \"Abc\">  = Type;\r\n// Invalid\r\nalias Bar<Type extends string = 123>  = Type;\r\n                             ^ Type '123' is not assignable to type 'TypeSpec.string'\r\n```\r\n\r\nAlso, all optional arguments must be placed at the end of the template. A required argument cannot follow an optional argument:\r\n\r\n```typespec\r\n// Invalid\r\nalias Foo<T extends string = \"Abc\", U> = ...;\r\n                                    ^ Required template arguments must not follow optional template arguments\r\n```\n\n## Named template arguments\n\nTemplate arguments can also be specified by name. This allows you to specify them out of order and omit optional arguments. This can be particularly useful when dealing with templates that have many arguments with defaults:\r\n\r\n```typespec\r\nalias Test<T, U extends numeric = int32, V extends string = \"example\"> = {\r\n  t: T;\r\n  v: V;\r\n};\r\n\r\n// Specify the argument V by name to skip argument U, since U is optional and we\r\n// are okay with its default\r\nalias Example1 = Test<unknown, V = \"example1\">;\r\n\r\n// Even all three arguments can be specified out of order\r\nalias Example2 = Test<V = \"example2\", T = unknown, U = uint64>;\r\n```\r\n\r\nHowever, once a template argument is specified by name, all subsequent arguments must also be specified by name:\r\n\r\n```typespec\r\n// Invalid\r\nalias Example3 = Test<\r\n  V = \"example3\",\r\n  unknown,\r\n  ^^^^^^^ Positional template arguments cannot follow named arguments in the same argument list.\r\n>;\r\n```\r\n\r\nSince template arguments can be specified by name, the names of template parameters are part of the template's public API. **Renaming a template parameter may break existing specifications that use the template.**\r\n\r\n**Note**: Template arguments are evaluated in the order the parameters are defined in the template _definition_, not the order in which they are written in the template _instance_. While this is usually inconsequential, it may be important in some cases where evaluating a template argument may trigger decorators with side effects.\n\n## Templates with values\n\nTemplates can be declared to accept values using a `valueof` constraint. This is useful for providing default values and parameters for decorators that take values.\r\n\r\n```typespec\r\nalias TakesValue<StringType extends string, StringValue extends valueof string> = {\r\n  @doc(StringValue)\r\n  property: StringType;\r\n};\r\n\r\nalias M1 = TakesValue<\"a\", \"b\">;\r\n```\r\n\r\nWhen a passing a literal or an enum or union member reference directly as a template parameter that accepts either a type or a value, we pass the value. In particular, `StringTypeOrValue` is a value with the string literal type `\"a\"`.\r\n\r\n```typespec\r\nalias TakesTypeOrValue<StringTypeOrValue extends string | (valueof string)> = {\r\n  @customDecorator(StringOrValue)\r\n  property: string;\r\n};\r\n\r\nalias M1 = TakesValue<\"a\">;\r\n```\r\n\r\nThe [`typeof` operator](./values.md#the-typeof-operator) can be used to get the declared type of a value if needed.\n\n### Template parameter value types\n\nWhen a template is instantiated with a value, the type of the value and the result of the `typeof` operator is determined based on the argument rather than the template parameter constraint. This follows the same rules as [const declaration type inference](./values.md#const-declarations). In particular, inside the template `TakesValue`, the type of `StringValue` is the string literal type `\"b\"`. If we passed a `const` instead, the type of the value would be the const's type. In the following example, the type of `property` in `M1` is `\"a\" | \"b\"`.\r\n\r\n```typespec\r\nalias TakesValue<StringValue extends valueof string> = {\r\n  @doc(StringValue)\r\n  property: typeof StringValue;\r\n};\r\n\r\nconst str: \"a\" | \"b\" = \"a\";\r\nalias M1 = TakesValue<str>;\r\n```\n", "latency": 6.899743556976318, "response_length": 550}
{"query": "title: The compiler is added as dependency instead of peer dependency\n\nquestion: When you create a TypeSpec emitter with the template, @typespec/compiler is added as a dependency instead of a peer dependency. However, according to the [document](https://typespec.io/docs/extending-typespec/basics#step-3-defining-dependencies), you should\nUse peerDependencies for all TypeSpec libraries (and the compiler) that you use in your own library or emitter.\nIs this intended behavior or not?\n**How to reproduce**\n1.Install `@typespec/compiler@0.57.0`\n2.Run `tsp init --template emitter-ts`\nIn the generated \"package.json\", `@typespec/compiler` is added as a dependency.", "ground_truth": "This is a bug, and a corresponding issue has been created. [#3632](https://github.com/microsoft/typespec/issues/3632)", "response": "The behavior of adding `@typespec/compiler` as a dependency instead of a peer dependency when using the `tsp init --template emitter-ts` command is not aligned with the recommended practice outlined in the TypeSpec documentation. According to the documentation, TypeSpec libraries, including the compiler, should be defined as `peerDependencies` to avoid conflicts caused by multiple versions of the compiler or libraries running simultaneously. You can manually update the generated `package.json` file to move `@typespec/compiler` from `dependencies` to `peerDependencies` to follow the recommended approach.", "context": "- document_dir: typespec_docs\n- document_filename: extending-typespec#basics.md\n- document_title: Creating a TypeSpec Library\n- document_link: https://typespec.io/docs/extending-typespec/basics\n- document_content: # extending-typespec#basics.md\n\n# Creating a TypeSpec Library\n\nA TypeSpec library is a package that includes TypeSpec types, decorators, emitters or linters. These libraries are [npm packages](https://docs.npmjs.com/packages-and-modules/contributing-packages-to-the-registry) with some additional TypeSpec-specific metadata and conventions. This guide will walk you through the process of creating a new TypeSpec library, adding types to it, and distributing it on the public npm registry. Further sections will delve into the specifics of creating [decorators](create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md).\r\n\r\nWhile this guide assumes that you'll be using [TypeScript](https://typescriptlang.org) to develop your library, you can skip the TypeScript-related steps if you prefer to use plain JavaScript.\n\n## Prerequisites\n\nYou'll need to have both Node and npm installed. If you're planning to develop multiple libraries simultaneously, it's recommended to set up a monorepo to simplify the development process. TypeSpec itself uses [pnpm](https://pnpm.io/).\n\n## Setting up with templates\n\nYou can use the following templates:\r\n\r\n```bash\n\n# Create a TypeSpec library (Decorators & Linters) with TypeScript enabled.\n\ntsp init --template library-ts\n\n# Create a TypeSpec emitter with TypeScript enabled.\n\ntsp init --template emitter-ts\r\n```\n\n## Standard package structure\n\nHere's a high-level overview of what a TypeSpec package typically contains. Each of these files will be explained in more detail in the following sections.\r\n\r\n- **dist/index.js** - The main file for your Node library\r\n- **lib/main.tsp** - The main file for your TypeSpec types (optional)\r\n- **src/index.ts** - The main file for your Node library in TypeScript\r\n- **src/lib.ts** - The file that defines your TypeSpec library\r\n- **package.json** - Metadata about your TypeSpec package\n\n## Step 1: Initial setup\n\nYou can skip this step if you've used one of the templates above.\n\n### a. Initialize your package directory & package.json\n\nRun the following commands:\r\n\r\n```bash\r\nmkdir myLibrary\r\ncd myLibrary\r\nnpm init\r\n```\r\n\r\nAfter completing the wizard, you'll have a package.json file that defines your TypeSpec library.\r\n\r\nUnlike Node libraries which support CommonJS (cjs), TypeSpec libraries must be ECMAScript Modules. To specify this, open your `package.json` and add the following top-level configuration key:\r\n\r\n```jsonc\r\n  \"type\": \"module\"\r\n```\n\n### b. Install TypeSpec dependencies\n\nRun the following command:\r\n\r\n```bash\r\nnpm install --save-peer @typespec/compiler\r\n```\r\n\r\nYou might need to install other dependencies from the TypeSpec standard library. For example, if you want to use the metadata found in `@typespec/openapi`, you'll need to install that as well.\r\n\r\nRefer to the [dependency section](#step-3-defining-dependencies) for more information on defining your dependencies.\n\n### c. Define your main files\n\nYour package.json needs to refer to two main files: your Node module main file, and your TypeSpec main. The Node module main file is specified by the `\"main\"` key in your package.json file, and it defines the entry point for your library when it's used as a Node library. This must reference a JS file. The TypeSpec main defines the entry point for your library when it's used from a TypeSpec program, and it can reference either a JS file (when your library doesn't contain any TypeSpec types) or a TypeSpec file.\r\n\r\n```jsonc\r\n  \"main\": \"dist/src/index.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"typespec\": \"./lib/main.tsp\"\r\n    },\r\n    // Additional named export are possible\r\n    \"./experimental\": {\r\n      \"typespec\": \"./lib/experimental.tsp\"\r\n    },\r\n    // Wildcard export as well\r\n    \"./lib/*\": {\r\n      \"typespec\": \"./lib/*.tsp\"\r\n    }\r\n  }\r\n```\n\n### d. Install and initialize TypeScript\n\nRun the following commands:\r\n\r\n```bash\r\nnpm install -D typescript\r\nnpx tsc --init --strict\r\n```\r\n\r\nThis will create a `tsconfig.json` file. You'll need to make a few changes to this file. Open `tsconfig.json` and set the following settings:\r\n\r\n```jsonc\r\n\"module\": \"Node16\",           // This and next setting tells TypeScript to use the new ESM import system to resolve types.\r\n\"moduleResolution\": \"Node16\",\r\n\"target\": \"es2019\",\r\n\"rootDir\": \".\",\r\n\"outDir\": \"./dist\",\r\n\"sourceMap\": true,\r\n```\n\n### e. Create `lib.ts`\n\nOpen `./src/lib.ts` and create your library definition that registers your library with the TypeSpec compiler and defines any diagnostics your library will emit. Make sure to export the library definition as `$lib`.\r\n\r\n:::caution\r\nIf `$lib` is not accessible from your library package (for example, `import {$lib} from \"my-library\";`), some features such as linting and emitter option validation will not be available.\r\n:::\r\n\r\nFor example:\r\n\r\n```typescript\r\nimport { createTypeSpecLibrary } from \"@typespec/compiler\";\r\n\r\nexport const $lib = createTypeSpecLibrary({\r\n  name: \"myLibrary\",\r\n  diagnostics: {},\r\n} as const);\r\n\r\n// Optional but convenient, these are meant to be used locally in your library.\r\nexport const { reportDiagnostic, createDiagnostic } = $lib;\r\n```\r\n\r\nDiagnostics are used for linters and decorators, which are covered in subsequent topics.\n\n### f. Create `index.ts`\n\nOpen `./src/index.ts` and import your library definition:\r\n\r\n```typescript\r\n// Re-export $lib so the compiler can access it and register your library correctly.\r\nexport { $lib } from \"./lib.js\";\r\n```\n\n### g. Build TypeScript\n\nTypeSpec can only import JavaScript files, so any changes made to TypeScript sources need to be compiled before they are visible to TypeSpec. To do this, run `npx tsc -p .` in your library's root directory. If you want to re-run the TypeScript compiler whenever files are changed, you can run `npx tsc -p . --watch`.\r\n\r\nAlternatively, you can add these as scripts in your `package.json` to make them easier to invoke. Consider adding the following:\r\n\r\n```jsonc\r\n  \"scripts\": {\r\n    \"clean\": \"rimraf ./dist ./temp\",\r\n    \"build\": \"tsc -p .\",\r\n    \"watch\": \"tsc -p . --watch\",\r\n    \"test\": \"node --test ./dist/test/**/*.test.js\", // Node 22+\r\n    \"test\": \"node --test ./dist/test/\"              // Node 18, 20\r\n  }\r\n```\r\n\r\nYou can then run `npm run build` or `npm run watch` to build or watch your library.\n\n### h. Add your main TypeSpec file\n\nOpen `./lib/main.tsp` and import your JS entrypoint. This ensures that when TypeSpec imports your library, the code to define the library is run. When we add decorators in later topics, this import will ensure those get exposed as well.\r\n\r\n```typespec\r\nimport \"../dist/index.js\";\r\n```\n\n## Step 2: Adding TypeSpec types to your library\n\nOpen `./lib/main.tsp` and add any types you want to be available when users import this library. It's strongly recommended to put these types in a namespace that corresponds with the library name. For example, your `./lib/main.tsp` file might look like:\r\n\r\n```typespec\r\nimport \"../dist/index.js\";\r\n\r\nnamespace MyLibrary;\r\nmodel Person {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n```\n\n## Step 3: Defining dependencies\n\nWhen defining dependencies in a TypeSpec library, follow these rules:\r\n\r\n- Use `peerDependencies` for all TypeSpec libraries (and the compiler) that you use in your own library or emitter.\r\n- Use `devDependencies` for other TypeSpec libraries that are only used in tests.\r\n- Use `dependencies` or `devDependencies` for any other packages, depending on whether they're used in library code or in test/dev scripts.\r\n\r\nTypeSpec libraries are defined using `peerDependencies` to avoid having multiple versions of the compiler or library running at the same time.\r\n\r\n**Example**\r\n\r\n```jsonc\r\n{\r\n  \"dependencies\": {\r\n    \"yaml\": \"~2.3.1\", // This is a regular package this library/emitter will use\r\n  },\r\n  \"peerDependencies\": {\r\n    // These are all TypeSpec libraries this library/emitter depends on\r\n    \"@typespec/compiler\": \"~0.43.0\",\r\n    \"@typespec/http\": \"~0.43.1\",\r\n    \"@typespec/openapi\": \"~0.43.0\",\r\n  },\r\n  \"devDependencies\": {\r\n    // This TypeSpec library is only used in the tests but is not required to use this library.\r\n    \"@typespec/versioning\": \"~0.43.0\",\r\n    // TypeScript is only used during development\r\n    \"typescript\": \"~5.0.2\",\r\n  },\r\n}\r\n```\n\n## Step 4: Testing your TypeSpec library\n\nTypeSpec provides a testing framework to assist in testing libraries. The examples here are shown using Node.js's built-in test framework (available in Node 20+), but any other JS test framework can be used that will provide more advanced features like vitest, which is used in this project.\n\n### a. Add devDependencies\n\nEnsure that you have the following in your `package.json`:\r\n\r\n```json\r\n\"devDependencies\": {\r\n  \"@types/node\": \"~18.11.9\",\r\n  \"source-map-support\": \"^0.5.21\"\r\n}\r\n```\r\n\r\nAlso add a `vitest.config.ts` file at the root of your project.\r\n\r\n```ts\r\nimport { defineConfig, mergeConfig } from \"vitest/config\";\r\n\r\nexport default defineConfig({\r\n  test: {\r\n    environment: \"node\",\r\n    // testTimeout: 10000, // Uncomment to increase the default timeout\r\n    isolate: false, // Your test shouldn't have side effects to this will improve performance.\r\n  },\r\n});\r\n```\n\n### b. Define the testing library\n\nThe first step is to define how your library can be loaded from the test framework. This will allow your library to be reused by other library tests.\r\n\r\n1. Create a new file `./src/testing/index.ts` with the following content\r\n\r\n```ts\r\nimport { createTestLibrary, findTestPackageRoot } from \"@typespec/compiler/testing\";\r\n\r\nexport const MyTestLibrary = createTestLibrary({\r\n  name: \"<name-of-npm-pkg>\",\r\n  // Set this to the absolute path to the root of the package. (e.g. in this case this file would be compiled to ./dist/src/testing/index.js)\r\n  packageRoot: await findTestPackageRoot(import.meta.url),\r\n});\r\n```\r\n\r\n2. Add an `exports` for the `testing` endpoint to `package.json` (update with correct paths)\r\n\r\n```jsonc\r\n{\r\n  // ...\r\n  \"main\": \"dist/src/index.js\",\r\n  \"exports\": {\r\n    \".\": {\r\n      \"default\": \"./dist/src/index.js\",\r\n      \"types\": \"./dist/src/index.d.ts\",\r\n    },\r\n    \"./testing\": {\r\n      \"default\": \"./dist/src/testing/index.js\",\r\n      \"types\": \"./dist/src/testing/index.d.ts\",\r\n    },\r\n  },\r\n}\r\n```\n\n### c. Define the test host and test runner for your library\n\nDefine some of the test framework base pieces that will be used in the tests. There are 2 functions:\r\n\r\n- `createTestHost`: This is a lower-level API that provides a virtual file system.\r\n- `createTestRunner`: This is a wrapper on top of the test host that will automatically add a `main.tsp` file and automatically import libraries.\r\n\r\nCreate a new file `test/test-host.js` (change `test` to be your test folder)\r\n\r\n```ts\r\nimport { createTestHost, createTestWrapper } from \"@typespec/compiler/testing\";\r\nimport { RestTestLibrary } from \"@typespec/rest/testing\";\r\nimport { MyTestLibrary } from \"../src/testing/index.js\";\r\n\r\nexport async function createMyTestHost() {\r\n  return createTestHost({\r\n    libraries: [RestTestLibrary, MyTestLibrary], // Add other libraries you depend on in your tests\r\n  });\r\n}\r\nexport async function createMyTestRunner() {\r\n  const host = await createMyTestHost();\r\n  return createTestWrapper(host, { autoUsings: [\"My\"] });\r\n}\r\n```\n\n### d. Write tests\n\nAfter setting up that infrastructure you can start writing tests. By default Node.js will run all files matching these patterns:\r\n\r\n```\r\n**/*.test.?(c|m)js\r\n**/*-test.?(c|m)js\r\n**/*_test.?(c|m)js\r\n**/test-*.?(c|m)js\r\n**/test.?(c|m)js\r\n**/test/**/*.?(c|m)js\r\n```\r\n\r\n[See nodejs doc](https://nodejs.org/api/test.html)\r\n\r\n```ts\r\nimport { createMyTestRunner } from \"./test-host.js\";\r\nimport { describe, beforeEach, it } from \"node:test\";\r\n\r\ndescribe(\"my library\", () => {\r\n  let runner: BasicTestRunner;\r\n\r\n  beforeEach(async () => {\r\n    runner = await createMyTestRunner();\r\n  });\r\n\r\n  // Check everything works fine\r\n  it(\"does this\", async () => {\r\n    const { Foo } = await runner.compile(`\r\n      @test model Foo {}\r\n    `);\r\n    strictEqual(Foo.kind, \"Model\");\r\n  });\r\n\r\n  // Check diagnostics are emitted\r\n  it(\"errors\", async () => {\r\n    const diagnostics = await runner.diagnose(`\r\n       model Bar {}\r\n    `);\r\n    expectDiagnostics(diagnostics, { code: \"...\", message: \"...\" });\r\n  });\r\n});\r\n```\r\n\r\n#### e. `@test` decorator\r\n\r\nThe `@test` decorator is a decorator loaded in the test environment. It can be used to collect any decorable type.\r\nWhen using the `compile` method it will return a `Record<string, Type>` which is a map of all the types annotated with the `@test` decorator.\r\n\r\n```ts\r\nconst { Foo, CustomName } = await runner.compile(`\r\n  @test model Foo {}\r\n\r\n  model Bar {\r\n    @test(\"CustomName\") name: string\r\n  }\r\n`);\r\n\r\nFoo; // type of: model Foo {}\r\nCustomName; // type of : Bar.name\r\n```\r\n\r\n#### f. Install VS Code extension for the test framework\r\n\r\nIf you are using VS Code, you can install the [Node test runner](https://marketplace.visualstudio.com/items?itemName=connor4312.nodejs-testing) to run your tests from the editor. This will also allow you to easily debug your tests.\r\n\r\nAfter installing the extension, you should be able to discover, run, and debug your tests from the test explorer.\n\n## Step 5: Publishing your TypeSpec library\n\nTo publish your library to the public npm registry, follow the instructions in the [npm documentation](https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages).\n\n## Step 6: Importing your TypeSpec library\n\nOnce your TypeSpec library is published, users can install and use it just like any of the standard TypeSpec libraries. First, they need to install it:\r\n\r\n```bash\r\nnpm install $packageName\r\n```\r\n\r\nNext, they can import it into their TypeSpec program and use the namespace (if desired):\r\n\r\n```typespec\r\nimport \"MyLibrary\";\r\nusing MyLibrary;\r\n\r\nmodel Employee extends Person {\r\n  job: string;\r\n}\r\n```\n\n## Step 7: Next steps\n\nTypeSpec libraries can contain more than just types. For more details on how to write [decorators](./create-decorators.md), [emitters](./emitters-basics.md) and [linters](./linters.md), refer to the subsequent topics.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#00howtogen.mdx\n- document_title: How to generate client libraries\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/00howtogen\n- document_content: # howtos#generate-client-libraries#00howtogen.mdx\n\n# How to generate client libraries\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page outlines the steps to build a client library based on your TypeSpec specification. It provides a guide for the whole process from initial API design to the release of SDKs. please visit https://aka.ms/azsdk/dpcodegen.\r\n\r\nThe best documentation on how to generate can be found using those links:\r\n\r\n- https://aka.ms/azsdk/dpcodegen/net\r\n- https://aka.ms/azsdk/dpcodegen/python\r\n- https://aka.ms/azsdk/dpcodegen/java\r\n- https://aka.ms/azsdk/rlc/js\r\n- https://aka.ms/azsdk/dpcodegen/js (do not use unless told to do so by the archboard)\r\n\r\nAt a glance, add your emitter name to your `package.json`, along with the right options in the `tspconfig.yaml`.\r\n\r\n> **NOTE:** Generating all languages from the same folder may be complicated due to the preview status of the emitters and TypeSpec libraries, such as `typespec-azure-core` and `typespec-azure-resource-manager`.\r\n> It is recommended to have a unique language emitter in each `package.json` to avoid conflicts until all emitters and the TypeSpec libraries reach their first stable release.\r\n\r\nModify your `package.json` to include the necessary dependencies for the language emitter(s). Remember to run `npm install` after making changes to the file:\r\n\r\n```json\r\n{\r\n  \"name\": \"clients\",\r\n  \"dependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/rest\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@azure-tools/typespec-azure-core\": \"latest\",\r\n    \"@azure-tools/typespec-autorest\": \"latest\",\r\n    \"@azure-tools/typespec-python\": \"latest\",\r\n    \"@azure-tools/typespec-java\": \"latest\",\r\n    \"@azure-tools/typespec-csharp\": \"latest\",\r\n    \"@azure-tools/typespec-ts\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\r\n\r\nAlways update your `tspconfig.yaml` file rather than passing options through the command line.\r\n\r\n```yaml\r\nemit:\r\n  # Emitter for Swagger files with Autorest Extensions\r\n  - \"@azure-tools/typespec-autorest\"\n\n\"latest\",\r\n    \"@azure-tools/typespec-autorest\": \"latest\",\r\n    \"@azure-tools/typespec-python\": \"latest\",\r\n    \"@azure-tools/typespec-java\": \"latest\",\r\n    \"@azure-tools/typespec-csharp\": \"latest\",\r\n    \"@azure-tools/typespec-ts\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\r\n\r\nAlways update your `tspconfig.yaml` file rather than passing options through the command line.\r\n\r\n```yaml\r\nemit:\r\n  # Emitter for Swagger files with Autorest Extensions\r\n  - \"@azure-tools/typespec-autorest\"\r\n  # add \"@azure-tools/typespec-python\" to your package.json to generate Python code\r\n  - \"@azure-tools/typespec-python\"\r\n  # add \"@azure-tools/typespec-java\" to your package.json to generate Java code\r\n  - \"@azure-tools/typespec-java\"\r\n  # add \"@azure-tools/typespec-csharp\" to your package.json to generate C# code\r\n  - \"@azure-tools/typespec-csharp\"\r\n  # add \"@azure-tools/typespec-ts\" to your package.json to generate Typescript code\r\n  - \"@azure-tools/typespec-ts\"\r\noptions:\r\n  \"@azure-tools/typespec-python\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-java\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-csharp\":\r\n    flavor: azure\r\n  \"@azure-tools/typespec-ts\":\r\n    flavor: azure\r\n```\r\n\r\nSeveral language repositories utilize the `tsp-client` tool to simplify generating client libraries. For more information on the tool, see [Getting started with `tsp-client`](<./../Generating with tsp-client/tsp_client.md>).\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n", "latency": 7.438507080078125, "response_length": 610}
{"query": "title: Is it possible to \"Pick\" a subset of properties into a model?\n\nquestion: The usecase is that we have models that are used by different apis, sometimes with only a subset of the properties. For example, emitting CustomerCreated events to a webhook that only include id, name, email from Customer.\nI could create BaseCustomer and have multiple things extend it, but maybe there's another way?\ne.g.\n```\nmodel Widget {\n@key id: string;\nweight: int32;\ncolor: \"red\" | \"blue\";\n}\nmodel WidgetNoColor extends Pick<Widget, \"id\" | \"weight\"> {\n}\nmodel WidgetNoWeight extends Widget {\nweight: never;\n}\nmodel WidgetCreatedEvent {\nwidgetId: Widget[\"id\"]\n}\n```", "ground_truth": "The user initially wanted `Pick` support in TypeSpec, similar to the existing `Omit` type. After discussing potential solutions like decorators or splitting models, it was confirmed that `Pick` was implemented and released in TypeSpec 0.57. The conversation also touched on the idea of supporting utility types like `Omit` and `Pick` as first-class types in TypeSpec, but there wasn’t a clear design for this at the time.", "response": "Yes, it is possible to create models with subsets of properties in TypeSpec using various approaches. Based on your example, here are two recommended methods:\n\n1. **Using the `extends` keyword**:\n   You can create a new model that explicitly extends another model, inheriting its properties. This approach allows you to define additional properties or override existing ones. For example:\n   ```typespec\n   model Widget {\n     id: string;\n     weight: int32;\n     color: \"red\" | \"blue\";\n   }\n\n   model WidgetNoColor extends Widget {\n     color: never;\n   }\n   ```\n   In this example, `WidgetNoColor` inherits all properties from `Widget` but explicitly removes the `color` property by setting its type to `never`.\n\n2. **Using the `spread` operator (`...`)**:\n   You can use the spread operator to copy specific properties from one model into another. This is useful for creating models with subsets of properties without creating inheritance relationships:\n   ```typespec\n   model Widget {\n     id: string;\n     weight: int32;\n     color: \"red\" | \"blue\";\n   }\n\n   model WidgetSubset {\n     id: string;\n     weight: int32;\n   }\n   ```\n   Alternatively, you can use the spread operator:\n   ```typespec\n   model WidgetSubset {\n     ...Widget;\n     color: never;\n   }\n   ```\n   This approach allows you to reuse properties while explicitly excluding or modifying certain ones.\n\nBoth methods are valid and depend on whether you want to establish a nominal inheritance relationship (`extends`) or simply reuse properties (`spread`).", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n- document_title: Getting Started with TypeSpec For REST APIs\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\n- document_content: # getting-started#getting-started-rest#01-setup-basic-syntax.mdx\n\n# Getting Started with TypeSpec For REST APIs\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nWelcome to our tutorial on using TypeSpec to define REST APIs with HTTP. In this section, we'll introduce you to TypeSpec, help you set up your development environment, and cover the basic syntax and structure of TypeSpec. By the end of this section, you'll have a solid foundation to build upon in the subsequent sections.\n\n### What is TypeSpec?\n\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\r\n\r\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\r\n\r\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\n\n### Summary of Setup and Installation\n\n1. **Install Node.js**: Download and install Node.js from [nodejs.org](https://nodejs.org/). This will also install npm, the Node.js package manager. The minimum versions required are Node.js 20.0.0 and npm 7.0.0.\r\n2. **Install TypeSpec CLI**: Run `npm install -g @typespec/compiler` to install the TypeSpec CLI.\r\n3. **Verify Installation**: Run `tsp --version` to verify that the TypeSpec CLI is installed correctly.\r\n4. **Create a New Project**:\r\n   - Run `tsp init` and select the `Generic REST API` template.\r\n   - Run `tsp install` to install dependencies.\r\n   - Run `tsp compile .` to compile the initial file.\r\n   - Run `tsp compile . --watch` to automatically compile changes on save.\n\n### Project Structure Overview\n\nOnce you've completed these steps, you'll have a basic TypeSpec project set up. Here's an overview of the files and directories in your TypeSpec project:\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3/\r\n      - openapi.yaml\r\n</FileTree>\r\n\r\n- **main.tsp**: Entry point for TypeSpec definitions.\r\n- **tspconfig.yaml**: TypeSpec compiler configuration.\r\n- **package.json**: Project metadata and dependencies.\r\n- **node_modules/**: Installed dependencies.\r\n- **tsp-output/**: Generated files.\r\n- **openapi.yaml**: Generated OpenAPI specification.\r\n\r\nAs we work through the tutorial, keep the openapi.yaml file open in Visual Studio or VS Code to watch the API specification evolve as we make changes.\n\n## Basic Syntax and Structure\n\nNow that we have our environment set up, let's dive into the basic syntax and structure of TypeSpec. We'll create a simple REST API for a pet store by introducing concepts in a layered fashion, increasing complexity as we progress through the tutorial.\r\n\r\nAs the tutorial advances and the code examples grow more complex, we'll highlight changes in the code to help you easily spot where new lines have been added.\n\n### Import and Using Statements\n\nBefore defining models and services, we need to import the necessary TypeSpec libraries and make them available in our namespace.\r\n\r\nAs we progress through the tutorial, you can follow along by updating the `main.tsp` file in your project and compiling the changes to see the results reflected in the generated `openapi.yaml` specification.\r\n\r\nYou can also alternatively use the `Try it` feature with the code samples to quickly view the generated OpenAPI spec in your browser via the TypeSpec Playground.\r\n\r\nLet's begin by adding the following import and using statements to the `main.tsp` file:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n```\r\n\r\nIn this example:\r\n\r\n- `import` statement brings in the [TypeSpec HTTP library](../../../libraries/http/reference/), which provides the decorators and models we'll be using to define our REST API.\r\n- `using` statement makes the imported library available in the current namespace, allowing us to use its features and decorators.\r\n\r\n**NOTE: Your generated project file likely already has these import/using statements, plus import/using for the `@typespec/openapi3` library. The `@typespec/openapi3` library is necessary for emitting the OpenAPI specification file but is not required for creating our Pet Store API in TypeSpec. Remove them from your `main.tsp` file so your code matches the example above.**\n\n## Defining a REST Service\n\nA REST service in TypeSpec is defined using the [`@service`](../../../standard-library/built-in-decorators/#@service) decorator. This decorator allows you to specify metadata about your service, such as its title. Additionally, you can use the [`@server`](../../../libraries/http/reference/decorators/#@TypeSpec.Http.server) decorator to define the server endpoint where your service will be hosted.\n\n### Example: Defining a Service with a Title and Server Endpoint\n\nLet's start by defining a simple REST service for a Pet Store:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n// highlight-start\r\n@service(#{\r\n  title: \"Pet Store\",\r\n})\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `@service` decorator is used to define a service with the title \"Pet Store\".\r\n- The `@server` decorator specifies the server endpoint for the service, which is \"https://example.com\".\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining the `info` object (which includes the title) and the `servers` array (which includes the server URL).\r\n\r\n**NOTE: This code will not compile as-is because we've not yet defined a `namespace` for these decorators to apply to. We'll cover that topic next.**\n\n## Organizing with Namespaces\n\n[Namespaces](../../language-basics/namespaces.md) in TypeSpec help you organize your models and operations logically. They act as containers for related definitions, making your API easier to manage and understand.\n\n### Example: Creating a Namespace\n\nLet's create a namespace for our Pet Store service:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n\r\n// highlight-next-line\r\nnamespace PetStore;\r\n```\r\n\r\nIn this example:\r\n\r\n- The `namespace` keyword is used to define a top-level namespace named `PetStore`.\r\n- All models and operations related to the Pet Store service will be defined within this namespace.\r\n- The first use of namespace defines the top-level namespace and does not require brackets. This is because it serves as the primary container for all related definitions.\r\n- Any subsequent namespaces defined within this top-level namespace will require brackets {} to indicate that they are nested within the top-level namespace.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, namespaces are similar to using tags to group related operations and definitions.\n\n## Defining Models\n\nIn TypeSpec, a [model](../../language-basics/models.md) is a fundamental building block used to define the structure of data. Models are used to represent entities, such as a `Pet`, with various properties that describe the entity's attributes.\n\n### Example: Defining a Simple Model\n\nLet's define a simple model for a `Pet`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nmodel Pet {\r\n  id: int32;\r\n  name: string;\r\n  age: int32;\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `model` keyword is used to define a new model named `Pet`.\r\n- The `Pet` model has four properties: `id`, `name`, `age`, and `kind`.\r\n- The `petType` [`enum`](../../language-basics/enums.md) defines possible values for the `kind` property.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to defining a `schema` object under the `components` section, where you define the structure and properties of your data models.\n\n### Example: Adding Validation Annotations\n\nWe can add [validation](../../../language-basics/values/#validation) annotations to our model properties to enforce certain constraints:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  // highlight-next-line\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  // highlight-next-line\r\n  @minValue(0)\r\n  // highlight-next-line\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- `@minLength(1)` ensures that the `name` property has at least one character.\r\n- `@minValue(0)` and `@maxValue(100)` ensure that the `age` property is between 0 and 100.\r\n\r\n**OpenAPI Comparison**: In OpenAPI, this is similar to using `minLength`, `minimum`, and `maximum` constraints within the `schema` object.\n\n## Conclusion\n\nIn this section, we introduced you to TypeSpec, set up the development environment, and covered basic language syntax and structure. We defined a simple REST service, organized our API using namespaces, and defined a model with validation annotations.\r\n\r\nWith this foundational knowledge, you're now ready to dive deeper into defining operations and handling different types of responses in your REST API. In the next section, we'll expand our API by adding CRUD operations.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#models.md\n- document_title: Models\n- document_link: https://typespec.io/docs/language-basics/models\n- document_content: # language-basics#models.md\n\n# Models\n\nModels in TypeSpec are utilized to define the structure or schema of data.\n\n## Types of models\n\nModels can be categorized into two main types:\r\n\r\n- [Record](#record)\r\n- [Array](#array)\n\n### Record\n\nA Record model is a structure that consists of named fields, referred to as properties.\r\n\r\n- The name can be an [`identifier`](./identifiers.md) or `string literal`.\r\n- The type can be any type reference.\r\n- Properties are arranged in a specific order. Refer to [property ordering](#property-ordering) for more details.\r\n\r\n```typespec\r\nmodel Dog {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n```\r\n\r\n#### Optional properties\r\n\r\nProperties can be designated as optional by using the `?` symbol.\r\n\r\n```typespec\r\nmodel Dog {\r\n  address?: string;\r\n}\r\n```\r\n\r\n#### Default values\r\n\r\nProperties can be assigned a default value using the `=` operator.\r\n\r\n```typespec\r\nmodel Dog {\r\n  address?: string = \"wild\";\r\n  age: uint8 = 0;\r\n}\r\n```\r\n\r\n#### Property ordering\r\n\r\nProperties are arranged in the order they are defined in the source. Properties acquired via `model is` are placed before properties defined in the model body. Properties obtained via `...` are inserted at the point where the spread appears in the source.\r\n\r\nExample:\r\n\r\n```tsp\r\nmodel Pet {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n\r\nmodel HasHome {\r\n  address: string;\r\n}\r\n\r\nmodel Cat is Pet {\r\n  meow: boolean;\r\n  ...HasHome;\r\n  furColor: string;\r\n}\r\n\r\n// The resulting property order for Cat is:\r\n// name, age, meow, address, furColor\r\n```\n\n### Additional properties\n\nThe `Record<T>` model can be used to define a model with an arbitrary number of properties of type T. It can be combined with a named model to provide some known properties.\r\n\r\nThere are three ways to achieve this, each with slightly different semantics:\r\n\r\n- Using the `...` operator\r\n- Using the `is` operator\r\n- Using the `extends` operator\r\n\r\n#### Using the `...` operator\r\n\r\nSpreading a Record into your model implies that your model includes all the properties you have explicitly defined, plus any additional properties defined by the Record. This means that a property in the model could be of a different and incompatible type with the Record value type.\r\n\r\n```tsp\r\n// In this example, the Person model has a property `age` that is an int32, but also has other properties that are all strings.\r\nmodel Person {\r\n  age: int32;\r\n  ...Record<string>;\r\n}\r\n```\r\n\r\n#### Using the `is` operator\r\n\r\nWhen using `is Record<T>`, it indicates that all properties of this model are of type T. This means that each property explicitly defined in the model must also be of type T.\r\n\r\nThe example above would be invalid\r\n\r\n```tsp\r\nmodel Person is Record<string> {\r\n  age: int32;\r\n  //   ^ int32 is not assignable to string\r\n}\r\n```\r\n\r\nBut the following would be valid\r\n\r\n```tsp\r\nmodel Person is Record<string> {\r\n  name: string;\r\n}\r\n```\r\n\r\n#### Using the `extends` operator\r\n\r\nThe `extends` operator has similar semantics to `is`, but it defines the relationship between the two models. In many languages, this would probably result in the same emitted code as `is` and it is recommended to use `is Record<T>` instead.\r\n\r\n```tsp\r\nmodel Person extends Record<string> {\r\n  name: string;\r\n}\r\n```\n\n### Special property types\n\n#### `never`\r\n\r\nA model property can be declared as having the type `never`. This can be interpreted as the model not having that property.\r\n\r\nThis can be useful in a model template to omit a property.\r\n\r\n```typespec\r\nmodel Address<TState> {\r\n  state: TState;\r\n  city: string;\r\n  street: string;\r\n}\r\n\r\nmodel UKAddress is Address<never>;\r\n```\r\n\r\n:::note\r\nThe responsibility of removing `never` properties lies with the emitter. The TypeSpec compiler will not automatically omit them.\r\n:::\n\n### Array\n\nArrays are models created using the `[]` syntax, which is a shorthand for using the `Array<T>` model type.\n\n## Model composition\n\n### Spread\n\nThe spread operator (`...`) copies the members of a source model into a target model. This operation doesn't create any nominal relationship between the source and target, making it useful when you want to reuse common properties without generating complex inheritance relationships.\r\n\r\n```typespec\r\nmodel Animal {\r\n  species: string;\r\n}\r\n\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Dog {\r\n  ...Animal;\r\n  ...Pet;\r\n}\r\n\r\n// The Dog model is equivalent to the following declaration:\r\nmodel Dog {\r\n  species: string;\r\n  name: string;\r\n}\r\n```\n\n### Extends\n\nThere are times when you want to create an explicit relationship between two models, such as when you're generating class definitions in languages that support inheritance. The `extends` keyword can be used to establish this relationship.\r\n\r\n```typespec\r\nmodel Animal {\r\n  species: string;\r\n}\r\n\r\nmodel Dog extends Animal {}\r\n```\n\n### Is\n\nThere are instances when you want to create a new type that is an exact copy of an existing type but with additional properties or metadata, without creating a nominal inheritance relationship. The `is` keyword can be used for this purpose. It copies all the properties (like spread), but also copies [decorators](./decorators.md) as well. A common use case is to provide a better name to a [template](#model-templates) instantiation:\r\n\r\n```typespec\r\n@decorator\r\nmodel Thing<T> {\r\n  property: T;\r\n}\r\n\r\nmodel StringThing is Thing<string>;\r\n\r\n// The StringThing declaration is equivalent to the following declaration:\r\n@decorator\r\nmodel StringThing {\r\n  property: string;\r\n}\r\n```\n\n## Model templates\n\nRefer to [templates](./templates.md) for more details on templates.\r\n\r\n```typespec\r\nmodel Page<Item> {\r\n  size: int32;\r\n  item: Item[];\r\n}\r\n\r\nmodel DogPage {\r\n  ...Page<Dog>;\r\n}\r\n```\n\n## Meta type references\n\nSome model property meta types can be referenced using `::`.\r\n\r\n| Name | Example          | Description                              |\r\n| ---- | ---------------- | ---------------------------------------- |\r\n| type | `Pet.name::type` | Reference the type of the model property |\n", "latency": 12.65680718421936, "response_length": 1526}
{"query": "title: Error in TypeSpec Code: duplicate-property: Model already has a property named\n\nquestion: When I write the code as below, I get an error duplicate-property: Model already has a property named countryCode.\nWhy is this happening?\n```\nimport \"@typespec/http\";\nusing TypeSpec.Http;\n@tag(\"Country\")\n@route(\"/countries\")\ninterface Countries {\n@route(\"{countryCode}/update\") @post update(@path countryCode: string, ...Country): void | Error;\n}\n@doc(\"Country\")\nmodel Country {\n@doc(\"countryCode\")\ncountryCode: string;\n@doc(\"countryName\")\ncountryName: string;\n}\n```\n```\ncountries.tsp:8:76 - error duplicate-property: Model already has a property named countryCode\n> 8 |     @route(\"{countryCode}/update\") @post update(@path countryCode: string, ...Country): void | Error;\n|                                                                            ^^^^^^^^^^\nFound 1 error.\n```\nIs it not possible to use a property name from the model as a path parameter?", "ground_truth": "Depending on what you exactly want to do here, there is 2 options\n```\nimport \"@typespec/http\";\nusing TypeSpec.Http;\n// Option 1 - here you reuse the same property\n@route(\"1/{countryCode}/update\") op read1(...Country1): void;\nmodel Country1 {\n@path countryCode: string;\ncountryName: string;\n}\n// Option 2 - here the country is just the body and you still have an explicit path param\n@route(\"2/{countryCode}/update\") op read2(\n@path countryCode: string,\n@body country: Country2,\n): void;\nmodel Country2 {\ncountryCode: string;\ncountryName: string;\n}\n```\n[Playground example](https://typespec.io/playground?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7Cgp1c2luZyBUeXBlU3BlYy5IdHRwOwoKLy8gT3B0aW9uIDEKQHJvdXRlKCIxL3tjb3VudHJ5Q29kZX0vdXBkYXRlIikgb3AgcmVhZDEoLi4uQ8YiMSk6IHZvaWQ7Cgptb2RlbCDIGCB7CiAgQHBhdGggy006IHN0cmluZzsKIMgXTmFtyxd97ACTMukAkzL%2FAJMyKNxuLMQdYm9kecgdOugApzIsCvcAwTLlAMH%2FALvvALs%3D&e=%40typespec%2Fopenapi3&options=%7B%7D)", "response": "The error occurs because the `countryCode` property is defined twice in the operation `update`. Once as a path parameter (`@path countryCode: string`) and again as part of the `Country` model, which is spread into the operation using `...Country`. This results in a conflict because TypeSpec does not allow duplicate property names within the same operation.\n\nTo resolve this issue, you can exclude the `countryCode` property from the `Country` model when spreading it into the operation. Use the `@bodyIgnore` decorator to exclude the `countryCode` property from being included in the HTTP body:\n\n```typespec\nimport \"@typespec/http\";\nusing TypeSpec.Http;\n\n@tag(\"Country\")\n@route(\"/countries\")\ninterface Countries {\n  @route(\"{countryCode}/update\") \n  @post \n  update(@path countryCode: string, @body country: Omit<Country, \"countryCode\">): void | Error;\n}\n\n@doc(\"Country\")\nmodel Country {\n  @doc(\"countryCode\")\n  countryCode: string;\n  @doc(\"countryName\")\n  countryName: string;\n}\n```\n\nIn this example, the `Omit` utility is used to exclude the `countryCode` property from the `Country` model when passing it as the body parameter. This ensures there is no duplication of the `countryCode` property in the operation.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#http#reference#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/libraries/http/reference/decorators\n- document_content: # libraries#http#reference#decorators.md\n\n# Decorators\n\n## TypeSpec.Http\n\n### `@body` {#@TypeSpec.Http.body}\n\nExplicitly specify that this property type will be exactly the HTTP body.\r\n\r\nThis means that any properties under `@body` cannot be marked as headers, query parameters, or path parameters.\r\nIf wanting to change the resolution of the body but still mix parameters, use `@bodyRoot`.\r\n\r\n```typespec\r\n@TypeSpec.Http.body\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(@body image: bytes): void;\r\nop download(): {\r\n  @body image: bytes;\r\n};\r\n```\n\n### `@bodyIgnore` {#@TypeSpec.Http.bodyIgnore}\n\nSpecify that this property shouldn't be included in the HTTP body.\r\nThis can be useful when bundling metadata together that would result in an empty property to be included in the body.\r\n\r\n```typespec\r\n@TypeSpec.Http.bodyIgnore\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(\r\n  name: string,\r\n  @bodyIgnore headers: {\r\n    @header id: string;\r\n  },\r\n): void;\r\n```\n\n### `@bodyRoot` {#@TypeSpec.Http.bodyRoot}\n\nSpecify that the body resolution should be resolved from that property.\r\nBy default the body is resolved by including all properties in the operation request/response that are not metadata.\r\nThis allows to nest the body in a property while still allowing to use headers, query parameters, and path parameters in the same model.\r\n\r\n```typespec\r\n@TypeSpec.Http.bodyRoot\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(\r\n  @bodyRoot user: {\r\n    name: string;\r\n    @header id: string;\r\n  },\r\n): void;\r\nop download(): {\r\n  @bodyRoot user: {\r\n    name: string;\r\n    @header id: string;\r\n  };\r\n};\r\n```\n\n### `@cookie` {#@TypeSpec.Http.cookie}\n\nSpecify this property is to be sent or received in the cookie.\r\n\r\n```typespec\r\n@TypeSpec.Http.cookie(cookieNameOrOptions?: valueof string | TypeSpec.Http.CookieOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name                | Type                                            | Description                                                                                                                                                                                       |\r\n| ------------------- | ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| cookieNameOrOptions | `valueof string \\| TypeSpec.Http.CookieOptions` | Optional name of the cookie in the cookie or cookie options.<br />By default the cookie name will be the property name converted from camelCase to snake_case. (e.g. `authToken` -> `auth_token`) |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(@cookie token: string): {\r\n  data: string[];\r\n};\r\nop create(\r\n  @cookie({\r\n    name: \"auth_token\",\r\n  })\r\n  data: string[],\r\n): void;\r\n```\r\n\r\n##### Implicit header name\r\n\r\n```typespec\r\nop read(): {\r\n  @cookie authToken: string;\r\n}; // headerName: auth_token\r\nop update(@cookie AuthToken: string): void; // headerName: auth_token\r\n```\n\n### `@delete` {#@TypeSpec.Http.delete}\n\nSpecify the HTTP verb for the target operation to be `DELETE`.\r\n\r\n```typespec\r\n@TypeSpec.Http.delete\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@delete op set(petId: string): void;\r\n```\n\n### `@get` {#@TypeSpec.Http.get}\n\nSpecify the HTTP verb for the target operation to be `GET`.\r\n\r\n```typespec\r\n@TypeSpec.Http.get\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@get op read(): string;\r\n```\n\n### `@head` {#@TypeSpec.Http.head}\n\nSpecify the HTTP verb for the target operation to be `HEAD`.\r\n\r\n```typespec\r\n@TypeSpec.Http.head\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@head op ping(petId: string): void;\r\n```\n\n### `@header` {#@TypeSpec.Http.header}\n\nSpecify this property is to be sent or received as an HTTP header.\r\n\r\n```typespec\r\n@TypeSpec.Http.header(headerNameOrOptions?: valueof string | TypeSpec.Http.HeaderOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name                | Type                                            | Description                                                                                                                                                                                                 |\r\n| ------------------- | ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| headerNameOrOptions | `valueof string \\| TypeSpec.Http.HeaderOptions` | Optional name of the header when sent over HTTP or header options.<br />By default the header name will be the property name converted from camelCase to kebab-case. (e.g. `contentType` -> `content-type`) |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(@header accept: string): {\r\n  @header(\"ETag\") eTag: string;\r\n};\r\nop create(\r\n  @header({\r\n    name: \"X-Color\",\r\n    format: \"csv\",\r\n  })\r\n  colors: string[],\r\n): void;\r\n```\r\n\r\n##### Implicit header name\r\n\r\n```typespec\r\nop read(): {\r\n  @header contentType: string;\r\n}; // headerName: content-type\r\nop update(@header ifMatch: string): void; // headerName: if-match\r\n```\n\n### `@multipartBody` {#@TypeSpec.Http.multipartBody}\n\n```typespec\r\n@TypeSpec.Http.multipartBody\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nop upload(\r\n  @header `content-type`: \"multipart/form-data\",\r\n  @multipartBody body: {\r\n    fullName: HttpPart<string>;\r\n    headShots: HttpPart<Image>[];\r\n  },\r\n): void;\r\n```\n\n### `@patch` {#@TypeSpec.Http.patch}\n\nSpecify the HTTP verb for the target operation to be `PATCH`.\r\n\r\n```typespec\r\n@TypeSpec.Http.patch(options?: valueof TypeSpec.Http.PatchOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                 | Description                      |\r\n| ------- | -------------------------------------------------------------------- | -------------------------------- |\r\n| options | [valueof `PatchOptions`](./data-types.md#TypeSpec.Http.PatchOptions) | Options for the PATCH operation. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@patch op update(pet: Pet): void;\r\n```\r\n\r\n```typespec\r\n// Disable implicit optionality, making the body of the PATCH operation use the\r\n// optionality as defined in the `Pet` model.\r\n@patch(#{ implicitOptionality: false })\r\nop update(pet: Pet): void;\r\n```\n\n### `@path` {#@TypeSpec.Http.path}\n\nExplicitly specify that this property is to be interpolated as a path parameter.\r\n\r\n```typespec\r\n@TypeSpec.Http.path(paramNameOrOptions?: valueof string | TypeSpec.Http.PathOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name               | Type                                          | Description                                                    |\r\n| ------------------ | --------------------------------------------- | -------------------------------------------------------------- |\r\n| paramNameOrOptions | `valueof string \\| TypeSpec.Http.PathOptions` | Optional name of the parameter in the uri template or options. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@route(\"/read/{explicit}/things/{implicit}\")\r\nop read(@path explicit: string, implicit: string): void;\r\n```\n\n### `@post` {#@TypeSpec.Http.post}\n\nSpecify the HTTP verb for the target operation to be `POST`.\r\n\r\n```typespec\r\n@TypeSpec.Http.post\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@post op create(pet: Pet): void;\r\n```\n\n### `@put` {#@TypeSpec.Http.put}\n\nSpecify the HTTP verb for the target operation to be `PUT`.\r\n\r\n```typespec\r\n@TypeSpec.Http.put\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@put op set(pet: Pet): void;\r\n```\n\n### `@query` {#@TypeSpec.Http.query}\n\nSpecify this property is to be sent as a query parameter.\r\n\r\n```typespec\r\n@TypeSpec.Http.query(queryNameOrOptions?: valueof string | TypeSpec.Http.QueryOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name               | Type                                           | Description                                                                     |\r\n| ------------------ | ---------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| queryNameOrOptions | `valueof string \\| TypeSpec.Http.QueryOptions` | Optional name of the query when included in the url or query parameter options. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(@query select: string, @query(\"order-by\") orderBy: string): void;\r\nop list(@query(#{ name: \"id\", explode: true }) ids: string[]): void;\r\n```\n\n### `@route` {#@TypeSpec.Http.route}\n\nDefines the relative route URI template for the target operation as defined by [RFC 6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)\r\n\r\n`@route` can only be applied to operations, namespaces, and interfaces.\r\n\r\n```typespec\r\n@TypeSpec.Http.route(path: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n\r\n| Name | Type             | Description |\r\n| ---- | ---------------- | ----------- |\r\n| path | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n##### Simple path parameter\r\n\r\n```typespec\r\n@route(\"/widgets/{id}\") op getWidget(@path id: string): Widget;\r\n```\r\n\r\n##### Reserved characters\r\n\r\n```typespec\r\n@route(\"/files{+path}\") op getFile(@path path: string): bytes;\r\n```\r\n\r\n##### Query parameter\r\n\r\n```typespec\r\n@route(\"/files\") op list(select?: string, filter?: string): Files[];\r\n@route(\"/files{?select,filter}\") op listFullUriTemplate(select?: string, filter?: string): Files[];\r\n```\n\n### `@server` {#@TypeSpec.Http.server}\n\nSpecify an endpoint for this service. Multiple `@server` decorators can be used to specify multiple endpoints.\r\n\r\n```typespec\r\n@TypeSpec.Http.server(url: valueof string, description?: valueof string, parameters?: Record<unknown>)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name        | Type              | Description                                             |\r\n| ----------- | ----------------- | ------------------------------------------------------- |\r\n| url         | `valueof string`  | Server endpoint                                         |\r\n| description | `valueof string`  | Description of the endpoint                             |\r\n| parameters  | `Record<unknown>` | Optional set of parameters used to interpolate the url. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\n@server(\"https://example.com\")\r\nnamespace PetStore;\r\n```\r\n\r\n##### With a description\r\n\r\n```typespec\r\n@service\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n```\r\n\r\n##### Parameterized\r\n\r\n```typespec\r\n@server(\"https://{region}.foo.com\", \"Regional endpoint\", {\r\n  @doc(\"Region name\")\r\n  region?: string = \"westus\",\r\n})\r\n```\r\n\r\n##### Multiple\r\n\r\n```typespec\r\n@service\r\n@server(\"https://example.com\", \"Standard endpoint\")\r\n@server(\r\n  \"https://{project}.private.example.com\",\r\n  \"Private project endpoint\",\r\n  {\r\n    project: string,\r\n  }\r\n)\r\nnamespace PetStore;\r\n```\n\n### `@sharedRoute` {#@TypeSpec.Http.sharedRoute}\n\n`@sharedRoute` marks the operation as sharing a route path with other operations.\r\n\r\nWhen an operation is marked with `@sharedRoute`, it enables other operations to share the same\r\nroute path as long as those operations are also marked with `@sharedRoute`.\r\n\r\n`@sharedRoute` can only be applied directly to operations.\r\n\r\n```typespec\r\n@sharedRoute\r\n@route(\"/widgets\")\r\nop getWidget(@path id: string): Widget;\r\n```\r\n\r\n```typespec\r\n@TypeSpec.Http.sharedRoute\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@statusCode` {#@TypeSpec.Http.statusCode}\n\nSpecify the status code for this response. Property type must be a status code integer or a union of status code integer.\r\n\r\n```typespec\r\n@TypeSpec.Http.statusCode\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(): {\r\n  @statusCode _: 200;\r\n  @body pet: Pet;\r\n};\r\nop create(): {\r\n  @statusCode _: 201 | 202;\r\n};\r\n```\n\n### `@useAuth` {#@TypeSpec.Http.useAuth}\n\nSpecify authentication for a whole service or specific methods. See the [documentation in the Http library](https://typespec.io/docs/libraries/http/authentication) for full details.\r\n\r\n```typespec\r\n@TypeSpec.Http.useAuth(auth: {} | Union | {}[])\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n\r\n| Name | Type                  | Description                                                                                                                                                     |\r\n| ---- | --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| auth | `{} \\| Union \\| {}[]` | Authentication configuration. Can be a single security scheme, a union(either option is valid authentication) or a tuple (must use all authentication together) |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\n@useAuth(BasicAuth)\r\nnamespace PetStore;\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#http#operations.md\n- document_title: Operations\n- document_link: https://typespec.io/docs/libraries/http/operations\n- document_content: # libraries#http#operations.md\n\n# Operations\n\n## Operation verb\n\n**Default behavior:**\r\n\r\n- If `@post` operation has a request body\r\n- `@get` otherwise\r\n\r\n**Configure:**\r\n\r\nYou can use one of the [verb decorators](./reference/decorators.md): `@get`, `@put`, etc.\n\n## Route\n\nAn operation route can be specified using the `@route` decorator.\r\n\r\n```typespec\r\n@route(\"/pets\") op list(): Pet[];\r\n```\r\n\r\nRoute path parameters are declared using `{}`. Providing `@path` on the model property with the matching name is optional.\r\n\r\n```typespec\r\n@route(\"/pets/{petId}\") op get(petId: string): Pet;\r\n// or explicit @path\r\n@route(\"/pets/{petId}\") op get(@path petId: string): Pet;\r\n```\r\n\r\nRoute can be specified on a parent namespace or interface. In that case all the operations, interfaces and namespaces underneath will be prefixed with it.\r\n\r\n```typespec\r\n@route(\"/store\")\r\nnamespace PetStore {\r\n  op hello(): void; // `/store`\r\n  @route(\"ping\") op ping(): void; // `/store/ping`\r\n\r\n  @route(\"/pets\")\r\n  interface Pets {\r\n    list(): Pet[]; // `/store/pets`\r\n    @route(\"{petId}\") read(petId: string): Pet; // `/store/pets/{petId}`\r\n  }\r\n}\r\n```\n\n## Path and query parameters\n\nModel properties and parameters which should be passed as path and query parameters use the `@path` and `@query` parameters respectively. Let's modify our list operation to support pagination, and add a read operation to our Pets resource:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): Pet[];\r\n  op read(@path petId: int32): Pet;\r\n}\r\n```\r\n\r\nPath parameters are appended to the URL unless a substitution with that parameter name exists on the resource path. For example, we might define a sub-resource using the following TypeSpec. Note how the path parameter for our sub-resource's list operation corresponds to the substitution in the URL.\r\n\r\n```typespec\r\n@route(\"/pets/{petId}/toys\")\r\nnamespace PetToys {\r\n  op list(@path petId: int32): Toy[];\r\n}\r\n```\n\n## Request & response bodies\n\nRequest and response bodies can be declared explicitly using the `@body` decorator. Let's add an endpoint to create a pet. Let's also use this decorator for the responses, although this doesn't change anything about the API.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[];\r\n  };\r\n  op read(@path petId: int32): {\r\n    @body pet: Pet;\r\n  };\r\n  @post\r\n  op create(@body pet: Pet): {};\r\n}\r\n```\r\n\r\nNote that in the absence of explicit `@body`:\r\n\r\n1. The set of parameters that are not marked @header, @query, or @path form the request body.\r\n2. The set of properties of the return model that are not marked @header or @statusCode form the response body.\r\n3. If the return type is not a model, then it defines the response body.\r\n\r\nThis is how we were able to return Pet and Pet[] bodies without using @body for list and read. We can actually write\r\ncreate in the same terse style by spreading the Pet object into the parameter list like this:\r\n\r\nSee also [metadata](./operations.md#metadata) for more advanced details.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @post\r\n  op create(...Pet): {};\r\n}\r\n```\n\n## Headers\n\nModel properties and parameters that should be passed in a header use the `@header` decorator. The decorator takes the header name as a parameter. If a header name is not provided, it is inferred from the property or parameter name. Let's add `etag` support to our pet store's read operation.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[];\r\n  };\r\n  op read(@path petId: int32, @header ifMatch?: string): {\r\n    @header eTag: string;\r\n    @body pet: Pet;\r\n  };\r\n  @post\r\n  op create(@body pet: Pet): {};\r\n}\r\n```\n\n## Status codes\n\n**Default behavior:**\r\n\r\n- `4xx,5xx` if response is marked with `@error`\r\n- `200` otherwise\r\n\r\n**Configure:**\r\n\r\nUse the `@statusCode` decorator on a property to declare a status code for a response. Generally, setting this to just `int32` isn't particularly useful. Instead, use number literal types to create a discriminated union of response types. Let's add status codes to our responses, and add a 404 response to our read endpoint.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @error\r\n  model Error {\r\n    code: string;\r\n  }\r\n\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[]; // statusCode: 200 Implicit\r\n  };\r\n  op read(@path petId: int32, @header ifMatch?: string): {\r\n    @statusCode statusCode: 200;\r\n    @header eTag: string;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n  };\r\n  op create(@body pet: Pet): {\r\n    @statusCode statusCode: 204;\r\n  } | Error; //statusCode: 4xx,5xx as Error use `@error` decorator\r\n}\r\n```\n\n## Content type\n\n[See the documentation of Content-Types](./content-types.md).\n\n## Built-in response shapes\n\nSince status codes are so common for REST APIs, TypeSpec comes with some built-in types for common status codes so you don't need to declare status codes so frequently.\r\n\r\nThere is also a `Body<T>` type, which can be used as a shorthand for { @body body: T } when an explicit body is required.\r\n\r\nLets update our sample one last time to use these built-in types:\r\n\r\n```typespec\r\nmodel ETag {\r\n  @header eTag: string;\r\n}\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): OkResponse & Body<Pet[]>;\r\n  op read(@path petId: int32, @header ifMatch?: string): (OkResponse &\r\n    Body<Pet> &\r\n    ETag) | NotFoundResponse;\r\n  @post\r\n  op create(...Pet): NoContentResponse;\r\n}\r\n```\r\n\r\nNote that the default status code is 200 for non-empty bodies and 204 for empty bodies. Similarly, explicit `Body<T>` is not required when T is known to be a model. So the following terser form is equivalent:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): Pet[];\r\n  op read(@path petId: int32, @header ifMatch?: string): (Pet & ETag) | NotFoundResponse;\r\n  @post\r\n  op create(...Pet): {};\r\n}\r\n```\r\n\r\nFinally, another common style is to make helper response types that are\r\nshared across a larger service definition. In this style, you can be\r\nentirely explicit while also keeping operation definitions concise.\r\n\r\nFor example, we could write :\r\n\r\n```typespec\r\nmodel ListResponse<T> {\r\n  ...OkResponse;\r\n  ...Body<T[]>;\r\n}\r\n\r\nmodel ReadSuccessResponse<T> {\r\n  ...OkResponse;\r\n  ...ETag;\r\n  ...Body<T>;\r\n}\r\n\r\nalias ReadResponse<T> = ReadSuccessResponse<T> | NotFoundResponse;\r\n\r\nmodel CreateResponse {\r\n  ...NoContentResponse;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): ListResponse<Pet>;\r\n  op read(@path petId: int32, @header ifMatch?: string): ReadResponse<Pet>;\r\n  @post\r\n  op create(...Pet): CreateResponse;\r\n}\r\n```\n\n## Handling files\n\n`@typespec/http` provides a special model [`TypeSpec.Http.File`](../http/reference/data-types.md#file-typespechttpfile) for handling file uploads and downloads in HTTP operations. When working with files, emitters need to implement special handling due to their binary nature.\r\n\r\nFor more information about HTTP file bodies and how to configure them, see [the documentation on Files][http-files].\r\n\r\n[http-files][./files.md]\n\n### Basic File Handling\n\nWhen the model `Http.File` (or any model that extends `Http.File`) is the _exact_ body of an HTTP request, emitters **must** treat this model with special care:\r\n\r\n- The `contentType` property should be used as the value for the `Content-Type` header in requests and vice-versa for responses.\r\n- The `filename` property should be used in the `Content-Disposition` header in responses and vice-versa for multipart requests (`filename` cannot be sent in a non-multipart HTTP request because `Content-Disposition` is only valid for responses and multipart requests).\r\n- The file content should be treated as the raw body of the request/response without any additional parsing.\r\n\r\nSee [`isHttpFile`](../http/reference/js-api/functions/isHttpFile.md) for a helper that emitters/libraries can use to detect instances of `Http.File`.\n\n### Examples\n\n#### Uploading and downloading files\r\n\r\n```typespec\r\n// Uploading and downloading\r\n@route(\"/files\")\r\ninterface Files {\r\n  @post\r\n  upload(@body file: Http.File): {\r\n    @statusCode statusCode: 201;\r\n  };\r\n\r\n  download(@path fileId: string): Http.File;\r\n}\r\n```\r\n\r\n#### Custom file types\r\n\r\nIf you want to declare specific types of files that are accepted, but still treated as binary files, declare the content types by extending the `Http.File` model and overriding the `contentType` field.\r\n\r\n```typespec\r\n// Custom file type for images\r\nmodel ImageFile extends Http.File {\r\n  contentType: \"image/jpeg\" | \"image/png\" | \"image/gif\";\r\n}\r\n\r\n@route(\"/images\")\r\ninterface Images {\r\n  @post\r\n  upload(@body image: ImageFile): {\r\n    @statusCode statusCode: 201;\r\n  };\r\n\r\n  download(@path imageId: string): ImageFile;\r\n}\r\n```\n\n## Automatic visibility\n\nThe `@typespec/rest` library understands [Lifecycle Visibility](../../language-basics/visibility.md#lifecycle-visibility) and provides functionality for emitters to apply visibility transforms based on whether a model represents a request or response and on HTTP method usage as detailed in the table below.\r\n\r\nSee [handling visibility and metadata](../../extending-typespec/emitter-metadata-handling.md) for details on how to incorporate this information into an emitter implementation.\r\n\r\n| Modifier         | Visible in           |\r\n| ---------------- | -------------------- |\r\n| Lifecycle.Read   | Any response         |\r\n| Lifecycle.Query  | GET or HEAD request  |\r\n| Lifecycle.Create | POST or PUT request  |\r\n| Lifecycle.Update | PATCH or PUT request |\r\n| Lifecycle.Delete | DELETE request       |\r\n\r\nThis allows a single logical TypeSpec model to be used as in the following example:\r\n\r\n```typespec\r\nmodel User {\r\n  name: string;\r\n  @visibility(Lifecycle.Read) id: string;\r\n  @visibility(Lifecycle.Create) password: string;\r\n}\r\n\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(@path id: string, ...User): User;\r\n  @get get(@path id: string): User;\r\n}\r\n```\r\n\r\nThere is a single logical user entity represented by the single TypeSpec type `User`, but the HTTP payload for this entity varies based on context. When returned in a response, the `id` property is included, but when sent in a request, it is not. Similarly, the `password` property is only included in create requests, but not present in responses.\r\n\r\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(Lifecycle.Read)` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas.\n\nincluded in create requests, but not present in responses.\r\n\r\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(Lifecycle.Read)` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas. For example, `@visibility(Lifecycle.Create)` applied to a model property of a type named Widget will generate a `WidgetCreate` schema.\r\n\r\nAnother emitter such as one generating client code can see and preserve a single logical type and deal with these HTTP payload differences by means other than type proliferation.\r\n\r\nModeling with logical entities rather than HTTP-specific shapes also keeps the TypeSpec spec decoupled from HTTP and REST and can allow the same spec to be used with multiple protocols.\n\n## Metadata\n\nin terms of the logical entity:\r\n\r\n```typespec\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(...User): User;\r\n}\r\n```\r\n\r\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\r\n\r\n```\r\nPOST /Users/TypeSpecFan42 HTTP/1.1\r\nContent-Type: application/json\r\n{\r\n  \"name\": \"TypeSpec Fan\",\r\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\r\n}\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\n{\r\n  name: \"TypeSpec Fan\",\r\n  id: \"TypeSpecFan42\r\n}\r\n```\n\nThe properties that designate content for the HTTP envelope (`@header`, `@path`, `@query`, `@statusCode`) rather than the content in an HTTP payload are often called \"metadata\".\r\n\r\nMetadata is determined to be applicable or inapplicable based on the context that it is used:\r\n\r\n| Context       | Applicability       |\r\n| ------------- | ------------------- |\r\n| `@query`      | request only        |\r\n| `@path`       | request only        |\r\n| `@statusCode` | response only       |\r\n| `@header`     | request or response |\r\n\r\nAdditionally metadata that appears in an array element type always inapplicable.\r\n\r\nWhen metadata is deemed \"inapplicable\", for example, if a `@path` property is seen in a response, it becomes part of the payload instead unless the [@includeInapplicableMetadataInPayload](./reference/decorators.md#@TypeSpec.Http.includeInapplicableMetadataInPayload) decorator is used and given a value of `false`.\r\n\r\nThe handling of metadata applicability furthers the goal of keeping a single logical model in TypeSpec. For example, this defines a logical `User` entity that has a name, ID and password, but further annotates that the ID is sent in the HTTP path and the HTTP body in responses. Also, using automatic visibility as before, we further indicate that the password is only present in create requests.\r\n\r\n```typespec\r\nmodel User {\r\n  name: string;\r\n  @path id: string;\r\n  @visibility(Lifecycle.Create) password: string;\r\n}\r\n```\r\n\r\nThen, we can write operations in terms of the logical entity:\r\n\r\n```typespec\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(...User): User;\r\n}\r\n```\r\n\r\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\r\n\r\n```\r\nPOST /Users/TypeSpecFan42 HTTP/1.1\r\nContent-Type: application/json\r\n{\r\n  \"name\": \"TypeSpec Fan\",\r\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\r\n}\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\n{\n\n### Visibility vs. Metadata applicability\n\nMetadata properties are filtered based on visibility as [described above](#automatic-visibility). This is done independently before applicability is considered. If a a metadata property is not visible then it is neither part of the envelope nor the HTTP payload, irrespective of its applicability.\n\n### Nested metadata\n\nMetadata properties are not required to be top-level. They can also be nested deeper in a parameter or response model type. For example:\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: {\r\n    @header example: string;\r\n  };\r\n  name: string;\r\n}\r\n```\r\n\r\nNote that nesting in this sense does not require the use of anonymous models. This is equivalent:\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: Headers;\r\n  name: string;\r\n}\r\nmodel Headers {\r\n  @header example: string;\r\n}\r\n```\r\n\r\nIn the event that this nesting introduces duplication, then the least nested property with a given name is preferred and the duplicate metadata properties are ignored.\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: {\r\n    @header example: string; // preferred\r\n    more: {\r\n      @header example: string; // ignored\r\n    };\r\n  };\r\n}\r\n```\n\n## Emitter resources\n\nSee [Handling metadata and visibility in emitters for REST API](../../extending-typespec/emitter-metadata-handling.md) for information on how to handle metadata applicability and automatic visibility in a custom emitter.\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#arm#resource-type.md\n- document_title: ARM Resource Types\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type\n- document_content: # howtos#arm#resource-type.md\n\n# ARM Resource Types\n\n## Introductions\n\nIntroduction\r\nResources are the basic building blocks of Azure. When a customer interacts with Azure through the Control Plane (ARM), they generally will be reading (GET), writing (PUT/PATCH), deleting (DELETE) or performing actions upon (POST) one or more resources. Each resource is managed by a particular Resource Provider, so we uniquely identify a resource by its 'fully-qualified type'. Some well-known examples of types are Microsoft.Compute/virtualMachines, or Microsoft.Network/networkSecurityGroups/securityRules. See Resource Ids for a more in-depth breakdown of the id and associated fields.\r\n\r\nIn order to give customers a consistent API when working with many different Resource Providers, and to allow ARM to understand and manage resources programmatically, ARM requires each RP to follow a set of contracts for resource management, defined in the ARM RPC.\n\n## ARM Resource Terminology\n\nThe most important distinction between resources is between _Tracked_ and _Proxy_ resources. Tracked resources are resources in which all of the metadata is maintained in Azure Resource Manager. Tracked Resources can be targeted to specific regions, and are generally the best choice for most top-level resources. Azure Resource Manager maintains data about Tracked Resources, and generally will handle many implementation details or operations on the resource. See [RPC: Resource API Reference](https://github.com/Azure/azure-resource-manager-rpc/blob/master/v1.0/resource-api-reference.md) for further information on the contract for Tracked Resources.\r\n\r\nProxy resources are resources in which only a portion of resource metadata is tracked in ARM. Generally, these model resources maintained on other systems, or that resource-providers want to track themselves. Generally, resource providers must implement most of the operations for Proxy resources. Tenant, Extension, and child resources are usually modeled as Proxy resources.\r\n\r\nThere is a good discussion on making the choice between Tracked and Proxy Resources in the armwiki discussion [Tracked vs Proxy Resources](https://armwiki.azurewebsites.net/rp_onboarding/tracked_vs_proxy_resources.html)\n\n## Choosing a Resource Type\n\n- The large majority of resources have their metadata tracked by ARM, can be assigned to regions, and are contained inside a resource group in a subscription, for ease of management and billing. These are called [Tracked Resources](#tracked-resources).\r\n- Some resources may need to have scope across an entire customer tenant, or may need to have a single instance across all customer subscriptions. These are called [tenant resources](#tenant-resources).\r\n- Some kinds of resources may augment or alter the functionality of resources or resource containers provided by other resource-providers. For example, policy or RBAC rules may be applied to any resource or resource container. These resources are called [extension resources](#extension-resource).\r\n- Some resources are complex and naturally break down into one or more components that are separately configurable, but an integral part of the larger resource (for example, a virtual network resource may contain many separately configurable subnets). These component resources are called [child resources](#child-resource).\r\n- Rarely, some resources may need to apply across a subscription, or have a single instance in a customer subscription, these are called [subscription-based resources](#subscription-based-resource).\r\n- Rarer still, some resources may need to apply across a specific region, or have a single instance in a region, these are called [location-based resources](#location-based-resource).\r\n- In some cases, there can only be one instance of a resource at a specific scope - this is rare, but happens most frequently in tenant, child, and location resources. In typespec, you will need to specify that the resource is a singleton, and the resource manager tools will automatically apply the correct pattern for singleton resources (using the recommended resource name 'default')\n\n## Modeling Resources in TypeSpec\n\nResources are modeled in TypeSpec by choosing a _base resource type_, defining _rp-specific properties_, and optionally mixing in _standard envelope properties_. Later sections document [how to model resource operations](./resource-operations.md). The following sections discuss usage of each of the base resource types. Later sections discuss [designing rp-specific properties](#designing-resource-specific-properties) and [adding standard ARM envelope properties](#adding-optional-standard-envelope-properties).\n\n### Tracked Resources\n\nTracked resources use the `TrackedResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tracked Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Tenant Resources\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@tenantResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Tenant Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Extension Resource\n\nExtension resources use the `ExtensionResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\nmodel EmployeeResource is ExtensionResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Extension Resources [in the TenantResource sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/tenantResource/main.tsp).\n\n### Child Resource\n\nChild resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@parentResource(EmployeeResource)\r\nmodel JobResource is ProxyResource<JobProperties> {\r\n  /** The job name */\r\n  @segment(\"jobs\")\r\n  @key(\"jobName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@parentResource`: designates the model type for the parent of this child resource. The resource identifier for this resource will be prepended with the resource identity of the parent.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Child Resources [in the DynaTrace sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/dynatrace/main.tsp).\n\n### Subscription-based Resource\n\nTenant resources use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@subscriptionResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@subscriptionResource`: designates this resource as being a cross-subscription resource, with scope across all resource groups in the subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Subscription Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Location-based Resource\n\nLocation-based resources usually use the `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@locationResource\r\nmodel EmployeeResource is ProxyResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@locationResource`: designates this resource as being a cross-location resource, with scope across a location within a subscription.\r\n`@doc`: provides documentation for the 'name' property of the resource.\r\n`@segment(employees)`: provides the resource type name for this resource.\r\n`@key(employeeName)`: provides the parameter name for the name of the resource in operations that use this resource.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Location Resources [in the OperationTemplates sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/operationsTest/opTemplates.tsp).\n\n### Singleton Resource\n\nSingleton resources can use any resource base type, but most often use `ProxyResource<TProperties/>` as their base resource type, where `TProperties` is the properties model for the rp-specific properties of the resource. Here is an example:\r\n\r\n```typespec\r\n@singleton\r\n@tenantResource\r\nmodel EmployeeAgreementResource is ProxyResource<EmployeeAgreementProperties> {\r\n  /** The default employee agreement, applying to all employees. */\r\n  @segment(\"employeeAgreements\")\r\n  @key\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n```\r\n\r\n`@singleton`: indicates that there can only be one of the resources in the resource container (in this case, only one instance in the customer tenant).\r\n`@tenantResource`: designates this resource as being a cross-tenant resource, with scope across all customer subscriptions in the tenant.\r\n`@doc`: provides documentation for the 'name' property of the resource. For a singleton, the name value will always be the same.\r\n`@segment(employeeAGreements)`: provides the resource type name for this resource.\r\n`@key`: provides the parameter name for the name of the resource in operations that use this resource - this will not be a settable value for singleton resources.\r\n`@visibility(read)`: indicates that this property is returned in the body of responses to operations over this resource, but does not appear in the body of requests. Later sections describe the [usage of property visibility](#property-visibility-and-other-constraints).\r\n`@path`: indicates that this property corresponds to the last segment of the url path to the resource (otherwise known as the resource identity).\r\n\r\nYou can find samples of Singleton Resources [in the Singleton sample](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/arm-scenarios/singleton/main.tsp#L29).\n\n## Designing Resource-specific Properties\n\nEach resource model consists of two distinct parts\r\n\r\n- An outer _envelope_ of information that provides metadata for optional standardized ARM functionality, like entity-tags and managed identities, and is processed by Azure Resource Manager.\r\n- An inner set of properties that are specific to the resource and are defined by the resource provider.\r\n\r\nModifying the ARM envelope is discussed in later sections on [mixing in standard ARM envelope add-ons](#adding-optional-standard-envelope-properties).\r\n\r\nThe inner _rp-specific property bag_ consists of all of the properties that the RP needs to manage about the resource. Properties should be completely specified, should not duplicate properties from the _ARM envelope_, and may consist of simple types, arrays, or other complex properties.\r\n\r\nHere is an example of a property bag for the `EmployeeResource` resource.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n}\r\n\r\nunion EmployeeProvisioningState {\r\n  string,\r\n\r\n  /** The resource create request has been accepted */\r\n  Accepted: \"Accepted\",\r\n\r\n  /** The resource is being provisioned */\r\n  Provisioning: \"Provisioning\",\r\n\r\n  /** The resource is updating */\r\n  Updating: \"Updating\",\r\n\r\n  /** Resource has been created. */\r\n  Succeeded: \"Succeeded\",\r\n\r\n  /** Resource creation failed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\n\nfailed. */\r\n  Failed: \"Failed\",\r\n\r\n  /** Resource creation was canceled. */\r\n  Canceled: \"Canceled\",\r\n\r\n  /** The resource is being deleted */\r\n  Deleting: \"Deleting\",\r\n}\r\n\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\n@secret\r\nscalar Password extends string;\r\n\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n\r\nmodel EmployeeProperties {\r\n  /** The current title of the employee */\r\n  title: string;\r\n\r\n  @visibility(Lifecycle.Read, Lifecycle.Create)\r\n  level: EmployeeLevel;\r\n\r\n  @visibility(Lifecycle.Read)\r\n  employeeId: int32;\r\n\r\n  biography?: string = \"No biography provided\";\r\n  colleagues: EmployeeResourceId[];\r\n  employmentHistory: Job[];\r\n\r\n  @visibility(Lifecycle.Create)\r\n  password: Password;\r\n\r\n  provisioningState?: EmployeeProvisioningState;\r\n}\r\n```\r\n\r\n`EmployeeProperties` specifies the employee metadata that the RP needs to track and manage. Notice that the model uses built-in scalar types like `string` and `int32`, new types built from scalar types with added constraints, like `Password` and `EmployeeLevel`, enumerations of values, like `EmployeeProvisioningState`, and complex types. The individual components of this model are described below.\r\n\r\nNote that _documentation comments on all models and model properties are required when specs are checked in_. Here they are omitted for clarity. The TypeSpec compiler and TypeSpec IDE tooling will emit warning diagnostics if you emit required documentation, and about most of the ARM rules described in this document.\n\n### The `provisioningState` Property for Tracked Resources\n\nAll Tracked Resources are required to implement a 'provisioningState' property in their rp-specific property bag. This is used by ARM and some ARM clients to track the provisioning state of a resource as it is created and deleted. At minimum, the provisioning state must contain the standard terminal values that ARM is looking for. There are contained in the `ResourceProvisioningState` enumeration in the Azure.ResourceManager library. If RPs have other provisioning states they would like to track, they can define their own provisioning state enum, and mix in the value, as shown in the sample above, or they may simply use the standard provisioning state as shown in the sample below:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  ...ResourceProvisioningState;\r\n}\r\n```\r\n\r\nNote that this example uses the spread operator `...`, which allows you to simply include the properties from a source model in the target model you are constructing. This has the effect of copying the properties of the source model and their decorations into the target model, without creating any nominal inheritance relationship.\r\n\r\nAlternately, this is also equivalent:\r\n\r\n```typespec\r\nmodel ResourceProperties {\r\n  /** The status of the last provisioning operation performed on the resource. */\r\n  @visibility(Lifecycle.Read)\r\n  provisioningState?: ResourceProvisioningState;\r\n}\r\n```\n\n### Required and Optional properties and Property Defaults\n\nIn the examples, note that some model properties use the optional operator `?` after the property name, like `biography?` and some do not, like `title`. Property names using the `?` are optional properties, which may or may not be provided in the request body for CreateOrUpdate (PUT) requests. Property names without the `?` are required properties, which must be provided in PUT requests. The exception is that properties that have 'readOnly' visibility do not appear in requests, but may be required or optional in responses.\r\n\r\nAlso note that optional properties may specify defaults, as with `biography?: string = \"No biography provided\"`. The default indicates the value that will be recorded on the server if no value is sent by the client.\n\n### Defining Custom Types\n\nIn the sample, new constrained scalar types and new complex model types are defined and used inside the _rp-specific property bag_. TypeSpec allows you to define custom types for use in your specification.\r\n\r\nYou will often want to define scalar types or properties that have constraints. For example, numeric values may be constrained to have a certain minimum or maximum, strign values may be constrained to follow a particular regex pattern, and so on. Whenever these constrained types are used in your spec, the constraints will be transmitted to the usage.\r\n\r\nThe example creates a numeric type with minimum and maximum constraints:\r\n\r\n```typespec\r\n@minValue(50)\r\n@maxValue(70)\r\nscalar EmployeeLevel extends int32;\r\n```\r\n\r\nThis defines 'EmployeeLevel' as an integer value between 50 and 70. The example also defines a complex type used in an array:\r\n\r\n```typespec\r\nmodel Job {\r\n  name: string;\r\n  companyName: string;\r\n  start: plainDate;\r\n  end: plainDate;\r\n  role: string;\r\n  notes?: string;\r\n}\r\n```\r\n\r\nMode details on what to consider when using complex types in an array are discussed in the section on [modeling arrays of complex types](#modeling-arrays-of-complex-types).\n\n### Using Resource identifiers\n\nIt is often the case that resources need to reference other resources to provide specific pieces of functionality. For example, resources may need to reference a storage account to use for storing user data, or a NIC to attach to a Network. The `Azure.ResourceManager` library defines a `ResourceIdentifier` template that allows you to easily represent references to resources in your API. The template allows you to specify one or more acceptable resource types, automatically designating the value as a resource reference, and providing the appropriate pattern validation - which helps in generating better code, better ARM templates, and better documentation for your API.\r\n\r\n```typespec\r\nscalar EmployeeResourceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.HR/employees\",\r\n    }\r\n  ]>;\r\n\r\nscalar NetworkInterfaceId\r\n  extends Azure.Core.armResourceIdentifier<[\r\n    {\r\n      type: \"Microsoft.Network/networkInterfaces\",\r\n    },\r\n    {\r\n      type: \"Microsoft.ClassicNetwork/networkInterfaces\",\r\n    }\r\n  ]>;\r\n```\r\n\r\nThe `NetworkInterfaceId example shows how to allow multiple resource types in a reference.\n\n### Property Visibility and Other Constraints\n\nThe sample uses the `@visibility` decorator to indicate how the resource definition is used in requests to PUT and PATCH operations, and in responses to PUT, PATCH, GET, and LIST operations.\r\n\r\nThis table shows how visibility is used to determine whether a property is used in requests and responses:\r\n\r\n| Visibility           | In Create Request? | In Patch Request/ Updateable in PUT | In Responses | Sample                                         |\r\n| -------------------- | ------------------ | ----------------------------------- | ------------ | ---------------------------------------------- |\r\n| None                 | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create, update | Yes                | Yes                                 | Yes          | Most properties                                |\r\n| read, create         | Yes                | No                                  | Yes          | resource location                              |\r\n| read, update         | No                 | Yes                                 | Yes          | Properties only settable after creation (keys) |\r\n| create, update       | Yes                | Yes                                 | No           | Secrets (e.g. password)                        |\r\n| read                 | No                 | No                                  | Yes          | Calculated properties, e.g. provisioningState  |\r\n| update               | No                 | Yes                                 | No           | Secrets (e.g. keys)                            |\r\n| create               | Yes                | No                                  | No           | Secrets (e.g. user-defined password)           |\n\n### Modeling Arrays of Complex Types\n\nFinally, when your _rp-specific property bag_ contains an array of complex properties, there are a few important considerations:\r\n\r\n- The complex properties in an array must have a key property - this means a property named 'name' or 'id' that uniquely identifies the property in the array. The TypeSpec tools will emit a diagnostic if you omit this.\r\n- ARM resources must be fully loaded in memory, so there are limits to the size of arrays in the properties of a resource. If your array is not strictly bounded, you should consider modeling the array property as a [child resource](#child-resource)\r\n- Updating the contents of arrays can be difficult, and result in data loss under simultaneous updates, especially as Json-Merge-Patch is not widely supported in ARM update operations. If users will frequently need to update the contents of arrays, you should consider modeling as a [child resource](#child-resource).\n\n## Adding Optional Standard Envelope Properties\n\nIn addition to the resource-specific property bag, a resource may configure on or more standard ARM features through the use of standard properties in the _ARM Envelope_. Standard features configured in the envelope include:\r\n\r\n- **Managed Identity**: Associating a managed identity with the resource to authorize actions taken by this resource on other resources.\r\n- **SKU**: A standard mechanism for configuring levels of service for a resource.\r\n- **Plan**: A standard mechanism for configuring MarketPlace billing plans for a resource.\r\n- **ETags**: A standard mechanism for managing concurrent operations over the resource.\r\n- **ResourceKind**: A standard mechanism for specifying a type of user experience in the portal.\n\n### Managed Identity\n\nStandard configuration for ARM support of both SystemAssigned and UserAssigned Managed Service Identity (MSI)\r\n\r\n- If a resource allows both generated (SystemAssigned) and user-assigned (UserAssigned) Managed Identity, use the spread (...) operator to include the standard ManagedServiceIdentity envelope property. This will allow users to manage any ManagedServiceIdentity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedServiceIdentity;\r\n  }\r\n  ```\r\n\r\n- If a resource allows only generated (SystemAssigned) Managed Identity, use the spread operator (...) to include the `ManagedSystemAssignedIdentity` standard envelope property in the resource definition. This will allow users to manage the SystemAssigned identity associated with this resource.\r\n\r\n  ```typespec\r\n  model EmployeeResource is TrackedResource<EmployeeProperties> {\r\n    /** The employee name, using 'Firstname Lastname' notation */\r\n    @segment(\"employees\")\r\n    @key(\"employeeName\")\r\n    @visibility(Lifecycle.Read)\r\n    @path\r\n    name: string;\r\n\r\n    ...ManagedSystemAssignedIdentity;\r\n  }\r\n  ```\r\n\r\nFor more information, see [Managed Service Identity Support](https://eng.ms/docs/products/arm/rpaas/msisupport)\n\n### SKU\n\nStandard support for setting a SKU-based service level for a resource. To enable SKU support, add the `ResourceSku` enevelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceSku;\r\n}\r\n```\r\n\r\nFor more information, see [SKU Support](https://eng.ms/docs/products/arm/rpaas/skusupport)\n\n### ETags\n\nIndicator that entity-tag operation concurrency support is enabled for this resource. To enable ETags, add the `EntityTag` envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...EntityTag;\r\n}\r\n```\r\n\r\nFor more information, and limitations on RPaaS concurrency support, see [RPaaS ETag Support](https://eng.ms/docs/products/arm/rpaas/etags)\n\n### Plan\n\nSupport for marketplace billing configuration for the resource. To enable `Plan` support, add the `ResourcePlan` standard envelope property to the resource definition.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourcePlan;\r\n}\r\n```\r\n\r\nSee [MarketPlace Third Party Billing SUpport](https://eng.ms/docs/products/arm/rpaas/custom_billing)\n\n### ResourceKind\n\nSupport for certain kinds of portal user experiences based on the kind of resource. To include 'Kind' in the resource defintion, add the `ResourceKind` standard envelope property.\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ResourceKind;\r\n}\r\n```\r\n\r\nFor more information on user experiences in the Azure Portal, see [Portal Support](https://eng.ms/docs/products/arm/rpaas/portal/gettingstarted)\n\n### ManagedBy\n\nSupport for management of this resource by other resources. To add 'ManagedBy' support to the resource, add the `ManagedBy` envelope property to the resource definition:\r\n\r\n```typespec\r\nmodel EmployeeResource is TrackedResource<EmployeeProperties> {\r\n  /** The employee name, using 'Firstname Lastname' notation */\r\n  @segment(\"employees\")\r\n  @key(\"employeeName\")\r\n  @visibility(Lifecycle.Read)\r\n  @path\r\n  name: string;\r\n\r\n  ...ManagedBy;\r\n}\r\n```\r\n\r\nFor more information on supporting 'ManagedBy', see [ManagedBy API Contract](https://eng.ms/docs/products/arm/api_contracts/managedby)\n\n## Reference\n\n[Fundamentals - ARM Wiki](https://armwiki.azurewebsites.net/fundamentals/overview.html)\n", "latency": 12.169511795043945, "response_length": 1217}
{"query": "title: How can I generate openapi json schema from typespec schema?\n\nquestion: I'm asking because the emit options does not seem to work for me. I'm trying:\n```\nnpx tsp compile docs/main.tsp --emit=\"@typespec/json-schema\"\n```\nand for example my main.tsp looks like:\n```\nimport \"@typespec/http\";\nimport \"@typespec/rest\";\nimport \"@typespec/openapi3\";\nimport \"@typespec/json-schema\";\nimport \"./Routes/auth.tsp\";\nusing TypeSpec.Http;\nusing TypeSpec.Rest;\nusing TypeSpec.JsonSchema;\n@service({\ntitle: \"FCH API\",\n})\n@server(\n\"https://{url}/api/{apiVersion}\",\n\"Single server endpoint\",\n{\nurl: string = \"127.0.0.1:8085\",\napiVersion: string = \"v1\",\n}\n)\nnamespace FCH;\n```", "ground_truth": "Do you want to emit openapi3 or json schema? those are 2 different document(s) and emitters in TypeSpec\nFor openapi3 you should use the `@typespec/openapi3` emitter https://typespec.io/docs/libraries/openapi3/reference/emitter", "response": "To generate JSON Schema from your TypeSpec schema using the `@typespec/json-schema` emitter, you need to ensure that the emitter is properly configured. Based on your example, you can use the following steps:\n\n1. **Install the JSON Schema emitter**:\n   Ensure you have installed the `@typespec/json-schema` package:\n   ```bash\n   npm install @typespec/json-schema\n   ```\n\n2. **Command-line usage**:\n   Use the following command to compile your TypeSpec file and emit JSON Schema:\n   ```bash\n   npx tsp compile docs/main.tsp --emit=@typespec/json-schema\n   ```\n\n3. **Configuration options**:\n   If you want to customize the behavior of the emitter (e.g., emit all models or bundle schemas into a single file), you can use a configuration file (`tspconfig.yaml`) with the following structure:\n   ```yaml\n   emit:\n     - \"@typespec/json-schema\"\n   options:\n     \"@typespec/json-schema\":\n       emitAllModels: true\n       file-type: \"json\"  # Optional: Choose between \"json\" or \"yaml\"\n   ```\n   Then, run the command:\n   ```bash\n   npx tsp compile docs/main.tsp\n   ```\n\n4. **Decorators**:\n   Ensure that your TypeSpec schema uses the `@jsonSchema` decorator or is within a namespace with the `@jsonSchema` decorator. Alternatively, you can use the `emitAllModels` option to emit all models without requiring the decorator.\n\nIf the emitter still does not work as expected, verify that the `@typespec/json-schema` package is installed and check for any errors in your TypeSpec schema or configuration.", "context": "- document_dir: typespec_docs\n- document_filename: emitters#json-schema#guide.md\n- document_title: Guide\n- document_link: https://typespec.io/docs/emitters/json-schema/guide\n- document_content: # emitters#json-schema#guide.md\n\n# Guide\n\ncontrolled using the `emitAllModels` and `emitAllRefs` options.\r\n\r\nBy default, this emitter does not define schemas for such data types. Instead, the schemas for them are placed in the `$defs` of any JSON Schema types that reference them. The schemas do not define either `$id` or `$schema` metadata keywords. The `$defs` are referenced using a `$ref` with URI fragment containing a JSON Pointer, which uses the syntax of the following form:\r\n\r\n```json\r\n{ \"$ref\": \"#/$defs/{TypeNameHere}\" }\r\n```\r\n\r\nIf you want to treat all TypeSpec types as JSON Schema types (even if they don't have the `@jsonSchema` decorator), you can set the `emitAllModels` option to true. With this set, every data type in your TypeSpec program will get its own schema file, and all references will be relative URIs.\r\n\r\nIf you want to treat all TypeSpec types referenced from JSON Schema types as JSON Schema types (even if they don't have the `@jsonSchema` decorator), you can set the `emitAllRefs` option to true. With this set, data types which are referenced from JSON Schema types will get their own schema file, and all references to them will be relative URIs.\n\nWhen a TypeSpec data type has the `@jsonSchema` decorator or is declared inside a namespace with that decorator, it is considered a _JSON Schema type_.\r\n\r\nBy default, this emitter will produce one JSON Schema file per JSON Schema type. The file defines an `$id` metadata keyword based on the TypeSpec type name and the file format of the schema (for example, `Widget.yaml`). The `$id` can be overridden by using the `@id` decorator.\r\n\r\n:::note\r\nThe base URI of a schema is the reference point for resolving relative URIs within the schema, such as those inside `$ref`s. When the `$id` metadata keyword of a schema is an absolute URI, the `$id` is the base URI. When the `$id` is a relative reference, then the base URI is determined by resolving the relative reference against the URI used to retrieve the schema.\r\n\r\nThe default behavior of this emitter for a model named `Widget` is to produce a schema with a `$id` of `Widget.yaml`, which allows the actual base URI of the document to differ depending on where it is retrieved from, and therefore should allow resolving relative references to other schemas whether loaded from disk or retrieved over HTTP.\r\n:::\r\n\r\nWhen JSON Schema types reference other JSON Schema types, those references are created using a `$ref` with a relative reference (see the note above for how this works in JSON Schema).\r\n\r\nHow this emitter handles data types which aren't JSON Schema types can be controlled using the `emitAllModels` and `emitAllRefs` options.\r\n\r\nBy default, this emitter does not define schemas for such data types. Instead, the schemas for them are placed in the `$defs` of any JSON Schema types that reference them. The schemas do not define either `$id` or `$schema` metadata keywords. The `$defs` are referenced using a `$ref` with URI fragment containing a JSON Pointer, which uses the syntax of the following form:\r\n\r\n```json\r\n{ \"$ref\": \"#/$defs/{TypeNameHere}\" }\r\n```\n\n## Bundling behavior\n\nBy default, this emitter will produce separate schema files for each JSON Schema type in your program. However, if you prefer to bundle all of your schemas into a single file, you can set the `bundleId` option to the id you want to use for your bundle. You will now get a single file containing all of your schemas.\r\n\r\nNote that bundling does not affect any references within the bundled schemas. In particular, references between JSON Schema types still use relative URIs. As such, correctly resolving these references to the local file requires JSON Schema implementations to support bundling as defined in the JSON Schema 2020-12 specification.\r\n\r\nNote also that this does not affect the behavior of non-JSON Schema data types. In particular, by default, non-JSON Schema data types are inlined into each referencing schema's `$defs` object. The `emitAllModels` and `emitAllRefs` options can be used to turn these inlined `$defs` into `$defs` in the bundle.\n\n## Example Configuration for `emitAllModels`\n\nTo treat all TypeSpec types as JSON Schema types, set the `emitAllModels` option to true. This will generate a schema file for every data type in your TypeSpec program.\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/json-schema\"\r\noptions:\r\n  \"@typespec/json-schema\":\r\n    emitAllModels: true\r\n```\n\n## Example Configuration for `emitAllRefs`\n\nTo treat all TypeSpec types referenced from JSON Schema types as JSON Schema types, set the `emitAllRefs` option to true. This will generate a schema file for every referenced data type.\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/json-schema\"\r\noptions:\r\n  \"@typespec/json-schema\":\r\n    emitAllRefs: true\r\n```\n\n## Example Configuration for `bundleId`\n\nTo bundle all schemas into a single file, set the `bundleId` option to the desired id. This will generate a single file containing all schemas.\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/json-schema\"\r\noptions:\r\n  \"@typespec/json-schema\":\r\n    bundleId: \"my-bundle\"\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#json-schema#reference#emitter.md\n- document_title: Emitter usage\n- document_link: https://typespec.io/docs/emitters/json-schema/reference/emitter\n- document_content: # emitters#json-schema#reference#emitter.md\n\n# Emitter usage\n\n## Usage\n\n1. Via the command line\r\n\r\n```bash\r\ntsp compile . --emit=@typespec/json-schema\r\n```\r\n\r\n2. Via the config\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/json-schema\"\r\n```\r\n\r\nThe config can be extended with options as follows:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/json-schema\"\r\noptions:\r\n  \"@typespec/json-schema\":\r\n    option: value\r\n```\n\n## Emitter options\n\n### `emitter-output-dir`\n\n**Type:** `absolutePath`\r\n\r\nDefines the emitter output directory. Defaults to `{output-dir}/@typespec/json-schema`\r\nSee [Configuring output directory for more info](https://typespec.io/docs/handbook/configuration/configuration/#configuring-output-directory)\n\n### `file-type`\n\n**Type:** `\"yaml\" | \"json\"`\r\n\r\nSerialize the schema as either yaml or json.\n\n### `int64-strategy`\n\n**Type:** `\"string\" | \"number\"`\r\n\r\nHow to handle 64 bit integers on the wire. Options are:\r\n\r\n- string: serialize as a string (widely interoperable)\r\n- number: serialize as a number (not widely interoperable)\n\n### `bundleId`\n\n**Type:** `string`\r\n\r\nWhen provided, bundle all the schemas into a single json schema document with schemas under $defs. The provided id is the id of the root document and is also used for the file name.\n\n### `emitAllModels`\n\n**Type:** `boolean`\r\n\r\nWhen true, emit all model declarations to JSON Schema without requiring the @jsonSchema decorator.\n\n### `emitAllRefs`\n\n**Type:** `boolean`\r\n\r\nWhen true, emit all references as json schema files, even if the referenced type does not have the `@jsonSchema` decorator or is not within a namespace with the `@jsonSchema` decorator.\n\n### `seal-object-schemas`\n\n**Type:** `boolean`\r\n\r\nIf true, then for models emitted as object schemas we default `unevaluatedProperties` to `{ not: {} }`,\r\nif not explicitly specified elsewhere.\r\nDefault: `false`\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#json-schema#reference#index.mdx\n- document_title: Overview\n- document_link: https://typespec.io/docs/emitters/json-schema/reference/index\n- document_content: # emitters#json-schema#reference#index.mdx\n\n# Overview\n\nimport { Tabs, TabItem } from '@astrojs/starlight/components';\r\n\r\nTypeSpec library for emitting TypeSpec to JSON Schema and converting JSON Schema to TypeSpec\n\n## Install\n\n<Tabs>\r\n<TabItem  label=\"In a spec\" default>\r\n\r\n```bash\r\nnpm install @typespec/json-schema\r\n```\r\n\r\n</TabItem>\r\n<TabItem  label=\"In a library\" default>\r\n\r\n```bash\r\nnpm install --save-peer @typespec/json-schema\r\n```\r\n\r\n</TabItem>\r\n</Tabs>\n\n## Emitter usage\n\n[See documentation](./emitter.md)\n\n## TypeSpec.JsonSchema\n\n### Decorators\n\n- [`@baseUri`](./decorators.md#@TypeSpec.JsonSchema.baseUri)\r\n- [`@contains`](./decorators.md#@TypeSpec.JsonSchema.contains)\r\n- [`@contentEncoding`](./decorators.md#@TypeSpec.JsonSchema.contentEncoding)\r\n- [`@contentMediaType`](./decorators.md#@TypeSpec.JsonSchema.contentMediaType)\r\n- [`@contentSchema`](./decorators.md#@TypeSpec.JsonSchema.contentSchema)\r\n- [`@extension`](./decorators.md#@TypeSpec.JsonSchema.extension)\r\n- [`@id`](./decorators.md#@TypeSpec.JsonSchema.id)\r\n- [`@jsonSchema`](./decorators.md#@TypeSpec.JsonSchema.jsonSchema)\r\n- [`@maxContains`](./decorators.md#@TypeSpec.JsonSchema.maxContains)\r\n- [`@maxProperties`](./decorators.md#@TypeSpec.JsonSchema.maxProperties)\r\n- [`@minContains`](./decorators.md#@TypeSpec.JsonSchema.minContains)\r\n- [`@minProperties`](./decorators.md#@TypeSpec.JsonSchema.minProperties)\r\n- [`@multipleOf`](./decorators.md#@TypeSpec.JsonSchema.multipleOf)\r\n- [`@oneOf`](./decorators.md#@TypeSpec.JsonSchema.oneOf)\r\n- [`@prefixItems`](./decorators.md#@TypeSpec.JsonSchema.prefixItems)\r\n- [`@uniqueItems`](./decorators.md#@TypeSpec.JsonSchema.uniqueItems)\n\n### Models\n\n- [`Json`](./data-types.md#TypeSpec.JsonSchema.Json)\n", "latency": 15.875491857528687, "response_length": 1495}
{"query": "title: Introduce ::name meta property\n\nquestion: Given the following models:\n```\n@discriminator(\"_type\")\nmodel Piece<T extends {}> {\n@key\nid: ID<T>; // custom scalar to denote an ID for a given model\nname: string;\ndescription: string;\n}\nmodel Course extends Piece<Course> {\n_type: \"Course\";\n}\nmodel Single extends Piece<Single> {\n_type: \"Single\";\n}\n```\nAnd a newly introduced `::name` meta property, we could simplify it to:\n```\n@discriminator(\"_type\")\nmodel Piece<T extends {}> {\n_type: T::name;\n@key\nid: string;\nname: string;\ndescription: string;\n}\nmodel Course extends Piece<Course> {}\nmodel Single extends Piece<Single> {}\n```", "ground_truth": "I did file an issue for this recently, however there the goal i had was more to use in string interpolation. so would be good add your use case there to be sure it is considered in the design [#2964](https://github.com/microsoft/typespec/issues/2964)", "response": "The newly introduced `::name` meta property simplifies the definition of the `_type` discriminator in the `Piece` model. By using `T::name`, the `_type` property automatically derives its value from the name of the extending model (`Course` or `Single`). This eliminates the need to manually specify the `_type` value in each extending model, streamlining the code and reducing redundancy. The `::name` meta property references the name of the model, as described in the TypeSpec documentation.", "context": "- document_dir: typespec_docs\n- document_filename: libraries#http#operations.md\n- document_title: Operations\n- document_link: https://typespec.io/docs/libraries/http/operations\n- document_content: # libraries#http#operations.md\n\n# Operations\n\n## Operation verb\n\n**Default behavior:**\r\n\r\n- If `@post` operation has a request body\r\n- `@get` otherwise\r\n\r\n**Configure:**\r\n\r\nYou can use one of the [verb decorators](./reference/decorators.md): `@get`, `@put`, etc.\n\n## Route\n\nAn operation route can be specified using the `@route` decorator.\r\n\r\n```typespec\r\n@route(\"/pets\") op list(): Pet[];\r\n```\r\n\r\nRoute path parameters are declared using `{}`. Providing `@path` on the model property with the matching name is optional.\r\n\r\n```typespec\r\n@route(\"/pets/{petId}\") op get(petId: string): Pet;\r\n// or explicit @path\r\n@route(\"/pets/{petId}\") op get(@path petId: string): Pet;\r\n```\r\n\r\nRoute can be specified on a parent namespace or interface. In that case all the operations, interfaces and namespaces underneath will be prefixed with it.\r\n\r\n```typespec\r\n@route(\"/store\")\r\nnamespace PetStore {\r\n  op hello(): void; // `/store`\r\n  @route(\"ping\") op ping(): void; // `/store/ping`\r\n\r\n  @route(\"/pets\")\r\n  interface Pets {\r\n    list(): Pet[]; // `/store/pets`\r\n    @route(\"{petId}\") read(petId: string): Pet; // `/store/pets/{petId}`\r\n  }\r\n}\r\n```\n\n## Path and query parameters\n\nModel properties and parameters which should be passed as path and query parameters use the `@path` and `@query` parameters respectively. Let's modify our list operation to support pagination, and add a read operation to our Pets resource:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): Pet[];\r\n  op read(@path petId: int32): Pet;\r\n}\r\n```\r\n\r\nPath parameters are appended to the URL unless a substitution with that parameter name exists on the resource path. For example, we might define a sub-resource using the following TypeSpec. Note how the path parameter for our sub-resource's list operation corresponds to the substitution in the URL.\r\n\r\n```typespec\r\n@route(\"/pets/{petId}/toys\")\r\nnamespace PetToys {\r\n  op list(@path petId: int32): Toy[];\r\n}\r\n```\n\n## Request & response bodies\n\nRequest and response bodies can be declared explicitly using the `@body` decorator. Let's add an endpoint to create a pet. Let's also use this decorator for the responses, although this doesn't change anything about the API.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[];\r\n  };\r\n  op read(@path petId: int32): {\r\n    @body pet: Pet;\r\n  };\r\n  @post\r\n  op create(@body pet: Pet): {};\r\n}\r\n```\r\n\r\nNote that in the absence of explicit `@body`:\r\n\r\n1. The set of parameters that are not marked @header, @query, or @path form the request body.\r\n2. The set of properties of the return model that are not marked @header or @statusCode form the response body.\r\n3. If the return type is not a model, then it defines the response body.\r\n\r\nThis is how we were able to return Pet and Pet[] bodies without using @body for list and read. We can actually write\r\ncreate in the same terse style by spreading the Pet object into the parameter list like this:\r\n\r\nSee also [metadata](./operations.md#metadata) for more advanced details.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @post\r\n  op create(...Pet): {};\r\n}\r\n```\n\n## Headers\n\nModel properties and parameters that should be passed in a header use the `@header` decorator. The decorator takes the header name as a parameter. If a header name is not provided, it is inferred from the property or parameter name. Let's add `etag` support to our pet store's read operation.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[];\r\n  };\r\n  op read(@path petId: int32, @header ifMatch?: string): {\r\n    @header eTag: string;\r\n    @body pet: Pet;\r\n  };\r\n  @post\r\n  op create(@body pet: Pet): {};\r\n}\r\n```\n\n## Status codes\n\n**Default behavior:**\r\n\r\n- `4xx,5xx` if response is marked with `@error`\r\n- `200` otherwise\r\n\r\n**Configure:**\r\n\r\nUse the `@statusCode` decorator on a property to declare a status code for a response. Generally, setting this to just `int32` isn't particularly useful. Instead, use number literal types to create a discriminated union of response types. Let's add status codes to our responses, and add a 404 response to our read endpoint.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @error\r\n  model Error {\r\n    code: string;\r\n  }\r\n\r\n  op list(@query skip: int32, @query top: int32): {\r\n    @body pets: Pet[]; // statusCode: 200 Implicit\r\n  };\r\n  op read(@path petId: int32, @header ifMatch?: string): {\r\n    @statusCode statusCode: 200;\r\n    @header eTag: string;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n  };\r\n  op create(@body pet: Pet): {\r\n    @statusCode statusCode: 204;\r\n  } | Error; //statusCode: 4xx,5xx as Error use `@error` decorator\r\n}\r\n```\n\n## Content type\n\n[See the documentation of Content-Types](./content-types.md).\n\n## Built-in response shapes\n\nSince status codes are so common for REST APIs, TypeSpec comes with some built-in types for common status codes so you don't need to declare status codes so frequently.\r\n\r\nThere is also a `Body<T>` type, which can be used as a shorthand for { @body body: T } when an explicit body is required.\r\n\r\nLets update our sample one last time to use these built-in types:\r\n\r\n```typespec\r\nmodel ETag {\r\n  @header eTag: string;\r\n}\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): OkResponse & Body<Pet[]>;\r\n  op read(@path petId: int32, @header ifMatch?: string): (OkResponse &\r\n    Body<Pet> &\r\n    ETag) | NotFoundResponse;\r\n  @post\r\n  op create(...Pet): NoContentResponse;\r\n}\r\n```\r\n\r\nNote that the default status code is 200 for non-empty bodies and 204 for empty bodies. Similarly, explicit `Body<T>` is not required when T is known to be a model. So the following terser form is equivalent:\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): Pet[];\r\n  op read(@path petId: int32, @header ifMatch?: string): (Pet & ETag) | NotFoundResponse;\r\n  @post\r\n  op create(...Pet): {};\r\n}\r\n```\r\n\r\nFinally, another common style is to make helper response types that are\r\nshared across a larger service definition. In this style, you can be\r\nentirely explicit while also keeping operation definitions concise.\r\n\r\nFor example, we could write :\r\n\r\n```typespec\r\nmodel ListResponse<T> {\r\n  ...OkResponse;\r\n  ...Body<T[]>;\r\n}\r\n\r\nmodel ReadSuccessResponse<T> {\r\n  ...OkResponse;\r\n  ...ETag;\r\n  ...Body<T>;\r\n}\r\n\r\nalias ReadResponse<T> = ReadSuccessResponse<T> | NotFoundResponse;\r\n\r\nmodel CreateResponse {\r\n  ...NoContentResponse;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op list(@query skip: int32, @query top: int32): ListResponse<Pet>;\r\n  op read(@path petId: int32, @header ifMatch?: string): ReadResponse<Pet>;\r\n  @post\r\n  op create(...Pet): CreateResponse;\r\n}\r\n```\n\n## Handling files\n\n`@typespec/http` provides a special model [`TypeSpec.Http.File`](../http/reference/data-types.md#file-typespechttpfile) for handling file uploads and downloads in HTTP operations. When working with files, emitters need to implement special handling due to their binary nature.\r\n\r\nFor more information about HTTP file bodies and how to configure them, see [the documentation on Files][http-files].\r\n\r\n[http-files][./files.md]\n\n### Basic File Handling\n\nWhen the model `Http.File` (or any model that extends `Http.File`) is the _exact_ body of an HTTP request, emitters **must** treat this model with special care:\r\n\r\n- The `contentType` property should be used as the value for the `Content-Type` header in requests and vice-versa for responses.\r\n- The `filename` property should be used in the `Content-Disposition` header in responses and vice-versa for multipart requests (`filename` cannot be sent in a non-multipart HTTP request because `Content-Disposition` is only valid for responses and multipart requests).\r\n- The file content should be treated as the raw body of the request/response without any additional parsing.\r\n\r\nSee [`isHttpFile`](../http/reference/js-api/functions/isHttpFile.md) for a helper that emitters/libraries can use to detect instances of `Http.File`.\n\n### Examples\n\n#### Uploading and downloading files\r\n\r\n```typespec\r\n// Uploading and downloading\r\n@route(\"/files\")\r\ninterface Files {\r\n  @post\r\n  upload(@body file: Http.File): {\r\n    @statusCode statusCode: 201;\r\n  };\r\n\r\n  download(@path fileId: string): Http.File;\r\n}\r\n```\r\n\r\n#### Custom file types\r\n\r\nIf you want to declare specific types of files that are accepted, but still treated as binary files, declare the content types by extending the `Http.File` model and overriding the `contentType` field.\r\n\r\n```typespec\r\n// Custom file type for images\r\nmodel ImageFile extends Http.File {\r\n  contentType: \"image/jpeg\" | \"image/png\" | \"image/gif\";\r\n}\r\n\r\n@route(\"/images\")\r\ninterface Images {\r\n  @post\r\n  upload(@body image: ImageFile): {\r\n    @statusCode statusCode: 201;\r\n  };\r\n\r\n  download(@path imageId: string): ImageFile;\r\n}\r\n```\n\n## Automatic visibility\n\nThe `@typespec/rest` library understands [Lifecycle Visibility](../../language-basics/visibility.md#lifecycle-visibility) and provides functionality for emitters to apply visibility transforms based on whether a model represents a request or response and on HTTP method usage as detailed in the table below.\r\n\r\nSee [handling visibility and metadata](../../extending-typespec/emitter-metadata-handling.md) for details on how to incorporate this information into an emitter implementation.\r\n\r\n| Modifier         | Visible in           |\r\n| ---------------- | -------------------- |\r\n| Lifecycle.Read   | Any response         |\r\n| Lifecycle.Query  | GET or HEAD request  |\r\n| Lifecycle.Create | POST or PUT request  |\r\n| Lifecycle.Update | PATCH or PUT request |\r\n| Lifecycle.Delete | DELETE request       |\r\n\r\nThis allows a single logical TypeSpec model to be used as in the following example:\r\n\r\n```typespec\r\nmodel User {\r\n  name: string;\r\n  @visibility(Lifecycle.Read) id: string;\r\n  @visibility(Lifecycle.Create) password: string;\r\n}\r\n\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(@path id: string, ...User): User;\r\n  @get get(@path id: string): User;\r\n}\r\n```\r\n\r\nThere is a single logical user entity represented by the single TypeSpec type `User`, but the HTTP payload for this entity varies based on context. When returned in a response, the `id` property is included, but when sent in a request, it is not. Similarly, the `password` property is only included in create requests, but not present in responses.\r\n\r\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(Lifecycle.Read)` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas.\n\nincluded in create requests, but not present in responses.\r\n\r\nThe OpenAPI v3 emitter will apply these visibilities automatically, without explicit use of `@withVisibility`, and it will generate separate schemas suffixed by visibility when necessary. `@visibility(Lifecycle.Read)` can be expressed in OpenAPI without generating additional schema by specifying `readOnly: true` and the OpenAPI v3 emitter will leverage this a an optimization, but other visibilities will generate additional schemas. For example, `@visibility(Lifecycle.Create)` applied to a model property of a type named Widget will generate a `WidgetCreate` schema.\r\n\r\nAnother emitter such as one generating client code can see and preserve a single logical type and deal with these HTTP payload differences by means other than type proliferation.\r\n\r\nModeling with logical entities rather than HTTP-specific shapes also keeps the TypeSpec spec decoupled from HTTP and REST and can allow the same spec to be used with multiple protocols.\n\n## Metadata\n\nin terms of the logical entity:\r\n\r\n```typespec\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(...User): User;\r\n}\r\n```\r\n\r\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\r\n\r\n```\r\nPOST /Users/TypeSpecFan42 HTTP/1.1\r\nContent-Type: application/json\r\n{\r\n  \"name\": \"TypeSpec Fan\",\r\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\r\n}\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\n{\r\n  name: \"TypeSpec Fan\",\r\n  id: \"TypeSpecFan42\r\n}\r\n```\n\nThe properties that designate content for the HTTP envelope (`@header`, `@path`, `@query`, `@statusCode`) rather than the content in an HTTP payload are often called \"metadata\".\r\n\r\nMetadata is determined to be applicable or inapplicable based on the context that it is used:\r\n\r\n| Context       | Applicability       |\r\n| ------------- | ------------------- |\r\n| `@query`      | request only        |\r\n| `@path`       | request only        |\r\n| `@statusCode` | response only       |\r\n| `@header`     | request or response |\r\n\r\nAdditionally metadata that appears in an array element type always inapplicable.\r\n\r\nWhen metadata is deemed \"inapplicable\", for example, if a `@path` property is seen in a response, it becomes part of the payload instead unless the [@includeInapplicableMetadataInPayload](./reference/decorators.md#@TypeSpec.Http.includeInapplicableMetadataInPayload) decorator is used and given a value of `false`.\r\n\r\nThe handling of metadata applicability furthers the goal of keeping a single logical model in TypeSpec. For example, this defines a logical `User` entity that has a name, ID and password, but further annotates that the ID is sent in the HTTP path and the HTTP body in responses. Also, using automatic visibility as before, we further indicate that the password is only present in create requests.\r\n\r\n```typespec\r\nmodel User {\r\n  name: string;\r\n  @path id: string;\r\n  @visibility(Lifecycle.Create) password: string;\r\n}\r\n```\r\n\r\nThen, we can write operations in terms of the logical entity:\r\n\r\n```typespec\r\n@route(\"/users\")\r\ninterface Users {\r\n  @post create(...User): User;\r\n}\r\n```\r\n\r\nAbstractly, this expresses that a create operation that takes and returns a user. But concretely, at the HTTP protocol level, a create request and response look like this:\r\n\r\n```\r\nPOST /Users/TypeSpecFan42 HTTP/1.1\r\nContent-Type: application/json\r\n{\r\n  \"name\": \"TypeSpec Fan\",\r\n  \"password\": \"Y0uW1llN3v3rGu3ss!\"\r\n}\r\n\r\nHTTP/1.1 200 OK\r\nContent-Type: application/json\r\n{\n\n### Visibility vs. Metadata applicability\n\nMetadata properties are filtered based on visibility as [described above](#automatic-visibility). This is done independently before applicability is considered. If a a metadata property is not visible then it is neither part of the envelope nor the HTTP payload, irrespective of its applicability.\n\n### Nested metadata\n\nMetadata properties are not required to be top-level. They can also be nested deeper in a parameter or response model type. For example:\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: {\r\n    @header example: string;\r\n  };\r\n  name: string;\r\n}\r\n```\r\n\r\nNote that nesting in this sense does not require the use of anonymous models. This is equivalent:\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: Headers;\r\n  name: string;\r\n}\r\nmodel Headers {\r\n  @header example: string;\r\n}\r\n```\r\n\r\nIn the event that this nesting introduces duplication, then the least nested property with a given name is preferred and the duplicate metadata properties are ignored.\r\n\r\n```typespec\r\nmodel Thing {\r\n  headers: {\r\n    @header example: string; // preferred\r\n    more: {\r\n      @header example: string; // ignored\r\n    };\r\n  };\r\n}\r\n```\n\n## Emitter resources\n\nSee [Handling metadata and visibility in emitters for REST API](../../extending-typespec/emitter-metadata-handling.md) for information on how to handle metadata applicability and automatic visibility in a custom emitter.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: language-basics#models.md\n- document_title: Models\n- document_link: https://typespec.io/docs/language-basics/models\n- document_content: # language-basics#models.md\n\n# Models\n\nModels in TypeSpec are utilized to define the structure or schema of data.\n\n## Types of models\n\nModels can be categorized into two main types:\r\n\r\n- [Record](#record)\r\n- [Array](#array)\n\n### Record\n\nA Record model is a structure that consists of named fields, referred to as properties.\r\n\r\n- The name can be an [`identifier`](./identifiers.md) or `string literal`.\r\n- The type can be any type reference.\r\n- Properties are arranged in a specific order. Refer to [property ordering](#property-ordering) for more details.\r\n\r\n```typespec\r\nmodel Dog {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n```\r\n\r\n#### Optional properties\r\n\r\nProperties can be designated as optional by using the `?` symbol.\r\n\r\n```typespec\r\nmodel Dog {\r\n  address?: string;\r\n}\r\n```\r\n\r\n#### Default values\r\n\r\nProperties can be assigned a default value using the `=` operator.\r\n\r\n```typespec\r\nmodel Dog {\r\n  address?: string = \"wild\";\r\n  age: uint8 = 0;\r\n}\r\n```\r\n\r\n#### Property ordering\r\n\r\nProperties are arranged in the order they are defined in the source. Properties acquired via `model is` are placed before properties defined in the model body. Properties obtained via `...` are inserted at the point where the spread appears in the source.\r\n\r\nExample:\r\n\r\n```tsp\r\nmodel Pet {\r\n  name: string;\r\n  age: uint8;\r\n}\r\n\r\nmodel HasHome {\r\n  address: string;\r\n}\r\n\r\nmodel Cat is Pet {\r\n  meow: boolean;\r\n  ...HasHome;\r\n  furColor: string;\r\n}\r\n\r\n// The resulting property order for Cat is:\r\n// name, age, meow, address, furColor\r\n```\n\n### Additional properties\n\nThe `Record<T>` model can be used to define a model with an arbitrary number of properties of type T. It can be combined with a named model to provide some known properties.\r\n\r\nThere are three ways to achieve this, each with slightly different semantics:\r\n\r\n- Using the `...` operator\r\n- Using the `is` operator\r\n- Using the `extends` operator\r\n\r\n#### Using the `...` operator\r\n\r\nSpreading a Record into your model implies that your model includes all the properties you have explicitly defined, plus any additional properties defined by the Record. This means that a property in the model could be of a different and incompatible type with the Record value type.\r\n\r\n```tsp\r\n// In this example, the Person model has a property `age` that is an int32, but also has other properties that are all strings.\r\nmodel Person {\r\n  age: int32;\r\n  ...Record<string>;\r\n}\r\n```\r\n\r\n#### Using the `is` operator\r\n\r\nWhen using `is Record<T>`, it indicates that all properties of this model are of type T. This means that each property explicitly defined in the model must also be of type T.\r\n\r\nThe example above would be invalid\r\n\r\n```tsp\r\nmodel Person is Record<string> {\r\n  age: int32;\r\n  //   ^ int32 is not assignable to string\r\n}\r\n```\r\n\r\nBut the following would be valid\r\n\r\n```tsp\r\nmodel Person is Record<string> {\r\n  name: string;\r\n}\r\n```\r\n\r\n#### Using the `extends` operator\r\n\r\nThe `extends` operator has similar semantics to `is`, but it defines the relationship between the two models. In many languages, this would probably result in the same emitted code as `is` and it is recommended to use `is Record<T>` instead.\r\n\r\n```tsp\r\nmodel Person extends Record<string> {\r\n  name: string;\r\n}\r\n```\n\n### Special property types\n\n#### `never`\r\n\r\nA model property can be declared as having the type `never`. This can be interpreted as the model not having that property.\r\n\r\nThis can be useful in a model template to omit a property.\r\n\r\n```typespec\r\nmodel Address<TState> {\r\n  state: TState;\r\n  city: string;\r\n  street: string;\r\n}\r\n\r\nmodel UKAddress is Address<never>;\r\n```\r\n\r\n:::note\r\nThe responsibility of removing `never` properties lies with the emitter. The TypeSpec compiler will not automatically omit them.\r\n:::\n\n### Array\n\nArrays are models created using the `[]` syntax, which is a shorthand for using the `Array<T>` model type.\n\n## Model composition\n\n### Spread\n\nThe spread operator (`...`) copies the members of a source model into a target model. This operation doesn't create any nominal relationship between the source and target, making it useful when you want to reuse common properties without generating complex inheritance relationships.\r\n\r\n```typespec\r\nmodel Animal {\r\n  species: string;\r\n}\r\n\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Dog {\r\n  ...Animal;\r\n  ...Pet;\r\n}\r\n\r\n// The Dog model is equivalent to the following declaration:\r\nmodel Dog {\r\n  species: string;\r\n  name: string;\r\n}\r\n```\n\n### Extends\n\nThere are times when you want to create an explicit relationship between two models, such as when you're generating class definitions in languages that support inheritance. The `extends` keyword can be used to establish this relationship.\r\n\r\n```typespec\r\nmodel Animal {\r\n  species: string;\r\n}\r\n\r\nmodel Dog extends Animal {}\r\n```\n\n### Is\n\nThere are instances when you want to create a new type that is an exact copy of an existing type but with additional properties or metadata, without creating a nominal inheritance relationship. The `is` keyword can be used for this purpose. It copies all the properties (like spread), but also copies [decorators](./decorators.md) as well. A common use case is to provide a better name to a [template](#model-templates) instantiation:\r\n\r\n```typespec\r\n@decorator\r\nmodel Thing<T> {\r\n  property: T;\r\n}\r\n\r\nmodel StringThing is Thing<string>;\r\n\r\n// The StringThing declaration is equivalent to the following declaration:\r\n@decorator\r\nmodel StringThing {\r\n  property: string;\r\n}\r\n```\n\n## Model templates\n\nRefer to [templates](./templates.md) for more details on templates.\r\n\r\n```typespec\r\nmodel Page<Item> {\r\n  size: int32;\r\n  item: Item[];\r\n}\r\n\r\nmodel DogPage {\r\n  ...Page<Dog>;\r\n}\r\n```\n\n## Meta type references\n\nSome model property meta types can be referenced using `::`.\r\n\r\n| Name | Example          | Description                              |\r\n| ---- | ---------------- | ---------------------------------------- |\r\n| type | `Pet.name::type` | Reference the type of the model property |\n", "latency": 7.542789936065674, "response_length": 494}
{"query": "title: Adding HTTP status codes responses\n\nquestion: Hello,\nI'm new to Typespec and I don't know how to assign different status codes in the response. Let's say I need to send a 409 response or any other specific HTTP status code.\nCan you help me with that please?\nThanks!", "ground_truth": "You can see examples [here](https://typespec.io/docs/getting-started/getting-started-http#status-codes). Essentially, when an operation returns a model, that model is checked for a field with the `@statusCode` decorator, which becomes the status code for that operation.", "response": "To assign specific HTTP status codes in TypeSpec responses, you can use the `@statusCode` decorator. This decorator allows you to specify the status code for a response. The property type must be an HTTP status code integer or a union of status code integers. For example, to send a 409 response, you can define it as follows:\n\n```typespec\n@post op update(@body widget: Widget): {\n  @statusCode _: 409;\n  @body body: Error;\n};\n```\n\nAlternatively, you can use predefined standard response types like `ConflictResponse` for a 409 status code. Here's an example:\n\n```typespec\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error);\n```\n\nThis approach ensures that your API responses are correctly mapped to the desired HTTP status codes.", "context": "- document_dir: typespec_docs\n- document_filename: getting-started#typespec-for-openapi-dev.md\n- document_title: TypeSpec for OpenAPI Developers\n- document_link: https://typespec.io/docs/getting-started/typespec-for-openapi-dev\n- document_content: # getting-started#typespec-for-openapi-dev.md\n\n# TypeSpec for OpenAPI Developers\n\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\r\n\r\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\r\nTypeSpec designs into OpenAPI.\r\n\r\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\r\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\r\nto the section of this document for that feature.\n\n## Data Types\n\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\r\n\r\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\n\n### type and format\n\n| RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\r\n  noType?: unknown;\r\n}\r\n```\r\n\r\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\r\nTypeSpec supports some of these directly.\r\n\r\n[Format Registry]: https://spec.openapis.org/registry/format\r\n\r\n| `type:`   | `format:`    | TypeSpec type | Notes |\r\n| --------- | ------------ | ------------- | ----- |\r\n| `number`  | `decimal`    | `decimal`     |       |\r\n| `number`  | `double-int` | `safeint`     |       |\r\n| `integer` | `int8`       | `int8`        |       |\r\n| `integer` | `int16`      | `int16`       |       |\r\n| `integer` | `uint8`      | `uint8`       |       |\r\n| `string`  | `uri`        | `url`         |       |\r\n\r\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\r\nthe format explicitly.\n\nThe following table shows how common OpenAPI types map to TypeSpec types:\r\n\r\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\r\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\r\n| `integer` | `int32`     | `int32`          |                                                                           |\r\n| `integer` | `int64`     | `int64`          |                                                                           |\r\n| `number`  | `float`     | `float32`        |                                                                           |\r\n| `number`  | `double`    | `float64`        |                                                                           |\r\n| `string`  |             | `string`         |                                                                           |\r\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\r\n| `string`  | `binary`    | `bytes`          | for \"binary\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\r\n| `string`  | `date`      | `plainDate`      |                                                                           |\r\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\r\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\r\n| `string`  | `password`  | `@secret string` |                                                                           |\r\n| `boolean` |             | `boolean`        |                                                                           |\r\n\r\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\r\n\r\n```typespec\r\nmodel Example {\r\n  /** This property has no `type` defined. */\n\n### JSON Schema assertions\n\nOpenAPI supports a variety of \"assertions\" that can be used to further restrict the values allowed for a data type.\r\nThese are actually borrowed into OpenAPI from JSON Schema.\r\n\r\nFor `type: integer` and `type: number` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minimum: value`            | `@minValue(value)` decorator |       |\r\n| `maximum: value`            | `@maxValue(value)` decorator |       |\r\n\r\nFor `type: string` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\r\n| --------------------------- | ----------------------------- | ----- |\r\n| `minLength: value`          | `@minLength(value)` decorator |       |\r\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\r\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\r\n\r\nFor `type: array` data types:\r\n\r\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\r\n| --------------------------- | ---------------------------- | ----- |\r\n| `minItems: value`           | `@minItems(value)` decorator |       |\r\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\n\n### enum\n\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\r\n\r\n<!-- To retain the quotes from the enum values -->\r\n<!-- prettier-ignore-start -->\r\n```typespec\r\nenum Color {\r\n  \"red\",\r\n  \"blue\",\r\n  \"green\",\r\n}\r\n```\r\n<!-- prettier-ignore-end -->\r\n\r\nAnother is to use the union operation to define the enum values inline, e.g.:\r\n\r\n```typespec\r\nmodel Example {\r\n  size?: \"small\" | \"medium\" | \"large\" | \"x-large\";\r\n}\r\n```\n\n### default\n\nA model property that specifies a default value using \"=\" will produce a `default` field in the schema for this property.\r\n\r\n```typespec\r\nmodel Example {\r\n  answer?: int32 = 42;\r\n  color?: string = \"purple\";\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nanswer:\r\n  type: integer\r\n  format: int32\r\n  default: 42\r\ncolor:\r\n  type: string\r\n  default: purple\r\n```\n\n## Host / BasePath / Servers\n\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\r\n\r\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\r\n\r\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\r\n\r\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\r\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\n\n## Paths Object\n\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \"path\" for the operation.\r\n\r\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\r\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\r\n\r\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\r\n\r\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\r\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\r\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\r\n\r\n```typespec\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  op create(@body pet: Pet): Pet; // uses path \"/pets\"\r\n  op read(@path petId: int32): Pet; // uses path \"/pets/{petId}\"\r\n}\r\n```\r\n\r\nWhen the `@route` decorator is used within a namespace or interface that also has a `@route` decorator, the path is\r\nobtained by concatenating the routes.\r\n\r\n```typespec\r\n@route(\"/widgets\")\r\nnamespace Widgets {\r\n  // widgets operations\r\n\r\n  @route(\"/{id}/parts\")\r\n  namespace Parts {\r\n    op list(@path id: string): Part[] | Error; // uses path \"/widgets/{id}/parts\"\r\n  }\r\n}\r\n```\n\n## Path Item Object\n\nIn OpenAPI, a path item object [[v2][v2-pathitem], [v3][v3-pathitem]] describes the operations available on a single path. A path may have at most one `get`, `put`, `post`, `patch`, `delete`, or `head` operation.\r\n\r\n[v2-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#path-item-object\r\n[v3-pathitem]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#path-item-object\r\n\r\nIn TypeSpec, operations are defined within a namespace or interface with a syntax similar to typescript functions.\r\nThe HTTP method for an operation can be specified explicitly using a decorator: `@get`, `@put`, `@post`, `@patch`, `@delete`, or `@head`.\r\nIf an HTTP method decorator is not specified then the default is `post` if there is a body and `get` otherwise.\r\n\r\n```typespec\r\n@tag(\"Gadgets\")\r\n@route(\"/gadgets\")\r\nnamespace Gadgets {\r\n  op create(@body gadget: Gadget): Gadget | Error; // uses \"post\" method\r\n  op read(@path id: string): Gadget | Error; // uses \"get\" method\r\n}\r\n```\r\n\r\nOther path item fields:\r\n\r\n| OpenAPI `pathItem` field | TypeSpec construct | Notes                    |\r\n| ------------------------ | ------------------ | ------------------------ |\r\n| `summary`                |                    | Not currently supported. |\r\n| `description`            |                    | Not currently supported. |\r\n| `parameters`             |                    | Not currently supported. |\n\n## Operation Object\n\nIn OpenAPI, an operation object [[v2][v2-operation], [v3][v3-operation]] describes an operation.\r\n\r\n[v2-operation]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#operation-object\r\n[v3-operation]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operation-object\r\n\r\nThe fields in an OpenAPI operation object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `operation` field | TypeSpec construct                         | Notes                                                                        |\r\n| ------------------------- | ------------------------------------------ | ---------------------------------------------------------------------------- |\r\n| `tags`                    | `@tag` decorator                           |                                                                              |\r\n| `summary`                 | `@summary` decorator                       |                                                                              |\r\n| `description`             | `@doc` decorator or doc comment            |                                                                              |\r\n| `externalDocs`            | `@externalDocs` decorator                  |                                                                              |\r\n| `operationId`             | operation name or `@operationId` decorator |                                                                              |\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n|\n\n|\r\n| `parameters`              | `op` parameter list                        | see [Parameter Object](#parameter-object)                                    |\r\n| `requestBody`             | parameter with `@body` decorator           | see [Request Body Object](#request-body-object-oas3)                         |\r\n| `responses`               | `op` return type(s)                        | see [Responses Object](#responses-object)                                    |\r\n| `callbacks`               |                                            | Not currently supported.                                                     |\r\n| `deprecated`              | `#deprecated` directive                    |                                                                              |\r\n| `security`                |                                            | see [Security Schemes Object](#securitydefinitions--securityschemes-object). |\r\n| `servers`                 | `@server` decorator                        | Can be specified multiple times.                                             |\n\n### Tags\n\nTags can be specified using the `@tag` decorator on an operation.\r\nThe `@tag` decorator can also be used on a namespace or interface to specify tags for all operations within the namespace or interface.\r\nTags are additive, so tags specified on an operation are added to the tags specified on the namespace or interface.\r\nThe `@tag` decorator can be used multiple times to specify multiple tags on an operation, namespace, or interface.\n\n### Description\n\nUse the `@doc` decorator to specify a description for an operation. The value of the `@doc` decorator can be a multi-line string\r\nand can contain markdown formatting.\r\n\r\n```typespec\r\n@doc(\"\"\"\r\n  Get status info for the service.\r\n  The status includes the current version of the service.\r\n  The status value may be one of:\r\n  - `ok`: the service is operating normally\r\n  - `degraded`: the service is operating in a degraded state\r\n  - `down`: the service is not operating\r\n  \"\"\")\r\n@tag(\"Status\")\r\n@route(\"/status\")\r\n@get\r\nop status(): string;\r\n```\r\n\r\nYou can also use a \"doc comment\" to specify the description for an operation. A doc comment is a comment that begins with `/**`.\r\nDoc comments may be spread across multiple lines and may contain markdown formatting.\r\n\r\n```typespec\r\n/**\r\n * Get health info for the service.\r\n * The health includes the current version of the service.\r\n * The health value may be one of:\r\n * - `ok`: the service is operating normally\r\n * - `degraded`: the service is operating in a degraded state\r\n * - `down`: the service is not operating\r\n */\r\n@tag(\"Health\")\r\n@route(\"/health\")\r\n@get\r\nop health(): string;\r\n```\r\n\r\n[See documentation doc for more information](../language-basics/documentation.md).\n\n### operationId\n\nYou can specify the operationId for an operation using the `@operationId` decorator.\r\nWhen the `@operationId` decorator is not specified, the operationId is generated from the operation name.\r\nFor an operation defined in the top-level namespace, the operationId is the just operation name.\r\nIf the operation is defined within a inner namespace or interface, then the operationId is\r\nprefixed with the name of the innermost namespace or interface name.\r\n\r\nNote: this approach will generally produce unique operationIds, as required by OpenAPI,\r\nbut it is possible to create duplicate operationIds.\n\n## Parameter Object\n\nIn OpenAPI, a parameter object [[v2][v2-parameter], [v3][v3-parameter]] describes a single operation parameter.\r\n\r\n[v2-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#parameter-object\r\n[v3-parameter]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#parameter-object\r\n\r\nThe following fields of a parameter object are common to both OpenAPI v2 and v3:\r\n\r\n| OpenAPI `parameter` field | TypeSpec construct           | Notes                                                                                                                        |\r\n| ------------------------- | ---------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |\r\n| `name`                    | parameter name               |                                                                                                                              |\r\n| `in`                      | decorator                    | `@query`, `@path`, `@header`, `@body`                                                                                        |\r\n| `description`             | `/** */` or `@doc` decorator |                                                                                                                              |\r\n| `required`                | from parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `allowEmptyValue`         |                              | Not supported, this field is `NOT RECOMMENDED` in OpenAPI.                                                                   |\r\n\r\n<!-- prettier-ignore-end -->\n\n### OpenAPI v2\n\nThe following fields of a parameter object are specific to OpenAPI v2:\r\n\r\n| OpenAPI v2 `parameter` field | TypeSpec construct                          | Notes                         |\r\n| ---------------------------- | ------------------------------------------- | ----------------------------- |\r\n| `type`                       | parameter type                              | see [Data Types](#data-types) |\r\n| `collectionFormat`           | uri template in `@route` or `expode, style` |                               |\r\n\r\n#### Collection Formats\r\n\r\nIn OpenAPI v2, the `collectionFormat` field of a query or header parameter object specifies how multiple values are delimited.\r\nYou can use a combination of the `@encode` decorator and `explode` field of the `@query` or `@header` decorator to specify the collection format.\r\n\r\n```typespec\r\nop read(\r\n  @query csv?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: false }) csvExplicit?: string[], // equivalent to collectionFormat: csv\r\n  @query(#{ explode: true }) multi?: string[], // equivalent to collectionFormat: multi\r\n  @query @encode(ArrayEncoding.pipeDelimited) pipes?: string[], // equivalent to collectionFormat: pipes\r\n): Widget | Error;\r\n```\n\n### OpenAPI v3\n\n|\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n| `content`                    |                                                                                                                 | Not currently supported.                                                        |\n\nThe following fields of a parameter object are specific to OpenAPI v3:\r\n\r\n| OpenAPI v3 `parameter` field | TypeSpec construct                                                                                              | Notes                                                                           |\r\n| ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| `style`                      | `explode` parameter on `@query` or `@header` and `@encode`                                                      |                                                                                 |\r\n| `explode`                    | `explode` parameter on `@query` or `@header`                                                                    |                                                                                 |\r\n| `schema`                     | parameter schema                                                                                                | see [Schema Object](#schema-object)                                             |\r\n| `deprecated`                 | `#deprecated` directive.                                                                                        |                                                                                 |\r\n| `example`                    | `@example` on data types (e.g. models, scalars), `@opExample` to describe in-line parameters of operations      | Open API 3.0 only supports a single example when using `@example` on data types |\r\n| `examples`                   | `@example` on data types (e.g. models, scalars), `@opExample` to describe parameters/return types of operations | Open API 3.1 always outputs `examples` instead of `example`.                    |\r\n|\n\n## Request Body Object (OAS3)\n\nIn OpenAPI v3, the operation request body is defined with a [Request Body object] rather than as a parameter.\r\n\r\n[Request Body object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#request-body-object\r\n\r\nAn OpenAPI v3 Request Body object corresponds to a TypeSpec `op` parameter with the `@body` decorator.\r\n\r\n<!-- prettier-ignore-start -->\r\n| OpenAPI `requestBody` field | TypeSpec construct      | Notes        |\r\n| --------------------------- | ----------------------- | ------------ |\r\n| `description`               | `@doc` decorator        |              |\r\n| `required`                  | parameter \"optionality\" | a \"?\" following the parameter name indicates it is optional (`required: false`), otherwise it is required (`required: true`) |\r\n| `content`                   | `@body` parameter type  |              |\r\n<!-- prettier-ignore-end -->\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\n```typespec\r\n@put op uploadImage(@header contentType: \"image/png\", @body image: bytes): void;\r\n@post op analyze(\r\n  @header contentType: \"application/octet-stream\" | \"application/pdf\" | \"image/jpeg\",\r\n  @body image: bytes,\r\n): string | Error;\r\n```\r\n\r\nTo get multiple `content` entries with different schemas (say one structured and one binary),\r\nyou need to define two separate operations that share the same path and method.\r\nYou do with with the `@sharedRoute` decorator.\r\n\r\n```typespec\r\n@route(\":process\")\r\nnamespace Process {\r\n  @sharedRoute\r\n  @post\r\n  op process(...Widget): Widget | Error;\r\n\r\n  model CsvBody {\r\n    @header contentType: \"text/csv\";\r\n    @body _: string;\r\n  }\r\n  @sharedRoute\r\n  @post\r\n  op process2(...CsvBody): Widget | Error;\r\n}\r\n```\n\n## Responses Object\n\nIn OpenAPI, the responses object [[v2][v2-responses], [v3][v3-responses]] specifies the possible responses for an operation.\r\nThe responses object maps a HTTP response code to the expected response.\r\n\r\n[v2-responses]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#responses-object\r\n[v3-responses]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#responses-object\r\n\r\nIn TypeSpec, operation responses are defined by the return types of the `op`. The status code for a response can be specified as a property in the return type with the `@statusCode` decorator. The value of the property with the `@statusCode` decorator should be an HTTP status code or union of status codes. When the value is a union of status codes, a response is generated for each status code in the union.\r\n\r\nIf a return type does not contain a `statusCode`, the default is `200` except for `void` which defaults to `204`.\r\n\r\nTo get the `default` response, specify the `@error` decorator on the return type model.\r\n\r\n```typespec\r\n@get op read(@path id: string): Widget; // has \"200\" response\r\n@delete op delete(@path id: string): void; // has \"204\" response\r\n// has \"200\" and \"201\" response\r\n@put op create(@body widget: Widget): {\r\n  @statusCode _: \"200\" | \"201\";\r\n  @body body: Widget;\r\n};\r\n// has \"200\" and \"default\" response\r\n@post op update(@body widget: Widget): Widget | Error;\r\n```\r\n\r\nThe TypeSpec.Http package also defines several standard response types.\r\n\r\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            |\n\n| HTTP Status Code | TypeSpec construct     |\r\n| ---------------- | ---------------------- |\r\n| `200`            | `OkResponse`           |\r\n| `201`            | `CreatedResponse`      |\r\n| `202`            | `AcceptedResponse`     |\r\n| `204`            | `NoContentResponse`    |\r\n| `301`            | `MovedResponse`        |\r\n| `304`            | `NotModifiedResponse`  |\r\n| `401`            | `UnauthorizedResponse` |\r\n| `404`            | `NotFoundResponse`     |\r\n| `409`            | `ConflictResponse`     |\r\n\r\nYou can intersect these standard response types with your own response types.\r\n\r\n```typespec\r\n// has \"200\", '409', and \"default\" responses\r\n@post op update(@body widget: Widget): Widget | (ConflictResponse & Error) | Error;\r\n```\n\n### Response Object\n\n| Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\r\nthen `content` will have one entry for each value.\r\n\r\nTo get multiple `content` entries with different schemas, use a union type.\r\n\r\n```typespec\r\n@tag(\"Response Content\")\r\n@route(\"/response-content\")\r\nnamespace ResponseContent {\r\n  @get op read(@path id: string): Widget | {\r\n    @header contentType: \"text/html\";\r\n    @body _: string;\r\n  } | {\r\n    @header contentType: \"image/jpeg\";\r\n    @body _: bytes;\r\n  };\r\n}\r\n```\n\nIn OpenAPI, a response object [[v2][v2-response], [v3][v3-response]] describes a single response for an operation.\r\nThe structure of the response object changed significantly from OpenAPI v2 to OpenAPI v3, but there are many\r\nelements common to both.\r\n\r\n[v2-response]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#response-object\r\n[v3-response]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#response-object\r\n\r\nThe fields in an OpenAPI response object are specified with the following TypeSpec constructs:\r\n\r\n| OpenAPI `response` field | TypeSpec construct                                  | Notes                                               |\r\n| ------------------------ | --------------------------------------------------- | --------------------------------------------------- |\r\n| `description`            | `@doc` decorator                                    |                                                     |\r\n| `headers`                | fields in the return type with `@header` decorator  | Required or optional based on optionality of field. |\r\n| `schema` (OAS2)          | return type or type of `@body`` property            |                                                     |\r\n| `content` (OAS3)         | return type or type of `@body`` property            |                                                     |\r\n| `examples` (OAS3)        | `@opExample` to describe return types of operations | Supported on an operation.                          |\r\n| `links` (OAS3)           |                                                     | Not currently supported.                            |\r\n\r\n```typespec\r\n@get op read(@path id: string): {\r\n  /** the widget */\r\n  @body\r\n  widget: Widget;\r\n\r\n  @header xRateLimitRemaining: int32;\r\n  @header xRateLimitReset: int32;\r\n};\r\n```\r\n\r\nThe media type of the request body is specified with a `content-type` header. If `content-type` has multiple values\n\n## Schema Object\n\nOpenAPI schemas are represented in TypeSpec by [models](https://typespec.io/docs/language-basics/models/).\r\nModels have any number of members and can extend and be composed with other models.\r\n\r\nModels can be defined with the `model` statement and then referenced by name, which generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nTypeSpec supports the [\"spread\" operator](https://typespec.io/docs/language-basics/models/#spread) (`...`), which copies the members of the source model into the target model.\r\nBut TypeSpec processes all spread transformations before emitters are invoked, so this form of reuse is not represented in the emitted OpenAPI.\r\n\r\nThe spread operation is useful if you want one or more properties to be present in several different models but in a standard fashion. For example:\r\n\r\n```typespec\r\nmodel Legs {\r\n  /** number of legs */\r\n  legs: int32;\r\n}\r\n\r\nmodel Dog {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Cat {\r\n  name: string;\r\n  ...Legs;\r\n}\r\n\r\nmodel Snake {\r\n  name: string;\r\n  // snakes have no legs\r\n}\r\n```\n\n### additionalProperties/unevaluatedProperties\n\nYou can generate a schema with `additionalProperties` with the TypeSpec `Record` construct.\r\n\r\n**Note:** `unevaluatedProperties` is used instead of `additionalProperties` when emitting Open API 3.1 specs.\r\n\r\n```typespec\r\n  bar: Record<unknown>;\r\n```\r\n\r\nis produced as\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties: {}\r\n```\r\n\r\nTo get a schema having both `properties` and `additionalProperties`, define a model that extends `Record<unknown>`.\r\n\r\n```typespec\r\nmodel Bar extends Record<unknown> {\r\n  bar?: string;\r\n}\r\n```\r\n\r\nproduces\r\n\r\n```yaml title=openapi.yaml\r\nBar:\r\n  type: object\r\n  properties:\r\n    bar:\r\n      type: string\r\n  additionalProperties: {}\r\n```\r\n\r\nTo define a schema with `additionalProperties` that has a specific type, use the `Record` construct with a type parameter.\r\n\r\n```typespec\r\n  bar: Record<string>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    type: string\r\n```\r\n\r\nTo define a schema that **does not** allow any additional properties, use `Record<never>`.\r\n\r\n```typespec\r\n  bar: Record<never>;\r\n```\r\n\r\nresults in\r\n\r\n```yaml title=openapi.yaml\r\nbar:\r\n  type: object\r\n  additionalProperties:\r\n    not: {}\r\n```\r\n\r\nIn the openapi3 emitter, schemas that don't define `additionalProperties` can automatically be set to `additionalProperties: { not: {} }` by setting the `seal-object-schemas` emitter option to `true`. This will not add `additionalProperties` to object schemas that are referenced in an `allOf` of another schema.\n\n### allOf and polymorphism using allOf\n\nTypeSpec supports single inheritance of models with the `extends` keyword. This construct can be used to produce an `allOf` with a single element (the parent schema) in OpenAPI. For example:\r\n\r\n```typespec title=main.tsp\r\nmodel Pet {\r\n  name: string;\r\n}\r\n\r\nmodel Cat extends Pet {\r\n  meow: int32;\r\n}\r\n\r\nmodel Dog extends Pet {\r\n  bark: string;\r\n}\r\n```\r\n\r\nTypeSpec does not currently provide a means to produce an `allOf` with more than one element -- these are generally treated as \"composition\" in code generators and thus better represented in TypeSpec with the spread operator.\r\n\r\nModels with a `@discriminator` decorator can be extended to produce polymorphic schemas in either OpenAPI v2 or v3 using `allOf`.\r\nThis schema produced for the base model will be defined with a `discriminator` property and schemas for the child models will `allOf` the base schema and add additional properties.\r\n\r\nFor example:\r\n\r\n```typespec\r\n@discriminator(\"kind\")\r\nmodel Pet {\r\n  name: string;\r\n  weight?: float32;\r\n}\r\nmodel Cat extends Pet {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog extends Pet {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates:\r\n\r\n```yaml title=openapi.yaml\r\nCat:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - cat\r\n    meow:\r\n      type: integer\r\n      format: int32\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nDog:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      enum:\r\n        - dog\r\n    bark:\r\n      type: string\r\n  required:\r\n    - kind\r\n  allOf:\r\n    - $ref: \"#/components/schemas/Pet\"\r\nPet:\r\n  type: object\r\n  properties:\r\n    kind:\r\n      type: string\r\n      description: Discriminator property for Pet.\r\n    name:\r\n      type: string\r\n    weight:\r\n      type: number\r\n      format: float\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n  required:\r\n    - name\r\n```\n\n### Polymorphism using anyOf and oneOf (OAS3)\n\nPolymorphism can also be represented in OpenAPI v3 with `anyOf` or `oneOf` constructs.\r\nThese can be represented in TypeSpec with a union type.\r\n\r\n```typespec\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n\r\nmodel Cat {\r\n  meow?: int32;\r\n}\r\n\r\nmodel Dog {\r\n  bark?: string;\r\n}\r\n```\r\n\r\ngenerates a Pet schema with `anyOf`.\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  anyOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nThe openapi emitter uses `anyOf` by default because the schemas may not be mutually exclusive.\r\nBut the `@oneOf` decorator of the OpenAPI library can be used to force the use of `oneOf` instead.\r\n\r\n```typespec\r\nimport \"@typespec/openapi3\";\r\nusing OpenAPI;\r\n\r\n@oneOf\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\n```\r\n\r\nproduces:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n```\r\n\r\nTo make Pet a discriminated union, add the `@discriminator` decorator and add the discriminator property\r\nwith a string literal value to each of the child schemas.\r\nView the [`@discriminated` documentation](https://typespec.io/docs/standard-library/built-in-decorators/#@discriminated) to learn how to further customize what is emitted.\r\n\r\n```typespec\r\n@discriminated(#{ envelope: \"none\" })\r\nunion Pet {\r\n  cat: Cat,\r\n  dog: Dog,\r\n}\r\nmodel Cat {\r\n  kind: \"cat\";\r\n  meow?: int32;\r\n}\r\nmodel Dog {\r\n  kind: \"dog\";\r\n  bark?: string;\r\n}\r\n```\r\n\r\nresults in the following schema for Pet:\r\n\r\n```yaml title=openapi.yaml\r\nPet:\r\n  oneOf:\r\n    - $ref: \"#/components/schemas/Cat\"\r\n    - $ref: \"#/components/schemas/Dog\"\r\n  discriminator:\r\n    propertyName: kind\r\n    mapping:\r\n      cat: \"#/components/schemas/Cat\"\r\n      dog: \"#/components/schemas/Dog\"\r\n```\n\n## definitions / components\n\nOpenAPI supports reuse of schemas, parameters, responses, and other elements with the `definitions` (OAS2) or `components` (OAS3) section of an OpenAPI definition.\r\n\r\nReferencing a model by name (not with \"spread\"), as an `op` parameter or return type or as the type of a property in another model, generally results in a `$ref` to a schema for the model in the `definitions` or `components.schemas` section of the OpenAPI document.\r\n\r\nReusable parameters can be defined as members of a model and then incorporated into an operation parameter list using the spread operator. For example:\r\n\r\n```typespec\r\nmodel PetId {\r\n  @path petId: int32;\r\n}\r\n\r\nnamespace Pets {\r\n  op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nresults in a `$ref` to the named parameter `PetId` in either `parameters` or `components.parameters`.\n\n## Info Object\n\nIn OpenAPI, the `info` object [[v2][v2-info], [v3][v3-info]] contains metadata about the API such as a `title`, `description`, `license`, and `version`.\r\n\r\n[v2-info]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#info-object\r\n[v3-info]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#info-object\r\n\r\nIn TypeSpec this information is specified with [decorators on the namespace][typespec-service-metadata].\r\n\r\n| OpenAPI `info` field | TypeSpec decorator    | Notes                       |\r\n| -------------------- | --------------------- | --------------------------- |\r\n| `title`              | `@service(#{title: }` | TypeSpec built-in decorator |\r\n| `description`        | `@doc`                | TypeSpec built-in decorator |\r\n| `version`            | `@info`               |                             |\r\n| `license`            | `@info`               |                             |\r\n| `contact`            | `@info`               |                             |\r\n\r\n[typespec-service-metadata]: https://typespec.io/docs/libraries/http/reference/decorators/\r\n\r\n```typespec\r\n/** The Contoso Widget Service provides access to the Contoso Widget API. */\r\n@service(#{ title: \"Widget Service\" })\r\n@info(#{\r\n  contact: #{ name: \"API Support\", email: \"contact@contoso.com\" },\r\n  license: #{ name: \"Apache 2.0\", url: \"https://www.apache.org/licenses/LICENSE-2.0.html\" },\r\n})\r\nnamespace DemoService;\r\n```\n\n## Consumes / Produces (OAS2)\n\nIn OpenAPI v2, the top-level `consumes` and `produces` fields specify a list of MIME types an operation can consume / produce\r\nwhen not overridden by a `consumes` or `produces` on an individual operation.\r\n\r\nThe typespec-autorest emitter previously supported `@produces` and `@consumes` decorators on a namespace, but these are deprecated\r\nin favor of explicit `content-type` and `accept` header properties in request and response bodies.\n\n## securityDefinitions / securitySchemes Object\n\nUse the `@useAuth` decorator from the `@typespec/rest\" library\r\n\r\n```typespec\r\nusing Http;\r\n@useAuth(OAuth2Auth<[\"read\", \"write\"]>)\r\nnamespace MyService;\r\n```\n\n## Specification Extensions\n\nYou can add arbitrary specification extensions (\"x-\" properties) to a model or an operation with the `@extension` decorator.\r\nFor example:\r\n\r\n```typespec\r\nnamespace Pets {\r\n  @extension(\"x-streaming-operation\", true) op read(...PetId): Pet | Error;\r\n}\r\n```\r\n\r\nOpenAPI decorators that map directly to an object in the openapi document also allow to provide extension.\r\n\r\n`@tagMetadata`\r\n\r\n```tsp\r\n@tagMetadata(\"my-tag\", #{\r\n  description: \"My tag\",\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\r\n\r\n- `@info`\r\n\r\n```tsp\r\n@info(#{\r\n  version: 1.1.0,\r\n  `x-custom`: \"custom value\",\r\n})\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: libraries#http#reference#decorators.md\n- document_title: Decorators\n- document_link: https://typespec.io/docs/libraries/http/reference/decorators\n- document_content: # libraries#http#reference#decorators.md\n\n# Decorators\n\n## TypeSpec.Http\n\n### `@body` {#@TypeSpec.Http.body}\n\nExplicitly specify that this property type will be exactly the HTTP body.\r\n\r\nThis means that any properties under `@body` cannot be marked as headers, query parameters, or path parameters.\r\nIf wanting to change the resolution of the body but still mix parameters, use `@bodyRoot`.\r\n\r\n```typespec\r\n@TypeSpec.Http.body\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(@body image: bytes): void;\r\nop download(): {\r\n  @body image: bytes;\r\n};\r\n```\n\n### `@bodyIgnore` {#@TypeSpec.Http.bodyIgnore}\n\nSpecify that this property shouldn't be included in the HTTP body.\r\nThis can be useful when bundling metadata together that would result in an empty property to be included in the body.\r\n\r\n```typespec\r\n@TypeSpec.Http.bodyIgnore\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(\r\n  name: string,\r\n  @bodyIgnore headers: {\r\n    @header id: string;\r\n  },\r\n): void;\r\n```\n\n### `@bodyRoot` {#@TypeSpec.Http.bodyRoot}\n\nSpecify that the body resolution should be resolved from that property.\r\nBy default the body is resolved by including all properties in the operation request/response that are not metadata.\r\nThis allows to nest the body in a property while still allowing to use headers, query parameters, and path parameters in the same model.\r\n\r\n```typespec\r\n@TypeSpec.Http.bodyRoot\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop upload(\r\n  @bodyRoot user: {\r\n    name: string;\r\n    @header id: string;\r\n  },\r\n): void;\r\nop download(): {\r\n  @bodyRoot user: {\r\n    name: string;\r\n    @header id: string;\r\n  };\r\n};\r\n```\n\n### `@cookie` {#@TypeSpec.Http.cookie}\n\nSpecify this property is to be sent or received in the cookie.\r\n\r\n```typespec\r\n@TypeSpec.Http.cookie(cookieNameOrOptions?: valueof string | TypeSpec.Http.CookieOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name                | Type                                            | Description                                                                                                                                                                                       |\r\n| ------------------- | ----------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| cookieNameOrOptions | `valueof string \\| TypeSpec.Http.CookieOptions` | Optional name of the cookie in the cookie or cookie options.<br />By default the cookie name will be the property name converted from camelCase to snake_case. (e.g. `authToken` -> `auth_token`) |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(@cookie token: string): {\r\n  data: string[];\r\n};\r\nop create(\r\n  @cookie({\r\n    name: \"auth_token\",\r\n  })\r\n  data: string[],\r\n): void;\r\n```\r\n\r\n##### Implicit header name\r\n\r\n```typespec\r\nop read(): {\r\n  @cookie authToken: string;\r\n}; // headerName: auth_token\r\nop update(@cookie AuthToken: string): void; // headerName: auth_token\r\n```\n\n### `@delete` {#@TypeSpec.Http.delete}\n\nSpecify the HTTP verb for the target operation to be `DELETE`.\r\n\r\n```typespec\r\n@TypeSpec.Http.delete\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@delete op set(petId: string): void;\r\n```\n\n### `@get` {#@TypeSpec.Http.get}\n\nSpecify the HTTP verb for the target operation to be `GET`.\r\n\r\n```typespec\r\n@TypeSpec.Http.get\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@get op read(): string;\r\n```\n\n### `@head` {#@TypeSpec.Http.head}\n\nSpecify the HTTP verb for the target operation to be `HEAD`.\r\n\r\n```typespec\r\n@TypeSpec.Http.head\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@head op ping(petId: string): void;\r\n```\n\n### `@header` {#@TypeSpec.Http.header}\n\nSpecify this property is to be sent or received as an HTTP header.\r\n\r\n```typespec\r\n@TypeSpec.Http.header(headerNameOrOptions?: valueof string | TypeSpec.Http.HeaderOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name                | Type                                            | Description                                                                                                                                                                                                 |\r\n| ------------------- | ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| headerNameOrOptions | `valueof string \\| TypeSpec.Http.HeaderOptions` | Optional name of the header when sent over HTTP or header options.<br />By default the header name will be the property name converted from camelCase to kebab-case. (e.g. `contentType` -> `content-type`) |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(@header accept: string): {\r\n  @header(\"ETag\") eTag: string;\r\n};\r\nop create(\r\n  @header({\r\n    name: \"X-Color\",\r\n    format: \"csv\",\r\n  })\r\n  colors: string[],\r\n): void;\r\n```\r\n\r\n##### Implicit header name\r\n\r\n```typespec\r\nop read(): {\r\n  @header contentType: string;\r\n}; // headerName: content-type\r\nop update(@header ifMatch: string): void; // headerName: if-match\r\n```\n\n### `@multipartBody` {#@TypeSpec.Http.multipartBody}\n\n```typespec\r\n@TypeSpec.Http.multipartBody\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```tsp\r\nop upload(\r\n  @header `content-type`: \"multipart/form-data\",\r\n  @multipartBody body: {\r\n    fullName: HttpPart<string>;\r\n    headShots: HttpPart<Image>[];\r\n  },\r\n): void;\r\n```\n\n### `@patch` {#@TypeSpec.Http.patch}\n\nSpecify the HTTP verb for the target operation to be `PATCH`.\r\n\r\n```typespec\r\n@TypeSpec.Http.patch(options?: valueof TypeSpec.Http.PatchOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\n| Name    | Type                                                                 | Description                      |\r\n| ------- | -------------------------------------------------------------------- | -------------------------------- |\r\n| options | [valueof `PatchOptions`](./data-types.md#TypeSpec.Http.PatchOptions) | Options for the PATCH operation. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@patch op update(pet: Pet): void;\r\n```\r\n\r\n```typespec\r\n// Disable implicit optionality, making the body of the PATCH operation use the\r\n// optionality as defined in the `Pet` model.\r\n@patch(#{ implicitOptionality: false })\r\nop update(pet: Pet): void;\r\n```\n\n### `@path` {#@TypeSpec.Http.path}\n\nExplicitly specify that this property is to be interpolated as a path parameter.\r\n\r\n```typespec\r\n@TypeSpec.Http.path(paramNameOrOptions?: valueof string | TypeSpec.Http.PathOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name               | Type                                          | Description                                                    |\r\n| ------------------ | --------------------------------------------- | -------------------------------------------------------------- |\r\n| paramNameOrOptions | `valueof string \\| TypeSpec.Http.PathOptions` | Optional name of the parameter in the uri template or options. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@route(\"/read/{explicit}/things/{implicit}\")\r\nop read(@path explicit: string, implicit: string): void;\r\n```\n\n### `@post` {#@TypeSpec.Http.post}\n\nSpecify the HTTP verb for the target operation to be `POST`.\r\n\r\n```typespec\r\n@TypeSpec.Http.post\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@post op create(pet: Pet): void;\r\n```\n\n### `@put` {#@TypeSpec.Http.put}\n\nSpecify the HTTP verb for the target operation to be `PUT`.\r\n\r\n```typespec\r\n@TypeSpec.Http.put\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@put op set(pet: Pet): void;\r\n```\n\n### `@query` {#@TypeSpec.Http.query}\n\nSpecify this property is to be sent as a query parameter.\r\n\r\n```typespec\r\n@TypeSpec.Http.query(queryNameOrOptions?: valueof string | TypeSpec.Http.QueryOptions)\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\n| Name               | Type                                           | Description                                                                     |\r\n| ------------------ | ---------------------------------------------- | ------------------------------------------------------------------------------- |\r\n| queryNameOrOptions | `valueof string \\| TypeSpec.Http.QueryOptions` | Optional name of the query when included in the url or query parameter options. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(@query select: string, @query(\"order-by\") orderBy: string): void;\r\nop list(@query(#{ name: \"id\", explode: true }) ids: string[]): void;\r\n```\n\n### `@route` {#@TypeSpec.Http.route}\n\nDefines the relative route URI template for the target operation as defined by [RFC 6570](https://datatracker.ietf.org/doc/html/rfc6570#section-3.2.3)\r\n\r\n`@route` can only be applied to operations, namespaces, and interfaces.\r\n\r\n```typespec\r\n@TypeSpec.Http.route(path: valueof string)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n\r\n| Name | Type             | Description |\r\n| ---- | ---------------- | ----------- |\r\n| path | `valueof string` |             |\r\n\r\n#### Examples\r\n\r\n##### Simple path parameter\r\n\r\n```typespec\r\n@route(\"/widgets/{id}\") op getWidget(@path id: string): Widget;\r\n```\r\n\r\n##### Reserved characters\r\n\r\n```typespec\r\n@route(\"/files{+path}\") op getFile(@path path: string): bytes;\r\n```\r\n\r\n##### Query parameter\r\n\r\n```typespec\r\n@route(\"/files\") op list(select?: string, filter?: string): Files[];\r\n@route(\"/files{?select,filter}\") op listFullUriTemplate(select?: string, filter?: string): Files[];\r\n```\n\n### `@server` {#@TypeSpec.Http.server}\n\nSpecify an endpoint for this service. Multiple `@server` decorators can be used to specify multiple endpoints.\r\n\r\n```typespec\r\n@TypeSpec.Http.server(url: valueof string, description?: valueof string, parameters?: Record<unknown>)\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace`\r\n\r\n#### Parameters\r\n\r\n| Name        | Type              | Description                                             |\r\n| ----------- | ----------------- | ------------------------------------------------------- |\r\n| url         | `valueof string`  | Server endpoint                                         |\r\n| description | `valueof string`  | Description of the endpoint                             |\r\n| parameters  | `Record<unknown>` | Optional set of parameters used to interpolate the url. |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\n@server(\"https://example.com\")\r\nnamespace PetStore;\r\n```\r\n\r\n##### With a description\r\n\r\n```typespec\r\n@service\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\nnamespace PetStore;\r\n```\r\n\r\n##### Parameterized\r\n\r\n```typespec\r\n@server(\"https://{region}.foo.com\", \"Regional endpoint\", {\r\n  @doc(\"Region name\")\r\n  region?: string = \"westus\",\r\n})\r\n```\r\n\r\n##### Multiple\r\n\r\n```typespec\r\n@service\r\n@server(\"https://example.com\", \"Standard endpoint\")\r\n@server(\r\n  \"https://{project}.private.example.com\",\r\n  \"Private project endpoint\",\r\n  {\r\n    project: string,\r\n  }\r\n)\r\nnamespace PetStore;\r\n```\n\n### `@sharedRoute` {#@TypeSpec.Http.sharedRoute}\n\n`@sharedRoute` marks the operation as sharing a route path with other operations.\r\n\r\nWhen an operation is marked with `@sharedRoute`, it enables other operations to share the same\r\nroute path as long as those operations are also marked with `@sharedRoute`.\r\n\r\n`@sharedRoute` can only be applied directly to operations.\r\n\r\n```typespec\r\n@sharedRoute\r\n@route(\"/widgets\")\r\nop getWidget(@path id: string): Widget;\r\n```\r\n\r\n```typespec\r\n@TypeSpec.Http.sharedRoute\r\n```\r\n\r\n#### Target\r\n\r\n`Operation`\r\n\r\n#### Parameters\r\n\r\nNone\n\n### `@statusCode` {#@TypeSpec.Http.statusCode}\n\nSpecify the status code for this response. Property type must be a status code integer or a union of status code integer.\r\n\r\n```typespec\r\n@TypeSpec.Http.statusCode\r\n```\r\n\r\n#### Target\r\n\r\n`ModelProperty`\r\n\r\n#### Parameters\r\n\r\nNone\r\n\r\n#### Examples\r\n\r\n```typespec\r\nop read(): {\r\n  @statusCode _: 200;\r\n  @body pet: Pet;\r\n};\r\nop create(): {\r\n  @statusCode _: 201 | 202;\r\n};\r\n```\n\n### `@useAuth` {#@TypeSpec.Http.useAuth}\n\nSpecify authentication for a whole service or specific methods. See the [documentation in the Http library](https://typespec.io/docs/libraries/http/authentication) for full details.\r\n\r\n```typespec\r\n@TypeSpec.Http.useAuth(auth: {} | Union | {}[])\r\n```\r\n\r\n#### Target\r\n\r\n`Namespace | Interface | Operation`\r\n\r\n#### Parameters\r\n\r\n| Name | Type                  | Description                                                                                                                                                     |\r\n| ---- | --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\r\n| auth | `{} \\| Union \\| {}[]` | Authentication configuration. Can be a single security scheme, a union(either option is valid authentication) or a tuple (must use all authentication together) |\r\n\r\n#### Examples\r\n\r\n```typespec\r\n@service\r\n@useAuth(BasicAuth)\r\nnamespace PetStore;\r\n```\n-------------------------\n- document_dir: typespec_azure_docs\n- document_filename: howtos#generate-client-libraries#99tcgctypes.mdx\n- document_title: TypeSpec Type Representation in TCGC\n- document_link: https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/99tcgctypes\n- document_content: # howtos#generate-client-libraries#99tcgctypes.mdx\n\n# TypeSpec Type Representation in TCGC\n\nimport { ClientTabs, ClientTabItem } from \"@components/client-tabs\";\r\n\r\nThis page documents what type definitions in TypeSpec would look like when returned by TCGC\n\n## Main TypeSpec Code Example\n\n```typespec\r\nimport \"@typespec/http\";\r\n\r\nusing Http;\r\n\r\n@useAuth(ApiKeyAuth<ApiKeyLocation.header, \"api-key\">)\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@server(\r\n  \"{endpoint}/widget\",\r\n  \"Contoso Widget APIs\",\r\n  {\r\n    endpoint: string,\r\n  }\r\n)\r\nnamespace Contoso.WidgetManager;\r\n\r\nmodel Widget {\r\n  @visibility(Lifecycle.Read, Lifecycle.Update)\r\n  @path\r\n  id: string;\r\n\r\n  weight: int32;\r\n  color: \"red\" | \"blue\";\r\n}\r\n\r\n@error\r\nmodel Error {\r\n  code: int32;\r\n  message: string;\r\n}\r\n\r\n@route(\"/widgets\")\r\n@tag(\"Widgets\")\r\ninterface Widgets {\r\n  @get list(): Widget[] | Error;\r\n  @get read(@path id: string): Widget | Error;\r\n  @post create(...Widget): Widget | Error;\r\n  @patch update(...Widget): Widget | Error;\r\n  @delete delete(@path id: string): void | Error;\r\n  @route(\"{id}/analyze\") @post analyze(@path id: string): string | Error;\r\n}\r\n```\n\n## SdkClientType\n\nAn `SdkClientType` represents a single client in your package.\r\n\r\nAll clients will have an `initialization` property. Whether that property's access is `internal` or `public` will determine whether your client can be publicly instantiated or not.\n\n### Interface\n\n```ts\r\nexport interface SdkClientType<TServiceOperation extends SdkServiceOperation> {\r\n  name: string;\r\n  kind: \"client\";\r\n  description?: string;\r\n  details?: string;\r\n  initialization: SdkInitializationType;\r\n  apiVersions: string[];\r\n  // fully qualified. Compare to sdkPackage.rootNamespace to figure out where to generate\r\n  nameSpace: string;\r\n  methods: SdkMethod<TServiceOperation>[];\r\n}\r\n```\n\n### Example\n\n```ts\r\nconst sdkClient = {\r\n  name: \"ContosoWidgetManagerClient\";\r\n  kind: \"client\";\r\n  initialization: {\r\n    name: \"WidgetManagerOptions\",\r\n    kind: \"model\",\r\n    access: \"public\",\r\n    ...\r\n  };\r\n  apiVersions: [],\r\n  nameSpace: \"Contoso.WidgetManager\",\r\n  methods: [\r\n    {\r\n      name: \"getWidgets\",\r\n      kind: \"clientaccessor\",\r\n      response: {\r\n        name: \"Widgets\",\r\n        kind: \"client\",\r\n        initialization: {\r\n          kind: \"model\",\r\n          access: \"internal\",\r\n        },\r\n        apiVersions: [],\r\n        nameSpace: \"Contoso.WidgetManager\",\r\n        methods: [\r\n          {\r\n            name: \"list\",\r\n            kind: \"method\",\r\n            ...\r\n          },\r\n          {\r\n            name: \"read\",\r\n            kind: \"method\",\r\n            ...\r\n          }\r\n        ]\r\n      }\r\n    }\r\n  ],\r\n}\r\n```\n\n### Usage\n\n```ts\r\nimport { SdkClientType } from \"@azure-tools/typespec-client-generator-core\";\r\nimport { PythonSdkServiceOperation } from \"./interfaces.js\";\r\nimport { get }\r\n\r\nconst serializedClients: PythonSdkClientType[] = [];\r\n\r\nfunction serializeClient<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  sdkContext: PythonSdkContext<TServiceOperation>,\r\n  client: SdkClientType<TServiceOperation>,\r\n): PythonSdkClientType {\r\n  // Map the information from the SdkClientType to your language's interface for a client.\r\n  // Would recommend that eventually your language's client type interface extends from\r\n  // SdkClientType, and just adds your language-specific information on top.\r\n  const pythonClient = {\r\n    ...client,\r\n    parameters: (client.initialization.properties.map(\r\n        (x) => getSdkModelPropertyType(\r\n          context, x\r\n        )\r\n      ) : undefined\r\n    ),\r\n    methods: client.methods.filter(\r\n      (x) => x.kind ===  \"method\"\r\n    ).map(\r\n      (x) => serializeServiceMethod(sdkContext, x)\r\n    ),\r\n    subclients: [],\r\n  }\r\n  sdkContext.ClientMap.set(client, pythonClient)\r\n  return pythonClient\r\n}\r\n\r\nfor (const client of sdkPackage.clients) {\r\n  serializedClients.push(serializeClient(sdkContext, client));\r\n}\r\n```\n\n## SdkInitializationType\n\nInitialization model for a client. Whether it's `access` is `public` or `internal` tells you whether the client is publicly instantiable.\n\n### Interface\n\n```ts\r\nexport interface SdkInitializationType extends SdkModelType {\r\n  // properties takes care of all of the initialization info that you will need.\r\n  properties: (SdkEndpointParameter | SdkCredentialParameter | SdkMethodParameter)[];\r\n}\r\n```\n\n### Example\n\n```ts\r\nconst sdkInitializationType = {\r\n  name: \"WidgetManagerOptions\",\r\n  kind: \"model\",\r\n  properties: [\r\n    {\r\n      kind: \"endpoint\",\r\n      serverUrl: \"{endpoint}/widget\",\r\n      templateArguments: [\r\n        {\r\n          kind: \"path\",\r\n          name: \"endpoint\",\r\n          type: {\r\n            kind: \"string\",\r\n          },\r\n        },\r\n      ],\r\n    },\r\n    {\r\n      kind: \"credential\",\r\n      type: {\r\n        kind: \"credential\",\r\n        scheme: {\r\n          kind: \"apiKey\",\r\n          in: \"header\",\r\n          name: \"api-key\",\r\n        },\r\n      },\r\n      onClient: true,\r\n    },\r\n  ],\r\n  crossLanguageDefinitionId: \"Contoso.WidgetManager.WidgetManagerOptions\",\r\n  apiVersions: [],\r\n  usage: UsageFlags.Input,\r\n  access: \"public\",\r\n  isFormDataType: false,\r\n  isError: false,\r\n};\r\n```\n\n### Usage\n\nThe usage of this property is more language-dependent.\r\n\r\nSome emitters will create a model and have the client accept the model as options to initialize your client. Others will flatten out the parameters and accept them individually as parameter input.\n\n## SdkMethod\n\nAn `SdkMethod` is any of the types of methods that can be a method on a client.\r\n\r\nThere are two main types of an `SdkMethod`:\r\n\r\n1. `SdkClientAccessor` returns a subclient of the client it's on\r\n2. `SdkServiceMethod` wraps a service call\r\n\r\n```ts\r\nexport type SdkMethod<TServiceOperation extends PythonSdkServiceOperation> =\r\n  | SdkServiceMethod<TServiceOperation>\r\n  | SdkClientAccessor<TServiceOperation>;\r\n```\r\n\r\nThey each extend from the shared `SdkMethodBase`\r\n\r\n```ts\r\ninterface SdkMethodBase<TServiceOperation extends SdkServiceOperation> {\r\n  __raw?: Operation;\r\n  name: string;\r\n  access: AccessFlags;\r\n  parameters: SdkParameter[];\r\n  apiVersions: string[];\r\n  description?: string;\r\n  details?: string;\r\n}\r\n```\r\n\r\nBelow we go into each method type\n\n### SdkClientAccessor\n\nA `clientaccessor` method is simply a method on a client that returns another client. The returned client can be instantiable or un-instantiable. If the returned client is instantiable, most likely your `clientaccessor` will be part of the public api surface, so users can instantiate the subclient using your client method. If it is not instantiable, it is up to you how to expose the subclient on your current client for users to access.\r\n\r\n#### Interface\r\n\r\n```ts\r\ninterface SdkClientAccessor<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkMethodBase<TServiceOperation> {\r\n  kind: \"clientaccessor\";\r\n  response: SdkClientType<TServiceOperation>;\r\n}\r\n```\r\n\r\n#### Example\r\n\r\n```ts\r\nconst sdkClientAccessor = {\r\n  name: \"getWidgets\",\r\n  kind: \"clientaccessor\",\r\n  response: {\r\n    name: \"Widgets\",\r\n    kind: \"client\",\r\n    initialization: undefined,\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\n#### Usage\r\n\r\nOur strong recommendation is you build up a list of clients by iterating through `sdkPackage.clients` first, and to _not_ recurse into creating the subclients.\r\nOnly once you've processed each client, then you go through and link clients to their subclients. Not doing recursion prevents confusion over where you are in the call chain.\r\n\r\n```ts\r\nimport { SdkServiceOperation, SdkClientType } from \"@azure-tools/typespec-client-generator-core\";\r\nimport { PythonSdkContext } from \"./lib.js\";\r\nimport { PythonSdkClientType } from \"./interfaces.js\";\r\n\r\nfunction linkSubClients<TServiceOperation extends PythonSdkServiceOperation>(\r\n  sdkContext: PythonSdkContext<TServiceOperation>,\r\n): void {\r\n  for (const client of sdkContext.clients) {\r\n    client.subclients = client.methods\r\n      .filter((x) => x.kind === \"clientaccessor\")\r\n      .map((x) => x.returnType)\r\n      .map((x) => sdkContext.ClientMap.get(x));\r\n  }\r\n}\r\n```\n\n### SdkServiceMethod\n\n\"lropaging\";\r\n  __raw_lro_metadata: LroMetadata;\r\n  // initial call to start LRO\r\n  operation: SdkServiceOperation;\r\n  __raw_paged_metadata: PagedResultMetadata;\r\n  nextLinkPath?: string; // off means fake paging\r\n  nextLinkOperation?: SdkServiceOperation;\r\n}\r\n```\r\n\r\n##### Usage\r\n\r\n```ts\r\nfunction serializeLroPagingServiceMethod<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkLroPagingServiceMethod<TServiceOperation>,\r\n): PythonSdkLroPagingServiceMethod<TServiceOperation> {\r\n  return {\r\n    ...method,\r\n    name: camelToSnakeCase(method.name),\r\n    operation: serializeServiceOperation(context, method, method.operation),\r\n    nextLinkOperation: method.nextLinkOperation ? serializeServiceOperation(context, method, method.nextLinkOperation) : undefined,\r\n  },\r\n}\r\n```\n\n// Widget Operations\r\n/** Creates or updates a Widget asynchronously */\r\n@pollingOperation(getWidgetOperationStatus)\r\ncreateOrUpdateWidget is Operations.LongRunningResourceCreateOrUpdate<Widget>;\r\n```\r\n\r\n```ts\r\nconst sdkLroServiceMethod = {\r\n  kind: \"lro\",\r\n  __raw?: {\r\n    // Original Tsp Operation type\r\n    kind: \"Operation\",\r\n  },\r\n  __raw_lro_metadata: {\r\n    // Raw output from getLroMetadata\r\n  }\r\n  name: \"createOrUpdateWidget\",\r\n  access: \"public\",\r\n  apiVersions: [],\r\n  parameters: [],\r\n  operation: {\r\n    kind: \"http\",\r\n    ...\r\n  },\r\n  response: {\r\n    kind: \"method\",\r\n    type: {\r\n      kind: \"model\",\r\n      name: \"Widget\",\r\n    }\r\n  },\r\n}\r\n```\r\n\r\n##### Usage\r\n\r\n```ts\r\nfunction serializeLroServiceMethod<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkLroServiceMethod<TServiceOperation>,\r\n): PythonSdkLroServiceMethod<TServiceOperation> {\r\n  return {\r\n    ...method,\r\n    name: camelToSnakeCase(method.name),\r\n    operation: serializeServiceOperation(context, method),\r\n  },\r\n}\r\n```\r\n\r\n#### SdkLroPagingServiceMethod\r\n\r\nThis is a combination of Lro and paging. We start off with an LRO call to the service, and then the response is returned to us in pages. Also only available for azure-sdks.\r\n\r\n##### Interface\r\n\r\n```ts\r\nexport interface SdkLroPagingServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"lropaging\";\r\n  __raw_lro_metadata: LroMetadata;\r\n  // initial call to start LRO\r\n  operation: SdkServiceOperation;\r\n  __raw_paged_metadata: PagedResultMetadata;\r\n  nextLinkPath?: string; // off means fake paging\r\n  nextLinkOperation?: SdkServiceOperation;\r\n}\r\n```\r\n\r\n##### Usage\r\n\r\n```ts\r\nfunction serializeLroPagingServiceMethod<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkLroPagingServiceMethod<TServiceOperation>,\n\nAn `SdkServiceMethod` is any service method on a client that calls the service.\r\n\r\nThe actual service call is a separate property on the method, `.operation`. This way, our service methods are able to abstract away the protocol used to call the service (i.e. `http` or `gRPC`)\r\n\r\nAll `SdkServiceMethod`s share the following base:\r\n\r\n```ts\r\ninterface SdkServiceMethodBase<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkMethodBase<TServiceOperation> {\r\n  // This represents the operation request we need to send to the service.\r\n  // This helps abstract away the transport\r\n  operation: TServiceOperation;\r\n  // The parameters you generate on the method signature that users will interact with.\r\n  // These aren't tied to any protocol, so there are no 'header' / 'path' parameters etc.\r\n  parameters: SdkMethodParameter[];\r\n  response: SdkMethodResponse;\r\n  exception?: SdkMethodResponse;\r\n}\r\n```\r\n\r\n```ts\r\nfunction serializeServiceMethod<TServiceOperation extends PythonSdkServiceOperation>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkServiceMethod<TServiceOperation>,\r\n): PythonSdkServiceMethod {\r\n  switch (method.kind) {\r\n    case \"basic\":\r\n      return serializeBasicServiceMethod(context, method);\r\n    case \"paging\":\r\n      return serializePagingServiceMethod(context, method);\r\n    case \"lro\":\r\n      return serializeLroServiceMethod(context, method);\r\n    case \"lropaging\":\r\n      return serializeLroPagingServiceMethod(context, method);\r\n  }\r\n}\r\n```\r\n\r\n#### SdkBasicServiceMethod\r\n\r\nThis models a basic service call that is synchronous server side.\r\n\r\n##### Interface\r\n\r\n```ts\r\nexport interface SdkBasicServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"basic\";\r\n}\r\n```\r\n\r\n##### Example\r\n\r\n```ts\r\nconst sdkBasicServiceMethod = {\r\n  kind: \"basic\",\r\n  __raw?: {\r\n    // Original Tsp Operation type\r\n    kind: \"Operation\",\r\n  },\r\n  name: \"read\",\r\n  access: \"public\",\n\n}\r\n}\r\n```\r\n\r\n#### SdkBasicServiceMethod\r\n\r\nThis models a basic service call that is synchronous server side.\r\n\r\n##### Interface\r\n\r\n```ts\r\nexport interface SdkBasicServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"basic\";\r\n}\r\n```\r\n\r\n##### Example\r\n\r\n```ts\r\nconst sdkBasicServiceMethod = {\r\n  kind: \"basic\",\r\n  __raw?: {\r\n    // Original Tsp Operation type\r\n    kind: \"Operation\",\r\n  },\r\n  name: \"read\",\r\n  access: \"public\",\r\n  apiVersions: [],\r\n  parameters: [\r\n    {\r\n      name: \"id\",\r\n      kind: \"method\",\r\n      ...\r\n    },\r\n  ],\r\n  operation: {\r\n    kind: \"http\",\r\n    ...\r\n  },\r\n  response: {\r\n    kind: \"method\",\r\n    type: {\r\n      kind: \"model\",\r\n      name: \"Widget\",\r\n    }\r\n  },\r\n}\r\n```\r\n\r\n##### Usage\r\n\r\n```ts\r\nfunction serializeBasicServiceMethod<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkBasicServiceMethod<TServiceOperation>,\r\n): PythonSdkBasicServiceMethod<TServiceOperation> {\r\n  return {\r\n    ...method,\r\n    name: camelToSnakeCase(method.name),\r\n    operation: serializeServiceOperation(context, method, method.operation)\r\n  },\r\n}\r\n```\r\n\r\n#### SdkPagingServiceMethod\r\n\r\nThis represents a paging method we will generate on the client. It includes an initial service operation call, and potentially a next link operation as well.\r\n\r\nWe currently only have paging method support for azure-generated sdks.\r\n\r\n##### Interface\r\n\r\n```ts\r\nexport interface SdkPagingServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"paging\";\r\n  // raw paging information returned from getPagedResult\r\n  __raw_paged_metadata: PagedResultMetadata;\r\n  // string to get to next link. If undefined, we are doing fake paging\r\n  nextLinkPath?: string;\r\n  // service operation if separate requests need to be made for subsequent paging\r\n  nextLinkOperation?: TServiceOperation;\r\n}\n\nTServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkPagingServiceMethod<TServiceOperation>,\r\n): PythonSdkBasicServiceMethod<TServiceOperation> {\r\n  return {\r\n    ...method,\r\n    name: camelToSnakeCase(method.name),\r\n    operation: serializeServiceOperation(context, method, method.operation),\r\n    nextLinkOperation: method.nextLinkOperation ? serializeServiceOperation(context, method, method.nextLinkOperation) : undefined,\r\n  },\r\n}\r\n```\r\n\r\n#### SdkLroServiceMethod\r\n\r\nRepresents an LRO method we want to generate on the client.\r\n\r\nOnly returned for azure-generated sdks\r\n\r\n##### Interfaces\r\n\r\n```ts\r\nexport interface SdkLroServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"lro\";\r\n  // raw LroMetadata returned from azure-core helper function getLroMetadata\r\n  __raw_lro_metadata: LroMetadata;\r\n  // initial call to begin LRO polling\r\n  // thinking of instead making it the regular operation property so we can continue using that property\r\n  operation: TServiceOperation;\r\n}\r\n```\r\n\r\n#### Example\r\n\r\n```tsp\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\n// Skipping past service definitions\r\n\r\nalias Operations = Azure.Core.ResourceOperations<SupportsRepeatableRequests>;\r\n\r\n// Operation Status\r\n/** Gets status of a Widget operation. */\r\ngetWidgetOperationStatus is Operations.GetResourceOperationStatus<Widget>;\r\n\r\n// Widget Operations\r\n/** Creates or updates a Widget asynchronously */\r\n@pollingOperation(getWidgetOperationStatus)\r\ncreateOrUpdateWidget is Operations.LongRunningResourceCreateOrUpdate<Widget>;\r\n```\r\n\r\n```ts\r\nconst sdkLroServiceMethod = {\r\n  kind: \"lro\",\r\n  __raw?: {\r\n    // Original Tsp Operation type\r\n    kind: \"Operation\",\r\n  },\r\n  __raw_lro_metadata: {\r\n    // Raw output from getLroMetadata\r\n  }\r\n  name: \"createOrUpdateWidget\",\r\n  access: \"public\",\r\n  apiVersions: [],\n\n```ts\r\nexport interface SdkPagingServiceMethod<TServiceOperation extends SdkServiceOperation>\r\n  extends SdkServiceMethodBase<TServiceOperation> {\r\n  kind: \"paging\";\r\n  // raw paging information returned from getPagedResult\r\n  __raw_paged_metadata: PagedResultMetadata;\r\n  // string to get to next link. If undefined, we are doing fake paging\r\n  nextLinkPath?: string;\r\n  // service operation if separate requests need to be made for subsequent paging\r\n  nextLinkOperation?: TServiceOperation;\r\n}\r\n```\r\n\r\n##### Example\r\n\r\n```tsp\r\nimport \"@azure-tools/typespec-azure-core\";\r\n\r\nusing Azure.Core;\r\nusing Azure.Core.Traits;\r\n\r\n// Skipping past service definitions\r\n\r\nalias Operations = Azure.Core.ResourceOperations<SupportsRepeatableRequests>;\r\n\r\nlistWidgets is Operations.ResourceList<Widget>;\r\n```\r\n\r\n```ts\r\nconst sdkPagingServiceMethod = {\r\n  kind: \"paging\",\r\n  __raw?: {\r\n    // Original Tsp Operation type\r\n    kind: \"Operation\",\r\n  },\r\n  __raw_paged_metadata: {\r\n    // Raw output from getPagedMetadata\r\n  }\r\n  name: \"listWidgets\",\r\n  access: \"public\",\r\n  apiVersions: [],\r\n  parameters: [],\r\n  operation: {\r\n    kind: \"http\",\r\n    ...\r\n  },\r\n  response: {\r\n    kind: \"method\",\r\n    type: {\r\n      kind: \"model\",\r\n      name: \"Widget\",\r\n    },\r\n    // we want to return the `.value` part of the service response to users\r\n    pathFromService: \"value\",\r\n  },\r\n  nextLinkPath: \"nextLink\",\r\n  nextLinkOperation: undefined,\r\n}\r\n```\r\n\r\n##### Usage\r\n\r\n```ts\r\nfunction serializePagingServiceMethod<\r\n  TServiceOperation extends PythonSdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkPagingServiceMethod<TServiceOperation>,\r\n): PythonSdkBasicServiceMethod<TServiceOperation> {\r\n  return {\r\n    ...method,\r\n    name: camelToSnakeCase(method.name),\r\n    operation: serializeServiceOperation(context, method, method.operation),\r\n    nextLinkOperation: method.nextLinkOperation ? serializeServiceOperation(context, method, method.nextLinkOperation) : undefined,\n\n## SdkServiceOperation\n\nOne main part of this design is we've decoupled the actual service operation call from the method we generate on our client. This is because we want to abstract away the protocol used to call our service. Additionally, while there is a high level of correlation between the method parameters we intake from SDK users, and the parameters we end up passing the service, it's not one-to-one. We need to serialize the method parameters and additionally, when parameters are spread or grouped together, it requires us to do mapping between which method parameters correspond to which service parameters.\r\n\r\nWe currently only support HTTP calls to the service.\n\n### Interface\n\n```ts\r\nexport interface SdkHttpOperation {\r\n  kind: \"http\";\r\n  // raw HTTP operation output from typespec/http\r\n  __raw: HttpOperation;\r\n  // route path for the target operation. TypeSpec suggest to use `uriTemplate` instead as `path` will not work for complex cases like not-escaping reserved chars.\r\n  path: string;\r\n  // the fully resolved URI template for the target operation as defined by [RFC 6570](https://datatracker.ietf.org/doc/html/rfc6570).\r\n  uriTemplate: string;\r\n  verb: HttpVerb;\r\n  parameters: (SdkPathParameter | SdkQueryParameter | SdkHeaderParameter)[];\r\n  bodyParam: SdkBodyParameter;\r\n  // mapping of status codes to SdkHttpResponse for valid responses\r\n  // HttpStatusCodeRange can represent either a single status code or a range.\r\n  responses: SdkHttpResponse[];\r\n  exceptions: SdkHttpResponse[];\r\n  examples?: SdkHttpOperationExample[];\r\n}\r\n```\n\n### Example\n\n```ts\r\nconst sdkHttpOperation = {\r\n  kind: \"http\",\r\n  __raw: {\r\n    // raw HttpOperation from @typespec/http;\r\n  },\r\n  path: \"/widgets\",\r\n  uriTemplate: \"/widgets\",\r\n  verb: \"get\",\r\n  parameters: [\r\n    {\r\n      kind: \"path\",\r\n      name: \"id\",\r\n      ...\r\n    }\r\n  ],\r\n  bodyParam: undefined,\r\n  responses: {\r\n    200: {\r\n      kind: \"http\",\r\n      ...\r\n    },\r\n  },\r\n  exceptions: {\r\n    \"*\": {\r\n      kind: \"http\",\r\n      ...\r\n    }\r\n  },\r\n  examples: [\r\n    {\r\n      kind: \"http\",\r\n      name: \"Example 1\",\r\n      description: \"Example 1\",\r\n      filePath: \"example1.json\",\r\n      rawExample: {...},\r\n      parameters: [...],\r\n      responses: {...}\r\n    }\r\n  ]\r\n}\r\n```\n\n### Usage\n\n```ts\r\nfunction serializeServiceOperation<TServiceOperation extends PythonSdkServiceOperation>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  method: SdkServiceMethod<TServiceOperation>,\r\n  operation: TServiceOperation,\r\n): TServiceOperation {\r\n  switch (operation.kind) {\r\n    case \"http\":\r\n      return serializeHttpServiceOperation(context, method, operation);\r\n  }\r\n}\r\n```\n\n## Parameters and Properties\n\nLike the TypeSpec concept of a `ModelProperty`, all properties and parameters are part of the `SdkModelPropertyType`. They all extend from `SdkModelPropertyTypeBase`.\r\n\r\n```ts\r\nexport type SdkModelPropertyType =\r\n  | SdkMethodParameter\r\n  | SdkEndpointParameter\r\n  | SdkCredentialParameter\r\n  | SdkBodyModelPropertyType\r\n  | SdkQueryParameter\r\n  | SdkPathParameter\r\n  | SdkHeaderParameter\r\n  | SdkBodyParameter;\r\n```\r\n\r\n```ts\r\ninterface SdkModelPropertyTypeBase {\r\n  __raw?: ModelProperty;\r\n  type: SdkType;\r\n  name: string;\r\n  description?: string;\r\n  details?: string;\r\n  apiVersions: string[];\r\n  onClient: boolean;\r\n  // clientDefaultValue only exists for api versions\r\n  clientDefaultValue?: any;\r\n  isApiVersionParam: boolean;\r\n  optional: boolean;\r\n  nullable: boolean;\r\n}\r\n```\n\n### Method parameters\n\nThese are parameters to client initialization and method son the client. These will be the parameters that SDK users directly use. They will eventually be mapped to\r\n\r\n#### SdkEndpointParameter\r\n\r\nAn `SdkEndpointParameter` represents a parameter to a client's endpoint.\r\n\r\nTCGC will always give it to you as overridable:\r\n\r\nIf the server URL is a constant, we will return a templated endpoint with a default value of the constant server URL.\r\nIn the case where the endpoint has extra template arguments, the type is a union of a completely-overridable endpoint, and an endpoint that accepts template arguments.\r\nIf there are multiple servers, we will return the union of all of the possibilities.\r\n\r\n```tsp\r\nexport interface SdkEndpointParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"endpoint\";\r\n  urlEncode: boolean;\r\n  onClient: true;\r\n  serializedName?: string;\r\n  type: SdkEndpointType | SdkUnionType<SdkEndpointType>;\r\n}\r\n```\r\n\r\n#### SdkCredentialParameter\r\n\r\nParameter for credential input to clients.\r\n\r\n```ts\r\nexport interface SdkCredentialParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"credential\";\r\n  // can be either an SdkCredentialType or a union\r\n  // of different credential types\r\n  type: SdkCredentialType | SdkUnionType;\r\n  onClient: true;\r\n}\r\n```\r\n\r\n#### SdkMethodParameter\r\n\r\nRepresents a parameter to a client method. Does not have any transport (i.e. HTTP) related information on it. This is solely meant to represent information that we expect sdk users to pass in. We then take care to map the method input and create our request to the service using the information users have inputted.\r\n\r\n```ts\r\nexport interface SdkMethodParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"method\";\r\n}\r\n```\n\n### Service Parameters\n\ntreat each value in array as a separate header parameter\r\nexport type CollectionFormat = \"multi\" | \"csv\" | \"ssv\" | \"tsv\" | \"pipes\" | \"simple\" | \"form\";\r\n\r\nexport interface SdkHeaderParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"header\";\r\n  collectionFormat?: CollectionFormat;\r\n  serializedName: string;\r\n  correspondingMethodParams: SdkModelPropertyType[];\r\n}\r\n```\r\n\r\n#### SdkPathParameter\r\n\r\n```ts\r\nexport interface SdkPathParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"path\";\r\n  // when interpolating this parameter in the case of array or object, expand each value using the given style, default is `false`\r\n  explode: boolean;\r\n  // different interpolating styles for the path parameter, default is `\"simple\"`\r\n  // - simple: no separator\r\n  // - label: . as separator\r\n  // - matrix: ; as separator\r\n  // - fragment: # as separator\r\n  // - path: / as separator\r\n  style: \"simple\" | \"label\" | \"matrix\" | \"fragment\" | \"path\";\r\n  // when interpolating this parameter, do not encode reserved characters, default is `false`\r\n  allowReserved: boolean;\r\n  serializedName: string;\r\n  optional: false;\r\n  correspondingMethodParams: SdkModelPropertyType[];\r\n}\r\n```\r\n\r\n#### SdkBodyParameter\r\n\r\n```ts\r\nexport interface SdkBodyParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"body\";\r\n  optional: boolean;\r\n  contentTypes: string[];\r\n  defaultContentType: string;\r\n  correspondingMethodParams: SdkModelPropertyType[];\r\n}\r\n```\n\nCurrently we only support HTTP service parameters.\r\n\r\n#### SdkQueryParameter\r\n\r\nThis represents an HTTP query parameter.\r\n\r\n```ts\r\n// different collection format to use to separate each value in array\r\n// - multi: no separator, treat each value in array as a separate query parameter\r\n// - csv: , as separator\r\n// - ssv: space as separator\r\n// - tsv: tab as separator\r\n// - pipes: | as separator\r\n// - simple: , as separator\r\n// - form: no separator, treat each value in array as a separate query parameter\r\nexport type CollectionFormat = \"multi\" | \"csv\" | \"ssv\" | \"tsv\" | \"pipes\" | \"simple\" | \"form\";\r\n\r\nexport interface SdkQueryParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"query\";\r\n  // the collection format to use to separate each value in array of a query parameter\r\n  collectionFormat?: CollectionFormat;\r\n  serializedName: string;\r\n  correspondingMethodParams: SdkModelPropertyType[];\r\n  // if true, send each value in array or object as a separate query parameter, default is `false`\r\n  explode: boolean;\r\n}\r\n```\r\n\r\n#### SdkHeaderParameter\r\n\r\nThis is an HTTP header parameter.\r\n\r\n```ts\r\n// different collection format to use to separate each value in array\r\n// - multi: no separator, treat each value in array as a separate header parameter\r\n// - csv: , as separator\r\n// - ssv: space as separator\r\n// - tsv: tab as separator\r\n// - pipes: | as separator\r\n// - simple: , as separator\r\n// - form: no separator, treat each value in array as a separate header parameter\r\nexport type CollectionFormat = \"multi\" | \"csv\" | \"ssv\" | \"tsv\" | \"pipes\" | \"simple\" | \"form\";\r\n\r\nexport interface SdkHeaderParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"header\";\r\n  collectionFormat?: CollectionFormat;\r\n  serializedName: string;\r\n  correspondingMethodParams: SdkModelPropertyType[];\r\n}\r\n```\r\n\r\n#### SdkPathParameter\r\n\r\n```ts\r\nexport interface SdkPathParameter extends SdkModelPropertyTypeBase {\r\n  kind: \"path\";\n\n### Properties\n\n#### SdkBodyModelPropertyType\r\n\r\nThis represents a property on a body model\r\n\r\n```ts\r\nexport interface SdkBodyModelPropertyType extends SdkModelPropertyTypeBase {\r\n  kind: \"property\";\r\n  discriminator: boolean;\r\n  serializedName: string;\r\n  isMultipartFileInput: boolean;\r\n  visibility: Visibility[];\r\n  flatten: boolean;\r\n}\r\n```\n\n### Usage\n\nWe recommend that for usage, you use one single function with switch statements for each kind of property.\r\nThis allows for the circular nature of an `SdkModelPropertyType`.\r\n\r\n```\r\nimport { SdkServiceOperation, SdkModelPropertyType } from \"@azure-tools/typespec-client-generator-core\";\r\nimport { PythonSdkContext } from \"./lib.js\";\r\nimport { getPythonSdkType } from \"./types.js\";\r\n\r\nexport function getSdkModelPropertyType<\r\n  TServiceOperation extends SdkServiceOperation\r\n>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  prop: SdkModelPropertyType\r\n): PythonSdkModelType {\r\n  const type = getPythonSdkType(context, prop.type)\r\n  switch (prop.kind) {\r\n    case \"query\":\r\n    case \"header\"\r\n    case \"path\":\r\n      return {\r\n        ...prop,\r\n        type,\r\n        correspondingMethodParams: prop.correspondingMethodParams.map(\r\n          (x) => getSdkModelPropertyType(context, x),\r\n        )\r\n      }\r\n    default:\r\n      return {\r\n        ...prop,\r\n        type,\r\n      }\r\n  }\r\n}\r\n```\n\n## SdkMethodResponse\n\nThis represents the response that our method will ultimately return.\r\nIt is not tied to a transport, like http, it solely represents what we want to return to users\n\n### Interface\n\n```ts\r\nexport interface SdkMethodResponse {\r\n  kind: \"method\";\r\n  // the path from the service response to what the method returns.\r\n  logicalPath?: string;\r\n  type?: SdkType;\r\n  description?: string;\r\n  details?: string;\r\n}\r\n```\n\n### Example\n\n```ts\r\nconst sdkMethodResponse = {\r\n  kind: \"method\",\r\n  logicalPath: undefined,\r\n  type: {\r\n    kind: string,\r\n  },\r\n}\r\n\r\nconst sdkPagingMethodResponse = {\r\n  kind: \"method\",\r\n  logicalPath: \"value\",\r\n  type: {\r\n    kind: \"array\",\r\n    valueType: {\r\n      kind: \"model\",\r\n      name: \"Widget\",\r\n      nullableValues: false,\r\n      ...\r\n    }\r\n  }\r\n}\r\n```\n\n### Usage\n\n```ts\r\nimport { SdkMethodResponse } from \"@azure-tools/typespec-client-generator-core\";\r\nimport { PythonSdkContext, PythonSdkMethodResponse } from \"./lib.js\";\r\nimport { getPythonSdkType } from \"./types.js\";\r\n\r\nfunction serializeMethodResponse<TServiceOperation extends SdkServiceOperation>(\r\n  context: PythonSdkContext<TServiceOperation>,\r\n  response: SdkMethodResponse,\r\n): PythonSdkMethodResponse {\r\n  return {\r\n    ...response,\r\n    type: getPythonSdkType(context, response.type),\r\n  };\r\n}\r\n```\n\n## SdkHttpResponse\n\nThis is the response returned from an HTTP service. The emitters should take care to map it to what the method ultimately returns to end users.\r\n\r\nEach response is mapped to an `HttpStatusCodeRange` on the `SdkHttpOperation` interface.\n\n### Interface\n\n```ts\r\ninterface HttpStatusCodeRange {\r\n  start: number; // inclusive start. If there's only start, then it's just a single value.\r\n  end?: number; // exclusive end. If it's a range, end is present, otherwise it's undefined.\r\n}\r\n\r\nexport interface SdkHttpResponse {\r\n  kind: \"http\";\r\n  statusCodes: number | HttpStatusCodeRange | \"*\";\r\n  headers: SdkServiceResponseHeader[];\r\n  apiVersions: string[];\r\n  type?: SdkType;\r\n  contentTypes: string[];\r\n  defaultContentType?: string;\r\n}\r\n```\n\n## SdkType\n\nThese are the TCGC versions of each TypeSpec Type. They include information that all emitters want, i.e. their description directly on them.\r\n\r\nThey all share this base:\r\n\r\n```ts\r\ninterface SdkTypeBase {\r\n  // the raw TypeSpec type. Some of our types are currently\r\n  // created by tcgc. Those won't have an original type\r\n  __raw?: Type;\r\n  kind: string;\r\n  deprecation?: string;\r\n  description?: string;\r\n  details?: string;\r\n}\r\n```\n\n### SdkBuiltInType\n\nA `SdkBuiltInType` represents a built-in scalar TypeSpec type or scalar type that derives from a built-in scalar TypeSpec type, but datetime and duration are not included.\r\nWe add `encode` onto these types if `@encode` decorator exists, telling us how to encode when sending to the service.\r\n\r\nThere is a one-to-one mapping between the TypeSpec scalar kinds and the `SdkBuiltInKinds`.\r\n\r\n#### Interface\r\n\r\n```ts\r\nexport interface SdkBuiltInType extends SdkTypeBase {\r\n  kind: SdkBuiltInKinds;\r\n  name: string;\r\n  encode?: string;\r\n  baseType?: SdkBuiltInType;\r\n  crossLanguageDefinitionId: string;\r\n}\r\n```\r\n\r\nThe `crossLanguageDefinitionId` represents the fully qualified name of this type in TypeSpec language for the emitter to distinguish from the built-in TypeSpec types.\r\n\r\nFor a full list of types defined in `@azure-tools/typespec-azure-core` library, please refer to its reference doc.\n\n### SdkDateTimeType\n\n```ts\r\ninterface SdkDatetimeTypeBase extends SdkTypeBase {\r\n  name: string;\r\n  baseType?: SdkDateTimeType;\r\n  encode: DateTimeKnownEncoding;\r\n  // what we send over the wire. Often it's string\r\n  wireType: SdkBuiltInType;\r\n  crossLanguageDefinitionId: string;\r\n}\r\n\r\ninterface SdkUtcDatetimeType extends SdkDatetimeTypeBase {\r\n  kind: \"utcDateTime\";\r\n}\r\n\r\ninterface SdkOffsetDatetimeType extends SdkDatetimeTypeBase {\r\n  kind: \"offsetDateTime\";\r\n}\r\n```\n\n### SdkDurationType\n\n```ts\r\ninterface SdkDurationType extends SdkTypeBase {\r\n  kind: \"duration\";\r\n  name: string;\r\n  baseType?: SdkDurationType;\r\n  encode: DurationKnownEncoding;\r\n  // What we send over the wire. It's usually either a string or a float\r\n  wireType: SdkBuiltInType;\r\n  crossLanguageDefinitionId: string;\r\n}\r\n```\n\n### SdkArrayType\n\n```ts\r\ninterface SdkArrayType extends SdkTypeBase {\r\n  kind: \"array\";\r\n  name: string;\r\n  valueType: SdkType;\r\n  crossLanguageDefinitionId: string;\r\n}\r\n```\n\n### SdkDictionaryType\n\n```ts\r\ninterface SdkDictionaryType extends SdkTypeBase {\r\n  kind: \"dict\";\r\n  keyType: SdkType; // currently can only be string\r\n  valueType: SdkType;\r\n}\r\n```\n\n### SdkEnumType\n\n```ts\r\nexport interface SdkEnumType extends SdkTypeBase {\r\n  kind: \"enum\";\r\n  name: string;\r\n  // Determines whether the name was generated or not\r\n  isGeneratedName: boolean;\r\n  valueType: SdkBuiltInType;\r\n  values: SdkEnumValueType[];\r\n  isFixed: boolean;\r\n  isFlags: boolean;\r\n  usage: UsageFlags;\r\n  access: AccessFlags;\r\n  crossLanguageDefinitionId: string;\r\n  apiVersions: string[];\r\n  isUnionAsEnum: boolean;\r\n}\r\n```\n\n### SdkEnumValueType\n\n```ts\r\nexport interface SdkEnumValueType extends SdkTypeBase {\r\n  kind: \"enumvalue\";\r\n  name: string;\r\n  value: string | number;\r\n  enumType: SdkEnumType;\r\n  valueType: SdkBuiltInType;\r\n}\r\n```\n\n### SdkConstantType\n\n```ts\r\nexport interface SdkConstantType extends SdkTypeBase {\r\n  kind: \"constant\";\r\n  value: string | number | boolean | null;\r\n  valueType: SdkBuiltInType;\r\n  name: string;\r\n  isGeneratedName: boolean;\r\n}\r\n```\n\n### SdkUnionType\n\n```ts\r\nexport interface SdkUnionType extends SdkTypeBase {\r\n  name: string;\r\n  // determines if the union name was generated or not\r\n  isGeneratedName: boolean;\r\n  kind: \"union\";\r\n  variantTypes: SdkType[];\r\n  crossLanguageDefinitionId: string;\r\n}\r\n```\n\n### SdkTupleType\n\n```ts\r\nexport interface SdkTupleType extends SdkTypeBase {\r\n  kind: \"tuple\";\r\n  valueTypes: SdkType[];\r\n}\r\n```\n\n### SdkModelType\n\n```ts\r\nexport interface SdkModelType extends SdkTypeBase {\r\n  kind: \"model\";\r\n  // purposely can also be header / query params for fidelity with TypeSpec\r\n  properties: SdkModelPropertyType[];\r\n  // we will always have a name. generatedName determines if it's generated or not.\r\n  name: string;\r\n  isGeneratedName: boolean;\r\n  access: AccessFlags;\r\n  usage: UsageFlags;\r\n  additionalProperties?: SdkType;\r\n  discriminatorValue?: string;\r\n  discriminatedSubtypes?: Record<string, SdkModelType>;\r\n  discriminatorProperty?: SdkModelPropertyType;\r\n  baseModel?: SdkModelType;\r\n  crossLanguageDefinitionId: string;\r\n  apiVersions: string[];\r\n}\r\n```\n\n### UsageFlags\n\n```ts\r\nexport enum UsageFlags {\r\n  None = 0,\r\n  Input = 1 << 1,\r\n  Output = 1 << 2,\r\n  ApiVersionEnum = 1 << 3,\r\n  JsonMergePatch = 1 << 4,\r\n  MultipartFormData = 1 << 5,\r\n}\r\n```\n\n### AccessFlags\n\nWe default the value of `.access` property on model, enum, and method types to be `\"public\"`. So if the `@access` decorator isn't explicitly applied to one of these definitions, its value will be `\"public\"`.\r\n\r\nIf you want to know if a tsp author explicitly set the value with an `@access` decorator, you can call `getAccessOverride`\r\n\r\n```ts\r\nexport type AccessFlags = \"internal\" | \"public\";\r\n```\n\n### SdkEndpointType\n\n```ts\r\nexport interface SdkEndpointType {\r\n  kind: \"endpoint\";\r\n  serverUrl: string;\r\n  templateArguments: SdkPathParameter[];\r\n}\r\n```\n\n## Example Types\n\nThe example types help to model the examples that TypeSpec author defined to help user understand how to use the API.\r\n\r\nWe currently only have examples based on the payload, so the examples model will bind to the SdkServiceOperation.\n", "latency": 13.296663999557495, "response_length": 754}
{"query": "title: How to append versions to URL?\n\nquestion: I am looking for a decorator to append versions to the URL.\nMy case is as below:\n```\n@versioned(Versions)\n@route(\"petstore\")\nnamespace PetStoreService;\nenum Versions{\nv1,v2,v3\n}\ninterface Pets extends Resource.ResourceOperations<Pet, Error> {}\n```\nThere will generate three openapi files(v1,v2,v3) after executing `tsp complie .` and these files include the same interfaces below:\n[POST] /petstore\n[GET] /petstore\n[GET] /petstore/{id}\n[PATCH] /petstore/{id}\n[DELETE] /petstore/{id}\nMy question is how to automatically append the version enum to the URL like:\n```\n// in openapi.v1.yaml like\n[POST] /petstore/v1\n[GET] /petstore/v1\n[GET] /petstore/{id}/v1\n[PATCH] /petstore/{id}/v1\n[DELETE] /petstore/{id}/v1\n```\n```\n// in openapi.v2.yaml like\n[POST] /petstore/v2\n[GET] /petstore/v2\n[GET] /petstore/{id}/v2\n[PATCH] /petstore/{id}/v2\n[DELETE] /petstore/{id}/v2\n...\n```\n```\n// in openapi.v3.yaml like\n[POST] /petstore/v3\n[GET] /petstore/v3\n[GET] /petstore/{id}/v3\n[PATCH] /petstore/{id}/v3\n[DELETE] /petstore/{id}/v3\n...\n```", "ground_truth": "The short answer is that there isn't a way to automatically do this yet, however, you can achieve a similar thing by using explict `@route` decoration with versioned interfaces or operations, for example [this playground shows versioning interfaces](https://cadlplayground.z22.web.core.windows.net/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZyI7Cgp1c2luZyBUeXBlU3BlYy5IdHRwO9AVUmVzdNEVVslH1TDEBW91cmNlOwoKQHNlcnZpY2UoewogIHRpdGxlOiAiV2lkZ2V0IFPGGyIsCn0pCkDnAJxlZCjHX3MpCkByb3V0ZSgicGV0c3RvcmUiKQpuYW1lc3BhY2UgUGV0U8QVx0c7CgplbnVtIMg%2BIMRydjEsxAYyxQYzLAp9Cgptb2RlbMQ9xSFAa2V5CiAgxFY6IHN0cuUA1MU5UHJvcM0TQGFkZOsAni52MinFXN8pcy52M8UpM84pfQoKQGVycm9y5wCSRcQM5QCUY29k6wCNICBtZXNzYWfLE8Q7cmVtb3bNZjLqATAvdjEiKQpAcHJvamVjdGVkTmFtZSgianNvbiIsICJQZXRzQ29sbGVjdGlvbiIpCmludGVyZucBVMsbVjEgZXh0ZW5kcyDoAdPKHU9wZXJhxAlzPFBldCzmAMA%2BIHv%2FAJ0oInvkAW19%2FwCjZXRz8QCZVjHmAbNwYXRjaMQJdXBkYXRlc%2BgAnChQZXTkAWrGFyguLukCiVBhcmFtZXRlcuUArD4sIEBib2R5IMQFOsRbKcUGIHzmAMXmAWHzAe7zANgz7AF1Mv8A0v8BdcYbVjL%2FAXX4AXX%2FALHyALHoAYn%2FALfzAYky%2FwGJ%2FwGJ%2FwGJ%2FwGJ7QFzM%2F8AvP8Bc8YbdjP%2FAXP%2FAXP8AV3%2FAKHzAV0z%2FwFd%2FwFd%2FwFd7QFd&e=%40typespec%2Fopenapi3&options=%7B%7D)\nCreating templates based on these definitions would make this a bit easier to express. In the future, it may be possible to use string interpolation to represent the version value in the operation route, which would remove the need to represent the versioned operatiosn separately.", "response": "To automatically append version enums to the URL in your TypeSpec project, you can use the `@versioned` decorator along with the `Versions` enum. The `@versioned` decorator generates separate OpenAPI specifications for each version, and the URLs will include the version string as specified in the `Versions` enum. Here's how you can achieve this:\n\n1. Define the `Versions` enum with the desired version strings:\n```typescript\nimport \"@typespec/versioning\";\n\n@versioned(Versions)\nnamespace PetStoreService;\n\nenum Versions {\n  v1: \"v1\",\n  v2: \"v2\",\n  v3: \"v3\",\n}\n```\n\n2. Use the `@route` decorator to define your endpoints. The version string will automatically be appended to the URL based on the `Versions` enum:\n```typescript\n@route(\"/petstore\")\ninterface Pets extends Resource.ResourceOperations<Pet, Error> {}\n```\n\n3. When you compile your TypeSpec project using `tsp compile .`, separate OpenAPI files will be generated for each version, and the URLs will include the version string as specified in the `Versions` enum. For example:\n\n- In `openapi.v1.yaml`:\n  ```\n  [POST] /petstore/v1\n  [GET] /petstore/v1\n  [GET] /petstore/{id}/v1\n  [PATCH] /petstore/{id}/v1\n  [DELETE] /petstore/{id}/v1\n  ```\n\n- In `openapi.v2.yaml`:\n  ```\n  [POST] /petstore/v2\n  [GET] /petstore/v2\n  [GET] /petstore/{id}/v2\n  [PATCH] /petstore/{id}/v2\n  [DELETE] /petstore/{id}/v2\n  ```\n\n- In `openapi.v3.yaml`:\n  ```\n  [POST] /petstore/v3\n  [GET] /petstore/v3\n  [GET] /petstore/{id}/v3\n  [PATCH] /petstore/{id}/v3\n  [DELETE] /petstore/{id}/v3\n  ```\n\nThis approach ensures that versioning is automatically handled in the generated OpenAPI specifications.", "context": "- document_dir: typespec_azure_docs\n- document_filename: getstarted#azure-core#step10.md\n- document_title: 10. Versioning\n- document_link: https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10\n- document_content: # getstarted#azure-core#step10.md\n\n# 10. Versioning\n\n## Versioning your service\n\nIt is inevitable that service specifications will change over time. It is a best practice to add versioning support to your specification from the first version. To do that, you will need to define an `enum` containing your service versions and then apply the `@versioned` decorator to your service namespace.\r\n\r\nHere is an example for the `WidgetManager` service:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n}\r\n```\r\n\r\nThere are a few things to point out here:\r\n\r\n- We define an `enum` called `Versions` inside of the service namespace. For each service version, we map a version symbol like `v2022_08_31` to a version string like `2022-08-31`. This service currently only has a single version, but we can add more to this enum as things change over time.\r\n- We add the `@versioned` decorator and reference the `Versions` enum we defined using the fully-qualified name `Contoso.WidgetManager.Versions`. This marks the service as being versioned and specifies the set of versions.\r\n- We change the `@useDependency` decorator we used previously to now link each service version to a specific version of `Azure.Core`. See the [Using Azure.Core Versions](#using-azurecore-versions) section for more information.\r\n\r\nImagine that it's 3 months later and you want to release a new version of your service with some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\n\nwith some slight changes. Add a new version to the `Versions` enum:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nYou will also need to add the `@useDependency` decorator:\r\n\r\n```typespec\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"2022-08-31\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"2022-11-30\",\r\n}\r\n```\r\n\r\nFinally, you can express changes to your service using the `@added` and `@removed` decorators. Here's an example of adding a new property to `Widget` and removing an old one:\r\n\r\n```typespec\r\n/** A widget. */\r\n@resource(\"widgets\")\r\nmodel Widget {\r\n  /** The widget name. */\r\n  @key(\"widgetName\")\r\n  @visibility(Lifecycle.Read)\r\n  name: string;\r\n\r\n  /** The widget color. */\r\n  @added(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  color: string;\r\n\r\n  /** The ID of the widget's manufacturer. */\r\n  @removed(Contoso.WidgetManager.Versions.v2022_11_30)\r\n  manufacturerId: string;\r\n}\r\n```\r\n\r\n> You can do a lot more with versioning decorators, so consult the `typespec-versioning` [README.md](https://github.com/microsoft/typespec/tree/main/packages/versioning#enable-versioning-for-service-or-library) for more information on how you can use them to annotate your service and describe changes between different versions.\n\n## Using Azure.Core versions\n\n`typespec-azure-core` is a versioned TypeSpec library. This means that even as the TypeSpec portions of the typespec-azure-core library are updated, you can anchor each version of your spec to a specific `Azure.Core` version. This is done by decorating your service namespace with the `@useDependency` decorator from the `typespec-versioning` library.\r\n\r\nSimple TypeSpec specs need only pass the desired `Azure.Core` version into the `@useDependency` decorator:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\nnamespace Contoso.WidgetManager;\r\n```\r\n\r\nIf your spec has [multiple versions](#versioning-your-service), you will need to specify the version of `typespec-azure-core` that was used for each version in your spec. Assuming that there are two versions of `Azure.Core` and each version of your service uses a different one, it would look like this:\r\n\r\n```typespec\r\n@service(#{ title: \"Contoso Widget Manager\" })\r\n@versioned(Contoso.WidgetManager.Versions)\r\nnamespace Contoso.WidgetManager;\r\n\r\nenum Versions {\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_1)\r\n  v2022_08_31: \"v20220831\",\r\n\r\n  @useDependency(Azure.Core.Versions.v1_0_Preview_2)\r\n  v2022_11_30: \"v20221130\",\r\n}\r\n```\n-------------------------\n- document_dir: typespec_docs\n- document_filename: emitters#clients#http-client-csharp#reference#emitter.md\n- document_title: Emitter usage\n- document_link: https://typespec.io/docs/emitters/clients/http-client-csharp/reference/emitter\n- document_content: # emitters#clients#http-client-csharp#reference#emitter.md\n\n# Emitter usage\n\n## Usage\n\n1. Via the command line\r\n\r\n```bash\r\ntsp compile . --emit=@typespec/http-client-csharp\r\n```\r\n\r\n2. Via the config\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-csharp\"\r\n```\r\n\r\nThe config can be extended with options as follows:\r\n\r\n```yaml\r\nemit:\r\n  - \"@typespec/http-client-csharp\"\r\noptions:\r\n  \"@typespec/http-client-csharp\":\r\n    option: value\r\n```\n\n## Emitter options\n\n### `emitter-output-dir`\n\n**Type:** `absolutePath`\r\n\r\nDefines the emitter output directory. Defaults to `{output-dir}/@typespec/http-client-csharp`\r\nSee [Configuring output directory for more info](https://typespec.io/docs/handbook/configuration/configuration/#configuring-output-directory)\n\n### `api-version`\n\n**Type:** `string`\r\n\r\nFor TypeSpec files using the [`@versioned`](https://typespec.io/docs/libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator, set this option to the version that should be used to generate against.\n\n### `generate-protocol-methods`\n\n**Type:** `boolean`\n\n### `generate-convenience-methods`\n\n**Type:** `boolean`\n\n### `unreferenced-types-handling`\n\n**Type:** `\"removeOrInternalize\" | \"internalize\" | \"keepAll\"`\r\n\r\nDefines the strategy on how to handle unreferenced types. The default value is `removeOrInternalize`.\n\n### `new-project`\n\n**Type:** `boolean`\r\n\r\nSet to `true` to overwrite the csproj if it already exists. The default value is `false`.\n\n### `save-inputs`\n\n**Type:** `boolean`\r\n\r\nSet to `true` to save the `tspCodeModel.json` and `Configuration.json` files that are emitted and used as inputs to the generator. The default value is `false`.\n\n### `package-name`\n\n**Type:** `string`\r\n\r\nDefine the package name. If not specified, the first namespace defined in the TypeSpec is used as the package name.\n\n### `debug`\n\n**Type:** `boolean`\r\n\r\nSet to `true` to automatically attempt to attach to a debugger when executing the C# generator. The default value is `false`.\n\n### `logLevel`\n\n**Type:** `\"info\" | \"debug\" | \"verbose\"`\r\n\r\nSet the log level. The default value is `info`.\n\n### `disable-xml-docs`\n\n**Type:** `boolean`\r\n\r\nSet to `true` to disable XML documentation generation. The default value is `false`.\n\n### `generator-name`\n\n**Type:** `string`\r\n\r\nThe name of the generator. By default this is set to `ScmCodeModelGenerator`. Generator authors can set this to the name of a generator that inherits from `ScmCodeModelGenerator`.\n\n### `emitter-extension-path`\n\n**Type:** `string`\r\n\r\nAllows emitter authors to specify the path to a custom emitter package, allowing you to extend the emitter behavior. This should be set to `import.meta.url` if you are using a custom emitter.\n\n### `update-code-model`\n\n**Type:** `object`\r\n\r\nAllows emitter authors to specify a custom function to modify the generated code model before emitting. This is useful for modifying the code model before it is passed to the generator.\n\n### `license`\n\n**Type:** `object`\r\n\r\nLicense information for the generated client code.\n\n### `sdk-context-options`\n\n**Type:** `object`\r\n\r\nThe SDK context options that implement the `CreateSdkContextOptions` interface from the [`@azure-tools/typespec-client-generator-core`](https://www.npmjs.com/package/@azure-tools/typespec-client-generator-core) package to be used by the CSharp emitter.\n-------------------------\n- document_dir: typespec_docs\n- document_filename: getting-started#getting-started-rest#06-versioning.mdx\n- document_title: Versioning\n- document_link: https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\n- document_content: # getting-started#getting-started-rest#06-versioning.mdx\n\n# Versioning\n\nimport { FileTree } from \"@astrojs/starlight/components\";\n\n## Introduction\n\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\n\n## Adding the Versioning Library\n\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\n\n### Step 1: Update `package.json`\n\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\r\n\r\n```json\r\n{\r\n  \"name\": \"typespec-petstore\",\r\n  \"version\": \"0.1.0\",\r\n  \"type\": \"module\",\r\n  \"peerDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@typespec/compiler\": \"latest\",\r\n    \"@typespec/http\": \"latest\",\r\n    \"@typespec/openapi3\": \"latest\",\r\n    // highlight-next-line\r\n    \"@typespec/versioning\": \"latest\"\r\n  },\r\n  \"private\": true\r\n}\r\n```\n\n### Step 2: Install Dependencies\n\nRun the following command to install the new dependencies:\r\n\r\n```sh\r\ntsp install\r\n```\n\n## Introduction to the `@versioned` Decorator\n\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\n\n### Example: Defining API Versions\n\nLet's define two versions of our API, `v1` and `v2`:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\n// highlight-next-line\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\n// highlight-next-line\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n// highlight-next-line\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\n// highlight-start\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\r\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\r\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\n\n### Generating OpenAPI Specifications for Different Versions\n\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\r\n\r\n{/* prettier-ignore */}\r\n<FileTree>\r\n- main.tsp\r\n- tspconfig.yaml\r\n- package.json\r\n- node_modules/\r\n- tsp-output/\r\n  - @typespec/\r\n    - openapi3\r\n      - openapi.1.0.yaml\r\n      - openapi.2.0.yaml\r\n</FileTree>\r\n\r\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\r\n\r\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\n\n## Using the `@added` Decorator\n\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\n\n### Example: Adding a New Model in a Specific Version\n\nLet's add a `Toy` model that is only available in version 2 of the API:\r\n\r\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n// highlight-start\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n// highlight-end\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toy` model is defined with the `@added(Versions.v2)` decorator to indicate that it was added in version 2 of the API.\n\n## Version-Specific Operations\n\nLet's define version-specific operations to manage toys for pets. These operations will only be available in version 2 of the API.\n\n### Example: Adding Version-Specific Operations\n\n}\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 404;\r\n        @body error: NotFoundError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 500;\r\n        @body error: InternalServerError;\r\n      };\r\n\r\n  @delete\r\n  @useAuth(BearerAuth)\r\n  op deletePet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 204;\r\n  } | {\r\n    @statusCode statusCode: 401;\r\n    @body error: UnauthorizedError;\r\n  };\r\n\r\n  // highlight-start\r\n  @route(\"{petId}/toys\")\r\n  namespace Toys {\r\n    @added(Versions.v2)\r\n    @get\r\n    op listToys(@path petId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 200;\r\n      @body toys: Toy[];\r\n    } | {\r\n      @statusCode statusCode: 404;\r\n      @body error: NotFoundError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @post\r\n    @useAuth(BearerAuth)\r\n    op createToy(@path petId: int32, @body toy: Toy, ...CommonParameters): {\r\n      @statusCode statusCode: 201;\r\n      @body newToy: Toy;\r\n    } | {\r\n      @statusCode statusCode: 400;\r\n      @body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\n\n```tsp title=main.tsp tryit=\"{\"emit\": [\"@typespec/openapi3\"]}\"\r\nimport \"@typespec/http\";\r\nimport \"@typespec/versioning\";\r\n\r\nusing Http;\r\nusing Versioning;\r\n\r\n@service(#{ title: \"Pet Store\" })\r\n@server(\"https://example.com\", \"Single server endpoint\")\r\n@versioned(Versions)\r\nnamespace PetStore;\r\n\r\nenum Versions {\r\n  v1: \"1.0\",\r\n  v2: \"2.0\",\r\n}\r\n\r\nmodel Pet {\r\n  id: int32;\r\n\r\n  @minLength(1)\r\n  name: string;\r\n\r\n  @minValue(0)\r\n  @maxValue(100)\r\n  age: int32;\r\n\r\n  kind: petType;\r\n}\r\n\r\nenum petType {\r\n  dog: \"dog\",\r\n  cat: \"cat\",\r\n  fish: \"fish\",\r\n  bird: \"bird\",\r\n  reptile: \"reptile\",\r\n}\r\n\r\n@added(Versions.v2)\r\nmodel Toy {\r\n  id: int32;\r\n  name: string;\r\n}\r\n\r\nmodel CommonParameters {\r\n  @header\r\n  requestID: string;\r\n\r\n  @query\r\n  locale?: string;\r\n\r\n  @header\r\n  clientVersion?: string;\r\n}\r\n\r\n@route(\"/pets\")\r\nnamespace Pets {\r\n  @get\r\n  op listPets(...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pets: Pet[];\r\n  };\r\n\r\n  @get\r\n  op getPet(@path petId: int32, ...CommonParameters): {\r\n    @statusCode statusCode: 200;\r\n    @body pet: Pet;\r\n  } | {\r\n    @statusCode statusCode: 404;\r\n    @body error: NotFoundError;\r\n  };\r\n\r\n  @post\r\n  @useAuth(BearerAuth)\r\n  op createPet(@body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 201;\r\n        @body newPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 202;\r\n        @body acceptedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      };\r\n\r\n  @put\r\n  @useAuth(BearerAuth)\r\n  op updatePet(@path petId: int32, @body pet: Pet, ...CommonParameters):\r\n    | {\r\n        @statusCode statusCode: 200;\r\n        @body updatedPet: Pet;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 400;\r\n        @body error: ValidationError;\r\n      }\r\n    | {\r\n        @statusCode statusCode: 401;\r\n        @body error: UnauthorizedError;\r\n      }\r\n    |\n\n@body error: ValidationError;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n\r\n    @added(Versions.v2)\r\n    @put\r\n    @useAuth(BearerAuth)\r\n    op updateToy(@path petId: int32, @path toyId: int32, @body toy: Toy, ...CommonParameters):\r\n      | {\r\n          @body updatedToy: Toy;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 400;\r\n          @body error: ValidationError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 401;\r\n          @body error: UnauthorizedError;\r\n        }\r\n      | {\r\n          @statusCode statusCode: 404;\r\n          @body error: NotFoundError;\r\n        };\r\n\r\n    @added(Versions.v2)\r\n    @delete\r\n    @useAuth(BearerAuth)\r\n    op deleteToy(@path petId: int32, @path toyId: int32, ...CommonParameters): {\r\n      @statusCode statusCode: 204;\r\n    } | {\r\n      @statusCode statusCode: 401;\r\n      @body error: UnauthorizedError;\r\n    };\r\n  }\r\n  // highlight-end\r\n}\r\n\r\n@error\r\nmodel NotFoundError {\r\n  code: \"NOT_FOUND\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel ValidationError {\r\n  code: \"VALIDATION_ERROR\";\r\n  message: string;\r\n  details: string[];\r\n}\r\n\r\n@error\r\nmodel UnauthorizedError {\r\n  code: \"UNAUTHORIZED\";\r\n  message: string;\r\n}\r\n\r\n@error\r\nmodel InternalServerError {\r\n  code: \"INTERNAL_SERVER_ERROR\";\r\n  message: string;\r\n}\r\n\r\nmodel InternalServerErrorResponse {\r\n  @statusCode statusCode: 500;\r\n  @body error: InternalServerError;\r\n}\r\n```\r\n\r\nIn this example:\r\n\r\n- The `Toys` namespace is defined under the `Pets` namespace.\r\n- The `@added(Versions.v2)` decorator is applied to the operations within the `Toys` namespace to indicate that they were added in version 2 of the API.\r\n- The `Toys` namespace includes operations to list, create, update, and delete toys for a specific pet. These operations are only available in version 2 of the API.\n\n## Conclusion\n\nIn the next section, we'll dive into creating custom response models for your REST API.\n", "latency": 14.197657108306885, "response_length": 1631}
