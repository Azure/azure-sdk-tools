{"query": "title: Output folder 'ContentUnderstanding' appears to contain TypeSpec-generated swagger files, not generated from the current TypeSpec sources. Perhaps you deleted a version from your TypeSpec, but didn't delete the associated swaggers?\n\nquestion: [Pull Request #21772](https://github.com/Azure/azure-rest-api-specs-pr/pull/21772) is currently failing TypeSpec validation because data-plane contains the Swagger for an older preview not specified in main.tsp.  The guidance I got from API board a month ago is that main.tsp should only list the latest preview. API version  But doing so triggered this error.\nShould this be an error?  Or can we make this into a warning instead?", "ground_truth": "You should only track the latest preview version in your TypeSpec files.\nIf there are older preview Swagger files still in the repo, they can remain there for the required 90-day deprecation window, even if they're no longer listed in your .tsp files.\nWhile TypeSpec validation currently throws an error if Swagger files exist without a matching version in TypeSpec, you can suppress this error by adding an entry to suppressions.yaml in your service's spec folder (not the global one).\nLonger-term, the goal is to eliminate swagger files entirely, but for now, swagger and TypeSpec coexist. So:\nKeep only the latest preview in .tsp\nKeep older generated swagger for 90 days\nAdd suppressions if needed to prevent TypeSpec validation from failing", "response": "This should NOT be an error. The current guidance is that your TypeSpec files (main.tsp) should only track the latest preview version. However, older preview Swagger files can remain in the repo for the required 90-day deprecation window, even if they're no longer listed in your .tsp files. \n\nTypeSpec validation currently throws an error if Swagger files exist without a matching version in TypeSpec, but you can suppress this error by adding an entry to suppressions.yaml in your service's spec folder. This allows you to keep the older Swagger files for the deprecation period without failing validation. \n\nSo, while the error is expected with the current tooling, the recommended approach is to suppress it (not treat it as a warning) until the older Swagger files can be safely deleted. Longer-term, the goal is to eliminate Swagger files entirely, but for now, this coexistence is necessary.", "context": null, "latency": 8.772613286972046, "response_length": 898}
{"query": "title: Typespec Validation Failing on PR due to `typespec-go` configuration missing\n\nquestion: Hi TypeSpec Discussion,\nCI has been failing constantly for our PR ([Azure Load Testing\\] Add 2025-03-01-preview Data-Plane APIs by Harshan01 · Pull Request #32585 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/32585)) for Typespec Validation step. The logs show that we are missing the Go SDK configuration and I am able to produce this error locally as well. However, our service doesnt have a Go SDK and we are not planning to put it in scope right now. This check has suddenly started failing for our PRs, what should we do?\n```\nExecuting rule：SdkTspConfigVa1idation\n[SdkTspconfigVa1idation]：validation failed．\n- Failed to find \"options.@azure-tools/typespec-go.generate-fakes\"．Please add \"options.@azure-tools/typespec-go.generate-fakes\".\n- Failed to find \"options.@azure-tools/typespec-go.inject一spans“．Please add \"options.@azure-tools/typespec-go.inject一spans.\n- Failed to find \"options.@azure-tools/typespec-go.service-dir\"．Please add \"options.@azure-tools/typespec-go.service-dir\".\n- Failed to find \"options.@azure-tools/typespec-go.package-dir\"．Please add\"options.@azure-tools/typespec-go.package-dir\".\nPlease See https://aka.ms/azsdk/spec-gen-sdk-config for more info．\nFor additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.\n```", "ground_truth": "Suppressing go specific rules worked for me (locally, checking CI now). Thanks Mike. Also FYI Darren Cohen. Here's our suppression file:\n```yml\n- tool: TypeSpecValidation\npaths:\n- tspconfig.yaml\nrules:\n- SdkTspConfigValidation\nsub-rules:", "response": "You are encountering TypeSpec validation failures in CI due to missing Go SDK configuration, even though your service does not plan to support a Go SDK. This is a known scenario, and the recommended solution is to suppress the Go-specific validation rules for your project.\n\nYou can do this by adding a suppression entry to your validation suppression file (typically a YAML file). Here is an example suppression configuration that has worked for others in the same situation:\n\n```yaml\n- tool: TypeSpecValidation\n  paths:\n    - tspconfig.yaml\n  rules:\n    - SdkTspConfigValidation\n  sub-rules:\n    # Suppress validation for Go emitter options\n    - options.@azure-tools/typespec-go.generate-fakes\n    - options.@azure-tools/typespec-go.inject-spans\n    - options.@azure-tools/typespec-go.service-dir\n    - options.@azure-tools/typespec-go.package-dir\n  reason: 'Azure Load Testing does not support a Go SDK currently'\n```\n\nThis will suppress the validation errors related to missing Go SDK configuration. After adding this, your CI should pass the TypeSpec validation step. If you need further help, you can reach out in the TypeSpec Discussion Channel or the Go language channel as referenced in the documentation.", "context": null, "latency": 34.83123064041138, "response_length": 1215}
{"query": "title: SdkTspConfigValidation failures for JS dataplane code generation\n\nquestion: We have a TypeSpec PR here: https://github.com/Azure/azure-rest-api-specs/pull/33130 . We are emitting the new type of JS client library (not RLC), I think it's called dataplane code generation, or modular library, but I'm not sure. We set `is-modular-library: true` in the tspconfig.yaml. However, we're still getting `SdkTspConfigValidation` failures complaining that the word \"rest\" does not appear in the package name and folder name. See below. I believe that restriction only applies to RLC. I will try to suppress these errors, but checking in here if I'm doing the right thing in tspconfig.yaml, and if so, why do we see these errors? Thanks! Tagging Mike Harder.\n```\nExecuting rule: SdkTspConfigValidation\nSkip validation on options.@azure-tools/typespec-go.generate-fakes.\nSkip validation on options.@azure-tools/typespec-go.inject-spans.\nSkip validation on options.@azure-tools/typespec-go.service-dir.\nSkip validation on options.@azure-tools/typespec-go.package-dir.\n[SdkTspConfigValidation]: validation failed.\n- The value of options.@azure-tools/typespec-ts.package-dir \"ai-projects\" does not match \"/^(?:[a-z]+-)*rest$/\". Please update the value of \"options.@azure-tools/typespec-ts.package-dir\" to match \"/^(?:[a-z]+-)*rest$/\".\n- The value of options.@azure-tools/typespec-ts.package-details.name \"@azure/ai-projects\" does not match \"/^\\@azure-rest\\/[a-z]+(?:-[a-z]+)*$/\". Please update the value of \"options.@azure-tools/typespec-ts.package-details.name\" to match \"/^\\@azure-rest\\/[a-z]+(?:-[a-z]+)*$/\".\nPlease see https://aka.ms/azsdk/spec-gen-sdk-config for more info.\nFor additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.\n```", "ground_truth": "Yes, you are right the `rest` check should only apply to RLC and I will check if the validation works as expected. One thing to confirm is if we got the JS architects approval to release Modular for AI projects, generally we would recommend to release RLC for data-plane.", "response": "You are correct: the requirement for the word \"rest\" to appear in the JS package name and folder name applies only to RLC (REST Level Client) libraries, not to the new modular (dataplane) JS client libraries. Setting `is-modular-library: true` in your `tspconfig.yaml` is the right approach for modular/dataplane generation. The validation errors you are seeing are likely due to the validation logic not properly distinguishing between RLC and modular configurations.\n\nAs confirmed in the Q&A:\n\n> Yes, you are right the `rest` check should only apply to RLC and I will check if the validation works as expected. One thing to confirm is if we got the JS architects approval to release Modular for AI projects, generally we would recommend to release RLC for data-plane.\n\nSo, your configuration is correct for modular/dataplane JS generation. If you are blocked by these validation errors, you can suppress them as a workaround until the validation logic is fixed. However, you should also confirm with the JS architects that modular is approved for your scenario, as RLC is generally recommended for data-plane SDKs.\n\nFor more information on SDK config validation and TypeSpec validation, see the following links:\n- https://aka.ms/azsdk/spec-gen-sdk-config\n- https://aka.ms/azsdk/specs/typespec-validation", "context": null, "latency": 21.089122533798218, "response_length": 1305}
{"query": "title: Support for pagination\n\nquestion: Hi, I have a typespec API which is a list api\n```\nlistResources is ArmResourceActionSync<\nAutoAction,\nvoid,\nAutoActionResourceListResponse\n>;\nmodel AutoActionResourceListResponse is Azure.Core.Page<AutoActionResource>;\n```\nThis api needs to support pagination. How can I achieve that using Microsoft.TypeSpec.Providerhub.Controller? we use the package to generate our controllers, which doesn't let me add query parameters to our API", "ground_truth": "The controller emitter will emit an endpoint for your action, but you will need to add an endpoint manually for the next page endpoint (which is, presumably, a GET).\nget is required for paging.  If you are not using GET, then automated paging mechanisms in ARM clients won't work.\nIt's possible to use a different paging mechanism, but will require custom code in SDKs\ntypespec-providerhub does not provide extra GET endpoints for resource actions that return lists - you would need to add this endpoint.  Since the controllers are partial, this should be fairly straightforward.\nThe question of whether RPaaS (providerhub) should support such an endpoint and typespec-providerhub should provide any required extension support for this is a good one.", "response": "To support pagination in your TypeSpec API using `microsoft.typespec.providerhub.controller`, you need to ensure your list operation is modeled to include pagination parameters and response shapes. However, as per the current state of the ProviderHub controller emitter, it does not automatically add query parameters for pagination (like `skip`, `top`, or continuation tokens) to resource action endpoints. You will need to manually add a GET endpoint that supports pagination parameters.\n\nHere's how you can approach this:\n\n1. **Define a GET List Operation with Pagination Parameters:**\n   Use query parameters for pagination, such as `skip`, `top`, or a continuation token. For example:\n   \n   ```typespec\n   @route(\"/resources\")\n   op listResources(@query skip?: int32, @query top?: int32): AutoActionResourceListResponse;\n   ```\n   Or, for server-driven pagination:\n   ```typespec\n   @route(\"/resources\")\n   op listResources(@query @continuationToken token?: string): {\n     @pageItems resources: AutoActionResource[];\n     @continuationToken nextToken?: string;\n   };\n   ```\n\n2. **Use the Pagination Decorators:**\n   TypeSpec provides decorators like `@list`, `@pageItems`, `@continuationToken`, etc., to annotate your operation and response model for pagination. This helps generate the correct OpenAPI and SDKs.\n\n3. **Manually Implement the GET Endpoint:**\n   Since `typespec-providerhub` does not generate this GET endpoint for you, you must add it yourself. The controller classes are partial, so you can extend them with your own implementation for the paged GET operation.\n\n4. **Why This Is Needed:**\n   The ARM/ProviderHub controller emitter only emits endpoints for resource actions, not for standard GET list operations with pagination. ARM clients expect a GET endpoint for paging to work automatically.\n\n**Summary Table:**\n\n| Step | Action |\n|------|--------|\n| 1    | Add a GET endpoint for listing resources |\n| 2    | Add pagination query parameters (skip/top or continuationToken) |\n| 3    | Use TypeSpec pagination decorators on operation and response |\n| 4    | Implement the endpoint in your controller |\n\nIf you want ARM/ProviderHub to support this automatically, you may need to request an enhancement to the `typespec-providerhub` package.\n", "context": null, "latency": 13.81828761100769, "response_length": 2267}
{"query": "title: Multiple layers of inheritance for discriminative model\n\nquestion: Like this\n```\n@discriminator(\"discountType\")\nmodel DiscountTypeProperties {\ndiscountType: string;\n}\nmodel DiscountTypeCustomPrice extends DiscountTypeProperties {\ndiscountType: \"CustomPrice\"\n}\nmodel DiscountTypeCustomPriceMultiCurrency extends DiscountTypeCustomPrice {\ndiscountType: \"CustomPriceMultiCurrency\";\n}\n```\nDiscountTypeCustomPriceMultiCurrency is extending DiscountTypeCustomPrice, but these two have different discriminator values. How could I represent it?", "ground_truth": "this is not supported in TypeSpec with the inheritance based discriminator, I think we talked about that in the past and that was an anti pattern.\nYou could use discriminated union to represent that instead but I don' think they will be supported in the same way in emitters for now", "response": "TypeSpec does not support multiple layers of inheritance with different discriminator values using the `@discriminator` decorator and `extends` keyword. Specifically, you cannot have a model hierarchy where each level introduces a new discriminator value for the same property (e.g., `discounttype: \"customprice\"` in one child, and `discounttype: \"custompricemulticurrency\"` in its child).\n\nThis is considered an anti-pattern in TypeSpec's inheritance-based discriminator model. The recommended approach is to use a discriminated union instead, which allows you to represent variants with different discriminator values, but this may not be supported in the same way by all emitters (such as OpenAPI emitters) at this time.\n\n**Summary Table:**\n\n| Approach                | Supported? | Notes                                                                 |\n|-------------------------|------------|-----------------------------------------------------------------------|\n| Inheritance with @discriminator | ❌         | Not supported for multiple layers with different discriminator values |\n| Discriminated union     | ✔️ (partial) | Can represent variants, but emitter support may vary                  |\n\n**Reference Example:**\n\n```typespec\n// Not supported:\n@discriminator(\"discounttype\")\nmodel DiscountTypeProperties {\n  discounttype: string;\n}\nmodel DiscountTypeCustomPrice extends DiscountTypeProperties {\n  discounttype: \"customprice\"\n}\nmodel DiscountTypeCustomPriceMultiCurrency extends DiscountTypeCustomPrice {\n  discounttype: \"custompricemulticurrency\";\n}\n```\n\n**Alternative (Discriminated Union):**\n\n```typespec\n@discriminated(#{ discriminatorPropertyName: \"discounttype\", envelope: \"none\" })\nunion DiscountType {\n  customprice: DiscountTypeCustomPrice,\n  custompricemulticurrency: DiscountTypeCustomPriceMultiCurrency,\n}\n\nmodel DiscountTypeCustomPrice {\n  discounttype: \"customprice\";\n  // other properties\n}\nmodel DiscountTypeCustomPriceMultiCurrency {\n  discounttype: \"custompricemulticurrency\";\n  // other properties\n}\n```\n\n**Note:** Emitter support for discriminated unions may not be complete in all tools.\n\nFor more details, see the references below.", "context": null, "latency": 13.555161476135254, "response_length": 2169}
{"query": "title: Extend ResourceModelWithAllowedPropertySet\n\nquestion: My customer has this resource definition:\n```\n\"Discount\": {\n\"type\": \"object\",\n\"x-ms-azure-resource\": true,\n\"description\": \"Resource definition for Discounts.\",\n\"allOf\": [\n{\n\"$ref\": \"../../../../../common-types/resource-management/v6/types.json#/definitions/ResourceModelWithAllowedPropertySet\"\n}\n],\n\"properties\": {\n\"properties\": {\n\"description\": \"Discount properties\",\n\"x-ms-client-flatten\": true,\n\"$ref\": \"#/definitions/DiscountProperties\"\n}\n}\n}\n```\nI tried this TypeSpec\n```\n@Azure.ResourceManager.Private.armResourceInternal(DiscountProperties)\n@TypeSpec.Http.Private.includeInapplicableMetadataInPayload(false)\nmodel Discount extends Azure.ResourceManager.CommonTypes.ResourceModelWithAllowedPropertySet {\n...ResourceNameParameter<\nResource = Discount,\nKeyName = \"discountName\",\nSegmentName = \"discounts\",\nNamePattern = \"^[a-zA-Z0-9_\\\\-\\\\.]+$\"\n>;\n@doc(\"The resource-specific properties for this resource.\")\n@Azure.ResourceManager.Private.conditionalClientFlatten\nproperties: DiscountProperties;\n}\n```\nError message is: @azure-tools/typespec-azure-resource-manager/arm-resource-invalid-base-type: The @armResourceInternal decorator can only be used on a type that ultimately extends TrackedResource, ProxyResource, or ExtensionResource.\nI don't quite understand this error, since ResourceModelWithAllowedPropertySet does extend TrackedResource. How could I represent that swagger in TypeSpec?", "ground_truth": "We should not use ResourceModelWithAllowedPropertySet.  Instead, we should spread in the appropriate properties using a tracked resource.\nThe ResourceModelWithAllowedPropertySet is meant as an example, not as something resources should use, and so far usage in the specs repo has been incredibly light.  We should not be afraid of this kind of break to make the resulting spec more accurate and easier to evolve over time.", "response": "The error you are seeing is because `ResourceModelWithAllowedPropertySet` is not intended to be used as a base type for ARM resources in TypeSpec. While it may appear to extend `TrackedResource` in some OpenAPI definitions, in TypeSpec, you should use the standard base resource types directly, such as `TrackedResource`, `ProxyResource`, or `ExtensionResource`.\n\nThe recommended approach is to define your resource model using one of these base types and spread in any additional properties you need. For your `Discount` resource, you should use `TrackedResource<DiscountProperties>` (or the appropriate base type) instead of extending `ResourceModelWithAllowedPropertySet`.\n\nHere is how you can model your resource in TypeSpec:\n\n```typespec\nmodel DiscountResource is TrackedResource<DiscountProperties> {\n  ...ResourceNameParameter<DiscountResource, \"discountName\", \"discounts\", \"^[a-zA-Z0-9_\\\\-\\\\.]+$\">;\n}\n```\n\nThis approach ensures compatibility with ARM and the TypeSpec ARM libraries. The `ResourceModelWithAllowedPropertySet` is not meant for direct use in resource definitions and is rarely used in practice.\n\n**Summary:**\n- Do **not** use `ResourceModelWithAllowedPropertySet` as a base type for your resource.\n- Use `TrackedResource<TProperties>` (or `ProxyResource`, `ExtensionResource` as appropriate) and spread in your custom properties.\n\nThis will resolve the error and accurately represent your Swagger definition in TypeSpec.", "context": null, "latency": 10.538838148117065, "response_length": 1442}
{"query": "title: Non-resource long running operation\n\nquestion: [This](https://github.com/Azure/azure-rest-api-specs/blob/4e8d16d3793228046ac6171eadda4b8d26ad2b4f/specification/botservice/resource-manager/Microsoft.BotService/preview/2023-09-15-preview/botservice.json#L1235) is a long running operation, which is not a resource operation. [This](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKdhA5AGB1zUyxTVhcm1Db21tb25U5AIExyrXfcspy1Q1xEhg8gDeYCwKfeYBKEHoASrrAUMg6AJl5AD9bW9kZWwgRW1wbG95ZWUgaXMgVHJhY2tlZOgAgjzIHFByb3BlcnRpZXM%2B5QFZLi7pAKbkAgtQYXJhbWV0ZXLJMT476ACGyV9wyUTSfMpg6QG4QWdlIG9mIGXIP%2BUBrWFnZT86IGludDMyOwrHKUNpdHnSKmNpdHk%2FOiBzdHLlAx7HLFByb2ZpbNNZQGVuY29kZSgiYmFzZTY0dXJsIuQBYHDGMD86IGJ5dGVzyUhUaGUgc3RhdHVzxEt0aGUgbGFzdCDkAMVhdGlvbuUDMSAgQHZpc2liaWxpdHkoTGlmZWN5Y2zkAeBhZMddxCDlA8BTdGF0xGflAavMFOkBSMRzzDLlAIDlAMph6QHVxXdAbHJvxDt1cwp1buQC59FU5QFk5gEaLOwA0shHIGNyZcQncmVxdWVzdCBoYXMgYmVlbiBhY2NlcHRlZMRnICBBxw46ICLICyLWUGnEQOQAtOkAwchE7ACcOiAizA%2FaTHVwZGF0xE%2FFQ1XHDjogIsgLyjvpBNrpAMTmANxk5wGiU3VjY2VlZOUAxckM0z%2FFNuQBTWZhaWzJPkbFDTogIsYJ3Dh3YXMgY2FuY2XKPkPHD%2BQFMscL%2FwFAIGRlbGXpAYBExA3mAPnICyLpA%2F3pA3dtb3bqAcrpA3lNb3ZlUscV6ANyxHNtb3bEaGZyb20gbG9j5gC8xW7EE%2FEDUMszdG%2FPMXRvyi%2F3AJVzcG9uc%2BsEi%2BYAlscW7ACX7gNsxT7FZMZ85gLuzW5pbnRlcmbkBlFP6AOUcyBleHRlbmRz9gcTLsspe30K5QbvyCPKG8tZ6ADN5gSzZ2V05AGnQco15APn7AUQIOcCe09y5QKn5QHWyy9Dxx1SZXBsYWNlQXN5bmPOP%2BUC98g3Q3VzdG9tUGF0Y2jGKwogICDpAJQsxQ72AOhGb3Vu5AMn5AZGyBzmAJJN5AGFyXQs8wWePsZZTHJvSGVhZGVycyA95ACN5QCC6QElxhs8RmluYWxSZXN1bHQgPclMPiAmxUPoAJ7lByruAJN0cnlBZnRlcsZICiAg5QD%2B5gL77wE15QL4ZVdpdGhvdXRPa%2FMBNWxpc3RCecgwR3JvdXDPREzFIlBhcmVudNQ8U3Vic2NyaXDlAtrGO8YzzBnMOegGwSBzYW1wbOsDx2FjxUR0aGF05gLE6QaEdG8gZGlmZmXkAITvA0fFKe4AskHFSFPsAOws7APSyA3mA0nzAJJIRUFE6gatxH5jaGVja%2BoAqmV4aXN0ZW7mCCcgxh5FyRTvArnNHe8IAuwDilTmBG3kBxhyb3V0ZSgiL3PrAUNzL3vMD0lkfS%2FlBi%2FkAmcv6goXQm90U%2BYKcy%2FpAMJy5QJmcy97yRLmAnhJZH3lB8dAZ2V05gOkKOUCfS4uLkFwaecJTOkIveYC3C4uLuwB2UlkyyDFIS8qKsUIIOYEm0lE6ASXyX3kAUjkAvZ0b8RzLscu5AFJICBAcGF0aMUK8QCs6ATB5ACIKTrnAWPlAcM87QHQIHzEHOgHc0xyb8kn8AOYTHJvTOcCTfUDlcRX5Antx1jkA5r%2FA5boA5bkAIVFcnJvcsg%2B5QHu&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%2C%22options%22%3A%7B%22%40azure-tools%2Ftypespec-autorest%22%3A%7B%22omit-unreachable-types%22%3Afalse%2C%22emit-common-types-schema%22%3A%22never%22%7D%7D%7D) is what I wrote in TypeSpec.\n```\n@route(\"/subscriptions/{subscriptionId}/providers/Microsoft.BotService/operationresults/{operationResultId}\")\n@get\nget(\n...ApiVersionParameter,\n...SubscriptionIdParameter,\n/**\n* The ID of the operation result to get.\n*/\n@path\noperationResultId: string,\n): ArmResponse<MoveResponse> | ArmAcceptedLroResponse<LroHeaders = ArmLroLocationHeader<FinalResult = MovedResponse> &\nAzure.Core.Foundations.RetryAfterHeader> | ErrorResponse;\n```\nIt's still not LRO. How could I represent this operation in TypeSpec?", "ground_truth": "long-running GET is not allowed in ARM, or in Azure at all.  We should not support any such operation, this is undoubtedly a mistake, if it appears in any spec.\nIt would be allowed to do a non-resource POST operation, which you might model [like this](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhslfcMlE0nzKYOkBg0FnZSBvZiBlyD%2FlAXhhZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5Pzogc3Ry5QLpxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAWBwxjA%2FOiBieXRlc8lIVGhlIHN0YXR1c8RLdGhlIGxhc3Qg5ADFYXRpb27lAvwgIEB2aXNpYmlsaXR5KExpZmVjeWNs5AHgYWTHXcQg5QOLU3RhdMRn5QGrzBTpAUjEc8wy5QCA5QDKYekB1cV3QGxyb8Q7dXMKdW7kArLRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QSl6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBP3HC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QP96QN3bW926gHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPrBIvmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AYcT%2BgDlHMgZXh0ZW5kc%2FYG3i7LKXt9CuUGusgjyhvLWegAzeYEs2dldOQBp0HKNeQD5%2BwFECDnAntPcuUCp%2BUB1ssvQ8cdUmVwbGFjZUFzeW5jzj%2FlAvfIN0N1c3RvbVBhdGNoU8QqCiAgIOkAkyzFDvYA50ZvdW7kAybkBkXIHOYAkU3kAYTGSdBLyhDqBarFGT4KICDlAJ3mAprvANTlApdlV2l0aG91dE9r8wDUbGlzdEJ5yDBHcm91cM9ETMUiUGFyZW501DxTdWJzY3JpcOUCecY7xjPMGcw56AZgIHNhbXBs6wNmYWPFRHRoYXTmAmPpBiN0byBkaWZmZeQAhO8C5sUp7gCyQcVI5QGWyHcs7ANxyA3mAujqAJJsb25nLXJ1buUF3uQCUOQC9mlzdGlj5Qcy5QJk5ALrxxPGdegH3MZ15gFi5QGadm9pZOYBveQCn8QBLi4uT2vId%2BQBQSAgfcYi7AErxklTY29wZeYB3PABMEhFQUTqBurkARxjaGVja%2BoBSGV4aXN0ZW7mCGQgxh5FyRTvAvbNHe4IPw%3D%3D&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%2C%22options%22%3A%7B%22%40azure-tools%2Ftypespec-autorest%22%3A%7B%22emit-lro-options%22%3A%22all%22%7D%7D%7D)\nBut, in this case, this looks like they are modeling a subscription-level operationResult resource, which should just be modeled as a resource operation get that is not long-running.", "response": "You cannot represent a long-running GET operation in TypeSpec for Azure Resource Manager (ARM) APIs, because ARM and Azure do not allow long-running GETs. This is a fundamental API guideline: long-running operations must not be modeled as GETs, regardless of whether they are resource or non-resource operations. If you see a long-running GET in an OpenAPI spec, it is considered a mistake and should not be supported or modeled in TypeSpec.\n\nIf you need to model a non-resource long-running operation, you should use a POST (or sometimes PUT/PATCH/DELETE) and then use the standard LRO patterns (such as returning a 202 with an Operation-Location or Azure-AsyncOperation header). You can then use the `@pollingOperation` decorator to link the initial operation to its status monitor endpoint, as shown in the examples in the documentation.\n\n**Summary Table:**\n\n| Operation Type         | LRO Allowed? | How to Model in TypeSpec           |\n|-----------------------|--------------|------------------------------------|\n| GET (resource/non-res)| No           | Not supported, do not model as LRO |\n| POST (non-resource)   | Yes          | Use LRO patterns and decorators    |\n\nIf you have a non-resource LRO, model it as a POST and use the LRO helpers and decorators from `@azure-tools/typespec-azure-core`.\n\n> \"long-running GET is not allowed in ARM, or in Azure at all.  We should not support any such operation, this is undoubtedly a mistake, if it appears in any spec. It would be allowed to do a non-resource POST operation, which you might model [like this](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhslfcMlE0nzKYOkBg0FnZSBvZCBlyD%2FlAXhhZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5Pzogc3Ry5QLpxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAWBwxjA%2FOiBieXRlc8lIVGhlIHN0YXR1c8RLdGhlIGxhc3Qg5ADFYXRpb27lAvwgIEB2aXNpYmlsaXR5KExpZmVjeWNs5AHgYWTHXcQg5QOLU3RhdMRn5QGrzBTpAUjEc8wy5QCA5QDKYekB1cV3QGxyb8Q7dXMKdW7kArLRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QSl6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBP3HC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QP96QN3bW926gHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPrBIvmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AYcT%2BgDlHMgZXh0ZW5kc%2FYG3i7LKXt9CuUGusgjyhvLWegAzeYEs2dldOQBp0HKNeQD5%2BwFECDnAntPcuUCp%2BUB1ssvQ8cdUmVwbGFjZUFzeW5jzj%2FlAvfIN0) is what I wrote in TypeSpec.\"\n\nFor more details and examples of correct LRO modeling, see the documentation below.", "context": null, "latency": 28.663994073867798, "response_length": 3172}
{"query": "title: Extending 'Azure.ResourceManager.CommonTypes.ProxyResource' that doesn't define a discriminator.\n\nquestion: Like this. I got warning\n```\nModel 'Employee' is extending 'Azure.ResourceManager.CommonTypes.ProxyResource' that doesn't define a discriminator. If 'Azure.ResourceManager.CommonTypes.ProxyResource' is meant to be used: - For composition consider using spread `...` or `model is` instead. - As a polymorphic relation, add the `@discriminator` decorator on the base model.\n```\nWhy this gets related to discriminator?", "ground_truth": "In general we want to discourage any use of in inheritance if not used with discriminator hence the warning. I assume you have to do this because there is a non standard resource tghat can't do `model is ProxyResource`? If so probably have to suppress that too", "response": "The warning you are seeing is related to TypeSpec's approach to inheritance and polymorphism. In TypeSpec, extending a model (using `extends`) is typically reserved for polymorphic scenarios, where a base model is meant to be used as a parent for multiple derived types. In such cases, a discriminator property (using the `@discriminator` decorator) is required on the base model to help serialization and deserialization frameworks distinguish between the derived types at runtime.\n\nHowever, `azure.resourcemanager.commontypes.proxyresource` does not define a discriminator. When you extend it, TypeSpec warns you because it assumes you might be trying to create a polymorphic relationship, but without a discriminator, this is not supported or recommended. If you are not intending to use polymorphism, you should use composition (with `...` spread or `model is`) instead of inheritance.\n\nTo summarize:\n- If you want polymorphism, add a `@discriminator` to the base model.\n- If you just want to reuse properties, use composition (`...` or `model is`).\n- The warning is there to discourage inheritance without a clear polymorphic intent.\n\nIf you must extend a model without a discriminator (for example, due to a non-standard resource), you may need to suppress the warning.", "context": null, "latency": 7.854297161102295, "response_length": 1275}
{"query": "title: Model validation failures - Newer models introduced in new version adds the parent models in the older version.\n\nquestion: Hi team!\nI am trying to create a new version with a new models only specific to the latest version. I have also added the @added attribute to it.\nDespite this it is adding the models from the parent model - here (Recomendation, MigrationIssues, MigrationSuitability, etc) to all the older versions of the swagger which is not an intended behaviour.\nAdded the model implementation for more context. and adding the PR for a more broader context.\n[WACA changes for assessedWebApps by alphaNewrex · Pull Request #22616 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/22616/files)\n```\n@doc(\"Compound Assessment Recommendations.\")\n@added(WACAApiVersions.v2025_03_30_preview)\nmodel CompoundAssessmentRecommendations\nis Recommendations<\nMigrationIssues,\nMigrationSuitability,\nSkus<MigrationSuitability>\n> {\n@doc(\"Arm id of the assessed resource. to get extended details.\")\nextendedDetailsAssessedResourceArmId: string;\n}\n```", "ground_truth": "Yes, `@added` does not process a tree of models,  any model you introduce will have to be versioned in the same way (so all of those models would need their own `@added` decorators).", "response": "The behavior you're seeing is expected: when you use the `@added` decorator on a model, it only applies to that specific model. If your new model (e.g., `CompoundAssessmentRecommendations`) references other models (like `Recommendations`, `MigrationIssues`, `MigrationSuitability`, etc.), those referenced models will also be included in the generated output for all versions—unless you explicitly version them as well.\n\nTo ensure that these parent or referenced models are only present in the intended (newer) version, you must also decorate each of them with the appropriate `@added` (and/or `@removed`) decorators. The versioning system does not automatically apply versioning to referenced models; it requires explicit annotation for each model you want to restrict to a specific version.\n\n**Recommended approach:**\n- Add `@added` (and/or `@removed`) decorators to all models that should only exist in certain versions, not just the top-level model.\n\n**Example:**\n```typespec\n@added(Versions.v2)\nmodel ParentModel {}\n\n@added(Versions.v2)\nmodel ChildModel is ParentModel {}\n```\n\nThis ensures that both `ParentModel` and `ChildModel` are only present in version 2 and later.\n\n**Summary:**\n- The `@added` decorator does not automatically apply to referenced or parent models.\n- You must explicitly version all models you want to restrict to a specific API version.\n\nFor more details, see the references below.", "context": null, "latency": 9.503723859786987, "response_length": 1410}
{"query": "title: Duplicate Example files for Typespec and other for Swagger. By design?\n\nquestion: Following folder have same 54 files of example json. Is it by design?\n- specification\\apicenter\\ApiCenter.Management\\examples\\2024-06-01-preview\n- specification\\apicenter\\resource-manager\\Microsoft.ApiCenter\\preview\\2024-06-01-preview\\examples", "ground_truth": "Yes.  The example files in the OpenAPI directory are automatically copied when you compile the spec, they are essentially part of the emitted OpenAPI", "response": "Yes, this is by design. The example JSON files are duplicated between the TypeSpec source folder and the Swagger (OpenAPI) folder because the TypeSpec compiler automatically copies example files from the TypeSpec source directory to the Swagger output directory when you compile the spec. This ensures that the examples are included in the emitted OpenAPI specification and remain consistent between the source and the generated API documentation.\n\nIf you need to update an example, you should modify it in the TypeSpec source folder and then re-run the TypeSpec compiler (`tsp compile`). The updated example will then be copied to the Swagger folder automatically.", "context": null, "latency": 6.844109058380127, "response_length": 665}
{"query": "title: Override contentType: \"application/json\" for ResourceCreateOrUpdate\n\nquestion: Hi TypeSpec Discussion,\nI am migrating an old swagger to typespec. I came across a method which is a PATCH ops with a application/json as content type. The API behaves exactly as a merge-patch route, but I cannot change it since it'll be consider a breaking change. In order to still use the convenient functionalities of typespec traits, I have define a custom function like so [playground](https://azure.github.io/typespec-azure/playground/?c=Ly8gLd8B3wHdAQovLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIMUlcyByZXNlcnZlZC7EPUxpY2Vuc2VkIHVuZGVyIHRoZSBNSVTIFy4gU2VlyQ10eHQgaW7FJHByb2plY3Qgcm9vdCBmb3IgbMYkIGluZm9ybcZ1xGD%2FAMDfAd4BCgppbXBvcnQgIkB0eXBlc3BlYy9yZXN0IjvTGXZlcnNpb25pbmfVH2h0dHDVGW9wZW5hcGnMHGF6dXJlLXRvb2xzL8goLcYVY29yZSI7Cgp1c2luZyBUeXBlU3BlYy5IdHRwO9AVUmVzdMgVQcQ%2BLkNvcmXSEi5UcmFpdHM7CgpuYW1lc3BhY2XGHjsKCiNzdXBwcmVzc%2F8Al29yZS9uby1wcml2YXRlLXVzYWdlIiAiIgpARm91bmTlAbBzLlDGHy5lbnN1cmVWZXJiKCJSZXNvdXJjZUNyZWF0ZU9yVXBkYXRlIiwgIlBBVENIIikKQGPFG3PIHHPIMyjICSkKQHBhcmFtZXRlclZpc2liaWxpdHkoTGlmZWN5Y2xlLsZdLCDKEsZLxTl0Y2gKb3Ag9gCJV2l0aEpzb25Db250ZW505AFdPAogyS0gZXh0ZW5kc%2BwBdmZsZWPlAqBNb2RlbCwKICDmAWHfLGRlbCA9IHt9xDFJbnRlcmZhY2XfOtI6RXJyb3JSZXNwb%2BQDLj3sAefsAYrNJwo%2BIGlz2CroAOpPcGXmA%2BzsAP%2FEcnsKICAgIC8qKsUIICogVGhlIOQCSiBvZu0DzHRvIHVzZS7HJy%2FFCEBkb2MoIlRoaeQEN3F1ZXN0IGhhcyBhIEpTT04gYm9keS4iKcYq7QLtLmhlYWRlcigi5wGYLcQexypj6gGrOiAiYXBwbGlj5QC6L2pzb27kAz7EJi4u9QDnQm9keTzIDT47yCvxAy7pAszFD1Byb3BlcnRpZXPkAR7EAcYmICbwAcvkATLJIExv5gCZLlDoAr7OIOUA3Xh05wK%2FIHzOFuYCocUw5QCp5QIA%2FwHGxkpkT3JPa%2BgB%2FukA7iAmxUz%2FAOv%2FAOv%2FAOtu5ACKxXf%2FAOn4AOk%2B6wNQ1XLvAto7Cg%3D%3D&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D) and am using it.\nIs there a better alternative?", "ground_truth": "Yes. it's expected that if you are using a non-standard content-type for PATCH you will need to use a custom operation or a custom operation template.", "response": "You are following the correct approach. When you need to override the default content type for a PATCH operation (for example, using `application/json` instead of the standard `application/merge-patch+json`), you must define a custom operation or operation template in TypeSpec. This is necessary because the built-in merge-patch helpers in TypeSpec automatically set the content type to `application/merge-patch+json` and apply merge-patch semantics, which would be a breaking change for your API.\n\nThere is no built-in TypeSpec trait or decorator to override the content type for the standard resource PATCH operation templates. The recommended and expected solution is to define your own operation, specifying the content type as needed. This allows you to retain the convenient traits and patterns from TypeSpec, while matching your legacy API's requirements.\n\nIn summary: **Defining a custom operation is the best and expected alternative when you need to use a non-standard content type for PATCH.**", "context": null, "latency": 7.421860456466675, "response_length": 1005}
{"query": "title: Customizing key for child operation\n\nquestion: Is there a way to customize the key of a parent resource for a specific child operation?\nIn SDKs we are being asked to change the name, but I couldn't find a good place to apply the `@clientName` decorator.", "ground_truth": "In the data plane API, resource keys are typically derived from the parent resource’s key and are not individually specified for each operation. By default, the key names for operations are inherited from the parent resource's key. The @clientName decorator is used to modify the name used by the client, not to change the parent resource's key in operations. To change the parent resource's key name globally, the simplest solution is to use the @key decorator on the name property to ensure consistency.\nChanging the key name specifically for certain operations is not straightforward because operation keys are typically tied to the parent resource key. Although you can explicitly define different keys for an operation, this generally requires redefining the operation.\nIn your case, the most reasonable approach would be to update the parent resource's key name to jobName across all operations to maintain consistency rather than using a different name for some operations. This approach reduces naming conflicts and ensures consistency.\nFor how to explicitly specify key definitions, you can refer to the Azure Data Plane documentation, which outlines how to define keys for each service's operations and resources.", "response": "In TypeSpec, the key for a parent resource (i.e., the path parameter name) is defined using the `@key` decorator on the resource model's property. This key name is then used in all operations involving that resource, including child operations. There is no built-in way to customize the parent resource's key name for only a specific child operation; the key name is global to the resource definition.\n\nThe `@clientName` decorator is used to change the name of the parameter or model in the generated SDKs, but it does not affect the wire format or the path parameter name in the API route. If you want to change the key name for all operations, you should update the `@key` decorator on the parent resource's property. If you need to change the name only in the SDK (not on the wire), you can use `@clientName` on the parameter or model.\n\nIf you need to customize the request body parameter name for a specific operation, you can use the `@@clientName` augment decorator on the operation's parameter, but this does not apply to path keys.\n\n**Summary Table**:\n\n| What you want to change                | How to do it                |\n|----------------------------------------|-----------------------------|\n| Path parameter name (on the wire)      | Use `@key` on resource      |\n| SDK parameter/model name (in client)   | Use `@clientName` decorator |\n| Request body parameter name (per op)   | Use `@@clientName` augment  |\n\nFor child resources, the parent key is always inherited from the parent resource's `@key` definition. There is no supported way to override this for only some operations.\n", "context": null, "latency": 10.161427736282349, "response_length": 1598}
{"query": "title: Default value starting from a specific API version?\n\nquestion: Hello, we currently have a property (StatelessServiceProperties,minInstancePercentage) that does not currently have a default value in our spec, but in practice is treated as if it is 0.\n[azure-rest-api-specs/specification/servicefabricmanagedclusters/resource-manager/Microsoft.ServiceFabric/preview/2025-03-01-preview/servicefabricmanagedclusters.json at main · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/servicefabricmanagedclusters/resource-manager/Microsoft.ServiceFabric/preview/2025-03-01-preview/servicefabricmanagedclusters.json)\nWe would like to treat the default prior to 2025-06-01 as 0, then as a different value from 2025-06-01 onward in our service.\n1. We haven't changed the default for an existing property before. Are there concerns about this intended behavior?\n2. In Typespec, is it possible to add a default value in our spec from a specific api version (say 2025-06-01) onward?", "ground_truth": "I think you need to run this change by the breaking change board, as a change in the default may be breaking, depending on the details.  Also, the most important thing is to make sure that the API description accurately reflects service behavior - if the default has always been in place, for example, it may be better to just change the default and go through the breaking change process.  Yes, it is possible to do this in TypeSpec, but involves removing and renaming the old property and adding a new property with the new default, [like this](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjQtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCu0AxTH%2FAMX%2FAMX%2FAMX%2FAMX%2FAMXtAMXsAKntAMU1LTAzLTAx%2FwC9%2FwC9%2FwC9%2FwC9%2FgC95wChYCwKfeYCbUHoAm%2FrAogg6AOq5ADAbW9kZWwgRW1wbG95ZWUgaXMgVHJhY2tlZMh6PMgcUHJvcGVydGllcz7lAp4uLukAnuQDUFBhcmFtZXRlcskxPjvoAIbJX3DJRNJ8ymDpAv1BZ2Ugb2YgZcg%2F5gFwcmVtb3brA4Au9AG35QFacmXkA5pkRnJvbd4uLCAiYWdlIsQ1Zm9ybWVyQWdlPzogaW50MzI76AIB9gCOYWRk%2FwCM5QCMYcpRID0gMjHJVkNpdHnSV2NpdHk%2FOiBzdHLlBR7HLFByb2ZpbPQAhmVuY29kZSgiYmFzZTY0dXJs5QDMcMYwPzogYnl0ZXPJSFRoZSBzdGF0dXPES3RoZSBsYXN0IOQBgGF0aW9u5QUxICBAdmlzaWJpbGl0eShMaWZlY3ljbOQCk2Fkx13EIOUFwFN0YXTEZ%2BUCZswU6QIDxHPMMuUAgOUAymHpApDFd0Bscm%2FEO3VzCnVu5ANl0VTlAh%2FmARrpA53EX8hHIGNyZcQncmVxdWVzdCBoYXMgYmVlbiBhY2NlcHRlZMRnICBBxw46ICLICyLWUGnEQOQAtOkAwchE7ACcOiAizA%2FaTHVwZGF0xE%2FFQ1XHDjogIsgLyjvpBtrpAMTmANxk5wGiU3VjY2VlZOUAxckM0z%2FFNuQBTWZhaWzJPkbFDTogIsYJ3Dh3YXMgY2FuY2XKPkPHD%2BQHMscL%2FwFAIGRlbGXpAYBExA3mAPnICyLpBLjpBDLkA%2BvpAcrpBDRNb3ZlUscV6AQtxHNtb3bEaGZyb20gbG9j5gC8xW7EE%2FEDUMszdG%2FPMXRvyi%2F3AJVzcG9uc%2BsFRuYAlscW7ACX7gNsxT7FZMZ85gLuzW5pbnRlcmbkCFFP6AOUcyBleHRlbmRz9gkTLsspe30K5QjvyCPKG8tZ6ADN5gVuZ2V05AGnQco15APn7AXLIOcCe09y5QKn5QHWyy9Dxx1SZXBsYWNlQXN5bmPOP%2BUC99A3UGF0Y2hTzCws8wYRxUDmAj3PQOUCOmVXaXRob3V0T2vTd2xpc3RCecgwR3JvdXDPREzFIlBhcmVudNQ8U3Vic2NyaXDlAhzGO8YzzBnMOegGMCBzYW1wbOsDCWFjxUR0aGF05gIG6QXGdG8gZGlmZmXkAITvAonFKe4AskHFSO8BN%2BsDFMgN5gKL8wCSSEVBROoF78R%2BY2hlY2vqAKpleGlzdGVu5ggkIMYeRckU7wH7zR3uB%2F8%3D&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D)", "response": "1. **Concerns about changing the default value:**\nChanging the default value for an existing property can be considered a breaking change, depending on how clients rely on the previous default. It's important to review this change with your breaking change review board and ensure that your API documentation accurately reflects the new behavior. If the default has always been in place (even if not documented), it may be better to update the spec and go through the breaking change process to maintain clarity and consistency for clients.\n\n2. **Specifying a default value from a specific API version in TypeSpec:**\nTypeSpec does not support conditional defaults on a property based on API version within a single property definition. The recommended approach is to version your model: for the new API version, you can introduce a new model (or property) with the updated default value. This typically involves removing or renaming the old property/model and adding a new one with the new default. This ensures that each API version's schema accurately reflects the intended default value for that version.\n\n**Summary Table:**\n\n| Concern                | Recommendation                                                                 |\n|------------------------|-------------------------------------------------------------------------------|\n| Changing default value | Review with breaking change board; update documentation to match behavior      |\n| Versioned defaults     | Use model/property versioning; define new default in new API version's model   |\n\nFor more details and an example, see the linked TypeSpec playground and guidance below.", "context": null, "latency": 13.343743562698364, "response_length": 1648}
{"query": "title: Does TypeSpec support example generation for new added versions?\n\nquestion: Hi team, when adding a new api version in the TypeSpec, is there any way I can generate thoes example Json files from preview version and with the \"api-version\" property changed? Or I will need to manually cope the example Json files from preview version and update the \"api-version\" property inside all of them?", "ground_truth": "Example generation for specs works the same way as it did before.\nYou will need to place version specific examples under `examples\\[version]`. So if you are adding a new version, you can copy over the example files and make appropriate add/remove/update to them including the `api-version`\nNote that you can also use swagger-based example generation, for the new version (which is less attractive if you have customized the examples)", "response": "When adding a new API version in TypeSpec, there is currently no built-in feature to automatically generate example JSON files for the new version by copying them from a previous version and updating the \"api-version\" property. The recommended approach is to manually copy the example files from the preview (previous) version into the new version's example directory (e.g., `examples/[version]`), and then update the `api-version` property inside each file as needed.\n\nAlternatively, if you are using Swagger-based example generation, you can regenerate examples for the new version, but this is less attractive if you have customized your examples.\n\nIn summary, you will need to manually copy and update your example files for each new API version.", "context": null, "latency": 7.097652435302734, "response_length": 750}
{"query": "title: Description changes across versions?\n\nquestion: Hi, as part of this PR: [Service Fabric Managed Clusters - API version 2025-03-01-preview · Azure/azure-rest-api-specs@599e269](https://github.com/Azure/azure-rest-api-specs/actions/runs/14090043123/job/39464153437?pr=33332)\nMy team wanted to add more details to a model description. This change results in a change in all spec versions generated with Typespec, and causes the Typespec validation to fail if I don't include the changes to the older specs.\nI wanted to know what the best course of action was for passing this check. Since we don't expect updates to our older specs, is it ok to just change the output path in our tspconfig.yaml to only point at the current version of the output spec? Or is there a better way to handle this?", "ground_truth": "Honestly, the best thing is to update your docs and take the update in previous versions (which are likely now more accurately described as well). Documentation-only updates should not be flagged as breaking changes at all. If they are for some reason, I'll just approve it.", "response": "The recommended approach is to update the model descriptions in all versions, including older specs. Documentation-only updates (such as improving descriptions) should not be considered breaking changes, and it's generally best practice to keep documentation accurate across all versions. If your validation is failing due to these description changes, you should update the older specs as well to reflect the improved documentation. \n\nIf, for some reason, you cannot or do not want to update older specs, changing the output path in your tspconfig.yaml to only generate the current version is technically possible, but it's not the preferred solution. Maintaining accurate and consistent documentation across all versions is better for long-term maintainability and clarity.\n\nIn summary: update your docs in all versions. If your process flags this as a breaking change, it should be approved since it's documentation-only.", "context": null, "latency": 7.231688499450684, "response_length": 924}
{"query": "title: Typespec Validation issue\n\nquestion: I've a PR where the Typespec validation is failing with some weird error. This is not being reproduced locally -\n```\nspecification/storagedatamanagementrp/Private.StorageDataManagement.Management/main.tsp:17:10 - error expect-value: Is a model expression type, but is being used as a value here. Use #{} to create an object value.\n53  > 17 | @service({\n54       |          ^\n55  > 18 |   title: \"Storage Data Management Resource Provider\",\n56       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n57  > 19 | })\n58       | ^^\n```\n```\nspecification/storagedatamanagementrp/Private.StorageDataManagement.Management/Connectors/connectorModels.tsp:19:15 - error invalid-argument: Argument of type '\"read\"' is not assignable to parameter of type 'valueof EnumMember'\n60  > 19 |   @visibility(\"read\")\n61       |               ^^^^^^\n```\nI'm not sure how to resolve this error. Could someone please help here?\n[Update Connector and DataShare Swagger by ujjawaljain-msft · Pull Request #21997 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/21997)", "ground_truth": "You may need to update to the latest typespec version - some of these particular properties have changed in a recent version. What you are using here isn't the latest style to specify these things.\nDoc for future reference: https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally", "response": "The errors you're seeing are likely due to changes in TypeSpec syntax and validation rules in recent versions. Specifically:\n\n1. **Error: 'is a model expression type, but is being used as a value here. use #{} to create an object value.'**\n   - This means that when using decorators like `@service`, you now need to use the object value syntax (`#{ ... }`) instead of a plain object literal. For example:\n     \n     ```typespec\n     @service(#{\n       title: \"Storage Data Management Resource Provider\"\n     })\n     ```\n\n2. **Error: 'argument of type '\"read\"' is not assignable to parameter of type 'valueof enummember''**\n   - This suggests that the `@visibility` decorator now expects an enum member, not just a string literal. You should check the definition of the enum used for visibility and use the correct enum member, e.g. `@visibility(Visibility.read)` instead of `@visibility(\"read\")`.\n\n**Resolution:**\n- Update your TypeSpec code to use the latest syntax as described above.\n- Make sure your local TypeSpec version matches the one used in CI, as differences can cause validation to pass locally but fail in CI.\n\nFor more details and troubleshooting, see the [TypeSpec Validation guide](https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally).", "context": null, "latency": 8.100935220718384, "response_length": 1286}
{"query": "title: Seeking Guidance on Defining ResourceStatusCode in TypeSpec\n\nquestion: Hello\nTypeSpec Discussion\nI am working on defining a `ResourceStatusCode` in TypeSpec, which is similar to HTTP status codes but specific to resource states. I would appreciate your guidance on the following:\n1. Should I use an `enum` or a `int` to define the `ResourceStatusCode`?\n2. What are the best practices for defining status codes in TypeSpec?\n3. How can I ensure that the `ResourceStatusCode` remains extensible for future updates?\nI want to add statuses like:\n- `NotSpecified: 204 No Content` - This indicates that the request was successful, but there is no content to return.\n- `Pending: 102 Processing` - This indicates that the server has received and is processing the request, but no response is available yet.\n- `Running: 202 Accepted` - This indicates that the request has been accepted for processing, but the processing has not been completed.\n- `Succeeded: 200 OK` - This indicates that the request has succeeded.\n- `Failed: 500 Internal Server Error` - This indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.\nThank you for your assistance.", "ground_truth": "As per one of our previous understanding, we defined similarly as an open union: [azure-rest-api-specs-pr/specification/impact/Impact.Management/connectors.tsp at RPSaaSMaster · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/blob/RPSaaSMaster/specification/impact/Impact.Management/connectors.tsp#L88-L94).  This explicitly allows any string value.\nGenerally, the reason for doing this is that you think additional values will be enabled in future versions (or even in this version).  Note that, if you do not make this an open union, then adding any values in any future api-version would be a breaking change (which is why this is recommended).\nThere are RPaaS extensions for validation that would allow you to reject requests for values that are not valid.", "response": "Hello! Great questions about defining a `ResourceStatusCode` in TypeSpec. Here are recommendations based on best practices and extensibility:\n\n1. **Enum vs. int**: For resource status codes that are conceptually distinct states (like `Pending`, `Running`, `Succeeded`, etc.), it's best to use an `enum` or a union of string literals, rather than raw integers. This makes your API more readable and self-documenting. You can map these states to HTTP status codes in your response models, but the resource status itself should be a descriptive value.\n\n2. **Best Practices**: \n   - Use enums or open unions of string literals for status codes that represent resource states. This is both clear and extensible.\n   - If you expect to add more statuses in the future, define your enum or union as an open union (allowing additional values), which avoids breaking changes when extending.\n   - Use the `@statusCode` decorator to specify HTTP status codes in your response models, but keep resource state as a separate property.\n\n3. **Extensibility**: To ensure extensibility, define your status as an open union (not a closed enum). This allows new values to be added without breaking existing clients. For example:\n\n```typespec\n// Open union for extensibility\nmodel Resource {\n  status: \"NotSpecified\" | \"Pending\" | \"Running\" | \"Succeeded\" | \"Failed\" | string;\n}\n```\n\nOr, if you want to use an enum for stricter control (but less extensible):\n\n```typespec\nenum ResourceStatusCode {\n  NotSpecified: \"NotSpecified\",\n  Pending: \"Pending\",\n  Running: \"Running\",\n  Succeeded: \"Succeeded\",\n  Failed: \"Failed\",\n}\n```\n\nBut note: adding new values to a closed enum is a breaking change. Open unions are preferred for evolving APIs.\n\n**Mapping to HTTP Status Codes**: In your operation responses, use the `@statusCode` decorator to specify the HTTP status code, and include your resource status as a property in the response model.\n\n| Resource Status   | HTTP Status Code |\n|------------------|-----------------|\n| NotSpecified     | 204             |\n| Pending          | 102             |\n| Running          | 202             |\n| Succeeded        | 200             |\n| Failed           | 500             |\n\n**Summary Table:**\n\n| Approach         | Extensible | Self-Documenting | Recommended |\n|------------------|------------|------------------|-------------|\n| Open Union       | Yes        | Yes              | Yes         |\n| Closed Enum      | No         | Yes              | Sometimes   |\n| Raw int          | No         | No               | No          |\n\nFor more details and examples, see the references below.", "context": null, "latency": 12.278796195983887, "response_length": 2604}
{"query": "title: Update API definition in typespec-providerhub\n\nquestion: Hi team, I'm using [providerhub template](https://armwiki.azurewebsites.net/rpaas/gettingstarted.html#bootstrap-your-development-with-typespec-formerly-cadl) to generate a new RP, when trying to add custom API(simple health check for testing) in main.tsp, after build it doesn't generate the new model and controllers that I added, does the template have restrictions on what kind of APIs can be added? Here's what I tried to add into typespec.\n```\n// Add the health check operation\n@doc(\"Health check endpoint to verify the service is running.\")\nmodel HealthCheckResponse {\nmessage: string;\n}\ninterface HealthCheck {\n@get\n@route(\"/api/healthcheck\")\n@doc(\"Returns a simple message indicating the service is running.\")\nhealthCheck(): HealthCheckResponse;\n}\n```", "ground_truth": "Yes, the emitter is specifically about generating RPaaS extensions, not about generating APIs.  You should be able to generate the model, however from your spec.\nThe emitter only updates a specific set of folders, so you can write your own controllers for any APIs outside of generated extensions, and just be sure not to place them in the folder with generated artifacts.", "response": "Yes, the providerhub TypeSpec template and its emitter are specifically designed to generate RPaaS (Resource Provider as a Service) extensions, not arbitrary custom APIs. This means that while you can define new models in your TypeSpec (such as your `HealthCheckResponse`), the emitter will only generate code for a specific set of folders and patterns related to RPaaS extensions. Custom APIs like your health check endpoint will not have controllers or models generated automatically if they fall outside the supported RPaaS extension patterns.\n\nYou can still add your own controllers and implementation for custom APIs, but you should place them outside the folders managed by the code generator to avoid them being overwritten or ignored. The template does not restrict you from defining custom APIs in TypeSpec, but the code generation process is limited to the RPaaS extension surface.\n\nIf you want to generate code for new interfaces (like your health check), you may need to manually scaffold or implement those controllers, as the emitter will not handle them automatically.", "context": null, "latency": 7.489595890045166, "response_length": 1083}
{"query": "title: How to properly update the TypeSpec environment?\n\nquestion: I tried inferring steps from the various installation documents but just managed to break my environment and have no idea how to fix it.\nI saw a recent post where it was said to run `npm install -g @typespec/compiler` to get the latest (0.66) but it looks like it did not work for me. My compiler is still 0.64.\n```\nNORTHAMERICA+darkoa@darkoa-ws MINGW64 /d/Dev/Projects/git/github/azure-rest-api-specs-pr (RPSaaSMaster)\n$ npm install -g @typespec/compiler\nchanged 268 packages in 11s\n34 packages are looking for funding\nrun `npm fund` for details\nNORTHAMERICA+darkoa@darkoa-ws MINGW64 /d/Dev/Projects/git/github/azure-rest-api-specs-pr (RPSaaSMaster)\n$ tsp compile specification/deviceupdate/DeviceUpdate.Edge.Management/\nTypeSpec compiler v0.64.0\nDiagnostics were reported during compilation:\n```\nI get a bunch of errors, although we made no changes recently. I am guessing those changes were made by the TypeSpec team and I am also guessing that if I manage to properly update tools, the errors should go away.\nSo, is there a single document that describes how to update the environment to the latest?", "ground_truth": "The issue you're facing is related to updating your local TypeSpec environment. Here's a summary of the solution:\nUpdate Local Dependencies:\nRunning npm install -g @typespec/compiler only updates the global TypeSpec compiler, which is not typically used for local development unless you need access to TypeSpec commands globally.\nTo properly update your local environment, navigate to your repository and run npm ci. This command installs the exact versions of dependencies specified in the package-lock.json, ensuring consistency.\nTypeSpec Versions in Repositories:\nWhen working with repositories like azure-rest-api-specs, you should always install dependencies based on the local package.json and package-lock.json at the root of your branch. This ensures you're using the correct version of TypeSpec and associated tools for your current project.\nDealing with Configuration Warnings:\nThe warnings you're seeing (such as missing options for SDK emitters) are configuration-related, not errors. These warnings appear when SDK emitters for specific languages (like Go, Python, C#) are not installed, but they do not affect your immediate work with TypeSpec validation. These can be safely ignored unless you need to work with SDK generation.\nSuppression and Documentation:\nIf you want to suppress specific warnings, you can modify the suppressions.yaml file, but it's important to follow the TypeSpec guidelines to ensure proper environment configuration.", "response": "To properly update your TypeSpec environment, it's important to distinguish between global and local installations:\n\n**Recommended Approach:**\n\n1. **Update Local Dependencies:**\n   - Navigate to your project directory (where your `package.json` is located).\n   - Run `npm ci` to install the exact versions specified in your `package-lock.json`. This ensures consistency and avoids version mismatches.\n\n2. **Global Installation:**\n   - Running `npm install -g @typespec/compiler` updates the global TypeSpec CLI, but your project may still use a locally installed version specified in its dependencies. The CLI you invoke (`tsp`) may be using the local version if present.\n\n3. **Check Your Version:**\n   - Run `npx tsp --version` in your project directory to see which version is being used locally.\n   - If you want to update to the latest version, update the `@typespec/compiler` version in your `package.json`, then run `npm install`.\n\n4. **Dealing with Warnings:**\n   - Some warnings (like missing SDK emitters) are configuration-related and can be safely ignored unless you need those features.\n\n**Summary Table:**\n\n| Step                        | Command                                  | Purpose                                      |\n|-----------------------------|------------------------------------------|----------------------------------------------|\n| Update global CLI           | npm install -g @typespec/compiler        | Updates global TypeSpec CLI                  |\n| Update local dependencies   | npm ci                                   | Installs exact versions from package-lock    |\n| Update local TypeSpec       | Edit package.json, then npm install      | Updates project-specific TypeSpec version    |\n| Check TypeSpec version      | npx tsp --version                        | Shows local TypeSpec version                 |\n\nFor more details, see the official [TypeSpec Documentation](https://typespec.io/docs/).\n\nIf you want to suppress specific warnings, you can modify the `suppressions.yaml` file, but always follow TypeSpec guidelines for environment configuration.", "context": null, "latency": 11.095100164413452, "response_length": 2098}
{"query": "title: How to restrict importing typespec files in main based off of versions.\n\nquestion: Hi Team,\nWe have 2 imports in our main.tsp to include other resource type tsp files, however we do not want to include one of the resourcetype to the new api version we want to introduce.  Is there a way to do conditional imports based off of version in main?\nThank you in advance!", "ground_truth": "no, you have to mark the models/types and everything that you want to remove with the @removed decorator using the versioning library\nif you are in preview version I think also the policy is to only have a single preview version in the spec repo at the timme now so you could also just delete it", "response": "No, TypeSpec does not support conditional imports in your `main.tsp` file based on API version. All imports are static and resolved at compile time, regardless of version. \n\nIf you want to exclude certain resource types from a new API version, the recommended approach is to use the `@removed` decorator from the versioning library on the models, types, or operations you want to remove for that version. This way, the types will be excluded from the generated output for the specified version, but the import itself remains in place.\n\nIf you are working with preview versions and want to completely remove a resource type, you may also consider deleting the relevant files or imports, but this is only practical if you are not maintaining multiple versions in the same repo.\n\n**Summary:**\n- Conditional imports based on version are not supported.\n- Use `@removed` (or `@added`) decorators to control type/resource visibility per version.\n\nLet me know if you need an example of how to use the `@removed` decorator!", "context": null, "latency": 8.677059173583984, "response_length": 1014}
{"query": "title: Brownfield TypeSpec migration\n\nquestion: Hi, Is there a timeframe for existing brownfield RPs to move from OpenAPI swagger to TypeSpec.  Is it possible to mix TypeSpec with handwritten swagger and migrate in phases. Say for example migrate one resource type at a time to minimize risk.", "ground_truth": "Migration to TypeSpec for existing services is not yet mandatory, but it is suggested, and teams should be planning for it in Bromine and Krypton\nServices must wholly switch to TypeSpec, there is no allowed mixing of hand-written and generated swagger\nServicesmust conform to a single, unified api-version for their service, servicesthat currently use different api-versions for parts of their service are going to need to plan for conformance -this either means SDK splitting or version uniformity.  Teams that use this 'different api-versions for different resources in the same sdk' pattern are not good candidates for conversion at the moment\nIn generally, the more compliant your service is to the RPC and best practices, the easier conversion will be\nThere is documentation on converting here: [Getting started | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started/)\nWe highly encourage you do the migration. Any problem related to https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started/, don't hesitate to reach out to me.", "response": "Currently, migration to TypeSpec for existing (brownfield) resource providers (RPs) is not mandatory, but it is strongly encouraged and teams should be planning for it, especially in Bromine and Krypton. Importantly, services must fully switch to TypeSpec—mixing TypeSpec with handwritten Swagger (OpenAPI) is not supported. This means you cannot migrate one resource type at a time or phase the migration by mixing both approaches within the same service. The migration must be done as a complete switch for the entire service to a unified API version. If your service currently uses different API versions for different resources, you will need to plan for version uniformity or SDK splitting before migrating.\n\nFor guidance on the migration process and tooling, see the official documentation and migration tool instructions. If you encounter issues, you are encouraged to reach out for support.\n\nRecommended next steps:\n- Plan for a full migration rather than a phased, mixed approach.\n- Review your service for API version uniformity.\n- Use the provided migration tools and documentation to assist with the process.\n\nFor more details and migration steps, refer to the documentation below.", "context": null, "latency": 8.93938136100769, "response_length": 1193}
{"query": "title: Setting default value for a union type for only some API versions\n\nquestion: Hi team,\nIs it possible to set default value for a union type for only some API versions?\nFor below union type, I want to set default value as ApprovalStatus.Pending from API version 2024-12-01-preview onwards. Is this possible?\n```\n@doc(\"Approval Status Enum\")\nunion ApprovalStatus {\n@doc(\"ApprovalStatus Type Approved\")\nApproved: \"Approved\",\n@doc(\"ApprovalStatus Type Rejected\")\nRejected: \"Rejected\",\n@doc(\"ApprovalStatus Type Pending\")\nPending: \"Pending\",\n@added(Microsoft.Mission.Versions.v2024_11_01_preview)\n@doc(\"ApprovalStatus Type Deleted\")\nDeleted: \"Deleted\",\n@added(Microsoft.Mission.Versions.v2024_11_01_preview)\n@doc(\"ApprovalStatus Type Expired\")\nExpired: \"Expired\",\nstring,\n}\n```", "ground_truth": "From a purely \"what is the TypeSpec syntax for assigning a default value to a type\", no, I don't think we have any way of doing this. You can create a reusable property that you can spread into various places if that is what you are trying to accomplish.\nFrom a service API design perspective, what actually changed between the API versions? The pending status was already there in older API versions. Presumably the property that had a type of ApprovalStatus always created things in a pending state (it looks like this is a type that would be used in a persisted model/resource). Wasn't that always conceptually pending?\nI think that shouldn't a problem on the breaking change part.", "response": "No, currently TypeSpec does not support assigning a default value to a union type (or its variants) for only some API versions. There is no built-in syntax or mechanism to conditionally set a default value based on API version. You can set default values for model properties (e.g., `status?: ApprovalStatus = ApprovalStatus.Pending;`), but this default applies to the property itself, not to the union type, and cannot be versioned directly.\n\nIf you need different defaults for different API versions, you would need to manage this in your service implementation or by duplicating models for each version and setting the default accordingly. There is no TypeSpec language feature to express a versioned default value for a union or enum.\n\n> \"From a purely 'what is the TypeSpec syntax for assigning a default value to a type', no, I don't think we have any way of doing this. You can create a reusable property that you can spread into various places if that is what you are trying to accomplish.\"\n\nFor more on how default values work for model properties, see the references below.", "context": null, "latency": 8.004889011383057, "response_length": 1083}
{"query": "title: Readonly on model\n\nquestion: We have such swagger\n```\n\"ReadonlyOnModel\": {\nreadonly: true,\nproperties: {}\n},\n\"AnotherModel\": {\nproperties: {\n\"a\": {\n$ref: \"ReadonlyOnModel\"\n}\n}\n}\n```\nWhen the type of property \"a\" in another model is that \"ReadonlyOnModel\", M4 will give a readonly on that property \"a\". I want to confirm if the equivalent TypeSpec should be\n```\nmodel AnotherModel {\n@visibility(Lifecycle.Read)\na: ReadonlyOnModel;\n}\nmodel ReadonlyOnModel {}\n```\ncc Alitzel Mendez : Common type replacement relates to this. I remember we have several models in the original common type have readonly on them and you removed these because TypeSpec cannot represent readonly on model. Then if any service refers to this model, those properties might need to be updated.", "ground_truth": "TypeSpec can only attach readOnly to properties, not to models or scalars.  Functionally (assuming all references to ReadOnlyModel are through readOnly properties),  these Swagger docs are equivalent, see: [autorest/docs/openapi/howto/$ref-siblings.md at main · Azure/autorest](https://github.com/Azure/autorest/blob/main/docs/openapi/howto/%24ref-siblings.md) from the perspective of both TypeSpec and autorest, these descriptions are equivalent.", "response": "TypeSpec does not support marking an entire model as readOnly; it only supports marking individual properties as readOnly (using `@visibility(Lifecycle.Read)`). In your Swagger example, the `readonly: true` on the model means that any property referencing this model will be treated as readOnly. In TypeSpec, you must apply `@visibility(Lifecycle.Read)` to the property itself, not to the model. So your TypeSpec equivalent should be:\n\n```typespec\nmodel AnotherModel {\n  @visibility(Lifecycle.Read)\n  a: ReadonlyOnModel;\n}\nmodel ReadonlyOnModel {}\n```\n\nThis approach is correct and matches the intended semantics. If you have models in your common types that were previously marked as readOnly in Swagger, you need to update all referencing properties in TypeSpec to use `@visibility(Lifecycle.Read)` instead, since TypeSpec cannot represent readOnly at the model level.\n\nFor more details, see the following reference:", "context": null, "latency": 8.146802186965942, "response_length": 918}
{"query": "title: Exclude property from list that is in create/update/get\n\nquestion: We have an ARM resource that has a property , e.g.  properties.blob that will contain a very large amount of text not appropriate for list responses.\nI see we can override the properties for ArmResourceCreateOrReplaceAsync and ArmResourcePatchAsync, but I don't see a way to do this for ArmResourceRead or ArmResourceListByParent.\nIs there a way to exclude a property from properties when listing other than defining a new resource type that lacks the specific property?\nThe property is required. The only way I can see to do this would be to make it appear optional but return an error is the user tried to set it to empty or null.", "ground_truth": "First, has this been through ARM Review?  Having a very large piece of data as part of a resource could present issues.\nTo answer the question, you can change the response type for a list operation using the `Response` parameter, [as in this playground](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhslfcMlE0nzKYOkBg0FnZSBvZiBlyD%2FlAXhhZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5Pzogc3Ry5QLpxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAWBwxjA%2FOiBieXRlc8lIc29tZSBsb25nIHRleHTGQ8QPVGV4dNJ2VGhlIHN0YXR1c8R5dGhlIGxhc3Qg5ADzYXRpb27lAyogIEB2aXNpYmlsaXR5KExpZmVjeWNs5AIOYWTnAIvEIOUDuVN0YXTkAJXlAdnMFOkBdv8B%2FPABgExpc3T8AgDEIP8CBP8CBP8CBNFk%2FwII%2FwII%2FwII%2FwII%2FwII6wII%2FwHa%2FwHa%2FwHazRTlAUzyATFSZXN1bOUBu%2BgBjMoW7QG%2BPucFCOQAssxx5QC%2F5QEJYekCIOYFumxyb8R6dXMKdW7kBPnxAJPlAaPmAVks7AERyEcgY3JlxCdyZXF1ZXN0IGhhcyBiZWVuIGFjY2VwdGVkxGcgIEHHDjogIsgLItZQacRA5AC06QDByETsAJw6ICLMD9pMdXBkYXTET8VDVccOOiAiyAvKO%2BkG7OkAxOYA3GTnAeFTdWNjZWVk5QDFyQzTP8U25AFNZmFpbMk%2BRsUNOiAixgncOHdhcyBjYW5jZco%2BQ8cP5AdExwv%2FAUAgZGVsZekBgETEDeYA%2BcgLIukGROkDum1vduoByukDvE1vdmVSxxXoA7HEc21vdsRoZnJvbSBsb2PmALzFbsQT9QUhxzN0b88xdG%2FKL%2FcAlXNwb25z6wTW5gCWxxbsAJfuA6vFPsVkxnzmAu7NbmludGVyZuQIY0%2FoA9NzIGV4dGVuZHP2CSUuyyl7fQrlCQHII8oby1noAM3mBPJnZeUDzUHKNeQEJuwFUyDnAntPcuUCp%2BUB1ssvQ8cdUmVwbGFjZUFzeW5jzj%2FlAvfIN0N1c3RvbVBhdGNoU8QqCiAgIOkAkyzFDvYA50ZvdW7kAybkCIzIHOYAkU3kAYTGSdBLyhDqBenFGT4KICDlAJ3mAprvANTlApdlV2l0aG91dE9r8wDUI3N1cHByZXNz%2Fwst7wstL2FybcoV6QW2xBPlAj0i5AfXaXN0QnnoAItHcm91cO8An%2BQFX0J5UGFyZW509AFB6QKLPfMFu%2BgA%2Bf8Awv8Awv8AwuQAoFN1YnNjcmlwxB%2FnAMHmALnMGf8Av%2FgAv%2BgHqyBzYW1wbOsEcmFjxW90aGF05gNv6QdudG8gZGlmZmXkATXvA%2FLFKe4BY0HFSOUCoukAnewEfcgN5gCq8wCSSEVBROoHl8R%2BY2hlY2vqAKpleGlzdGVu5gkdIMYeRckU7wNkzR3uCPA%3D&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D)", "response": "You do not need to define a new resource type to exclude a property (such as `properties.blob`) from list responses in ARM TypeSpec. Instead, you can control which properties appear in requests and responses for each operation using the TypeSpec property visibility framework.\n\nTo exclude a property from the LIST response (but keep it required for create/update/get), you should:\n\n1. Use the `@visibility` decorator on the property and specify the appropriate visibilities. For example, you can use `@visibility(\"read, create, update\")` to include the property in GET, PUT, and PATCH, but not in LIST.\n2. If you want even more granular control (e.g., exclude only from LIST but include in GET), you may need to use custom response models for the LIST operation, as the default resource operation templates use the same model for GET and LIST.\n\nThe recommended approach is to override the response type for the LIST operation using the `Response` parameter, so you can define a model that omits the large property. This is shown in the [TypeSpec Azure playground example](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhslfcMlE0nzKYOkBg0FnZSBvZiBlyD%2FlAXhhZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5Pzogc3Ry5QLpxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAWBwxjA%2FOiAieXRlc8lIc29tZSBsb25nIHRleHTGQ8QPVGV4dNJ2VGhlIHN0YXR1c8R5dGhlIGxhc3Qg5ADzYXRpb27lAyogIEB2aXNpYmlsaXR5KExpZmVjeWNs5AIOYWTnAIvEIOUDuVN0YXTkAJXlAdnMFOkBdv8B%2FPABgExpc3T8AgDEIP8CBP8CBP8CBNFk%2FwII%2FwII%2FwII%2FwII%2FwII6wII%2FwHa%2FwHa%2FwHazRTlAUzyATFSZXN1bOUBu%2BgBjMoW7QG%2BPucFCOQAssxx5QC%2F5QEJYekCIOYFumxyb8R6dXMKdW7kBPnxAJPlAaPmAVks7AERyEcgY3JlxCdyZXF1ZXN0IGhhcyBiZWVuIGFjY2VwdGVkxGcgIEHHDjogIsgLItZQacRA5AC06QDByETsAJw6ICLMD9pMdXBkYXTET8VDVccOOiAiyAvKO%2BkG7OkAxOYA3GTnAeFTdWNjZWVk5QDFyQzTP8U25AFNZmFpbMk%2BRsUNOiAixgncOHdhcyBjYW5jZco%2BQ8cP5AdExwv%2FAUAgZGVsZekBgETEDeYA%2BcgLIukGROkDum1vduoByukDvE1vdmVSxxXoA7HEc21vdsRoZnJvbSBsb2PmALzFbsQT9QUhxzN0b88xdG%2FKL%2FcAlXNw).\n\n**Summary Table:**\n\n| Operation | How to Exclude Property |\n|-----------|------------------------|\n| GET       | Include property in model |\n| PUT/PATCH | Include property in model |\n| LIST      | Use custom response model or visibility to omit property |\n\n**Note:** If the property is required for create/update/get, but you want to exclude it from list, do NOT make it optional in the model. Instead, use the visibility or custom response model approach.\n\nFor more details, see the documentation on [property visibility and operation customization](https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type#property-visibility-and-other-constraints) and [customizing operation responses](https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations).", "context": null, "latency": 22.166747570037842, "response_length": 3340}
{"query": "title: Additional OKResponse\n\nquestion: Like [this](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhslfcMlE0nzKYOkBg0FnZSBvZiBlyD%2FlAXhhZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5Pzogc3Ry5QLpxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAWBwxjA%2FOiBieXRlc8lIVGhlIHN0YXR1c8RLdGhlIGxhc3Qg5ADFYXRpb27lAvwgIEB2aXNpYmlsaXR5KExpZmVjeWNs5AHgYWTHXcQg5QOLU3RhdMRn5QGrzBTpAUjEc8wy5QCA5QDKYekB1cV3QGxyb8Q7dXMKdW7kArLRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QSl6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBP3HC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QP96QN3bW926gHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPrBIvmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AYcT%2BgDlHMgZXh0ZW5kc%2FYG3i7LKXt9CuUGusgjyhvLWegAzeQEs%2BgEtCBzYW1wbOsBumFjxDcgdGhhdOYAt%2BkEd3RvIGRpZmZlcuQHL%2B4BOsUpaXMgQeoAgkHFSEFzeW5j6QVkLOwBxiwgT2voATvlBX0%3D&e=%40azure-tools%2Ftypespec-client-generator-core&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D). My expected response is\n```\n\"200\": {\n\"description\": \"ignore\"\n},\n\"202\": {\n\"description\": \"ignore\"\n},\n\"default\": {\n\"description\": \"ignore\",\n\"schema\": {\n\"$ref\": \"../../../../../common-types/resource-management/v5/types.json#/definitions/ErrorResponse\"\n}\n}\n```\nAnd it is lro. Therefore I wrote this TypeSpec\n```\nmove is ArmResourceActionAsync<Employee, MoveRequest, OkResponse>;\n```\nHowever, this will emit a useless model `TypeSpec.Http.OkResponse` which causes problems in downstream. Can we remove this model? (omit-unreachable-types: true does not work)", "ground_truth": "If the `OkResponse` model is being emitted but not actually referenced, that does sound like a bug — we shouldn't be generating unused models. Especially in cases like this where you're doing a long-running POST action and the 200 response is effectively empty, it’s more accurate to model the operation with just a `202` and an error response.\nFor your case, you can avoid using `OkResponse` entirely by switching to `ArmResourceActionNoResponseContentAsync` or passing `never` as the third argument. That will prevent the generation of the unnecessary `OkResponse` model.\nAlso, keep in mind that for LROs, the POST operation typically doesn't return 200 anyway. That response is just a placeholder in the old pattern to signal \"void\". If you're converting from existing Swagger, and it doesn’t actually return 200, you should be able to safely drop that response from the Swagger and avoid the breaking change.\nAlternatively, if you do need to customize the final response for the LRO, `getLroResponse` can be used to override the response returned at the end of the operation — no need to rely on `OkResponse` at all.", "response": "You are correct that the `OkResponse` model is unnecessary in your scenario and its emission can cause downstream issues. This is a known issue when using `ArmResourceActionAsync<Employee, MoveRequest, OkResponse>`, as the third argument (`OkResponse`) leads to the generation of the `TypeSpec.Http.OkResponse` model, even if it is not referenced in the final OpenAPI.\n\n**Recommended Solution:**\n\n- **Use `ArmResourceActionNoResponseContentAsync`** or pass `never` as the third argument instead of `OkResponse`. This will prevent the generation of the unused `OkResponse` model.\n\n  Example:\n  ```typespec\n  move is ArmResourceActionNoResponseContentAsync<Employee, MoveRequest>;\n  // or\n  move is ArmResourceActionAsync<Employee, MoveRequest, never>;\n  ```\n\n- For LRO POST operations, the 200 response is typically not needed unless you have a final response schema. If your operation does not return a schema for 200, you should not specify `OkResponse`.\n\n- If you need to customize the final LRO response, consider using `getLroResponse` to override the response, rather than relying on `OkResponse`.\n\n- The `omit-unreachable-types: true` emitter option does not currently remove this model if it is referenced, even indirectly, so the above approach is necessary.\n\n**Summary Table:**\n\n| Pattern                                      | Emits OkResponse? | Recommended for your case? |\n|----------------------------------------------|-------------------|----------------------------|\n| ArmResourceActionAsync<Employee, MoveRequest, OkResponse> | Yes               | No                         |\n| ArmResourceActionNoResponseContentAsync<Employee, MoveRequest> | No                | Yes                        |\n| ArmResourceActionAsync<Employee, MoveRequest, never> | No                | Yes                        |\n\nThis approach will give you the desired OpenAPI output without the unnecessary `OkResponse` model.\n", "context": null, "latency": 10.02536916732788, "response_length": 1917}
{"query": "title: TSP Install fails with below error\n\nquestion: I am trying to install TSP and its dependencies and it fails with below error. I have latest node.js Can you please help?\nError: spawn EINVAL\nat ChildProcess.spawn (node:internal/child_process:420:11)\nat spawn (node:child_process:753:9)\nat installTypeSpecDependencies (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/dist/src/core/install.js:4:19)\nat file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/dist/src/core/cli/cli.js:152:95\nat Object.handler (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/dist/src/core/cli/utils.js:16:16)\nat file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/node_modules/yargs/build/lib/command.js:206:54\nat maybeAsyncResult (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/node_modules/yargs/build/lib/utils/maybe-async-result.js:9:15)\nat CommandInstance.handleValidationAndGetResult (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/node_modules/yargs/build/lib/command.js:205:25)\nat CommandInstance.applyMiddlewareAndGetResult (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/node_modules/yargs/build/lib/command.js:245:20)\nat CommandInstance.runCommand (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/node_modules/yargs/build/lib/command.js:128:20) {\nerrno: -4071,\ncode: 'EINVAL',\nsyscall: 'spawn'\n}", "ground_truth": "1. which version of the compiler did you install globally, this looks liek quite an old one?\n2. where are you trying to use typespec, if its the azure spec repo please follow the docs there https://github.com/Azure/azure-rest-api-specs/blob/7fc6689d84858b1c71b786526b04c014c4589968/documentation/typespec-rest-api-dev-process.md", "response": "The error `spawn EINVAL` during TypeSpec installation is often related to an outdated or incompatible global installation of the TypeSpec compiler, or issues with your Node.js/npm environment. Here are the recommended steps to resolve this:\n\n1. **Check TypeSpec Compiler Version**: Make sure you have the latest version of the TypeSpec compiler installed globally. Older versions can cause this error. Uninstall any existing global installation and reinstall the latest:\n\n```bash\nnpm uninstall -g @typespec/compiler\nnpm install -g @typespec/compiler@latest\n```\n\n2. **Verify Node.js and npm Versions**: Ensure you are using at least Node.js 20.0.0 and npm 7.0.0 or higher.\n\n3. **Project Setup**: If you are working in a specific repository (like Azure REST API specs), follow their documentation for setup instructions, as they may require specific versions or steps: [Azure TypeSpec REST API Dev Process](https://github.com/Azure/azure-rest-api-specs/blob/7fc6689d84858b1c71b786526b04c014c4589968/documentation/typespec-rest-api-dev-process.md)\n\n4. **Clean npm Cache**: Sometimes, clearing the npm cache can help:\n\n```bash\nnpm cache clean --force\n```\n\n5. **Try Standalone Installer (Experimental)**: If issues persist, you can try the experimental standalone installer for Windows:\n\n```powershell\npowershell -c \"irm typespec.io/install.ps1|iex\"\n```\n\nIf you continue to see the error, please provide the output of `tsp --version` and details about your operating system and Node.js/npm versions.\n\n**Summary Table:**\n\n| Step | Command |\n|------|---------|\n| Uninstall old TypeSpec | npm uninstall -g @typespec/compiler |\n| Install latest TypeSpec | npm install -g @typespec/compiler@latest |\n| Clean npm cache | npm cache clean --force |\n| Standalone install (Windows) | powershell -c \"irm typespec.io/install.ps1|iex\" |\n\nIf you are following a specific repo's instructions, always refer to their documentation for any additional requirements.", "context": null, "latency": 10.950177431106567, "response_length": 1941}
{"query": "title: Augmented decorators on resource in the multi-path scenario\n\nquestion: This is a resource [model](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/SharedAccessAuthorizationRuleResource.tsp#L18) in the multi-path scenario. It wants to have [minLength and maxLength](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/SharedAccessAuthorizationRuleResource.tsp#L179-L180). Its [parent](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/NotificationHubResource.tsp#L18) also has [augmented decorator](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/NotificationHubResource.tsp#L116-L117) on it.\nActual: No minLength and maxLength [at generated parameter](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/resource-manager/Microsoft.NotificationHubs/preview/2023-10-01-preview/notificationhubs.json#L1286-L1308).\nExpected: [This](https://github.com/Azure/azure-rest-api-specs/blob/5351ac8e1e6fdf48933bae2cd879434b93b36ac0/specification/notificationhubs/resource-manager/Microsoft.NotificationHubs/preview/2023-10-01-preview/notificationhubs.json#L417-L425) is the original swagger. There is limitations on minLength and maxLength.", "ground_truth": "Yes, because the actual path parameters do not come from the resource, you would need to decorate the parameters in the LegacyOperations instantiation.\nWhen you construct the LegacyOperations interface, you pass in the parameters - those passed-in parameters would need to be decorated.\nI wonder if we shouldn't have a legacy resource template that omits the name parameter, just to avoid confusion, it is literally unused in this context.\nIf you need to decorate the name parameter, you will need to define them directly, or name the resulting model, so they can be decoratred.  You can decorate a model statement, but not a model expression.", "response": "In the multi-path scenario you described, where a resource model (such as `SharedAccessAuthorizationRuleResource`) wants to enforce `minLength` and `maxLength` constraints on a parameter (like `name`), but those constraints are missing in the generated OpenAPI, the root cause is that the actual path parameters do not come directly from the resource model. Instead, they are defined as parameters in the operations or in the instantiation of the operations interface (such as `LegacyOperations`).\n\nTo ensure that `minLength` and `maxLength` constraints are present in the generated OpenAPI, you must decorate the parameters directly where they are defined for the operation, not just on the resource model. This means:\n\n- When constructing the operations interface (e.g., `LegacyOperations`), decorate the parameters (like `name`) with `@minLength` and `@maxLength`.\n- If you want to decorate a parameter, you need to define it as a named model or parameter so that decorators can be applied. You cannot decorate a model expression directly—only a model statement.\n\nThis is why your generated OpenAPI is missing the constraints, and why the original Swagger (which had the constraints directly on the parameter) differs from the generated one.\n\n**Summary Table:**\n\n| Where to decorate? | Effect |\n|-------------------|--------|\n| Resource model only | Constraints may not appear on path parameters |\n| Operation/interface parameter | Constraints will appear in OpenAPI |\n\n**Recommendation:**\n- Define the parameter as a named model or parameter and decorate it directly with `@minLength` and `@maxLength`.\n- Consider whether a template or helper can reduce duplication if you have many such parameters.\n\n> \"If you need to decorate the name parameter, you will need to define them directly, or name the resulting model, so they can be decoratred.  You can decorate a model statement, but not a model expression.\"\n\nThis approach ensures that the OpenAPI output matches your expectations and includes the necessary validation constraints.", "context": null, "latency": 12.582697868347168, "response_length": 2036}
{"query": "title: First experience of TSP ApiVersion introduction - passed all CI checks, what's next?\n\nquestion: Hi TypeSpec friends!\nWe are bringing 2nd \"private-preview\" API version to exercise TSP-based wirings and learn the ecosystem:\nhttps://github.com/Azure/azure-rest-api-specs-pr/pull/22321\nFirst round was back in the swagger days.\nNow that we are bringing TSP, it comes with a lot of learning.\nWe made lots of adjustments to satisfy the checks, that were not really changing the protocol, and we had to apply several suppressions otherwise since development of this version has completed - and it is heading to PowerShell CLI partners.\nIt is clear that specification work of the next API version need to be exercised through Azure REST repository tooling to flip the process around, and be able to make protocol affecting changes.\nWith that said - with all checks satisfied - except for \"Automated merging requirements met\" - what is the next step to bring this PR into the review loop?\nUpdated based on the review comments:\n1) for comment [about metadata](https://github.com/Azure/azure-rest-api-specs-pr/pull/22321#discussion_r2072077880)\nwe have:\n```\n@doc(\"The metadata\")\nmetadata?: Record<string>;\n```\nsuggestion was: Consider using array of KVP\nmy follow up suggestion: our desired over-the-wire representation is { \"mykey\": \"myvalue\" }\ncan we achieve that via below, will that be supported:\n```\nmodel MetadataModel {  [key: string]: string;}\n```\n2) regarding a [question for the purpose of the PR](https://github.com/Azure/azure-rest-api-specs-pr/pull/22321#issuecomment-2847987559) - I provided brief [answer](https://github.com/Azure/azure-rest-api-specs-pr/pull/22321#issuecomment-2848108430), can you please share the \"control plane template\" form for me to fill?\n3) for the initatorId property [question](https://github.com/Azure/azure-rest-api-specs-pr/pull/22321#discussion_r2072077812) - I answered it, not sure if I should put all of my answer in the @doc, since some of that doesn't have to be public facing. Would a regular comment be of help for reviewers, something that is otherwise invisible to the swagger?\n4) there was a [recommendation](https://github.com/Azure/azure-rest-api-specs-pr/pull/22321#discussion_r2072053387) on how operation ids should look like - and my question was how do we control operation ids, since I am not seeing TSP code of ours being responsible for operation id strings that end up in the swagger?", "ground_truth": "Some thoughts:\n1. That issue isn't how to get Typespec to construct that over-the-wire pattern. The issue is that the dictionary pattern is an ARM anti-pattern. It defeats important ARM features that customers expect to be able to use (ARG, and Azure Policy). There are other issues with this pattern: (how are the supported keys documented, how are the supported keys versioned, how do clients determine what keys are required vs. optional, etc.).\n2. You can create a new dummy PR in github to get a template file and add it to your existing PR. If you use the link to create the PR, Github automatically adds the template file.\n3. The type of that property was string. The suggestion is to use the name and @doc to help clients understand what that string represents and how to correctly populate it. It's up to you how much to share about internals.\n4. This appears to be the only TypeSpec Discussion question here. I don't know the answer.\nFollow-up on items 1-3 above should be in PR comments rather than here. Current on-call reviewer will follow up.", "response": "Congratulations on getting your TypeSpec-based API version through all CI checks! Here’s guidance on your next steps and answers to your specific questions:\n\n### 1. Next Step After Passing CI Checks\nWith all checks satisfied except for \"Automated merging requirements met,\" your PR is ready to enter the review loop. Typically, this means:\n- Wait for a human reviewer to pick up your PR. If you want to expedite, you can @-mention the relevant reviewers or follow up in the TypeSpec Discussions Channel.\n- Ensure you have filled out any required PR templates (see below for the control plane template).\n- Address any review comments as they come in.\n\n### 2. Metadata Representation\nYou want `{ \"mykey\": \"myvalue\" }` as the wire format. In TypeSpec, you can achieve this with:\n```tsp\nmodel MetadataModel {\n  [key: string]: string;\n}\n```\nHowever, be aware that using a dictionary pattern for metadata is considered an ARM anti-pattern, as it can interfere with features like Azure Resource Graph and Policy. Reviewers may push back on this design for ARM APIs.\n\n> \"The issue is that the dictionary pattern is an ARM anti-pattern. It defeats important ARM features that customers expect to be able to use (ARG, and Azure Policy). There are other issues with this pattern: (how are the supported keys documented, how are the supported keys versioned, how do clients determine what keys are required vs. optional, etc.).\"\n\n### 3. Control Plane Template\nTo fill out the control plane template for your PR:\n- You can create a new dummy PR in GitHub to get the template file, then add it to your existing PR. If you use the link to create the PR, GitHub automatically adds the template file.\n\n### 4. Internal Comments for Properties\nFor properties like `initiatorId`, you can use regular TypeSpec comments (not `@doc`) for internal notes to reviewers. Only `@doc` content is emitted to Swagger/public docs. Regular comments are visible in the TypeSpec source but not in the generated OpenAPI.\n\n### 5. Operation IDs\nOperation IDs are typically generated by the TypeSpec emitter based on operation names and paths. If you want to control them, you may need to use specific decorators or naming conventions in your TypeSpec code. If you’re not seeing the expected operation IDs, check the emitter documentation or ask in the TypeSpec Discussions Channel for guidance on customizing operation IDs.\n\n### 6. General Guidance\n- For any process or CI issues, consult the [CI Fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\n- For further help, use the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\n\n**Summary Table**\n\n| Step/Question | Guidance |\n|---------------|----------|\n| Next after CI | Wait for review, fill template, respond to comments |\n| Metadata      | `[key: string]: string` works, but is an ARM anti-pattern |\n| Control plane template | Create dummy PR to get template |\n| Internal comments | Use regular comments for reviewers, `@doc` for public |\n| Operation IDs | Controlled by emitter; check docs or ask for specifics |\n\nGood luck with your TypeSpec journey! If you need more details on any of these steps, feel free to ask.", "context": null, "latency": 14.97943639755249, "response_length": 3390}
{"query": "title: Namespace when not specified?\n\nquestion: [azure-rest-api-specs/specification/ai/Face/tspconfig.yaml at main · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/ai/Face/tspconfig.yaml)\nI'm working on adding Tier 1 language namespace names to TypeSpec APIView. I can get this from the compiler options when namespace is specified in the tspconfig.yaml. However, what should the behavior be when, as in the above config, the namespace isn't specified (for typespec-ts)?  What heuristic is applied to determine the namespace? Is it language specific?", "ground_truth": "When the `namespace` isn't explicitly specified in `tspconfig.yaml`, the behavior falls back to what's defined in the TypeSpec file itself—i.e., whatever `namespace` is declared there. If no namespace is declared in the TypeSpec, then the emitter determines the default, which may vary by language.\nIn the management plane, it's fairly standardized: we derive the namespace based on the resource provider name, stripping prefixes like `Azure` or `Microsoft`, flattening separators, and applying language-specific naming conventions. For example:\n* .NET: `Azure.ResourceManager.[ProviderName]`\n* Python: `azure-mgmt-[providername]`\n* Java: `com.azure.resourcemanager.[providername]`\n* JS: `@azure/arm-[providername]`\nFor **data plane**, it's similar but instead of \"ResourceManager\", you use the service group (like `AI`, `Data`, etc.). By default, it uses the namespace from the TypeSpec unless you override it via:\n```yaml\nnamespace: Azure.LoadTesting\n```\nin the `tspconfig.yaml`. That flag overrides the namespace across all language emitters.\nThere was some confusion with how this gets surfaced through TCGC. Although `clients[0].namespace` is supposed to reflect the effective namespace, it wasn't showing the expected value (`azure.ai.vision.face`). Isabella helped identify the issue and confirm that it was due to a workaround or emitter configuration not being applied as expected.", "response": "When the `namespace` is not specified in `tspconfig.yaml`, the effective namespace used by TypeSpec emitters (such as typespec-ts) is determined by the namespace declared in the TypeSpec source file itself. If no namespace is declared in the TypeSpec file, the emitter will apply its own default, which may vary by language and emitter. For Azure SDKs, the convention is to derive the namespace based on the resource provider or service group, applying language-specific naming conventions (e.g., `Azure.ResourceManager.[ProviderName]` for .NET, `azure-mgmt-[providername]` for Python, etc.).\n\nIf you want to override this behavior and enforce a specific namespace across all language emitters, you should specify the `namespace` property in your `tspconfig.yaml`.\n\nIn summary:\n\n- If `namespace` is set in `tspconfig.yaml`, it overrides everything.\n- If not, the namespace from the TypeSpec file is used.\n- If neither is set, the emitter applies its own default, which is language-specific.\n\nThis behavior is consistent across language emitters, but the exact default namespace format is language-specific.", "context": null, "latency": 9.94809079170227, "response_length": 1106}
{"query": "title: Resource Action LRO response modelling\n\nquestion: I want to define an Asyn resource action. Calling this action doesn't produce a  body in the immediate response, but the  long running operation will have a body when it finally reaches a `Succeeded` state. What's the correct way to model this in typespec? This is management plane.", "ground_truth": "The way this is currently modeled in swagger (and required by lintdiff rules) is that you have a 200 response that represents the eventual operation return value when the operation is resolved, like the 'move' operation [in this example](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhslfcMlE0nzKYOkBg0FnZSBvZiBlyD%2FlAXhhZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5Pzogc3Ry5QLpxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAWBwxjA%2FOiBieXRlc8lIVGhlIHN0YXR1c8RLdGhlIGxhc3Qg5ADFYXRpb27lAvwgIEB2aXNpYmlsaXR5KExpZmVjeWNs5AHgYWTHXcQg5QOLU3RhdMRn5QGrzBTpAUjEc8wy5QCA5QDKYekB1cV3QGxyb8Q7dXMKdW7kArLRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QSl6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBP3HC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QP96QN3bW926gHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPrBIvmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AYcT%2BgDlHMgZXh0ZW5kc%2FYG3i7LKXt9CuUGusgjyhvLWegAzeYEs2dldOQBp0HKNeQD5%2BwFECDnAntPcuUCp%2BUB1ssvQ8cdUmVwbGFjZUFzeW5jzj%2FlAvfIN0N1c3RvbVBhdGNoU8QqCiAgIOkAkyzFDvYA50ZvdW7kAybkBkXIHOYAkU3kAYTGSdBLyhDqBarFGT4KICDlAJ3mAprvANTlApdlV2l0aG91dE9r8wDUbGlzdEJ5yDBHcm91cM9ETMUiUGFyZW501DxTdWJzY3JpcOUCecY7xjPMGcw56AZgIHNhbXBs6wNmYWPFRHRoYXTmAmPpBiN0byBkaWZmZeQAhO8C5sUp7gCyQcVI7gDtLOwDcsgN5gLp8wCTSEVBROoGTcR%2FY2hlY2vqAKtleGlzdGVu5gfHIMYeRckU7wJZzR3uB6I%3D&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D).\nWe would like to move to a representation where the 200 response is not in the swagger and the return value is represented in the long-running-operation-options extension, but not all emitters for required languages support this yet.", "response": "To model an asynchronous (LRO) resource action in TypeSpec where the initial response has no body, but the final (succeeded) state returns a body, you should use the `ArmResourceActionAsync<ResourceType, Request, Response>` template for management plane scenarios. This template is designed for actions that take input and eventually produce output after the operation completes.\n\nThe current best practice, as required by lintdiff rules and Swagger compatibility, is to define a 200 response representing the eventual operation return value (the body you get when the operation reaches `Succeeded`). The initial response (typically 202) does not include a body. This pattern is reflected in the TypeSpec templates and is compatible with Azure SDKs and tooling.\n\nHere is a minimal example:\n\n```typespec\n// Assuming MyResource is your resource type, MyRequest is the input, and MyResponse is the final output\nmyAction is ArmResourceActionAsync<MyResource, MyRequest, MyResponse>;\n```\n\n- `MyRequest` is the model for the request body.\n- `MyResponse` is the model for the response body returned when the operation is complete (Succeeded).\n\nIf your action does not return a body even at completion, use `ArmResourceActionNoResponseContentAsync<ResourceType, Request>` instead.\n\nFor more advanced or custom LRO patterns (such as custom polling or final result retrieval), you can use the decorators and patterns described in the Azure.Core documentation, such as `@pollingOperation`, `@finalOperation`, and custom status monitor models. But for standard management plane actions, the above template is recommended.\n\n**Summary Table:**\n\n| Scenario                                 | TypeSpec Template                                      |\n|------------------------------------------|--------------------------------------------------------|\n| Async action, returns body at completion | ArmResourceActionAsync<ResourceType, Request, Response>|\n| Async action, no body at completion      | ArmResourceActionNoResponseContentAsync<ResourceType, Request> |\n\nThis approach ensures compatibility with current Azure tooling and aligns with the expected LRO modeling in management plane APIs.", "context": null, "latency": 15.319666147232056, "response_length": 2178}
{"query": "title: How to customize \"original-uri\" in arm template?\n\nquestion: We have a customer who sets [\"final-state-via\": \"original-uri\"](https://github.com/Azure/azure-rest-api-specs/blob/11059b2f00c7572b276dc9862c0b41db8702cc78/specification/dashboard/resource-manager/Microsoft.Dashboard/stable/2024-10-01/grafana.json#L1007). We have ArmAsyncOperationHeader, ArmLroLocationHeader. Seems we don't have a header for original-uri?", "ground_truth": "`original-uri` is only a valid setting for PUT operations, it means that the original URI in the PUT request is used to retrieve the resource, which has a status field that determines its state. Generally, this is the default for LRO PUT operations, but if there are multiple valid pathways to resolve the lro, you can use `@useFinalStateVia` to choose which one should be favored.\n[like this](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BgAhslfcMlE0nzKYOkBg0FnZSBvZiBlyD%2FlAXhhZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5Pzogc3Ry5QLpxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAWBwxjA%2FOiBieXRlc8lIVGhlIHN0YXR1c8RLdGhlIGxhc3Qg5ADFYXRpb27lAvwgIEB2aXNpYmlsaXR5KExpZmVjeWNs5AHgYWTHXcQg5QOLU3RhdMRn5QGrzBTpAUjEc8wy5QCA5QDKYekB1cV3QGxyb8Q7dXMKdW7kArLRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QSl6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBP3HC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QP96QN3bW926gHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPrBIvmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AYcT%2BgDlHMgZXh0ZW5kc%2FYG3i7LKXt9CuUGusgjyhvLWegAzeYEs2dldOQBp0HKNeQD5%2BwFEOYGNkZpbmFs5QOGVmlhKCJvcmlnxBItdXJp5QRy5wN7zktDxRVPclJlcGxhY2VBc3luY85b5QMTyDdDdXN0b21QYXRjaFPEKgogICDpAK8sxQ72AQNGb3Vu5ANC5AZhyBzlA1RlTeQBoMZJ0EvKEOoFxsUZPgogIOUAneYCtu8A1OUCs2VXaXRob3V0T2vzANRsaXN0QnnIMEdyb3Vwz0RMxSJQYXJlbnTUPFN1YnNjcmlw5QKVxjvGM8wZzDnoBnwgc2FtcGzrA4JhY8VEdGhhdOYCf%2BkGP3RvIGRpZmZl5ACE7wMCxSnuALJBxUjlAZbIdyzsA43IDeYDBPMAkkhFQUTqBmjEfmNoZWNr6gCqZXhpc3RlbuYH4iDGHkXJFO8CWM0d7ge9&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%2C%22options%22%3A%7B%22%40azure-tools%2Ftypespec-autorest%22%3A%7B%22emit-lro-options%22%3A%22final-state-only%22%7D%7D%7D).  When you have multiple valid pathways to resolve the lro, you might have to use `@useFinalStateVia` to prefer one over the other.  Since this API also has an Azure-AsyncOperation header, and for ARM, looking at it the default for PUT is Azure-AsyncOperation, when it is present.", "response": "To customize the final-state-via behavior (such as using \"original-uri\") for a long-running operation (LRO) in an ARM template or TypeSpec, you should use the `@useFinalStateVia` decorator on your operation. This decorator allows you to specify which polling mechanism should be used to determine the final state of the operation. \n\nFor example, to explicitly set the final state to use the original URI (which is typically the default for PUT LROs), you would annotate your operation like this:\n\n```typespec\n@Azure.Core.useFinalStateVia(\"original-uri\")\nop createOrUpdate(...) is ...;\n```\n\nThere is no specific header model for \"original-uri\" like there is for `ArmAsyncOperationHeader` or `ArmLroLocationHeader`, because \"original-uri\" refers to polling the original resource URI for status, not a header-based polling mechanism. The decorator is the correct way to express this intent in TypeSpec.\n\nIf you have multiple valid LRO pathways (e.g., both Azure-AsyncOperation and Location headers are present), use `@useFinalStateVia` to specify which one should be favored.\n", "context": null, "latency": 8.788609266281128, "response_length": 1073}
{"query": "title: Avocado Failing on PR\n\nquestion: Hi TypeSpec Discussion\nI have a PR here to add a new set of Azure AI APIs: https://github.com/Azure/azure-rest-api-specs/pull/33130\nI'm a bit confused on why the avocado step is failing? As this is a brand new API, we started from scratch with tsp itself, and these swaggers are the output of `npx tsv` .... Do I really need to include a README.md in the swagger directories, or is this just failing incorrectly? I don't see README.md files in other service directories (i.e. keyvault) for example.", "ground_truth": "you need a readme.md somewhere to generate SDKs.  location and factoring of the readme.md(s) can vary by spec.", "response": "Yes, you do need a `readme.md` file in your Swagger (OpenAPI) directories when working in the `azure-rest-api-specs` repo, especially for SDK generation and pipeline validation. The `readme.md` serves as the entry point for tools like Avocado and for SDK generation pipelines to locate and process your API definitions. The location and structure of the `readme.md` can vary, but its presence is required for the automation to work correctly. Even if you don't see it in some older service directories, it is now a standard requirement for new TypeSpec-based APIs and for proper CI/CD integration.\n\nIf Avocado is failing due to a missing `readme.md`, you should add one in the appropriate directory (typically alongside your generated OpenAPI files). This will resolve the validation and enable downstream tooling to function as expected.", "context": null, "latency": 18.251375675201416, "response_length": 838}
{"query": "title: Need help in Adding final-state-schema for a single post action\n\nquestion: Hi TypeSpec Discussion,\nPR: https://github.com/Azure/azure-rest-api-specs-pr/pull/22427\nWe would like to add final-state-schema for a single post action LRO operation for now. Is it possible to do it for a single post action or not ?\nwhen we add emit-lro-options: \"all\" in tspconfig.yml. It is reflected in all the long-running options..", "ground_truth": "So, what you need to do is the following:  Change the response type to match the final result type you want  Here is a playground showing that the response parameter in ArmResourceActionAsync shows up both in the 200 response and in the final-state-schema, which means that typespec-based emitters  will get the right final response value and so will swagger-based emitters.\nTo be clear the final-state-schema in this case is just for debugging purposes is it not necessary in the actual swagger.  I added a comment to the PR showing the change you should make here.", "response": "Yes, it is possible to specify the final-state-schema (i.e., the final response type) for a single POST action LRO operation in TypeSpec. You do not need to rely solely on the global `emit-lro-options: \"all\"` in your `tspconfig.yml` to achieve this for just one operation.\n\nThe recommended approach is to change the response type of your specific POST action LRO operation to match the final result type you want. This way, the TypeSpec emitters (and downstream OpenAPI/Swagger) will correctly reflect the final-state-schema for that operation only.\n\nYou can use operation templates and decorators such as `@pollingOperation` and `@finalOperation` to model custom LRO patterns and specify how the final result is obtained. For example, you can link your POST action to a final GET operation that returns the final resource state, or directly specify the final response type in your operation signature.\n\nThis approach is operation-specific and does not require changing the global emitter options for all LROs in your service.\n\n> To be clear the final-state-schema in this case is just for debugging purposes is it not necessary in the actual swagger. I added a comment to the PR showing the change you should make here.\n\nIf you want to see concrete examples of how to model this, refer to the linked documentation and examples below.", "context": null, "latency": 10.416318655014038, "response_length": 1334}
{"query": "title: Typespec -> Autorest generation : multiple specs per service\n\nquestion: Currently while we are able to organize and manage multiple typespec files per service easily, the final generated swagger is a single file.\nI was asked during my API review to check if there is feasibility to produce multiple specs per service for organizational purposes considering the generated file is huge.\nI see prior posts on this indicating this is not supported, but looking for any latest update/guidance here.\nSecondly, if the above is in fact supported, any idea if the SDK generation part can handle multiple specs per service?", "ground_truth": "No, since the swagger is now just an emitted artifact, there is no real reason to organize it.  There is no mechanism for splitting a TypeSpec spec into multiple OpenAPI files.", "response": "Currently, TypeSpec does not support splitting a single service's OpenAPI (Swagger) output into multiple files for organizational purposes. The emitted OpenAPI spec is always a single file per service (or per version, if you use versioning). There is no built-in mechanism to partition a large service's OpenAPI output into multiple smaller specs.\n\nFrom the latest guidance:\n\n> No, since the swagger is now just an emitted artifact, there is no real reason to organize it. There is no mechanism for splitting a TypeSpec spec into multiple OpenAPI files.\n\nHowever, TypeSpec does support generating separate OpenAPI files for different versions of your API if you use the `@versioned` decorator. This is primarily for versioning, not for splitting a single version's spec into multiple files.\n\nRegarding SDK generation: Since multiple OpenAPI files per service are not supported, SDK generators (like AutoRest) expect a single OpenAPI file per service/version. If you were to manually split the OpenAPI file, you would likely encounter issues with SDK generation tools, as they expect a complete spec.\n\n**Summary:**\n- Splitting a single service's OpenAPI output into multiple files is not supported.\n- Multiple files are only generated for different versions (using versioning), not for organizational partitioning.\n- SDK generation expects a single OpenAPI file per service/version.\n\nIf you need to manage a very large API, consider using namespaces and versioning for organization within TypeSpec, but the emitted OpenAPI will still be a single file per service/version.", "context": null, "latency": 9.2616548538208, "response_length": 1570}
{"query": "title: Proper Service Versioning\n\nquestion: Hi TypeSpec Discussion. I'm looking to understand how to properly add a new service version to my team's typespec. I've been looking at this doc here as a baseline, and I think I generally understand everything there. But I've got a couple of questions for my specific case.\n1. What does the `added` decorator actually do? Just tell the swagger which version should/shouldn't contain a property? I'm assuming the question of whether it has an impact on any of the SDKs is a question for the individual generator teams?\n2. My team's spec has a [client.tsp file](https://github.com/Azure/azure-rest-api-specs/blob/dargilco/ai-model-inference/specification/ai/ModelClient/client.tsp#L8) with a `customization` namespace, which has this decorator: `@useDependency(AI.Model.Versions.v2024_05_01_Preview)`. I get the general gist that this ties things to a specific version, but what does that mean from a practical standpoint? I maybe can understand client customizations being specific to individual versions, but what about modifications that work across versions? I don't seem to be able to provide a list or anything to that decorator. I've tried removing it, and I get an error saying that the `customization` namespace is referencing a versioned namespace and should add the decorator. I've also tried just changing the namespace to match, but then I get an error from my client interfaces saying that I have duplicate operations. So I'm trying to understand how to correctly handle this.\nAny pointers would be appreciated. Thanks in advance!", "ground_truth": "On the first question, TypeSpec is allowing you to version based on differences,  starting with the base api-version, whenever you make changes to the api, you just need to tag those changes with the 'versioning' decorator to ensure that typespec can reconstruct the api at each version that is still active.\nIn the case of `@added` this is used whenever adding a new type to the spec - a new model, a new model property, a new interface, a new parameter, a new operation - you simply decorate the element with this decorator and pass in the version that this change occurred in.  `@removed` works similarly for removing types (which is always a breaking change).  decorators like `@renamedFrom` allow you to rename types, and take the version the change occurred at and the old name of the type (the type name is changed inline). `@typeChangedFrom` works similarly - describing the state of the type before the change occurred.\nThere are some limitations around versioning (for example, versioning decorators is impossible, so the decorated types themselves generally need to be versioned.\nAs far as the client.tsp goes, versioning is tightly tied to a namespace (but includes all the child namespaces).  If your client.tsp is a child namespace of the versioned namespace, then no explicit version coupling is required.  If not, then you will need to replicate the versions enum from the service namespace in client.tsp,  and explicitly tie each version to the corresponding version.  I have shown an example of what I mean [in this playground](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3JlIjsKCnVzaW5nIEh0dHA7xwxSZXN0yAxWyVfIEkHEPi5Db3Jl0hIuVHJhaXRzOwoKQOcAkGVkKENvbnRvc28uV2lkZ2V0TWFuYWdlci7HWXMpCm5hbWVzcGFjZSDVKiB7CiAgLyoqIFRoySIgxiIgyCNzZXJ2aWNlIMd1LiAqLwogIGVudW3oAMFzxUfGSccTIDIwMjItMDgtMzDGMCAgQHVzZURlcGVuZGVuY3ko6wDZyEcudjFfMF9QcmV2aWV3XzIpxTdgykpgLArUaDUtMDHfaN9oyGjHSmAsCiAgfcRsLy8gTW9kZWxzIC%2FTAcUi5wE9Y29sb3Igb2YgYSB35QFA5wEodW7kAKbmAVNDxSTmASxzdHJpbmfrANFCbGFja8cpIMYqxUEgxho6ICLFCCLLM1doaXRl1TPFGjogIsUIzDNSZWTVMVJlZDogIlJlZMwtR3JlZegAvM4vxRo6ICLFCMwzQmx19gCSxBnlAMR15ACQ6AFfKiogQe4BMEByZXNvdXJjZSgixhhzIuQBoG3kAYbIWeoCbuQBesYnIOQC6sdEICBAa2V5yEFOYW1lxUQgIEB2aXNpYmlsaXR5KExpZmVjeWNsZS5SZWFkxiDERDrnAZs76gDVy2blAefJZ8UOOuwB3s82SUTkAhN0yUAncyBtYW51ZmFjdHVyZcpJzBVJZO8Agy4uLkV0YWdQcm9wZXJ0eTvsAT7EZXJlcGFpciBzdGF0ZfMCgkBscm9TdGF0dXPvAo9SxTjEG2X4ApXGKcdicyBzdWNjZWVkZWTHWyAgU8gSOiAiyQztAqTOQmZhaWzLP0bFDzogIsYJ2zl3ZXJlIGNhbmNlzEBDxxE6ICLIC9NEd2FzIHNlbnQgdG%2FlAYz1AYNTZW50VG9NyxvkANPRFfACvXN1Ym1pdHRlZOgBh3JlcXVlc3QgZm9y8AGK7ALF5gF9Usct7gLS6QHK6gI5z17HUSDIEOUBxegCiesB2O8Cj2TEWGFuZCB0aW1lIHdoZW7FY8dcaXMgc2NoZWR1bGVk5AErb2NjdeoBIMkbRGF0ZVRp5AMpdXRjyA3faclp5gDv5AGRY3JlYXTrAcvHEN9e317JXnVwxCXKXscQ317fXsleY29tcGxlzGDJEtdi7wOzcGFyYW1ldGXkAxLrAijlAfp1c8ls9wI25gPOUMRE7Ad79ARxIGJl5AhG5gHi6wCwQHBhdGjFCsYo7AR18wWdJ3PkALPzBaTEFuYFokBwYXJlbnRSyBvmALHwBbxQYXLwAu7kBXXoALXLZe4FxcQ4%2FwXJ%2FwXJyG9JROQC3HVzZeUBenJlb3JkZcQn8gCAxA3xBY3yAWnEJ%2F8F2P8F2PcF2GRldGFpbHPEaGHoAKnvBF%2FqAVXzBGPEF1LGN%2FIEaElkZW50aWZpZXMgd2hvIHNpZ25lZCBvZuYA1M9ux10gxydPZmZCefICMC8gQW4gZXhh5AMK5gC15ArCbGV0b24g6AIy5wDfUHJvdmlkZXMgYW5hbHl0aWNzIGFib3V0xX3kAZzkA4BtYWludGVu5AXYxk%2FmANfyAoXJRf8CiewBHUHJee4CjmnoARhy5QFj5ACQyV8gb2JqZWN0LiDEKnJl5AUxb25seSBvbuYCxmQgJ2N1csR9J%2B8CxclDSWT%2FAsLoAsJp5AbUx07kDErtAzJ1bWJl5QptdXNl5QIg6gPxyXl1c2VDb3VudDogaW50NjTZQ%2BQE5nPLQeUE4fEEMMYRzlHtBCjsAurEV8ZNc%2FIBrcwp7Anc7Adl7wGUzDMnc%2BQIxHF15AOC7wFlzCf%2FAWjuAWj1A%2BHPde0KX%2FsEX883ZnVsbCBhZGRyZXPoAQwgyBD%2FBA%2FrA1hPcGVyYXTlDWr%2FDIjpDa505A4tZXPsBBZTxhvmDkfnAWMuLi5TdXDkDtFzUmVwZWF0YWJsZecELnPkAIPNI0NvbmRp5ACIYWzaJGxp5QN%2BxR9JZDzpDXXsDWE%2B6QDeYWxpYXPsAOE97A7z6APFyiA87QDGPjsKfQoK5A3yQXV0aCgKICBBcGlLZXnEDjzGC0xvY8U6LmhlYWRlciwgImFwaS1rZXkiPiB8IE%2FEKjLFL1vlAMrmARcgIOQP0TrHH0Zsb3dUeXBlLmltcGxpY2l05AoExAFhdXRob3JpesVhVXJsOiAi5BBdczovL2xvZ2luLmPnD3Vjb20vY29tbW9uL2%2FENTIvdjIuMC%2FIQOYNE8QBc2NvcGVzOiBbyUnnA9fMSi5kZWZhdWx0Il3GN30KICBdPgopCkDnAf4oI3sgdGl0bOQNcvYP1iIgfccvZXLkATcie2VuZHBvaW50fcdy5QCT0D5BUElzxRnqA6EK5wH56g5Z5wGicyDIU3MgKHByb3RvY29s5QXZaG9zdOQDQyzlBWPnBjI6CukA8mVzdHVzLmFwaS7yAP0pLgroA0fIX%2BgDSOYLminsER%2F7EQnrAnPkAM3mEW71ESXlA6DkBotyZsRAxhzGNu4DniDpDWfnD0DEJ%2BcJ0%2BsGwSDkA%2BHFMeoEwXNoYXJlZFJvdXTkByMgIGdldMYtyV3GXOQGdMkTcy5H5AoT7wMjxik8xj%2FlA2n%2BAI5kZeQKuf8Ale4AlUTFM%2F8Am%2FoAm8VNIOcAgOgC%2Bm5ldmVyxQw%2B6AVTL8cjy1fGGSoqIEPlDC9zIG9y5wvcc%2BoA0mFzeW5jaHJvbm91c2x56grzb2xsaW5nyU3nCBpzLvgBbeYGIuYMmU9yVcVnx2PuAOxMb25nUnVu5BPK6AD05gCgyDbqAY7sAY%2FqALLnAKPpAInPYMhV5Aa300vmAY%2F4AQDrC%2FT%2FAQH3AdnmAQfmAif%2FAP%2FpAP%2FGSfMArExpc3TqD9zGLecGpiAgbGlz5wCJ8AJOyFjEP%2FYCQMQaUXVlcnnlDRjlDVzlBiQ8U3RhbmRhcmTTISAmxz3kD%2F9sZWPPID73Ao%2FpCjz1Ac3JHusB1soU%2FwHZyyvJeP4C7tFvxiHfcvYCoNJ86QD05g569AOK5AD85Ao%2F8gRb7RDk6QKHI3N1cHDkCQD%2FF0NvcmUvdXNlLXPnAcAt6QSicyIgIlRoaeUA22EgY3VzdG9t6gTA6ACJ6AYfLiLFd0By5ATIKCLnBt9zL3vGCUlkfS%2FnEmUve8lFSWR95wpB7w92xHRGb3VuZOoE5%2F0E38w85g%2By6AKx8wEk7gJwKiogU%2BcRdeoQIuYOtcQ06gpQ%2FwPZ%2BQTa6BHT5gCE8AIq8wPWQWPEG%2FYDgPMAz9sbICYgxwpJZFJlc3BvbnNlSOUJoegBBOcKIPAHeOQO1ewNtPcG1sQn8wbT6QEQxCD%2FBsD%2FB1vFQ%2FQDpO0Ag%2B0S3csY%2FAOVV2l0aOcJROcPKGTkEPvXd%2BwEe8xz7QDr13DrBHfQV%2B8GVMxa7AYK213tBgPQX%2BsGB8VD%2BwYLxCD9Bg%2FWYucQ%2BiBhbGzlEaPmE2rzDyn4Az7FeOoDQvMCMuYDRucRLPQAp%2FQIGG9s5AZpaW9u9ANNxEXuAzbyEcX1CTHxAy7sD0%2F9AzDMKfYDMswi%2FwM0%2BgM0zEX3BtpyZXBsYeQCA%2B8Ale0DRE9yUsYnzSP%2BBuTHMvkAhOYDQ9R07wD%2B12jlA0fYXekDSc1J%2FwmjyWUozDblAo77AY7sCan7ALf6Ca%2F4AMTlA67NUvUDsMwi%2FQOyz2jvFPj%2FHoj%2FHoj%2FHoj%2FHiD6HiDPN%2F4feeUQ7cd4YP8eyP8eyP8AqP8AqP8AqO0RlfgfCOYV2yAiZ2xvYmFsIiBSUEPqBCnnAbjmB8RkcyB3aXRo6ARgaW5mb3JtxSfrFd9vdmVy5AWV5wHQ6RQi5gmfxxbkCfZ0deYUIG9w5AOI5wcS6gR4UnBj6QJg5gVGe33mBRzoEcTGRFPlEB3sFq8gIMcp7RJMCuUFSX0K&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fdata-plane%22%5D%7D%7D)\nFeel free to reach out with any specific questions.\nThe linked playground is a little more complex than it needs to be, but, depending on what is in your client.tsp, is likely similar.  Note that this also gives you the option of making version-specific client.tsp changes, but simply having the linkage as shown using the `@useDependency` decorators will ensure that the client.tsp is used in both versions.", "response": "Great questions! Here’s a detailed breakdown for both:\n\n**1. What does the `@added` decorator actually do?**\n\nThe `@added` decorator is used to indicate that a model, property, operation, or other API element was introduced in a specific version of your API. When you decorate something with `@added(Versions.v2)`, for example, TypeSpec will only include that element in the generated OpenAPI (Swagger) spec for version 2 and later. Earlier versions will not include it. This allows you to evolve your API over time without breaking existing clients.\n\nWhether this impacts SDKs depends on the generator: the OpenAPI spec for each version will reflect the presence or absence of the element, so SDKs generated from those specs will only include the element in the appropriate versions. But the specifics of SDK behavior are up to each generator.\n\n> \"The `@added` decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\" ([TypeSpec Docs: Versioning](https://typespec.io/docs/getting-started/getting-started-rest/06-versioning))\n\n**2. What does `@useDependency` do in the context of a versioned client.tsp?**\n\nThe `@useDependency` decorator ties a particular version of your service (or a namespace) to a specific version of a dependency (like Azure.Core or another versioned namespace). In your case, `@useDependency(ai.model.versions.v2024_05_01_preview)` means that the `customization` namespace is explicitly linked to that version of the dependency.\n\n- If your `client.tsp` is a child namespace of the versioned service namespace, you usually don’t need to explicitly use `@useDependency`—the versioning flows down.\n- If it’s not, you must use `@useDependency` to tell TypeSpec which version of the dependency to use for that namespace.\n- You cannot provide a list to `@useDependency`; it’s one version per decorated namespace. If you want to support customizations across multiple versions, you typically need to replicate the customization logic for each versioned namespace, or structure your code so that shared logic is in a non-versioned namespace that is then referenced by each versioned customization.\n\nIf you remove `@useDependency` and reference a versioned namespace, you’ll get an error because TypeSpec needs to know which version to use. If you try to change the namespace to match, you may get duplicate operation errors if the same operations are defined in multiple places.\n\n> \"If your client.tsp is a child namespace of the versioned namespace, then no explicit version coupling is required. If not, then you will need to replicate the versions enum from the service namespace in client.tsp, and explicitly tie each version to the corresponding version.\" ([TypeSpec Q&A](#))\n\n> \"You will need to specify the version of typespec-azure-core that was used for each version in your spec... you can express changes to your service using the `@added` and `@removed` decorators.\" ([Azure TypeSpec Docs: Versioning](https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10))\n\n**Summary Table**\n\n| Decorator         | Purpose                                                                 | Notes                                                                                 |\n|-------------------|-------------------------------------------------------------------------|---------------------------------------------------------------------------------------|\n| `@added(version)` | Marks when a type/operation/property was introduced                     | Only present in OpenAPI/spec for that version and later                               |\n| `@useDependency`  | Ties a namespace to a specific version of a dependency                  | Required if referencing a versioned namespace from outside; one version per namespace |\n\nIf you need to support customizations across versions, consider structuring your code so that shared logic is in a non-versioned namespace, and version-specific logic is in versioned namespaces with the appropriate `@useDependency`.\n\nLet me know if you need a concrete code example or have more questions!", "context": null, "latency": 19.087082624435425, "response_length": 4181}
{"query": "title: JSON merge-patch support in TypeSpec\n\nquestion: How exactly does TypeSpec support `application/merge-patch+json` i.e., \"JSON merge-patch\"? Is there explicit types, or is it really just a matter of service authors adding `| null` to their type defs e.g.,\n```\nmodel M {\n@key(\"id\")\nid: string;\nname: string | null;\ndob?: utcDateTime | null;\n}\n```\nThis will greatly affect how Rust will support this, give a discussion Larry, Johan, and I were having yesterday.", "ground_truth": "Currently, TypeSpec does **not** have built-in or explicit support for `application/merge-patch+json` (JSON Merge Patch). That means there are no dedicated keywords or types in the language to model it directly.\nThe current recommended approach is to **manually define a separate PATCH model** for each resource. This model should mirror the resource structure, but all properties should be made optional. This expresses the correct merge-patch behavior where only specified fields are updated.\nImportantly, we **do not use `| null` in the model to indicate erasable fields**. Just like in Azure and Graph, we treat merge-patch support as a **fundamental protocol decision of the service**, not something that should be reflected in the type system. In other words, the ability to pass `null` is not encoded in the TypeSpec models today.\nThat said, we recognize that for generation-first languages like Rust, it's essential to know whether a field can explicitly be `null` versus being omitted. To address this, we're currently designing a new **`MergePatch` template**, which will help service authors more easily generate accurate merge-patch OpenAPI schemas. It will also make it possible for emitters to trace a merge-patch model back to its original resource definition.", "response": "TypeSpec provides explicit support for `application/merge-patch+json` (JSON Merge Patch) via special model templates, not by simply adding `| null` to property types. The recommended and supported approach is to use the `MergePatchUpdate` and `MergePatchCreateOrUpdate` templates from the TypeSpec.Http library. These templates automatically transform your resource model into a merge-patch model according to RFC 7396 rules.\n\nKey points:\n- **Do not manually add `| null` to properties** to indicate erasable fields for merge-patch. This is not the intended pattern and does not accurately model merge-patch semantics in TypeSpec.\n- Instead, use the `MergePatchUpdate<T>` or `MergePatchCreateOrUpdate<T>` templates. These generate a PATCH model where all properties are optional, and the correct nullability and erasure semantics are applied according to the property type and defaults.\n- For example, given a resource model, you would write:\n\n```typespec\ntype PatchBody = MergePatchUpdate<Resource>;\n```\n\n- The transformation rules are:\n  - Required properties without a default become optional in the patch model, but cannot be set to null.\n  - Optional properties can be omitted or set to null (erased).\n  - Properties with a default value, if set to null, revert to their default value.\n  - Model and record properties are recursively transformed.\n\nThis approach ensures that code generators (including Rust) can accurately reflect the merge-patch semantics without ambiguity about nullability or erasure.\n\nIn summary: **Use the MergePatch templates, not manual `| null` unions, to model JSON Merge Patch in TypeSpec.**", "context": null, "latency": 14.204097986221313, "response_length": 1623}
{"query": "title: How to make an interface internal ?\n\nquestion: I am looking for ways to make an interface internal so that it does not appear in public interface of python SDK. This is the interface which emits `EvaluationResultsOperations` which shows up on client. I would like to generate it but keep it hidden from public interface.\nI tried following:\n1. Mark all operations under it internal\n2. Adding @access decorator to interface but that fails.\nIs there a way to achieve it ?", "ground_truth": "If your goal is to **hide an operations interface from the public Python SDK surface**, here's the key takeaway:\n> **We currently do not support hiding an entire operation group directly.**\nHowever, there are **two main approaches** to achieve your intent:\n1. **Use `client.tsp` to redefine your client** and control which operations appear on the public client. When you redefine the client structure this way, **default service clients (and their `Operations` classes) should not be emitted**—as long as there’s no leftover generated code from a previous run. Make sure to:\n* Remove all previously generated SDK output before regenerating.\n* Verify your custom client structure is complete.\n2. **Use `_patch.py` to customize visibility**, e.g., by renaming `client.evaluation_results` to `client._evaluation_results`, if needed. This is a workaround until more flexible TypeSpec features are available.\n> Also, note that the `@access` decorator doesn’t work on interfaces right now—it’s not interpreted that way by the client generator (tcgc).\nSo, the current best practice is to **redefine the client properly in `client.tsp`**, clean your generated code, and regenerate to reflect the changes accurately.", "response": "Currently, TypeSpec does not support directly marking an entire interface as internal so that it is hidden from the public Python SDK surface. The `@access` decorator does not work on interfaces for this purpose, and marking all operations under the interface as internal is not sufficient to hide the operation group from the generated client.\n\n**Recommended approach:**\n\n1. **Redefine your client in `client.tsp`** to explicitly control which operations and operation groups are exposed in the public client. By customizing the client structure, you can prevent unwanted operation groups (such as `EvaluationResultsOperations`) from appearing in the generated SDK. Make sure to remove any previously generated SDK output before regenerating to avoid leftover code.\n2. **Workaround:** If you need to further hide or rename generated members, you can use a `_patch.py` file to rename or hide members (e.g., rename `client.evaluation_results` to `client._evaluation_results`).\n\n**Summary:**\n- There is no built-in way to mark an entire interface as internal for SDK generation.\n- Use client customization in `client.tsp` to control the public surface.\n- The `@access` decorator does not apply to interfaces for this use case.\n\nFor more details and examples, see the reference below.", "context": null, "latency": 8.50714635848999, "response_length": 1281}
{"query": "title: Sharing models between data plane and control plane\n\nquestion: Has anyone successfully shared models between control plane and data plane? I'm struggling with this seemingly simple task and could use come guidance or an example other than the trivial one for sharing a TSP file withing control plan or within data plane for a single service.\nEven to share models across separate versioned data plane APIs, I ended up creating a new data plane shared namespace and associated version to get it working. Do I need to create a control plane shared namespace and version? This makes me a bit nervous about conflicting versions of the same dependency between the service namespace, data plane shared namespace and control plane shared namespace.\nWhen I try to cross data plane and control plane TypeSpec, I end up with unhelpful errors like this:\n```\n<unknown location>:1:1 - error @typespec/versioning/using-versioned-library: Namespace '' is referencing types from versioned namespace 'Azure.Core' but didn't specify which versions with @useDependency.\n<unknown location>:1:1 - error @typespec/versioning/using-versioned-library: Namespace '' is referencing types from versioned namespace 'Azure.ResourceManager' but didn't specify which versions with @useDependency.\n```\nOr errors about multiple namespace or about @service not specifying a namespace even though it does.", "ground_truth": "Yes, you **can share models** between data plane and control plane, but you need to be careful:\n* ✅ **Create a shared namespace** (e.g., `Discovery.Shared`) that’s not tied to either control or data plane.\n* ✅ **Version the shared types independently**, not tied to any API version.\n* ✅ **Avoid ARM library dependencies in data plane** — model things like resource IDs using aliases or common types.\n* ✅ Use `@useDependency` to reference versioned namespaces like `Azure.Core` or `Azure.ResourceManager`.\nThis way, you can safely reuse types without introducing versioning conflicts or unwanted dependencies.", "response": "Yes, it is possible to share models between the control plane and data plane in TypeSpec, but there are important best practices to avoid versioning and dependency issues:\n\n- **Create a shared namespace** (for example, `MyService.Shared`) that is not tied to either the control plane or data plane. This namespace should contain only the models you want to share.\n- **Version the shared types independently** from your control plane and data plane APIs. This helps prevent version conflicts.\n- **Avoid referencing ARM (Azure Resource Manager) libraries in your data plane models.** If you need to represent things like resource IDs, use simple types or aliases instead of pulling in ARM dependencies.\n- **Use `@useDependency`** to explicitly specify which versions of versioned namespaces (like `Azure.Core` or `Azure.ResourceManager`) you are referencing. This is required to resolve errors like:\n  ```\n  error @typespec/versioning/using-versioned-library: namespace '' is referencing types from versioned namespace 'azure.core' but didn't specify which versions with @usedependency.\n  ```\n\nBy following these steps, you can safely share models between control plane and data plane without introducing versioning conflicts or unwanted dependencies. If you need to share models across multiple versioned APIs, creating a dedicated shared namespace and versioning it independently is the recommended approach.\n\nIf you encounter errors about multiple namespaces or missing `@service` annotations, double-check that each namespace is properly defined and that you are using `@useDependency` where required.\n\nFor more details and examples, see the Q&A below.", "context": null, "latency": 8.506028413772583, "response_length": 1654}
{"query": "title: Question regarding the unexpected readonly, and customize the enum name\n\nquestion: Hi team,\nWhen dealing with the TypeSpec migration, we hit below two issues. Could you help take a look and see if there is any way to fix them? Thanks!\n1. Haven't add @visibility(Lifecycle.Read) to the property, but the definition has \"readOnly\": true on it.\n- TSP: https://github.com/Azure/azure-rest-api-specs/blob/45317772ce7c50313eaf55b8d242f4d12ca6fe06/specification/desktopvirtualization/DesktopVirtualization.Management/models.tsp#L3665\nSwagger: https://github.com/Azure/azure-rest-api-specs/blob/45317772ce7c50313eaf55b8d242f4d12ca6fe06/specification/desktopvirtualization/resource-manager/Microsoft.DesktopVirtualization/preview/2025-04-01-preview/desktopvirtualization.json#L11380\n- TSP: https://github.com/Azure/azure-rest-api-specs/blob/45317772ce7c50313eaf55b8d242f4d12ca6fe06/specification/desktopvirtualization/DesktopVirtualization.Management/models.tsp#L4859\nSwagger: https://github.com/Azure/azure-rest-api-specs/blob/45317772ce7c50313eaf55b8d242f4d12ca6fe06/specification/desktopvirtualization/resource-manager/Microsoft.DesktopVirtualization/preview/2025-04-01-preview/desktopvirtualization.json#L10826\n2. How to make enum's \"x-ms-enum\" name to be different than the type name like below?\n- https://github.com/Azure/azure-rest-api-specs/blob/cb262725d128f6dfec4622cca03bc9e04e2d0f1f/specification/desktopvirtualization/resource-manager/Microsoft.DesktopVirtualization/preview/2024-11-01-preview/desktopvirtualization.json#L9487C4-L9493C33", "ground_truth": "1. This is because of this https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error/#_top\n2. No its not possible change the enum name to be what is in `x-ms-enum.name` it is pointless information otherwise", "response": "Let's address your two issues:\n\n### 1. Unexpected `readonly: true` in Swagger without `@visibility(lifecycle.read)` in TypeSpec\nThis is a known issue due to how the validation and conversion tools interpret read-only properties. The root cause is that the LintDiff and some validation scripts use an outdated mechanism to detect `readOnly` properties, which may not align with your TypeSpec decorators. The recommended workaround is to set `use-read-only-status-schema: true` in your `tspconfig.yaml` under the `@azure-tools/typespec-autorest` options. This will help align the generated OpenAPI with the expected read-only status and avoid false positives in validation.\n\nExample:\n```yaml\ne mit:\n  - \"@azure-tools/typespec-autorest\"\noptions:\n  \"@azure-tools/typespec-autorest\":\n    use-read-only-status-schema: true\n```\n\nFor more details, see the references below.\n\n### 2. Customizing the `x-ms-enum` Name in OpenAPI\nBy default, TypeSpec uses the type name as the `x-ms-enum.name` in the generated OpenAPI. Previously, it was not possible to customize this. However, as of version 0.51.0 (February 2025), you can use the `@clientName` decorator on your enum or union type in TypeSpec, and the value will propagate to `x-ms-enum.name` in the emitted OpenAPI. This allows you to set a different name for the enum in the OpenAPI output.\n\n**Example:**\n```tsp\n@clientName(\"CustomEnumName\")\nunion MyEnum {\n  Value1: \"Value1\",\n  Value2: \"Value2\"\n}\n```\nThis will result in `x-ms-enum.name` being set to `CustomEnumName` in the OpenAPI.\n\n#### Summary Table\n\n| Issue | Solution |\n|-------|----------|\n| Unexpected `readonly: true` | Set `use-read-only-status-schema: true` in `tspconfig.yaml` |\n| Custom `x-ms-enum.name` | Use `@clientName` decorator on the enum/union |\n", "context": null, "latency": 11.359038829803467, "response_length": 1762}
{"query": "title: Discrepancy in the original LRO response and Status Monitor Response\n\nquestion: Hi TypeSpec Discussion team,\nWe have created a long running resource action on our dataplane resource and have created a common status monitor endpoint (`operations/{operationId}`). Now the default status monitor response for the LRO comes out to be :\n```\n{\n\"id\": \"\",\n\"status\": \"\"\n\"error\": \"\"\n}\n```\nHowever, following standard resource conventions for the status monitor, the LRO for it comes out to be :\n```\n{\n\"operationId\": \"\",\n\"status\": \"\",\n\"kind\": \"\"\n\"error\": \"\"\n}\n```\nGiven this, how can I change the response of our Long Running Action defined?\nHere is Repro Link: https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3JlIjsKCnVzaW5nIEh0dHA7xwxSZXN0yAxWyVfIEkHEPi5Db3Jl0hIuVHJhaXRzOwoKQHVzZUF1dGgoCiAgQXBpS2V5xA48xgtMb2NhdGlvbi5oZWFkZXIsICJhcGkta2V5Ij4gfCBPxCoyxS9bCiAgICB7xQYgIOQAwTrHH0Zsb3dUeXBlLmltcGxpY2l0LMclYXV0aG9yaXrFYVVybDogIuQBTXM6Ly9sb2dpbi5jb250b3NvLmNvbS9jb21tb24vb8Q1Mi92Mi4wL8hAZSLIUnNjb3BlczogW8lJd2lkZ2V0zUouZGVmYXVsdCJdxjd9CiAgXT4KKQpAc2VydmljZSgjeyB0aXRsZTogIkPGOSBXxUggTWFuYWdlciIgfccvZXLkATcie2VuZHBvaW50fcdy5QCT0D5BUElzxRnmAScvKiogClN1cOQCAWVkyCVT5gCFcyDIU3MgKHByb3RvY29sIGFuZCBob3N0bmFtZSwgZm9yIGV4YW1wbGU6CukA8mVzdHVzLmFwaS7yAP0pLgogKi%2FFfshfOiBzdHJpbmfkAJh95AEG5wKfZWQo5wC%2FLuYAmucA%2FC7nAmhzKQrkAIZzcGFjZSDVKjsKCuQA41RoySDvAUcg5wFxIMdzLuQAnGVudW3oAsxz5QEqxEXHESAyMDIyLTA4LTMxxCwgIOQCvURlcGVuZGVuY3ko6wLgyEMudjFfMF9QcmV2aWV3XzIpCiAgYMlGMGAsCn0KCi8vIE1vZGVscyAv0wHqAMdjb2xvciBvZiBhIOcBXOQAhnVu5ACa5gDbQ8Ui5AC26AFW5wDBQmxhY2vHJSDGJuUAwcUYOiAixQgiyS9XaGl0ZdMvxRg6ICLFCMovUuoCQMstUmVkOiAiUmVkyilHcmVl6ACszCvFGDogIsUIyi9CbHX0AIbEF%2BUAtHXkAITkAUEqKiBB7AEUQHJlc291cmNlKCLGFnMiKQpt5AFkyE%2FoAdrkAVjGIyDkAlDFPiAgQGtlecg7TmFtZSLkAbhAdmlzaWJpbGl0eShMaWZlY3ljbGUuUmVhZMQexD7oAs076ADBy17lAb3HX8UMOuwBtM0ySUTkAeV0yTwncyBtYW51ZmFjdHVyZchFzBNJZM17Li4uRXRhZ1Byb3BlcnR5O%2BQBJEBkb2MoIk9wZXLlBPEgSWQgUGF0aCBQYXJhbWV0ZXIu6QEjySVJZMQjySLlATXGSOQAp3VuaXF17ACuxG7FOMRL5gFF%2FwE3IMo07ADD6QCvS2luZMhebG9uZyBydW7kBmPOa%2BYDAukAtsU17wME8AD%2BcmVwcmVzZeQE32EgY2xvbukBqMla5QDEQ8Qb5gGo5AWPyg7mAnnGV1N0YXR1c%2BYDmfoApusClMkY6gKX6QCbx03uAWtzdGF0ZfcBZ8QcdXM6IEZvdW5kxlYuzU5l5QIUyk1r6wFVz0zEGzruAUrLPUVycuQEgGJqZWN0IHRoYXQgZGVzY3JpYmVzxU1lxSB3aGVu5wCVIGlzIFwiRmFpbGVkXCLGY8UlP%2B4Ar8VZ6AK6%2BAJ%2B5QIX5gEt5QGx5gGIUmVxdWVz5gPQbmV3xhVJZD%2FtAk0vL%2BoA1PgFZWFsaWFz6Ab%2F5gieID0g5wcgc1JlcGVhdGFibGXHcXMgJgogyR9Db25kacReYWzWIGxpZW7oAKxJ5AFUxm%2FrAJY97AkeUucCK8ogPO0Amj47CgppbnRlcmbkBv9McstI5AEJZ2V08AJQaXMgU3RhbmRhcmTSXclw5AOWPM87PuUBQ8pu5gFjxGnoBdVldCBhxxfmBJtnZXTHD2nsAOTOZ8Yi5ADKxkflA13pBtvGSUBwb2xsaW5nyUQo7ADsLvIA6OUEeGZpbmFsyjPGacUuxgvFJWFjxR0i5QJM5QKa6wJW%2FwEvTG9uZ1LmA%2BTIHkHFT%2BcA1SzzAqIsIG5ldmVy5ADwfQo%3D&e=%40azure-tools%2Ftypespec-autorest&options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fdata-plane%22%5D%7D%7D", "ground_truth": "A notice on Guideline on LRO, the \"id\" of the status monitor should be \"id\", not \"operationId\"\nhttps://github.com/microsoft/api-guidelines/blob/vNext/azure/ConsiderationsForServiceDesign.md#long-running-action-operations\nTo ensure its called {operationId} in the route template but id in the response object, I think you can use this\n```\n@key(\"operationId\")\n@visibility(Lifecycle.Read)\nid: string;\n```", "response": "To customize the response shape of your status monitor endpoint for a long-running operation (LRO) in TypeSpec, you should define your own StatusMonitor model with the desired fields and use the appropriate decorators to indicate which fields represent status, result, and error. Then, link your LRO to this status monitor operation using the @pollingOperation decorator.\n\nFor example, if you want your status monitor response to have fields like \"operationId\", \"status\", \"kind\", and \"error\", you can define your model as follows:\n\n```typespec\n@lroStatus\nunion OperationStatus {\n  Running: \"Running\",\n  Succeeded: \"Succeeded\",\n  Failed: \"Failed\",\n  Canceled: \"Canceled\",\n  string,\n}\n\nmodel CustomStatusMonitor {\n  operationId: string;\n  status: OperationStatus;\n  kind?: string;\n  error?: Error;\n}\n\n@route(\"/operations/{operationId}\")\nop getOperationStatus(@path operationId: string): CustomStatusMonitor | ErrorResult;\n\n@pollingOperation(getOperationStatus)\nop doLongRunningAction(...): ...;\n```\n\nKey points:\n- Use @lroStatus on the status field (which can be a union for custom terminal states).\n- You can add any additional fields (like operationId, kind) as needed.\n- Link your LRO to the custom status monitor operation with @pollingOperation.\n\nThis approach allows you to fully control the shape of the status monitor response for your LROs.\n\nFor more details and examples, see the documentation on custom status monitors and decorators for LROs in Azure.Core.", "context": null, "latency": 13.35245680809021, "response_length": 1466}
{"query": "title: Visibility-sealed error while validating locally\n\nquestion: I am getting this error while running `npx tsv` locally:\n```\nerror visibility-sealed: Visibility of property 'name' is sealed and cannot be changed.\n> 155 | @Azure.ResourceManager.Private.armResourceInternal(FileSystemResourceProperties)\n```\nI tried removing the visibility decorator for the field/property 'name', but still the error was coming.\nHow do I resolve this?\nPackage version details:\n```\n\"@typespec/compiler\": \"0.67.2\",\n\"@typespec/http\": \"0.67.1\",\n\"@typespec/sse\": \"0.67.1\",\n\"@typespec/events\": \"0.67.1\",\n\"@typespec/openapi\": \"0.67.1\",\n\"@typespec/openapi3\": \"0.67.1\",\n\"@typespec/prettier-plugin-typespec\": \"0.67.1\",\n\"@typespec/rest\": \"0.67.1\",\n\"@typespec/streams\": \"0.67.1\",\n\"@typespec/versioning\": \"0.67.1\",\n\"@typespec/xml\": \"0.67.1\",\n```\nThe relevant typespec file:\n```\nimport \"./../LiftrBase/main.tsp\";\nimport \"@typespec/openapi\";\nimport \"@typespec/http\";\nimport \"@typespec/rest\";\nimport \"@typespec/versioning\";\nusing Azure.ResourceManager;\nusing LiftrBase;\nusing TypeSpec.Http;\nusing TypeSpec.OpenAPI;\nusing TypeSpec.Rest;\nusing TypeSpec.Versioning;\nusing TypeSpec.Reflection;\nusing Azure.ResourceManager.Foundations;\n@versioned(LiftrBase.Storage.Versions)\n@armLibraryNamespace\nnamespace LiftrBase.Storage;\n@doc(\"Supported versions for LiftrBase.Storage resource model\")\nenum Versions {\n@doc(\"Dependent on Azure.ResourceManager.Versions.v1_0_Preview_1 and LiftrBase.Versions.v1_preview\")\n@useDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)\n@useDependency(LiftrBase.Versions.v2_preview)\n@armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v3)\nv2_preview: \"2024-02-01-preview\",\n}\n/**\n* Properties specific to the Qumulo File System resource\n*/\nmodel FileSystemResourceProperties {\n/**\n* Marketplace details\n*/\nmarketplaceDetails: MarketplaceDetails;\n/**\n* Provisioning State of the resource\n*/\n@visibility(Lifecycle.Read)\nprovisioningState?: ProvisioningState;\n/**\n* Storage Sku\n*/\nstorageSku: string;\n/**\n* User Details\n*/\nuserDetails: UserDetails;\n/**\n* Delegated subnet id for Vnet injection\n*/\ndelegatedSubnetId: string;\n/**\n* File system Id of the resource\n*/\nclusterLoginUrl?: string;\n/**\n* Private IPs of the resource\n*/\nprivateIPs?: string[];\n/**\n* Initial administrator password of the resource\n*/\n@extension(\"x-ms-secret\", true)\nadminPassword: string;\n/**\n* Availability zone\n*/\navailabilityZone?: string;\n}\n/**\n* Common fields that are returned in the response for all Azure Resource Manager resources\n*/\nmodel Resource {\n/**\n* Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}\n*/\n@visibility(Lifecycle.Read)\nid?: string;\n/**\n* The name of the resource\n*/\n@visibility(Lifecycle.Read)\nname?: string;\n/**\n* The type of the resource. E.g. \"Microsoft.Compute/virtualMachines\" or \"Microsoft.Storage/storageAccounts\"\n*/\n@visibility(Lifecycle.Read)\ntype?: string;\n/**\n* Azure Resource Manager metadata containing createdBy and modifiedBy information.\n*/\n@visibility(Lifecycle.Read)\nsystemData?: SystemData;\n}\n/**\n* The type used for update operations of the FileSystemResource.\n*/\nmodel FileSystemResourceUpdate {\n/**\n* The managed service identities assigned to this resource.\n*/\nidentity?: Azure.ResourceManager.CommonTypes.ManagedServiceIdentity;\n/**\n* Resource tags.\n*/\ntags?: Record<string>;\n/**\n* The updatable properties of the FileSystemResource.\n*/\nproperties?: FileSystemResourceUpdateProperties;\n}\n/**\n* The updatable properties of the FileSystemResource.\n*/\nmodel FileSystemResourceUpdateProperties {\n/**\n* Marketplace details\n*/\nmarketplaceDetails?: MarketplaceDetails;\n/**\n* User Details\n*/\nuserDetails?: UserDetails;\n/**\n* Delegated subnet id for Vnet injection\n*/\ndelegatedSubnetId?: string;\n}\n@Http.Private.includeInapplicableMetadataInPayload(false)\n@Azure.ResourceManager.Private.armResourceInternal(FileSystemResourceProperties)\nmodel FileSystemResource\nis Azure.ResourceManager.TrackedResource<FileSystemResourceProperties> {\n/**\n* Name of the File System resource\n*/\n@path\n@key(\"fileSystemName\")\n@segment(\"fileSystems\")\n@visibility(Lifecycle.Read)\n@pattern(\"^[a-zA-Z0-9_-]*$\")\nname: string;\n...Azure.ResourceManager.ManagedServiceIdentityProperty;\n}\n```", "ground_truth": "I believe this occurs because  the `TrackedResource` template already has the @Azure.ResourceManager.Private.armResourceInternal decorator applied, and using the model is, you are including both decorators in that type.  Based on the suppression you also have there on 'composition-over-inheritance', my guess s that this type previouslu used `FileSystemResource extends TrackedResource<FileSystemProperties>`  in this case, the decorator from TrackedResource<T>  would not be applied.\nThe solution would be to remove the `armResourceInternal`  decorator here, because it is redundant", "response": "The error `visibility-sealed: visibility of property 'name' is sealed and cannot be changed` occurs because the `TrackedResource<TProperties>` template (which you are using via `is Azure.ResourceManager.TrackedResource<FileSystemResourceProperties>`) already applies the necessary decorators, including visibility, to the `name` property. When you add another `@visibility` decorator to the `name` property in your derived model, TypeSpec detects a conflict because the visibility for that property is already 'sealed' (i.e., locked and cannot be changed).\n\nTo resolve this error, you should remove the `@visibility` decorator from the `name` property in your `FileSystemResource` model. The base `TrackedResource` type already handles the correct visibility for `name`, so you do not need to (and cannot) override it in your derived model.\n\n**Recommended fix:**\n- Remove the `@visibility(Lifecycle.Read)` decorator from the `name` property in your `FileSystemResource` model.\n- Also, ensure you are not redundantly applying decorators like `@Azure.ResourceManager.Private.armResourceInternal` if the base type already applies them.\n\nThis approach aligns with how ARM resource types are modeled in TypeSpec, as shown in the documentation examples.\n", "context": null, "latency": 9.712347269058228, "response_length": 1248}
{"query": "title: Annotate same model with SubscriptionLocationResource and ResourceGroupLocationResource\n\nquestion: 1. We have added a new SubscriptionLocationResource named \"ValidatedSolutionRecipe\", as per the typespec docs to our RP - Microsoft.AzureStackHCI. Here is the typespec for this resource\n2. This is a proxy resource and the URL path for this resource looks like \"/subscriptions/921d26b3-c14d-4efc-b56e-93a2439e028c/providers/Microsoft.AzureStackHCI/locations/eastus/validatedSolutionRecipes/10.2502.0?api-version=2023-12-01-preview\"\nAs above API is a subscription level API, the clients of the API need to have subscription level RBAC. Due to security requirements, we need to have a similar API, but at resource group scope.\n1. From the typespec docs and our prototyping, we see that we can achieve this by havning a ResourceGroupLocationResource.\n2. However, same model in typespec can't be annotated with both SubscriptionLocationResource and ResourceGroupLocationResource. When we do so, the generated swagger only has either subscription level paths or resourcegroup level paths, depending on which annotation is first on the model.\n3. Thus, to work around this, we had to introduce a new resource type with an undesirable name - \"ResourceGroupValidatedSolutionRecipe\".\nBut it is the same resource. Just because of the limitation of not being able to support both [SubscriptionLocationResource](https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types/#Azure.ResourceManager.SubscriptionLocationResource) and [ResourceGroupLocationResource](https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types/#Azure.ResourceManager.ResourceGroupLocationResource), we have to create a new model with an undesirable name - \"ResourceGroupValidatedSolutionRecipe\".\nPlease help us and let us know how can we utilize the model with same name (i.e. the same resource type) for both of the above APIs.", "ground_truth": "he main issue is that TypeSpec does not support annotating the same model with both SubscriptionLocationResource and ResourceGroupLocationResource. This leads to the creation of two different models (e.g., ValidatedSolutionRecipe and ResourceGroupValidatedSolutionRecipe), even though they represent the same resource. According to ARM requirements, these resources must be registered as two different types because they have different scopes and operations.\nSolution:\nShared Model: If the operations for both resources are identical, you can consider using custom operations to share the same model, avoiding the need to create two different resource types.\nRPaaS Proxy Resources: By using RPaaS extensions, you can handle this scenario and simplify the API, reducing confusion for customers.\nIn summary, although the resources may represent the same entity, due to ARM registration requirements and operational differences, two models may be necessary. However, using custom operations or extension resource patterns can help avoid redundant model creation in certain cases.", "response": "TypeSpec currently does not support annotating the same model with both `@subscriptionLocationResource` and `@resourceGroupLocationResource` (or their equivalents). As a result, you cannot generate both subscription-level and resource-group-level paths for the same resource type/model in a single TypeSpec definition. This limitation forces you to define two separate resource types (e.g., `ValidatedSolutionRecipe` and `ResourceGroupValidatedSolutionRecipe`), even if they represent the same logical resource.\n\n**Recommended Approach:**\n- If the operations and properties are identical, you can define a shared properties model and use it in both resource types to avoid duplication.\n- Alternatively, you can use custom operations or extension resource patterns to expose the same model at different scopes, but you will still need to define two resource types for ARM registration and path generation.\n\n**Summary Table:**\n\n| Option | Pros | Cons |\n|-------|------|------|\n| Two resource types (current workaround) | Follows ARM requirements, generates correct paths | Duplicate resource type names, maintenance overhead |\n| Shared properties model | Reduces duplication | Still requires two resource types |\n| Custom operations/extension resource | Can avoid redundant models in some cases | More complex, may not fit all scenarios |\n\nThis is a known limitation due to ARM and TypeSpec design. For more details, see the Q&A below.\n\n> \"The main issue is that TypeSpec does not support annotating the same model with both SubscriptionLocationResource and ResourceGroupLocationResource. This leads to the creation of two different models (e.g., ValidatedSolutionRecipe and ResourceGroupValidatedSolutionRecipe), even though they represent the same resource. According to ARM requirements, these resources must be registered as two different types because they have different scopes and operations.\"\n\nIf you want to avoid confusion for customers, consider using RPaaS proxy resources or extension resource patterns, but ARM registration will still require two types.\n\n**In summary:** You cannot annotate a single model with both resource types in TypeSpec. The best practice is to share the properties model and define two resource types, or use custom operations if appropriate.", "context": null, "latency": 11.176673889160156, "response_length": 2278}
{"query": "title: Support for @includeInapplicableMetadataInPayload decorator\n\nquestion: After pulling the latest changes, I been getting errors regarding \"@includeInapplicableMetadataInPayload(false)\" decorator not being supported anymore.\nIs it not possible to make use of the decorator? If I removed the decorator from the model ts file, it changes the expected model definition for the API path on swagger.", "ground_truth": "The issue is related to the deprecation of the @includeInapplicableMetadataInPayload(false) decorator in TypeSpec version 0.67. It has been moved to a private namespace, and you can still use it, but with a warning.\nDecorator Usage: You can still use the @includeInapplicableMetadataInPayload decorator, but it will trigger a warning since it's now in a private namespace.\nBreaking Change: Removing this decorator causes a breaking change for existing API versions because the Swagger model definition is altered.\nSuggestion: The team suggests not relying on the decorator and using existing resource models like TrackedResource<T> instead.", "response": "The error you are seeing is due to a breaking change in TypeSpec version 0.67: the `@includeInapplicableMetadataInPayload` decorator has been moved to a private namespace and is no longer officially supported for public use. You can still use it, but it will trigger a warning, and its future availability is not guaranteed.\n\nIf you remove the decorator, it will change the generated OpenAPI/Swagger model, which can be a breaking change for existing APIs. The recommended approach is to avoid relying on this decorator and instead use existing resource models like `TrackedResource<T>` to achieve the desired API shape.\n\n**Summary:**\n- The decorator is deprecated and moved to a private namespace (not recommended for use).\n- Removing it changes your API model output.\n- Prefer using standard resource models or refactoring your TypeSpec models to avoid the need for this decorator.\n\nIf you have a strong use case, consider filing an issue with the TypeSpec team.", "context": null, "latency": 8.270363092422485, "response_length": 964}
{"query": "title: Type Spec review for Data plane API specs\n\nquestion: Hi TypeSpec Discussion, do we need review from type spec team before we could merge data plane API spec PR on github specs repo?", "ground_truth": "All data plane API specs must be reviewed by the API Stewardship board.  Please create a release plan and then you can schedule a review.  [What is a release plan](https://eng.ms/docs/products/azure-developer-experience/plan/release-plan)?", "response": "Hi! For data plane API specs, you do NOT need a review from the TypeSpec team specifically before merging a PR in the specs repo. However, all data plane API specs must be reviewed by the API Stewardship board. The process is to create a release plan and then schedule a review with the board. You can find more about what a release plan is in the linked documentation.", "context": null, "latency": 4.9952757358551025, "response_length": 369}
{"query": "title: What is `x-ms-long-running-operation-options` for LRO operation of data-plane when `emit-lro-options: none` in `@azure-tools/typespec-autorest`?\n\nquestion: Many `tspconfig.yaml` files for data-plane have an option `emit-lro-options: none` for emitter `@azure-tools/typespec-autorest`, which means only emit `x-ms-long-running-operation` but does not emit`x-ms-long-running-operation-option` for resource providers, like the following loadtestservice `tspconfig.yaml`: [azure-rest-api-specs/specification/loadtestservice/LoadTestService/tspconfig.yaml at main · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/loadtestservice/LoadTestService/tspconfig.yaml#L24)\nSo what exactly does this data-plane operation use when polling LRO request then? Can someone explain a little more about this situation of `emit-lro-options: none`? thanks", "ground_truth": "This is just an emitter option for emission of OpenAPI from the spec.  It doesn't impact how other emitters view the LRO - the LRO is resolved based on the encoding of the operation.\nBecause it's nice to have a visual indicator that the lro is encoded correctly, it is highly encouraged that spec authors use no emit-lro-options seting, , or use `emit-lro-options: \"all\"` to check .  But this is not required for check-in, because the lro-options are a microsoft-specific extension with little or no documentary value to customers.\nWe don't generate data plane clients from OpenAPI if there is a corresponding TypeSpec, they are generated form TypeSpec directly.", "response": "When you set `emit-lro-options: none` in the `@azure-tools/typespec-autorest` emitter options for a data-plane TypeSpec project, the emitter will only emit the `x-ms-long-running-operation` extension in the generated OpenAPI, and will NOT emit the `x-ms-long-running-operation-options` extension. \n\nThis does NOT affect how the actual long-running operation (LRO) is modeled or how clients poll for LRO completion. The LRO behavior is determined by the operation's structure and the TypeSpec modeling (such as use of Azure.Core LRO templates and decorators), not by the presence of `x-ms-long-running-operation-options` in the OpenAPI. \n\nFor data-plane services, client SDKs are generated directly from TypeSpec, not from the OpenAPI, so the absence of `x-ms-long-running-operation-options` does not impact client generation or LRO polling logic. The polling mechanism is still determined by the TypeSpec LRO modeling (e.g., which headers are used, what endpoints to poll, etc.), and the generated OpenAPI will still have enough information for tools that rely on `x-ms-long-running-operation`.\n\nIn summary: `emit-lro-options: none` just omits a Microsoft-specific OpenAPI extension that is not required for data-plane LROs. The actual LRO polling logic is unaffected and is driven by the TypeSpec model and Azure.Core conventions.", "context": null, "latency": 10.44843077659607, "response_length": 1331}
{"query": "title: Why does the PR bot add the `WaitForARMFeedback` label when TypeSpec validation pipeline fails?\n\nquestion: Hi, not a typespec question per se, but I am curious why the PR bot now adds the WaitForARMFeedback label even when required checks fail? If I'm remembering correctly, this didn't used to be the case.\nAnd now that it does add the label, it seems like the reviewer will typically manually say \"Fix X pipeline check.\" and then switch it to \"ARMChangesRequested\".\nWould it be possible for that to happen automatically? I feel bad for wasting the reviewer's time if I don't sit around and wait for the pipeline to fail and then manually remove the label myself.\nOr is the expectation that a commit shouldn't be pushed if I think the required checks may fail?", "ground_truth": "The WaitForARMFeedback label being added even when required checks fail is intended behavior and has always worked this way, according to the ARM review team.\nIdeally, contributors should open a draft PR first and only mark it \"ready for review\" after all required checks pass. This avoids wasting reviewer time.\nThe suggestion to automatically change the label to ARMChangesRequested when checks fail is a good idea and is already on the backlog.\nThe engineering team is currently migrating the labeling system to GitHub Actions, which should make improvements like this easier in the future.", "response": "The PR bot adds the `WaitForARMFeedback` label even when required checks (like the TypeSpec validation pipeline) fail because this is the intended behavior, according to the ARM review team. This approach has always been in place. The recommended workflow is to open a draft PR and only mark it as 'ready for review' after all required checks have passed, which helps avoid unnecessary reviewer effort.\n\nYour suggestion to automatically switch the label to `ARMChangesRequested` when checks fail is a good one and is already on the backlog for future improvements. The engineering team is currently migrating the labeling system to GitHub Actions, which should make it easier to implement such enhancements in the future.", "context": null, "latency": 5.847080707550049, "response_length": 721}
{"query": "title: Is path case sensitive?\n\nquestion: I have these swaggers paths:\n```\n\"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ElasticSan/elasticSans/{elasticSanName}/volumeGroups\"\n\"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ElasticSan/elasticSans/{elasticSanName}/volumegroups/{volumeGroupName}\"\n```\nThe second path represents a resource like\n```\nmodel VolumeGroup\nis Azure.ResourceManager.ProxyResource<VolumeGroupProperties> {\n...ResourceNameParameter<\nResource = VolumeGroup,\nKeyName = \"volumeGroupName\",\nSegmentName = \"volumegroups\",\nNamePattern = \"^[A-Za-z0-9]+((-|_)[a-z0-9A-Z]+)*$\"\n>;\n```\nPay attention to segment is volumegroups.\nThe first path is a list operation to this resource. However, its last segment is volumeGroups. If I use ArmResourceListByParent<VolumeGroup> for the first path it produces volumegroups. Can I use it?", "ground_truth": "static segments in ARM urls are meant to be case-insensitive.  In this case, the swagger is incorrect, since this is clearly meant to be the ARM type name.  You should use the correct type name in both cases.\nIf the url is /subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/..., is that the same as `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/...? The \"G\" in resourceGroups has different cases.\nThese are case insensitive,  we should favor the camel case here, there is no need to match the exact casing of these in existing swagger.", "response": "Yes, you can use ArmResourceListByParent<VolumeGroup> for the first path, even though the casing of the static segment ('volumegroups' vs 'volumeGroups') differs. In ARM, static segments in URLs are meant to be case-insensitive. The recommended approach is to use the correct type name casing consistently in your TypeSpec definitions, but the ARM platform itself does not treat these segments as case-sensitive. Therefore, the generated path segment 'volumegroups' from ArmResourceListByParent<VolumeGroup> is valid and will work, even if the Swagger path uses 'volumeGroups'.\n\nIf possible, you should align the casing in your Swagger and TypeSpec definitions for clarity and consistency, but it is not a technical requirement for ARM resource paths.", "context": null, "latency": 6.783924102783203, "response_length": 751}
{"query": "title: Discriminators/polymorphism\n\nquestion: I'm looking into introducing polymorphism into one of our APIs. This question provides great insight but is apparently closed as a duplicate of an issue that does not seem exist. Mark Cowlishaw, do you know what the outcome of this no longer existent issue?\nNote that there is an issue around how we should encourage types using extends in Azure APIs to use discriminators here: https://github.com/Azure/typespec-azure/issues/3510\nLike Brian Terlson,  I tend to favor the union approach for operations:\nop create(@body body: Cat | Dog // replace the base class with union of subs)\nIs this the recommended Azure approach, union (i.e. @body: SubModel1 | SubModel2 for operation with @discriminator in base model type for @body ?", "ground_truth": "Azure recommends using @discriminator to model polymorphism, but there are still some missing pieces before discriminated union types will be allowed in Azure APIs. The polymorphism in the model looks correct, and it is suggested to use PascalCase for union variant names. Additionally, narrowing inherited property types in inheriting classes (except for the discriminator) is not allowed.", "response": "Azure recommends modeling polymorphism using discriminators, specifically with the `@discriminator` decorator on a base model and using model inheritance (`extends`) for subtypes. For operations, the preferred approach is to use the base model (with the discriminator) as the operation parameter, not a union of subtypes. This allows Azure tooling and OpenAPI emitters to generate the correct `discriminator` and `allOf` relationships in the schema.\n\nWhile unions can represent polymorphism (using `@discriminated` or `@oneOf`), Azure's guidance is to use model inheritance with discriminators for API bodies, as this aligns with Azure's linter rules and OpenAPI best practices. The union approach is more common in generic TypeSpec or OpenAPI, but for Azure APIs, inheritance with discriminators is the recommended and supported pattern.\n\n**Key points:**\n- Use `@discriminator` on the base model and `extends` for subtypes.\n- Do not use a union of subtypes as the operation body; use the base model.\n- The discriminator property should be an extensible union (not a string or closed enum).\n- Avoid nested discriminators (no multiple levels of polymorphism).\n\n**Example:**\n```typespec\n@discriminator(\"kind\")\nmodel Pet {\n  name: string;\n  kind: PetKind;\n}\n\nmodel Cat extends Pet {\n  kind: \"cat\";\n  meow: boolean;\n}\n\nmodel Dog extends Pet {\n  kind: \"dog\";\n  bark: boolean;\n}\n\nop create(@body body: Pet): ...\n```\n\nThis will generate the correct OpenAPI schema with a discriminator and `allOf` inheritance.\n\nIf you use a union for the operation body, it may not align with Azure's linter rules and could cause issues with downstream tooling.", "context": null, "latency": 12.894856452941895, "response_length": 1637}
{"query": "title: Folder structure recommendation for typespec.\n\nquestion: Hi Team,\nCan you please confirm what the folder structure needs to be for the .tsp files, specifically for teams that are separating services within the same RP namespace?", "ground_truth": "1. Service Folder Naming:\nEach service should reside in its own folder under the RP namespace.\nUse PascalCase for RP namespace folders (e.g., Language, Vision).\nService folders should be singular and lowercase (e.g., TextAnalytics, ComputerVision).\n2. Shared Libraries:\nIf multiple services share models or utilities, create a Shared folder at the same level as the services.\nExample:\n-> specification\n-> cognitiveservices\n-> Language.TextAnalytics\n-> Language.QnA\n-> Language.Shared\n-> Vision.ComputerVision\n-> Vision.CustomVision\n-> Vision.Shared\n3. Required Files in Each Service Folder:\ntspconfig.yaml: Configuration for emitters and SDK generation.\nmain.tsp: Entry point for the TypeSpec definitions.\nSupporting *.tsp files: For models, operations, etc.\nexamples/: Folder with example JSON files.\n4. SDK Generation:\nOnly services intending to generate SDKs should include emitter configuration in tspconfig.yaml.\nShared libraries should not include tspconfig.yaml.\n5. No package.json in Service Folder:\nUse the root-level package.json for dependencies like @azure-tools/typespec-autorest.\nThis structure ensures modularity and clarity when multiple services coexist under a single RP namespace, while also supporting shared components and SDK generation workflows.\nLet me know if you’d like help drafting a sample folder layout or tspconfig.yaml for your team.", "response": "For teams separating services within the same RP (Resource Provider) namespace, the recommended folder structure for .tsp files is as follows:\n\n1. **Service Folder Naming:**\n   - Each service should have its own folder under the RP namespace.\n   - Use PascalCase for RP namespace folders (e.g., `Language`, `Vision`).\n   - Service folders should be singular and lowercase (e.g., `TextAnalytics`, `ComputerVision`).\n\n2. **Shared Libraries:**\n   - If multiple services share models or utilities, create a `Shared` folder at the same level as the services.\n\n3. **Example Structure:**\n\n   ```\n   specification/\n     cognitiveservices/\n       Language.TextAnalytics/\n       Language.QnA/\n       Language.Shared/\n       Vision.ComputerVision/\n       Vision.CustomVision/\n       Vision.Shared/\n   ```\n\n4. **Required Files in Each Service Folder:**\n   - `tspconfig.yaml`: Configuration for emitters and SDK generation.\n   - `main.tsp`: Entry point for TypeSpec definitions.\n   - Supporting `*.tsp` files: For models, operations, etc.\n   - `examples/`: Folder with example JSON files.\n\n5. **SDK Generation:**\n   - Only services intending to generate SDKs should include emitter configuration in `tspconfig.yaml`.\n   - Shared libraries should not include `tspconfig.yaml`.\n\n6. **No `package.json` in Service Folder:**\n   - Use the root-level `package.json` for dependencies like `@azure-tools/typespec-autorest`.\n\nThis structure ensures modularity and clarity when multiple services coexist under a single RP namespace, while also supporting shared components and SDK generation workflows.", "context": null, "latency": 8.589030981063843, "response_length": 1579}
{"query": "title: Is there way to change property from required to optional?\n\nquestion: Hi, dear, I am working releasing video translation GA API with new version.\nAnd we want to change a property from required to optional in the new version.\nPreviously we have a required property: sourceLocale: localeName\n(Here localeName is a defined as: scalar localeName extends string;)\nAnd now we want to change the property to optional: sourceLocale?: localeName\nIs there anyway I can do to make the change for the new version?\nI have tried this but doesn't work:\n@doc(\"Translation input.\")\nmodel TranslationInput {\n@typeChangedFrom(ApiVersions.v2024_05_20_preview, localeName)\nsourceLocale?: localeName;\n}\nCould anyone help please?", "ground_truth": "use the @madeOptional decorator like this:\n```\n@doc(\"Translation input.\")\nmodel TranslationInput {\n@typeChangedFrom(ApiVersions.v2024_05_20_preview, localeName)\n@madeOptional\nsourceLocale?: localeName;\n}\n```", "response": "Yes, you can change a property from required to optional in a new version of your TypeSpec API by using the `@madeOptional` decorator. This decorator should be applied to the property you want to make optional, and you should specify the version in which the change occurs. Here is how you can do it:\n\n```typespec\n@doc(\"Translation input.\")\nmodel TranslationInput {\n  @typeChangedFrom(ApiVersions.v2024_05_20_preview, localeName)\n  @madeOptional(ApiVersions.v2024_06_01)\n  sourceLocale?: localeName;\n}\n```\n\nReplace `ApiVersions.v2024_06_01` with the actual version where the property becomes optional. The `@typeChangedFrom` decorator is used if the type of the property also changed, but for making a property optional, `@madeOptional` is the key decorator to use.\n\nThis approach ensures that previous versions keep the property as required, while the new version treats it as optional.", "context": null, "latency": 8.029006481170654, "response_length": 887}
