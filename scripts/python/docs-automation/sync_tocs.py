# This script is intended for use in intermediate doc repos generated from docs.ms CI.
# Given a reference ToC and a set of namespaces, limit the reference to ToC entries that contain
# namespaces in our set.

import argparse
import pdb
import os
import fnmatch
import re

# by default, yaml does not maintain insertion order of the dicts
# given that this is intended to generate TABLE OF CONTENTS values,
# maintaining this order is important.
# The drop-in replacement oyaml is a handy solution for us.
import oyaml as yaml


def filter_children(targeted_ns_list, known_namespaces):
    amended_list = []

    for ns in targeted_ns_list:
        # also need to handle when the namespace grep is a pattern
        # azure-eventhubs* <-- for instance
        if any(
            [
                re.match(fnmatch.translate(ns), known_namespace)
                for known_namespace in known_namespaces
            ]
        ):
            amended_list.append(ns)

    return amended_list


def amend_href(input_string, repo_location, readme_suffix):
    suffix = "-" + readme_suffix + ".md"

    resolvable_path = os.path.join(repo_location, input_string.replace("~/", ""))
    possible_target_readme = os.path.splitext(resolvable_path)[0] + "-" + suffix

    if os.path.exists(possible_target_readme):

        return input_string.replace(".md", suffix)

    return input_string


# a post-order recursive function that returns a modified reference.yml
# based on the set of namespaces that we've grabbed from autogenerated ToC.yml
def filter_toc(toc_dict, namespaces, repo_location=None, readme_suffix=None):
    if toc_dict is None:
        return None

    # internal node
    if "items" in toc_dict:
        # recurse as mant times as necessary
        item_list = []
        for item in toc_dict["items"]:
            result_n = filter_toc(item, namespaces, repo_location, readme_suffix)
            # only append the result if we know it exists
            if result_n:
                item_list.append(result_n)
        if item_list:
            toc_dict["items"] = item_list
        else:
            return None

        # handle href
        if repo_location and readme_suffix:
            if "href" in toc_dict:
                toc_dict["href"] = amend_href(
                    toc_dict["href"], repo_location, readme_suffix
                )

    # leaf node
    if "children" in toc_dict:
        filtered_children = filter_children(toc_dict["children"], namespaces)
        # if we filter out all the children, this node should simply cease to exist
        if not filtered_children:
            return None

    # always amend the uid to include the suffix if one is present.
    if "uid" in toc_dict and readme_suffix:
        toc_dict["uid"] = toc_dict["uid"] + "." + readme_suffix

    return toc_dict


def grep_children_namespaces(autogenerated_toc_yml):
    return [
        top_level_namespace["name"] for top_level_namespace in autogenerated_toc_yml
    ] + ["*"]


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="""
      Combines a reference and target ToC. The new target ToC mirrors the reference, omitting ToC
      entries that are NOT present in the preview output.
      """
    )

    parser.add_argument("-r", "--reference", help="The source ToC.yml", required=True)

    parser.add_argument("-t", "--target", help="The target ToC.yml", required=True)

    parser.add_argument(
        "-n",
        "--namespaces",
        help="The ToC.yml where target autogenerated documentation exists",
        required=True,
    )

    parser.add_argument(
        "-d",
        "--docrepo",
        help="The root directory of the target documentation repository.",
        required=False,
    )

    parser.add_argument(
        "-s",
        "--suffix",
        help="If possible, find readmes with this suffix.",
        required=False,
    )

    args = parser.parse_args()

    try:
        with open(args.reference, "r") as reference_yml:
            base_reference_toc = yaml.safe_load(reference_yml)

        with open(args.namespaces, "r") as target_autogenerated_toc_yml:
            target_autogenerated_toc = yaml.safe_load(target_autogenerated_toc_yml)
    except Exception as f:
        print(
            "Execution requires that both the known namespaces and reference yml be defined."
        )

    present_in_target = grep_children_namespaces(target_autogenerated_toc)

    print(
        "Here are the visible namespaces in target autogenerated ToC. Constraining reference.yml."
    )
    for ns in sorted(present_in_target):
        print(" |__ " + ns)

    base_reference_toc[0] = filter_toc(
        base_reference_toc[0], present_in_target, args.docrepo, args.suffix
    )
    updated_content = yaml.dump(base_reference_toc, default_flow_style=False)

    with open(args.target, "w") as f:
        f.write(updated_content)
