[33mcommit e6ed5ad84b5fa09e1a555543d1c2f2a6917e8c55[m[33m ([m[1;36mHEAD[m[33m -> [m[1;32mcopilot/fix-10893[m[33m, [m[1;31morigin/copilot/fix-10893[m[33m)[m
Author: copilot-swe-agent[bot] <198982749+Copilot@users.noreply.github.com>
Date:   Fri Jun 13 16:48:03 2025 +0000

    Fix DuplicateTypeNameValidation false positives for same assembly types
    
    Co-authored-by: KrzysztofCwalina <9724236+KrzysztofCwalina@users.noreply.github.com>

[1mdiff --git a/src/dotnet/Azure.ClientSdk.Analyzers/Azure.ClientSdk.Analyzers.Tests/AZC0034Tests.cs b/src/dotnet/Azure.ClientSdk.Analyzers/Azure.ClientSdk.Analyzers.Tests/AZC0034Tests.cs[m
[1mindex 3ba7680..91c0f5b 100644[m
[1m--- a/src/dotnet/Azure.ClientSdk.Analyzers/Azure.ClientSdk.Analyzers.Tests/AZC0034Tests.cs[m
[1m+++ b/src/dotnet/Azure.ClientSdk.Analyzers/Azure.ClientSdk.Analyzers.Tests/AZC0034Tests.cs[m
[36m@@ -43,5 +43,80 @@[m [mnamespace Azure.Test[m
             var expected = Verifier.Diagnostic("AZC0034").WithSpan(4, 18, 4, 28).WithArguments("BlobClient", "Azure.Storage.Blobs.BlobClient (from Azure.Storage.Blobs)");[m
             await Verifier.VerifyAnalyzerAsync(code, expected);[m
         }[m
[32m+[m
[32m+[m[32m        [Fact][m
[32m+[m[32m        public async Task AZC0034NotProducedForSameTypeInSameAssembly()[m
[32m+[m[32m        {[m
[32m+[m[32m            // This test reproduces the false positive issue where a type defined in Azure.Core[m
[32m+[m[32m            // is flagged as conflicting with itself in the reserved types list[m
[32m+[m[32m            var test = Verifier.CreateAnalyzer("");[m
[32m+[m[32m            test.TestState.Sources.Add(@"[assembly: System.Reflection.AssemblyTitle(""Azure.Core"")][m
[32m+[m
[32m+[m[32mnamespace Azure[m
[32m+[m[32m{[m
[32m+[m[32m    public abstract class Operation { }[m
[32m+[m[32m    public abstract class Response { }[m
[32m+[m[32m}");[m
[32m+[m
[32m+[m[32m            // Set the assembly name to match what's expected in the reserved types file[m
[32m+[m[32m            test.SolutionTransforms.Add((solution, projectId) =>[m
[32m+[m[32m            {[m
[32m+[m[32m                var project = solution.GetProject(projectId);[m
[32m+[m[32m                return solution.WithProjectAssemblyName(projectId, "Azure.Core");[m
[32m+[m[32m            });[m
[32m+[m
[32m+[m[32m            // Should not produce any diagnostics since these are the exact same types as in the reserved list[m
[32m+[m[32m            await test.RunAsync();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [Fact][m
[32m+[m[32m        public async Task AZC0034NotProducedForSameGenericTypeInSameAssembly()[m
[32m+[m[32m        {[m
[32m+[m[32m            // This test reproduces the false positive issue where a generic type defined in Azure.Core[m
[32m+[m[32m            // is flagged as conflicting with the non-generic version in the reserved types list[m
[32m+[m[32m            var test = Verifier.CreateAnalyzer("");[m
[32m+[m[32m            test.TestState.Sources.Add(@"[assembly: System.Reflection.AssemblyTitle(""Azure.Core"")][m
[32m+[m
[32m+[m[32mnamespace Azure[m
[32m+[m[32m{[m
[32m+[m[32m    public abstract class Operation<T> { }[m
[32m+[m[32m}");[m
[32m+[m
[32m+[m[32m            // Set the assembly name to match what's expected in the reserved types file[m
[32m+[m[32m            test.SolutionTransforms.Add((solution, projectId) =>[m
[32m+[m[32m            {[m
[32m+[m[32m                var project = solution.GetProject(projectId);[m
[32m+[m[32m                return solution.WithProjectAssemblyName(projectId, "Azure.Core");[m
[32m+[m[32m            });[m
[32m+[m
[32m+[m[32m            // Should not produce any diagnostics since Operation<T> is defined in Azure.Core,[m
[32m+[m[32m            // and even though it matches the "Operation" name, it should be skipped if it's from the same assembly[m
[32m+[m[32m            await test.RunAsync();[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        [Fact][m
[32m+[m[32m        public async Task AZC0034NotProducedForNestedTypesInSameAssembly()[m
[32m+[m[32m        {[m
[32m+[m[32m            // This test covers the case for types like ArrayEnumerator and ObjectEnumerator[m
[32m+[m[32m            // mentioned in the original issue[m
[32m+[m[32m            var test = Verifier.CreateAnalyzer("");[m
[32m+[m[32m            test.TestState.Sources.Add(@"[assembly: System.Reflection.AssemblyTitle(""Azure.Core"")][m
[32m+[m
[32m+[m[32mnamespace Azure.Core[m
[32m+[m[32m{[m
[32m+[m[32m    public struct ArrayEnumerator { }[m
[32m+[m[32m    public struct ObjectEnumerator { }[m
[32m+[m[32m}");[m
[32m+[m
[32m+[m[32m            // Set the assembly name to match what's expected in the reserved types file[m
[32m+[m[32m            test.SolutionTransforms.Add((solution, projectId) =>[m
[32m+[m[32m            {[m
[32m+[m[32m                var project = solution.GetProject(projectId);[m
[32m+[m[32m                return solution.WithProjectAssemblyName(projectId, "Azure.Core");[m
[32m+[m[32m            });[m
[32m+[m
[32m+[m[32m            // Should not produce any diagnostics since these are the same types defined in Azure.Core[m
[32m+[m[32m            await test.RunAsync();[m
[32m+[m[32m        }[m
     }[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/src/dotnet/Azure.ClientSdk.Analyzers/Azure.ClientSdk.Analyzers/DuplicateTypeNameAnalyzer.cs b/src/dotnet/Azure.ClientSdk.Analyzers/Azure.ClientSdk.Analyzers/DuplicateTypeNameAnalyzer.cs[m
[1mindex 3f854be..44ea0c3 100644[m
[1m--- a/src/dotnet/Azure.ClientSdk.Analyzers/Azure.ClientSdk.Analyzers/DuplicateTypeNameAnalyzer.cs[m
[1m+++ b/src/dotnet/Azure.ClientSdk.Analyzers/Azure.ClientSdk.Analyzers/DuplicateTypeNameAnalyzer.cs[m
[36m@@ -148,11 +148,23 @@[m [mnamespace Azure.ClientSdk.Analyzers[m
                 var currentFullTypeName = namedTypeSymbol.ToDisplayString();[m
                 var currentAssemblyName = namedTypeSymbol.ContainingAssembly?.Name ?? "";[m
                 [m
[31m-                // Don't report if it's exactly the same type[m
[31m-                if (string.Equals(currentFullTypeName, qualifiedTypeName, StringComparison.Ordinal) && [m
[31m-                    string.Equals(currentAssemblyName, packageName, StringComparison.Ordinal))[m
[32m+[m[32m                // For generic types, we need to check the base type name without generic parameters[m
[32m+[m[32m                var currentTypeNameWithoutGenerics = currentFullTypeName;[m
[32m+[m[32m                var genericMarkerIndex = currentFullTypeName.IndexOf('<');[m
[32m+[m[32m                if (genericMarkerIndex >= 0)[m
                 {[m
[31m-                    return;[m
[32m+[m[32m                    currentTypeNameWithoutGenerics = currentFullTypeName.Substring(0, genericMarkerIndex);[m
[32m+[m[32m                }[m
[32m+[m[41m                [m
[32m+[m[32m                // Check if it's the same assembly first (most important check)[m
[32m+[m[32m                if (string.Equals(currentAssemblyName, packageName, StringComparison.Ordinal))[m
[32m+[m[32m                {[m
[32m+[m[32m                    // If same assembly, check if the type names match (handling both fully qualified and simple names)[m
[32m+[m[32m                    if (string.Equals(currentTypeNameWithoutGenerics, qualifiedTypeName, StringComparison.Ordinal) ||[m
[32m+[m[32m                        (qualifiedTypeName.IndexOf('.') < 0 && currentTypeNameWithoutGenerics.EndsWith("." + qualifiedTypeName)))[m
[32m+[m[32m                    {[m
[32m+[m[32m                        return;[m
[32m+[m[32m                    }[m
                 }[m
                 [m
                 // Create the error message including package name if available[m
