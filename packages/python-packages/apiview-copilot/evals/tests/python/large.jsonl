{"testcase": "few_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.16), Python version: 3.10.16\n\n\nnamespace azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\n@distributed_trace_async\nasync def analyze_document_async(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AnalyzeResult:\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.aio\n\nclass azure.ai.documentintelligence.aio.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@asyncio.coroutine\ndef get_classifier_old(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails:\n\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failed_count: int\nivar skipped_count: int\nivar succeeded_count: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\nNEURAL = \"neural\"\nTEMPLATE = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "\nDO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```\nDO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine (https://docs.python.org/3.4/library/asyncio-task.html) syntax.", "response": "{\"status\": \"Error\", \"violations\": [{\"rule_ids\": [\"python_design.html#python-client-separate-sync-async\"], \"line_no\": 325, \"bad_code\": \"async def analyze_document_async(self, model_id: str, body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], **kwargs: Any) -> AnalyzeResult\", \"suggestion\": \"Remove this asynchronous method from the synchronous client. Instead, offer an equivalent async method only in the async client located under the azure.ai.documentintelligence.aio namespace.\", \"comment\": \"Synchronous client classes must not mix in async methods. The 'analyze_document_async' method in the sync client violates the guideline for providing separate sync and async clients.\"}, {\"rule_ids\": [\"python_design.html#python-client-async-keywords\"], \"line_no\": 937, \"bad_code\": \"@asyncio.coroutine\", \"suggestion\": \"Replace '@asyncio.coroutine' with the async/await syntax. Define the method using 'async def' and use 'await' where needed.\", \"comment\": \"Using '@asyncio.coroutine' is deprecated. Async methods should use the modern async/await syntax to comply with Python 3.5+ guidelines.\"}]}"}
{"testcase": "many_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.16), Python version: 3.10.16\n\nnamespace microsoft.azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\ndef client(self, name, **kwargs) -> DocumentIntelligenceClient\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\n@distributed_trace\ndef process_document(\nself,\nmodel_id,\ndoc_type,\nsource,\nversion,\nlocale,\nformat,\npages,\nfields,\ntimeout\n) -> AnalyzeResult\n\n@distributed_trace\ndef analyze_batch(\nself,\nmodel_id,\nbody,\nfeatures=None,\nlocale=None,\noutput=None\n) -> LROPoller[AnalyzeBatchResult]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.async\n\nclass azure.ai.documentintelligence.async.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.async.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.async.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    api_key: str,\n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failedCount: int\nivar skippedCount: int\nivar succeededCount: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\nneural = \"neural\"\ntemplate = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\nclass DocumentIntelligenceCustomError(Exception):\n    ivar error: str\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "\nDO implement your library as a sub-package of the azure root namespace.\n\nNote: You MUST NOT use microsoft as your root namespace. If you need to include microsoft in the namespace (e.g. because of policy requirements for extensions to other projects such as opentelemetry), you should concatenate it with the package specific namespace with an underscore (e.g. microsoft_myservice). You may still use microsoft-myservice as the distribution package name in this scenario.\nYOU SHOULD NOT have methods that require more than five positional parameters. Optional/flag parameters can be accepted using keyword-only arguments, or **kwargs.\n\n\nDO use keyword-only arguments for optional or less-often-used arguments for modules that only need to support Python 3.\n\n```python\n# Yes\ndef foo(a, b, *, c, d=None):\n    # Note that I can even have required keyword-only arguments...\n    ...\n\n```\nDO NOT create new exception types when a built-in exception type (https://docs.python.org/3/library/exceptions.html) will suffice.\nDO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods.\nDO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child.\nDO use UPPERCASE for enum member names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```\nDO use the credentials classes in azure-core whenever possible.\nDO use snake_case for variable, function, and method names:\n\n```python\n# Yes:\nservice_client = ServiceClient()\n\nservice_client.list_things()\n\ndef do_something():\n    ...\n\n# No:\nserviceClient = ServiceClient()\n\nservice_client.listThings()\n\ndef DoSomething():\n    ...\n\n```", "response": "{\"status\": \"Error\", \"violations\": [{\"rule_ids\": [\"python_design.html#python-namespaces-prefix\"], \"line_no\": 3, \"bad_code\": \"namespace microsoft.azure.ai.documentintelligence\", \"suggestion\": \"namespace azure.ai.documentintelligence\", \"comment\": \"The library is using 'microsoft' as the root namespace rather than 'azure'. According to the guidelines, libraries must be implemented as a sub\\u2010package of the azure root namespace.\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-long-args\"], \"line_no\": 629, \"bad_code\": \"def process_document(self, model_id, doc_type, source, version, locale, format, pages, fields, timeout) -> AnalyzeResult\", \"suggestion\": \"Refactor the method signature to reduce the count of required positional parameters. For example, consider making parameters like 'version, locale, format, pages, fields, timeout' keyword\\u2010only by using '*' after the required parameters: \\n\\n def process_document(self, model_id, doc_type, source, *, version, locale, format, pages, fields, timeout) -> AnalyzeResult\", \"comment\": \"This method requires nine positional parameters which exceeds the guideline recommendation to limit positional parameters to five. Use keyword-only parameters for optional or less ordered parameters.\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-optional-args\"], \"line_no\": 642, \"bad_code\": \"def analyze_batch(self, model_id, body, features=None, locale=None, output=None) -> LROPoller[AnalyzeBatchResult]\", \"suggestion\": \"Modify the function signature to enforce keyword-only for optional parameters. For example:\\n\\n def analyze_batch(self, model_id, body, *, features=None, locale=None, output=None) -> LROPoller[AnalyzeBatchResult]\", \"comment\": \"Optional parameters should be defined as keyword-only to improve clarity and prevent accidental misplacement, per SDK guidelines.\"}, {\"rule_ids\": [\"python_design.html#python-errors-use-standard-exceptions\"], \"line_no\": 3160, \"bad_code\": \"class DocumentIntelligenceCustomError(Exception):\", \"suggestion\": \"Consider using an existing exception type from azure-core (for example, subclass AzureError) or a built-in exception if appropriate, rather than creating a new custom exception.\", \"comment\": \"Custom exceptions should be avoided if a standard or azure-core exception type can convey the error, per SDK guidelines.\"}, {\"rule_ids\": [\"python_design.html#python-namespaces-async\"], \"line_no\": 661, \"bad_code\": \"namespace azure.ai.documentintelligence.async\", \"suggestion\": \"namespace azure.ai.documentintelligence.aio\", \"comment\": \"The asynchronous client namespace must use an '.aio' suffix, not '.async', to adhere to the async client naming guidelines.\"}, {\"rule_ids\": [\"python_design.html#python-client-hier-vend\"], \"line_no\": 332, \"bad_code\": \"def client(self, name, **kwargs) -> DocumentIntelligenceClient\", \"suggestion\": \"def get_document_intelligence_client(self, name, **kwargs) -> DocumentIntelligenceClient\", \"comment\": \"Hierarchical client retrieval methods should follow the 'get_<child>_client' naming convention.\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-name-uppercase\"], \"line_no\": 1948, \"bad_code\": \"neural = \\\"neural\\\"\", \"suggestion\": \"NEURAL = \\\"neural\\\" (and similarly, use TEMPLATE = \\\"template\\\" for the other member)\", \"comment\": \"Enum member names must be in UPPERCASE. The current definition of DocumentBuildMode uses lower-case member names.\"}, {\"rule_ids\": [\"python_design.html#python-auth-credential-azure-core\"], \"line_no\": 995, \"bad_code\": \"api_key: str\", \"suggestion\": \"Replace 'api_key: str' with 'credential: Union[AzureKeyCredential, AsyncTokenCredential]' (and update the parameter name) to align with the sync client and azure-core credential guidelines.\", \"comment\": \"The async client's constructor uses a simple string ('api_key') rather than a proper azure-core credential type, causing an inconsistency with the sync client.\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1427, \"bad_code\": \"ivar failedCount: int\", \"suggestion\": \"ivar failed_count: int\", \"comment\": \"Variable names should use snake_case. 'failedCount' should be renamed to 'failed_count'.\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1428, \"bad_code\": \"ivar skippedCount: int\", \"suggestion\": \"ivar skipped_count: int\", \"comment\": \"Variable names should use snake_case. 'skippedCount' should be renamed to 'skipped_count'.\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1429, \"bad_code\": \"ivar succeededCount: int\", \"suggestion\": \"ivar succeeded_count: int\", \"comment\": \"Variable names should use snake_case. 'succeededCount' should be renamed to 'succeeded_count'.\"}]}"}
{"testcase": "no_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.18), Python version: 3.10.16\n\n\nnamespace azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.aio\n\nclass azure.ai.documentintelligence.aio.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failed_count: int\nivar skipped_count: int\nivar succeeded_count: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\nNEURAL = \"neural\"\nTEMPLATE = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "", "response": "{\"status\": \"Success\", \"violations\": []}"}
{"testcase": "multiple_same_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.18), Python version: 3.10.16\n\n\nnamespace azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.aio\n\nclass azure.ai.documentintelligence.aio.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failed_count: int\nivar skipped_count: int\nivar succeeded_count: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(Enum):\nNEURAL = \"neural\"\nTEMPLATE = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "\nDO use extensible enumerations.", "response": "{\"status\": \"Error\", \"violations\": [{\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 1448, \"bad_code\": \"class azure.ai.documentintelligence.models.AnalyzeOutputOption(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\", \"comment\": \"Enums in the SDK should be extensible by inheriting from str as well as Enum. This allows for flexible comparisons and future extensions.\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1902, \"bad_code\": \"class azure.ai.documentintelligence.models.DocumentBarcodeKind(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\", \"comment\": \"Enum members should be based on str to ensure extensibility and compliance with SDK guidelines.\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1922, \"bad_code\": \"class azure.ai.documentintelligence.models.DocumentBuildMode(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\", \"comment\": \"For consistency and extensibility, enums should inherit from str alongside Enum.\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1864, \"bad_code\": \"class azure.ai.documentintelligence.models.DocumentAnalysisFeature(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\", \"comment\": \"Enums should extend str to adhere to the guideline of using extensible enumerations in the SDK.\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1811, \"bad_code\": \"class azure.ai.documentintelligence.models.ContentSourceKind(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\", \"comment\": \"Enums should extend str to adhere to the guideline of using extensible enumerations in the SDK.\"}]}"}