# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

import abc
from azure.core import CaseInsensitiveEnumMeta
from collections.abc import Sequence
import datetime
from enum import Enum, EnumMeta
import functools
from typing import Any, overload, Dict, TypedDict, Union, Optional, Generic, TypeVar, NewType, ClassVar, Protocol
from typing_extensions import runtime_checkable

from ._mixin import MixinWithOverloads


def my_decorator(fn):
    @functools.wraps(fn)
    def wrapper(*args, **kwargs):
        pass
    return wrapper


def another_decorator(value):
    def decorator(fn):
        @functools.wraps(fn)
        def wrapper(*args, **kwargs):
            return value
        return wrapper
    return decorator

def get_id(self):
    return self.__id

def add_id(cls):
    cls_init = cls.__init__

    def __init__(self, id, *args, **kwargs):
        self.__id = id
        self.get_id = get_id
        cls_init(self, *args, **kwargs)

    cls.__init__ = __init__
    return cls


@add_id
class ClassWithDecorators:
    pass


class ClassWithIvarsAndCvars:
    captain: str = "Picard"                 # instance var w/ default
    damage: int                             # instance var w/out default
    stats: ClassVar[Dict[str, int]] = {}    # class var


class PublicCaseInsensitiveEnumMeta(EnumMeta):
    def __getitem__(self, name: str):
        pass

    def __getattr__(cls, name: str):
        pass


class DocstringClass:
    """A class for testing docstring behavior.
    """

    def docstring_with_default_formal(self, value, another, some_class, **kwargs) -> str:
        """Docstring containing a formal default.

        :param value: Some dummy value, defaults
         to "cat". Extra text.
        :type value: str
        :param another: Something else, defaults
         to dog. Extra text.
        :type another: str
        :param some_class: Some kind of class type, defaults to :py:class:`apistubgen.test.models.FakeObject`.
        :type some_class: class
        :return: Some string.
        :rtype: str
        """
        return f"{value} {another} {some_class}"


class PetEnumPy3Metaclass(str, Enum, metaclass = CaseInsensitiveEnumMeta):
    """A test enum for Py3 way of doing case-insensitive enum
    """
    DOG = "dog"
    CAT = "cat"
    DEFAULT = "cat"


class PetEnumPy3MetaclassAlt(str, Enum, metaclass=PublicCaseInsensitiveEnumMeta):
    """A test enum
    """
    DOG = "dog"
    CAT = "cat"
    DEFAULT = "cat"


# pylint:disable=docstring-missing-param
class FakeObject(object):
    """Fake Object

    :ivar str name: Name
    :ivar int age: Age
    :ivar union: Union
    :vartype union: Union[bool, PetEnumPy3MetaclassAlt]
    """
    def __init__(self, name: str, age: int, union: Union[bool, PetEnumPy3MetaclassAlt]):
        self.name = name
        self.age = age
        self.union = union

    PUBLIC_CONST: str = "SOMETHING"

    # This should be ignored
    _SOME_THING: dict = {
        "cat": "hat"
    }


class FakeError(object):
    pass


FakeTypedDict = TypedDict(
    'FakeTypedDict',
    name=str,
    age=int,
    union=Union[bool, FakeObject, PetEnumPy3MetaclassAlt]
)


class PublicPrivateClass:

    public_var: str = "SOMEVAL"

    public_datetime: datetime.datetime

    _private_var: str

    public_dict: dict = {"a": "b"}

    _private_dict: dict = {"c": "d"}

    def __init__(self):
        self.public_var = "test"

    def _private_func(self) -> str:
        return ""

    def public_func(self, **kwargs) -> str:
        return ""


class RequiredKwargObject:
    """A class with required kwargs.
    :param str id: An id. Required.
    :keyword str name: Required. The name.
    :keyword int age: Required. The age.
    :keyword str other: Some optional thing.
    """

    def __init__(self, id: str, *, name: str, age: int, other: str = None, **kwargs: "Any"):
        self.id = id
        self.name = name
        self.age = age
        self.other = other


class ObjectWithDefaults:

    def __init__(self, name: str = "Bob", age: int = 21, is_awesome: bool = True, pet: PetEnumPy3MetaclassAlt = PetEnumPy3MetaclassAlt.DOG):
        self.name = name
        self.age = age
        self.is_awesome = is_awesome
        self.pet = pet


class SomePoorlyNamedObject:

    def __init__(self, name: str):
        self.name = name


class SomeAwesomelyNamedObject(SomePoorlyNamedObject):
    pass


class SomethingWithOverloads:

    @overload
    def double(self, input: int = 1, *, test: bool = False, **kwargs) -> int:
        ...

    @overload
    def double(self, input: Sequence[int] = [1], *, test: bool = False, **kwargs) -> list[int]:
        ...

    def double(self, input: int | Sequence[int], *, test: bool = False, **kwargs) -> int | list[int]:
        if isinstance(input, Sequence):
            return [i * 2 for i in input]
        return input * 2

    @overload
    def something(self, id: str, *args, **kwargs) -> str:
        ...

    @overload
    def something(self, id: int, *args, **kwargs) -> str:
        ...

    def something(self, id: int | str, *args, **kwargs) -> str:
        return str(id)


class SomethingAsyncWithOverloads:

    @overload
    async def double(self, input: int = 1, *, test: bool = False, **kwargs) -> int:
        ...

    @overload
    async def double(self, input: Sequence[int] = [1], *, test: bool = False, **kwargs) -> list[int]:
        ...

    async def double(self, input: int | Sequence[int], *, test: bool = False, **kwargs) -> int | list[int]:
        if isinstance(input, Sequence):
            return [i * 2 for i in input]
        return input * 2

    @overload
    async def something(self, id: str, *args, **kwargs) -> str:
        ...

    @overload
    async def something(self, id: int, *args, **kwargs) -> str:
        ...

    async def something(self, id: int | str, *args, **kwargs) -> str:
        return str(id)


class SomethingWithInheritedOverloads(MixinWithOverloads):
    pass


class SomethingWithDecorators:

    @my_decorator
    async def name_async(self):
        pass

    @my_decorator
    def name_sync(self):
        pass

    @another_decorator("Test")
    async def complex_decorator_async(self):
        pass

    @another_decorator("Test")
    def complex_decorator_sync(self):
        pass


# pylint:disable=docstring-missing-return
class SomethingWithProperties:

    @property
    def py3_property(self) -> Optional[str]:
        pass

    @property
    def py2_property(self):
        # type: () -> Optional[str]
        pass

    @property
    def docstring_property(self):
        """ Property

        :rtype: Optional[str]
        """
        pass

# pylint:disable=docstring-missing-rtype
class _SomeAbstractBase(abc.ABC):
    """ Some abstract base class. """

    @property
    @abc.abstractmethod
    def say_hello(self) -> str:
        """ A method to say hello. """
        ...

class SomeImplementationClass(_SomeAbstractBase):

    def say_hello(self) -> str:
        return "Hello!"


T = TypeVar('T')

class GenericStack(Generic[T]):
    def __init__(self) -> None:
        # Create an empty list with items of type T
        self.items: list[T] = []

    def push(self, item: T) -> None:
        self.items.append(item)

    def pop(self) -> T:
        return self.items.pop()

    def empty(self) -> bool:
        return not self.items

AliasUnion = NewType('AliasUnion', Union[str, int, bool])

AliasNewType = NewType('AliasNewType', Dict[str, str])

@runtime_checkable
class SomeProtocolDecorator(Protocol):
    pass
