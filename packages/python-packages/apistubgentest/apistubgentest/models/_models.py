# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------

from azure.core import CaseInsensitiveEnumMeta
from azure.core.tracing.decorator import distributed_trace

from dataclasses import dataclass
from enum import Enum, EnumMeta
from six import with_metaclass
from typing import Any, TypedDict, Union


class PublicCaseInsensitiveEnumMeta(EnumMeta):
    def __getitem__(self, name: str):
        pass

    def __getattr__(cls, name: str):
        pass


class DocstringClass:
    """A class for testing docstring behavior.
    """

    def docstring_with_default_formal(self, value, another, some_class, **kwargs) -> str:
        """Docstring containing a formal default.

        :param value: Some dummy value, defaults
         to "cat". Extra text.
        :type value: str
        :param another: Something else, defaults
         to dog. Extra text.
        :type another: str
        :param some_class: Some kind of class type, defaults to :py:class:`apistubgen.test.models.FakeObject`.
        :type some_class: class
        :rtype: str
        """
        return f"{value} {another} {some_class}"


class PetEnumPy2Metaclass(with_metaclass(CaseInsensitiveEnumMeta, str, Enum)):
    """A test enum for Py2 way of doing case-insensitive enum
    """
    DOG = "dog"
    CAT = "cat"
    DEFAULT = "cat"


class PetEnumPy3Metaclass(str, Enum, metaclass = CaseInsensitiveEnumMeta):
    """A test enum for Py3 way of doing case-insensitive enum
    """
    DOG = "dog"
    CAT = "cat"
    DEFAULT = "cat"


class PetEnum(str, Enum, metaclass=PublicCaseInsensitiveEnumMeta):
    """A test enum
    """
    DOG = "dog"
    CAT = "cat"
    DEFAULT = "cat"


class FakeObject(object):
    """Fake Object

    :ivar str name: Name
    :ivar int age: Age
    :ivar union: Union
    :vartype union: Union[bool, PetEnum]
    """
    def __init__(self, name: str, age: int, union: Union[bool, PetEnum]):
        self.name = name
        self.age = age
        self.union = union

    PUBLIC_CONST: str = "SOMETHING"

    # This should be ignored
    _SOME_THING: dict = {
        "cat": "hat"
    }


FakeTypedDict = TypedDict(
    'FakeTypedDict',
    name=str,
    age=int,
    union=Union[bool, FakeObject, PetEnum]
)


@dataclass
class FakeInventoryItemDataClass:
    """Class for testing @dataclass
    """
    name: str
    unit_price: float
    quantity_on_hand: int = 0

    def total_cost(self, **kwargs) -> float:
        return self.unit_price * self.quantity_on_hand


class PublicPrivateClass:

    public_var: str = "SOMEVAL"

    _private_var: str

    public_dict: dict = {"a": "b"}

    _private_dict: dict = {"c": "d"}

    def __init__(self):
        self.public_var = "test"

    def _private_func(self) -> str:
        return ""

    def public_func(self, **kwargs) -> str:
        return ""


class RequiredKwargObject:
    """A class with required kwargs.
    :param str id: An id. Required.
    :keyword str name: Required. The name.
    :keyword int age: Required. The age.
    :keyword str other: Some optional thing.
    """

    def __init__(self, id: str, *, name: str, age: int, other: str = None, **kwargs: "Any"):
        self.id = id
        self.name = name
        self.age = age
        self.other = other


class ObjectWithDefaults:

    def __init__(self, name: str = "Bob", age: int = 21, is_awesome: bool = True, pet: PetEnum = PetEnum.DOG):
        self.name = name
        self.age = age
        self.is_awesome = is_awesome
        self.pet = pet

class SomePoorlyNamedObject:

    def __init__(self, name: str):
        self.name = name


class ObjectWithSuppressions:

    # apiview: disable=missing-kwargs
    @distributed_trace
    def get(self, name):
        return name

    @distributed_trace
    def mismatch_types(self, val, **kwargs):
        # type: (str) -> int
        """ A test of mismatched types.
        
        :param int val: A mismatch val.
        :rtype: bool
        """
        return 0

    @distributed_trace
    def list_bad_return(self, **kwargs):
        # type: (...) -> List[str]
        """
        :rtype: List[str]
        """
        return [""]

    @distributed_trace
    def bad_source_line(self, obj, **kwargs):
        # (~some.bad.link) -> str
        """ Testing bad source link.
        
        :param obj: An obj
        :type obj: ~some.bad.link
        """
        return ""
