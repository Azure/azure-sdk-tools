[
    {
        "testcase": "Guidance on cross version breaking change for readonly and async operations in new api-versions",
        "expected": {
            "answer": "The 'provisioningState' change in the PATCH request model seems like a bug fix if this field was always read-only.  When you get a breaking change review, if this is explained with an appropriate comment, this is likely to be justified as a bug fix.\nOn changing PATCH to synchronous.  ARM does support async PATCH operations, although REST API Guidelines discourage async PATCH operations.  If this operation is synchronous in the previous stable version, then this change is a real breaking change that you will need to justify in breaking change review.\nSimilarly, making PUT and DELETE Asynchronous is a breaking change if these operations were synchronous in the previous stable version is a real breaking change, and you will need to justify the change in a breaking change review.",
            "reference_urls": []
        },
        "actual": {
            "answer": "Let's address both of your concerns with Azure API/TypeSpec best practices:\n\n1. **ReadOnly Property (`provisioningState`) in Patch Models and Breaking Change Detection**\n\n- You are correct that readOnly properties like `provisioningState` should NOT be included in PATCH/update models (such as `ConfigurationPropertiesUpdate`). The Azure RPC guidelines [RPC-Patch-V1-02] explicitly state that `provisioningState` must not be updatable, and if present in the PATCH model, must be marked as readOnly. The standard pattern is for PATCH models to only include properties that are updatable by the client.\n- The cross-version breaking change checker sometimes flags the removal of readOnly properties from PATCH models as a breaking change, but this is a **false positive**. According to Azure guidelines and TypeSpec best practices, you should NOT include `provisioningState` in the PATCH/update model.\n- If your TypeSpec code looks like this, it is correct:\n\n```typespec\nmodel ConfigurationPropertiesUpdate {\n  // PATCH-able properties only. DO NOT include provisioningState here.\n  // e.g. optional properties you want to allow updating\n  field1?: string;\n  field2?: int32;\n}\n```\n\n- For the resource's main properties model (used in PUT/GET), you should include `provisioningState` as readOnly:\n\n```typespec\nmodel ConfigurationProperties {\n  ...\n  @visibility(Lifecycle.Read)\n  provisioningState?: ResourceProvisioningState;\n}\n```\n\n- **Resolution:** You can safely ignore the breaking change flag in this scenario, as your implementation follows Azure API guidelines. If you need to justify this in a review, cite the [Azure RPC Patch guidelines](https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/patch-resource.md#rules) and point out that readOnly fields must not be PATCH-able.\n\n2. **Switching from Synchronous to LRO (Long-Running Operation) in a New API Version**\n\n- Changing a synchronous operation (returning 200) to an LRO (returning 202 or 201 and async headers) IS a breaking change, but **only if you make this change in an existing API version**. According to Azure API versioning guidelines, breaking changes must be introduced only in a new API version.\n- The correct approach is to:\n  - Introduce the LRO behavior in the new api-version only (e.g., `2025-12-01-preview`).\n  - Retain the original synchronous behavior in previous api-versions.\n  - In your TypeSpec, use versioning decorators to mark the old operation as removed in the new version and add the new LRO operation, sharing the same route via `@sharedRoute`.\n\n**Example:**\n```typespec\n@armResourceOperations\ninterface Configurations {\n  @removed(Versions.v2025_12_01_preview)\n  @renamedFrom(Versions.v2025_12_01_preview, \"createOrUpdate\")\n  @sharedRoute\n  createOrUpdateSync is ArmResourceCreateOrReplaceSync<Configuration>;\n\n  @added(Versions.v2025_12_01_preview)\n  @sharedRoute\n  createOrUpdate is ArmResourceCreateOrReplaceAsync<Configuration>;\n}\n```\n\n- This ensures each api-version's behavior is stable and discoverable, and is the pattern recommended by TypeSpec and Azure API guidelines.\n\n**Summary**:\n- Do NOT include readOnly properties (like provisioningState) in PATCH/update models. This is NOT a breaking change across versions.\n- When converting a synchronous operation to an LRO, always do so in a new API version, and use TypeSpec versioning decorators to ensure proper version-specific behavior.\n\nIf your TypeSpec follows these patterns, you are fully compliant with Azure guidelines, and any breaking change flags in this context are false positives.\n",
            "reference_urls": [
                "https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/patch-resource.md",
                "https://azure.github.io/typespec-azure/docs/howtos/arm/versioning",
                "https://github.com/microsoft/api-guidelines/blob/vNext/azure/VersioningGuidelines.md"
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": NaN,
        "groundedness_result": NaN,
        "groundedness_threshold": NaN,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response covers almost all the ground truth points, but omits minor details about REST API Guidelines discouraging async PATCH and the breaking change status for PUT/DELETE operations.",
        "overall_score": 0.0
    },
    {
        "testcase": "Playground usage",
        "expected": {
            "answer": "There is no a 'remote import' feature in the typespec azure playground.",
            "reference_urls": []
        },
        "actual": {
            "answer": "Currently, the Azure TypeSpec Playground (https://azure.github.io/typespec-azure/playground) does not support scoping its context to an entire existing specification directory or adding multiple files for import resolution. The playground is designed as a single-file editor and does not have the capability to upload, reference, or resolve additional files (like models.tsp) from your local directory or from a multi-file Azure REST API spec structure. As a result, any import statements such as import \"./../models.tsp\" will result in import errors because the playground has no access to those files.\n\nTo work around this limitation for experimentation or examples:\n- Copy the relevant content from your referenced files (e.g., models.tsp) and paste it directly into the playground editor, either above your code or merged into a single file.\n- Alternatively, set up a local TypeSpec development environment, where you can organize files and imports as they exist in your repo. This allows you to resolve local imports as expected (see the Installation and Getting Started docs for how to do this).\n\nFor more advanced scenarios, such as testing multi-file imports or simulating your real directory structure, using the local TypeSpec CLI and VS Code extension is strongly recommended.\n\nIf you need to share a repro or example that requires imports, consider pasting all relevant models and definitions into a single file for the playground context.",
            "reference_urls": [
                "https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax",
                "https://typespec.io/docs/language-basics/imports",
                "https://azure.github.io/typespec-azure/docs/getstarted/installation"
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 3.0,
        "gpt_groundedness": 3.0,
        "groundedness_reason": "The RESPONSE is accurate and relevant, but it introduces additional information about playground limitations and workarounds that are not directly supported by the CONTEXT.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 3.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response provides related information about import limitations but does not directly address the specific claim about the absence of a \"remote import\" feature, missing the key statement in the ground truth.",
        "overall_score": 4.800000000000001
    },
    {
        "testcase": "What decorator should be used in this case?",
        "expected": {
            "answer": "it should be `typedChangedFrom(v2, model1)` here otherwise you are saying in v1 you changed from using model1 to model2 which then of course doesn't exists",
            "reference_urls": []
        },
        "actual": {
            "answer": "The error occurs because you are using @typeChangedFrom(v1, model1) on a property declared as body: model2, but model2 does not exist in v1. The correct way to use @typeChangedFrom is to indicate that, starting in v2, the property changes from model1 to model2. So, you should annotate the property in v2 as follows:\n\n@typeChangedFrom(v2, model1)\nbody: model2;\n\nThis means: in version v2, 'body' changes from model1 (used in v1) to model2 (introduced in v2). The first argument to @typeChangedFrom should always be the version where the change occurs, and the second argument is the type it changed from.\n\nHere is how you should write your TypeSpec:\n\n```typespec\n@added(v1)\nmodel model1 {};\n\n@added(v2)\nmodel model2 {};\n\n@added(v1)\nmodel featureA {\n  @typeChangedFrom(v2, model1)\n  body: model2;\n}\n```\n\nThis will properly express that in v1, featureA has body: model1, and in v2, it has body: model2.",
            "reference_urls": [
                "https://typespec.io/docs/libraries/versioning/reference/decorators"
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded in the CONTEXT, accurately explains the error, provides the correct usage, and gives a complete code example without unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, with no missing statements or claims.",
        "overall_score": 7.0
    },
    {
        "testcase": "Hi team, could someone please help grant me permission to view the workflow for my Azure REST API PR?",
        "expected": {
            "answer": "You need to get the necessary permissions, see here: https://aka.ms/azsdk/access",
            "reference_urls": []
        },
        "actual": {
            "answer": "You currently do not have the required permissions to view the workflow and error details for validation checks on your Azure REST API PR. To gain access, you need to ensure:\n\n1. Your membership in the Azure GitHub organization is set to public (not private).\n2. You have joined the Azure SDK Partners group and requested the necessary write access.\n\nYou can follow the instructions at https://aka.ms/azsdk/access to request these permissions. Once you have the correct access, you will be able to see the workflow results and debug any issues before the final review.\n\nIf you need further assistance after following these steps, you can reach out in the TypeSpec Discussions channel or consult the Azure REST API Specs Wiki for troubleshooting access and pipeline visibility.",
            "reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation"
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, complete, and directly supported by the CONTEXT without unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response contains all the information from the ground truth and adds relevant, accurate details, making it fully complete.",
        "overall_score": 6.4
    },
    {
        "testcase": "Brownfield TypeSpec migration",
        "expected": {
            "answer": "Migration to TypeSpec for existing services is not yet mandatory, but it is suggested, and teams should be planning for it in Bromine and Krypton\nServices must wholly switch to TypeSpec, there is no allowed mixing of hand-written and generated swagger\nServicesmust conform to a single, unified api-version for their service, servicesthat currently use different api-versions for parts of their service are going to need to plan for conformance -this either means SDK splitting or version uniformity.  Teams that use this 'different api-versions for different resources in the same sdk' pattern are not good candidates for conversion at the moment\nIn generally, the more compliant your service is to the RPC and best practices, the easier conversion will be\nThere is documentation on converting here: [Getting started | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started/)",
            "reference_urls": [
                "https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started"
            ]
        },
        "actual": {
            "answer": "There is currently no mandatory deadline for existing (brownfield) Resource Providers (RPs) to migrate from OpenAPI (Swagger) to TypeSpec. Migration is encouraged and should be planned for upcoming platform phases (such as Bromine and Krypton), but it is not enforced yet.\n\nIt is NOT permitted to mix TypeSpec with handwritten Swagger in the same service. The migration must be performed for the entire service at once; partial or phased migration (e.g., one resource type at a time) is not allowed. This ensures consistency, avoids versioning issues, and aligns with Azure API guidelines requiring services to conform to a single, unified API version for their entire surface area. If your service currently uses different API versions for different resources, you'll need to address this (by splitting SDKs or enforcing version uniformity) before migrating.\n\nYou can find more migration guidance and recommendations in the official documentation. The more compliant your service is to Azure RPC and API best practices, the easier the conversion will be.\n\nIn summary:\n- No current hard deadline, but plan for migration.\n- Mixing TypeSpec and handwritten Swagger is NOT allowed; the whole service must migrate together.\n- You must have a single API version for the entire service to migrate.\n- See the linked guidance for how to get started with migration.",
            "reference_urls": []
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully supported by the CONTEXT, accurately restates all key points, and does not add or omit any critical information.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response includes all major points from the ground truth, with only a minor omission of the explicit statement about teams not being good candidates for conversion if they use mixed API versions. Otherwise, it is thorough and accurate.",
        "overall_score": 6.6
    },
    {
        "testcase": "Unable to apply client flatten to a top level resource property.",
        "expected": {
            "answer": "Add\n@@Azure.ClientGenerator.Core.Legacy.flattenProperty(ArcSettings.propeties)\nBy convention put this in a back-compatible.tsp file.",
            "reference_urls": []
        },
        "actual": {
            "answer": "In TypeSpec, the equivalent of OpenAPI's x-ms-client-flatten is the @flattenProperty decorator from the Azure.ClientGenerator.Core.Legacy library. To express x-ms-client-flatten: true on a property (such as 'properties' on your ArcSetting resource), you should apply @flattenProperty to that property in your TypeSpec model. However, for Azure ARM resources that use the ProxyResource template (as you are doing), the properties field is automatically generated as part of the resource type, and the x-ms-client-flatten behavior is already handled by the Azure TypeSpec tooling\u2014so you do not need to add @flattenProperty manually for standard ProxyResource patterns.\n\nIf you have a custom property that is not handled by the default ProxyResource or if you want to force flattening in other cases, you can use:\n\n```typespec\nmodel ArcSetting is Azure.ResourceManager.ProxyResource<ArcSettingProperties> {\n  ...ResourceNameParameter;\n  // If you had a custom nested property to flatten, you would use:\n  // @flattenProperty\n  // customProperty: CustomType;\n}\n```\n\nBut for typical ARM resources modeled with ProxyResource and a 'properties' property, the correct Azure ARM OpenAPI output (with x-ms-client-flatten: true) is already produced by TypeSpec, as shown in the TypeSpec ARM Model Mapping documentation. If your generated OpenAPI is missing the x-ms-client-flatten, ensure you are using the latest TypeSpec Azure libraries and the ProxyResource template correctly.\n\n**Implication for SDKs:**\n- x-ms-client-flatten: true is used by client generators (like AutoRest) to flatten nested 'properties' into the top-level resource model in SDKs. If omitted, the SDK will expose a nested 'properties' object instead of flattening its fields into the top-level resource class, which is a breaking change for consumers expecting the flattened structure.\n- You should not manually add OpenAPI extensions like x-ms-client-flatten via @extension; use @flattenProperty if you must customize.\n\n**Summary:** For ARM ProxyResource in TypeSpec, do NOT add x-ms-client-flatten manually\u2014use the standard ProxyResource template. Only use @flattenProperty if you have non-standard nesting that requires flattening.\n\nIf you still observe the flag missing in generated OpenAPI, check that your ArcSetting model is correctly aliased to ProxyResource<ArcSettingProperties> and you are using up-to-date TypeSpec Azure tooling.",
            "reference_urls": [
                "https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi",
                "https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators",
                "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/mustread"
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The response is fully supported by the context, covers all essential points, and does not add unsupported information or omit critical details.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response is mostly complete: it covers the decorator, its purpose, and usage context, but misses the exact syntax and the convention about the file location.",
        "overall_score": 6.0
    },
    {
        "testcase": "Missing APIs in default tag error for typespec conversion PR",
        "expected": {
            "answer": "Part of the typespec conversion is replacing the existing swagger with a generated swagger.  The generated swagger is still used for some purposes, and Avocado protects the ability to process it. The generated swagger needs to be equivalent, but not necessarily identical.  Generally these issues reflected in the swagger will also show up in breaking change checks, which will have to be resolved (or suppressed if they are false positives)",
            "reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Requirement",
                "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff"
            ]
        },
        "actual": {
            "answer": "For a TypeSpec conversion PR like https://github.com/Azure/azure-rest-api-specs/pull/35346, the 'missing APIs in default tag' (Avocado) check compares the generated OpenAPI spec with the previous stable release. This check ensures that the new, TypeSpec-generated OpenAPI spec is functionally equivalent to the prior hand-authored Swagger, even though the source is now TypeSpec.\n\nSuppressing this check outright is not the recommended or supported approach for management-plane specs. Instead, you should:\n- Carefully review the differences reported by the check to ensure that all APIs present in the previous release are also present in the new TypeSpec-generated OpenAPI.\n- If the differences are false positives (e.g., due to conversion artifacts but not actual API removals), you may provide justification and follow the documented suppression process for false positives in breaking change or requirement checks.\n\nIn summary: You should not blanket suppress the 'missing APIs' check just because it's a TypeSpec conversion. Address the reported differences, and only suppress specific violations with justification if you confirm they are not real breaking changes. The generated OpenAPI must remain equivalent in API coverage to the previous release.\n\nFor more information on suppressions and resolving these validation issues, see the linked documentation below.",
            "reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec"
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": "",
        "groundedness_result": "unknown",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response is mostly complete, covering the main points about equivalence, breaking change checks, and suppression, but omits minor details about the ongoing use of the generated swagger and Avocado's specific protective function.",
        "overall_score": 0.0
    },
    {
        "testcase": "ArmResourcePatchAsync & discriminator",
        "expected": {
            "answer": "we generally suggest that PATCH requests over discriminated types should require the discriminator property.  This may result in some lintdiff violations, but that is expected, and those cna be suppressed.  This is especially true if, as most services, your PATCH operation would need the discriminator value on the wire to determine how to apply the PATCH request to the existing reosurce.",
            "reference_urls": []
        },
        "actual": {
            "answer": "When defining an ARM PATCH operation (such as using ArmResourcePatchAsync) for a resource that uses a discriminator (i.e., polymorphic resources with a 'kind' property), you must ensure that your PATCH model and schema conform to both the Azure API Guidelines for polymorphism and PATCH, and that the generated OpenAPI includes all required properties for each possible subtype. The OBJECT_MISSING_REQUIRED_PROPERTY_DEFINITION error from OpenAPI Validator (oav) typically means that the PATCH schema for one or more polymorphic subtypes does not include a required property definition, usually the discriminator itself (e.g., 'kind').\n\nHere is how you should model this in TypeSpec:\n\n1. **Use the DiscriminatedTrackedResource or DiscriminatedProxyResource templates** from `Azure.ResourceManager.Legacy` for your base resource model. These ensure the discriminator (usually 'kind') is present and properly handled.\n\n2. **For the PATCH (update) operation**, you should define a PATCH model that is also polymorphic and includes the discriminator property, with the same set of possible values (subtypes) as the main resource. This ensures the PATCH schema generated in OpenAPI has a oneOf/anyOf for each subtype, and that each includes the required discriminator property.\n\n3. **Use ArmCustomPatchAsync** (or ArmCustomPatchSync for sync PATCH) with your custom update model, rather than ArmResourcePatchAsync, if you need to control the PATCH request shape more precisely for discriminated resources. ArmResourcePatchAsync works well for flat resources, but with polymorphic ones you often need a bespoke PATCH model to ensure all requirements are met.\n\n4. **Ensure the PATCH model allows partial updates** but always includes the discriminator property as required, matching the guidance in the Azure API Guidelines (see reference below).\n\nExample:\n```typespec\nimport \"@azure-tools/typespec-azure-core\";\nimport \"@azure-tools/typespec-azure-resource-manager\";\n\n// Discriminated resource base\nmodel HostResourceBase is Azure.ResourceManager.Legacy.DiscriminatedTrackedResource<string, HostResourceProperties> {\n  kind: string; // Discriminator\n  properties: HostResourceProperties;\n}\n\n// Example subtypes\nmodel WindowsHostResource extends HostResourceBase {\n  kind: \"windows\";\n  properties: WindowsHostProperties;\n}\nmodel LinuxHostResource extends HostResourceBase {\n  kind: \"linux\";\n  properties: LinuxHostProperties;\n}\n\n// PATCH model: must be polymorphic and include 'kind'\nmodel HostResourceUpdateBase {\n  kind: string;\n  properties?: PartialHostResourceProperties;\n}\n\nmodel WindowsHostResourceUpdate extends HostResourceUpdateBase {\n  kind: \"windows\";\n  properties?: PartialWindowsHostProperties;\n}\nmodel LinuxHostResourceUpdate extends HostResourceUpdateBase {\n  kind: \"linux\";\n  properties?: PartialLinuxHostProperties;\n}\n\n// Union for PATCH body (for OpenAPI oneOf/anyOf)\ntype HostResourcePatchModel = WindowsHostResourceUpdate | LinuxHostResourceUpdate;\n\n@armResourceOperations\ninterface Hosts {\n  // ... other operations ...\n  update is ArmCustomPatchAsync<HostResourceBase, HostResourcePatchModel>;\n}\n```\n\n**Key points:**\n- The PATCH request model must be a discriminated union (with kind) matching the resource.\n- Each subtype must define the required discriminator and any required properties (if any).\n- The PATCH operation should reference this union, not just the base resource or a non-polymorphic model.\n\nThis approach will ensure the generated OpenAPI contains a oneOf/anyOf with required 'kind' for PATCH, passing oav validation for OBJECT_MISSING_REQUIRED_PROPERTY_DEFINITION.\n\nIf you use only ArmResourcePatchAsync on a discriminated resource without a custom PATCH model, the emitted PATCH schema may lack the required discriminator, leading to the validator error you observed.\n\n**Summary:**\n- Use a discriminated PATCH model matching your resource's polymorphism.\n- Reference that in your PATCH operation with ArmCustomPatchAsync.\n- Ensure each subtype includes the required discriminator property.\n\nThis will both satisfy Azure API Guidelines and pass OpenAPI validation.",
            "reference_urls": [
                "https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md",
                "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types",
                "https://azure.github.io/typespec-azure/docs/howtos/arm/resource-operations"
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": "",
        "groundedness_result": "unknown",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response is almost fully complete, covering all key claims and rationale from the ground truth, with only a minor omission regarding lintdiff violations and their suppression.",
        "overall_score": 0.0
    },
    {
        "testcase": "CI Failure \u2013 Swagger LintDiff",
        "expected": {
            "answer": "if you are fixing bugs already in main, this is expected.  lintdiff needs to run on your spec both before and after your PR, and if before is crashing, the PR to fix it will still crash.",
            "reference_urls": []
        },
        "actual": {
            "answer": "If your PR only fixes the README format and the CI check for Swagger LintDiff fails with `[Exception] No input files provided.`, this is expected behavior in certain cases. LintDiff needs to run on your spec both before and after your PR. If the base branch (the 'before' state) is already broken (for example, due to missing or misconfigured input files in main), then your PR\u2014even if it fixes the configuration\u2014will still fail LintDiff because it cannot compare against a valid 'before' state.\n\nTo resolve this:\n- Confirm that the base branch is compiling and LintDiff is passing before your PR. If not, any fix PRs will continue to fail until the base is repaired.\n- This is not a TypeSpec bug, but rather a workflow limitation with how LintDiff runs comparisons.\n- If you are fixing issues already present in main, it is normal for LintDiff to continue failing until the base/main branch is fixed. You may need to coordinate with repo maintainers to get the base branch into a passing state first.\n\nReference the guidance below for further troubleshooting and best practices.",
            "reference_urls": []
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": NaN,
        "groundedness_result": NaN,
        "groundedness_threshold": NaN,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response contains all the necessary and relevant information from the ground truth, with additional helpful context, and does not miss any key statements.",
        "overall_score": 0.0
    },
    {
        "testcase": "is sdk generation required for private preview?",
        "expected": {
            "answer": "API approval for private preview does NOT always require SDK generation or SDK configuration in your tspconfig.yaml. For private preview ARM APIs, it is acceptable to onboard and validate your API contract without including SDK emitter settings (such as for Go, Python, Java, etc.).\n\nHowever, the Azure TypeSpec validation tooling (tsv) is configured to expect certain SDK emitter options in tspconfig.yaml by default, even for private preview, which is why you see SdkTspConfigValidation failures if you remove them.\n\nThe correct and supported approach is:\n- Remove SDK emitter configs you do NOT want in your tspconfig.yaml.\n- Add a suppressions.yaml file in the same directory as tspconfig.yaml to explicitly suppress the SdkTspConfigValidation rule (or specific sub-rules for missing SDK configs).\n\nHere is a sample suppressions.yaml to suppress all SdkTspConfigValidation checks (recommended for your scenario):\n\n```yaml\n- tool: TypeSpecValidation\n  paths:\n    - tspconfig.yaml\n  rules:\n    - SdkTspConfigValidation\n  reason: 'SDK generation is not in scope for private preview onboarding.'\n```\n\nPlace this suppressions.yaml alongside your tspconfig.yaml. This will allow CI and local validation to succeed without requiring SDK settings, letting you focus on API review and onboarding. When you later want to add SDK support, you can remove the suppression and add the required SDK emitter configuration.\n\nIn summary: No, API approval for private preview does not require SDK generation. Use suppressions.yaml to bypass SDK validation in tspconfig.yaml until you are ready to onboard SDKs.",
            "reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline",
                "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation"
            ]
        },
        "actual": {
            "answer": "SDK generation is NOT required for ARM (management-plane) API approval for private preview. The API approval process primarily requires a valid OpenAPI (Swagger) generated from your TypeSpec, passing all validation checks, but you do NOT have to onboard SDK generation at this stage if your preview customers do not need it.\n\nTo configure your tspconfig.yaml for validation WITHOUT SDK emitter options:\n- You can safely remove SDK-related emitter configs (like @azure-tools/typespec-csharp, @azure-tools/typespec-python, etc.) from your tspconfig.yaml.\n- However, by default, TypeSpec validation in Azure DevOps (using tsv) may expect certain SDK options to be present and will fail SdkTspConfigValidation if they are missing.\n- To avoid tsv failures, you should SUPPRESS the SdkTspConfigValidation rule in your service's suppressions.yaml file. This is the recommended approach for services that do not wish to onboard SDKs yet.\n\nExample suppressions.yaml:\n```yaml\n- tool: TypeSpecValidation\n  paths:\n    - tspconfig.yaml\n  rules:\n    - SdkTspConfigValidation\n  reason: \"SDK generation is not required for private preview.\"\n```\n\nPlace this file at the root of your TypeSpec project (typically alongside your tspconfig.yaml). This tells the validation system to skip SDK configuration checks, allowing your TypeSpec validation to pass with only the @azure-tools/typespec-autorest emitter configured.\n\nYou do NOT need to supply fake or placeholder SDK options, and you should not leave incomplete SDK emitter config in your tspconfig.yaml.\n\nWhen you are ready to onboard SDKs later, simply remove the suppression and add the required emitter options as per the Azure SDK onboarding guidance.",
            "reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation"
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The response is fully grounded in the provided context, accurately conveying all essential information about SDK requirements, tspconfig.yaml configuration, and suppression for validation, with no unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, accurately reflecting each statement and instruction, with only minor wording differences and no missing claims.",
        "overall_score": 7.0
    },
    {
        "testcase": "Typespec Validation Failing on PR due to `typespec-go` configuration missing",
        "expected": {
            "answer": "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#suppressing-sdktspconfigvalidation-rules\nSuppressing go specific rules worked for me. Here's our suppression file:\n```yml\n- tool: TypeSpecValidation\npaths:\n- tspconfig.yaml\nrules:\n- SdkTspConfigValidation\nsub-rules:\n- options.@azure-tools/typespec-go.generate-fakes\n- options.@azure-tools/typespec-go.inject-spans\n- options.@azure-tools/typespec-go.service-dir\n- options.@azure-tools/typespec-go.package-dir\nreason: 'Azure Load Testing does not support a Go SDK currently'\n```",
            "reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation"
            ]
        },
        "actual": {
            "answer": "You are encountering TypeSpec validation failures due to missing Go SDK configuration options in your `tspconfig.yaml`, even though your service does not intend to produce a Go SDK. This is a known scenario. \n\nThe Azure TypeSpec validation pipeline enforces checks for all supported SDK languages by default, which includes Go, even if your service doesn't generate a Go SDK. To resolve this and bypass the validation failures, you should suppress the specific Go-related rules for the SdkTspConfigValidation validator.\n\nHere's how you can do it:\n\n1. Create (or update) a `suppressions.yaml` file in your service's TypeSpec root directory (the same place as your `tspconfig.yaml`).\n2. Add a suppression entry that targets the relevant Go SDK options. For example:\n\n```yaml\n- tool: TypeSpecValidation\n  paths:\n    - tspconfig.yaml\n  rules:\n    - SdkTspConfigValidation\n  sub-rules:\n    # Suppress validation for Go emitter options\n    - options.@azure-tools/typespec-go.generate-fakes\n    - options.@azure-tools/typespec-go.inject-spans\n    - options.@azure-tools/typespec-go.service-dir\n    - options.@azure-tools/typespec-go.package-dir\n  reason: 'This service does not support or plan to release a Go SDK.'\n```\n\nThis suppression will allow your PR to pass the required TypeSpec validation step, without forcing you to provide irrelevant Go configuration. This approach is fully supported and recommended in this scenario by Azure API guidelines.\n\nIf you later decide to produce a Go SDK, you can remove the suppression and add the required options.\n\nFor more details, see the references below.",
            "reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation"
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The response is complete, accurate, and directly supported by the context, with no unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, including the suppression file details and the solution steps, with no omissions.",
        "overall_score": 7.0
    },
    {
        "testcase": "How to make an interface internal ?",
        "expected": {
            "answer": "We do not support hiding an entire operation group directly. The recommended approach is to redefine your client in client.tsp to control which operations appear on the public client. When you do this properly, the default service clients and their Operations classes should not be emitted\u2014as long as you remove all previously generated SDK output before regenerating. Or you can use _patch.py to customize the code.",
            "reference_urls": [
                "https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators",
                "https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators"
            ]
        },
        "actual": {
            "answer": "Currently, there is no direct way to mark an entire interface as internal so that it is hidden from the public Python SDK surface using just a decorator like @access on the interface itself. The @access decorator does not work on interfaces for this purpose, as it is not interpreted by the client generator (tcgc) in that way.\n\nTo achieve your goal (hide EvaluationResultsOperations from the public Python SDK client), the best practice is to:\n\n1. Redefine your client in a separate `client.tsp` file. This allows you to control exactly which operations appear on the public client. By customizing the client structure this way, the default service clients and their associated `Operations` classes (like `EvaluationResultsOperations`) should not be emitted\u2014provided there is no leftover generated code from previous runs.\n2. After redefining the client, make sure to delete all previously generated SDK output before regenerating to ensure changes take effect.\n3. Optionally, you can use Python SDK customization (like a `_patch.py` file) to further hide or rename items (e.g., renaming `client.evaluation_results` to `client._evaluation_results`). This is only a workaround until more granular TypeSpec features are available.\n\nIn summary: The current best approach is to control the public client surface via client redefinition in TypeSpec, not by marking the interface as internal.\n\n> Note: Marking all operations under the interface as internal is not sufficient if the interface itself is still emitted. And the @access decorator does not currently propagate as desired to hide the interface in the generated Python SDK.\n\nIf you need a concrete example of how to redefine the client in `client.tsp`, please let me know.",
            "reference_urls": []
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, complete, and accurately conveys all essential information from the CONTEXT without introducing unsupported details or omitting critical points.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, with some additional clarifying details, and does not miss any key statements.",
        "overall_score": 7.0
    },
    {
        "testcase": "How to restrict importing typespec files in main based off of versions.",
        "expected": {
            "answer": "no, you have to mark the models/types and everything that you want to remove with the @removed decorator using the versioning library\nif you are in preview version I think also the policy is to only have a single preview version in the spec repo at the timme now so you could also just delete it",
            "reference_urls": [
                "https://azure.github.io/typespec-azure/docs/howtos/arm/versioning"
            ]
        },
        "actual": {
            "answer": "TypeSpec does NOT support conditional imports based on API version in your main.tsp or anywhere else. All imported files and their contents are always included in the TypeSpec program regardless of versioning. To handle resources, models, or operations that should not appear in certain API versions, you must use versioning decorators such as @removed and @added on the relevant types, models, or operations. This ensures the TypeSpec compiler will include or exclude these elements in the appropriate API versions when generating OpenAPI or SDKs.\n\nFor example, if you have a model or interface you want to remove starting with a new version, annotate it with @removed(Version.NewVersion). You do not need to (and cannot) conditionally import or exclude files. This is the official and only supported approach in Azure TypeSpec and aligns with Azure API best practices.\n\nIf your project is in preview and you only want one preview version, you could delete the old resource types from the codebase. But for proper versioned support, always use @removed and related decorators.",
            "reference_urls": [
                "https://azure.github.io/typespec-azure/docs/howtos/arm/versioning"
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, complete, and directly supported by the CONTEXT, with no unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response fully includes all necessary and relevant information from the ground truth, with no omissions or inaccuracies.",
        "overall_score": 7.0
    },
    {
        "testcase": "Description changes across versions?",
        "expected": {
            "answer": "Honestly, the best thing is to update your docs and take the update in previous versions (which are likely now more accurately described as well). Documentation updates are not breaking changes, and, if changes are limited to documentation, this should be passed easily by the breaking change board.",
            "reference_urls": []
        },
        "actual": {
            "answer": "The best practice in this situation is to update your documentation (description) and accept the update in previous versions as well. Documentation-only updates are not considered breaking changes, and these improvements should be propagated to all previously emitted specs for consistency and better documentation accuracy. It is not recommended to change the output path in tspconfig.yaml just to avoid updating older specs\u2014this approach is discouraged as it breaks the principle of reproducibility and consistency across versions.\n\nSo, when TypeSpec validation fails because the description changed in all versions, you should commit the updated generated specs for all versions. This ensures your documentation is correct everywhere and passes validation. Documentation changes do not trigger new SDK releases, so there is no negative impact from updating previous versions with improved descriptions.\n\nIn summary: update the docs, regenerate all affected specs, and commit the changes for all versions. Do not restrict the output to just the current version to work around validation checks.",
            "reference_urls": []
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": NaN,
        "groundedness_result": NaN,
        "groundedness_threshold": NaN,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response contains all relevant information from the ground truth and adds some helpful context, but does not miss any key statements or claims.",
        "overall_score": 0.0
    },
    {
        "testcase": "Quantum RP, add new filter to offering API",
        "expected": {
            "answer": "For a case like this, just decorating the filter property with `@added` in the same operation is the simplest mechanism.  Versioning the request and response data in an operation like this is usually the most straightforward way to version an operation.\nFor more complex operation versioning, you can use the remove/rename/sharedRoute mechanism described here: [Versioning | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/howtos/arm/versioning/#converting-an-operation-from-synchronous-to-asynchronous)\nNote also that you should name the property 'filter', the `@query(\"$filter\")` decorator actually sets the name on the wire,  you generally want to follow standard naming rules for parameters:\n```\n// v2 (new preview)\nlistBySubscription is ArmListBySubscription<\nQuantumSuiteOffer,\nParameters = {\n/**\n* The filter to apply to the operation. Example: '$filter=kind eq \"v1\"'\n*/\n@added(Versions.v2025_11_01_preview)\n@query(\"$filter\")\nfilter?: string;\n}\n>;\n```",
            "reference_urls": []
        },
        "actual": {
            "answer": "You are encountering a common issue when evolving an ARM list operation to support a new filter parameter. In TypeSpec, when you need to add a filter (or any parameter) to an operation in a new version, you should NOT remove and re-add the entire operation. Instead, you should version the parameters themselves using the @added decorator. This preserves the operation's continuity and avoids breaking the versioning system.\n\nHere's the correct way to add a filter parameter to your existing ArmListBySubscription operation for a new API version:\n\nAssume your version enum looks like this:\n\n```tsp\nenum Versions {\n  v2023_07_01,\n  v2025_11_01_preview,\n}\n\n@versioned(Versions)\nnamespace Microsoft.Quantum;\n```\n\nSuppose your original operation was:\n\n```tsp\n@armResourceOperations\ninterface Workspaces {\n  listBySubscription is ArmListBySubscription<Workspace>;\n}\n```\n\nTo add a filter in v2025_11_01_preview, do this:\n\n```tsp\n@armResourceOperations\ninterface Workspaces {\n  listBySubscription is ArmListBySubscription<\n    Workspace,\n    Parameters = {\n      @added(Versions.v2025_11_01_preview)\n      @query filter?: string;\n    }\n  >;\n}\n```\n\n- Do NOT use @removed or @added on the operation itself.\n- Only use @added on the new parameter, so it is only present in the new version and later.\n- The operation name stays the same, so you do not break clients using the older version.\n- If you need to add more query or header parameters, just add them to the Parameters model and decorate them appropriately.\n\nThis approach is directly aligned with the ARM TypeSpec versioning best practices.\n\n**Summary:**\n- Version the parameters, not the operation.\n- Use @added on the filter parameter for the new version.\n- Keep the operation name the same to ensure smooth versioning and avoid breaks.\n\nIf you need a concrete example, see the references below.",
            "reference_urls": [
                "https://azure.github.io/typespec-azure/docs/howtos/arm/versioning",
                "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/interfaces"
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded in the CONTEXT, accurately and completely conveying all essential information without introducing unsupported details or omitting critical points.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 3,
        "response_completeness_reason": "The response contains all the major information about versioning the parameter with @added and not the operation, and provides a matching example, but omits the detail about using @query(\"$filter\") for wire naming and the explicit naming guidance. These are minor omissions.",
        "overall_score": 6.6
    },
    {
        "average_score": 4.36,
        "total_evals": 15,
        "similarity_pass_rate": 15,
        "groundedness_pass_rate": 10,
        "response_completeness_pass_rate": 15,
        "similarity_fail_rate": 0,
        "groundedness_fail_rate": 0,
        "response_completeness_fail_rate": 0
    }
]