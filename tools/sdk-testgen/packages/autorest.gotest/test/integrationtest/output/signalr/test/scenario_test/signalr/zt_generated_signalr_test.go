//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package test_test

import (
	"context"
	"os"
	"testing"

	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/resources/armresources"
)

var (
	ctx               context.Context
	cred              azcore.TokenCredential
	resourceGroup     *armresources.ResourceGroup
	location          = getEnv("LOCATION", "")
	resourceGroupName = getEnv("RESOURCE_GROUP_NAME", "")
	subscriptionId    = getEnv("SUBSCRIPTION_ID", "")
)

func TestSignalr(t *testing.T) {
	setUp(t)
	scenarioSignalr(t)
	tearDown(t)
}

func setUp(t *testing.T) {
	var err error
	ctx = context.Background()
	cred, err = azidentity.NewEnvironmentCredential(nil)
	if err != nil {
		t.Fatalf("Failed to create credential: %v", err)
	}
	resourceGroup, err = createResourceGroup(ctx, cred)
	if err != nil {
		t.Fatalf("Failed to create resource group: %v", err)
	}
	t.Logf("Resource group created: id - %s name - %s", *resourceGroup.ID, *resourceGroup.Name)
	prepare(t)
}

func createResourceGroup(ctx context.Context, cred azcore.TokenCredential) (*armresources.ResourceGroup, error) {
	rgClient := armresources.NewResourceGroupsClient(subscriptionId, cred, nil)
	param := armresources.ResourceGroup{
		Location: to.StringPtr(location),
	}
	resp, err := rgClient.CreateOrUpdate(ctx, resourceGroupName, param, nil)
	if err != nil {
		return nil, err
	}
	return &resp.ResourceGroup, nil
}

func deleteResourceGroup(ctx context.Context, cred azcore.TokenCredential) error {
	rgClient := armresources.NewResourceGroupsClient(subscriptionId, cred, nil)
	poller, err := rgClient.BeginDelete(ctx, resourceGroupName, nil)
	if err != nil {
		return err
	}
	if _, err := poller.PollUntilDone(ctx, 10*time.Second); err != nil {
		return err
	}
	return nil
}

func tearDown(t *testing.T) {
	cleanup(t)
	err := deleteResourceGroup(ctx, cred)
	if err != nil {
		t.Fatalf("Failed to delete resource group: %v", err)
	}
	t.Logf("Resource group deleted")
}

func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}
	return fallback
}

func createDeployment(deploymentName string, template, params map[string]interface{}) (de *armresources.DeploymentExtended, err error) {
	deployClient := armresources.NewDeploymentsClient(subscriptionId, cred, nil)
	poller, err := deployClient.BeginCreateOrUpdate(
		ctx,
		resourceGroupName,
		deploymentName,
		armresources.Deployment{
			Properties: &armresources.DeploymentProperties{
				Template:   template,
				Parameters: params,
				Mode:       armresources.DeploymentModeIncremental.ToPtr(),
			},
		},
		&armresources.DeploymentsClientBeginCreateOrUpdateOptions{},
	)
	if err != nil {
		return nil, err
	}
	res, err := poller.PollUntilDone(ctx, 10*time.Second)
	if err != nil {
		return nil, err
	}
	return &res.DeploymentExtended, nil
}

func prepare(t *testing.T) {
}
func scenarioSignalr(t *testing.T) {
	var resourceName string
	// From step Generate_Unique_Name
	{
		template := map[string]interface{}{
			"$schema":        "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
			"contentVersion": "1.0.0.0",
			"outputs": map[string]interface{}{
				"resourceName": map[string]interface{}{
					"type":  "string",
					"value": "[variables('name').value]",
				},
			},
			"resources": []interface{}{},
			"variables": map[string]interface{}{
				"name": map[string]interface{}{
					"type": "string",
					"metadata": map[string]interface{}{
						"description": "Name of the SignalR service.",
					},
					"value": "[concat('sw',uniqueString(resourceGroup().id))]",
				},
			},
		}
		params := map[string]interface{}{}
		deploymentExtend, err := createDeployment("Generate_Unique_Name", template, params)
		if err != nil {
			t.Fatalf("Deployment error: %v", err)
		}
		resourceName = deploymentExtend.Properties.Outputs["resourceName"].(map[string]interface{})["value"].(string)
	}

	// From step SignalR_CheckNameAvailability
	signalRClient := test.NewSignalRClient(subscriptionId, cred, nil)
	{
		signalRClientCheckNameAvailabilityResponse, err := signalRClient.CheckNameAvailability(ctx,
			location,
			test.NameAvailabilityParameters{
				Name: to.StringPtr(resourceName),
				Type: to.StringPtr("Microsoft.SignalRService/SignalR"),
			},
			nil)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
		t.Logf("Response result: %#v\n", signalRClientCheckNameAvailabilityResponse.SignalRClientCheckNameAvailabilityResult)
	}

	// From step SignalR_CreateOrUpdate
	{
		signalRClientCreateOrUpdatePollerResponse, err := signalRClient.BeginCreateOrUpdate(ctx,
			resourceGroupName,
			resourceName,
			test.ResourceInfo{
				Location: to.StringPtr(location),
				Tags: map[string]*string{
					"key1": to.StringPtr("value1"),
				},
				Identity: &test.ManagedIdentity{
					Type: test.ManagedIdentityTypeSystemAssigned.ToPtr(),
				},
				Kind: test.ServiceKindSignalR.ToPtr(),
				Properties: &test.SignalRProperties{
					Cors: &test.SignalRCorsSettings{
						AllowedOrigins: []*string{
							to.StringPtr("https://foo.com"),
							to.StringPtr("https://bar.com")},
					},
					DisableAADAuth:   to.BoolPtr(false),
					DisableLocalAuth: to.BoolPtr(false),
					Features: []*test.SignalRFeature{
						{
							Flag:       test.FeatureFlagsServiceMode.ToPtr(),
							Properties: map[string]*string{},
							Value:      to.StringPtr("Serverless"),
						},
						{
							Flag:       test.FeatureFlagsEnableConnectivityLogs.ToPtr(),
							Properties: map[string]*string{},
							Value:      to.StringPtr("True"),
						},
						{
							Flag:       test.FeatureFlagsEnableMessagingLogs.ToPtr(),
							Properties: map[string]*string{},
							Value:      to.StringPtr("False"),
						},
						{
							Flag:       test.FeatureFlagsEnableLiveTrace.ToPtr(),
							Properties: map[string]*string{},
							Value:      to.StringPtr("False"),
						}},
					NetworkACLs: &test.SignalRNetworkACLs{
						DefaultAction: test.ACLActionDeny.ToPtr(),
						PrivateEndpoints: []*test.PrivateEndpointACL{
							{
								Allow: []*test.SignalRRequestType{
									test.SignalRRequestTypeServerConnection.ToPtr()},
								Name: to.StringPtr(resourceName + ".1fa229cd-bf3f-47f0-8c49-afb36723997e"),
							}},
						PublicNetwork: &test.NetworkACL{
							Allow: []*test.SignalRRequestType{
								test.SignalRRequestTypeClientConnection.ToPtr()},
						},
					},
					PublicNetworkAccess: to.StringPtr("Enabled"),
					TLS: &test.SignalRTLSSettings{
						ClientCertEnabled: to.BoolPtr(false),
					},
					Upstream: &test.ServerlessUpstreamSettings{
						Templates: []*test.UpstreamTemplate{
							{
								Auth: &test.UpstreamAuthSettings{
									Type: test.UpstreamAuthTypeManagedIdentity.ToPtr(),
									ManagedIdentity: &test.ManagedIdentitySettings{
										Resource: to.StringPtr("api://example"),
									},
								},
								CategoryPattern: to.StringPtr("*"),
								EventPattern:    to.StringPtr("connect,disconnect"),
								HubPattern:      to.StringPtr("*"),
								URLTemplate:     to.StringPtr("https://example.com/chat/api/connect"),
							}},
					},
				},
				SKU: &test.ResourceSKU{
					Name:     to.StringPtr("Standard_S1"),
					Capacity: to.Int32Ptr(1),
					Tier:     test.SignalRSKUTierStandard.ToPtr(),
				},
			},
			nil)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
		response, err := signalRClientCreateOrUpdatePollerResponse.PollUntilDone(ctx, 10*time.Second)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
		t.Logf("Response result: %#v\n", response.SignalRClientCreateOrUpdateResult)
	}

	// From step SignalR_Get
	{
		signalRClientGetResponse, err := signalRClient.Get(ctx,
			resourceGroupName,
			resourceName,
			nil)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
		t.Logf("Response result: %#v\n", signalRClientGetResponse.SignalRClientGetResult)
	}

	// From step SignalR_Update
	{
		signalRClientUpdatePollerResponse, err := signalRClient.BeginUpdate(ctx,
			resourceGroupName,
			resourceName,
			test.ResourceInfo{
				Location: to.StringPtr(location),
				Tags: map[string]*string{
					"key1": to.StringPtr("value1"),
				},
				Identity: &test.ManagedIdentity{
					Type: test.ManagedIdentityTypeSystemAssigned.ToPtr(),
				},
				Kind: test.ServiceKindSignalR.ToPtr(),
				Properties: &test.SignalRProperties{
					Cors: &test.SignalRCorsSettings{
						AllowedOrigins: []*string{
							to.StringPtr("https://foo.com"),
							to.StringPtr("https://bar.com")},
					},
					DisableAADAuth:   to.BoolPtr(false),
					DisableLocalAuth: to.BoolPtr(false),
					Features: []*test.SignalRFeature{
						{
							Flag:       test.FeatureFlagsServiceMode.ToPtr(),
							Properties: map[string]*string{},
							Value:      to.StringPtr("Serverless"),
						},
						{
							Flag:       test.FeatureFlagsEnableConnectivityLogs.ToPtr(),
							Properties: map[string]*string{},
							Value:      to.StringPtr("True"),
						},
						{
							Flag:       test.FeatureFlagsEnableMessagingLogs.ToPtr(),
							Properties: map[string]*string{},
							Value:      to.StringPtr("False"),
						},
						{
							Flag:       test.FeatureFlagsEnableLiveTrace.ToPtr(),
							Properties: map[string]*string{},
							Value:      to.StringPtr("False"),
						}},
					NetworkACLs: &test.SignalRNetworkACLs{
						DefaultAction: test.ACLActionDeny.ToPtr(),
						PrivateEndpoints: []*test.PrivateEndpointACL{
							{
								Allow: []*test.SignalRRequestType{
									test.SignalRRequestTypeServerConnection.ToPtr()},
								Name: to.StringPtr(resourceName + ".1fa229cd-bf3f-47f0-8c49-afb36723997e"),
							}},
						PublicNetwork: &test.NetworkACL{
							Allow: []*test.SignalRRequestType{
								test.SignalRRequestTypeClientConnection.ToPtr()},
						},
					},
					PublicNetworkAccess: to.StringPtr("Enabled"),
					TLS: &test.SignalRTLSSettings{
						ClientCertEnabled: to.BoolPtr(false),
					},
					Upstream: &test.ServerlessUpstreamSettings{
						Templates: []*test.UpstreamTemplate{
							{
								Auth: &test.UpstreamAuthSettings{
									Type: test.UpstreamAuthTypeManagedIdentity.ToPtr(),
									ManagedIdentity: &test.ManagedIdentitySettings{
										Resource: to.StringPtr("api://example"),
									},
								},
								CategoryPattern: to.StringPtr("*"),
								EventPattern:    to.StringPtr("connect,disconnect"),
								HubPattern:      to.StringPtr("*"),
								URLTemplate:     to.StringPtr("https://example.com/chat/api/connect"),
							}},
					},
				},
				SKU: &test.ResourceSKU{
					Name:     to.StringPtr("Standard_S1"),
					Capacity: to.Int32Ptr(1),
					Tier:     test.SignalRSKUTierStandard.ToPtr(),
				},
			},
			nil)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
		response, err := signalRClientUpdatePollerResponse.PollUntilDone(ctx, 10*time.Second)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
		t.Logf("Response result: %#v\n", response.SignalRClientUpdateResult)
	}

	// From step SignalR_ListKeys
	{
		signalRClientListKeysResponse, err := signalRClient.ListKeys(ctx,
			resourceGroupName,
			resourceName,
			nil)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
		t.Logf("Response result: %#v\n", signalRClientListKeysResponse.SignalRClientListKeysResult)
	}

	// From step SignalR_RegenerateKey
	{
		signalRClientRegenerateKeyPollerResponse, err := signalRClient.BeginRegenerateKey(ctx,
			resourceGroupName,
			resourceName,
			test.RegenerateKeyParameters{
				KeyType: test.KeyTypePrimary.ToPtr(),
			},
			nil)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
		_, err = signalRClientRegenerateKeyPollerResponse.PollUntilDone(ctx, 10*time.Second)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
	}

	// From step SignalR_Restart
	{
		signalRClientRestartPollerResponse, err := signalRClient.BeginRestart(ctx,
			resourceGroupName,
			resourceName,
			nil)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
		_, err = signalRClientRestartPollerResponse.PollUntilDone(ctx, 10*time.Second)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
	}

	// From step Usages_List
	usagesClient := test.NewUsagesClient(subscriptionId, cred, nil)
	{
		usagesClientListPager := usagesClient.List(location,
			nil)
		for usagesClientListPager.NextPage(ctx) {
			if err := usagesClientListPager.Err(); err != nil {
				t.Fatalf("Failed to advance page: %v", err)
			}
			for _, v := range usagesClientListPager.PageResponse().Value {
				t.Logf("Pager result: %#v\n", v)
			}
		}
	}

	// From step SignalR_ListByResourceGroup
	{
		signalRClientListByResourceGroupPager := signalRClient.ListByResourceGroup(resourceGroupName,
			nil)
		for signalRClientListByResourceGroupPager.NextPage(ctx) {
			if err := signalRClientListByResourceGroupPager.Err(); err != nil {
				t.Fatalf("Failed to advance page: %v", err)
			}
			for _, v := range signalRClientListByResourceGroupPager.PageResponse().Value {
				t.Logf("Pager result: %#v\n", v)
			}
		}
	}

	// From step SignalR_ListBySubscription
	{
		signalRClientListBySubscriptionPager := signalRClient.ListBySubscription(nil)
		for signalRClientListBySubscriptionPager.NextPage(ctx) {
			if err := signalRClientListBySubscriptionPager.Err(); err != nil {
				t.Fatalf("Failed to advance page: %v", err)
			}
			for _, v := range signalRClientListBySubscriptionPager.PageResponse().Value {
				t.Logf("Pager result: %#v\n", v)
			}
		}
	}

	// From step Operations_List
	operationsClient := test.NewOperationsClient(cred, nil)
	{
		operationsClientListPager := operationsClient.List(nil)
		for operationsClientListPager.NextPage(ctx) {
			if err := operationsClientListPager.Err(); err != nil {
				t.Fatalf("Failed to advance page: %v", err)
			}
			for _, v := range operationsClientListPager.PageResponse().Value {
				t.Logf("Pager result: %#v\n", v)
			}
		}
	}

	// From step SignalR_Delete
	{
		signalRClientDeletePollerResponse, err := signalRClient.BeginDelete(ctx,
			resourceGroupName,
			resourceName,
			nil)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
		_, err = signalRClientDeletePollerResponse.PollUntilDone(ctx, 10*time.Second)
		if err != nil {
			t.Fatalf("Request error: %v", err)
		}
	}
}

func cleanup(t *testing.T) {
}
