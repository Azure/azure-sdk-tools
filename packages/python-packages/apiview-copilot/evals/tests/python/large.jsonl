{"testcase": "few_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.16), Python version: 3.10.16\n\n\nnamespace azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\n@distributed_trace_async\nasync def analyze_document_async(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AnalyzeResult:\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.aio\n\nclass azure.ai.documentintelligence.aio.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@asyncio.coroutine\ndef get_classifier_old(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails:\n\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failed_count: int\nivar skipped_count: int\nivar succeeded_count: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\nNEURAL = \"neural\"\nTEMPLATE = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "\nDO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```\nDO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine (https://docs.python.org/3.4/library/asyncio-task.html) syntax.", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-client-separate-sync-async\"], \"line_no\": 326, \"bad_code\": \"async def analyze_document_async(self, model_id: str, body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], **kwargs: Any) -> AnalyzeResult\", \"suggestion\": \"Remove this asynchronous method from the synchronous client. Instead, offer an equivalent async method only in the async client located under the azure.ai.documentintelligence.aio namespace.\", \"comment\": \"Synchronous client classes must not mix in async methods. The 'analyze_document_async' method in the sync client violates the guideline for providing separate sync and async clients.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-async-keywords\"], \"line_no\": 937, \"bad_code\": \"    @asyncio.coroutine\", \"suggestion\": \"Replace the use of '@asyncio.coroutine' with an 'async def' definition. For example, remove the decorator and define the method with 'async def get_classifier_old(...):'.\", \"comment\": \"The use of '@asyncio.coroutine' is deprecated; the guidelines require using async/await syntax for asynchronous methods.\", \"source\": \"guideline\"}]}"}
{"testcase": "many_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.16), Python version: 3.10.16\n\nnamespace microsoft.azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\ndef client(self, name, **kwargs) -> DocumentIntelligenceClient\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\n@distributed_trace\ndef process_document(\nself,\nmodel_id,\ndoc_type,\nsource,\nversion,\nlocale,\nformat,\npages,\nfields,\ntimeout\n) -> AnalyzeResult\n\n@distributed_trace\ndef analyze_batch(\nself,\nmodel_id,\nbody,\nfeatures=None,\nlocale=None,\noutput=None\n) -> LROPoller[AnalyzeBatchResult]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.async\n\nclass azure.ai.documentintelligence.async.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.async.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.async.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    api_key: str,\n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failedCount: int\nivar skippedCount: int\nivar succeededCount: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\nneural = \"neural\"\ntemplate = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\nclass DocumentIntelligenceCustomError(Exception):\n    ivar error: str\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "\nDO implement your library as a sub-package of the azure root namespace.\n\nNote: You MUST NOT use microsoft as your root namespace. If you need to include microsoft in the namespace (e.g. because of policy requirements for extensions to other projects such as opentelemetry), you should concatenate it with the package specific namespace with an underscore (e.g. microsoft_myservice). You may still use microsoft-myservice as the distribution package name in this scenario.\nDO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child.\nYOU SHOULD NOT have methods that require more than five positional parameters. Optional/flag parameters can be accepted using keyword-only arguments, or **kwargs.\n\n\nDO use keyword-only arguments for optional or less-often-used arguments for modules that only need to support Python 3.\n\n```python\n# Yes\ndef foo(a, b, *, c, d=None):\n    # Note that I can even have required keyword-only arguments...\n    ...\n\n```\nDO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods.\nDO use the credentials classes in azure-core whenever possible.\nDO use snake_case for variable, function, and method names:\n\n```python\n# Yes:\nservice_client = ServiceClient()\n\nservice_client.list_things()\n\ndef do_something():\n    ...\n\n# No:\nserviceClient = ServiceClient()\n\nservice_client.listThings()\n\ndef DoSomething():\n    ...\n\n```\nDO use UPPERCASE for enum member names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```\nDO NOT create new exception types when a built-in exception type (https://docs.python.org/3/library/exceptions.html) will suffice.", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-namespaces-prefix\"], \"line_no\": 3, \"bad_code\": \"namespace microsoft.azure.ai.documentintelligence\", \"suggestion\": \"namespace azure.ai.documentintelligence\", \"comment\": \"The namespace declaration includes a 'microsoft' prefix. According to the guidelines, the library should be implemented as a sub\\u2010package of the azure root namespace (and must not use 'microsoft' as the root namespace).\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-hier-vend\"], \"line_no\": 332, \"bad_code\": \"def client(self, name, **kwargs) -> DocumentIntelligenceClient\", \"suggestion\": \"def get_client(self, name, **kwargs) -> DocumentIntelligenceClient\", \"comment\": \"For hierarchical clients the method retrieving a child client should be named with a 'get_' prefix (e.g. get_client) according to the guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-long-args\"], \"line_no\": 629, \"bad_code\": \"def process_document(self, model_id, doc_type, source, version, locale, format, pages, fields, timeout) -> AnalyzeResult\", \"suggestion\": \"def process_document(self, model_id, *, doc_type, source, version, locale, format, pages, fields, timeout) -> AnalyzeResult\", \"comment\": \"The process_document method takes too many positional parameters (nine in total). This violates the guideline that advises against methods requiring more than five positional parameters. Refactor these parameters to be keyword-only.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-optional-args\"], \"line_no\": 643, \"bad_code\": \"def analyze_batch(\", \"suggestion\": \"def analyze_batch(self, model_id, body, *, features=None, locale=None, output=None) -> LROPoller[AnalyzeBatchResult]\", \"comment\": \"Optional parameters in the analyze_batch method should be declared as keyword\\u2011only. This helps improve clarity and conforms to SDK design guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-namespaces-async\"], \"line_no\": 661, \"bad_code\": \"namespace azure.ai.documentintelligence.async\", \"suggestion\": \"namespace azure.ai.documentintelligence.aio\", \"comment\": \"Asynchronous client types should reside in an '.aio' subpackage rather than '.async'. This change conforms with SDK guidelines for async namespacing.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-auth-credential-azure-core\"], \"line_no\": 995, \"bad_code\": \"api_key: str\", \"suggestion\": \"credential: Union[AzureKeyCredential, AsyncTokenCredential]\", \"comment\": \"In the async DocumentIntelligenceClient constructor the parameter is defined as a plain string (api_key: str). The guidelines require using the credential types provided by azure-core (e.g. AzureKeyCredential or AsyncTokenCredential) for authentication.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1427, \"bad_code\": \"ivar failedCount: int\", \"suggestion\": \"ivar failed_count: int\", \"comment\": \"The attribute name 'failedCount' does not follow snake_case conventions. It should be renamed to 'failed_count' to comply with the naming guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1428, \"bad_code\": \"ivar skippedCount: int\", \"suggestion\": \"ivar skipped_count: int\", \"comment\": \"Variable names should use snake_case. 'skippedCount' should be renamed to 'skipped_count'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1429, \"bad_code\": \"ivar succeededCount: int\", \"suggestion\": \"ivar succeeded_count: int\", \"comment\": \"Variable names should use snake_case. 'succeededCount' should be renamed to 'succeeded_count'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-name-uppercase\"], \"line_no\": 1948, \"bad_code\": \"neural = \\\"neural\\\"\", \"suggestion\": \"NEURAL = \\\"neural\\\" (and similarly, use TEMPLATE = \\\"template\\\" for the other member)\", \"comment\": \"Enum member names must be in UPPERCASE. The current definition of DocumentBuildMode uses lower-case member names.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-errors-use-standard-exceptions\"], \"line_no\": 3160, \"bad_code\": \"class DocumentIntelligenceCustomError(Exception):\", \"suggestion\": \"Consider using an existing exception type from azure-core (for example, subclass AzureError) or a built-in exception if appropriate, rather than creating a new custom exception.\", \"comment\": \"Custom exceptions should be avoided if a standard or azure-core exception type can convey the error, per SDK guidelines.\", \"source\": \"guideline\"}]}"}
{"testcase": "no_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.18), Python version: 3.10.16\n\n\nnamespace azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.aio\n\nclass azure.ai.documentintelligence.aio.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failed_count: int\nivar skipped_count: int\nivar succeeded_count: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\nNEURAL = \"neural\"\nTEMPLATE = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "", "response": "{\"comments\": []}"}
{"testcase": "multiple_same_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.18), Python version: 3.10.16\n\n\nnamespace azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.aio\n\nclass azure.ai.documentintelligence.aio.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failed_count: int\nivar skipped_count: int\nivar succeeded_count: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(Enum):\nNEURAL = \"neural\"\nTEMPLATE = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "\nDO use extensible enumerations.", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 1448, \"bad_code\": \"class azure.ai.documentintelligence.models.AnalyzeOutputOption(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\", \"comment\": \"Enums in the SDK should be extensible by inheriting from str as well as Enum. This allows for flexible comparisons and future extensions.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1811, \"bad_code\": \"class azure.ai.documentintelligence.models.ContentSourceKind(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\", \"comment\": \"Enums should extend str to adhere to the guideline of using extensible enumerations in the SDK.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1864, \"bad_code\": \"class azure.ai.documentintelligence.models.DocumentAnalysisFeature(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\", \"comment\": \"Enums should extend str to adhere to the guideline of using extensible enumerations in the SDK.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1902, \"bad_code\": \"class azure.ai.documentintelligence.models.DocumentBarcodeKind(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\", \"comment\": \"Enum members should be based on str to ensure extensibility and compliance with SDK guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1922, \"bad_code\": \"class azure.ai.documentintelligence.models.DocumentBuildMode(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\", \"comment\": \"For consistency and extensibility, enums should inherit from str alongside Enum.\", \"source\": \"guideline\"}]}"}
