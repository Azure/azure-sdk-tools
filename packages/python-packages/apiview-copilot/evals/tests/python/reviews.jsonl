{"testcase": "small_apiview_few_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.14), Python version: 3.12.9\n\nnamespace azure.ai.vision.imageanalysis\n\nclass azure.ai.vision.imageanalysis.ImageAnalysisClient(ImageAnalysisClient): implements ContextManager \n    def __init__(\n        self, \n        endpoint: str, \n        credential: Union[AzureKeyCredential, TokenCredential], \n        connection_string: Optional[str] = None,\n        *, \n        api_version: str = ..., \n        **kwargs: Any\n    ) -> None\n\n    @distributed_trace\n    def analyze(\n        self, \n        image_data: bytes, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    @distributed_trace\n    def analyze_from_url(\n        self, \n        image_url: str, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    def close(self) -> None\n\n    def send_request(\n        self, \n        request: HttpRequest, \n        *, \n        stream: bool = False, \n        **kwargs: Any\n    ) -> HttpResponse\n\nnamespace azure.ai.vision.imageanalysis.aio\n\nclass azure.ai.vision.imageanalysis.aio.ImageAnalysisClient(ImageAnalysisClient): implements AsyncContextManager \n    def __init__(\n        self, \n        endpoint: str, \n        credential: Union[AzureKeyCredential, AsyncTokenCredential], \n        *, \n        api_version: str = ..., \n        **kwargs: Any\n    ) -> None\n\n    @distributed_trace_async\n    async def analyze(\n        self, \n        image_data: bytes, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    @distributed_trace_async\n    async def analyze_from_url(\n        self, \n        image_url: str, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    async def close(self) -> None\n\n    def send_request(\n        self, \n        request: HttpRequest, \n        *, \n        stream: bool = False, \n        **kwargs: Any\n    ) -> Awaitable[AsyncHttpResponse]\n\nnamespace azure.ai.vision.imageanalysis.models\n\nclass azure.ai.vision.imageanalysis.models.CaptionResult(MutableMapping[str, Any]):\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.CropRegion(MutableMapping[str, Any]):\n    ivar aspect_ratio: float\n    ivar bounding_box: ImageBoundingBox\n\n    @overload\n    def __init__(\n        self, \n        *, \n        aspect_ratio: float, \n        bounding_box: ImageBoundingBox\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nnamespace azure.ai.vision.imageanalysis.models\n\nclass azure.ai.vision.imageanalysis.models.DenseCaption(MutableMapping[str, Any]):\n    ivar bounding_box: ImageBoundingBox\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_box: ImageBoundingBox, \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DenseCaptionsResult(MutableMapping[str, Any]):\n    ivar list: List[DenseCaption]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DenseCaption]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextBlock(MutableMapping[str, Any]):\n    ivar lines: List[DetectedTextLine]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        lines: List[DetectedTextLine]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextLine(MutableMapping[str, Any]):\n    ivar bounding_polygon: List[ImagePoint]\n    ivar text: str\n    ivar words: List[DetectedTextWord]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_polygon: List[ImagePoint], \n        text: str, \n        words: List[DetectedTextWord]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextWord(MutableMapping[str, Any]):\n    ivar bounding_polygon: List[ImagePoint]\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_polygon: List[ImagePoint], \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImageAnalysisResult(MutableMapping[str, Any]):\n    ivar caption: Optional[CaptionResult]\n    ivar dense_captions: Optional[DenseCaptionsResult]\n    ivar metadata: ImageMetadata\n    ivar model_version: str\n    ivar objects: Optional[ObjectsResult]\n    ivar people: Optional[PeopleResult]\n    ivar read: Optional[ReadResult]\n    ivar smart_crops: Optional[SmartCropsResult]\n    ivar tags: Optional[TagsResult]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        caption: Optional[CaptionResult] = ..., \n        dense_captions: Optional[DenseCaptionsResult] = ..., \n        metadata: ImageMetadata, \n        model_version: str, \n        objects: Optional[ObjectsResult] = ..., \n        people: Optional[PeopleResult] = ..., \n        read: Optional[ReadResult] = ..., \n        smart_crops: Optional[SmartCropsResult] = ..., \n        tags: Optional[TagsResult] = ...\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImageBoundingBox(MutableMapping[str, Any]):\n    ivar height: int\n    ivar width: int\n    ivar x: int\n    ivar y: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        height: int, \n        width: int, \n        x: int, \n        y: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.ImageMetadata(MutableMapping[str, Any]):\n    ivar height: int\n    ivar width: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        height: int, \n        width: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImagePoint(MutableMapping[str, Any]):\n    ivar x: int\n    ivar y: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        x: int, \n        y: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ObjectsResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedObject]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedObject]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.aio.PeopleResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedPerson]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedPerson]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ReadResult(MutableMapping[str, Any]):\n    ivar blocks: List[DetectedTextBlock]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        blocks: List[DetectedTextBlock]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.SmartCropsResult(MutableMapping[str, Any]):\n    ivar list: List[CropRegion]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[CropRegion]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.TagsResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedTag]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedTag]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.VisualFeatures(str, Enum):\n    CAPTION = 'caption'\n    DENSE_CAPTIONS = 'denseCaptions'\n    OBJECTS = 'objects'\n    PEOPLE = 'people'\n    READ = 'read'\n    SMART_CROPS = 'smartCrops'\n    TAGS = 'tags'", "language": "python", "context": "\nDO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\nDO NOT duplicate models between the root and aio namespace.", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-client-connection-string\"], \"line_no\": 10, \"bad_code\": \"connection_string: Optional[str] = None,\", \"suggestion\": \"Remove the connection_string parameter from the __init__ method and instead implement a separate from_connection_string class method.\", \"comment\": \"The constructor should not accept a connection string per the guideline. Instead, a factory method (from_connection_string) must be provided if supported.\", \"source\": \"guideline\"}, {\"rule_ids\": [], \"line_no\": 171, \"bad_code\": \"ivar list: List[DenseCaption]\", \"suggestion\": \"ivar captions: List[DenseCaption]\", \"comment\": \"Using 'list' as an attribute name shadows the built-in list type and may be ambiguous. A more descriptive name such as 'captions' would better convey its intent.\", \"source\": \"generic\"}, {\"rule_ids\": [\"python_design.html#python-models-async\"], \"line_no\": 382, \"bad_code\": \"class azure.ai.vision.imageanalysis.models.aio.PeopleResult(MutableMapping[str, Any]):\", \"suggestion\": \"Remove PeopleResult from the aio sub-namespace and define it only once in the shared models namespace.\", \"comment\": \"Models should not be duplicated between the root and aio namespace per the guidelines. Reuse the model from azure.ai.vision.imageanalysis.models.\", \"source\": \"guideline\"}]}"}
{"testcase": "small_apiview_many_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.14), Python version: 3.12.9\n\nnamespace azure.ai.vision.imageanalysis\n\nclass azure.ai.vision.imageanalysis.ImageAnalysisClient(ImageAnalysisClient): implements ContextManager \n    def __init__(\n        self, \n        endpoint: str, \n        credential: Union[AzureKeyCredential, TokenCredential], \n        connection_string: Optional[str] = None,\n        *, \n        api_version: str = ..., \n        **kwargs: Any\n    ) -> None\n\n    @distributed_trace\n    def analyze(\n        self, \n        image_data: bytes, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    @distributed_trace\n    def analyze_from_url(\n        self, \n        image_url: str, \n        visual_features: List[VisualFeatures], \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    def close(self) -> None\n\n    def send_request(\n        self, \n        request: HttpRequest, \n        *, \n        stream: bool = False, \n        **kwargs: Any\n    ) -> HttpResponse\n\nnamespace azure.ai.vision.imageanalysis.aio\n\nclass azure.ai.vision.imageanalysis.aio.AsyncImageAnalysisClient(ImageAnalysisClient): implements AsyncContextManager \n    def __init__(\n        self, \n        endpoint: str, \n        credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    ) -> None\n\n    @distributed_trace_async\n    async def analyze(\n        self, \n        image_data: bytes, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    @distributed_trace_async\n    async def analyze_from_url(\n        self, \n        image_url: str, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    async def close(self) -> None\n\n    @staticmethod\n    def send_request(\n        self, \n        request: HttpRequest, \n        *, \n        stream: bool = False, \n        **kwargs: Any\n    ) -> Awaitable[AsyncHttpResponse]\n\nnamespace azure.ai.vision.imageanalysis.models\n\nclass azure.ai.vision.imageanalysis.models.CaptionResult(MutableMapping[str, Any]):\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.CropRegion(MutableMapping[str, Any]):\n    ivar aspect_ratio: float\n    ivar bounding_box: ImageBoundingBox\n\n    @overload\n    def __init__(\n        self, \n        *, \n        aspect_ratio: float, \n        bounding_box: ImageBoundingBox\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nnamespace azure.ai.vision.imageanalysis.models\n\nclass azure.ai.vision.imageanalysis.models.DenseCaption(MutableMapping[str, Any]):\n    ivar bounding_box: ImageBoundingBox\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_box: ImageBoundingBox, \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DenseCaptionsResult(MutableMapping[str, Any]):\n    ivar list: List[DenseCaption]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DenseCaption]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DetectedObject(MutableMapping[str, Any]):\nivar bounding_box: ImageBoundingBox\nivar tags: List[DetectedTag]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_box: ImageBoundingBox, \n    tags: List[DetectedTag]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.detectedPerson(MutableMapping[str, Any]):\nivar bounding_box: ImageBoundingBox\nivar confidence: float\n\n\nclass azure.ai.vision.imageanalysis.models.DetectedTag(MutableMapping[str, Any]):\nivar confidence: float\nivar name: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    name: str\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextBlock(MutableMapping[str, Any]):\n    ivar lines: List[DetectedTextLine]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        lines: List[DetectedTextLine]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextLine(MutableMapping[str, Any]):\n    ivar bounding_polygon: List[ImagePoint]\n    ivar text: str\n    ivar words: List[DetectedTextWord]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_polygon: List[ImagePoint], \n        text: str, \n        words: List[DetectedTextWord]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextWord(MutableMapping[str, Any]):\n    ivar bounding_polygon: List[ImagePoint]\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_polygon: List[ImagePoint], \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImageAnalysisResult(MutableMapping[str, Any]):\n    ivar caption: Optional[CaptionResult]\n    ivar dense_captions: Optional[DenseCaptionsResult]\n    ivar metadata: ImageMetadata\n    ivar model_version: str\n    ivar objects: Optional[ObjectsResult]\n    ivar people: Optional[PeopleResult]\n    ivar read: Optional[ReadResult]\n    ivar smart_crops: Optional[SmartCropsResult]\n    ivar tags: Optional[TagsResult]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        caption: Optional[CaptionResult] = ..., \n        dense_captions: Optional[DenseCaptionsResult] = ..., \n        metadata: ImageMetadata, \n        model_version: str, \n        objects: Optional[ObjectsResult] = ..., \n        people: Optional[PeopleResult] = ..., \n        read: Optional[ReadResult] = ..., \n        smart_crops: Optional[SmartCropsResult] = ..., \n        tags: Optional[TagsResult] = ...\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImageBoundingBox(MutableMapping[str, Any]):\n    ivar height: int\n    ivar width: int\n    ivar x: int\n    ivar y: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        height: int, \n        width: int, \n        x: int, \n        y: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.ImageMetadata(MutableMapping[str, Any]):\n    ivar height: int\n    ivar width: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        height: int, \n        width: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImagePoint(MutableMapping[str, Any]):\n    ivar x: int\n    ivar y: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        x: int, \n        y: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ObjectsResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedObject]\n\n    def get_result(self) -> ObjectsResult\n\n    def set_result(self, obj) -> None\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedObject]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.aio.PeopleResult(MutableMapping[str, Any]):\n    ivar list: List[detectedPerson]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[detectedPerson]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ReadResult(MutableMapping[str, Any]):\n    ivar blocks: List[DetectedTextBlock]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        blocks: List[DetectedTextBlock]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.SmartCropsResult(MutableMapping[str, Any]):\n    ivar list: List[CropRegion]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[CropRegion]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.TagsResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedTag]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedTag]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.VisualFeatures(str, Enum):\n    CAPTION = 'caption'\n    DENSE_CAPTIONS = 'denseCaptions'\n    OBJECTS = 'objects'\n    PEOPLE = 'people'\n    READ = 'read'\n    SMART_CROPS = 'smartCrops'\n    tags = 'tags'", "language": "python", "context": "\nDO use a separate factory classmethod from_connection_string to create a client from a connection string (if the client supports connection strings). The from_connection_string factory method should take the same set of arguments (excluding information provided in the connection string) as the constructor. The constructor (__init__ method) must not take a connection string, even if it means that using the from_connection_string is the only supported method to create an instance of the client.\nDO provide optional operation-specific arguments as keyword only.\nDO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|\nDO accept an optional api_version keyword-only argument of type string on the Client. If specified, the provided api version MUST be used when interacting with the service.\nDO NOT use static methods (staticmethod (https://docs.python.org/3/library/functions.html#staticmethod) . Prefer module level functions instead.\n\nStatic methods are rare and usually forced by other libraries.\nDO use Pascal case for types:\n\n```python\n# Yes:\nclass ThisIsCorrect(object):\n    pass\n\n# No:\nclass this_is_not_correct(object):\n    pass\n\n# No:\nclass camelCasedTypeName(object):\n    pass\n\n```\nDO NOT use simple getter and setter functions. Use properties instead.\n\n```python\n# Yes\nclass GoodThing(object):\n\n    @property\n    def something(self):\n        \"\"\" Example of a good read-only property.\"\"\"\n        return self._something\n\n# No\nclass BadThing(object):\n\n    def get_something(self):\n        \"\"\" Example of a bad 'getter' style method.\"\"\"\n        return self._something\n\n```\nDO NOT duplicate models between the root and aio namespace.\nDO use UPPERCASE for enum member names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-client-connection-string\"], \"line_no\": 10, \"bad_code\": \"connection_string: Optional[str] = None,\", \"suggestion\": \"Remove the connection_string parameter from __init__ and add a separate factory method (e.g. from_connection_string) to create the client.\", \"comment\": \"The __init__ method accepts a connection_string parameter, which violates the guideline that the constructor must not take a connection string.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-optional-arguments-keyword-only\"], \"line_no\": 30, \"bad_code\": \"def analyze_from_url(\", \"suggestion\": \"Insert a '*' after the required parameters to enforce keyword-only optional arguments, e.g.,\\n\\ndef analyze_from_url(self, image_url: str, visual_features: List[VisualFeatures], *, gender_neutral_caption: Optional[bool] = ..., ...):\", \"comment\": \"Optional parameters in analyze_from_url must be keyword-only according to the SDK guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-same-name-sync-async\"], \"line_no\": 53, \"bad_code\": \"class azure.ai.vision.imageanalysis.aio.AsyncImageAnalysisClient(ImageAnalysisClient): implements AsyncContextManager\", \"suggestion\": \"Rename the async client to 'ImageAnalysisClient' so it matches the synchronous client name in the aio package.\", \"comment\": \"The asynchronous client should use the same client name as the synchronous one; having 'AsyncImageAnalysisClient' violates the naming guideline for sync/async clients.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-constructor-api-version-argument-1\"], \"line_no\": 54, \"bad_code\": \"def __init__(\\n        self, \\n        endpoint: str, \\n        credential: Union[AzureKeyCredential, AsyncTokenCredential], \\n    ) -> None\", \"suggestion\": \"Add an optional keyword-only api_version parameter to the async client __init__ signature, for example: \\n    def __init__(self, endpoint: str, credential: Union[AzureKeyCredential, AsyncTokenCredential], *, api_version: str = ..., **kwargs: Any) -> None\", \"comment\": \"The async client constructor is missing the optional api_version parameter required by the guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-static-methods\"], \"line_no\": 88, \"bad_code\": \"@staticmethod\", \"suggestion\": \"Remove the staticmethod decorator and refactor send_request as an instance method or a module-level function.\", \"comment\": \"Static methods are discouraged; module-level functions or instance methods should be used instead.\", \"source\": \"guideline\"}, {\"rule_ids\": [], \"line_no\": 168, \"bad_code\": \"ivar list: List[DenseCaption]\", \"suggestion\": \"Use a less ambiguous attribute name such as 'items' or 'captions' to avoid shadowing the built-in 'list' type.\", \"comment\": \"Naming an attribute 'list' can lead to confusion with Python\\u2019s built-in type. Choosing a more descriptive name improves clarity.\", \"source\": \"generic\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-type-naming\"], \"line_no\": 209, \"bad_code\": \"class azure.ai.vision.imageanalysis.models.detectedPerson(MutableMapping[str, Any]):\", \"suggestion\": \"Rename the class to 'DetectedPerson' using PascalCase.\", \"comment\": \"Type names must be in PascalCase; 'detectedPerson' should be renamed to 'DetectedPerson'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-properties\"], \"line_no\": 411, \"bad_code\": \"def get_result(self) -> ObjectsResult\", \"suggestion\": \"Replace this getter method with a property (e.g. @property def result(self): ...).\", \"comment\": \"Simple getter methods are discouraged; use a property to expose the value instead.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-properties\"], \"line_no\": 413, \"bad_code\": \"def set_result(self, obj) -> None\", \"suggestion\": \"Replace this setter method with a property setter (e.g. @result.setter def result(self, value): ...).\", \"comment\": \"Simple setter methods are discouraged; use a property setter to update the value.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-async\"], \"line_no\": 432, \"bad_code\": \"class azure.ai.vision.imageanalysis.models.aio.PeopleResult(MutableMapping[str, Any]):\", \"suggestion\": \"Move PeopleResult to the common models namespace (azure.ai.vision.imageanalysis.models) instead of duplicating it in the aio sub-namespace.\", \"comment\": \"Models should not be duplicated between the root and aio namespaces.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-name-uppercase\"], \"line_no\": 517, \"bad_code\": \"    tags = 'tags'\", \"suggestion\": \"Change the enum member to uppercase: TAGS = 'tags'\", \"comment\": \"Enum member names must be in UPPERCASE; 'tags' should be renamed to 'TAGS'.\", \"source\": \"guideline\"}]}"}
{"testcase": "small_apiview_no_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.14), Python version: 3.12.9\n\nnamespace azure.ai.vision.imageanalysis\n\nclass azure.ai.vision.imageanalysis.ImageAnalysisClient(ImageAnalysisClient): implements ContextManager \n    def __init__(\n        self, \n        endpoint: str, \n        credential: Union[AzureKeyCredential, TokenCredential], \n        *, \n        api_version: str = ..., \n        **kwargs: Any\n    ) -> None\n\n    @distributed_trace\n    def analyze(\n        self, \n        image_data: bytes, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    @distributed_trace\n    def analyze_from_url(\n        self, \n        image_url: str, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    def close(self) -> None\n\n    def send_request(\n        self, \n        request: HttpRequest, \n        *, \n        stream: bool = False, \n        **kwargs: Any\n    ) -> HttpResponse\n\nnamespace azure.ai.vision.imageanalysis.aio\n\nclass azure.ai.vision.imageanalysis.aio.ImageAnalysisClient(ImageAnalysisClient): implements AsyncContextManager \n    def __init__(\n        self, \n        endpoint: str, \n        credential: Union[AzureKeyCredential, AsyncTokenCredential], \n        *, \n        api_version: str = ..., \n        **kwargs: Any\n    ) -> None\n\n    @distributed_trace_async\n    async def analyze(\n        self, \n        image_data: bytes, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    @distributed_trace_async\n    async def analyze_from_url(\n        self, \n        image_url: str, \n        visual_features: List[VisualFeatures], \n        *, \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    async def close(self) -> None\n\n    def send_request(\n        self, \n        request: HttpRequest, \n        *, \n        stream: bool = False, \n        **kwargs: Any\n    ) -> Awaitable[AsyncHttpResponse]\n\nnamespace azure.ai.vision.imageanalysis.models\n\nclass azure.ai.vision.imageanalysis.models.CaptionResult(MutableMapping[str, Any]):\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.CropRegion(MutableMapping[str, Any]):\n    ivar aspect_ratio: float\n    ivar bounding_box: ImageBoundingBox\n\n    @overload\n    def __init__(\n        self, \n        *, \n        aspect_ratio: float, \n        bounding_box: ImageBoundingBox\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nnamespace azure.ai.vision.imageanalysis.models\n\nclass azure.ai.vision.imageanalysis.models.DenseCaption(MutableMapping[str, Any]):\n    ivar bounding_box: ImageBoundingBox\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_box: ImageBoundingBox, \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DenseCaptionsResult(MutableMapping[str, Any]):\n    ivar list: List[DenseCaption]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DenseCaption]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextBlock(MutableMapping[str, Any]):\n    ivar lines: List[DetectedTextLine]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        lines: List[DetectedTextLine]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextLine(MutableMapping[str, Any]):\n    ivar bounding_polygon: List[ImagePoint]\n    ivar text: str\n    ivar words: List[DetectedTextWord]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_polygon: List[ImagePoint], \n        text: str, \n        words: List[DetectedTextWord]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextWord(MutableMapping[str, Any]):\n    ivar bounding_polygon: List[ImagePoint]\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_polygon: List[ImagePoint], \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImageAnalysisResult(MutableMapping[str, Any]):\n    ivar caption: Optional[CaptionResult]\n    ivar dense_captions: Optional[DenseCaptionsResult]\n    ivar metadata: ImageMetadata\n    ivar model_version: str\n    ivar objects: Optional[ObjectsResult]\n    ivar people: Optional[PeopleResult]\n    ivar read: Optional[ReadResult]\n    ivar smart_crops: Optional[SmartCropsResult]\n    ivar tags: Optional[TagsResult]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        caption: Optional[CaptionResult] = ..., \n        dense_captions: Optional[DenseCaptionsResult] = ..., \n        metadata: ImageMetadata, \n        model_version: str, \n        objects: Optional[ObjectsResult] = ..., \n        people: Optional[PeopleResult] = ..., \n        read: Optional[ReadResult] = ..., \n        smart_crops: Optional[SmartCropsResult] = ..., \n        tags: Optional[TagsResult] = ...\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImageBoundingBox(MutableMapping[str, Any]):\n    ivar height: int\n    ivar width: int\n    ivar x: int\n    ivar y: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        height: int, \n        width: int, \n        x: int, \n        y: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.ImageMetadata(MutableMapping[str, Any]):\n    ivar height: int\n    ivar width: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        height: int, \n        width: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImagePoint(MutableMapping[str, Any]):\n    ivar x: int\n    ivar y: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        x: int, \n        y: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ObjectsResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedObject]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedObject]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.PeopleResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedPerson]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedPerson]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ReadResult(MutableMapping[str, Any]):\n    ivar blocks: List[DetectedTextBlock]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        blocks: List[DetectedTextBlock]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.SmartCropsResult(MutableMapping[str, Any]):\n    ivar list: List[CropRegion]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[CropRegion]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.TagsResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedTag]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedTag]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.VisualFeatures(str, Enum):\n    CAPTION = 'caption'\n    DENSE_CAPTIONS = 'denseCaptions'\n    OBJECTS = 'objects'\n    PEOPLE = 'people'\n    READ = 'read'\n    SMART_CROPS = 'smartCrops'\n    TAGS = 'tags'", "language": "python", "context": "", "response": "{\"comments\": []}"}
{"testcase": "small_apiview_multiple_same_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.14), Python version: 3.12.9\n\nnamespace azure.ai.vision.imageanalysis\n\nclass azure.ai.vision.imageanalysis.ImageAnalysisClient(ImageAnalysisClient): implements ContextManager \n    def __init__(\n        self, \n        endpoint: str, \n        credential: Union[AzureKeyCredential, TokenCredential], \n        *, \n        api_version: str = ..., \n        **kwargs: Any\n    ) -> None\n\n    @distributed_trace\n    def analyze(\n        self, \n        image_data: bytes, \n        visual_features: List[VisualFeatures], \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    @distributed_trace\n    def analyze_from_url(\n        self, \n        image_url: str, \n        visual_features: List[VisualFeatures], \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    def close(self) -> None\n\n    def send_request(\n        self, \n        request: HttpRequest, \n        *, \n        stream: bool = False, \n        **kwargs: Any\n    ) -> HttpResponse\n\nnamespace azure.ai.vision.imageanalysis.aio\n\nclass azure.ai.vision.imageanalysis.aio.ImageAnalysisClient(ImageAnalysisClient): implements AsyncContextManager \n    def __init__(\n        self, \n        endpoint: str, \n        credential: Union[AzureKeyCredential, AsyncTokenCredential], \n        *, \n        api_version: str = ..., \n        **kwargs: Any\n    ) -> None\n\n    @distributed_trace_async\n    async def analyze(\n        self, \n        image_data: bytes, \n        visual_features: List[VisualFeatures], \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    @distributed_trace_async\n    async def analyze_from_url(\n        self, \n        image_url: str, \n        visual_features: List[VisualFeatures], \n        gender_neutral_caption: Optional[bool] = ..., \n        language: Optional[str] = ..., \n        model_version: Optional[str] = ..., \n        smart_crops_aspect_ratios: Optional[List[float]] = ..., \n        **kwargs: Any\n    ) -> ImageAnalysisResult\n\n    async def close(self) -> None\n\n    def send_request(\n        self, \n        request: HttpRequest, \n        *, \n        stream: bool = False, \n        **kwargs: Any\n    ) -> Awaitable[AsyncHttpResponse]\n\nnamespace azure.ai.vision.imageanalysis.models\n\nclass azure.ai.vision.imageanalysis.models.CaptionResult(MutableMapping[str, Any]):\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.CropRegion(MutableMapping[str, Any]):\n    ivar aspect_ratio: float\n    ivar bounding_box: ImageBoundingBox\n\n    @overload\n    def __init__(\n        self, \n        *, \n        aspect_ratio: float, \n        bounding_box: ImageBoundingBox\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nnamespace azure.ai.vision.imageanalysis.models\n\nclass azure.ai.vision.imageanalysis.models.DenseCaption(MutableMapping[str, Any]):\n    ivar bounding_box: ImageBoundingBox\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_box: ImageBoundingBox, \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DenseCaptionsResult(MutableMapping[str, Any]):\n    ivar list: List[DenseCaption]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DenseCaption]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextBlock(MutableMapping[str, Any]):\n    ivar lines: List[DetectedTextLine]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        lines: List[DetectedTextLine]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextLine(MutableMapping[str, Any]):\n    ivar bounding_polygon: List[ImagePoint]\n    ivar text: str\n    ivar words: List[DetectedTextWord]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_polygon: List[ImagePoint], \n        text: str, \n        words: List[DetectedTextWord]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.DetectedTextWord(MutableMapping[str, Any]):\n    ivar bounding_polygon: List[ImagePoint]\n    ivar confidence: float\n    ivar text: str\n\n    @overload\n    def __init__(\n        self, \n        *, \n        bounding_polygon: List[ImagePoint], \n        confidence: float, \n        text: str\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImageAnalysisResult(MutableMapping[str, Any]):\n    ivar caption: Optional[CaptionResult]\n    ivar dense_captions: Optional[DenseCaptionsResult]\n    ivar metadata: ImageMetadata\n    ivar model_version: str\n    ivar objects: Optional[ObjectsResult]\n    ivar people: Optional[PeopleResult]\n    ivar read: Optional[ReadResult]\n    ivar smart_crops: Optional[SmartCropsResult]\n    ivar tags: Optional[TagsResult]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        caption: Optional[CaptionResult] = ..., \n        dense_captions: Optional[DenseCaptionsResult] = ..., \n        metadata: ImageMetadata, \n        model_version: str, \n        objects: Optional[ObjectsResult] = ..., \n        people: Optional[PeopleResult] = ..., \n        read: Optional[ReadResult] = ..., \n        smart_crops: Optional[SmartCropsResult] = ..., \n        tags: Optional[TagsResult] = ...\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImageBoundingBox(MutableMapping[str, Any]):\n    ivar height: int\n    ivar width: int\n    ivar x: int\n    ivar y: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        height: int, \n        width: int, \n        x: int, \n        y: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.ImageMetadata(MutableMapping[str, Any]):\n    ivar height: int\n    ivar width: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        height: int, \n        width: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ImagePoint(MutableMapping[str, Any]):\n    ivar x: int\n    ivar y: int\n\n    @overload\n    def __init__(\n        self, \n        *, \n        x: int, \n        y: int\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ObjectsResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedObject]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedObject]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.PeopleResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedPerson]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedPerson]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.ReadResult(MutableMapping[str, Any]):\n    ivar blocks: List[DetectedTextBlock]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        blocks: List[DetectedTextBlock]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\n\nclass azure.ai.vision.imageanalysis.models.SmartCropsResult(MutableMapping[str, Any]):\n    ivar list: List[CropRegion]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[CropRegion]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.TagsResult(MutableMapping[str, Any]):\n    ivar list: List[DetectedTag]\n\n    @overload\n    def __init__(\n        self, \n        *, \n        list: List[DetectedTag]\n    )\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any])\n\n    def __init__(\n        self, \n        *args: Any, \n        **kwargs: Any\n    ) -> None\n\nclass azure.ai.vision.imageanalysis.models.VisualFeatures(str, Enum):\n    CAPTION = \"caption\"\n    DENSE_CAPTIONS = \"denseCaptions\"\n    OBJECTS = \"objects\"\n    PEOPLE = \"people\"\n    READ = \"read\"\n    SMART_CROPS = \"smartCrops\"\n    TAGS = \"tags\"", "language": "python", "context": "\nDO provide optional operation-specific arguments as keyword only.", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-client-optional-arguments-keyword-only\"], \"line_no\": 16, \"bad_code\": \"def analyze(\", \"suggestion\": \"def analyze(self, image_data: bytes, visual_features: List[VisualFeatures], *, gender_neutral_caption: Optional[bool] = ..., language: Optional[str] = ..., model_version: Optional[str] = ..., smart_crops_aspect_ratios: Optional[List[float]] = ..., **kwargs: Any) -> ImageAnalysisResult\", \"comment\": \"Optional parameters in the 'analyze' method should be keyword-only. Insert a '*' after the required parameters so that all optional parameters must be specified by name.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-optional-arguments-keyword-only\"], \"line_no\": 28, \"bad_code\": \"def analyze_from_url(\", \"suggestion\": \"def analyze_from_url(self, image_url: str, visual_features: List[VisualFeatures], *, gender_neutral_caption: Optional[bool] = ..., language: Optional[str] = ..., model_version: Optional[str] = ..., smart_crops_aspect_ratios: Optional[List[float]] = ..., **kwargs: Any) -> ImageAnalysisResult\", \"comment\": \"Optional parameters in the 'analyze_from_url' method should be keyword-only. Adding a '*' after the required parameters will enforce this design guideline.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-optional-arguments-keyword-only\"], \"line_no\": 62, \"bad_code\": \"async def analyze(self, image_data: bytes, visual_features: List[VisualFeatures], gender_neutral_caption: Optional[bool] = ..., language: Optional[str] = ..., model_version: Optional[str] = ..., smart_crops_aspect_ratios: Optional[List[float]] = ..., **kwargs: Any) -> ImageAnalysisResult\", \"suggestion\": \"async def analyze(self, image_data: bytes, visual_features: List[VisualFeatures], *, gender_neutral_caption: Optional[bool] = ..., language: Optional[str] = ..., model_version: Optional[str] = ..., smart_crops_aspect_ratios: Optional[List[float]] = ..., **kwargs: Any) -> ImageAnalysisResult\", \"comment\": \"For async methods, optional parameters must also be keyword-only. Insert '*' to force keyword-only usage.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-optional-arguments-keyword-only\"], \"line_no\": 74, \"bad_code\": \"async def analyze_from_url(self, image_url: str, visual_features: List[VisualFeatures], gender_neutral_caption: Optional[bool] = ..., language: Optional[str] = ..., model_version: Optional[str] = ..., smart_crops_aspect_ratios: Optional[List[float]] = ..., **kwargs: Any) -> ImageAnalysisResult\", \"suggestion\": \"async def analyze_from_url(self, image_url: str, visual_features: List[VisualFeatures], *, gender_neutral_caption: Optional[bool] = ..., language: Optional[str] = ..., model_version: Optional[str] = ..., smart_crops_aspect_ratios: Optional[List[float]] = ..., **kwargs: Any) -> ImageAnalysisResult\", \"comment\": \"Optional parameters should be made keyword-only by inserting '*' after the required parameters.\", \"source\": \"guideline\"}, {\"rule_ids\": [], \"line_no\": 166, \"bad_code\": \"ivar list: List[DenseCaption]\", \"suggestion\": \"ivar captions: List[DenseCaption]\", \"comment\": \"Using 'list' as an attribute name shadows the built-in list type in Python. Renaming this attribute to something more descriptive (like 'captions' or 'dense_captions') will avoid potential conflicts and improve code clarity.\", \"source\": \"generic\"}]}"}
{"testcase": "medium_apiview_few_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.16), Python version: 3.10.16\n\n\nnamespace azure.healthinsights.clinicalmatching\n\nclass azure.healthinsights.clinicalmatching.ClinicalMatchingClient(ClinicalMatchingClientOperationsMixin): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: AzureKeyCredential, \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_match_trials(\n    self, \n    body: TrialMatcherData, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef begin_match_trials(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef begin_match_trials(\n    self, \n    body: IO, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@distributed_trace\ndef begin_match_trials(\n    self, \n    body: Union[TrialMatcherData, JSON, IO], \n    *, \n    content_type: str = ..., \n    continuation_token: Optional[str] = ..., \n    polling: Union[bool, PollingMethod] = ..., \n    polling_interval: Optional[int] = ..., \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\ndef close(self) -> None\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: Optional[bool] = ..., \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.healthinsights.clinicalmatching\n\nclass azure.healthinsights.clinicalmatching.ClinicalMatchingAsyncClient(ClinicalMatchingClientOperationsMixin): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: AzureKeyCredential, \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_match_trials(\n    self, \n    body, \n    *, \n    content_type, \n    repeatability_first_sent, \n    repeatability_request_id, \n    **kwargs\n)\n\n@overload\nasync def begin_match_trials(\n    self, \n    body, \n    *, \n    content_type, \n    repeatability_first_sent, \n    repeatability_request_id, \n    **kwargs\n)\n\n@overload\nasync def begin_match_trials(\n    self, \n    body, \n    *, \n    content_type, \n    repeatability_first_sent, \n    repeatability_request_id, \n    **kwargs\n)\n\n@distributed_trace_async\nasync def begin_match_trials(\n    self, \n    body,\n    *, \n    content_type, \n    continuation_token, \n    polling, \n    polling_interval, \n    repeatability_first_sent, \n    repeatability_request_id, \n    **kwargs\n)\n\nasync def close(self) -> None\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: Optional[bool] = ..., \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\nclass azure.healthinsights.clinicalmatching.HealthInsightsKeyCredential:\ndef __init__(\n    self, \n    api_key: str\n) -> None\n\nnamespace azure.healthinsights.clinicalmatching.models\n\nclass azure.healthinsights.clinicalmatching.models.AcceptedAge(MutableMapping[str, Any]):\nivar unit: Union[str, AgeUnit]\nivar value: float\n\n@overload\ndef __init__(\n    self, \n    *, \n    unit: Union[str, AgeUnit], \n    value: float\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AcceptedAgeRange(MutableMapping[str, Any]):\nivar maximum_age: Optional[AcceptedAge]\nivar minimum_age: Optional[AcceptedAge]\n\n@overload\ndef __init__(\n    self, \n    *, \n    maximum_age: Optional[AcceptedAge] = ..., \n    minimum_age: Optional[AcceptedAge] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AgeUnit(str, Enum):\nDAYS = \"days\"\nMONTHS = \"months\"\nYEARS = \"years\"\n\n\nclass azure.healthinsights.clinicalmatching.models.AreaGeometry(MutableMapping[str, Any]):\nivar coordinates: List[float]\nivar type: Union[str, GeoJsonGeometryType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    coordinates: List[float], \n    type: Union[str, GeoJsonGeometryType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AreaProperties(MutableMapping[str, Any]):\nivar radius: float\nivar sub_type: Union[str, GeoJsonPropertiesSubType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    radius: float, \n    sub_type: Union[str, GeoJsonPropertiesSubType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalCodedElement(MutableMapping[str, Any]):\nivar code: str\nivar name: Optional[str]\nivar system: str\nivar value: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    name: Optional[str] = ..., \n    system: str, \n    value: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalDocumentType(str, Enum):\nCONSULTATION = \"consultation\"\nDISCHARGE_SUMMARY = \"dischargeSummary\"\nHISTORY_AND_PHYSICAL = \"historyAndPhysical\"\nIMAGING = \"imaging\"\nLABORATORY = \"laboratory\"\nPATHOLOGY = \"pathology\"\nPROCEDURE = \"procedure\"\nPROGRESS = \"progress\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalNoteEvidence(MutableMapping[str, Any]):\nivar id: str\nivar length: int\nivar offset: int\nivar text: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    id: str, \n    length: int, \n    offset: int, \n    text: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialAcceptedSex(str, Enum):\nALL = \"all\"\nFEMALE = \"female\"\nMALE = \"male\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialDemographics(MutableMapping[str, Any]):\nivar accepted_age_range: Optional[AcceptedAgeRange]\nivar accepted_sex: Optional[Union[str, ClinicalTrialAcceptedSex]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    accepted_age_range: Optional[AcceptedAgeRange] = ..., \n    accepted_sex: Optional[Union[str, ClinicalTrialAcceptedSex]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialDetails(MutableMapping[str, Any]):\nivar demographics: Optional[ClinicalTrialDemographics]\nivar eligibility_criteria_text: Optional[str]\nivar id: str\nivar metadata: ClinicalTrialMetadata\n\n@overload\ndef __init__(\n    self, \n    *, \n    demographics: Optional[ClinicalTrialDemographics] = ..., \n    eligibility_criteria_text: Optional[str] = ..., \n    id: str, \n    metadata: ClinicalTrialMetadata\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialMetadata(MutableMapping[str, Any]):\nivar conditions: List[str]\nivar contacts: Optional[List[ForwardRef('ContactDetails')]]\nivar facilities: Optional[List[ForwardRef('ClinicalTrialResearchFacility')]]\nivar phases: Optional[List[Union[str, ForwardRef('ClinicalTrialPhase')]]]\nivar recruitment_status: Optional[Union[str, ClinicalTrialRecruitmentStatus]]\nivar sponsors: Optional[List[str]]\nivar study_type: Optional[Union[str, ClinicalTrialStudyType]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    conditions: List[str], \n    contacts: Optional[List[ContactDetails]] = ..., \n    facilities: Optional[List[ClinicalTrialResearchFacility]] = ..., \n    phases: Optional[List[Union[str, ClinicalTrialPhase]]] = ..., \n    recruitment_status: Optional[Union[str, ClinicalTrialRecruitmentStatus]] = ..., \n    sponsors: Optional[List[str]] = ..., \n    study_type: Optional[Union[str, ClinicalTrialStudyType]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialPhase(str, Enum):\nEARLY_PHASE1 = \"earlyPhase1\"\nNOT_APPLICABLE = \"notApplicable\"\nPHASE1 = \"phase1\"\nPHASE2 = \"phase2\"\nPHASE3 = \"phase3\"\nPHASE4 = \"phase4\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialPurpose(str, Enum):\nBASIC_SCIENCE = \"basicScience\"\nDEVICE_FEASIBILITY = \"deviceFeasibility\"\nDIAGNOSTIC = \"diagnostic\"\nHEALTH_SERVICES_RESEARCH = \"healthServicesResearch\"\nNOT_APPLICABLE = \"notApplicable\"\nOTHER = \"other\"\nPREVENTION = \"prevention\"\nSCREENING = \"screening\"\nSUPPORTIVE_CARE = \"supportiveCare\"\nTREATMENT = \"treatment\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialRecruitmentStatus(str, Enum):\nENROLLING_BY_INVITATION = \"enrollingByInvitation\"\nNOT_YET_RECRUITING = \"notYetRecruiting\"\nRECRUITING = \"recruiting\"\nUNKNOWN_STATUS = \"unknownStatus\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialRegistryFilter(MutableMapping[str, Any]):\nivar conditions: Optional[List[str]]\nivar facility_areas: Optional[List[ForwardRef('GeographicArea')]]\nivar facility_locations: Optional[List[ForwardRef('GeographicLocation')]]\nivar facility_names: Optional[List[str]]\nivar ids: Optional[List[str]]\nivar phases: Optional[List[Union[str, ForwardRef('ClinicalTrialPhase')]]]\nivar purposes: Optional[List[Union[str, ForwardRef('ClinicalTrialPurpose')]]]\nivar recruitment_statuses: Optional[List[Union[str, ForwardRef('ClinicalTrialRecruitmentStatus')]]]\nivar sources: Optional[List[Union[str, ForwardRef('ClinicalTrialSource')]]]\nivar sponsors: Optional[List[str]]\nivar study_types: Optional[List[Union[str, ForwardRef('ClinicalTrialStudyType')]]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    conditions: Optional[List[str]] = ..., \n    facility_areas: Optional[List[GeographicArea]] = ..., \n    facility_locations: Optional[List[GeographicLocation]] = ..., \n    facility_names: Optional[List[str]] = ..., \n    ids: Optional[List[str]] = ..., \n    phases: Optional[List[Union[str, ClinicalTrialPhase]]] = ..., \n    purposes: Optional[List[Union[str, ClinicalTrialPurpose]]] = ..., \n    recruitment_statuses: Optional[List[Union[str, ClinicalTrialRecruitmentStatus]]] = ..., \n    sources: Optional[List[Union[str, ClinicalTrialSource]]] = ..., \n    sponsors: Optional[List[str]] = ..., \n    study_types: Optional[List[Union[str, ClinicalTrialStudyType]]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialResearchFacility(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar country_or_region: str\nivar name: str\nivar state: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    country_or_region: str, \n    name: str, \n    state: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialSource(str, Enum):\nCLINICALTRIALS_GOV = \"clinicaltrials.gov\"\nCUSTOM = \"custom\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialStudyType(str, Enum):\nEXPANDED_ACCESS = \"expandedAccess\"\nINTERVENTIONAL = \"interventional\"\nOBSERVATIONAL = \"observational\"\nPATIENT_REGISTRIES = \"patientRegistries\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrials(MutableMapping[str, Any]):\nivar custom_trials: Optional[List[ForwardRef('ClinicalTrialDetails')]]\nivar registry_filters: Optional[List[ForwardRef('ClinicalTrialRegistryFilter')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_trials: Optional[List[ClinicalTrialDetails]] = ..., \n    registry_filters: Optional[List[ClinicalTrialRegistryFilter]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ContactDetails(MutableMapping[str, Any]):\nivar email: Optional[str]\nivar name: Optional[str]\nivar phone: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    email: Optional[str] = ..., \n    name: Optional[str] = ..., \n    phone: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentContent(MutableMapping[str, Any]):\nivar source_type: Union[str, DocumentContentSourceType]\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    source_type: Union[str, DocumentContentSourceType], \n    value: str\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentContentSourceType(str, Enum):\nINLINE = \"inline\"\nREFERENCE = \"reference\"\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentType(str, Enum):\nDICOM = \"dicom\"\nFHIR_BUNDLE = \"fhirBundle\"\nGENOMIC_SEQUENCING = \"genomicSequencing\"\nNOTE = \"note\"\n\n\nclass azure.healthinsights.clinicalmatching.models.Error(MutableMapping[str, Any]):\nivar code: str\nivar details: List[Error]\nivar innererror: Optional[InnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: List[Error], \n    innererror: Optional[InnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ExtendedClinicalCodedElement(MutableMapping[str, Any]):\nivar category: Optional[str]\nivar code: str\nivar name: Optional[str]\nivar semantic_type: Optional[str]\nivar system: str\nivar value: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    category: Optional[str] = ..., \n    code: str, \n    name: Optional[str] = ..., \n    semantic_type: Optional[str] = ..., \n    system: str, \n    value: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonGeometryType(str, Enum):\nPOINT = \"Point\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonPropertiesSubType(str, Enum):\nCIRCLE = \"Circle\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonType(str, Enum):\nFEATURE = \"Feature\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeographicArea(MutableMapping[str, Any]):\nivar geometry: AreaGeometry\nivar properties: AreaProperties\nivar type: Union[str, GeoJsonType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    geometry: AreaGeometry, \n    properties: AreaProperties, \n    type: Union[str, GeoJsonType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.GeographicLocation(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar country_or_region: str\nivar state: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    country_or_region: str, \n    state: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.InnerError(MutableMapping[str, Any]):\nivar code: str\nivar innererror: Optional[InnerError]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    innererror: Optional[InnerError] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.JobStatus(str, Enum):\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nPARTIALLY_COMPLETED = \"partiallyCompleted\"\nRUNNING = \"running\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientDocument(MutableMapping[str, Any]):\nivar clinical_type: Optional[Union[str, ClinicalDocumentType]]\nivar content: DocumentContent\nivar created_date_time: Optional[datetime]\nivar id: str\nivar language: Optional[str]\nivar type: Union[str, DocumentType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    clinical_type: Optional[Union[str, ClinicalDocumentType]] = ..., \n    content: DocumentContent, \n    created_date_time: Optional[datetime] = ..., \n    id: str, \n    language: Optional[str] = ..., \n    type: Union[str, DocumentType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientInfo(MutableMapping[str, Any]):\nivar birth_date: Optional[date]\nivar clinical_info: Optional[List[ForwardRef('ClinicalCodedElement')]]\nivar sex: Optional[Union[str, PatientInfoSex]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    birth_date: Optional[date] = ..., \n    clinical_info: Optional[List[ClinicalCodedElement]] = ..., \n    sex: Optional[Union[str, PatientInfoSex]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientInfoSex(str, Enum):\nFEMALE = \"female\"\nMALE = \"male\"\nUNSPECIFIED = \"unspecified\"\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientRecord(MutableMapping[str, Any]):\nivar data: Optional[List[ForwardRef('PatientDocument')]]\nivar id: str\nivar info: Optional[PatientInfo]\n\n@overload\ndef __init__(\n    self, \n    *, \n    data: Optional[List[PatientDocument]] = ..., \n    id: str, \n    info: Optional[PatientInfo] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.RepeatabilityResultType(str, Enum):\nACCEPTED = \"accepted\"\nREJECTED = \"rejected\"\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherData(MutableMapping[str, Any]):\nivar configuration: Optional[TrialMatcherModelConfiguration]\nivar patients: List[PatientRecord]\n\n@overload\ndef __init__(\n    self, \n    *, \n    configuration: Optional[TrialMatcherModelConfiguration] = ..., \n    patients: List[PatientRecord]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInference(MutableMapping[str, Any]):\nivar confidence_score: Optional[float]\nivar description: Optional[str]\nivar evidence: Optional[List[ForwardRef('TrialMatcherInferenceEvidence')]]\nivar id: Optional[str]\nivar metadata: Optional[ClinicalTrialMetadata]\nivar source: Optional[Union[str, ClinicalTrialSource]]\nivar type: Union[str, TrialMatcherInferenceType]\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence_score: Optional[float] = ..., \n    description: Optional[str] = ..., \n    evidence: Optional[List[TrialMatcherInferenceEvidence]] = ..., \n    id: Optional[str] = ..., \n    metadata: Optional[ClinicalTrialMetadata] = ..., \n    source: Optional[Union[str, ClinicalTrialSource]] = ..., \n    type: Union[str, TrialMatcherInferenceType], \n    value: str\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInferenceEvidence(MutableMapping[str, Any]):\nivar eligibility_criteria_evidence: Optional[str]\nivar importance: Optional[float]\nivar patient_data_evidence: Optional[ClinicalNoteEvidence]\nivar patient_info_evidence: Optional[ClinicalCodedElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    eligibility_criteria_evidence: Optional[str] = ..., \n    importance: Optional[float] = ..., \n    patient_data_evidence: Optional[ClinicalNoteEvidence] = ..., \n    patient_info_evidence: Optional[ClinicalCodedElement] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInferenceType(str, Enum):\nTRIAL_ELIGIBILITY = \"trialEligibility\"\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherModelConfiguration(MutableMapping[str, Any]):\nivar clinical_trials: ClinicalTrials\nivar include_evidence: bool\nivar verbose: bool\n\n@overload\ndef __init__(\n    self, \n    *, \n    clinical_trials: ClinicalTrials, \n    include_evidence: bool = True, \n    verbose: bool = False\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherPatientResult(MutableMapping[str, Any]):\nivar id: str\nivar inferences: List[TrialMatcherInference]\nivar needed_clinical_info: Optional[List[ForwardRef('ExtendedClinicalCodedElement')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    id: str, \n    inferences: List[TrialMatcherInference], \n    needed_clinical_info: Optional[List[ExtendedClinicalCodedElement]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherResult(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar errors: Optional[List[ForwardRef('Error')]]\nivar expiration_date_time: datetime\nivar job_id: str\nivar last_update_date_time: datetime\nivar results: Optional[TrialMatcherResults]\nivar status: Union[str, JobStatus]\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherResults(MutableMapping[str, Any]):\nivar knowledge_graph_last_update_date: Optional[date]\nivar model_version: str\nivar patients: List[TrialMatcherPatientResult]\n\n@overload\ndef __init__(\n    self, \n    *, \n    knowledge_graph_last_update_date: Optional[date] = ..., \n    model_version: str, \n    patients: List[TrialMatcherPatientResult]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n", "language": "python", "context": "\nDO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|\nDO provide type hints PEP484 (https://www.python.org/dev/peps/pep-0484/) for publicly documented classes and functions", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-client-same-name-sync-async\"], \"line_no\": 78, \"bad_code\": \"class azure.healthinsights.clinicalmatching.ClinicalMatchingAsyncClient(ClinicalMatchingClientOperationsMixin): implements AsyncContextManager\", \"suggestion\": \"Place the async client in an '.aio' subpackage and name it identically to the sync client (i.e. ClinicalMatchingClient). For example:\\n\\n# In module azure.healthinsights.clinicalmatching.aio\\nclass ClinicalMatchingClient(ClinicalMatchingClientOperationsMixin):\\n    async def begin_match_trials(...): ...\\n    async def close(...): ...\", \"comment\": \"The async client does not follow the naming and namespace conventions. According to the guidelines (python_design.html#python-client-same-name-sync-async and python_design.html#python-client-namespace-async), the async client should have the same name as its synchronous counterpart and reside in an '.aio' namespace.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-pep484\"], \"line_no\": 91, \"bad_code\": \"async def begin_match_trials(\", \"suggestion\": \"async def begin_match_trials(self, body: Union[TrialMatcherData, JSON, IO], *, content_type: str = \\\"application/json\\\", repeatability_first_sent: Optional[datetime] = None, repeatability_request_id: Optional[str] = None, **kwargs: Any) -> LROPoller[TrialMatcherResult]:\", \"comment\": \"Public asynchronous methods must include full PEP484 type annotations. The async overloads for 'begin_match_trials' are missing explicit type hints.\", \"source\": \"guideline\"}, {\"rule_ids\": [], \"line_no\": 368, \"bad_code\": \"contacts: Optional[List[ForwardRef('ContactDetails')]]\", \"suggestion\": \"Add 'from __future__ import annotations' at the top of the module to simplify forward references in type hints.\", \"comment\": \"$Explicit use of ForwardRef can be avoided in Python 3.10+ using postponed evaluation of annotations. This change can improve readability and reduce boilerplate in type annotations. (general comment)\", \"source\": \"generic\"}]}"}
{"testcase": "medium_apiview_many_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.16), Python version: 3.10.16\n\n\nnamespace azure.healthinsights.clinicalmatching\n\nclass azure.healthinsights.clinicalmatching.ClinicalMatching(ClinicalMatchingClientOperationsMixin): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    api_key: str, \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_match_trials(\n    self, \n    body: TrialMatcherData, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef begin_match_trials(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef begin_match_trials(\n    self, \n    body: IO, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@distributed_trace\ndef begin_match_trials(\n    self, \n    body: Union[TrialMatcherData, JSON, IO], \n    *, \n    content_type: str = ..., \n    continuation_token: Optional[str] = ..., \n    polling: Union[bool, PollingMethod] = ..., \n    polling_interval: Optional[int] = ..., \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef create_trials(\n    self, \n    body: TrialMatcherData, \n    *, \n    options: Optional[CreateTrialsOptions] = None,\n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef create_trials(\n    self, \n    body: JSON, \n    *, \n    options: Optional[CreateTrialsOptions] = None,\n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef create_trials(\n    self, \n    body: IO, \n    *, \n    options: Optional[CreateTrialsOptions] = None,\n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@distributed_trace\ndef create_trials(\n    self, \n    body: Union[TrialMatcherData, JSON, IO], \n    *, \n    options: Optional[CreateTrialsOptions] = None,\n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@distributed_trace\ndef trials(\n    self, \n    **kwargs: Any\n) -> List[TrialMatcherResult]\n\n@distributed_trace\ndef erase_trials(\n    self, \n                trial: str,\n    **kwargs: Any\n) -> None\n\ndef close(self) -> None\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: Optional[bool] = ..., \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.healthinsights.clinicalmatching.aio\n\nclass azure.healthinsights.clinicalmatching.aio.ClinicalMatchingClient(ClinicalMatchingClientOperationsMixin): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    api_key: str, \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_match_trials(\n    self, \n    body: TrialMatcherData, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@overload\nasync def begin_match_trials(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@overload\nasync def begin_match_trials(\n    self, \n    body: IO, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@distributed_trace_async\nasync def begin_match_trials(\n    self, \n    body: Union[TrialMatcherData, JSON, IO], \n    *, \n    content_type: str = ..., \n    continuation_token: Optional[str] = ..., \n    polling: Union[bool, AsyncPollingMethod] = ..., \n    polling_interval: Optional[int] = ..., \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@overload\nasync def create_trials(\n    self, \n    body: TrialMatcherData, \n    *, \n    options: Optional[CreateTrialsOptions] = None,\n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@overload\nasync def create_trials(\n    self, \n    body: JSON, \n    *, \n    options: Optional[CreateTrialsOptions] = None,\n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@overload\nasync def create_trials(\n    self, \n    body: IO, \n    *, \n    options: Optional[CreateTrialsOptions] = None,\n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@distributed_trace_async\nasync def create_trials(\n    self, \n    body: Union[TrialMatcherData, JSON, IO], \n    *, \n    options: Optional[CreateTrialsOptions] = None,\n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@distributed_trace\ndef trials(\n    self, \n    **kwargs: Any\n) -> List[TrialMatcherResult]\n\n@distributed_trace_async\nasync def erase_trials(\n    self, \n                trial: str,\n    **kwargs: Any\n) -> None\n\nasync def close(self) -> None\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: Optional[bool] = ..., \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.healthinsights.clinicalmatching.models\n\nclass azure.healthinsights.clinicalmatching.models.CreateTrialsOptions(MutableMapping[str, Any]):\nivar unit: Optional[Union[str, AgeUnit]]\nivar value: Optional[float]\n        ivar language: Optional[str]\n        ivar date: Optional[datetime.datetime]\n\n@overload\ndef __init__(\n    self, \n    *, \n    unit: Optional[Union[str, AgeUnit]], \n    value: Optional[float],\n                language: Optional[str],\n                date: Optional[datetime.datetime]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AcceptedAge(MutableMapping[str, Any]):\nivar unit: Union[str, AgeUnit]\nivar value: float\n\n@overload\ndef __init__(\n    self, \n    *, \n    unit: Union[str, AgeUnit], \n    value: float\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AcceptedAgeRange(MutableMapping[str, Any]):\nivar maximum_age: Optional[AcceptedAge]\nivar minimum_age: Optional[AcceptedAge]\n\n@overload\ndef __init__(\n    self, \n    *, \n    maximum_age: Optional[AcceptedAge] = ..., \n    minimum_age: Optional[AcceptedAge] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AgeUnit(str, Enum):\nDAYS = \"days\"\nMONTHS = \"months\"\nYEARS = \"years\"\n\n\nclass azure.healthinsights.clinicalmatching.models.AreaGeometry(MutableMapping[str, Any]):\nivar coordinates: List[float]\nivar type: Union[str, GeoJsonGeometryType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    coordinates: List[float], \n    type: Union[str, GeoJsonGeometryType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AreaProperties(MutableMapping[str, Any]):\nivar radius: float\nivar sub_type: Union[str, GeoJsonPropertiesSubType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    radius: float, \n    sub_type: Union[str, GeoJsonPropertiesSubType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalCodedElement(MutableMapping[str, Any]):\nivar code: str\nivar name: Optional[str]\nivar system: str\nivar value: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    name: Optional[str] = ..., \n    system: str, \n    value: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalDocumentType(str, Enum):\nCONSULTATION = \"consultation\"\nDISCHARGE_SUMMARY = \"dischargeSummary\"\nHISTORY_AND_PHYSICAL = \"historyAndPhysical\"\nIMAGING = \"imaging\"\nLABORATORY = \"laboratory\"\nPATHOLOGY = \"pathology\"\nPROCEDURE = \"procedure\"\nPROGRESS = \"progress\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalNoteEvidence(MutableMapping[str, Any]):\nivar id: str\nivar length: int\nivar offset: int\nivar text: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    id: str, \n    length: int, \n    offset: int, \n    text: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialAcceptedSex(str, Enum):\nALL = \"all\"\nFEMALE = \"female\"\nMALE = \"male\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialDemographics(MutableMapping[str, Any]):\nivar accepted_age_range: Optional[AcceptedAgeRange]\nivar accepted_sex: Optional[Union[str, ClinicalTrialAcceptedSex]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    accepted_age_range: Optional[AcceptedAgeRange] = ..., \n    accepted_sex: Optional[Union[str, ClinicalTrialAcceptedSex]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialDetails(MutableMapping[str, Any]):\nivar demographics: Optional[ClinicalTrialDemographics]\nivar eligibility_criteria_text: Optional[str]\nivar id: str\nivar metadata: ClinicalTrialMetadata\n\n@overload\ndef __init__(\n    self, \n    *, \n    demographics: Optional[ClinicalTrialDemographics] = ..., \n    eligibility_criteria_text: Optional[str] = ..., \n    id: str, \n    metadata: ClinicalTrialMetadata\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialMetadata(MutableMapping[str, Any]):\nivar conditions: List[str]\nivar contacts: Optional[List[ForwardRef('ContactDetails')]]\nivar facilities: Optional[List[ForwardRef('ClinicalTrialResearchFacility')]]\nivar phases: Optional[List[Union[str, ForwardRef('ClinicalTrialPhase')]]]\nivar recruitment_status: Optional[Union[str, ClinicalTrialRecruitmentStatus]]\nivar sponsors: Optional[List[str]]\nivar study_type: Optional[Union[str, ClinicalTrialStudyType]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    conditions: List[str], \n    contacts: Optional[List[ContactDetails]] = ..., \n    facilities: Optional[List[ClinicalTrialResearchFacility]] = ..., \n    phases: Optional[List[Union[str, ClinicalTrialPhase]]] = ..., \n    recruitment_status: Optional[Union[str, ClinicalTrialRecruitmentStatus]] = ..., \n    sponsors: Optional[List[str]] = ..., \n    study_type: Optional[Union[str, ClinicalTrialStudyType]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialPhase(str, Enum):\nEARLY_PHASE1 = \"earlyPhase1\"\nNOT_APPLICABLE = \"notApplicable\"\nPHASE1 = \"phase1\"\nPHASE2 = \"phase2\"\nPHASE3 = \"phase3\"\nPHASE4 = \"phase4\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialPurpose(str, Enum):\nBASIC_SCIENCE = \"basicScience\"\nDEVICE_FEASIBILITY = \"deviceFeasibility\"\nDIAGNOSTIC = \"diagnostic\"\nHEALTH_SERVICES_RESEARCH = \"healthServicesResearch\"\nNOT_APPLICABLE = \"notApplicable\"\nOTHER = \"other\"\nPREVENTION = \"prevention\"\nSCREENING = \"screening\"\nSUPPORTIVE_CARE = \"supportiveCare\"\nTREATMENT = \"treatment\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialRecruitmentStatus(str, Enum):\nENROLLING_BY_INVITATION = \"enrollingByInvitation\"\nNOT_YET_RECRUITING = \"notYetRecruiting\"\nRECRUITING = \"recruiting\"\nUNKNOWN_STATUS = \"unknownStatus\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialRegistryFilter(MutableMapping[str, Any]):\nivar conditions: Optional[List[str]]\nivar facility_areas: Optional[List[ForwardRef('GeographicArea')]]\nivar facility_locations: Optional[List[ForwardRef('GeographicLocation')]]\nivar facility_names: Optional[List[str]]\nivar ids: Optional[List[str]]\nivar phases: Optional[List[Union[str, ForwardRef('ClinicalTrialPhase')]]]\nivar purposes: Optional[List[Union[str, ForwardRef('ClinicalTrialPurpose')]]]\nivar recruitment_statuses: Optional[List[Union[str, ForwardRef('ClinicalTrialRecruitmentStatus')]]]\nivar sources: Optional[List[Union[str, ForwardRef('ClinicalTrialSource')]]]\nivar sponsors: Optional[List[str]]\nivar study_types: Optional[List[Union[str, ForwardRef('ClinicalTrialStudyType')]]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    conditions: Optional[List[str]] = ..., \n    facility_areas: Optional[List[GeographicArea]] = ..., \n    facility_locations: Optional[List[GeographicLocation]] = ..., \n    facility_names: Optional[List[str]] = ..., \n    ids: Optional[List[str]] = ..., \n    phases: Optional[List[Union[str, ClinicalTrialPhase]]] = ..., \n    purposes: Optional[List[Union[str, ClinicalTrialPurpose]]] = ..., \n    recruitment_statuses: Optional[List[Union[str, ClinicalTrialRecruitmentStatus]]] = ..., \n    sources: Optional[List[Union[str, ClinicalTrialSource]]] = ..., \n    sponsors: Optional[List[str]] = ..., \n    study_types: Optional[List[Union[str, ClinicalTrialStudyType]]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialResearchFacility(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar country_or_region: str\nivar name: str\nivar state: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    country_or_region: str, \n    name: str, \n    state: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialSource(str, Enum):\nCLINICALTRIALS_GOV = \"clinicaltrials.gov\"\nCUSTOM = \"custom\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialStudyType(str, Enum):\nEXPANDED_ACCESS = \"expandedAccess\"\nINTERVENTIONAL = \"interventional\"\nOBSERVATIONAL = \"observational\"\nPATIENT_REGISTRIES = \"patientRegistries\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrials(MutableMapping[str, Any]):\nivar custom_trials: Optional[List[ForwardRef('ClinicalTrialDetails')]]\nivar registry_filters: Optional[List[ForwardRef('ClinicalTrialRegistryFilter')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_trials: Optional[List[ClinicalTrialDetails]] = ..., \n    registry_filters: Optional[List[ClinicalTrialRegistryFilter]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ContactDetails(MutableMapping[str, Any]):\nivar email: Optional[str]\nivar name: Optional[str]\nivar phone: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    email: Optional[str] = ..., \n    name: Optional[str] = ..., \n    phone: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentContent(MutableMapping[str, Any]):\nivar source_type: Union[str, DocumentContentSourceType]\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    source_type: Union[str, DocumentContentSourceType], \n    value: str\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentContentSourceType(str, Enum):\nINLINE = \"inline\"\nREFERENCE = \"reference\"\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentType(str, Enum):\nDICOM = \"dicom\"\nFHIR_BUNDLE = \"fhirBundle\"\nGENOMIC_SEQUENCING = \"genomicSequencing\"\nNOTE = \"note\"\n\n\nclass azure.healthinsights.clinicalmatching.models.Error(MutableMapping[str, Any]):\nivar code: str\nivar details: List[Error]\nivar innererror: Optional[InnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: List[Error], \n    innererror: Optional[InnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ExtendedClinicalCodedElement(MutableMapping[str, Any]):\nivar category: Optional[str]\nivar code: str\nivar name: Optional[str]\nivar semantic_type: Optional[str]\nivar system: str\nivar value: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    category: Optional[str] = ..., \n    code: str, \n    name: Optional[str] = ..., \n    semantic_type: Optional[str] = ..., \n    system: str, \n    value: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonGeometryType(str, Enum):\nPOINT = \"Point\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonPropertiesSubType(str, Enum):\nCIRCLE = \"Circle\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonType(str, Enum):\nFEATURE = \"Feature\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeographicArea(MutableMapping[str, Any]):\nivar geometry: AreaGeometry\nivar properties: AreaProperties\nivar type: Union[str, GeoJsonType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    geometry: AreaGeometry, \n    properties: AreaProperties, \n    type: Union[str, GeoJsonType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.GeographicLocation(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar country_or_region: str\nivar state: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    country_or_region: str, \n    state: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.InnerError(MutableMapping[str, Any]):\nivar code: str\nivar innerrror: Optional[InnerError]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    innererror: Optional[InnerError] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.JobStatus(str, Enum):\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nPARTIALLY_COMPLETED = \"partiallyCompleted\"\nRUNNING = \"running\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientDocument(MutableMapping[str, Any]):\nivar clinical_type: Optional[Union[str, ClinicalDocumentType]]\nivar content: DocumentContent\nivar created_date_time: Optional[datetime]\nivar id: str\nivar language: Optional[str]\nivar type: Union[str, DocumentType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    clinical_type: Optional[Union[str, ClinicalDocumentType]] = ..., \n    content: DocumentContent, \n    created_date_time: Optional[datetime] = ..., \n    id: str, \n    language: Optional[str] = ..., \n    type: Union[str, DocumentType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientInfo(MutableMapping[str, Any]):\nivar birth_date: Optional[date]\nivar clinical_info: Optional[List[ForwardRef('ClinicalCodedElement')]]\nivar sex: Optional[Union[str, PatientInfoSex]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    birth_date: Optional[date] = ..., \n    clinical_info: Optional[List[ClinicalCodedElement]] = ..., \n    sex: Optional[Union[str, PatientInfoSex]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientInfoSex(str, Enum):\nFEMALE = \"female\"\nMALE = \"male\"\nUNSPECIFIED = \"unspecified\"\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientRecord(MutableMapping[str, Any]):\nivar data: Optional[List[ForwardRef('PatientDocument')]]\nivar id: str\nivar info: Optional[PatientInfo]\n\n@overload\ndef __init__(\n    self, \n    *, \n    data: Optional[List[PatientDocument]] = ..., \n    id: str, \n    info: Optional[PatientInfo] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.RepeatabilityResultType(str, Enum):\nACCEPTED = \"accepted\"\nREJECTED = \"rejected\"\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherData(MutableMapping[str, Any]):\nivar configuration: Optional[TrialMatcherModelConfiguration]\nivar patients: List[PatientRecord]\n\n@overload\ndef __init__(\n    self, \n    *, \n    configuration: Optional[TrialMatcherModelConfiguration] = ..., \n    patients: List[PatientRecord]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInference(MutableMapping[str, Any]):\nivar confidence_score: Optional[float]\nivar description: Optional[str]\nivar evidence: Optional[List[ForwardRef('TrialMatcherInferenceEvidence')]]\nivar id: Optional[str]\nivar metadata: Optional[ClinicalTrialMetadata]\nivar source: Optional[Union[str, ClinicalTrialSource]]\nivar type: Union[str, TrialMatcherInferenceType]\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence_score: Optional[float] = ..., \n    description: Optional[str] = ..., \n    evidence: Optional[List[TrialMatcherInferenceEvidence]] = ..., \n    id: Optional[str] = ..., \n    metadata: Optional[ClinicalTrialMetadata] = ..., \n    source: Optional[Union[str, ClinicalTrialSource]] = ..., \n    type: Union[str, TrialMatcherInferenceType], \n    value: str\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInferenceEvidence(MutableMapping[str, Any]):\nivar eligibilityCriteriaEvidence: Optional[str]\nivar importance: Optional[float]\nivar patientDataEvidence: Optional[ClinicalNoteEvidence]\nivar patientInfoEvidence: Optional[ClinicalCodedElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    eligibility_criteria_evidence: Optional[str] = ..., \n    importance: Optional[float] = ..., \n    patient_data_evidence: Optional[ClinicalNoteEvidence] = ..., \n    patient_info_evidence: Optional[ClinicalCodedElement] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInferenceType(str, Enum):\nTRIAL_ELIGIBILITY = \"trialEligibility\"\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherModelConfiguration(MutableMapping[str, Any]):\nivar clinical_trials: ClinicalTrials\nivar include_evidence: bool\nivar verbose: bool\n\n@overload\ndef __init__(\n    self, \n    *, \n    clinical_trials: ClinicalTrials, \n    include_evidence: bool = True, \n    verbose: bool = False\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherPatientResult(MutableMapping[str, Any]):\nivar id: str\nivar inferences: List[TrialMatcherInference]\nivar needed_clinical_info: Optional[List[ForwardRef('ExtendedClinicalCodedElement')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    id: str, \n    inferences: List[TrialMatcherInference], \n    needed_clinical_info: Optional[List[ExtendedClinicalCodedElement]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherResult(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar errors: Optional[List[ForwardRef('Error')]]\nivar expiration_date_time: datetime\nivar job_id: str\nivar last_update_date_time: datetime\nivar results: Optional[TrialMatcherResults]\nivar status: Union[str, JobStatus]\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherResults(MutableMapping[str, Any]):\nivar knowledge_graph_last_update_date: Optional[date]\nivar model_version: str\nivar patients: List[TrialMatcherPatientResult]\n\n@overload\ndef __init__(\n    self, \n    *, \n    knowledge_graph_last_update_date: Optional[date] = ..., \n    model_version: str, \n    patients: List[TrialMatcherPatientResult]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n", "language": "python", "context": "\nDO name service client types with a Client suffix.\nDO use the same client name for sync and async packages\n\nExample:\n\n|Sync/async|Namespace|Distribution package name|Client name|\n|-|-|-|-|\n|Sync|azure.sampleservice|azure-sampleservice|azure.sampleservice.SampleServiceClient|\n|Async|azure.sampleservice.aio|azure-sampleservice-aio|azure.sampleservice.aio.SampleServiceClient|\nDO use the credentials classes in azure-core whenever possible.\nDO NOT use an \"options bag\" object to group optional parameters. Instead, pass as individual keyword-only arguments.\nDO use a begin_ prefix for all long running operations.\nDO prefix methods with list_ for methods that enumerate (lists) resources.\nYOU SHOULD prefer the usage one of the preferred verbs for method names. You should have a good (articulated) reason to have an alternate verb for one of these operations.\n\n|Verb|Parameters|Returns|Comments|\n|-|-|-|-|\n|create_\\<noun>|key, item, [allow_overwrite=False]|Created item|Create new item. Fails if item already exists.|\n|upsert_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used in database-like services |\n|set_\\<noun>|key, item|item|Create new item, or update existing item. Verb is primarily used for dictionary-like properties of a service |\n|update_\\<noun>|key, partial item|item|Fails if item doesn't exist. |\n|replace_\\<noun>|key, item|item|Completely replaces an existing item. Fails if the item doesn't exist. |\n|append_\\<noun>|item|item|Add item to a collection. Item will be added last. |\n|add_\\<noun>|index, item|item|Add item to a collection. Item will be added at the given index. |\n|get_\\<noun>|key|item|Raises an exception if item doesn't exist |\n|list_\\<noun>||azure.core.ItemPaged[Item]|Return an iterable of Items. Returns an iterable with no items if no items exist (doesn't return None or throw)|\n|\\<noun>\\_exists|key|bool|Return True if the item exists. Must raise an exception if the method failed to determine if the item exists (for example, the service returned an HTTP 503 response)|\n|delete_\\<noun>|key|None|Delete an existing item. Must succeed even if item didn't exist.|\n|remove_\\<noun>|key|removed item or None|Remove a reference to an item from a collection. This method doesn't delete the actual item, only the reference.|\nDO use snake_case for variable, function, and method names:\n\n```python\n# Yes:\nservice_client = ServiceClient()\n\nservice_client.list_things()\n\ndef do_something():\n    ...\n\n# No:\nserviceClient = ServiceClient()\n\nservice_client.listThings()\n\ndef DoSomething():\n    ...\n\n```", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-client-naming\", \"python_design.html#python-client-same-name-sync-async\"], \"line_no\": 6, \"bad_code\": \"class azure.healthinsights.clinicalmatching.ClinicalMatching(ClinicalMatchingClientOperationsMixin): implements ContextManager\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.ClinicalMatchingClient(ClinicalMatchingClientOperationsMixin): implements ContextManager\", \"comment\": \"Service client types should be named with a 'Client' suffix. In addition, the sync and async clients must share the same name. Rename the sync client from 'ClinicalMatching' to 'ClinicalMatchingClient' to comply with these guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-auth-credential-azure-core\"], \"line_no\": 11, \"bad_code\": \"api_key: str\", \"suggestion\": \"Use a credential object from azure.core.credentials (e.g., AzureKeyCredential) instead of a raw string for the api key.\", \"comment\": \"Authentication parameters should leverage azure-core credential classes rather than using a simple string.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-options-naming\"], \"line_no\": 70, \"bad_code\": \"    options: Optional[CreateTrialsOptions] = None,\", \"suggestion\": \"    <individual keyword parameters> instead of an options bag\", \"comment\": \"Avoid using an options bag object to group optional parameters. Pass each optional parameter as a separate keyword-only argument.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-lro-poller-begin-naming\"], \"line_no\": 93, \"bad_code\": \"def create_trials(\", \"suggestion\": \"def begin_create_trials(\", \"comment\": \"Long running operations must use a 'begin_' prefix. Rename 'create_trials' to 'begin_create_trials' per the long running operations naming guideline.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-paged-prefix\"], \"line_no\": 102, \"bad_code\": \"def trials(\", \"suggestion\": \"def list_trials(\", \"comment\": \"Methods that enumerate resources should be prefixed with 'list_'. Rename 'trials' to 'list_trials' to follow the paging method naming guideline.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-service-verbs\"], \"line_no\": 108, \"bad_code\": \"def erase_trials(\", \"suggestion\": \"def delete_trials(\", \"comment\": \"For deletion operations the preferred verb is 'delete_'. Rename 'erase_trials' to 'delete_trials' per the service verb naming guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-lro-poller-begin-naming\"], \"line_no\": 214, \"bad_code\": \"async def create_trials(\", \"suggestion\": \"async def begin_create_trials(\", \"comment\": \"Long running operations should use a 'begin_' prefix. Rename the async 'create_trials' method to 'begin_create_trials'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-paged-prefix\"], \"line_no\": 223, \"bad_code\": \"def trials(\", \"suggestion\": \"def list_trials(\", \"comment\": \"Methods that enumerate resources should be prefixed with 'list_'. Consider renaming 'trials' to 'list_trials' and returning an ItemPaged type.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-service-verbs\"], \"line_no\": 229, \"bad_code\": \"async def erase_trials(\", \"suggestion\": \"async def delete_trials(\", \"comment\": \"Deletion operation names should use the 'delete_' prefix rather than 'erase_'. Rename 'erase_trials' to 'delete_trials' in the async client.\", \"source\": \"guideline\"}, {\"rule_ids\": [], \"line_no\": 824, \"bad_code\": \"ivar innerrror: Optional[InnerError]\", \"suggestion\": \"ivar inner_error: Optional[InnerError]\", \"comment\": \"There is a typo in the attribute name ('innerrror'). Correcting it to 'inner_error' (or a similar consistent name) improves clarity and consistency in the API.\", \"source\": \"generic\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 998, \"bad_code\": \"ivar eligibilityCriteriaEvidence: Optional[str]\", \"suggestion\": \"ivar eligibility_criteria_evidence: Optional[str]\", \"comment\": \"Variable names should use snake_case instead of camelCase.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1000, \"bad_code\": \"ivar patientDataEvidence: Optional[ClinicalNoteEvidence]\", \"suggestion\": \"ivar patient_data_evidence: Optional[ClinicalNoteEvidence]\", \"comment\": \"Variable names should use snake_case instead of camelCase.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1001, \"bad_code\": \"ivar patientInfoEvidence: Optional[ClinicalCodedElement]\", \"suggestion\": \"ivar patient_info_evidence: Optional[ClinicalCodedElement]\", \"comment\": \"Variable names should use snake_case instead of camelCase.\", \"source\": \"guideline\"}]}"}
{"testcase": "medium_apiview_no_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.18), Python version: 3.10.16\n\n\nnamespace azure.healthinsights.clinicalmatching\n\nclass azure.healthinsights.clinicalmatching.ClinicalMatchingClient(ClinicalMatchingClientOperationsMixin): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: AzureKeyCredential, \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_match_trials(\n    self, \n    body: TrialMatcherData, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef begin_match_trials(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef begin_match_trials(\n    self, \n    body: IO, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@distributed_trace\ndef begin_match_trials(\n    self, \n    body: Union[TrialMatcherData, JSON, IO], \n    *, \n    content_type: str = ..., \n    continuation_token: Optional[str] = ..., \n    polling: Union[bool, PollingMethod] = ..., \n    polling_interval: Optional[int] = ..., \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\ndef close(self) -> None\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: Optional[bool] = ..., \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.healthinsights.clinicalmatching.aio\n\nclass azure.healthinsights.clinicalmatching.aio.ClinicalMatchingClient(ClinicalMatchingClientOperationsMixin): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: AzureKeyCredential, \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_match_trials(\n    self, \n    body: TrialMatcherData, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@overload\nasync def begin_match_trials(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@overload\nasync def begin_match_trials(\n    self, \n    body: IO, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@distributed_trace_async\nasync def begin_match_trials(\n    self, \n    body: Union[TrialMatcherData, JSON, IO], \n    *, \n    content_type: str = ..., \n    continuation_token: Optional[str] = ..., \n    polling: Union[bool, AsyncPollingMethod] = ..., \n    polling_interval: Optional[int] = ..., \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\nasync def close(self) -> None\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: Optional[bool] = ..., \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.healthinsights.clinicalmatching.models\n\nclass azure.healthinsights.clinicalmatching.models.AcceptedAge(MutableMapping[str, Any]):\nivar unit: Union[str, AgeUnit]\nivar value: float\n\n@overload\ndef __init__(\n    self, \n    *, \n    unit: Union[str, AgeUnit], \n    value: float\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AcceptedAgeRange(MutableMapping[str, Any]):\nivar maximum_age: Optional[AcceptedAge]\nivar minimum_age: Optional[AcceptedAge]\n\n@overload\ndef __init__(\n    self, \n    *, \n    maximum_age: Optional[AcceptedAge] = ..., \n    minimum_age: Optional[AcceptedAge] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AgeUnit(str, Enum):\nDAYS = \"days\"\nMONTHS = \"months\"\nYEARS = \"years\"\n\n\nclass azure.healthinsights.clinicalmatching.models.AreaGeometry(MutableMapping[str, Any]):\nivar coordinates: List[float]\nivar type: Union[str, GeoJsonGeometryType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    coordinates: List[float], \n    type: Union[str, GeoJsonGeometryType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AreaProperties(MutableMapping[str, Any]):\nivar radius: float\nivar sub_type: Union[str, GeoJsonPropertiesSubType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    radius: float, \n    sub_type: Union[str, GeoJsonPropertiesSubType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalCodedElement(MutableMapping[str, Any]):\nivar code: str\nivar name: Optional[str]\nivar system: str\nivar value: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    name: Optional[str] = ..., \n    system: str, \n    value: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalDocumentType(str, Enum):\nCONSULTATION = \"consultation\"\nDISCHARGE_SUMMARY = \"dischargeSummary\"\nHISTORY_AND_PHYSICAL = \"historyAndPhysical\"\nIMAGING = \"imaging\"\nLABORATORY = \"laboratory\"\nPATHOLOGY = \"pathology\"\nPROCEDURE = \"procedure\"\nPROGRESS = \"progress\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalNoteEvidence(MutableMapping[str, Any]):\nivar id: str\nivar length: int\nivar offset: int\nivar text: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    id: str, \n    length: int, \n    offset: int, \n    text: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialAcceptedSex(str, Enum):\nALL = \"all\"\nFEMALE = \"female\"\nMALE = \"male\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialDemographics(MutableMapping[str, Any]):\nivar accepted_age_range: Optional[AcceptedAgeRange]\nivar accepted_sex: Optional[Union[str, ClinicalTrialAcceptedSex]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    accepted_age_range: Optional[AcceptedAgeRange] = ..., \n    accepted_sex: Optional[Union[str, ClinicalTrialAcceptedSex]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialDetails(MutableMapping[str, Any]):\nivar demographics: Optional[ClinicalTrialDemographics]\nivar eligibility_criteria_text: Optional[str]\nivar id: str\nivar metadata: ClinicalTrialMetadata\n\n@overload\ndef __init__(\n    self, \n    *, \n    demographics: Optional[ClinicalTrialDemographics] = ..., \n    eligibility_criteria_text: Optional[str] = ..., \n    id: str, \n    metadata: ClinicalTrialMetadata\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialMetadata(MutableMapping[str, Any]):\nivar conditions: List[str]\nivar contacts: Optional[List[ForwardRef('ContactDetails')]]\nivar facilities: Optional[List[ForwardRef('ClinicalTrialResearchFacility')]]\nivar phases: Optional[List[Union[str, ForwardRef('ClinicalTrialPhase')]]]\nivar recruitment_status: Optional[Union[str, ClinicalTrialRecruitmentStatus]]\nivar sponsors: Optional[List[str]]\nivar study_type: Optional[Union[str, ClinicalTrialStudyType]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    conditions: List[str], \n    contacts: Optional[List[ContactDetails]] = ..., \n    facilities: Optional[List[ClinicalTrialResearchFacility]] = ..., \n    phases: Optional[List[Union[str, ClinicalTrialPhase]]] = ..., \n    recruitment_status: Optional[Union[str, ClinicalTrialRecruitmentStatus]] = ..., \n    sponsors: Optional[List[str]] = ..., \n    study_type: Optional[Union[str, ClinicalTrialStudyType]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialPhase(str, Enum):\nEARLY_PHASE1 = \"earlyPhase1\"\nNOT_APPLICABLE = \"notApplicable\"\nPHASE1 = \"phase1\"\nPHASE2 = \"phase2\"\nPHASE3 = \"phase3\"\nPHASE4 = \"phase4\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialPurpose(str, Enum):\nBASIC_SCIENCE = \"basicScience\"\nDEVICE_FEASIBILITY = \"deviceFeasibility\"\nDIAGNOSTIC = \"diagnostic\"\nHEALTH_SERVICES_RESEARCH = \"healthServicesResearch\"\nNOT_APPLICABLE = \"notApplicable\"\nOTHER = \"other\"\nPREVENTION = \"prevention\"\nSCREENING = \"screening\"\nSUPPORTIVE_CARE = \"supportiveCare\"\nTREATMENT = \"treatment\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialRecruitmentStatus(str, Enum):\nENROLLING_BY_INVITATION = \"enrollingByInvitation\"\nNOT_YET_RECRUITING = \"notYetRecruiting\"\nRECRUITING = \"recruiting\"\nUNKNOWN_STATUS = \"unknownStatus\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialRegistryFilter(MutableMapping[str, Any]):\nivar conditions: Optional[List[str]]\nivar facility_areas: Optional[List[ForwardRef('GeographicArea')]]\nivar facility_locations: Optional[List[ForwardRef('GeographicLocation')]]\nivar facility_names: Optional[List[str]]\nivar ids: Optional[List[str]]\nivar phases: Optional[List[Union[str, ForwardRef('ClinicalTrialPhase')]]]\nivar purposes: Optional[List[Union[str, ForwardRef('ClinicalTrialPurpose')]]]\nivar recruitment_statuses: Optional[List[Union[str, ForwardRef('ClinicalTrialRecruitmentStatus')]]]\nivar sources: Optional[List[Union[str, ForwardRef('ClinicalTrialSource')]]]\nivar sponsors: Optional[List[str]]\nivar study_types: Optional[List[Union[str, ForwardRef('ClinicalTrialStudyType')]]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    conditions: Optional[List[str]] = ..., \n    facility_areas: Optional[List[GeographicArea]] = ..., \n    facility_locations: Optional[List[GeographicLocation]] = ..., \n    facility_names: Optional[List[str]] = ..., \n    ids: Optional[List[str]] = ..., \n    phases: Optional[List[Union[str, ClinicalTrialPhase]]] = ..., \n    purposes: Optional[List[Union[str, ClinicalTrialPurpose]]] = ..., \n    recruitment_statuses: Optional[List[Union[str, ClinicalTrialRecruitmentStatus]]] = ..., \n    sources: Optional[List[Union[str, ClinicalTrialSource]]] = ..., \n    sponsors: Optional[List[str]] = ..., \n    study_types: Optional[List[Union[str, ClinicalTrialStudyType]]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialResearchFacility(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar country_or_region: str\nivar name: str\nivar state: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    country_or_region: str, \n    name: str, \n    state: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialSource(str, Enum):\nCLINICALTRIALS_GOV = \"clinicaltrials.gov\"\nCUSTOM = \"custom\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialStudyType(str, Enum):\nEXPANDED_ACCESS = \"expandedAccess\"\nINTERVENTIONAL = \"interventional\"\nOBSERVATIONAL = \"observational\"\nPATIENT_REGISTRIES = \"patientRegistries\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrials(MutableMapping[str, Any]):\nivar custom_trials: Optional[List[ForwardRef('ClinicalTrialDetails')]]\nivar registry_filters: Optional[List[ForwardRef('ClinicalTrialRegistryFilter')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_trials: Optional[List[ClinicalTrialDetails]] = ..., \n    registry_filters: Optional[List[ClinicalTrialRegistryFilter]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ContactDetails(MutableMapping[str, Any]):\nivar email: Optional[str]\nivar name: Optional[str]\nivar phone: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    email: Optional[str] = ..., \n    name: Optional[str] = ..., \n    phone: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentContent(MutableMapping[str, Any]):\nivar source_type: Union[str, DocumentContentSourceType]\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    source_type: Union[str, DocumentContentSourceType], \n    value: str\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentContentSourceType(str, Enum):\nINLINE = \"inline\"\nREFERENCE = \"reference\"\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentType(str, Enum):\nDICOM = \"dicom\"\nFHIR_BUNDLE = \"fhirBundle\"\nGENOMIC_SEQUENCING = \"genomicSequencing\"\nNOTE = \"note\"\n\n\nclass azure.healthinsights.clinicalmatching.models.Error(MutableMapping[str, Any]):\nivar code: str\nivar details: List[Error]\nivar innererror: Optional[InnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: List[Error], \n    innererror: Optional[InnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ExtendedClinicalCodedElement(MutableMapping[str, Any]):\nivar category: Optional[str]\nivar code: str\nivar name: Optional[str]\nivar semantic_type: Optional[str]\nivar system: str\nivar value: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    category: Optional[str] = ..., \n    code: str, \n    name: Optional[str] = ..., \n    semantic_type: Optional[str] = ..., \n    system: str, \n    value: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonGeometryType(str, Enum):\nPOINT = \"Point\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonPropertiesSubType(str, Enum):\nCIRCLE = \"Circle\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonType(str, Enum):\nFEATURE = \"Feature\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeographicArea(MutableMapping[str, Any]):\nivar geometry: AreaGeometry\nivar properties: AreaProperties\nivar type: Union[str, GeoJsonType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    geometry: AreaGeometry, \n    properties: AreaProperties, \n    type: Union[str, GeoJsonType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.GeographicLocation(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar country_or_region: str\nivar state: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    country_or_region: str, \n    state: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.InnerError(MutableMapping[str, Any]):\nivar code: str\nivar innererror: Optional[InnerError]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    innererror: Optional[InnerError] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.JobStatus(str, Enum):\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nPARTIALLY_COMPLETED = \"partiallyCompleted\"\nRUNNING = \"running\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientDocument(MutableMapping[str, Any]):\nivar clinical_type: Optional[Union[str, ClinicalDocumentType]]\nivar content: DocumentContent\nivar created_date_time: Optional[datetime]\nivar id: str\nivar language: Optional[str]\nivar type: Union[str, DocumentType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    clinical_type: Optional[Union[str, ClinicalDocumentType]] = ..., \n    content: DocumentContent, \n    created_date_time: Optional[datetime] = ..., \n    id: str, \n    language: Optional[str] = ..., \n    type: Union[str, DocumentType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientInfo(MutableMapping[str, Any]):\nivar birth_date: Optional[date]\nivar clinical_info: Optional[List[ForwardRef('ClinicalCodedElement')]]\nivar sex: Optional[Union[str, PatientInfoSex]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    birth_date: Optional[date] = ..., \n    clinical_info: Optional[List[ClinicalCodedElement]] = ..., \n    sex: Optional[Union[str, PatientInfoSex]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientInfoSex(str, Enum):\nFEMALE = \"female\"\nMALE = \"male\"\nUNSPECIFIED = \"unspecified\"\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientRecord(MutableMapping[str, Any]):\nivar data: Optional[List[ForwardRef('PatientDocument')]]\nivar id: str\nivar info: Optional[PatientInfo]\n\n@overload\ndef __init__(\n    self, \n    *, \n    data: Optional[List[PatientDocument]] = ..., \n    id: str, \n    info: Optional[PatientInfo] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.RepeatabilityResultType(str, Enum):\nACCEPTED = \"accepted\"\nREJECTED = \"rejected\"\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherData(MutableMapping[str, Any]):\nivar configuration: Optional[TrialMatcherModelConfiguration]\nivar patients: List[PatientRecord]\n\n@overload\ndef __init__(\n    self, \n    *, \n    configuration: Optional[TrialMatcherModelConfiguration] = ..., \n    patients: List[PatientRecord]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInference(MutableMapping[str, Any]):\nivar confidence_score: Optional[float]\nivar description: Optional[str]\nivar evidence: Optional[List[ForwardRef('TrialMatcherInferenceEvidence')]]\nivar id: Optional[str]\nivar metadata: Optional[ClinicalTrialMetadata]\nivar source: Optional[Union[str, ClinicalTrialSource]]\nivar type: Union[str, TrialMatcherInferenceType]\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence_score: Optional[float] = ..., \n    description: Optional[str] = ..., \n    evidence: Optional[List[TrialMatcherInferenceEvidence]] = ..., \n    id: Optional[str] = ..., \n    metadata: Optional[ClinicalTrialMetadata] = ..., \n    source: Optional[Union[str, ClinicalTrialSource]] = ..., \n    type: Union[str, TrialMatcherInferenceType], \n    value: str\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInferenceEvidence(MutableMapping[str, Any]):\nivar eligibility_criteria_evidence: Optional[str]\nivar importance: Optional[float]\nivar patient_data_evidence: Optional[ClinicalNoteEvidence]\nivar patient_info_evidence: Optional[ClinicalCodedElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    eligibility_criteria_evidence: Optional[str] = ..., \n    importance: Optional[float] = ..., \n    patient_data_evidence: Optional[ClinicalNoteEvidence] = ..., \n    patient_info_evidence: Optional[ClinicalCodedElement] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInferenceType(str, Enum):\nTRIAL_ELIGIBILITY = \"trialEligibility\"\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherModelConfiguration(MutableMapping[str, Any]):\nivar clinical_trials: ClinicalTrials\nivar include_evidence: bool\nivar verbose: bool\n\n@overload\ndef __init__(\n    self, \n    *, \n    clinical_trials: ClinicalTrials, \n    include_evidence: bool = True, \n    verbose: bool = False\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherPatientResult(MutableMapping[str, Any]):\nivar id: str\nivar inferences: List[TrialMatcherInference]\nivar needed_clinical_info: Optional[List[ForwardRef('ExtendedClinicalCodedElement')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    id: str, \n    inferences: List[TrialMatcherInference], \n    needed_clinical_info: Optional[List[ExtendedClinicalCodedElement]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherResult(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar errors: Optional[List[ForwardRef('Error')]]\nivar expiration_date_time: datetime\nivar job_id: str\nivar last_update_date_time: datetime\nivar results: Optional[TrialMatcherResults]\nivar status: Union[str, JobStatus]\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherResults(MutableMapping[str, Any]):\nivar knowledge_graph_last_update_date: Optional[date]\nivar model_version: str\nivar patients: List[TrialMatcherPatientResult]\n\n@overload\ndef __init__(\n    self, \n    *, \n    knowledge_graph_last_update_date: Optional[date] = ..., \n    model_version: str, \n    patients: List[TrialMatcherPatientResult]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n", "language": "python", "context": "", "response": "{\"comments\": []}"}
{"testcase": "medium_apiview_multiple_same_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.18), Python version: 3.10.16\n\n\nnamespace azure.healthinsights.clinicalmatching\n\nclass azure.healthinsights.clinicalmatching.ClinicalMatchingClient(ClinicalMatchingClientOperationsMixin): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: AzureKeyCredential, \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_match_trials(\n    self, \n    body: TrialMatcherData, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef begin_match_trials(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@overload\ndef begin_match_trials(\n    self, \n    body: IO, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\n@distributed_trace\ndef begin_match_trials(\n    self, \n    body: Union[TrialMatcherData, JSON, IO], \n    *, \n    content_type: str = ..., \n    continuation_token: Optional[str] = ..., \n    polling: Union[bool, PollingMethod] = ..., \n    polling_interval: Optional[int] = ..., \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> LROPoller[TrialMatcherResult]\n\ndef close(self) -> None\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: Optional[bool] = ..., \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.healthinsights.clinicalmatching.aio\n\nclass azure.healthinsights.clinicalmatching.aio.ClinicalMatchingClient(ClinicalMatchingClientOperationsMixin): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: AzureKeyCredential, \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_match_trials(\n    self, \n    body: TrialMatcherData, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@overload\nasync def begin_match_trials(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@overload\nasync def begin_match_trials(\n    self, \n    body: IO, \n    *, \n    content_type: str = \"application/json\", \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\n@distributed_trace_async\nasync def begin_match_trials(\n    self, \n    body: Union[TrialMatcherData, JSON, IO], \n    *, \n    content_type: str = ..., \n    continuation_token: Optional[str] = ..., \n    polling: Union[bool, AsyncPollingMethod] = ..., \n    polling_interval: Optional[int] = ..., \n    repeatability_first_sent: Optional[datetime] = ..., \n    repeatability_request_id: Optional[str] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[TrialMatcherResult]\n\nasync def close(self) -> None\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: Optional[bool] = ..., \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.healthinsights.clinicalmatching.models\n\nclass azure.healthinsights.clinicalmatching.models.AcceptedAge(MutableMapping[str, Any]):\nivar unit: Union[str, AgeUnit]\nivar value: float\n\n@overload\ndef __init__(\n    self, \n    *, \n    unit: Union[str, AgeUnit], \n    value: float\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AcceptedAgeRange(MutableMapping[str, Any]):\nivar maximum_age: Optional[AcceptedAge]\nivar minimum_age: Optional[AcceptedAge]\n\n@overload\ndef __init__(\n    self, \n    *, \n    maximum_age: Optional[AcceptedAge] = ..., \n    minimum_age: Optional[AcceptedAge] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AgeUnit(Enum):\nDAYS = \"days\"\nMONTHS = \"months\"\nYEARS = \"years\"\n\n\nclass azure.healthinsights.clinicalmatching.models.AreaGeometry(MutableMapping[str, Any]):\nivar coordinates: List[float]\nivar type: Union[str, GeoJsonGeometryType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    coordinates: List[float], \n    type: Union[str, GeoJsonGeometryType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.AreaProperties(MutableMapping[str, Any]):\nivar radius: float\nivar sub_type: Union[str, GeoJsonPropertiesSubType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    radius: float, \n    sub_type: Union[str, GeoJsonPropertiesSubType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalCodedElement(MutableMapping[str, Any]):\nivar code: str\nivar name: Optional[str]\nivar system: str\nivar value: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    name: Optional[str] = ..., \n    system: str, \n    value: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalDocumentType(Enum):\nCONSULTATION = \"consultation\"\nDISCHARGE_SUMMARY = \"dischargeSummary\"\nHISTORY_AND_PHYSICAL = \"historyAndPhysical\"\nIMAGING = \"imaging\"\nLABORATORY = \"laboratory\"\nPATHOLOGY = \"pathology\"\nPROCEDURE = \"procedure\"\nPROGRESS = \"progress\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalNoteEvidence(MutableMapping[str, Any]):\nivar id: str\nivar length: int\nivar offset: int\nivar text: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    id: str, \n    length: int, \n    offset: int, \n    text: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialAcceptedSex(Enum):\nALL = \"all\"\nFEMALE = \"female\"\nMALE = \"male\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialDemographics(MutableMapping[str, Any]):\nivar accepted_age_range: Optional[AcceptedAgeRange]\nivar accepted_sex: Optional[Union[str, ClinicalTrialAcceptedSex]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    accepted_age_range: Optional[AcceptedAgeRange] = ..., \n    accepted_sex: Optional[Union[str, ClinicalTrialAcceptedSex]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialDetails(MutableMapping[str, Any]):\nivar demographics: Optional[ClinicalTrialDemographics]\nivar eligibility_criteria_text: Optional[str]\nivar id: str\nivar metadata: ClinicalTrialMetadata\n\n@overload\ndef __init__(\n    self, \n    *, \n    demographics: Optional[ClinicalTrialDemographics] = ..., \n    eligibility_criteria_text: Optional[str] = ..., \n    id: str, \n    metadata: ClinicalTrialMetadata\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialMetadata(MutableMapping[str, Any]):\nivar conditions: List[str]\nivar contacts: Optional[List[ForwardRef('ContactDetails')]]\nivar facilities: Optional[List[ForwardRef('ClinicalTrialResearchFacility')]]\nivar phases: Optional[List[Union[str, ForwardRef('ClinicalTrialPhase')]]]\nivar recruitment_status: Optional[Union[str, ClinicalTrialRecruitmentStatus]]\nivar sponsors: Optional[List[str]]\nivar study_type: Optional[Union[str, ClinicalTrialStudyType]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    conditions: List[str], \n    contacts: Optional[List[ContactDetails]] = ..., \n    facilities: Optional[List[ClinicalTrialResearchFacility]] = ..., \n    phases: Optional[List[Union[str, ClinicalTrialPhase]]] = ..., \n    recruitment_status: Optional[Union[str, ClinicalTrialRecruitmentStatus]] = ..., \n    sponsors: Optional[List[str]] = ..., \n    study_type: Optional[Union[str, ClinicalTrialStudyType]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialPhase(Enum):\nEARLY_PHASE1 = \"earlyPhase1\"\nNOT_APPLICABLE = \"notApplicable\"\nPHASE1 = \"phase1\"\nPHASE2 = \"phase2\"\nPHASE3 = \"phase3\"\nPHASE4 = \"phase4\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialPurpose(Enum):\nBASIC_SCIENCE = \"basicScience\"\nDEVICE_FEASIBILITY = \"deviceFeasibility\"\nDIAGNOSTIC = \"diagnostic\"\nHEALTH_SERVICES_RESEARCH = \"healthServicesResearch\"\nNOT_APPLICABLE = \"notApplicable\"\nOTHER = \"other\"\nPREVENTION = \"prevention\"\nSCREENING = \"screening\"\nSUPPORTIVE_CARE = \"supportiveCare\"\nTREATMENT = \"treatment\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialRecruitmentStatus(Enum):\nENROLLING_BY_INVITATION = \"enrollingByInvitation\"\nNOT_YET_RECRUITING = \"notYetRecruiting\"\nRECRUITING = \"recruiting\"\nUNKNOWN_STATUS = \"unknownStatus\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialRegistryFilter(MutableMapping[str, Any]):\nivar conditions: Optional[List[str]]\nivar facility_areas: Optional[List[ForwardRef('GeographicArea')]]\nivar facility_locations: Optional[List[ForwardRef('GeographicLocation')]]\nivar facility_names: Optional[List[str]]\nivar ids: Optional[List[str]]\nivar phases: Optional[List[Union[str, ForwardRef('ClinicalTrialPhase')]]]\nivar purposes: Optional[List[Union[str, ForwardRef('ClinicalTrialPurpose')]]]\nivar recruitment_statuses: Optional[List[Union[str, ForwardRef('ClinicalTrialRecruitmentStatus')]]]\nivar sources: Optional[List[Union[str, ForwardRef('ClinicalTrialSource')]]]\nivar sponsors: Optional[List[str]]\nivar study_types: Optional[List[Union[str, ForwardRef('ClinicalTrialStudyType')]]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    conditions: Optional[List[str]] = ..., \n    facility_areas: Optional[List[GeographicArea]] = ..., \n    facility_locations: Optional[List[GeographicLocation]] = ..., \n    facility_names: Optional[List[str]] = ..., \n    ids: Optional[List[str]] = ..., \n    phases: Optional[List[Union[str, ClinicalTrialPhase]]] = ..., \n    purposes: Optional[List[Union[str, ClinicalTrialPurpose]]] = ..., \n    recruitment_statuses: Optional[List[Union[str, ClinicalTrialRecruitmentStatus]]] = ..., \n    sources: Optional[List[Union[str, ClinicalTrialSource]]] = ..., \n    sponsors: Optional[List[str]] = ..., \n    study_types: Optional[List[Union[str, ClinicalTrialStudyType]]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialResearchFacility(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar country_or_region: str\nivar name: str\nivar state: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    country_or_region: str, \n    name: str, \n    state: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialSource(Enum):\nCLINICALTRIALS_GOV = \"clinicaltrials.gov\"\nCUSTOM = \"custom\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrialStudyType(Enum):\nEXPANDED_ACCESS = \"expandedAccess\"\nINTERVENTIONAL = \"interventional\"\nOBSERVATIONAL = \"observational\"\nPATIENT_REGISTRIES = \"patientRegistries\"\n\n\nclass azure.healthinsights.clinicalmatching.models.ClinicalTrials(MutableMapping[str, Any]):\nivar custom_trials: Optional[List[ForwardRef('ClinicalTrialDetails')]]\nivar registry_filters: Optional[List[ForwardRef('ClinicalTrialRegistryFilter')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_trials: Optional[List[ClinicalTrialDetails]] = ..., \n    registry_filters: Optional[List[ClinicalTrialRegistryFilter]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ContactDetails(MutableMapping[str, Any]):\nivar email: Optional[str]\nivar name: Optional[str]\nivar phone: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    email: Optional[str] = ..., \n    name: Optional[str] = ..., \n    phone: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentContent(MutableMapping[str, Any]):\nivar source_type: Union[str, DocumentContentSourceType]\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    source_type: Union[str, DocumentContentSourceType], \n    value: str\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentContentSourceType(Enum):\nINLINE = \"inline\"\nREFERENCE = \"reference\"\n\n\nclass azure.healthinsights.clinicalmatching.models.DocumentType(Enum):\nDICOM = \"dicom\"\nFHIR_BUNDLE = \"fhirBundle\"\nGENOMIC_SEQUENCING = \"genomicSequencing\"\nNOTE = \"note\"\n\n\nclass azure.healthinsights.clinicalmatching.models.Error(MutableMapping[str, Any]):\nivar code: str\nivar details: List[Error]\nivar innererror: Optional[InnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: List[Error], \n    innererror: Optional[InnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.ExtendedClinicalCodedElement(MutableMapping[str, Any]):\nivar category: Optional[str]\nivar code: str\nivar name: Optional[str]\nivar semantic_type: Optional[str]\nivar system: str\nivar value: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    category: Optional[str] = ..., \n    code: str, \n    name: Optional[str] = ..., \n    semantic_type: Optional[str] = ..., \n    system: str, \n    value: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonGeometryType(str, Enum):\nPOINT = \"Point\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonPropertiesSubType(str, Enum):\nCIRCLE = \"Circle\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeoJsonType(str, Enum):\nFEATURE = \"Feature\"\n\n\nclass azure.healthinsights.clinicalmatching.models.GeographicArea(MutableMapping[str, Any]):\nivar geometry: AreaGeometry\nivar properties: AreaProperties\nivar type: Union[str, GeoJsonType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    geometry: AreaGeometry, \n    properties: AreaProperties, \n    type: Union[str, GeoJsonType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.GeographicLocation(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar country_or_region: str\nivar state: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    country_or_region: str, \n    state: Optional[str] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.InnerError(MutableMapping[str, Any]):\nivar code: str\nivar innererror: Optional[InnerError]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    innererror: Optional[InnerError] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.JobStatus(Enum):\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nPARTIALLY_COMPLETED = \"partiallyCompleted\"\nRUNNING = \"running\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientDocument(MutableMapping[str, Any]):\nivar clinical_type: Optional[Union[str, ClinicalDocumentType]]\nivar content: DocumentContent\nivar created_date_time: Optional[datetime]\nivar id: str\nivar language: Optional[str]\nivar type: Union[str, DocumentType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    clinical_type: Optional[Union[str, ClinicalDocumentType]] = ..., \n    content: DocumentContent, \n    created_date_time: Optional[datetime] = ..., \n    id: str, \n    language: Optional[str] = ..., \n    type: Union[str, DocumentType]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientInfo(MutableMapping[str, Any]):\nivar birth_date: Optional[date]\nivar clinical_info: Optional[List[ForwardRef('ClinicalCodedElement')]]\nivar sex: Optional[Union[str, PatientInfoSex]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    birth_date: Optional[date] = ..., \n    clinical_info: Optional[List[ClinicalCodedElement]] = ..., \n    sex: Optional[Union[str, PatientInfoSex]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientInfoSex(str, Enum):\nFEMALE = \"female\"\nMALE = \"male\"\nUNSPECIFIED = \"unspecified\"\n\n\nclass azure.healthinsights.clinicalmatching.models.PatientRecord(MutableMapping[str, Any]):\nivar data: Optional[List[ForwardRef('PatientDocument')]]\nivar id: str\nivar info: Optional[PatientInfo]\n\n@overload\ndef __init__(\n    self, \n    *, \n    data: Optional[List[PatientDocument]] = ..., \n    id: str, \n    info: Optional[PatientInfo] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.RepeatabilityResultType(str, Enum):\nACCEPTED = \"accepted\"\nREJECTED = \"rejected\"\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherData(MutableMapping[str, Any]):\nivar configuration: Optional[TrialMatcherModelConfiguration]\nivar patients: List[PatientRecord]\n\n@overload\ndef __init__(\n    self, \n    *, \n    configuration: Optional[TrialMatcherModelConfiguration] = ..., \n    patients: List[PatientRecord]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInference(MutableMapping[str, Any]):\nivar confidence_score: Optional[float]\nivar description: Optional[str]\nivar evidence: Optional[List[ForwardRef('TrialMatcherInferenceEvidence')]]\nivar id: Optional[str]\nivar metadata: Optional[ClinicalTrialMetadata]\nivar source: Optional[Union[str, ClinicalTrialSource]]\nivar type: Union[str, TrialMatcherInferenceType]\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence_score: Optional[float] = ..., \n    description: Optional[str] = ..., \n    evidence: Optional[List[TrialMatcherInferenceEvidence]] = ..., \n    id: Optional[str] = ..., \n    metadata: Optional[ClinicalTrialMetadata] = ..., \n    source: Optional[Union[str, ClinicalTrialSource]] = ..., \n    type: Union[str, TrialMatcherInferenceType], \n    value: str\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInferenceEvidence(MutableMapping[str, Any]):\nivar eligibility_criteria_evidence: Optional[str]\nivar importance: Optional[float]\nivar patient_data_evidence: Optional[ClinicalNoteEvidence]\nivar patient_info_evidence: Optional[ClinicalCodedElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    eligibility_criteria_evidence: Optional[str] = ..., \n    importance: Optional[float] = ..., \n    patient_data_evidence: Optional[ClinicalNoteEvidence] = ..., \n    patient_info_evidence: Optional[ClinicalCodedElement] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherInferenceType(Enum):\nTRIAL_ELIGIBILITY = \"trialEligibility\"\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherModelConfiguration(MutableMapping[str, Any]):\nivar clinical_trials: ClinicalTrials\nivar include_evidence: bool\nivar verbose: bool\n\n@overload\ndef __init__(\n    self, \n    *, \n    clinical_trials: ClinicalTrials, \n    include_evidence: bool = True, \n    verbose: bool = False\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherPatientResult(MutableMapping[str, Any]):\nivar id: str\nivar inferences: List[TrialMatcherInference]\nivar needed_clinical_info: Optional[List[ForwardRef('ExtendedClinicalCodedElement')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    id: str, \n    inferences: List[TrialMatcherInference], \n    needed_clinical_info: Optional[List[ExtendedClinicalCodedElement]] = ...\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherResult(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar errors: Optional[List[ForwardRef('Error')]]\nivar expiration_date_time: datetime\nivar job_id: str\nivar last_update_date_time: datetime\nivar results: Optional[TrialMatcherResults]\nivar status: Union[str, JobStatus]\n\n\nclass azure.healthinsights.clinicalmatching.models.TrialMatcherResults(MutableMapping[str, Any]):\nivar knowledge_graph_last_update_date: Optional[date]\nivar model_version: str\nivar patients: List[TrialMatcherPatientResult]\n\n@overload\ndef __init__(\n    self, \n    *, \n    knowledge_graph_last_update_date: Optional[date] = ..., \n    model_version: str, \n    patients: List[TrialMatcherPatientResult]\n)\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any])\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n", "language": "python", "context": "\nDO use extensible enumerations.", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 194, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.AgeUnit(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.AgeUnit(str, Enum):\", \"comment\": \"Enum types should be implemented as extensible enumerations by inheriting from both str and Enum, per the guideline 'python-models-enum-string'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 270, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.ClinicalDocumentType(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.ClinicalDocumentType(str, Enum):\", \"comment\": \"This enum should be extensible; inherit from str along with Enum as recommended by 'python-models-enum-string'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 307, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialAcceptedSex(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialAcceptedSex(str, Enum):\", \"comment\": \"For extensibility, the enum should inherit from str and Enum as per the guideline 'python-models-enum-string'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 393, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialPhase(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialPhase(str, Enum):\", \"comment\": \"Implement the enum as an extensible enumeration by subclassing from str and Enum ('python-models-enum-string').\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 402, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialPurpose(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialPurpose(str, Enum):\", \"comment\": \"Extend the enum by inheriting from str along with Enum, following 'python-models-enum-string'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 415, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialRecruitmentStatus(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialRecruitmentStatus(str, Enum):\", \"comment\": \"This enum should inherit from str and Enum to be extensible, as described in 'python-models-enum-string'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 488, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialSource(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialSource(str, Enum):\", \"comment\": \"For extensibility, implement the enum by inheriting from both str and Enum ('python-models-enum-string').\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 493, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialStudyType(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.ClinicalTrialStudyType(str, Enum):\", \"comment\": \"Change the enum declaration to inherit from str and Enum to comply with 'python-models-enum-string'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 568, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.DocumentContentSourceType(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.DocumentContentSourceType(str, Enum):\", \"comment\": \"To allow for extensibility, the enum should subclass both str and Enum ('python-models-enum-string').\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 573, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.DocumentType(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.DocumentType(str, Enum):\", \"comment\": \"This enum should also be extensible by inheriting from str alongside Enum, as per 'python-models-enum-string'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 720, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.JobStatus(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.JobStatus(str, Enum):\", \"comment\": \"For consistency and extensibility, define the enum by inheriting from str and Enum ('python-models-enum-string').\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 812, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.RepeatabilityResultType(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.RepeatabilityResultType(str, Enum):\", \"comment\": \"$The enum should be made extensible by subclassing both str and Enum, following 'python-models-enum-string'. (general comment)\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 899, \"bad_code\": \"class azure.healthinsights.clinicalmatching.models.TrialMatcherInferenceType(Enum):\", \"suggestion\": \"class azure.healthinsights.clinicalmatching.models.TrialMatcherInferenceType(str, Enum):\", \"comment\": \"Implement this enum as an extensible enumeration by inheriting from str in addition to Enum ('python-models-enum-string').\", \"source\": \"guideline\"}]}"}
{"testcase": "large_apiview_few_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.16), Python version: 3.10.16\n\n\nnamespace azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\n@distributed_trace_async\nasync def analyze_document_async(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AnalyzeResult:\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.aio\n\nclass azure.ai.documentintelligence.aio.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@asyncio.coroutine\ndef get_classifier_old(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails:\n\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failed_count: int\nivar skipped_count: int\nivar succeeded_count: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\nNEURAL = \"neural\"\nTEMPLATE = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "\nDO provide two separate client classes for synchronous and asynchronous operations.  Do not combine async and sync operations in the same class.\n\n```python\n# Yes\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\n# In module azure.example.aio\nclass ExampleClient:\n    # Same method name as sync, different client\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient:\n    def some_service_operation(self, name, size) ...\n\nclass AsyncExampleClient: # No async/async pre/postfix.\n    async def some_service_operation(self, name, size) ...\n\n# No\n# In module azure.example\nclass ExampleClient: # Don't mix'n match with different method names\n    def some_service_operation(self, name, size) ...\n    async def some_service_operation_async(self, name, size) ...\n\n\n```\nDO use the async/await keywords (requires Python 3.5+). Do not use the yield from coroutine or asyncio.coroutine (https://docs.python.org/3.4/library/asyncio-task.html) syntax.", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-client-separate-sync-async\"], \"line_no\": 326, \"bad_code\": \"async def analyze_document_async(self, model_id: str, body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], **kwargs: Any) -> AnalyzeResult\", \"suggestion\": \"Remove this asynchronous method from the synchronous client. Instead, offer an equivalent async method only in the async client located under the azure.ai.documentintelligence.aio namespace.\", \"comment\": \"Synchronous client classes must not mix in async methods. The 'analyze_document_async' method in the sync client violates the guideline for providing separate sync and async clients.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-async-keywords\"], \"line_no\": 937, \"bad_code\": \"    @asyncio.coroutine\", \"suggestion\": \"Replace the use of '@asyncio.coroutine' with an 'async def' definition. For example, remove the decorator and define the method with 'async def get_classifier_old(...):'.\", \"comment\": \"The use of '@asyncio.coroutine' is deprecated; the guidelines require using async/await syntax for asynchronous methods.\", \"source\": \"guideline\"}]}"}
{"testcase": "large_apiview_many_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.16), Python version: 3.10.16\n\nnamespace microsoft.azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\ndef client(self, name, **kwargs) -> DocumentIntelligenceClient\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\n@distributed_trace\ndef process_document(\nself,\nmodel_id,\ndoc_type,\nsource,\nversion,\nlocale,\nformat,\npages,\nfields,\ntimeout\n) -> AnalyzeResult\n\n@distributed_trace\ndef analyze_batch(\nself,\nmodel_id,\nbody,\nfeatures=None,\nlocale=None,\noutput=None\n) -> LROPoller[AnalyzeBatchResult]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.async\n\nclass azure.ai.documentintelligence.async.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.async.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.async.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    api_key: str,\n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failedCount: int\nivar skippedCount: int\nivar succeededCount: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\nneural = \"neural\"\ntemplate = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\nclass DocumentIntelligenceCustomError(Exception):\n    ivar error: str\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "\nDO implement your library as a sub-package of the azure root namespace.\n\nNote: You MUST NOT use microsoft as your root namespace. If you need to include microsoft in the namespace (e.g. because of policy requirements for extensions to other projects such as opentelemetry), you should concatenate it with the package specific namespace with an underscore (e.g. microsoft_myservice). You may still use microsoft-myservice as the distribution package name in this scenario.\nDO provide a get_<child>_client(self, name, **kwargs) method to retrieve a client for the named child. The method must not make a network call to verify the existence of the child.\nYOU SHOULD NOT have methods that require more than five positional parameters. Optional/flag parameters can be accepted using keyword-only arguments, or **kwargs.\n\n\nDO use keyword-only arguments for optional or less-often-used arguments for modules that only need to support Python 3.\n\n```python\n# Yes\ndef foo(a, b, *, c, d=None):\n    # Note that I can even have required keyword-only arguments...\n    ...\n\n```\nDO use an .aio suffix added to the namespace of the sync client for async clients.\n\nExample:\n\n```python\n# Yes:\nfrom azure.exampleservice.aio import ExampleServiceClient\n\n# No: Wrong namespace, wrong client name...\nfrom azure.exampleservice import AsyncExampleServiceClient\n\n```\n\nHere are some examples of namespaces that meet these guidelines:\nazure.storage.blob\nazure.keyvault.certificates\nazure.ai.textanalytics\nazure.mgmt.servicebus\n\nThe asyncio library has been available since Python 3.4, and the async/await keywords were introduced in Python 3.5. Despite such availability, most Python developers aren't familiar with or comfortable using libraries that only provide asynchronous methods.\nDO use the credentials classes in azure-core whenever possible.\nDO use snake_case for variable, function, and method names:\n\n```python\n# Yes:\nservice_client = ServiceClient()\n\nservice_client.list_things()\n\ndef do_something():\n    ...\n\n# No:\nserviceClient = ServiceClient()\n\nservice_client.listThings()\n\ndef DoSomething():\n    ...\n\n```\nDO use UPPERCASE for enum member names.\n\n```python\n\n# Yes\nclass MyGoodEnum(str, Enum):\n    ONE = 'one'\n    TWO = 'two'\n\n# No\nclass MyBadEnum(str, Enum):\n    One = 'one' # No - using PascalCased name.\n    two = 'two' # No - using all lower case name.\n\n```\nDO NOT create new exception types when a built-in exception type (https://docs.python.org/3/library/exceptions.html) will suffice.", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-namespaces-prefix\"], \"line_no\": 3, \"bad_code\": \"namespace microsoft.azure.ai.documentintelligence\", \"suggestion\": \"namespace azure.ai.documentintelligence\", \"comment\": \"The namespace declaration includes a 'microsoft' prefix. According to the guidelines, the library should be implemented as a sub\\u2010package of the azure root namespace (and must not use 'microsoft' as the root namespace).\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-client-hier-vend\"], \"line_no\": 332, \"bad_code\": \"def client(self, name, **kwargs) -> DocumentIntelligenceClient\", \"suggestion\": \"def get_client(self, name, **kwargs) -> DocumentIntelligenceClient\", \"comment\": \"For hierarchical clients the method retrieving a child client should be named with a 'get_' prefix (e.g. get_client) according to the guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-long-args\"], \"line_no\": 629, \"bad_code\": \"def process_document(self, model_id, doc_type, source, version, locale, format, pages, fields, timeout) -> AnalyzeResult\", \"suggestion\": \"def process_document(self, model_id, *, doc_type, source, version, locale, format, pages, fields, timeout) -> AnalyzeResult\", \"comment\": \"The process_document method takes too many positional parameters (nine in total). This violates the guideline that advises against methods requiring more than five positional parameters. Refactor these parameters to be keyword-only.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-optional-args\"], \"line_no\": 643, \"bad_code\": \"def analyze_batch(\", \"suggestion\": \"def analyze_batch(self, model_id, body, *, features=None, locale=None, output=None) -> LROPoller[AnalyzeBatchResult]\", \"comment\": \"Optional parameters in the analyze_batch method should be declared as keyword\\u2011only. This helps improve clarity and conforms to SDK design guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-namespaces-async\"], \"line_no\": 661, \"bad_code\": \"namespace azure.ai.documentintelligence.async\", \"suggestion\": \"namespace azure.ai.documentintelligence.aio\", \"comment\": \"Asynchronous client types should reside in an '.aio' subpackage rather than '.async'. This change conforms with SDK guidelines for async namespacing.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-auth-credential-azure-core\"], \"line_no\": 995, \"bad_code\": \"api_key: str\", \"suggestion\": \"credential: Union[AzureKeyCredential, AsyncTokenCredential]\", \"comment\": \"In the async DocumentIntelligenceClient constructor the parameter is defined as a plain string (api_key: str). The guidelines require using the credential types provided by azure-core (e.g. AzureKeyCredential or AsyncTokenCredential) for authentication.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1427, \"bad_code\": \"ivar failedCount: int\", \"suggestion\": \"ivar failed_count: int\", \"comment\": \"The attribute name 'failedCount' does not follow snake_case conventions. It should be renamed to 'failed_count' to comply with the naming guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1428, \"bad_code\": \"ivar skippedCount: int\", \"suggestion\": \"ivar skipped_count: int\", \"comment\": \"Variable names should use snake_case. 'skippedCount' should be renamed to 'skipped_count'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_implementation.html#python-codestyle-vars-naming\"], \"line_no\": 1429, \"bad_code\": \"ivar succeededCount: int\", \"suggestion\": \"ivar succeeded_count: int\", \"comment\": \"Variable names should use snake_case. 'succeededCount' should be renamed to 'succeeded_count'.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-models-enum-name-uppercase\"], \"line_no\": 1948, \"bad_code\": \"neural = \\\"neural\\\"\", \"suggestion\": \"NEURAL = \\\"neural\\\" (and similarly, use TEMPLATE = \\\"template\\\" for the other member)\", \"comment\": \"Enum member names must be in UPPERCASE. The current definition of DocumentBuildMode uses lower-case member names.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python_design.html#python-errors-use-standard-exceptions\"], \"line_no\": 3160, \"bad_code\": \"class DocumentIntelligenceCustomError(Exception):\", \"suggestion\": \"Consider using an existing exception type from azure-core (for example, subclass AzureError) or a built-in exception if appropriate, rather than creating a new custom exception.\", \"comment\": \"Custom exceptions should be avoided if a standard or azure-core exception type can convey the error, per SDK guidelines.\", \"source\": \"guideline\"}]}"}
{"testcase": "large_apiview_no_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.18), Python version: 3.10.16\n\n\nnamespace azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.aio\n\nclass azure.ai.documentintelligence.aio.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failed_count: int\nivar skipped_count: int\nivar succeeded_count: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\nNEURAL = \"neural\"\nTEMPLATE = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "", "response": "{\"comments\": []}"}
{"testcase": "large_apiview_multiple_same_violations", "query": "# Package is parsed using apiview-stub-generator(version:0.3.18), Python version: 3.10.16\n\n\nnamespace azure.ai.documentintelligence\n\nclass azure.ai.documentintelligence.AnalyzeDocumentLROPoller(LROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: PollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace\ndef authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace\ndef authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@distributed_trace\ndef begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentClassifierDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@overload\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\n@distributed_trace\ndef begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> LROPoller[DocumentModelDetails]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace\ndef get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace\ndef get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace\ndef get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> Iterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> Iterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> Iterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nclass azure.ai.documentintelligence.DocumentIntelligenceClient(DocumentIntelligenceClient): implements ContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, TokenCredential], \n    *, \n    api_version: str = ..., \n    polling_interval: Optional[int] = ..., \n    **kwargs: Any\n) -> None\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeBatchResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@overload\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\n@distributed_trace\ndef begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> LROPoller[AnalyzeResult]\n\ndef close(self) -> None\n\n@distributed_trace\ndef delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace\ndef get_analyze_batch_result(self, continuation_token: str) -> LROPoller[AnalyzeBatchResult]\n\n@distributed_trace\ndef get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> Iterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> Iterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> HttpResponse\n\n\nnamespace azure.ai.documentintelligence.aio\n\nclass azure.ai.documentintelligence.aio.AsyncAnalyzeDocumentLROPoller(AsyncLROPoller[+PollingReturnType_co]):\nproperty details: Mapping[str, Any]    # Read-only\n\n@classmethod\ndef from_continuation_token(\n    cls, \n    polling_method: AsyncPollingMethod[PollingReturnType_co], \n    continuation_token: str, \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceAdministrationClient(DocumentIntelligenceAdministrationClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: AuthorizeClassifierCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_classifier_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_classifier_copy(\n    self, \n    body: Union[AuthorizeClassifierCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ClassifierCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: AuthorizeCopyRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def authorize_model_copy(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@distributed_trace_async\nasync def authorize_model_copy(\n    self, \n    body: Union[AuthorizeCopyRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> ModelCopyAuthorization\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: BuildDocumentClassifierRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_classifier(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_build_classifier(\n    self, \n    body: Union[BuildDocumentClassifierRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: BuildDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_build_document_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_build_document_model(\n    self, \n    body: Union[BuildDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: ComposeDocumentModelRequest, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_compose_model(\n    self, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_compose_model(\n    self, \n    body: Union[ComposeDocumentModelRequest, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: ClassifierCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@distributed_trace_async\nasync def begin_copy_classifier_to(\n    self, \n    classifier_id: str, \n    body: Union[ClassifierCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentClassifierDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: ModelCopyAuthorization, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@overload\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\n@distributed_trace_async\nasync def begin_copy_model_to(\n    self, \n    model_id: str, \n    body: Union[ModelCopyAuthorization, JSON, IO[bytes]], \n    **kwargs: Any\n) -> AsyncLROPoller[DocumentModelDetails]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_classifier(\n    self, \n    classifier_id: str, \n    **kwargs: Any\n) -> DocumentClassifierDetails\n\n@distributed_trace_async\nasync def get_model(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> DocumentModelDetails\n\n@distributed_trace_async\nasync def get_operation(\n    self, \n    operation_id: str, \n    **kwargs: Any\n) -> DocumentIntelligenceOperationDetails\n\n@distributed_trace_async\nasync def get_resource_details(self, **kwargs: Any) -> DocumentIntelligenceResourceDetails\n\n@distributed_trace\ndef list_classifiers(self, **kwargs: Any) -> AsyncIterable[DocumentClassifierDetails]\n\n@distributed_trace\ndef list_models(self, **kwargs: Any) -> AsyncIterable[DocumentModelDetails]\n\n@distributed_trace\ndef list_operations(self, **kwargs: Any) -> AsyncIterable[DocumentIntelligenceOperationDetails]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nclass azure.ai.documentintelligence.aio.DocumentIntelligenceClient(DocumentIntelligenceClient): implements AsyncContextManager \n\ndef __init__(\n    self, \n    endpoint: str, \n    credential: Union[AzureKeyCredential, AsyncTokenCredential], \n    *, \n    api_version: str = ..., \n    **kwargs: Any\n) -> None\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: AnalyzeBatchDocumentsRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def begin_analyze_batch_documents(\n    self, \n    model_id: str, \n    body: Union[AnalyzeBatchDocumentsRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: AnalyzeDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_analyze_document(\n    self, \n    model_id: str, \n    body: Union[AnalyzeDocumentRequest, JSON, IO[bytes]], \n    *, \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    locale: Optional[str] = ..., \n    output: Optional[List[Union[str, AnalyzeOutputOption]]] = ..., \n    output_content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    pages: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncAnalyzeDocumentLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: ClassifyDocumentRequest, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: JSON, \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@overload\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: IO[bytes], \n    *, \n    content_type: str = \"application/json\", \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\n@distributed_trace_async\nasync def begin_classify_document(\n    self, \n    classifier_id: str, \n    body: Union[ClassifyDocumentRequest, JSON, IO[bytes]], \n    *, \n    pages: Optional[str] = ..., \n    split: Optional[Union[str, SplitMode]] = ..., \n    string_index_type: Optional[Union[str, StringIndexType]] = ..., \n    **kwargs: Any\n) -> AsyncLROPoller[AnalyzeResult]\n\nasync def close(self) -> None\n\n@distributed_trace_async\nasync def delete_analyze_batch_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def delete_analyze_result(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> None\n\n@distributed_trace_async\nasync def get_analyze_batch_result(self, continuation_token: str) -> AsyncLROPoller[AnalyzeBatchResult]\n\n@distributed_trace_async\nasync def get_analyze_result_figure(\n    self, \n    model_id: str, \n    result_id: str, \n    figure_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace_async\nasync def get_analyze_result_pdf(\n    self, \n    model_id: str, \n    result_id: str, \n    **kwargs: Any\n) -> AsyncIterator[bytes]\n\n@distributed_trace\ndef list_analyze_batch_results(\n    self, \n    model_id: str, \n    **kwargs: Any\n) -> AsyncIterable[AnalyzeBatchOperation]\n\ndef send_request(\n    self, \n    request: HttpRequest, \n    *, \n    stream: bool = False, \n    **kwargs: Any\n) -> Awaitable[AsyncHttpResponse]\n\n\nnamespace azure.ai.documentintelligence.models\n\nclass azure.ai.documentintelligence.models.AddressValue(MutableMapping[str, Any]):\nivar city: Optional[str]\nivar city_district: Optional[str]\nivar country_region: Optional[str]\nivar house: Optional[str]\nivar house_number: Optional[str]\nivar level: Optional[str]\nivar po_box: Optional[str]\nivar postal_code: Optional[str]\nivar road: Optional[str]\nivar state: Optional[str]\nivar state_district: Optional[str]\nivar street_address: Optional[str]\nivar suburb: Optional[str]\nivar unit: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    city: Optional[str] = ..., \n    city_district: Optional[str] = ..., \n    country_region: Optional[str] = ..., \n    house: Optional[str] = ..., \n    house_number: Optional[str] = ..., \n    level: Optional[str] = ..., \n    po_box: Optional[str] = ..., \n    postal_code: Optional[str] = ..., \n    road: Optional[str] = ..., \n    state: Optional[str] = ..., \n    state_district: Optional[str] = ..., \n    street_address: Optional[str] = ..., \n    suburb: Optional[str] = ..., \n    unit: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchDocumentsRequest(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar overwrite_existing: Optional[bool]\nivar result_container_url: str\nivar result_prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    overwrite_existing: Optional[bool] = ..., \n    result_container_url: str, \n    result_prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperation(MutableMapping[str, Any]):\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar last_updated_date_time: datetime\nivar percent_completed: Optional[int]\nivar result: Optional[AnalyzeBatchResult]\nivar result_id: Optional[str]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    percent_completed: Optional[int] = ..., \n    result: Optional[AnalyzeBatchResult] = ..., \n    result_id: Optional[str] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchOperationDetail(MutableMapping[str, Any]):\nivar error: Optional[DocumentIntelligenceError]\nivar result_url: Optional[str]\nivar source_url: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: Optional[DocumentIntelligenceError] = ..., \n    result_url: Optional[str] = ..., \n    source_url: str, \n    status: Union[str, DocumentIntelligenceOperationStatus]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeBatchResult(MutableMapping[str, Any]):\nivar details: Optional[List[ForwardRef('AnalyzeBatchOperationDetail')]]\nivar failed_count: int\nivar skipped_count: int\nivar succeeded_count: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    details: Optional[List[AnalyzeBatchOperationDetail]] = ..., \n    failed_count: int, \n    skipped_count: int, \n    succeeded_count: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzeOutputOption(Enum):\nFIGURES = \"figures\"\nPDF = \"pdf\"\n\n\nclass azure.ai.documentintelligence.models.AnalyzeResult(MutableMapping[str, Any]):\nivar api_version: str\nivar content: str\nivar content_format: Optional[Union[str, DocumentContentFormat]]\nivar documents: Optional[List[ForwardRef('AnalyzedDocument')]]\nivar figures: Optional[List[ForwardRef('DocumentFigure')]]\nivar key_value_pairs: Optional[List[ForwardRef('DocumentKeyValuePair')]]\nivar languages: Optional[List[ForwardRef('DocumentLanguage')]]\nivar model_id: str\nivar pages: List[DocumentPage]\nivar paragraphs: Optional[List[ForwardRef('DocumentParagraph')]]\nivar sections: Optional[List[ForwardRef('DocumentSection')]]\nivar string_index_type: Union[str, StringIndexType]\nivar styles: Optional[List[ForwardRef('DocumentStyle')]]\nivar tables: Optional[List[ForwardRef('DocumentTable')]]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    content: str, \n    content_format: Optional[Union[str, DocumentContentFormat]] = ..., \n    documents: Optional[List[AnalyzedDocument]] = ..., \n    figures: Optional[List[DocumentFigure]] = ..., \n    key_value_pairs: Optional[List[DocumentKeyValuePair]] = ..., \n    languages: Optional[List[DocumentLanguage]] = ..., \n    model_id: str, \n    pages: List[DocumentPage], \n    paragraphs: Optional[List[DocumentParagraph]] = ..., \n    sections: Optional[List[DocumentSection]] = ..., \n    string_index_type: Union[str, StringIndexType], \n    styles: Optional[List[DocumentStyle]] = ..., \n    tables: Optional[List[DocumentTable]] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AnalyzedDocument(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: float\nivar doc_type: str\nivar fields: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: float, \n    doc_type: str, \n    fields: Optional[Dict[str, DocumentField]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeClassifierCopyRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AuthorizeCopyRequest(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar prefix: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    prefix: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.AzureBlobFileListContentSource(MutableMapping[str, Any]):\nivar container_url: str\nivar file_list: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    container_url: str, \n    file_list: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BoundingRegion(MutableMapping[str, Any]):\nivar page_number: int\nivar polygon: List[float]\n\n@overload\ndef __init__(\n    self, \n    *, \n    page_number: int, \n    polygon: List[float]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentClassifierRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.BuildDocumentModelRequest(MutableMapping[str, Any]):\nivar allow_overwrite: Optional[bool]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Union[str, DocumentBuildMode]\nivar description: Optional[str]\nivar max_training_hours: Optional[float]\nivar model_id: str\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    allow_overwrite: Optional[bool] = ..., \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    build_mode: Union[str, DocumentBuildMode], \n    description: Optional[str] = ..., \n    max_training_hours: Optional[float] = ..., \n    model_id: str, \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_classifier_id: str\nivar target_classifier_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_classifier_id: str, \n    target_classifier_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifierDocumentTypeDetails(MutableMapping[str, Any]):\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar source_kind: Optional[Union[str, ContentSourceKind]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    azure_blob_file_list_source: Optional[AzureBlobFileListContentSource] = ..., \n    azure_blob_source: Optional[AzureBlobContentSource] = ..., \n    source_kind: Optional[Union[str, ContentSourceKind]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ClassifyDocumentRequest(MutableMapping[str, Any]):\nivar bytes_source: Optional[bytes]\nivar url_source: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bytes_source: Optional[bytes] = ..., \n    url_source: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ComposeDocumentModelRequest(MutableMapping[str, Any]):\nivar classifier_id: str\nivar description: Optional[str]\nivar doc_types: Dict[str, DocumentTypeDetails]\nivar model_id: str\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: str, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, DocumentTypeDetails], \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.ContentSourceKind(Enum):\nAZURE_BLOB = \"azureBlob\"\nAZURE_BLOB_FILE_LIST = \"azureBlobFileList\"\nBASE64 = \"base64\"\nURL = \"url\"\n\n\nclass azure.ai.documentintelligence.models.CurrencyValue(MutableMapping[str, Any]):\nivar amount: float\nivar currency_code: Optional[str]\nivar currency_symbol: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    amount: float, \n    currency_code: Optional[str] = ..., \n    currency_symbol: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.CustomDocumentModelsDetails(MutableMapping[str, Any]):\nivar count: int\nivar limit: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    count: int, \n    limit: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentAnalysisFeature(Enum):\nBARCODES = \"barcodes\"\nFORMULAS = \"formulas\"\nKEY_VALUE_PAIRS = \"keyValuePairs\"\nLANGUAGES = \"languages\"\nOCR_HIGH_RESOLUTION = \"ocrHighResolution\"\nQUERY_FIELDS = \"queryFields\"\nSTYLE_FONT = \"styleFont\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcode(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentBarcodeKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentBarcodeKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentBarcodeKind(Enum):\nAZTEC = \"Aztec\"\nCODABAR = \"Codabar\"\nCODE128 = \"Code128\"\nCODE39 = \"Code39\"\nCODE93 = \"Code93\"\nDATA_BAR = \"DataBar\"\nDATA_BAR_EXPANDED = \"DataBarExpanded\"\nDATA_MATRIX = \"DataMatrix\"\nEAN13 = \"EAN13\"\nEAN8 = \"EAN8\"\nITF = \"ITF\"\nMAXI_CODE = \"MaxiCode\"\nMICRO_QR_CODE = \"MicroQRCode\"\nPDF417 = \"PDF417\"\nQR_CODE = \"QRCode\"\nUPCA = \"UPCA\"\nUPCE = \"UPCE\"\n\n\nclass azure.ai.documentintelligence.models.DocumentBuildMode(Enum):\nNEURAL = \"neural\"\nTEMPLATE = \"template\"\n\n\nclass azure.ai.documentintelligence.models.DocumentCaption(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_CLASSIFIER_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentClassifierDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentClassifierDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentClassifierDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar base_classifier_id: Optional[str]\nivar classifier_id: str\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Dict[str, ClassifierDocumentTypeDetails]\nivar expiration_date_time: Optional[datetime]\nivar modified_date_time: Optional[datetime]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: str, \n    base_classifier_id: Optional[str] = ..., \n    classifier_id: str, \n    created_date_time: datetime, \n    description: Optional[str] = ..., \n    doc_types: Dict[str, ClassifierDocumentTypeDetails], \n    expiration_date_time: Optional[datetime] = ..., \n    warnings: Optional[List[DocumentIntelligenceWarning]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentContentFormat(str, Enum):\nMARKDOWN = \"markdown\"\nTEXT = \"text\"\n\n\nclass azure.ai.documentintelligence.models.DocumentField(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar confidence: Optional[float]\nivar content: Optional[str]\nivar spans: Optional[List[ForwardRef('DocumentSpan')]]\nivar type: Union[str, DocumentFieldType]\nivar value_address: Optional[AddressValue]\nivar value_array: Optional[List[ForwardRef('DocumentField')]]\nivar value_boolean: Optional[bool]\nivar value_country_region: Optional[str]\nivar value_currency: Optional[CurrencyValue]\nivar value_date: Optional[date]\nivar value_integer: Optional[int]\nivar value_number: Optional[float]\nivar value_object: Optional[Dict[str, ForwardRef('DocumentField')]]\nivar value_phone_number: Optional[str]\nivar value_selection_group: Optional[List[str]]\nivar value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]]\nivar value_signature: Optional[Union[str, DocumentSignatureType]]\nivar value_string: Optional[str]\nivar value_time: Optional[time]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    confidence: Optional[float] = ..., \n    content: Optional[str] = ..., \n    spans: Optional[List[DocumentSpan]] = ..., \n    type: Union[str, DocumentFieldType], \n    value_address: Optional[AddressValue] = ..., \n    value_array: Optional[List[DocumentField]] = ..., \n    value_boolean: Optional[bool] = ..., \n    value_country_region: Optional[str] = ..., \n    value_currency: Optional[CurrencyValue] = ..., \n    value_date: Optional[date] = ..., \n    value_integer: Optional[int] = ..., \n    value_number: Optional[float] = ..., \n    value_object: Optional[Dict[str, DocumentField]] = ..., \n    value_phone_number: Optional[str] = ..., \n    value_selection_group: Optional[List[str]] = ..., \n    value_selection_mark: Optional[Union[str, DocumentSelectionMarkState]] = ..., \n    value_signature: Optional[Union[str, DocumentSignatureType]] = ..., \n    value_string: Optional[str] = ..., \n    value_time: Optional[time] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldSchema(MutableMapping[str, Any]):\nivar description: Optional[str]\nivar example: Optional[str]\nivar items_schema: Optional[DocumentFieldSchema]\nivar properties: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar type: Union[str, DocumentFieldType]\n\n@overload\ndef __init__(\n    self, \n    *, \n    description: Optional[str] = ..., \n    example: Optional[str] = ..., \n    items_schema: Optional[DocumentFieldSchema] = ..., \n    properties: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    type: Union[str, DocumentFieldType]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFieldType(str, Enum):\nADDRESS = \"address\"\nARRAY = \"array\"\nBOOLEAN = \"boolean\"\nCOUNTRY_REGION = \"countryRegion\"\nCURRENCY = \"currency\"\nDATE = \"date\"\nINTEGER = \"integer\"\nNUMBER = \"number\"\nOBJECT = \"object\"\nPHONE_NUMBER = \"phoneNumber\"\nSELECTION_GROUP = \"selectionGroup\"\nSELECTION_MARK = \"selectionMark\"\nSIGNATURE = \"signature\"\nSTRING = \"string\"\nTIME = \"time\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFigure(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar elements: Optional[List[str]]\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar id: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    elements: Optional[List[str]] = ..., \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    id: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFontStyle(str, Enum):\nITALIC = \"italic\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFontWeight(str, Enum):\nBOLD = \"bold\"\nNORMAL = \"normal\"\n\n\nclass azure.ai.documentintelligence.models.DocumentFootnote(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormula(MutableMapping[str, Any]):\nivar confidence: float\nivar kind: Union[str, DocumentFormulaKind]\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar value: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    kind: Union[str, DocumentFormulaKind], \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    value: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentFormulaKind(str, Enum):\nDISPLAY = \"display\"\nINLINE = \"inline\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceError(MutableMapping[str, Any]):\nivar code: str\nivar details: Optional[List[ForwardRef('DocumentIntelligenceError')]]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    details: Optional[List[DocumentIntelligenceError]] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceErrorResponse(MutableMapping[str, Any]):\nivar error: DocumentIntelligenceError\n\n@overload\ndef __init__(\n    self, \n    *, \n    error: DocumentIntelligenceError\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceInnerError(MutableMapping[str, Any]):\nivar code: Optional[str]\nivar innererror: Optional[DocumentIntelligenceInnerError]\nivar message: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: Optional[str] = ..., \n    innererror: Optional[DocumentIntelligenceInnerError] = ..., \n    message: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar created_date_time: datetime\nivar error: Optional[DocumentIntelligenceError]\nivar kind: str\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: Optional[int]\nivar resource_location: str\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: Optional[Dict[str, str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceOperationStatus(str, Enum):\nCANCELED = \"canceled\"\nFAILED = \"failed\"\nNOT_STARTED = \"notStarted\"\nRUNNING = \"running\"\nSKIPPED = \"skipped\"\nSUCCEEDED = \"succeeded\"\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceResourceDetails(MutableMapping[str, Any]):\nivar custom_document_models: CustomDocumentModelsDetails\n\n@overload\ndef __init__(\n    self, \n    *, \n    custom_document_models: CustomDocumentModelsDetails\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentIntelligenceWarning(MutableMapping[str, Any]):\nivar code: str\nivar message: str\nivar target: Optional[str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    code: str, \n    message: str, \n    target: Optional[str] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValueElement(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentKeyValuePair(MutableMapping[str, Any]):\nivar confidence: float\nivar key: DocumentKeyValueElement\nivar value: Optional[DocumentKeyValueElement]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    key: DocumentKeyValueElement, \n    value: Optional[DocumentKeyValueElement] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLanguage(MutableMapping[str, Any]):\nivar confidence: float\nivar locale: str\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    locale: str, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentLine(MutableMapping[str, Any]):\nivar content: str\nivar polygon: Optional[List[float]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelBuildOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_BUILD]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelComposeOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COMPOSE]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelCopyToOperationDetails(MutableMapping[str, Any]):\nivar api_version: str\nivar created_date_time: datetime\nivar error: DocumentIntelligenceError\nivar kind: Literal[DOCUMENT_MODEL_COPY_TO]\nivar last_updated_date_time: datetime\nivar operation_id: str\nivar percent_completed: int\nivar resource_location: str\nivar result: Optional[DocumentModelDetails]\nivar status: Union[str, DocumentIntelligenceOperationStatus]\nivar tags: dict[str, str]\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    result: Optional[DocumentModelDetails] = ..., \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\n@overload\ndef __init__(\n    self, \n    *, \n    api_version: Optional[str] = ..., \n    created_date_time: datetime, \n    error: Optional[DocumentIntelligenceError] = ..., \n    kind: str, \n    last_updated_date_time: datetime, \n    operation_id: str, \n    percent_completed: Optional[int] = ..., \n    resource_location: str, \n    status: Union[str, DocumentIntelligenceOperationStatus], \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentModelDetails(MutableMapping[str, Any]):\nivar api_version: Optional[str]\nivar azure_blob_file_list_source: Optional[AzureBlobFileListContentSource]\nivar azure_blob_source: Optional[AzureBlobContentSource]\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar classifier_id: Optional[str]\nivar created_date_time: datetime\nivar description: Optional[str]\nivar doc_types: Optional[Dict[str, ForwardRef('DocumentTypeDetails')]]\nivar expiration_date_time: Optional[datetime]\nivar model_id: str\nivar modified_date_time: Optional[datetime]\nivar split: Optional[Union[str, SplitMode]]\nivar tags: Optional[Dict[str, str]]\nivar training_hours: Optional[float]\nivar warnings: Optional[List[ForwardRef('DocumentIntelligenceWarning')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    classifier_id: Optional[str] = ..., \n    description: Optional[str] = ..., \n    model_id: str, \n    split: Optional[Union[str, SplitMode]] = ..., \n    tags: Optional[Dict[str, str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentPage(MutableMapping[str, Any]):\nivar angle: Optional[float]\nivar barcodes: Optional[List[ForwardRef('DocumentBarcode')]]\nivar formulas: Optional[List[ForwardRef('DocumentFormula')]]\nivar height: Optional[float]\nivar lines: Optional[List[ForwardRef('DocumentLine')]]\nivar page_number: int\nivar selection_marks: Optional[List[ForwardRef('DocumentSelectionMark')]]\nivar spans: List[DocumentSpan]\nivar unit: Optional[Union[str, LengthUnit]]\nivar width: Optional[float]\nivar words: Optional[List[ForwardRef('DocumentWord')]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    angle: Optional[float] = ..., \n    barcodes: Optional[List[DocumentBarcode]] = ..., \n    formulas: Optional[List[DocumentFormula]] = ..., \n    height: Optional[float] = ..., \n    lines: Optional[List[DocumentLine]] = ..., \n    page_number: int, \n    selection_marks: Optional[List[DocumentSelectionMark]] = ..., \n    spans: List[DocumentSpan], \n    unit: Optional[Union[str, LengthUnit]] = ..., \n    width: Optional[float] = ..., \n    words: Optional[List[DocumentWord]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentParagraph(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar content: str\nivar role: Optional[Union[str, ParagraphRole]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    content: str, \n    role: Optional[Union[str, ParagraphRole]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSection(MutableMapping[str, Any]):\nivar elements: Optional[List[str]]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    elements: Optional[List[str]] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMark(MutableMapping[str, Any]):\nivar confidence: float\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\nivar state: Union[str, DocumentSelectionMarkState]\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan, \n    state: Union[str, DocumentSelectionMarkState]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentSelectionMarkState(str, Enum):\nSELECTED = \"selected\"\nUNSELECTED = \"unselected\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSignatureType(str, Enum):\nSIGNED = \"signed\"\nUNSIGNED = \"unsigned\"\n\n\nclass azure.ai.documentintelligence.models.DocumentSpan(MutableMapping[str, Any]):\nivar length: int\nivar offset: int\n\n@overload\ndef __init__(\n    self, \n    *, \n    length: int, \n    offset: int\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentStyle(MutableMapping[str, Any]):\nivar background_color: Optional[str]\nivar color: Optional[str]\nivar confidence: float\nivar font_style: Optional[Union[str, DocumentFontStyle]]\nivar font_weight: Optional[Union[str, DocumentFontWeight]]\nivar is_handwritten: Optional[bool]\nivar similar_font_family: Optional[str]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    background_color: Optional[str] = ..., \n    color: Optional[str] = ..., \n    confidence: float, \n    font_style: Optional[Union[str, DocumentFontStyle]] = ..., \n    font_weight: Optional[Union[str, DocumentFontWeight]] = ..., \n    is_handwritten: Optional[bool] = ..., \n    similar_font_family: Optional[str] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTable(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar caption: Optional[DocumentCaption]\nivar cells: List[DocumentTableCell]\nivar column_count: int\nivar footnotes: Optional[List[ForwardRef('DocumentFootnote')]]\nivar row_count: int\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    caption: Optional[DocumentCaption] = ..., \n    cells: List[DocumentTableCell], \n    column_count: int, \n    footnotes: Optional[List[DocumentFootnote]] = ..., \n    row_count: int, \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCell(MutableMapping[str, Any]):\nivar bounding_regions: Optional[List[ForwardRef('BoundingRegion')]]\nivar column_index: int\nivar column_span: Optional[int]\nivar content: str\nivar elements: Optional[List[str]]\nivar kind: Optional[Union[str, DocumentTableCellKind]]\nivar row_index: int\nivar row_span: Optional[int]\nivar spans: List[DocumentSpan]\n\n@overload\ndef __init__(\n    self, \n    *, \n    bounding_regions: Optional[List[BoundingRegion]] = ..., \n    column_index: int, \n    column_span: Optional[int] = ..., \n    content: str, \n    elements: Optional[List[str]] = ..., \n    kind: Optional[Union[str, DocumentTableCellKind]] = ..., \n    row_index: int, \n    row_span: Optional[int] = ..., \n    spans: List[DocumentSpan]\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentTableCellKind(str, Enum):\nCOLUMN_HEADER = \"columnHeader\"\nCONTENT = \"content\"\nDESCRIPTION = \"description\"\nROW_HEADER = \"rowHeader\"\nSTUB_HEAD = \"stubHead\"\n\n\nclass azure.ai.documentintelligence.models.DocumentTypeDetails(MutableMapping[str, Any]):\nivar build_mode: Optional[Union[str, DocumentBuildMode]]\nivar confidence_threshold: Optional[float]\nivar description: Optional[str]\nivar features: Optional[List[Union[str, ForwardRef('DocumentAnalysisFeature')]]]\nivar field_confidence: Optional[Dict[str, float]]\nivar field_schema: Optional[Dict[str, ForwardRef('DocumentFieldSchema')]]\nivar max_documents_to_analyze: Optional[int]\nivar model_id: Optional[str]\nivar query_fields: Optional[List[str]]\n\n@overload\ndef __init__(\n    self, \n    *, \n    build_mode: Optional[Union[str, DocumentBuildMode]] = ..., \n    confidence_threshold: Optional[float] = ..., \n    description: Optional[str] = ..., \n    features: Optional[List[Union[str, DocumentAnalysisFeature]]] = ..., \n    field_confidence: Optional[Dict[str, float]] = ..., \n    field_schema: Optional[Dict[str, DocumentFieldSchema]] = ..., \n    max_documents_to_analyze: Optional[int] = ..., \n    model_id: Optional[str] = ..., \n    query_fields: Optional[List[str]] = ...\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.DocumentWord(MutableMapping[str, Any]):\nivar confidence: float\nivar content: str\nivar polygon: Optional[List[float]]\nivar span: DocumentSpan\n\n@overload\ndef __init__(\n    self, \n    *, \n    confidence: float, \n    content: str, \n    polygon: Optional[List[float]] = ..., \n    span: DocumentSpan\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.LengthUnit(str, Enum):\nINCH = \"inch\"\nPIXEL = \"pixel\"\n\n\nclass azure.ai.documentintelligence.models.ModelCopyAuthorization(MutableMapping[str, Any]):\nivar access_token: str\nivar expiration_date_time: datetime\nivar target_model_id: str\nivar target_model_location: str\nivar target_resource_id: str\nivar target_resource_region: str\n\n@overload\ndef __init__(\n    self, \n    *, \n    access_token: str, \n    expiration_date_time: datetime, \n    target_model_id: str, \n    target_model_location: str, \n    target_resource_id: str, \n    target_resource_region: str\n) -> None\n\n@overload\ndef __init__(self, mapping: Mapping[str, Any]) -> None\n\ndef __init__(\n    self, \n    *args: Any, \n    **kwargs: Any\n) -> None\n\n\nclass azure.ai.documentintelligence.models.OperationKind(str, Enum):\nDOCUMENT_CLASSIFIER_BUILD = \"documentClassifierBuild\"\nDOCUMENT_CLASSIFIER_COPY_TO = \"documentClassifierCopyTo\"\nDOCUMENT_MODEL_BUILD = \"documentModelBuild\"\nDOCUMENT_MODEL_COMPOSE = \"documentModelCompose\"\nDOCUMENT_MODEL_COPY_TO = \"documentModelCopyTo\"\n\n\nclass azure.ai.documentintelligence.models.ParagraphRole(str, Enum):\nFOOTNOTE = \"footnote\"\nFORMULA_BLOCK = \"formulaBlock\"\nPAGE_FOOTER = \"pageFooter\"\nPAGE_HEADER = \"pageHeader\"\nPAGE_NUMBER = \"pageNumber\"\nSECTION_HEADING = \"sectionHeading\"\nTITLE = \"title\"\n\n\nclass azure.ai.documentintelligence.models.SplitMode(str, Enum):\nAUTO = \"auto\"\nNONE = \"none\"\nPER_PAGE = \"perPage\"\n\n\nclass azure.ai.documentintelligence.models.StringIndexType(str, Enum):\nTEXT_ELEMENTS = \"textElements\"\nUNICODE_CODE_POINT = \"unicodeCodePoint\"\nUTF16_CODE_UNIT = \"utf16CodeUnit\"\n", "language": "python", "context": "\nDO use extensible enumerations.", "response": "{\"comments\": [{\"rule_ids\": [\"python_design.html#python-models-enum-string\"], \"line_no\": 1448, \"bad_code\": \"class azure.ai.documentintelligence.models.AnalyzeOutputOption(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.AnalyzeOutputOption(str, Enum):\", \"comment\": \"Enums in the SDK should be extensible by inheriting from str as well as Enum. This allows for flexible comparisons and future extensions.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1811, \"bad_code\": \"class azure.ai.documentintelligence.models.ContentSourceKind(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.ContentSourceKind(str, Enum):\", \"comment\": \"Enums should extend str to adhere to the guideline of using extensible enumerations in the SDK.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1864, \"bad_code\": \"class azure.ai.documentintelligence.models.DocumentAnalysisFeature(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.DocumentAnalysisFeature(str, Enum):\", \"comment\": \"Enums should extend str to adhere to the guideline of using extensible enumerations in the SDK.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1902, \"bad_code\": \"class azure.ai.documentintelligence.models.DocumentBarcodeKind(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.DocumentBarcodeKind(str, Enum):\", \"comment\": \"Enum members should be based on str to ensure extensibility and compliance with SDK guidelines.\", \"source\": \"guideline\"}, {\"rule_ids\": [\"python-models-enum-string\"], \"line_no\": 1922, \"bad_code\": \"class azure.ai.documentintelligence.models.DocumentBuildMode(Enum):\", \"suggestion\": \"class azure.ai.documentintelligence.models.DocumentBuildMode(str, Enum):\", \"comment\": \"For consistency and extensibility, enums should inherit from str alongside Enum.\", \"source\": \"guideline\"}]}"}