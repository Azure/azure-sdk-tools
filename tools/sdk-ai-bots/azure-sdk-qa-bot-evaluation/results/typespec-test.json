[
    {
        "testcase": "Guidance on cross version breaking change for readonly and async operations in new api-versions",
        "expected": {
            "answer": "The 'provisioningState' change in the PATCH request model seems like a bug fix if this field was always read-only.  When you get a breaking change review, if this is explained with an appropriate comment, this is likely to be justified as a bug fix.\nOn changing PATCH to synchronous.  ARM does support async PATCH operations, although REST API Guidelines discourage async PATCH operations.  If this operation is synchronous in the previous stable version, then this change is a real breaking change that you will need to justify in breaking change review.\nSimilarly, making PUT and DELETE Asynchronous is a breaking change if these operations were synchronous in the previous stable version is a real breaking change, and you will need to justify the change in a breaking change review.",
            "references": [
                {
                    "title": "ARM Resource Types | Designing Resource-specific Properties",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/arm/resource-type"
                },
                {
                    "title": "How can I change the operation template of an operation in newer versions | Workaround",
                    "link": "https://azure.github.io/typespec-azure/docs/troubleshoot/versioning_operation_template_changes"
                },
                {
                    "title": "Versioning | Simple Scenarios | Converting an Operation from Synchronous to Asynchronous",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/arm/versioning"
                },
                {
                    "title": "Azure Versioning and Breaking Changes Policy V1.3.2 | 1. Policy Overview and Motivation | 1.1 Motivation",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "Your understanding is mostly correct, but there are important Azure API and TypeSpec versioning best practices to follow for both readonly field handling and LRO introduction:\n\n1. **Readonly Field (`provisioningState`) in Patch Model and Breaking Change Flag**:\n- According to Azure guidelines, removing a readonly property (like `provisioningState`) from a PATCH (update) model should NOT be considered a breaking change, because PATCH request bodies should only include updatable (writable) properties. Readonly properties are not expected in PATCH request payloads, and their presence in PATCH models in previous versions is likely a modeling bug.\n- If your PATCH model in previous versions included `provisioningState` as readonly, you should remove it in the new version. This is a bug fix, not a breaking change. The breaking change tooling may flag this, but you can safely ignore this violation for readonly fields in PATCH models. Document this in your PR and, if required, request an exemption from the breaking change board, referencing the Azure guidelines.\n\n2. **Introducing LRO (Long-Running Operations) in New API Versions**:\n- Changing a synchronous operation to an LRO (asynchronous) operation in a new API version is allowed, but you must version the operation correctly to avoid breaking changes for existing clients.\n- The recommended approach is to use the `@sharedRoute` decorator on both the old (sync) and new (LRO) operations, and use `@removed` and `@added` decorators to version the operation implementation. This ensures that the old API versions continue to expose the synchronous operation, while the new API version exposes the LRO.\n- Example pattern:\n\n```typespec\n@sharedRoute\n@removed(Versions.v2025_12_01_preview)\n@renamedFrom(Versions.v2025_12_01_preview, \"createOrUpdate\")\ncreateOrUpdateSync is ArmResourceCreateOrReplaceSync<Configuration>;\n\n@sharedRoute\n@added(Versions.v2025_12_01_preview)\ncreateOrUpdate is ArmResourceCreateOrReplaceAsync<Configuration>;\n```\n\n- This pattern ensures that the route remains the same, but the operation implementation changes only in the new version. See the [TypeSpec Azure guidance on versioning operation template changes](https://azure.github.io/typespec-azure/docs/troubleshoot/versioning_operation_template_changes).\n\n**Summary of Guidance:**\n- Removing readonly fields from PATCH models is a bug fix, not a breaking change. Document this and request an exemption if needed.\n- For LRO introduction, use `@sharedRoute`, `@removed`, `@added`, and `@renamedFrom` decorators to version the operation template change. This avoids breaking changes for existing clients and aligns with Azure API guidelines.\n\nIf you follow these patterns, you will be compliant with Azure API and TypeSpec best practices, and the breaking change flags can be safely addressed as described.",
            "references": [
                {
                    "title": "How can I change the operation template of an operation in newer versions | Workaround",
                    "link": "https://azure.github.io/typespec-azure/docs/troubleshoot/versioning_operation_template_changes"
                },
                {
                    "title": "Need advice on how to change operation parameters on a breaking change | answer",
                    "link": ""
                },
                {
                    "title": "Resolving OpenAPI Breaking Change Violations | Migrating ARM Specifications | Visibility Changes for `nextLink` and `value` Properties",
                    "link": "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange"
                },
                {
                    "title": "Azure Versioning and Breaking Changes Policy V1.3.2 | 1. Policy Overview and Motivation | 1.1 Motivation",
                    "link": ""
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, accurately and completely reflecting the context, with no unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is mostly complete, accurately covering the readonly field removal and LRO introduction/versioning, but it misses the explicit statement that changing PATCH/PUT/DELETE from sync to async is a real breaking change requiring justification.",
        "reference_match": 0.5,
        "reference_match_result": "fail",
        "knowledge_match": 0.76,
        "knowledge_match_result": "fail",
        "overall_score": 7.859999999999999
    },
    {
        "testcase": "What decorator should be used in this case?",
        "expected": {
            "answer": "it should be `typedChangedFrom(v2, model1)` here otherwise you are saying in v1 you changed from using model1 to model2 which then of course doesn't exists",
            "references": [
                {
                    "title": "What decorator should be used in this case? | answer",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "You should use the @typeChangedFrom decorator, but the version argument must be the version where the change occurs (v2), not the version where the old type was used (v1). The correct usage is:\n\n```\n@added(v1)\nmodel1;\n\n@added(v2)\nmodel2;\n\n@added(v1)\nfeatureA {\n  @typeChangedFrom(v2, model1)\n  body: model2;\n}\n```\n\nThis tells TypeSpec that in v2 (and later), the type of 'body' changed from model1 to model2. The error you saw happens because your original code said the change happened in v1, but model2 doesn't exist in v1. Always use the version where the new type is introduced as the first argument to @typeChangedFrom.",
            "references": [
                {
                    "title": "What decorator should be used in this case? | answer",
                    "link": ""
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, complete, and directly supported by the CONTEXT, with no omissions or unsupported additions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, including the correct decorator usage, the reasoning behind it, and the consequences of incorrect usage.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.8666666666666667,
        "knowledge_match_result": "pass",
        "overall_score": 8.866666666666667
    },
    {
        "testcase": "Hi team, could someone please help grant me permission to view the workflow for my Azure REST API PR?",
        "expected": {
            "answer": "You need to get the necessary permissions, see here: https://aka.ms/azsdk/access",
            "references": [
                {
                    "title": "Hi team, could someone please help grant me permission to view the workflow for my Azure REST API PR? | answer",
                    "link": ""
                },
                {
                    "title": "How to Re-evaluate `SDK Validation Status` Check",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation"
                }
            ]
        },
        "actual": {
            "answer": "You are unable to view the workflow and validation check details for your Azure REST API PR because you do not have the necessary permissions. To resolve this, you need to:\n\n1. Ensure your GitHub account is a member of the Azure organization and that your membership is set to public (not private).\n2. Request access by following the instructions at https://aka.ms/azsdk/access. This will guide you through joining the appropriate Azure SDK groups and setting up your permissions.\n\nOnce you have the correct permissions and your membership is public, you will be able to view workflow logs and validation errors for your PRs, allowing you to debug and verify your changes before final review.",
            "references": [
                {
                    "title": "Hi team, could someone please help grant me permission to view the workflow for my Azure REST API PR? | answer",
                    "link": ""
                },
                {
                    "title": "PR gateway pipelines not starting/waiting for long time | answer",
                    "link": ""
                },
                {
                    "title": "How to Re-evaluate `SDK Validation Status` Check",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The response is fully supported by the context, covers all necessary steps, and does not add unsupported information or omit critical details.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all the necessary information from the ground truth and expands on it with helpful, relevant details, but does not omit any required information.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 1.0,
        "knowledge_match_result": "pass",
        "overall_score": 9.0
    },
    {
        "testcase": "Service under conversation label",
        "expected": {
            "answer": "The label should not impact your previous PR, and , if this is a later api-version thatn the conversion PR, the conversion would normally be based on that version once checked in.",
            "references": [
                {
                    "title": "Service under conversation label | answer",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "The 'service-under-conversion' label does not indicate a delay in merging your stable API PR. The label is informational and should not impact your previous PR. If your stable API PR is for a later API version than the TypeSpec migration PR, the migration will typically be based on the latest version once it is checked in. You do not need to make additional changes solely because of this label. Continue following the standard PR review and merge process for your stable API PR.",
            "references": [
                {
                    "title": "Service under conversation label | answer",
                    "link": ""
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": NaN,
        "groundedness_result": NaN,
        "groundedness_threshold": NaN,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response fully and accurately reflects all statements in the ground truth without missing any key information.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.8,
        "knowledge_match_result": "pass",
        "overall_score": NaN
    },
    {
        "testcase": "Design question about suppression rules",
        "expected": {
            "answer": "suppression can only be provided inline for now. Linter rules can be disabled globally but that would apply to the whole project, can't filter by files",
            "references": [
                {
                    "title": "Swagger LintDiff validation for certain models | question",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "Currently, TypeSpec only supports inline suppressions for linter rules within the TypeSpec source code. There is no mechanism to package suppressions with a definitions package such that they apply only to the imported definitions and not to the rest of the consumer's project. Linter rules can be disabled globally, but this would affect the entire project, not just the imported definitions. Therefore, if you want to suppress specific linter rules for your shared definitions, you must do so inline in the TypeSpec code itself. There is no supported way to scope suppressions to only the imported definitions without impacting the consumer's broader project linting.",
            "references": [
                {
                    "title": "Swagger LintDiff validation for certain models | question",
                    "link": ""
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": "",
        "groundedness_result": "unknown",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all the necessary and relevant information from the ground truth, accurately and thoroughly representing each statement.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.8888888888888888,
        "knowledge_match_result": "pass",
        "overall_score": NaN
    },
    {
        "testcase": "what's typespec",
        "expected": {
            "answer": "TypeSpec is a language and toolset developed by Microsoft for defining APIs and data models in a structured, reusable, and extensible way. It is similar to TypeScript in syntax, but is specifically designed for describing the shape and behavior of APIs (such as REST, gRPC, or GraphQL), not for general-purpose programming.\nTypeSpec allows you to:\nDefine the interface of your API, including operations, request/response models, and error handling.\nGenerate artifacts such as OpenAPI (Swagger) specifications, SDKs, and documentation from a single source of truth.\nEnforce API design consistency and reduce errors, especially in large organizations or when following strict guidelines (like Azure's API standards).\nReuse and extend models and patterns using TypeSpec libraries and templates.\nFor Azure, TypeSpec has dedicated extensions and libraries that help you follow Azure API guidelines and make it easier to build ARM (Azure Resource Manager) and data-plane services. Using TypeSpec leads to APIs that are easier to review, more consistent, and better supported by tooling.\nYou can get started by installing the TypeSpec CLI and using templates to quickly scaffold a project. For more information, see the official documentation linked below.",
            "references": [
                {
                    "title": "What is TypeSpec?",
                    "link": "https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec"
                },
                {
                    "title": "Getting Started with TypeSpec For REST APIs | Introduction | What is TypeSpec?",
                    "link": "https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax"
                },
                {
                    "title": "Introduction",
                    "link": "https://azure.github.io/typespec-azure/docs/intro"
                }
            ]
        },
        "actual": {
            "answer": "TypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. TypeSpec is used to define the interface of your API, including operations, request and response models, and error handling mechanisms. From these definitions, TypeSpec can generate code, documentation, OpenAPI specifications, and other artifacts, making it easier to maintain and evolve your services. TypeSpec is the new standard API definition language for Azure, and its usage is mandatory for all new Azure data plane and management plane services. It offers benefits such as consistency across APIs, efficiency, enhanced tooling, and accessibility for both technical and non-technical stakeholders.",
            "references": [
                {
                    "title": "What is TypeSpec?",
                    "link": "https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec"
                },
                {
                    "title": "Getting Started with TypeSpec For REST APIs | Introduction | What is TypeSpec?",
                    "link": "https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax"
                },
                {
                    "title": "Introduction",
                    "link": "https://azure.github.io/typespec-azure/docs/intro"
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE accurately and completely reflects the information in the CONTEXT, without adding unsupported details or omitting critical points.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The Response contains most of the necessary and relevant information but misses several minor and moderately important details about syntax, extensibility, Azure-specific libraries, and getting started. It is mostly complete but not perfect.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.9166666666666666,
        "knowledge_match_result": "pass",
        "overall_score": 7.916666666666667
    },
    {
        "testcase": "How to reserve \"x-ms-discriminator-value\"",
        "expected": {
            "answer": "Let's address both of your issues with the TypeSpec migration and generated Swagger:\n1. Missing x-ms-discriminator-value and presence of discriminator:\nYes, this is by design. The TypeSpec emitter uses the standard OpenAPI 3 discriminator property, not the Azure-specific x-ms-discriminator-value. The @discriminator decorator in TypeSpec results in the discriminator field in the generated OpenAPI, as per the latest OpenAPI and Azure SDK standards. This approach provides better compatibility with code generators and client SDKs. The use of x-ms-discriminator-value is not needed when the discriminator field is present and correctly configured.\nSee the TypeSpec documentation and Azure guidelines for more.\n2. Duplicate objectType property in generated Swagger:\nThis is a known limitation of how inheritance and discriminator are currently handled in TypeSpec to OpenAPI conversion. If both the base (AzureBackupRestoreRequest) and the derived model (AzureBackupRecoveryPointBasedRestoreRequest) define the objectType property, OpenAPI will reflect both in the derived model, leading to apparent duplication.\nThis does not cause functional issues, but it can be confusing. The current best practice is to only define the discriminator property (objectType) in the base model and set its value in the derived models, rather than redefining the property. In TypeSpec, this would look like:\n```\n@discriminator(\"objectType\")\nmodel AzureBackupRestoreRequest {\nobjectType: string;\n// ... other properties ...\n}\nmodel AzureBackupRecoveryPointBasedRestoreRequest extends AzureBackupRestoreRequest {\nobjectType: \"AzureBackupRecoveryPointBasedRestoreRequest\";\nrecoveryPointId: string;\n}\n```\nThis way, the objectType property is only defined in the base model, and the derived model just sets its value. This should prevent duplication in the emitted Swagger.\nAction Items:\nRefactor your TypeSpec so that only the base model defines the discriminator property (objectType), and the derived models assign its value.\nDo not worry about x-ms-discriminator-value not being present: it is not required when the standard discriminator property is used.",
            "references": [
                {
                    "title": "Generated Types | Models | Discriminator",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/08types"
                },
                {
                    "title": "OpenAPI v3 emitter | Model Composition | Extends Keyword",
                    "link": "https://typespec.io/docs/emitters/openapi3/openapi"
                },
                {
                    "title": "Built-in Decorators | TypeSpec | `@discriminator`",
                    "link": "https://typespec.io/docs/standard-library/built-in-decorators"
                }
            ]
        },
        "actual": {
            "answer": "1. **About `x-ms-discriminator-value` vs. `discriminator`:**\n\nThis is by design. TypeSpec emits the standard OpenAPI `discriminator` property (see the `@discriminator` decorator), which is the current OpenAPI 3.x way to represent polymorphism. The legacy `x-ms-discriminator-value` extension is not generated by TypeSpec emitters, as it is not required for modern Azure SDKs or OpenAPI tooling. Azure guidelines now recommend using the standard `discriminator` property, and the TypeSpec-to-OpenAPI emitters do not output `x-ms-discriminator-value` ([see references]).\n\n2. **About duplicate `objectType` property:**\n\nThis is a modeling issue in your TypeSpec. When you use `extends` and both the base (`AzureBackupRestoreRequest`) and derived (`AzureBackupRecoveryPointBasedRestoreRequest`) models declare the same property (`objectType`), the generated OpenAPI will include `objectType` in both the base and derived schemas, resulting in duplication. \n\n**How to fix:**\n- Only declare `objectType` in the base model (`AzureBackupRestoreRequest`).\n- In the derived model, set the discriminator value by assigning a string literal to `objectType`, e.g.:\n\n```typespec\n@discriminator(\"objectType\")\nmodel AzureBackupRestoreRequest {\n  objectType: string;\n  // ... other properties ...\n}\n\nmodel AzureBackupRecoveryPointBasedRestoreRequest extends AzureBackupRestoreRequest {\n  objectType: \"AzureBackupRecoveryPointBasedRestoreRequest\";\n  recoveryPointId: string;\n}\n```\n\nThis pattern ensures that:\n- The base model defines the discriminator property.\n- Each derived model sets the discriminator property to a unique literal value, which will be reflected in the generated OpenAPI as the discriminator mapping.\n- No duplicate `objectType` property appears in the generated OpenAPI.\n\n**Summary:**\n- The absence of `x-ms-discriminator-value` is by design; use the standard `discriminator` property.\n- Avoid duplicate properties by only declaring the discriminator property in the base model and assigning a literal value in derived models.\n\nThis approach is fully aligned with Azure API guidelines and TypeSpec best practices.",
            "references": [
                {
                    "title": "Built-in Decorators | TypeSpec | `@discriminator`",
                    "link": "https://typespec.io/docs/standard-library/built-in-decorators"
                },
                {
                    "title": "TypeSpec for OpenAPI Developers | Schema Object | allOf and polymorphism using allOf",
                    "link": "https://typespec.io/docs/getting-started/typespec-for-openapi-dev"
                },
                {
                    "title": "Generated Types | Models | Discriminator",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/08types"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, accurate, and complete, directly supported by the context and documentation provided.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is fully complete, accurately and thoroughly reflecting all necessary information from the ground truth without omissions.",
        "reference_match": 0.6666666666666666,
        "reference_match_result": "fail",
        "knowledge_match": 0.6923076923076923,
        "knowledge_match_result": "fail",
        "overall_score": 8.35897435897436
    },
    {
        "testcase": "Does Typespec has any decorator to set customzed `final-state-via` for LRO API?",
        "expected": {
            "answer": "Yes, TypeSpec provides a decorator for setting a customized `final-state-via` value for long-running operation (LRO) APIs. You should use the `@Azure.Core.useFinalStateVia decorator` on your operation to explicitly specify the desired final state resolution strategy. The decorator supports values such as \"original-uri\", \"operation-location\", \"location\", and \"azure-async-operation\". For example:\n```\n@Azure.Core.useFinalStateVia(\"original-uri\")\nop createResource is ArmResourceCreateOrReplaceAsync<ResourceModel>;\n```\nThis will ensure the generated OpenAPI includes the correct `x-ms-long-running-operation-options` with your chosen `final-state-via setting`. This approach fully aligns with Azure REST API and ARM guidelines for LRO patterns.",
            "references": [
                {
                    "title": "Decorators | Azure.Core | `@useFinalStateVia` {#@Azure.Core.useFinalStateVia}",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/decorators"
                },
                {
                    "title": "Only \"final-state-via\": \"location\" need to been changed to \"final-state-via\": \"azure-async-operation\" | answer",
                    "link": "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange"
                }
            ]
        },
        "actual": {
            "answer": "Yes, TypeSpec provides a decorator to set a customized `final-state-via` value for Long Running Operation (LRO) APIs. You should use the `@Azure.Core.useFinalStateVia` decorator from the Azure.Core library. This decorator allows you to specify the desired value for `final-state-via` on an operation. The supported values are: \"original-uri\", \"operation-location\", \"location\", and \"azure-async-operation\".\n\nExample usage:\n\n```typespec\n@Azure.Core.useFinalStateVia(\"azure-async-operation\")\nop myLroOperation(...): ...;\n```\n\nThis will ensure that the generated OpenAPI (Swagger) includes the correct `x-ms-long-running-operation-options` with your specified `final-state-via` value for the operation. This is the recommended and supported way to customize LRO final state behavior in Azure TypeSpec.",
            "references": [
                {
                    "title": "Decorators | Azure.Core | `@useFinalStateVia` {#@Azure.Core.useFinalStateVia}",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/decorators"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, complete, and directly supported by the CONTEXT, with no omissions or unsupported additions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, with only minor differences in example details and phrasing, but no missing claims or statements.",
        "reference_match": 0.5,
        "reference_match_result": "fail",
        "knowledge_match": 0.8518518518518519,
        "knowledge_match_result": "pass",
        "overall_score": 8.351851851851851
    },
    {
        "testcase": "Brownfield TypeSpec migration",
        "expected": {
            "answer": "Migration to TypeSpec for existing services is not yet mandatory, but it is suggested, and teams should be planning for it in Bromine and Krypton\nServices must wholly switch to TypeSpec, there is no allowed mixing of hand-written and generated swagger\nServicesmust conform to a single, unified api-version for their service, servicesthat currently use different api-versions for parts of their service are going to need to plan for conformance -this either means SDK splitting or version uniformity.  Teams that use this 'different api-versions for different resources in the same sdk' pattern are not good candidates for conversion at the moment\nIn generally, the more compliant your service is to the RPC and best practices, the easier conversion will be\nThere is documentation on converting here: [Getting started | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started/)",
            "references": [
                {
                    "title": "What is TypeSpec?",
                    "link": "https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec"
                },
                {
                    "title": "Brownfield TypeSpec migration | answer",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "There is a required timeframe for brownfield Resource Providers (RPs) to migrate from OpenAPI Swagger to TypeSpec. Brownfield services must transition to TypeSpec Azure by March 30, 2026. Starting in Q4 FY26, pull requests for new API versions that are not based on TypeSpec will be blocked, and SDK releases from non-TypeSpec specs will also be blocked. This is to ensure a consistent, high-quality developer experience across Azure that aligns with Azure SDK guidelines.\n\nIt is NOT allowed to mix TypeSpec with handwritten Swagger during migration. Services must wholly switch to TypeSpec; partial migration (such as migrating one resource type at a time and mixing TypeSpec with hand-authored Swagger) is not permitted. All API versions for a service must be unified under TypeSpec, and services using different API versions for different resources will need to plan for conformance, either by splitting SDKs or ensuring version uniformity. The migration must be planned and executed as a complete switch, not in incremental phases mixing the two specification formats.\n\nYou are encouraged to start planning your migration now. There are tools and documentation to assist with the migration process, but the final TypeSpec must be reviewed, corrected, and optimized by hand to ensure compliance.",
            "references": [
                {
                    "title": "What is TypeSpec?",
                    "link": "https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec"
                },
                {
                    "title": "Brownfield TypeSpec migration | answer",
                    "link": ""
                },
                {
                    "title": "Getting started with TypeSpec migration",
                    "link": "https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started"
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": NaN,
        "groundedness_result": NaN,
        "groundedness_threshold": NaN,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is mostly complete, covering the main requirements and prohibitions, but it misstates the mandatory status and omits some minor details about candidate suitability and best practices.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.782608695652174,
        "knowledge_match_result": "fail",
        "overall_score": NaN
    },
    {
        "testcase": "Unable to apply client flatten to a top level resource property.",
        "expected": {
            "answer": "Add\n@@Azure.ClientGenerator.Core.Legacy.flattenProperty(ArcSettings.propeties)\nBy convention put this in a back-compatible.tsp file.",
            "references": [
                {
                    "title": "Decorators | Azure.ClientGenerator.Core.Legacy | @flattenProperty",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators"
                },
                {
                    "title": "no-openapi | Decorators and their alternatives",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi"
                },
                {
                    "title": "additional  \"x-ms-client-flatten\": true | answer",
                    "link": "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange"
                },
                {
                    "title": "TypeSpec ARM Model Mapping to Swagger Documentation | 37. ProxyResource | TypeSpec Example",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "To represent `x-ms-client-flatten: true` for a top-level resource property (such as the `properties` bag in a ProxyResource) in TypeSpec, you should use the `@Azure.ClientGenerator.Core.Legacy.flattenProperty` decorator on the `properties` field. This decorator is the direct TypeSpec equivalent for the OpenAPI `x-ms-client-flatten` extension.\n\nHere's how you can update your TypeSpec model:\n\n```typespec\n/**\n * ArcSetting details.\n */\n@parentResource(Cluster)\nmodel ArcSetting is Azure.ResourceManager.ProxyResource<ArcSettingProperties> {\n  ...ResourceNameParameter;\n\n  @doc(\"ArcSetting properties.\")\n  @Azure.ClientGenerator.Core.Legacy.flattenProperty\n  properties: ArcSettingProperties;\n}\n```\n\n**Implications for the SDK if the flag is missing:**\n- If you omit the `@flattenProperty` decorator, the generated OpenAPI will not include `x-ms-client-flatten: true` on the `properties` field. This means that SDKs generated from this spec will not flatten the `properties` bag into the top-level resource model. As a result, SDK users will have to access resource-specific properties via an extra `.properties` object, which is a breaking change from the previous SDK experience if flattening was present before.\n- To maintain backward compatibility for existing SDKs, you must ensure the flattening behavior is preserved by using the decorator as shown above.\n\n**Note:** The `@Azure.ClientGenerator.Core.Legacy.flattenProperty` decorator is intended for migration and back-compat scenarios. For new (greenfield) services, you should avoid using it and follow the latest Azure Resource Manager modeling patterns.",
            "references": [
                {
                    "title": "Decorators | Azure.ClientGenerator.Core.Legacy | `@flattenProperty`",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators"
                },
                {
                    "title": "no-openapi | Decorators and their alternatives",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi"
                },
                {
                    "title": "additional  \"x-ms-client-flatten\": true | answer",
                    "link": "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully accurate, complete, and directly supported by the CONTEXT without any unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains almost all the necessary information, including the decorator usage and its implications, but misses the specific file placement convention.",
        "reference_match": 0.5,
        "reference_match_result": "fail",
        "knowledge_match": 0.8571428571428571,
        "knowledge_match_result": "pass",
        "overall_score": 7.957142857142856
    },
    {
        "testcase": "In Resource provider, what is the type I should declare for an object or dictionary of string, string?",
        "expected": {
            "answer": "For a property in a TypeSpec ARM resource provider model that represents a dictionary (object) mapping strings to strings, you should use the built-in `Record<string>` type.\nFor example:\n```\nmodel MyResourceProperties {\nmetadata?: Record<string>;\n}\n```\nThis models a property (`metadata`) that is an object/dictionary where all keys and values are strings, equivalent to `{ [key: string]: string }` in TypeScript or `Dictionary<string, string>` in .NET.\nYou should not use `{}` (empty model) or just `Record` (without specifying the value type) as these are either incomplete or invalid in TypeSpec. The correct, type-safe way is `Record<string>`, which will be emitted to OpenAPI/Swagger as an `object` with `additionalProperties: { type: \"string\" }`.\nIf your API spec review asks for a 'model', you can define a named type:\n```\nmodel MetadataModel is Record<string>;\nmodel MyResourceProperties {\nmetadata?: MetadataModel;\n}\n```\nBut `Record<string>` is the canonical, recommended approach for a string-to-string dictionary in TypeSpec ARM resource definitions.\nNote: While this is technically correct, ARM guidelines recommend against unbounded dictionary/object types unless absolutely necessary, as they can limit Azure Policy and ARG capabilities. Use with care, and document any supported/expected keys in your @doc comments if possible.",
            "references": [
                {
                    "title": "bad-record-type",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/bad-record-type"
                },
                {
                    "title": "Built-in types | Other core types",
                    "link": "https://typespec.io/docs/language-basics/built-in-types"
                },
                {
                    "title": "Generated Types | Models | Models with additional properties of any type",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/08types"
                }
            ]
        },
        "actual": {
            "answer": "In Azure Resource Provider TypeSpec, when you want to represent a property that is a dictionary (object) with string keys and string values (e.g., for metadata or tags), you should use `Record<string>`. This is the correct and recommended way to declare such a type in TypeSpec. \n\nFor example:\n\n```typespec\nmodel MyResourceProperties {\n  metadata?: Record<string>;\n}\n```\n\n- Do NOT use `{}` (empty object) as a type; TypeSpec expects a model or a valid type.\n- Do NOT use just `Record;` (without a type argument), as `Record` is a generic type and requires a value type argument.\n- `Record<string>` means an object with arbitrary string keys and string values, which matches the typical JSON object structure for metadata or tags in Azure APIs.\n\nThis pattern is widely used in Azure Resource Manager specs for properties like `tags` and `metadata`.\n\nIf you want to require the property, omit the `?` (optional marker):\n\n```typespec\nmodel MyResourceProperties {\n  metadata: Record<string>;\n}\n```\n\nThis will emit the correct OpenAPI schema for an object with string keys and string values.",
            "references": [
                {
                    "title": "bad-record-type",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/bad-record-type"
                },
                {
                    "title": "Built-in types | Other core types",
                    "link": "https://typespec.io/docs/language-basics/built-in-types"
                },
                {
                    "title": "Usages for Illustrates various of dictionaries. | Scenario: Template to have dictionary operations",
                    "link": "https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/type/dictionary/main.tsp"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully supported by the CONTEXT, includes all essential details, and does not add unsupported information or omit critical points.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is mostly complete, covering all major technical points and examples, but omits minor details about the named model alternative and ARM guidelines for unbounded dictionaries.",
        "reference_match": 0.6666666666666666,
        "reference_match_result": "fail",
        "knowledge_match": 0.8518518518518519,
        "knowledge_match_result": "pass",
        "overall_score": 8.118518518518519
    },
    {
        "testcase": "ArmResourceActionSync how to get x-ms-pageable ?",
        "expected": {
            "answer": "To add the `x-ms-pageable` extension (with `nextLinkName: \"nextLink\"`) to your TypeSpec operation, you should use the `@list` decorator on your operation. This will ensure that the generated OpenAPI/Swagger includes the correct `x-ms-pageable` extension, as required by Azure ARM and API guidelines.\nHere's how you should modify your TypeSpec:\n```\n@list\n@get\n@action(\"elasticvolumes\")\nlistVolumes is ArmResourceActionSync<\nElasticSnapshotPolicy,\nvoid,\nElasticSnapshotPolicyVolumeList\n>;\nmodel ElasticSnapshotPolicyVolumeList is Azure.Core.Page<ElasticSnapshotPolicyVolume>;\n```\nThe `@list` decorator is what triggers the addition of `x-ms-pageable` in the generated OpenAPI.\nYour model should use the standard ARM paging model, which is `Azure.Core.Page<T>`. This will ensure you have the required `value` and `nextLink` properties, and that `nextLink` is correctly annotated.\nAfter adding `@list`, the generated Swagger/OpenAPI will include:\n```\n\"x-ms-pageable\": {\n\"nextLinkName\": \"nextLink\"\n}\n```\nIf you have a custom response model, make sure it uses the `@pageItems` and `@nextLink` decorators:\n```\nmodel ElasticSnapshotPolicyVolumeList {\n@pageItems\nvalue: ElasticSnapshotPolicyVolume[];\n@nextLink\nnextLink?: string;\n}\n```\nSummary:\nAdd `@list` to your operation.\nUse the ARM paging model or annotate your custom model with `@pageItems` and `@nextLink`.\nNo need to manually add the `x-ms-pageable` extension via `@extension`\u2014the emitter handles this for you when `@list` is present.\nThis approach is fully compliant with Azure API guidelines and will resolve your `XmsPageableForListCalls` lintDiff finding.",
            "references": [
                {
                    "title": "missing `x-ms-pageable` for paging operation | answer",
                    "link": "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange"
                },
                {
                    "title": "Pagination | Basics",
                    "link": "https://typespec.io/docs/standard-library/pagination"
                },
                {
                    "title": "Same response model is used both in pageable operation and non-pageable operation | answer",
                    "link": "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange"
                }
            ]
        },
        "actual": {
            "answer": "To ensure your ArmResourceActionSync operation emits the `x-ms-pageable` extension with `nextLinkName: \"nextLink\"`, you must decorate the operation with the `@list` decorator. This is required by both the TypeSpec standard library and Azure API guidelines for pageable operations.\n\nYour current response model is correct (`Azure.Core.Page<T>` includes `nextLink`), but the `@list` decorator is what triggers the emission of `x-ms-pageable` in the generated OpenAPI/Swagger.\n\nHere's how you should update your TypeSpec code:\n\n```typespec\n/**\n * Get elastic volumes associated with elastic snapshot policy\n */\n@get\n@action(\"elasticvolumes\")\n@list // <-- This is required for x-ms-pageable\n@added(Versions.v2025_09_01_preview)\nlistVolumes is ArmResourceActionSync<\n  ElasticSnapshotPolicy,\n  void,\n  ElasticSnapshotPolicyVolumeList\n>;\n\nmodel ElasticSnapshotPolicyVolumeList is Azure.Core.Page<ElasticVolume>;\n```\n\nThis will ensure the generated operation includes:\n\n```json\n\"x-ms-pageable\": {\n  \"nextLinkName\": \"nextLink\"\n}\n```\n\n**Summary:**\n- The `@list` decorator is required on the operation to emit `x-ms-pageable`.\n- The response model should use `Azure.Core.Page<T>` (or equivalent) with a `nextLink` property.\n- This approach is fully aligned with Azure Resource Manager and REST API guidelines.\n\nIf you are still not seeing `x-ms-pageable`, ensure you are using the latest TypeSpec packages and templates as required by your repo.",
            "references": [
                {
                    "title": "missing `x-ms-pageable` for paging operation | answer",
                    "link": "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange"
                },
                {
                    "title": "Pagination | Basics",
                    "link": "https://typespec.io/docs/standard-library/pagination"
                },
                {
                    "title": "Using Page Model from Library",
                    "link": "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/mustread"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": "",
        "groundedness_result": "unknown",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is mostly complete, accurately reflecting the main guidance and steps, but misses minor details about custom model annotation and emitter behavior.",
        "reference_match": 0.6666666666666666,
        "reference_match_result": "fail",
        "knowledge_match": 0.9310344827586207,
        "knowledge_match_result": "pass",
        "overall_score": NaN
    },
    {
        "testcase": "Should I add a visibilityFilter to a model",
        "expected": {
            "answer": "ou do not need to explicitly add a visibilityFilter or use @withVisibility(Lifecycle.Read) if your model is only used as the return result of an operation. TypeSpec's HTTP library and standard emitters automatically apply Lifecycle.Read visibility to properties when a model is used as a return type. By default, properties are included in the response if they have Lifecycle.Read visibility, and all properties have all visibilities enabled unless you restrict them with @visibility.\nTherefore, unless you have properties with more restrictive visibilities, all properties will be included in the response by default. If you want to limit which properties are returned, you should annotate those properties with @visibility(Lifecycle.Read) or other appropriate modifiers, but you do not need to explicitly use a visibilityFilter just because a model is a response type.\nIf you use the built-in Lifecycle visibility model as intended, the behavior you expect is implicit and handled automatically for response models.",
            "references": [
                {
                    "title": "Operations | Automatic visibility",
                    "link": "https://typespec.io/docs/libraries/http/operations"
                },
                {
                    "title": "Visibility | Lifecycle visibility",
                    "link": "https://typespec.io/docs/language-basics/visibility"
                },
                {
                    "title": "Built-in Decorators | TypeSpec | @withVisibility",
                    "link": "https://typespec.io/docs/standard-library/built-in-decorators"
                }
            ]
        },
        "actual": {
            "answer": "You do NOT need to add a visibility filter (such as @withVisibilityFilter or @withVisibility(Lifecycle.Read)) to a model just because it is only used as a return result of an operation. This behavior is implicit in TypeSpec when using the standard HTTP library and the Lifecycle visibility system.\n\nWhen a model is used as the return type of an operation, the TypeSpec HTTP library and emitters (such as OpenAPI) automatically apply the Lifecycle.Read visibility filter. This means only properties marked with @visibility(Lifecycle.Read) (or with no explicit visibility, which defaults to all visibilities) will be included in the response schema. You only need to explicitly set @visibility(Lifecycle.Read) on properties that should be read-only (i.e., only appear in responses, not in requests).\n\nExplicit use of @withVisibilityFilter or @withVisibility is only necessary if you want to create a custom view of a model for a specific purpose, or if you are not using the standard HTTP library and automatic visibility handling. For typical Azure REST API scenarios, rely on the implicit behavior and just decorate properties as needed.",
            "references": [
                {
                    "title": "Operations | Automatic visibility",
                    "link": "https://typespec.io/docs/libraries/http/operations"
                },
                {
                    "title": "Built-in Decorators | TypeSpec | @withVisibility",
                    "link": "https://typespec.io/docs/standard-library/built-in-decorators"
                },
                {
                    "title": "Visibility | Lifecycle visibility",
                    "link": "https://typespec.io/docs/language-basics/visibility"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": "",
        "groundedness_result": "unknown",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is mostly complete, covering all major points from the ground truth, with only minor omissions in explicitness about default property visibility.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.8695652173913043,
        "knowledge_match_result": "pass",
        "overall_score": NaN
    },
    {
        "testcase": "Model validations are failing although am referring from common-types",
        "expected": {
            "answer": "Looking at your PR, it seems that the avocado error is the only remaining one - this is just reporting that you have removed an API.  If you do not need to continue supporting the older preview, you might consider removing it,  otherwise, this is an error you can safely suppress (https://aka.ms/ci-fix is a great link to remember, as it has links to all kinds of useful info about ci errors, including a link to the suppression guides).\nFor PrivateEndpointConnections, RPs have done both, as the name of the private endpoint connection type doesn't really matter to the API, however, there is a new template that greatly simplifies adding private endpoint connection operations to any resourc,e see:\n[typespec-azure/packages/samples/specs/resource-manager/resource-types/private-endpoints/private-end\u2026](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/resource-types/private-endpoints/private-endpoints.tsp#L69-L94)\n```\nmodel PrivateEndpointConnection is PrivateEndpointConnectionResource;\nalias PrivateEndpointOperations = PrivateEndpoints<PrivateEndpointConnection>;\n@armResourceOperations\ninterface Employees {\nget is ArmResourceRead<Employee>;\ncreateOrUpdate is ArmResourceCreateOrReplaceAsync<Employee>;\nupdate is ArmCustomPatchSync<\nEmployee,\nAzure.ResourceManager.Foundations.ResourceUpdateModel<Employee, EmployeeProperties>\n>;\ndelete is ArmResourceDeleteSync<Employee>;\nlistByResourceGroup is ArmResourceListByParent<Employee>;\nlistBySubscription is ArmListBySubscription<Employee>;\n/** A sample resource action that move employee to different location */\nmove is ArmResourceActionSync<Employee, MoveRequest, MoveResponse>;\n/** A sample HEAD operation to check resource existence */\ncheckExistence is ArmResourceCheckExistence<Employee>;\ngetPrivateEndpointConnection is PrivateEndpointOperations.Read<Employee>;\ncreateOrUpdatePrivateEndpointConnection is PrivateEndpointOperations.CreateOrUpdateAsync<Employee>;\nupdatePrivateEndpointConnection is PrivateEndpointOperations.CustomPatchAsync<Employee>;\ndeletePrivateEndpointConnection is PrivateEndpointOperations.DeleteAsync<Employee>;\nlistPrivateEndpointConnections is PrivateEndpointOperations.ListByParent<Employee>;\n}\n```\nSee here for the Avocado error.  We need to find a better way to handle intentionally removed APIs in Avocado.\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#known-issues",
            "references": [
                {
                    "title": "Data types | Azure.ResourceManager.CommonTypes | `PrivateEndpointConnection`",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types"
                },
                {
                    "title": "TypeSpec Azure.ResourceManager.CommonTypes Models Mapping to Swagger Documentation | 42. PrivateEndpointConnection | Description",
                    "link": ""
                },
                {
                    "title": "Swagger LintDiff validation for certain models | question",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "1. **Model Validation Error (Additional properties not allowed: groupIds, privateLinkServiceConnectionState, privateEndpoint, provisioningState):**\n\nThis error occurs because your `PrivateEndpointConnection` model is not correctly referencing the properties from the Azure common-types definition. The properties `groupIds`, `privateLinkServiceConnectionState`, `privateEndpoint`, and `provisioningState` are part of the standard `PrivateEndpointConnectionProperties` in `Azure.ResourceManager.CommonTypes`.\n\n**How to fix:**\n- You should use the Azure TypeSpec template for private endpoint connections instead of manually defining the model. This ensures your model structure matches the common-types definition and passes validation.\n- The recommended pattern is:\n\n```typespec\nimport \"@azure-tools/typespec-azure-resource-manager\";\n\nmodel PrivateEndpointConnection is Azure.ResourceManager.CommonTypes.PrivateEndpointConnection {}\n```\n\n- If you need to add parameters, use the spread operator for `PrivateEndpointConnectionParameter` as shown in the template, but do not redefine or omit the properties from `PrivateEndpointConnectionProperties`.\n- The resource name (`PrivateEndpointConnection`) can be retained as is or aliased (e.g., `PrivateEndpointConnectionResource`). The name does not affect the API contract as long as the model structure matches the common-types definition. This is a matter of local convention or reviewer guidance, but using the template is preferred for consistency and maintainability.\n\n2. **Avocado Error (API removal):**\n\nThe Avocado error is reporting that you have removed an API (`revokeCertificate`) and added a new one (`revokeCertificates`).\n\n**How to fix:**\n- If you do not need to support the old API version, you can remove the old version entirely from your TypeSpec and Swagger. This is the cleanest approach.\n- If you must keep the old version for backward compatibility, you should use TypeSpec versioning decorators like `@added` and `@removed` to indicate when APIs are introduced or removed. This will help the pipeline understand the intended API surface for each version.\n- If the Avocado error is only about the removal and you have handled versioning correctly, you can suppress the error as documented in the [Avocado known issues guide](https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#known-issues). However, you should always prefer to fix the TypeSpec validation first before suppressing errors.\n\n**Summary:**\n- Use the Azure TypeSpec template for private endpoint connections to avoid model validation errors.\n- The resource name can be retained or customized; it does not affect validation if the structure is correct.\n- For Avocado errors due to API removal, use versioning decorators or remove the old API if not needed; suppress only if necessary and after validation passes.",
            "references": [
                {
                    "title": "Data types | Azure.ResourceManager.CommonTypes | `PrivateEndpointConnection`",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types"
                },
                {
                    "title": "Data types | Azure.ResourceManager.CommonTypes | `PrivateEndpointConnectionProperties`",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types"
                },
                {
                    "title": "TypeSpec Azure.ResourceManager.CommonTypes Models Mapping to Swagger Documentation | 42. PrivateEndpointConnection | Description",
                    "link": ""
                },
                {
                    "title": "Swagger LintDiff validation for certain models | question",
                    "link": ""
                },
                {
                    "title": "Swagger LintDiff validation for certain models | question",
                    "link": ""
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": "",
        "groundedness_result": "unknown",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all relevant information from the ground truth, accurately and thoroughly, without missing any key statements or claims.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.9310344827586207,
        "knowledge_match_result": "pass",
        "overall_score": NaN
    },
    {
        "testcase": "Missing APIs in default tag error for typespec conversion PR",
        "expected": {
            "answer": "Part of the typespec conversion is replacing the existing swagger with a generated swagger.  The generated swagger is still used for some purposes, and Avocado protects the ability to process it. The generated swagger needs to be equivalent, but not necessarily identical.  Generally these issues reflected in the swagger will also show up in breaking change checks, which will have to be resolved (or suppressed if they are false positives)",
            "references": [
                {
                    "title": "Known Issues",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado"
                },
                {
                    "title": "Missing APIs in default tag error for typespec conversion PR | answer",
                    "link": ""
                },
                {
                    "title": "Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221 | answer",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "There is no direct way to suppress the 'missing APIs in default tag' (Avocado) check only for a TypeSpec conversion PR. The Avocado check is designed to ensure that the generated Swagger (OpenAPI) from your TypeSpec is equivalent to the previous version, as the generated Swagger is still used for validation and downstream tooling. Any differences, including missing APIs, will be flagged\u2014even if your PR only contains TypeSpec conversion and no manual OpenAPI changes.\n\nIf the missing APIs are intentional (for example, you are intentionally removing deprecated APIs as part of the migration), you must follow the standard breaking change process and request approval from the breaking change board. If the differences are false positives or due to known tool limitations, you may request a temporary suppression by adding the 'Approved-Avocado' label to your PR, but this requires coordination with the Avocado/tooling team and is not a self-service option.\n\nIn summary, you cannot suppress this check yourself for a single PR. You must:\n- Ensure your TypeSpec-generated Swagger is equivalent to the previous version, or\n- Work with the breaking change board or Avocado team for approval if the differences are intentional or false positives.\n\nFor more details, see the Avocado known issues and suppression process documentation.",
            "references": [
                {
                    "title": "Known Issues",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado"
                },
                {
                    "title": "Missing APIs in default tag error for typespec conversion PR | answer",
                    "link": ""
                },
                {
                    "title": "Suppress validation failures on a PR",
                    "link": "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions"
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully supported by the CONTEXT, covers all essential details, and does not introduce unsupported information or omit critical points.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is mostly complete, covering the main points about Avocado checks, equivalence, breaking change process, and suppression, but misses minor details about equivalence not requiring identity and explicit replacement of Swagger.",
        "reference_match": 0.6666666666666666,
        "reference_match_result": "fail",
        "knowledge_match": 0.8275862068965517,
        "knowledge_match_result": "pass",
        "overall_score": 7.494252873563219
    },
    {
        "testcase": "ArmResourcePatchAsync & discriminator",
        "expected": {
            "answer": "we generally suggest that PATCH requests over discriminated types should require the discriminator property.  This may result in some lintdiff violations, but that is expected, and those cna be suppressed.  This is especially true if, as most services, your PATCH operation would need the discriminator value on the wire to determine how to apply the PATCH request to the existing reosurce.",
            "references": [
                {
                    "title": "TypeSpec for OpenAPI Developers | Schema Object | allOf and polymorphism using allOf",
                    "link": "https://typespec.io/docs/getting-started/typespec-for-openapi-dev"
                },
                {
                    "title": "TypeSpec ARM Operation Mapping to Swagger Documentation | 23. ArmResourcePatchAsync | TypeSpec Example",
                    "link": ""
                },
                {
                    "title": "Interfaces and Operations | Azure.ResourceManager | ArmResourcePatchAsync",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/interfaces"
                },
                {
                    "title": "TypeSpec for OpenAPI Developers | Schema Object | Polymorphism using anyOf and oneOf (OAS3)",
                    "link": "https://typespec.io/docs/getting-started/typespec-for-openapi-dev"
                }
            ]
        },
        "actual": {
            "answer": "When using ArmResourcePatchAsync for a resource with a discriminator (polymorphic resource), you must ensure that the PATCH request body schema includes all required properties, especially the discriminator property. The OBJECT_MISSING_REQUIRED_PROPERTY_DEFINITION error from oav typically means the PATCH schema is missing the discriminator property, which is required for correct deserialization and validation.\n\nIn TypeSpec, the PATCH request body is generated from the resource's properties model. For polymorphic resources, you should:\n\n1. Use the @discriminator decorator on your base model and ensure all derived models set the discriminator property as a required string literal.\n2. When defining the PATCH operation, use ArmResourcePatchAsync<Resource, ResourceProperties> (or ArmCustomPatchAsync if you need a custom PATCH shape).\n3. Make sure the PATCH request body model includes the discriminator property as required. If your PATCH model omits the discriminator, OpenAPI and oav will fail validation.\n\nExample:\n\n```typespec\n@discriminator(\"kind\")\nmodel HostProperties {\n  kind: string;\n  // ... other properties\n}\n\nmodel WindowsHostProperties extends HostProperties {\n  kind: \"Windows\";\n  // ... windows-specific properties\n}\n\nmodel LinuxHostProperties extends HostProperties {\n  kind: \"Linux\";\n  // ... linux-specific properties\n}\n\nmodel Host is TrackedResource<HostProperties> {}\n\n@armResourceOperations\ninterface Hosts {\n  update is ArmResourcePatchAsync<Host, HostProperties>;\n}\n```\n\nThis ensures the PATCH request body includes the discriminator property (\"kind\") as required, satisfying both OpenAPI and oav validation. If you use a PATCH model that omits the discriminator, you will get OBJECT_MISSING_REQUIRED_PROPERTY_DEFINITION.\n\nIf you need to allow partial updates and want the discriminator to be optional in PATCH, this is not allowed by Azure API guidelines: the discriminator must always be present for polymorphic models in PATCH bodies.\n\n**Summary:**\n- Always include the discriminator property as required in your PATCH request body model for resources with polymorphism.\n- Use @discriminator and ensure all derived types set the discriminator property.\n- Use ArmResourcePatchAsync with the correct properties model.\n\nThis approach is fully compliant with Azure ARM and OpenAPI guidelines.",
            "references": [
                {
                    "title": "TypeSpec for OpenAPI Developers | Schema Object | allOf and polymorphism using allOf",
                    "link": "https://typespec.io/docs/getting-started/typespec-for-openapi-dev"
                },
                {
                    "title": "Patch Resource # | Rules ## | General impact of violating the rules ###",
                    "link": "https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/patch-resource.md"
                },
                {
                    "title": "TypeSpec for OpenAPI Developers | Schema Object | Polymorphism using anyOf and oneOf (OAS3)",
                    "link": "https://typespec.io/docs/getting-started/typespec-for-openapi-dev"
                },
                {
                    "title": "TypeSpec ARM Operation Mapping to Swagger Documentation | 23. ArmResourcePatchAsync | TypeSpec Example",
                    "link": ""
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded in the CONTEXT, accurately and thoroughly conveying all essential information about PATCH operations for polymorphic resources, including the need for a required discriminator property and the use of TypeSpec features. No unsupported additions or omissions are present.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is mostly complete, covering all major points about requiring the discriminator property in PATCH requests for discriminated types, but it misses the minor detail about lintdiff violations and their suppression.",
        "reference_match": 0.75,
        "reference_match_result": "fail",
        "knowledge_match": 0.8076923076923077,
        "knowledge_match_result": "pass",
        "overall_score": 7.5576923076923075
    },
    {
        "testcase": "CI Failure \u2013 Swagger LintDiff",
        "expected": {
            "answer": "if you are fixing bugs already in main, this is expected.  lintdiff needs to run on your spec both before and after your PR, and if before is crashing, the PR to fix it will still crash.",
            "references": [
                {
                    "title": "CI Failure \u2013 Swagger LintDiff | question",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "This error is expected when you are fixing bugs that already exist in the main branch. The Swagger LintDiff check works by running on your spec both before and after your PR. If the 'before' state (main branch) is already broken (for example, missing input files or invalid configuration), then your PR to fix it will still show the same error because LintDiff cannot run the comparison. \n\nTo resolve this, ensure that the main branch is fixed first so that LintDiff can successfully run on both the base and your PR branch. Once the main branch is healthy, your PR should pass the LintDiff check if your changes are correct. This is not a configuration bug in your PR, but a limitation of how LintDiff operates when the baseline is already failing.",
            "references": [
                {
                    "title": "CI Failure \u2013 Swagger LintDiff",
                    "link": ""
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": "",
        "groundedness_result": "unknown",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all the necessary and relevant information from the ground truth, with some additional helpful context, and does not miss any key statements.",
        "reference_match": 0.0,
        "reference_match_result": "fail",
        "knowledge_match": 0.9259259259259259,
        "knowledge_match_result": "pass",
        "overall_score": NaN
    },
    {
        "testcase": "PR gateway pipelines not starting/waiting for long time",
        "expected": {
            "answer": "Looks like a permissions issue.  The PR author needs to make their membership in Azure public, not private.  And also join the Azure SDK Partners group.\nhttps://aka.ms/azsdk/access\nhttps://github.com/orgs/Azure/people?query=AbhishekSinha-AEP",
            "references": [
                {
                    "title": "PR gateway pipelines not starting/waiting for long time | answer",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "This issue is most likely caused by a permissions problem with the PR author. For the Azure REST API specs pipelines (including SDK Validation Status and Swagger PrettierCheck) to run and report status, the PR author must:\n\n1. Make their membership in the Azure GitHub organization public (not private).\n2. Join the Azure SDK Partners group to get the necessary permissions.\n\nYou can verify and update your membership visibility here: https://github.com/orgs/Azure/people?query=AbhishekSinha-AEP\n\nAnd request access or check your status here: https://aka.ms/azsdk/access\n\nOnce these steps are completed, the required pipelines should start and report status, unblocking your PR merge. If you have already done this and the issue persists, please allow some time for permissions to propagate, or try closing and reopening the PR after updating your membership.",
            "references": [
                {
                    "title": "PR gateway pipelines not starting/waiting for long time | answer",
                    "link": ""
                },
                {
                    "title": "SDK-Validation.md | How to Re-evaluate `SDK Validation Status` Check",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded in the CONTEXT, accurately restating the cause and solution, and does not introduce unsupported details or omit critical information.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, with no missing statements or claims.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.8461538461538461,
        "knowledge_match_result": "pass",
        "overall_score": 8.846153846153847
    },
    {
        "testcase": "RPaaSMaster branch requirement for Ring 0 services",
        "expected": {
            "answer": "Based on the available knowledge context, syncing API specs between the public 'main' branch and the private 'RPaaSMaster' branch is the responsibility of the spec owner. There is no strict requirement in the referenced documentation that all resource providers (including ring 0 services like Microsoft.Compute) must have their specs present in RPaaSMaster if they have received an explicit exemption from RPaaS onboarding. The documentation and FAQ state that if your service is not onboarded to RPaaS (and has an exception), you do not need to merge your specs into RPaaSMaster. The presence or absence of Microsoft.Compute in RPaaSMaster does not dictate requirements for other RPs; each spec owner is responsible for their own onboarding and branch sync according to their onboarding status and exemptions. If your ring 0 service has an approved exception, you can continue to manage your specs in 'main' and do not need to merge into RPaaSMaster unless instructed otherwise by the ARM or EngSys team.",
            "references": [
                {
                    "title": "PR in azure-rest-api-specs-pr/main branch isnt merged to RPSaasMaster | answer",
                    "link": ""
                },
                {
                    "title": "API-Spec-Review-FAQ.md",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ"
                }
            ]
        },
        "actual": {
            "answer": "If your service has received an explicit exception from onboarding to RPaaS, you are not required to merge your API spec into the RPaaSMaster branch before merging to the main branch in the public repository. The requirement to sync specs between main and RPaaSMaster is generally for services that are onboarded to RPaaS. Since you are a ring 0 service with an onboarding exception, and as you observed with Microsoft.Compute (another ring 0 RP not present in RPaaSMaster), you are exempt from this requirement. You should follow the standard process for main branch PRs and ensure you comply with any other guidance provided for ring 0 services.",
            "references": [
                {
                    "title": "PR in azure-rest-api-specs-pr/main branch isnt merged to RPSaasMaster | answer",
                    "link": ""
                },
                {
                    "title": "API-Spec-Review-FAQ.md",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": NaN,
        "groundedness_result": NaN,
        "groundedness_threshold": NaN,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is mostly complete, covering the main requirements and exemptions, but misses minor details about spec owner responsibility and conditional instructions from ARM/EngSys.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.7777777777777778,
        "knowledge_match_result": "fail",
        "overall_score": NaN
    },
    {
        "testcase": "Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221",
        "expected": {
            "answer": "Based on the information provided and the knowledge context, the Avocado CI failure in your PR (https://github.com/Azure/azure-rest-api-specs/pull/36221) is expected because the Compute service currently has multiple API versions in its default tag, which violates the Uniform Versioning Principle. The Avocado check (MULTIPLE_API_VERSION) was recently made a blocking error to enforce this policy.\nTo temporarily suppress this failure and unblock your PR, you can add the Approved-Avocado label to your PR. However, this is only a one-time suppression and should be done if:\nThere is an ongoing discussion and plan to resolve the uniform versioning issue for Compute.\nYou or your team are aware that this is a temporary measure and are working towards compliance.\nImportant: Regular use of this suppression is discouraged. The long-term solution is to restructure your API versions so all components under Compute adopt a uniform versioning scheme, or split into independent services as outlined in the Uniform Versioning Violation Guide.\nIf you are not aware of any ongoing discussion or plan for resolution, you should reach out to azversioning@service.microsoft.com for guidance.",
            "references": [
                {
                    "title": "Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221 | question",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "You do not need to suppress CI failures for your PR to a feature branch, as no checks are required at this stage. However, when you attempt to merge to the main branch, you may encounter a blocking error due to the Avocado check, specifically the MULTIPLE_API_VERSION rule. This rule was changed from a warning to an error as of 7/1/2025 and is a blocker for TypeSpec conversion, which is a critical Azure-wide initiative.\n\nTo address this, you should:\n1. Review the guidance on handling multiple API versions and uniform versioning violations: https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#multiple_api_version\n2. If your PR is blocked due to this error, consult the Uniform Versioning Violation Guide for resolution steps.\n3. If you believe your service requires a one-time suppression, contact azversioning@service.microsoft.com for approval.\n\nSuppression is not recommended as a permanent solution. The preferred approach is to resolve the versioning issue according to the guidelines. Only request a one-time suppression if you have a valid justification and cannot resolve the issue immediately.",
            "references": [
                {
                    "title": "Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221 | answer",
                    "link": ""
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully supported by the CONTEXT, includes all essential details, and does not add unsupported information or omit critical points.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is mostly complete, covering the main points about the error, suppression, and long-term resolution, but omits some specific details and context found in the ground truth.",
        "reference_match": 0.0,
        "reference_match_result": "fail",
        "knowledge_match": 0.8333333333333334,
        "knowledge_match_result": "pass",
        "overall_score": 6.833333333333333
    },
    {
        "testcase": "is sdk generation required for private preview?",
        "expected": {
            "answer": "API approval for private preview does NOT always require SDK generation or SDK configuration in your tspconfig.yaml. For private preview ARM APIs, it is acceptable to onboard and validate your API contract without including SDK emitter settings (such as for Go, Python, Java, etc.).\n\nHowever, the Azure TypeSpec validation tooling (tsv) is configured to expect certain SDK emitter options in tspconfig.yaml by default, even for private preview, which is why you see SdkTspConfigValidation failures if you remove them.\n\nThe correct and supported approach is:\n- Remove SDK emitter configs you do NOT want in your tspconfig.yaml.\n- Add a suppressions.yaml file in the same directory as tspconfig.yaml to explicitly suppress the SdkTspConfigValidation rule (or specific sub-rules for missing SDK configs).\n\nHere is a sample suppressions.yaml to suppress all SdkTspConfigValidation checks (recommended for your scenario):\n\n```yaml\n- tool: TypeSpecValidation\n  paths:\n    - tspconfig.yaml\n  rules:\n    - SdkTspConfigValidation\n  reason: 'SDK generation is not in scope for private preview onboarding.'\n```\n\nPlace this suppressions.yaml alongside your tspconfig.yaml. This will allow CI and local validation to succeed without requiring SDK settings, letting you focus on API review and onboarding. When you later want to add SDK support, you can remove the suppression and add the required SDK emitter configuration.\n\nIn summary: No, API approval for private preview does not require SDK generation. Use suppressions.yaml to bypass SDK validation in tspconfig.yaml until you are ready to onboard SDKs.",
            "references": [
                {
                    "title": "Typespec Validation Failing on PR due to `typespec-go` configuration missing | question",
                    "link": ""
                },
                {
                    "title": "Can required fields have default values? | answer",
                    "link": ""
                },
                {
                    "title": "Validation Rule Suppression | Suppressing SdkTspConfigValidation Rules | Suppress Specific Sub-rules within SdkTspConfigValidation",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation"
                }
            ]
        },
        "actual": {
            "answer": "SDK generation is NOT required for private preview approval of an ARM (management-plane) API. According to Azure guidelines, private preview APIs do not need to ship SDKs, and you can onboard SDK generation later when you move to public preview or GA. However, the TypeSpec validation (specifically the SdkTspConfigValidation rule) expects certain SDK emitter options to be present in your tspconfig.yaml, even if you are not generating SDKs yet. If you remove these options, validation will fail.\n\nTo pass validation without actually generating SDKs, you have two options:\n\n1. **Add minimal required SDK emitter options to tspconfig.yaml**: You can include the required emitter options with placeholder values. This will satisfy validation, but you do not need to actually run the emitters or publish SDKs.\n\n2. **Suppress the SDK config validation rules**: If you do not want to add SDK emitter options at all, you can add a `suppressions.yaml` file to your service folder and explicitly suppress the SdkTspConfigValidation sub-rules for the SDKs you do not support (e.g., Go, .NET, Java, JS). This is an accepted approach for private preview scenarios where SDKs are not in scope.\n\nExample `suppressions.yaml` to suppress Go SDK validation (repeat for other languages as needed):\n\n```yaml\n- tool: TypeSpecValidation\n  paths:\n    - tspconfig.yaml\n  rules:\n    - SdkTspConfigValidation\n  sub-rules:\n    - options.@azure-tools/typespec-go.generate-fakes\n    - options.@azure-tools/typespec-go.inject-spans\n    - options.@azure-tools/typespec-go.service-dir\n    - options.@azure-tools/typespec-go.package-dir\n  reason: 'SDK generation is not required for private preview.'\n```\n\n**Summary:**\n- SDK generation is NOT required for private preview.\n- You must either provide minimal emitter options in tspconfig.yaml or suppress the validation rules for missing SDK configs to pass CI/type validation.\n- This is a common and supported pattern for ARM APIs in private preview.",
            "references": [
                {
                    "title": "Typespec Validation Failing on PR due to `typespec-go` configuration missing | answer",
                    "link": ""
                },
                {
                    "title": "Validation Rule Suppression | Suppressing SdkTspConfigValidation Rules | Suppress Specific Sub-rules within SdkTspConfigValidation",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation"
                },
                {
                    "title": "Azure Service Versioning Guide | Positive Consequences of the Azure Service Definition",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, complete, and precise, with all statements directly supported by the CONTEXT and no unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, including the main claims and supported approaches, with only minor differences in detail. It is fully complete.",
        "reference_match": 0.3333333333333333,
        "reference_match_result": "fail",
        "knowledge_match": 0.8620689655172413,
        "knowledge_match_result": "pass",
        "overall_score": 8.195402298850574
    },
    {
        "testcase": "Typespec Validation Failing on PR due to `typespec-go` configuration missing",
        "expected": {
            "answer": "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#suppressing-sdktspconfigvalidation-rules\nSuppressing go specific rules worked for me. Here's our suppression file:\n```yml\n- tool: TypeSpecValidation\npaths:\n- tspconfig.yaml\nrules:\n- SdkTspConfigValidation\nsub-rules:\n- options.@azure-tools/typespec-go.generate-fakes\n- options.@azure-tools/typespec-go.inject-spans\n- options.@azure-tools/typespec-go.service-dir\n- options.@azure-tools/typespec-go.package-dir\nreason: 'Azure Load Testing does not support a Go SDK currently'\n```",
            "references": [
                {
                    "title": "Typespec Validation Failing on PR due to `typespec-go` configuration missing | answer",
                    "link": ""
                },
                {
                    "title": "Validation Rule Suppression",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation"
                }
            ]
        },
        "actual": {
            "answer": "Your TypeSpec validation is failing because the CI checks are enforcing the presence of Go SDK emitter configuration options in your `tspconfig.yaml`, even though your service does not plan to support a Go SDK. This is due to the `SdkTspConfigValidation` rule, which validates emitter options for all supported SDK languages by default.\n\n**Best Practice Solution:**\nSince you do not intend to support a Go SDK, you should suppress the specific Go-related validation sub-rules for your TypeSpec project. This is the recommended and supported approach according to Azure TypeSpec validation guidelines.\n\n**How to Suppress Go Emitter Validation:**\n1. Create or update a `suppressions.yaml` file in the root directory of your service specification (the same folder as your `tspconfig.yaml`).\n2. Add the following suppression entry to ignore only the Go emitter options:\n\n```yaml\n- tool: TypeSpecValidation\n  paths:\n    - tspconfig.yaml\n  rules:\n    - SdkTspConfigValidation\n  sub-rules:\n    # Suppress validation for Go emitter options\n    - options.@azure-tools/typespec-go.generate-fakes\n    - options.@azure-tools/typespec-go.inject-spans\n    - options.@azure-tools/typespec-go.service-dir\n    - options.@azure-tools/typespec-go.package-dir\n  reason: 'This service does not support a Go SDK currently.'\n```\n\nThis will allow your PR to pass TypeSpec validation without requiring you to add unnecessary Go SDK configuration. If you ever decide to support Go in the future, you should remove these suppressions and add the required configuration.\n\n**References:**\n- [TypeSpec Validation Rule Suppression Guidance](https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation)\n- [Sample suppression for Go emitter options](see below)\n\nIf you need to suppress all validation for emitter options (not recommended unless absolutely necessary), you can suppress the entire `SdkTspConfigValidation` rule, but targeting only the Go sub-rules is preferred.",
            "references": [
                {
                    "title": "Validation Rule Suppression",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation"
                },
                {
                    "title": "Typespec Validation Failing on PR due to `typespec-go` configuration missing | answer",
                    "link": ""
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully supported by the CONTEXT, accurately reflects the recommended solution, and does not add or omit any critical details.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, including the specific suppression approach, sample file, and reference to official documentation.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.8928571428571429,
        "knowledge_match_result": "pass",
        "overall_score": 8.892857142857142
    },
    {
        "testcase": "Conflicting @azure-tools/typespec-azure-core/no-openapi and missing-x-ms-identifiers errors",
        "expected": {
            "answer": "You should NOT use @OpenAPI.extension(\"x-ms-identifiers\", #[]) in your Azure Resource Manager TypeSpec code. The no-openapi rule is strict: ARM specs must NOT use decorators from @typespec/openapi or @azure-tools/typespec-autorest, including $extension, because these are only processed by OpenAPI emitters and will break other emitters (like client SDKs).\nFor array properties, the correct approach is to use the @identifiers decorator from @azure-tools/typespec-azure-resource-manager. This decorator is the ARM-compliant way to specify identifying properties for array items and will ensure that x-ms-identifiers is emitted in the generated OpenAPI as needed, without violating the no-openapi rule. If there are no identifying properties, you can use @identifiers([]) to indicate this.\nExample:\n```\n@identifiers([])\nmyArrayField: MyItemType[];\n```\nIf you use @identifiers, the ARM linter will recognize the array is correctly specified and will not require you to use the OpenAPI extension directly.\nYou should only suppress the error if you have a legitimate, ARM-approved reason (for example, for backwards compatibility or an explicit reviewer exemption). But for new fields and normal scenarios, always use the ARM-compliant decorators, NOT OpenAPI extensions.\nSummary:\nDO NOT use @OpenAPI.extension(\"x-ms-identifiers\", #[]) in ARM specs.\nDO use @identifiers([]) or @identifiers([\"propertyName\"]) as appropriate for array items.\nSuppression should only be used in rare, reviewer-approved cases, not as a general workaround.\nThis approach ensures your spec is future-proof, passes all ARM validation, and is compliant with Azure API guidelines.",
            "references": [
                {
                    "title": "missing-x-ms-identifiers",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/rules/missing-x-ms-identifiers"
                },
                {
                    "title": "no-openapi",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi"
                },
                {
                    "title": "TypeSpec ARM Decorator Mapping to Swagger Documentation | 15. @identifiers | Description",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "You should NOT use the @OpenAPI.extension(\"x-ms-identifiers\", #[]) decorator directly in your TypeSpec code for Azure management-plane specs. The correct and Azure-compliant way to resolve the missing-x-ms-identifiers error is to use the @identifiers decorator from the Azure.ResourceManager library, not the OpenAPI extension decorator.\n\nHere's how to fix both errors:\n\n1. **Replace @OpenAPI.extension(\"x-ms-identifiers\", #[]) with @identifiers(#[...])**\n   - For each array property of a model where you get the missing-x-ms-identifiers error, decorate it with @identifiers and specify the identifying property names of the array item type. If there are no identifying properties, you can pass an empty array (#[ ]), but this should be rare and only if justified.\n\nExample:\n```typespec\nimport \"@azure-tools/typespec-azure-resource-manager\";\n\nmodel ResourceProperties {\n  @identifiers(#[\"city\", \"street\"])\n  addresses: Address[];\n}\n\nmodel Address {\n  city: string;\n  street: string;\n}\n```\nIf there are truly no identifiers:\n```typespec\nmodel ResourceProperties {\n  @identifiers(#[])\n  items: Item[];\n}\nmodel Item {\n  // ...\n}\n```\n\n2. **Remove all uses of @OpenAPI.extension(\"x-ms-identifiers\", ...)**\n   - This decorator is not allowed in Azure specs and will trigger the @azure-tools/typespec-azure-core/no-openapi error. The @identifiers decorator is the supported and required approach.\n\n3. **Suppressions**\n   - Suppression should only be used as a last resort and only if you have a strong justification. In almost all cases, using @identifiers will resolve both errors without the need for suppression.\n\n**Summary:**\n- Use @identifiers from the Azure.ResourceManager library, not @OpenAPI.extension.\n- Do not suppress these errors unless you have a scenario that cannot be modeled with @identifiers (which is extremely rare).\n- This approach is fully compliant with Azure API guidelines and TypeSpec best practices.",
            "references": [
                {
                    "title": "missing-x-ms-identifiers",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/rules/missing-x-ms-identifiers"
                },
                {
                    "title": "no-openapi",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-openapi"
                },
                {
                    "title": "TypeSpec ARM Decorator Mapping to Swagger Documentation | 15. @identifiers | TypeSpec Example",
                    "link": ""
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, complete, and directly supported by the CONTEXT without any unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all major claims and instructions from the ground truth, with only minor omissions of technical rationale and ARM linter details. It is mostly complete.",
        "reference_match": 0.6666666666666666,
        "reference_match_result": "fail",
        "knowledge_match": 0.9333333333333333,
        "knowledge_match_result": "pass",
        "overall_score": 8.2
    },
    {
        "testcase": "Need help with what appear like False Positives in ARM PR",
        "expected": {
            "answer": "You should NOT manually edit the autogenerated hardware.json file to work around TypeSpec or linter errors. Instead, you must address these issues at the TypeSpec source level and via configuration, following Azure TypeSpec best practices.\n1.ProvisioningState Must Be ReadOnly: The LintDiff check for `ProvisioningStateMustBeReadOnly` is triggered because the validation expects the type schema referenced by `provisioningState` to be `readOnly`, not just the property instance. The recommended (and officially supported) solution is to update your `tspconfig.yaml` to set:\n```\noptions:\n\"@azure-tools/typespec-autorest\":\nuse-read-only-status-schema: true\n```\nThis ensures all `ProvisioningState` schemas are emitted as `readOnly`, resolving the LintDiff error at the TypeSpec emission layer and removing the need to edit the generated Swagger.\n2.Missing Examples for Subscription-level APIs: The OpenAPI validation (ModelValidation) requires an example for each operation, including subscription-level (preview) APIs. If auto-generation tools like OAV are not generating examples for these, you must:\nManually add a valid example JSON file in the `examples/<api-version>/` folder of your TypeSpec project, ensuring the `operationId` matches your operation.\nThere is currently NO supported way to suppress example requirements in TypeSpec or Swagger for missing examples. Suppression can sometimes be done via labels (like `Approved-ModelValidation`) to unblock a PR, but the recommended approach is to provide at least one example per operation.\nGeneral Best Practices:\nDo NOT edit the emitted Swagger (`hardware.json`). Always make changes at the TypeSpec or configuration level.\nIf you encounter TypeSpec validation failures, refer to the TypeSpec source, emitter options, or required supporting files (such as examples or suppressions.yaml for certain rule types). For LintDiff, suppressions must be done in `readme.md` or `suppressions.yaml` (for TypeSpecRequirement errors only, not LintDiff or example requirements).\nSummary:\nSet `use-read-only-status-schema: true` in `tspconfig.yaml` to resolve the `ProvisioningStateMustBeReadOnly` error.\nAdd missing example files for all operations, including subscription-level ones, as there is no suppression for missing examples.\nNever edit the generated OpenAPI files to workaround linter errors.\nLet me know if you need guidance on creating an example file or configuring the emitter options.",
            "references": [
                {
                    "title": "`ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service",
                    "link": "https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error"
                },
                {
                    "title": "How to create an Example for a typespec model? | answer",
                    "link": ""
                },
                {
                    "title": "TypeSpec Validation failed | answer",
                    "link": ""
                },
                {
                    "title": "Suppress validation failures on a PR | Suppression cases table",
                    "link": "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions"
                }
            ]
        },
        "actual": {
            "answer": "You should not manually edit the generated OpenAPI (hardware.json) to work around validation or linter errors. All changes must be made in the TypeSpec (.tsp) files, and then you must regenerate the OpenAPI files using `npx tsp compile`. This is a strict requirement for Azure REST API specs to ensure consistency and traceability.\n\n**1. Marking `provisioningState` as readOnly:**\n- The Swagger LintDiff check for `ProvisioningStateMustBeReadOnly` is a known issue due to legacy validation logic. The correct way to resolve this is to configure the TypeSpec emitter to always output the `ProvisioningState` schema as readOnly, not by editing the OpenAPI directly.\n- In your `tspconfig.yaml`, add the following under the `@azure-tools/typespec-autorest` options:\n\n```yaml\nemit:\n  - \"@azure-tools/typespec-autorest\"\noptions:\n  \"@azure-tools/typespec-autorest\":\n    use-read-only-status-schema: true\n```\n\n- This will ensure the generated OpenAPI marks `provisioningState` as readOnly and resolves the LintDiff error. If you use the ARM scaffolding template, this is already set.\n\n**2. Examples for Subscription-level APIs:**\n- Do not use the `@example` decorator in TypeSpec for Azure specs. Instead, operation examples are required as separate `.json` files in the `examples/<api-version>/` folder. These are matched to operations by `operationId`.\n- If `oav` (OpenAPI validator) does not generate examples for subscription-level APIs, you must manually create the example file and ensure it is placed in the correct folder and references the correct `operationId`.\n- The OpenAPI emitter will automatically associate the example with the operation if the `operationId` matches.\n\n**3. TypeSpec Validation Failure (hardware.json changed):**\n- The validation failure is likely because the OpenAPI file in your PR does not match what is generated from the current TypeSpec source. This usually happens if you manually edit the OpenAPI or your local dependencies are out of date.\n- To resolve:\n  1. Sync your branch with the latest upstream/main.\n  2. Run `npm ci` at the repo root.\n  3. Run `npx tsp compile` in your service directory.\n  4. Add and commit all generated files.\n  5. Push your changes.\n- If you still see differences, try a clean clone or a different machine. If the issue persists, reach out to the TypeSpec Discussion Teams channel.\n\n**Suppression:**\n- TypeSpec Validation failures cannot be suppressed. You must resolve the underlying issue in the TypeSpec source and regenerate the OpenAPI.\n\n**Summary:**\n- Never manually edit generated OpenAPI files to work around validation errors.\n- Mark `provisioningState` as readOnly using the emitter config, not by editing OpenAPI.\n- Add operation examples as separate files, not via decorators or direct OpenAPI edits.\n- Always regenerate OpenAPI from TypeSpec after making changes.\n\nIf you follow these steps, your PR should pass TypeSpec Validation and Swagger LintDiff checks.",
            "references": [
                {
                    "title": "`ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service",
                    "link": "https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error"
                },
                {
                    "title": "How to create an Example for a typespec model? | answer",
                    "link": ""
                },
                {
                    "title": "TypeSpec Validation failed | answer",
                    "link": ""
                },
                {
                    "title": "Suppress validation failures on a PR | Suppression cases table",
                    "link": "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions"
                },
                {
                    "title": "Examples generation | answer",
                    "link": ""
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded in the CONTEXT, accurately conveying all necessary details and instructions without unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The Response is fully complete, accurately reflecting all key statements and instructions from the Ground Truth, with only minor differences in wording and no missing substantive information.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.8518518518518519,
        "knowledge_match_result": "pass",
        "overall_score": 8.851851851851851
    },
    {
        "testcase": "Swagger LintDiff validation for certain models",
        "expected": {
            "answer": "You should not suppress this LintDiff validation error. The error `RequiredPropertiesMissingInResourceModel` indicates that your `SharingDetail` model is being interpreted as a resource model, but it does not contain the required ARM resource properties: `name`, `id`, and `type` (all marked as readOnly). According to Azure API and TypeSpec guidelines, all resource models must include these properties to be compliant.\nSuppressing this error is not the correct approach\u2014instead, you must fix your TypeSpec definition. Ensure that resource models either extend the appropriate common-types resource base model (such as `Resource`, `ProxyResource`, or `ExtensionResource`) or, if `SharingDetail` is not a resource, ensure it is not referenced in a way that causes it to be treated as one.\nFor suppressing LintDiff errors in general, you can add scoped suppressions in your `readme.md` following the guidance here: https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff#adding-scoped-suppressions. However, for this particular error, you are expected to fix your TypeSpec spec to meet the ARM requirements\u2014not suppress it.\nTo resolve this:\nIf `SharingDetail` is a resource, extend from the correct base model and add `id`, `name`, `type` (all readOnly).\nIf it is not a resource, check where it is referenced in your operations or model hierarchy to ensure it is not being treated as a resource by the code generator.",
            "references": [
                {
                    "title": "Swagger LintDiff Suppression via TypeSpec | question",
                    "link": ""
                },
                {
                    "title": "TypeSpec",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff"
                }
            ]
        },
        "actual": {
            "answer": "Yes, you can suppress the LintDiff validation error 'RequiredPropertiesMissingInResourceModel' for the 'SharingDetail' model, but only in the OpenAPI (Swagger) validation layer, not directly in TypeSpec. According to Azure API guidelines and current tooling, LintDiff errors must be suppressed in the `readme.md` file of your spec, not in the TypeSpec source or suppressions.yaml.\n\nTo suppress this error:\n1. Open your `readme.md` file in the relevant folder (e.g., `specification/limit/resource-manager/Microsoft.Limit/Limit/readme.md`).\n2. Add a suppression directive for the specific error and path. The suppression should target the exact location in the generated OpenAPI where the error occurs (see the error message for the path).\n\nExample suppression directive:\n\n```yaml\n  - where:\n    - $.definitions.SharingDetail\n    suppress:\n      - RequiredPropertiesMissingInResourceModel\n    reason: 'SharingDetail is not a resource model and does not require id, name, type.'\n```\n\nMake sure the path (`$.definitions.SharingDetail`) matches the location in your generated OpenAPI where the error is reported. If the error is in a different location (e.g., inside a PATCH body or another definition), adjust the path accordingly.\n\n**Important:**\n- This suppression only affects LintDiff (Swagger) validation. TypeSpec validation errors must be fixed in the TypeSpec source itself.\n- Suppressions for LintDiff cannot be placed in TypeSpec files or suppressions.yaml\u2014they must be in `readme.md`.\n- Always provide a clear reason for the suppression, as reviewers will check for justification.\n\nFor more details and examples, see the official guidance: https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff#adding-scoped-suppressions",
            "references": [
                {
                    "title": "Swagger LintDiff Suppression via TypeSpec | question",
                    "link": ""
                },
                {
                    "title": "Swagger LintDiff validation for certain models | question",
                    "link": ""
                },
                {
                    "title": "Swagger-LintDiff.md",
                    "link": "https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully supported by the CONTEXT, covers all essential points, and does not add unsupported details or omit critical information.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all major and minor information from the ground truth, with only a very slight omission about the location for suppressions, but this does not affect the main completeness. It is fully complete.",
        "reference_match": 0.5,
        "reference_match_result": "fail",
        "knowledge_match": 0.8518518518518519,
        "knowledge_match_result": "pass",
        "overall_score": 5.951851851851852
    },
    {
        "testcase": "How to make an interface internal ?",
        "expected": {
            "answer": "We do not support hiding an entire operation group directly. The recommended approach is to redefine your client in client.tsp and use @@access decorator to control which operations appear on the public client. When you do this properly, the default service clients and their Operations classes should not be emitted",
            "references": [
                {
                    "title": "Decorators | Azure.ClientGenerator.Core | `@access`",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators"
                },
                {
                    "title": "Usages for Test for internal decorator. | Scenario: This scenario contains internal operations. All should be generated but not exposed.",
                    "link": "https://github.com/Azure/typespec-azure/blob/main/packages/azure-http-specs/specs/azure/client-generator-core/access/main.tsp"
                },
                {
                    "title": "How to remove certain classes for Python SDK only | answer",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "To make an interface internal in TypeSpec so that it does not appear in the public interface of the generated Python SDK, you must ensure that all operations under the interface are marked as internal using the `@access(Access.internal)` decorator from `@azure-tools/typespec-client-generator-core`. The access level of the interface itself is determined by the access of its operations. If all operations are internal, the interface and its models will be treated as internal and will not be exposed in the public SDK surface.\n\nHowever, applying `@access(Access.internal)` directly to the interface is not supported and will not have the desired effect. The correct approach is to decorate every operation within the interface with `@access(Access.internal)`. The access control will propagate from the operations to the interface and its models, ensuring they are not included in the public SDK.\n\nHere is an example:\n\n```typespec\nimport \"@azure-tools/typespec-client-generator-core\";\nusing Azure.ClientGenerator.Core;\n\ninterface EvaluationResultsOperations {\n  @access(Access.internal)\n  @route(\"/evaluationResults\")\n  @get\n  listEvaluationResults(): EvaluationResult[];\n\n  @access(Access.internal)\n  @route(\"/evaluationResults/{id}\")\n  @get\n  getEvaluationResult(@path id: string): EvaluationResult;\n}\n\nmodel EvaluationResult {\n  id: string;\n  score: int32;\n}\n```\n\nWith this setup, the `EvaluationResultsOperations` interface and its operations will be generated for internal use but will not appear in the public interface of the Python SDK.\n\nIf any operation under the interface is public, the interface (and its models) will be exposed. So, ensure all operations are internal. There is no supported way to make an interface internal for only one language (e.g., Python) without affecting others. If you need language-specific suppression, this is not currently supported in TypeSpec and would require SDK suppression files, which is not recommended for long-term maintenance.",
            "references": [
                {
                    "title": "Decorators | Azure.ClientGenerator.Core | `@access`",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators"
                },
                {
                    "title": "Usages for Test for internal decorator. | Scenario: This scenario contains internal operations. All should be generated but not exposed.",
                    "link": "https://github.com/Azure/typespec-azure/blob/main/packages/azure-http-specs/specs/azure/client-generator-core/access/main.tsp"
                },
                {
                    "title": "How to remove certain classes for Python SDK only | answer",
                    "link": ""
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, complete, and accurately reflects all relevant details from the CONTEXT without unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, with no omissions, and even adds helpful clarifications.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.7931034482758621,
        "knowledge_match_result": "fail",
        "overall_score": 6.993103448275862
    },
    {
        "testcase": "How to restrict importing typespec files in main based off of versions.",
        "expected": {
            "answer": "no, you have to mark the models/types and everything that you want to remove with the @removed decorator using the versioning library\nif you are in preview version I think also the policy is to only have a single preview version in the spec repo at the timme now so you could also just delete it",
            "references": [
                {
                    "title": "How to restrict importing typespec files in main based off of versions. | question",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "There is no way to conditionally import TypeSpec files in main.tsp based on API version. TypeSpec does not support conditional imports or version-based file inclusion at the import level. All files imported in main.tsp are always included in the compilation, regardless of the API version.\n\nTo achieve version-specific inclusion or exclusion of resource types, you must use the versioning decorators provided by the @typespec/versioning library. Specifically, you should:\n\n- Mark the models, types, or operations you want to remove from a specific version with the @removed(VERSION) decorator.\n- If you want to add a type or property only in a specific version, use the @added(VERSION) decorator.\n\nThis approach ensures that the unwanted resource type is excluded from the generated output for the new API version, while still being present for previous versions. This is the recommended and supported way to manage versioned API surface in TypeSpec.\n\nIf you are in a preview version and want to remove a resource type entirely, the Azure policy is to only have a single preview version in the spec repo at a time, so you could also just delete the resource type if it is no longer needed.\n\nExample:\n```typespec\nmodel MyResource {\n  // ...\n}\n\n// Remove from v2024_10_01\n@removed(Versions.v2024_10_01)\nmodel MyResource;\n```\n\nThis will ensure MyResource is not present in the generated OpenAPI for v2024_10_01 and later, but is present in earlier versions.",
            "references": [
                {
                    "title": "How to restrict importing typespec files in main based off of versions. | question",
                    "link": ""
                },
                {
                    "title": "Versioning | Introduction to the `@versioned` Decorator | Example: Defining API Versions",
                    "link": "https://typespec.io/docs/getting-started/getting-started-rest/06-versioning"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, complete, and accurately conveys all essential information from the CONTEXT without introducing unsupported details or omitting critical points.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is fully complete, accurately reflecting all necessary information from the ground truth without missing any key points.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.7586206896551724,
        "knowledge_match_result": "fail",
        "overall_score": 8.758620689655173
    },
    {
        "testcase": "Description changes across versions?",
        "expected": {
            "answer": "Honestly, the best thing is to update your docs and take the update in previous versions (which are likely now more accurately described as well). Documentation updates are not breaking changes, and, if changes are limited to documentation, this should be passed easily by the breaking change board.",
            "references": [
                {
                    "title": "Description changes across versions? | question",
                    "link": ""
                },
                {
                    "title": "TypeSpec: How can I change only descriptions/comments between versions while keeping models identical? | question",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "The best practice for updating a model description (documentation-only change) in TypeSpec is to simply update the description in your TypeSpec files and allow this change to propagate to all versions. Documentation-only changes are not considered breaking changes and should not be versioned or scoped to a single API version. There is no need to change the output path in your tspconfig.yaml or restrict output to only the current version.\n\nIf TypeSpec validation fails because older generated OpenAPI specs do not match the updated documentation, the correct approach is to update the documentation in all versions (including older ones) so that the generated specs are consistent and accurate. This ensures that all versions benefit from improved documentation and avoids unnecessary complexity in your TypeSpec configuration.\n\nIn summary:\n- Update the description in your TypeSpec files for all versions.\n- Allow the improved documentation to be reflected in all generated OpenAPI specs.\n- Do not attempt to restrict output or version documentation changes.\n- If your CI flags documentation-only changes as breaking, these are generally approved and do not trigger SDK releases.\n\nThis approach aligns with Azure API guidelines and TypeSpec best practices.",
            "references": [
                {
                    "title": "Description changes across versions? | question",
                    "link": ""
                },
                {
                    "title": "TypeSpec: How can I change only descriptions/comments between versions while keeping models identical? | question",
                    "link": ""
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is entirely based on the CONTEXT, accurately and thoroughly conveying all essential information without introducing unsupported details or omitting critical points.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response fully covers all necessary and relevant information from the ground truth, with additional helpful context but no omissions.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.8148148148148148,
        "knowledge_match_result": "pass",
        "overall_score": 8.814814814814815
    },
    {
        "testcase": "Quantum RP, add new filter to offering API",
        "expected": {
            "answer": "For a case like this, just decorating the filter property with `@added` in the same operation is the simplest mechanism.  Versioning the request and response data in an operation like this is usually the most straightforward way to version an operation.\nFor more complex operation versioning, you can use the remove/rename/sharedRoute mechanism described here: [Versioning | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/howtos/arm/versioning/#converting-an-operation-from-synchronous-to-asynchronous)\nNote also that you should name the property 'filter', the `@query(\"$filter\")` decorator actually sets the name on the wire,  you generally want to follow standard naming rules for parameters:\n```\n// v2 (new preview)\nlistBySubscription is ArmListBySubscription<\nQuantumSuiteOffer,\nParameters = {\n/**\n* The filter to apply to the operation. Example: '$filter=kind eq \"v1\"'\n*/\n@added(Versions.v2025_11_01_preview)\n@query(\"$filter\")\nfilter?: string;\n}\n>;\n```",
            "references": [
                {
                    "title": "Versioning | Simple Scenarios | Adding a Parameter to an Operation and Making Another Parameter Optional",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/arm/versioning"
                },
                {
                    "title": "Handling multiple API versions using typespec | answer",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "To add a new filter parameter to your listBySubscription operation in your Quantum ARM API using TypeSpec, and handle versioning correctly, you should use versioning decorators to indicate when the new parameter is introduced. The recommended approach is to use the @madeOptional and @added decorators on the parameter itself, not on the operation. This way, the operation remains the same across versions, and only the parameter changes are versioned.\n\nHere's how you can do it:\n\nSuppose your original operation is:\n```typespec\nlistBySubscription is ArmListBySubscription<QuantumWorkspace>;\n```\n\nTo add a new optional filter parameter in a new version (e.g., v2025_11_01_preview), do the following:\n\n1. Define a parameters model for the operation, and use @added to introduce the new filter parameter in the new version.\n2. Pass this parameters model to ArmListBySubscription as the Parameters argument.\n\nExample:\n```typespec\nmodel ListBySubscriptionParameters {\n  // Existing parameters (if any)\n  @added(Versions.v2025_11_01_preview)\n  @query(\"$filter\")\n  filter?: string;\n}\n\nlistBySubscription is ArmListBySubscription<\n  QuantumWorkspace,\n  Parameters = ListBySubscriptionParameters\n>;\n```\n\nThis approach ensures:\n- The operation name and route remain stable (no need to use @removed/@added on the operation itself).\n- The filter parameter only appears in the new version and later.\n- The generated OpenAPI and SDKs will reflect the correct parameter set for each version.\n\nDo NOT use @removed/@added on the operation itself unless you are changing the operation template or route. For parameter changes, always version the parameter, not the operation.\n\nIf you need to make the filter parameter required in a future version, use @madeOptional or remove the optionality as needed.\n\nThis pattern is the Azure ARM and TypeSpec best practice for evolving operation parameters.",
            "references": [
                {
                    "title": "Versioning | Simple Scenarios | Adding a Parameter to an Operation and Making Another Parameter Optional",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/arm/versioning"
                },
                {
                    "title": "Handling multiple API versions using typespec | answer",
                    "link": ""
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": "",
        "groundedness_result": "unknown",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains almost all relevant information and accurately reflects the ground truth, missing only minor details such as the documentation link and explicit mention of naming rules. It is mostly complete.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.8,
        "knowledge_match_result": "pass",
        "overall_score": NaN
    },
    {
        "testcase": "Swagger generation fails due to duplicate operations in interface irrespective of different models.",
        "expected": {
            "answer": "To update the maximum value of `validityPeriodInDays` from 30 to 90 for only the new API version (`2025-11-01-preview`) in your TypeSpec definition, you must use TypeSpec's versioning patterns for breaking model changes. However, TypeSpec currently does not support versioning decorators on decorator arguments (like changing the `@maxValue` parameter per version). Directly updating the decorator value would affect all versions.\nThe correct Azure-compliant pattern is:\nCreate a new property (with a different internal name) for the updated constraint.\nUse `@removed` and `@renamedFrom` on the old property, and `@added` on the new property, both on the same model. This allows you to apply different constraints in different API versions without affecting other versions or causing duplicate operation errors.\nIf the operation signature/model type is changed for only the new version, use the add/remove/rename pattern and use `@sharedRoute` on both versions of the operation (see linked examples). This avoids the duplicate operation error and ensures correct OpenAPI emission for each version.\nExample:\n```\nmodel LeafCertificateConfiguration {\n// Old property: max 30 days, removed in new version\n@maxValue(30)\n@removed(Versions.v2025_11_01_preview)\n@renamedFrom(Versions.v2025_11_01_preview, \"validityPeriodInDays\")\nvalidityPeriodInDaysV1: int32;\n// New property: max 90 days, only in new version\n@added(Versions.v2025_11_01_preview)\n@maxValue(90)\nvalidityPeriodInDays: int32;\n}\n```\nIn your operation/interface, you may need to do the same if the operation signature changes. If you want to have different models for different versions but keep the same route, use the `@sharedRoute` decorator and the `@renamedFrom` pattern for the operation as well (see the \"Converting an Operation from Synchronous to Asynchronous\" example in the docs).\nThis pattern will:\nPrevent duplicate operation errors (since each operation/model is only present in one version)\nEmit the correct schema per version\nNot require changing the operation name at the API surface (the renaming is internal)\nSummary:\nUse the add/remove/rename pattern for versioned property changes that affect validation/constraints.\nUse `@sharedRoute` and `@renamedFrom` for operations if the operation signature changes with the model.\nDo NOT update decorator arguments directly for just one version\u2014they affect all versions.",
            "references": [
                {
                    "title": "Versioning | Adding a Property or Parameter",
                    "link": "https://azure.github.io/typespec-azure/docs/getstarted/versioning"
                },
                {
                    "title": "Versioning | Versioning Decorators | @renamedFrom",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/arm/versioning"
                },
                {
                    "title": "Diagnostics | duplicate-type-name",
                    "link": "https://typespec.io/docs/emitters/openapi3/diagnostics"
                }
            ]
        },
        "actual": {
            "answer": "The root cause of your duplicate operation error is that TypeSpec's versioning system does not allow you to have two operations with the same HTTP route and method\u2014even if they use different models\u2014unless you use the correct versioning decorators and patterns. Changing only the model (e.g., updating the max value of a property) and attempting to version the operation by duplicating it (with or without @renamedFrom) will result in a duplicate operation error because both operations resolve to the same HTTP path and verb.\n\n**Best Practice Solution:**\n- In TypeSpec, you should version the *model* (not the operation) when only the schema changes between versions, and keep a single operation definition. The operation should reference a versioned model, and the model should use versioning decorators like @added, @removed, or @renamedFrom for properties as needed.\n- You should NOT duplicate the operation or interface for each version. Instead, use a single interface and operation, and version the model or property.\n- If you need to change a property constraint (like max value), update the model property directly. If the change is not backward compatible, you may need to create a new model and use @renamedFrom, but this is only necessary if the wire shape changes (e.g., property name/type changes), not for validation changes.\n\n**How to update your model for a new version:**\n```typespec\nmodel LeafCertificateConfiguration {\n  validityPeriodInDays: int32 @maxValue(30); // for v2025-08-01-preview\n  @maxValue(90) @added(Versions.v2025_11_01_preview)\n  validityPeriodInDays: int32;\n}\n```\nHowever, note that TypeSpec does not version decorator arguments (like @maxValue). If you need to change the max value, you must:\n- Either update the max value for all versions (if the service enforces the same rule for all versions),\n- Or, if the max value is truly different per version, create a new model for the new version and use @added/@removed to version the property or model, and reference the correct model in the operation via versioning decorators.\n\n**Do NOT duplicate the operation or interface.**\n\n**If you must have two models:**\n```typespec\nmodel LeafCertificateConfigurationV1 {\n  validityPeriodInDays: int32 @maxValue(30);\n}\n@added(Versions.v2025_11_01_preview)\nmodel LeafCertificateConfigurationV2 {\n  validityPeriodInDays: int32 @maxValue(90);\n}\n```\nThen, in your resource model, use the correct model per version:\n```typespec\nmodel Policy is TrackedResource<LeafCertificateConfigurationV1> {\n  // ...\n}\n@added(Versions.v2025_11_01_preview)\nmodel PolicyV2 is TrackedResource<LeafCertificateConfigurationV2> {\n  // ...\n}\n```\nAnd in your interface, version the operation:\n```typespec\n@armResourceOperations\ninterface Policies {\n  get is ArmResourceRead<Policy>;\n  @added(Versions.v2025_11_01_preview)\n  getV2 is ArmResourceRead<PolicyV2>;\n}\n```\nBut you must use @sharedRoute to avoid duplicate route errors:\n```typespec\n@added(Versions.v2025_11_01_preview)\n@sharedRoute\ngetV2 is ArmResourceRead<PolicyV2>;\n```\n\n**Summary:**\n- Do not duplicate operations/interfaces for versioning; version the models/properties instead.\n- If you must have two operations with the same route, use @sharedRoute and versioning decorators (@added, @removed, @renamedFrom) to avoid duplicate operation errors.\n- For property validation changes, if possible, update the model in place if the service behavior is consistent. Otherwise, create a new model and version it.\n\nThis approach aligns with Azure TypeSpec versioning best practices and will resolve your duplicate operation error.",
            "references": [
                {
                    "title": "How to update any model without affecting old API versions | answer",
                    "link": ""
                },
                {
                    "title": "How can I change the operation template of an operation in newer versions | Workaround",
                    "link": "https://azure.github.io/typespec-azure/docs/troubleshoot/versioning_operation_template_changes"
                },
                {
                    "title": "Versioning | Adding a Property or Parameter",
                    "link": "https://azure.github.io/typespec-azure/docs/getstarted/versioning"
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded in the CONTEXT, accurately and completely conveying all relevant information and best practices without unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response is mostly complete, missing only the specific add/remove/rename pattern for property versioning within the same model, but otherwise covers the main points about TypeSpec versioning and avoiding duplicate operation errors.",
        "reference_match": 0.3333333333333333,
        "reference_match_result": "fail",
        "knowledge_match": 0.7407407407407407,
        "knowledge_match_result": "fail",
        "overall_score": 7.0740740740740735
    },
    {
        "testcase": "Swagger LintDiff - Analyze Code Error",
        "expected": {
            "answer": "You cannot directly version a decorator such as @pattern in TypeSpec; decorators themselves are not versioned. This means that if you update a pattern in your TypeSpec model, it will apply to all API versions emitted by TypeSpec, not just a new version. This is a deliberate design choice to avoid hidden inconsistencies between the declared API surface and the actual backend behavior.\nIf you need different validation patterns (such as a new regex for a resource name) for a specific API version and newer, you have two supported options in TypeSpec:\nIf the new pattern applies to all versions: Update the @pattern decorator in the model directly. This is the common and recommended path if your backend enforces the new pattern for all versions.\nIf the pattern truly differs by API version (rare, and usually discouraged): You must explicitly version the type. For example, you can introduce a new scalar type or model for the new version, and use the @typeChangedFrom or @renamedFrom decorators to describe the transition between versions. This approach requires you to manage versioning logic in TypeSpec, not in the generated OpenAPI/JSON files. You should not edit the generated files by hand, and manual changes to JSON files are not supported.\nHere's a sketch of the pattern versioning approach:\n```\n/** Legacy pattern type for old API versions */\n@pattern(\"^[a-z0-9]{3,18}$\")\nscalar ResourceNameLegacy extends string;\nmodel MyResource {\n@key(\"resourceName\")\n@typeChangedFrom(Versions.v2, ResourceNameLegacy)\n@pattern(\"^[a-zA-Z][a-zA-Z0-9]*(-[a-zA-Z0-9]+)*$\")\nname: string;\n}\n```\nIn this example, TypeSpec will emit the old pattern for older API versions and the new pattern for v2 and above, but you must structure your code accordingly. Note that this approach can lead to more complicated TypeSpec code and is only justified if your backend actually enforces different rules per API version.\nSummary: Do not manually edit JSON files generated by TypeSpec. Use versioning decorators and, if necessary, versioned types to achieve per-version differences. But for most cases, apply the new pattern universally if the service behavior matches. This approach keeps your TypeSpec code clear and maintainable.",
            "references": [
                {
                    "title": "How to update any model without affecting old API versions | answer",
                    "link": ""
                },
                {
                    "title": "How to change the model to accommodate new decorators for validations | question",
                    "link": ""
                },
                {
                    "title": "Data types | Azure.ResourceManager | `ResourceNameParameter`",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types"
                }
            ]
        },
        "actual": {
            "answer": "There is currently no supported way in TypeSpec to add a pattern restriction (such as a regex for the resource name parameter) only for a specific API version and newer, without affecting older versions, and without manually editing the generated JSON file.\n\n**Reason:**\n- TypeSpec decorators like `@pattern` (or the `NamePattern` parameter in `ResourceNameParameter`) are not versioned. If you add or change the pattern in your TypeSpec model, it will apply to all API versions that use that model. This is a known limitation of TypeSpec's versioning system.\n- The Azure API guidelines and TypeSpec best practices recommend that, unless your service actually enforces different validation rules for different API versions, you should apply the pattern restriction to all versions. This is because client SDKs do not use the pattern for validation; it is only for documentation and API review purposes.\n- If your service does enforce different patterns for different versions (which is rare and generally discouraged), you would need to create separate models for each version, which leads to significant duplication and maintenance overhead.\n\n**Recommended Solution:**\n- If the pattern restriction is a bug fix or an accurate reflection of the service's behavior, update the pattern for all versions. This is not considered a breaking change for SDKs, as they do not validate the pattern client-side.\n- If you must have different patterns for different versions (for example, if the service behavior truly changed), you would need to define separate models for each version and use the appropriate model in each versioned namespace. However, this is not recommended unless absolutely necessary and approved by the API review board.\n\n**Do not manually edit the generated JSON file.** All changes should be made in TypeSpec source files to ensure consistency and maintainability.\n\n**Summary:**\n- Decorator values (like `NamePattern`) are not versioned in TypeSpec.\n- The best practice is to apply the pattern restriction to all versions, unless your service truly enforces different patterns per version.\n- If you need per-version differences, you must create separate models per version, but this is discouraged.\n- Do not edit the generated JSON directly.",
            "references": [
                {
                    "title": "Can I have different Name Regex for ARM Resource for different api versions?",
                    "link": ""
                },
                {
                    "title": "How to update any model without affecting old API versions",
                    "link": ""
                },
                {
                    "title": "Data types | Azure.ResourceManager | ResourceNameParameter",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types"
                },
                {
                    "title": "How to change the model to accommodate new decorators for validations",
                    "link": ""
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": NaN,
        "groundedness_result": NaN,
        "groundedness_threshold": NaN,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains almost all relevant information from the ground truth, missing only minor details such as specific decorator names and the illustrative code sketch. It is mostly complete.",
        "reference_match": 0.0,
        "reference_match_result": "fail",
        "knowledge_match": 0.8333333333333334,
        "knowledge_match_result": "pass",
        "overall_score": NaN
    },
    {
        "testcase": "Versioning the LRO headers",
        "expected": {
            "answer": "here's a [playground](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D&c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjUtMTAtMDEtcHJldmlld8g1xDQgIOQA10NvbW1vblTkAY%2FHQCj1ATcuyykuyGoudjUpCiAgYNJpYCwK8ACFN%2F8Ahf8Ahf8AhesAhclpYCwKfeYBOEHoATrrAVMg6AJ15ACIbW9kZWwgRW1wbG95ZWUgaXMgVHJhY2tlZOgAgjzIHFByb3BlcnRpZXM%2B5QFpLi7pAKbkAhtQYXJhbWV0ZXLJMT476ACGyV9wyUTSfMpg6QHIQWdlIG9mIGXIP%2BUBOGFnZT86IGludDMyO%2BgBbENpdHnSKmNpdHk%2FOiBzdHLlAy7HLFByb2ZpbNNZQGVuY29kZSgiYmFzZTY0dXJsIuQBYHDGMD86IGJ5dGVzyUhUaGUgc3RhdHVzxEt0aGUgbGFzdCDkAMVhdGlvbuUDQSAgQHZpc2liaWxpdHkoTGlmZWN5Y2zkAeBhZMddxCDlA9BTdGF0xGflAavMFOkBSMRzzDLlAIDlAMph6QHVxXdAbHJvxDt1cwp1buQCctFU5QFk5gEa6QKyxF%2FIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QTq6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBULHC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QP96QN3bW926gHK6QN5TW92ZVLHFegDcsRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPrBIvmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AZhT%2BgDlHMgZXh0ZW5kc%2FYHIy7LKXt9CuUG%2F8gjyhvLWegAzeYEs2dldOQBp0HKNeQD5%2BwFEOQEEHJl5Ab6ZEZyb23pBw4u9QXFICLmAqlPcuUC1WXlBI9AcmXkAPzqB0rVPMUqc2hhcmVkUm91dGXkBQ7NTE9sZO8ArEPHIFJlcGxhY2VBc3luY%2BwAvN9RxU71AVVMZWdhY3ku1WAKICAg6QFGLMUOT3DkAWZhbOcCm0JvZHkgPSB0cnXEdOUAiOUD%2FMZxcm1DdXN0b21QYXRjaFPXUvYAl0ZvdW7kBCvkAUPIHOYAy03kAonGSdBLyhDqBq%2FFGT7oAJ3mA5%2FvAVzlA5xlV2l0aG91dE9r8wFcbGlzdEJ5yDBHcm91cM9ETMUiUGFyZW501DxTdWJzY3Jp5QE%2BxzvGM8wZzDnoB2Ugc2FtcGzrBGthY8VEdGhhdOYDaOkHKHRvIGRpZmZl5ACE7wPrxSnuALJBxUjlAZbIdyzsBHbIDeYD7fMAkkhFQUTqB1HEfmNoZWNr6gCqZXhpc3RlbuYIyyDGHkXJFO8C4M0d7gim&e=%40azure-tools%2Ftypespec-autorest&vs=%7B%7D) showing how you would version a required to optional request body for a templated async put operation:\n```\n@armResourceOperations\ninterface Employees {\nget is ArmResourceRead<Employee>;\n@renamedFrom(Versions.`2025-10-07-preview`, \"createOrUpdate\")\n@removed(Versions.`2025-10-07-preview`)\n@sharedRoute\ncreateOrUpdateOld is ArmResourceCreateOrReplaceAsync<Employee>;\n@sharedRoute\ncreateOrUpdate is Azure.ResourceManager.Legacy.CreateOrReplaceAsync<\nEmployee,\nOptionalRequestBody = true\n>;\nupdate is ArmCustomPatchSync<\nEmployee,\nAzure.ResourceManager.Foundations.ResourceUpdateModel<\nEmployee,\nEmployeeProperties\n>\n>;\ndelete is ArmResourceDeleteWithoutOkAsync<Employee>;\nlistByResourceGroup is ArmResourceListByParent<Employee>;\nlistBySubscription is ArmListBySubscription<Employee>;\n/** A sample resource action that move employee to different location */\nmove is ArmResourceActionSync<Employee, MoveRequest, MoveResponse>;\n/** A sample HEAD operation to check resource existence */\ncheckExistence is ArmResourceCheckExistence<Employee>;\n}\n```\nthe trick is to use @sharedRoute in the old and new operations and to rename and remove the old operation in the new version.",
            "references": [
                {
                    "title": "Versioning the LRO headers | answer",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "The recommended way to version LRO headers and related behavior in TypeSpec is to version the entire operation, not the LRO headers or decorators themselves. TypeSpec and the Azure TypeSpec libraries do not support applying @added or @removed directly to LRO header types or to the LRO header parameters within the operation template. Instead, you should use operation versioning patterns:\n\n1. Use @sharedRoute on both the old and new operations to keep the same route across versions.\n2. In the new API version, remove (with @removed) or rename (with @renamedFrom) the old operation, and introduce a new operation with the updated behavior (e.g., optional request body, LRO semantics, new headers).\n3. In the new operation, use the appropriate Azure.ResourceManager.Legacy.CreateOrReplaceAsync template with OptionalRequestBody = true and the correct LRO headers (e.g., ArmAsyncOperationHeader or ArmLroLocationHeader with FinalResult set).\n\nExample:\n\n```typespec\n@armResourceOperations\ninterface Employees {\n  get is ArmResourceRead<Employee>;\n\n  @renamedFrom(Versions.`2025-10-07-preview`, \"createOrUpdate\")\n  @removed(Versions.`2025-10-07-preview`)\n  @sharedRoute\n  createOrUpdateOld is ArmResourceCreateOrReplaceAsync<Employee>;\n\n  @sharedRoute\n  createOrUpdate is Azure.ResourceManager.Legacy.CreateOrReplaceAsync<\n    Employee,\n    OptionalRequestBody = true\n  >;\n  // ... other operations ...\n}\n```\n\nThis approach ensures that the new LRO behavior (including headers and final-state-via semantics) only applies to the new API version, while the old behavior is preserved for previous versions. You do not need to (and cannot) version the LRO headers themselves\u2014version the operation instead. This is the Azure TypeSpec best practice for evolving LRO semantics and request/response shapes across API versions.",
            "references": [
                {
                    "title": "Versioning the LRO headers | answer",
                    "link": ""
                },
                {
                    "title": "Handling multiple API versions using typespec | answer",
                    "link": ""
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "The RESPONSE is fully grounded, complete, and directly supported by the CONTEXT, with no unsupported additions or omissions.",
        "groundedness_result": "pass",
        "groundedness_threshold": 3.0,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all the major information and claims from the ground truth about how to version LRO headers and operations in TypeSpec, with only minor omissions (like the playground link and extra operations). It accurately reflects the recommended approach and provides a matching code example.",
        "reference_match": 1.0,
        "reference_match_result": "pass",
        "knowledge_match": 0.7586206896551724,
        "knowledge_match_result": "fail",
        "overall_score": 8.358620689655172
    },
    {
        "testcase": "Creating stable API version with select properties omitted?",
        "expected": {
            "answer": "TypeSpec versioning works in the following way:\nAll types in the spec are automatically part of the initial api-version\nWhen a new api-version is introduced,  any new types `use@added(VERSION)` decorators to indicate they were added in that version, they are impliciutly included in every subsequent version\nWhen a type does not appear in one version, then you use `@removed(VERSION)` to remove the type at that version, by default, it will not appear any subsequent versions.  It can be added back using `@added` [Here is a playground](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D&c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCuoAxTTGHP8Avf8Avf8Avf8Avf4AvecAoe0AtTUtMDf%2FAXr%2FAL3%2FAL3%2FAL3%2FAL3qAL3vAKlgLAp95gJtQegCb%2BsCiCDoA6rkAMhtb2RlbCBFbXBsb3llZSBpcyBUcmFja2Vk6ACCPMgcUHJvcGVydGllcz7lAp4uLukApuQDUFBhcmFtZXRlcskxPjvoAIbJX3DJRNJ8ymDpAv1BZ2Ugb2YgZcg%2F5gF4YWRk6wN%2BLuwBveQBEGFnZT86IGludDMyO%2BgBzENpdHnSSmNpdHk%2FOiBzdHLlBIPHLFByb2ZpbNR5cmVtb3bce%2FQAm%2FABm8UoZW5jb2RlKCJiYXNlNjR1cmwixBdwxno%2FOiBieXRlc%2BkAklRoZSBzdGF0dXPkAJV0aGUgbGFzdCDkAS9hdGlvbuUE4CAgQHZpc2liaWxpdHkoTGlmZWN5Y2zkAkphZMddxCDlBW9TdGF0xGflAhXMFOkBssRzzDLlAIDlARRh6QI%2FxXdAbHJvxDt1cwp1buQDHNFU5QHO5gFk6QNcxF%2FIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx1cGRhdMRPxUNVxw46ICLIC8o76QaJ6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBuHHC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QRn6QPh5AMh6QHK6QPjTW92ZVLHFegD3MRzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA5rLM3RvzzF0b8ov9wCVc3BvbnPrBPXmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AgAT%2BgDlHMgZXh0ZW5kc%2FYIwi7LKXt9CuUInsgjyhvLWegAzeYFHWdldOQBp0HKNeQD5%2BwFeiDnAntPcuUCp%2BUB1ssvQ8cdUmVwbGFjZUFzeW5jzj%2FlAvfIN0N1c3RvbVBhdGNoU8QqCiAgIOkAkyzFDvYA50ZvdW7kAybkBQ7IHOYAkU3kAYTGSdBLyhDqBhTFGT4KICDlAJ3mAprvANTlApdlV2l0aG91dE9r8wDUbGlzdEJ5yDBHcm91cM9ETMUiUGFyZW501DxTdWJzY3JpcOUCecY7xjPMGcw56AbKIHNhbXBs6wNmYWPFRHRoYXTmAmPpBm10byBkaWZmZeQAhO8C5sUp7gCyQcVI5QGWyHcs7ANxyA3mAujzAJJIRUFE6gZMxH5jaGVja%2BoAqmV4aXN0ZW7mCDAgxh5FyRTvAljNHe4ICw%3D%3D&e=%40azure-tools%2Ftypespec-autorest&vs=%7B%7D)\n```\n/** Contoso API versions */\nenum Versions {\n/** 2021-10-01-preview version */\n@useDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)\n@armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\n`2021-10-01-preview`,\n/** 2024-10-01 version */\n@useDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)\n@armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\n`2024-10-01`,\n/** 2025-07-01-preview version */\n@useDependency(Azure.ResourceManager.Versions.v1_0_Preview_1)\n@armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\n`2025-07-01-preview`,\n}\n/** A ContosoProviderHub resource */\nmodel Employee is TrackedResource<EmployeeProperties> {\n...ResourceNameParameter<Employee>;\n}\n/** Employee properties */\nmodel EmployeeProperties {\n/** Age of employee */\n@added(Versions.`2024-10-01`)\nage?: int32;\n/** City of employee */\ncity?: string;\n/** Profile of employee */\n@removed(Versions.`2024-10-01`)\n@added(Versions.`2025-07-01-preview`)\n@encode(\"base64url\")\nprofile?: bytes;\n/** The status of the last operation. */\n@visibility(Lifecycle.Read)\nprovisioningState?: ProvisioningState;\n}\n```\nshowing two propertties (EmployeeProperties.age and EmployeeProperties.profile) that use versioning.  'age' appears in the second, stable version and all subsequent versions,  'profile' appears in the first (preview) version, is removed in the stable version, and then added back again in the subsequent preview version.\nNotably, this practice of adding a property at each preview version and removing it at each stable is easy to get wrong.\nthe official Azure policy is to have only one active preview, as much as that is possible with api retention requirements.  So that, when you introduce a new preview version, the older preview is removed, ideally, this means that, especially when you just had a stable release, you remove support for the previous preview when (or soon after) you add the new preview version.\nYou can see more details about versioning in typespec here: [Versioning | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/getstarted/versioning/)",
            "references": [
                {
                    "title": "How to define a preview version | Preview Versioning Rules for All Azure APIs",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/versioning/01-preview-version"
                },
                {
                    "title": "Creating stable API version with select properties omitted? | answer",
                    "link": ""
                },
                {
                    "title": "Adding a Stable Version when the Last Version was Preview | Making Changes to your TypeSpec spec",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/versioning/arm/03-stable-after-preview"
                },
                {
                    "title": "How to Manage a Single Active Preview When Some Features Always Remain In Preview",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/versioning/arm/uncommon-scenarios/02-perpetual-preview"
                }
            ]
        },
        "actual": {
            "answer": "No, you cannot have multiple versions marked with @previewVersion in TypeSpec. According to Azure API guidelines and TypeSpec best practices, only one version should be marked with @previewVersion at any time. This is enforced to ensure clarity and consistency in API evolution and SDK/tooling support.\n\nTo handle properties that should exist in multiple preview versions but be excluded from stable releases, you must use the @added and @removed decorators to precisely control their presence across versions. Here\u2019s how you should approach your scenario:\n\n1. When you introduce a new stable version, you must decide which preview-only features are ready to be GA (stable) and which are not. For features not ready for GA, you should:\n   - Remove them from the stable version using @removed(<stable_version>).\n   - If you want them to continue in the next preview, add them back with @added(<next_preview_version>).\n\n2. You should not have multiple active previews. When you add a new preview version, you should remove the previous preview version from your spec (or at least from the versions enum and @previewVersion decorator). This is the official Azure policy and is required for correct TypeSpec and SDK generation.\n\n3. For properties that are in multiple previews but not in stable, you must use a pattern like:\n\n```tsp\nmodel Example {\n  // This property was in preview1, removed in stable, added back in preview2\n  @added(Versions.preview1)\n  @removed(Versions.stable)\n  @added(Versions.preview2)\n  previewOnlyProperty?: string;\n}\n```\n\nThis ensures the property appears in the first preview, is omitted from the stable, and reappears in the next preview.\n\n4. The TypeSpec versioning system is designed to model changes incrementally. When you add a new preview, you should forward the decorators as needed, but always ensure only one version is marked as @previewVersion.\n\n5. If you need to retain OpenAPI for older previews for ARM validation or registration, you can keep the generated OpenAPI files, but your TypeSpec should only have one active preview version.\n\nIn summary: Only one @previewVersion is allowed. Use @added and @removed to manage property presence across versions. Remove previous previews from the TypeSpec when adding a new preview. This is the only supported and compliant way to handle your scenario.",
            "references": [
                {
                    "title": "How to define a preview version | Preview Versioning Rules for All Azure APIs",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/versioning/01-preview-version"
                },
                {
                    "title": "Creating stable API version with select properties omitted? | answer",
                    "link": ""
                },
                {
                    "title": "How to Manage a Single Active Preview When Some Features Always Remain In Preview",
                    "link": "https://azure.github.io/typespec-azure/docs/howtos/versioning/arm/uncommon-scenarios/02-perpetual-preview"
                },
                {
                    "title": "Versioning | Adding a Property or Parameter",
                    "link": "https://azure.github.io/typespec-azure/docs/getstarted/versioning"
                }
            ]
        },
        "similarity": 4.0,
        "gpt_similarity": 4.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": NaN,
        "gpt_groundedness": NaN,
        "groundedness_reason": "",
        "groundedness_result": "unknown",
        "groundedness_threshold": 3.0,
        "response_completeness": 5.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains all necessary and relevant information from the ground truth, including the versioning mechanism, decorator usage, Azure policy on previews, and a representative code example. No key information is missing.",
        "reference_match": 0.75,
        "reference_match_result": "fail",
        "knowledge_match": 0.8,
        "knowledge_match_result": "pass",
        "overall_score": NaN
    },
    {
        "testcase": "LRO header return 200",
        "expected": {
            "answer": "Based on ARM RPC guidelines and the TypeSpec ARM templates:\n1.You generally should NOT model \u201csubsequent PUT returns 202\u201d for a resource PUT.\nFor ARM resource PUT, the required pattern is: return `201` for create and `200` for update, and if the operation is long-running you still use `x-ms-long-running-operation: true` and include the appropriate LRO headers.\nReturning `202` for PUT is explicitly called out as an old model and is no longer supported for new resource types/patterns.\n2.If your service returns an async polling header on the `200` response, it\u2019s OK (and often desirable) to specify it \u2014 but only if the operation is actually long-running in that case.\nIn ARM, the LRO \u201cpolling\u201d header is typically `Azure-AsyncOperation` (required for greenfield starting Jan 2025 per RPC contract) and/or `Location` (required for 202 patterns; also commonly used).\nFor PUT LROs, the standard ARM templates already model the correct behavior: `200` and `201` responses with the resource body, and LRO headers on the create response (and depending on template/pattern, can be present when the operation is async).\n3.Recommended way to model this in TypeSpec (preferred over hand-authoring swagger)\nUse the ARM operation template for async PUT, and let the emitter generate the correct OpenAPI, including `x-ms-long-running-operation-options.final-state-via`.\nIf you need `Azure-AsyncOperation` to be the final-state mechanism, use the template that emits that (e.g. `ArmResourceCreateOrUpdateAsync` / `ArmResourceCreateOrReplaceAsync` depending on your chosen semantics).\nExample (management-plane, ARM):\n```\nimport \"@azure-tools/typespec-azure-resource-manager\";\nusing Azure.ResourceManager;\n@armResourceOperations\ninterface ManagedClusters {\n// Pick the template that matches your service\u2019s LRO header behavior.\n// This produces 200/201 + x-ms-long-running-operation and final-state-via azure-async-operation.\ncreateOrUpdate is ArmResourceCreateOrReplaceAsync<ManagedCluster>;\n}\n```\n4.If you truly must keep a 202-on-PUT behavior (brownfield), align it to ARM guidance rather than just documenting the current behavior.\nThe guidance is to fix the service to return `200/201` for PUT (even when async) and rely on LRO headers + provisioningState.\nIf you cannot change runtime behavior immediately, you should discuss with ARM/API review because it conflicts with the current ARM contract guidance for PUT.\n5.About \u201c200 response with async operation header\u201d specifically\nIn OpenAPI/Swagger, you can absolutely define headers on the `200` response. There\u2019s nothing structurally preventing it.\nHowever, the recommended ARM modeling is to use the standard templates so the LRO metadata is consistent (headers + `x-ms-long-running-operation` + `final-state-via`). Don\u2019t invent a one-off pattern unless you have to.\nIf you paste the relevant snippet of your current swagger responses for one of these PUTs (the `responses` block), I can tell you exactly what to change and which TypeSpec template/parameters best match your service behavior (including whether you should be using `ArmResourceCreateOrReplaceAsync` vs `ArmResourceCreateOrUpdateAsync`, and whether you need `Location` and/or `Azure-AsyncOperation`).",
            "references": [
                {
                    "title": "Asynchronous API Reference",
                    "link": "https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/async-api-reference.md"
                },
                {
                    "title": "put-operation-response-codes",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/rules/put-operation-response-codes"
                },
                {
                    "title": "TypeSpec Definitions | ArmResourceCreateOrUpdateAsync",
                    "link": ""
                },
                {
                    "title": "LRO Header Data Type",
                    "link": ""
                }
            ]
        },
        "actual": {
            "answer": "I can\u2019t access the GitHub/ADO links you included, but based on the behavior you described and ARM LRO guidance:\n\nYes\u2014if your service returns `Azure-AsyncOperation` on the initial `200` response, you should model that header in the spec. Otherwise, generated clients/tools won\u2019t know they can (or should) poll, and you\u2019ll also be out of alignment with the ARM async contract that expects `Azure-AsyncOperation` to be the operation-resource URL.\n\nThat said, the bigger issue is the *status-code pattern*: for ARM resource PUT create/replace, the recommended LRO pattern is `201` (create) / `200` (update) with the resource body including `provisioningState` while in progress. Returning `202` for \u201csubsequent PUTs\u201d is the legacy pattern and is no longer recommended for new resource types. If you must keep it for backward compatibility, you can still model it, but consider aligning the service behavior over time.\n\nRecommended TypeSpec modeling pattern (ARM):\n\n1) Use the ARM operation template for async PUT (`ArmResourceCreateOrUpdateAsync` or `ArmResourceCreateOrReplaceAsync`) so the emitter/linter understands it\u2019s an LRO.\n2) Override the success `Response` union to include a `200` response variant that carries `Azure-AsyncOperation` (and `Retry-After` if you return it).\n3) Ensure the LRO metadata has a final result schema (so `x-ms-long-running-operation-options.final-state-schema` can be emitted when applicable).\n\nExample (pattern for \u201c200 with Azure-AsyncOperation header\u201d):\n\n```typespec\nimport \"@azure-tools/typespec-azure-core\";\nimport \"@azure-tools/typespec-azure-resource-manager\";\n\nusing Azure.Core;\nusing Azure.ResourceManager;\n\n// Reusable header set: Azure-AsyncOperation (+ optional Location) + Retry-After\nalias PutLroHeaders = {\n  ...ArmAsyncOperationHeader<FinalResult = ManagedCluster>;\n  ...Azure.Core.Foundations.RetryAfterHeader;\n};\n\n// If you also return Location sometimes, prefer combined headers:\n// alias PutLroHeaders = {\n//   ...ArmCombinedLroHeaders<FinalResult = ManagedCluster>;\n//   ...Azure.Core.Foundations.RetryAfterHeader;\n// };\n\n// A 200 response that includes the resource body AND the async header.\nalias ManagedClusterPut200 = ArmResponse<ManagedCluster> & {\n  @header(\"Azure-AsyncOperation\")\n  @Azure.Core.pollingLocation(Azure.Core.StatusMonitorPollingOptions<PollingModel = ArmOperationStatus>)\n  @Azure.Core.finalLocation(ManagedCluster)\n  azureAsyncOperation?: string;\n\n  // If you already defined PutLroHeaders above, you can instead do:\n  // ...PutLroHeaders;\n};\n\n@armResourceOperations\ninterface ManagedClusters {\n  @put\n  @Azure.Core.useFinalStateVia(\"azure-async-operation\")\n  createOrUpdate is ArmResourceCreateOrUpdateAsync<\n    ManagedCluster,\n    // Override the success responses to include your 200-with-header shape.\n    Response = ManagedClusterPut200 |\n      ArmResourceCreatedResponse<ManagedCluster, PutLroHeaders> |\n      ArmAcceptedLroResponse<LroHeaders = PutLroHeaders>\n  >;\n}\n```\n\nNotes:\n- If your initial create really returns `200` (not `201`) and you need to preserve that, the key is: define a `200` response type that includes the header(s) and the body, and include it in the operation\u2019s `Response` union.\n- If you return `202`, ARM linter rules also require a `Location` header on `202` responses. If you\u2019re returning `202` without `Location`, you should fix the service and/or model `ArmCombinedLroHeaders` so both headers are present.\n- Prefer using the provided ARM header models (`ArmAsyncOperationHeader`, `ArmLroLocationHeader`, `ArmCombinedLroHeaders`) rather than hand-rolling headers, because they carry the right `@pollingLocation`/`@finalLocation` metadata.\n\nIf you paste the current TypeSpec (or Swagger) response shapes for those PUTs (200/202/201), I can suggest the smallest change that both matches your wire behavior and satisfies the ARM linter rules.",
            "references": [
                {
                    "title": "Asynchronous API Reference | Creating or Replacing using Put",
                    "link": "https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/async-api-reference.md"
                },
                {
                    "title": "Data types | Azure.ResourceManager | `ArmAsyncOperationHeader`",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types"
                },
                {
                    "title": "Data types | Azure.ResourceManager | `ArmCombinedLroHeaders`",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types"
                },
                {
                    "title": "missing final result for lro | answer",
                    "link": "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange"
                },
                {
                    "title": "lro-location-header",
                    "link": "https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/rules/lro-location-header"
                }
            ]
        },
        "similarity": 5.0,
        "gpt_similarity": 5.0,
        "similarity_result": "pass",
        "similarity_threshold": 4,
        "groundedness": 5.0,
        "gpt_groundedness": 5.0,
        "groundedness_reason": "",
        "groundedness_result": "pass",
        "groundedness_threshold": 3,
        "response_completeness": 4.0,
        "response_completeness_result": "pass",
        "response_completeness_threshold": 4,
        "response_completeness_reason": "The response contains most of the necessary and relevant information from the ground truth, with only minor omissions or paraphrasing. It covers the ARM guidance, recommended modeling patterns, legacy 202-on-PUT, header modeling, and offers to review code for precise changes.",
        "reference_match": 0.0,
        "reference_match_result": "fail",
        "knowledge_match": 0.5,
        "knowledge_match_result": "fail",
        "overall_score": 7.1
    },
    {
        "average_score": NaN,
        "total_evals": 33,
        "similarity_pass_rate": 33,
        "groundedness_pass_rate": 23,
        "response_completeness_pass_rate": 32,
        "reference_match_pass_rate": 17,
        "knowledge_match_pass_rate": 25,
        "similarity_fail_rate": 1,
        "groundedness_fail_rate": 0,
        "response_completeness_fail_rate": 2,
        "reference_match_fail_rate": 16,
        "knowledge_match_fail_rate": 8
    }
]