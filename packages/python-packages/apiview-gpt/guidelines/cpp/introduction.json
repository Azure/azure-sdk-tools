[
  {
    "id": "cpp-general-follow-general-guidelines",
    "category": "General Guidelines {#cpp-general}",
    "text": "DO follow the [General Azure SDK Guidelines].\n\nThis document contains guidelines developed primarily for typical Azure REST services, i.e. stateless services with request-response based interaction model. Many of the guidelines in this document are more broadly applicable, but some might be specific to such REST services.\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "cpp-design-naming-concise",
    "category": "Azure SDK API Design {#cpp-api}",
    "text": "DO use clear, concise, and meaningful names."
  },
  {
    "id": "cpp-design-naming-abbrev",
    "category": "Azure SDK API Design {#cpp-api}",
    "text": "YOU SHOULD NOT use abbreviations unless necessary or when they are commonly used and understood.  For example, az is allowed since it is commonly used to mean Azure, and iot is used since it is a commonly understood industry term.  However, using kv for Key Vault would not be allowed since kv is not commonly used to refer to Key Vault."
  },
  {
    "id": "cpp-design-dependencies-adparch",
    "category": "Azure SDK API Design {#cpp-api}",
    "text": "DO consult the [Architecture Board] if you wish to use a dependency that is not on the list of approved dependencies.\n\nService clients are the main starting points for developers calling Azure services with the Azure SDK. Each client library should have at least one client in its main namespace, so it\u2019s easy to discover. The guidelines in this section describe patterns for the design of a service client.\n\nThere exists a distinction that must be made clear with service clients: not all classes that perform HTTP (or otherwise) requests to a service are automatically designated as a service client. A service client designation is only applied to classes that are able to be directly constructed because they are uniquely represented on the service. Additionally, a service client designation is only applied if there is a specific scenario that applies where the direct creation of the client is appropriate. If a resource can not be uniquely identified or there is no need for direct creation of the type, then the service client designation should not apply."
  },
  {
    "id": "cpp-service-client-name",
    "category": "Service Client {#cpp-client}",
    "text": "DO name service client types with the Client suffix (for example, ConfigurationClient)."
  },
  {
    "id": "cpp-service-client-namespace",
    "category": "Service Client {#cpp-client}",
    "text": "DO place service client types that the consumer is most likely to interact with in the root namespace of the client library (for example, Azure::<group>::<service>). Specialized service clients should be placed in sub-packages."
  },
  {
    "id": "cpp-service-client-type",
    "category": "Service Client {#cpp-client}",
    "text": "DO make service clients classes, not structs."
  },
  {
    "id": "cpp-service-client-immutable",
    "category": "Service Client {#cpp-client}",
    "text": "DO ensure that all service client classes thread safe (usually by making them immutable and stateless)."
  },
  {
    "id": "cpp-service-client-geturl",
    "category": "Service Client {#cpp-client}",
    "text": "DO expose a GetUrl() method which returns the URL."
  },
  {
    "id": "cpp-service-client-constructor-minimal",
    "category": "Service Client Constructors {#cpp-client-ctor}",
    "text": "DO provide a minimal constructor that takes only the parameters required to connect to the service.\n\nTODO: Add service client factory pattern examples for connection strings."
  },
  {
    "id": "cpp-client-constructor-no-default-params",
    "category": "Service Client Constructors {#cpp-client-ctor}",
    "text": "DO NOT use default parameters in the simplest constructor."
  },
  {
    "id": "cpp-client-constructor-overloads",
    "category": "Service Client Constructors {#cpp-client-ctor}",
    "text": "DO provide constructor overloads that allow specifying additional options via  an options parameter. The type of the parameter is typically a subclass of ClientOptions type, shown below."
  },
  {
    "id": "cpp-config-global-config",
    "category": "Client Configuration",
    "text": "DO use relevant global configuration settings either by default or when explicitly requested to by the user, for example by passing in a configuration object to a client constructor."
  },
  {
    "id": "cpp-config-for-different-clients",
    "category": "Client Configuration",
    "text": "DO allow different clients of the same type to use different configurations."
  },
  {
    "id": "cpp-config-optout",
    "category": "Client Configuration",
    "text": "DO allow consumers of your service clients to opt out of all global configuration settings at once."
  },
  {
    "id": "cpp-config-global-overrides",
    "category": "Client Configuration",
    "text": "DO allow all global configuration settings to be overridden by client-provided options. The names of these options should align with any user-facing global configuration keys."
  },
  {
    "id": "cpp-config-defaults-nochange",
    "category": "Client Configuration",
    "text": "DO NOT Change the default values of client\nconfiguration options based on system or program state."
  },
  {
    "id": "cpp-config-defaults-nobuildchange",
    "category": "Client Configuration",
    "text": "DO NOT Change default values of\nclient configuration options based on how the client library was built."
  },
  {
    "id": "cpp-config-behaviour-changes",
    "category": "Client Configuration",
    "text": "DO NOT change behavior based on configuration changes that occur after the client is constructed. Hierarchies of clients inherit parent client configuration unless explicitly changed or overridden. Exceptions to this requirement are as follows:\nLog level, which must take effect immediately across the Azure SDK.\nTracing on/off, which must take effect immediately across the Azure SDK."
  },
  {
    "id": "cpp-config-noruntime",
    "category": "Client Configuration",
    "text": "DO NOT use client library specific runtime\nconfiguration such as environment variables or a config file. Keep in mind that many IoT devices\nwon't have a filesystem or an \"environment block\" to read from.\n\nTODO: This section needs to be driven by code in the Core library.\n\nTODO: This section needs to be driven by code in the Core library."
  },
  {
    "id": "cpp-versioning-highest-api",
    "category": "Service Versions",
    "text": "DO call the highest supported service API version by default."
  },
  {
    "id": "cpp-versioning-select-api-version",
    "category": "Service Versions",
    "text": "DO allow the consumer to explicitly select a supported service API version when instantiating the service client.\n\nUse a constructor parameter called version on the client options type.\nThe version parameter must be the first parameter to all constructor overloads.\nThe version parameter must be required, and default to the latest supported service version.\nThe type of the version parameter must be ServiceVersion; an enum nested in the options type.\nThe ServiceVersion enum must use explicit values starting from 1.\nServiceVersion enum value 0 is reserved. When 0 is passed into APIs, ArgumentException should be thrown.\n\nTODO: This section needs to be driven by code in the Core library.\n\nTODO: This section needs to be driven by code in the Core library.\n\nService methods are the methods on the client that invoke operations on the service.\n\nThe C++ SDK is designed for synchronous api calls."
  },
  {
    "id": "cpp-design-client-sync-api",
    "category": "Sync and Async",
    "text": "DO provide a synchronous programming model."
  },
  {
    "id": "cpp-design-client-sync-api",
    "category": "Sync and Async",
    "text": "DO NOT provide an async programming model.\n\nTODO: This section needs to be driven by code in the Core library.\n\nPascalCase identifiers start with an uppercase letter and then use additional capital letters to divide words. Acronyms and initialisms are capitalized if they are 2 letters or shorter; otherwise only the first letter is capitalized. For example, PascalCase, HttpRequest, JsonParser, or IOContext.\n\n\ncamelCase identifiers start with a lowercase letter and then use additional capital letters to divide words. Acronyms and initialisms that start an identifier are all lowercase if they begin an identifier, otherwise they follow the same 2 letters rule as PascalCase. For example, camelCase, httpRequest, processHttp, ioContext, startIO.\n\n\nALL_CAPITAL_SNAKE_CASE identifiers are composed of entirely capital letters and divide words with underscores.\n\n\nPascalCase identifiers start with an uppercase letter and then use additional capital letters to divide words. Acronyms and initialisms are capitalized if they are 2 letters or shorter; otherwise only the first letter is capitalized. For example, PascalCase, HttpRequest, JsonParser, or IOContext.\n\ncamelCase identifiers start with a lowercase letter and then use additional capital letters to divide words. Acronyms and initialisms that start an identifier are all lowercase if they begin an identifier, otherwise they follow the same 2 letters rule as PascalCase. For example, camelCase, httpRequest, processHttp, ioContext, startIO.\n\nALL_CAPITAL_SNAKE_CASE identifiers are composed of entirely capital letters and divide words with underscores."
  },
  {
    "id": "cpp-design-naming-functions",
    "category": "Naming",
    "text": "DO name functions with PascalCase. For example:\n\n{% highlight cpp %}\nnamespace Azure { namespace Group { namespace Service {\nnamespace _detail {\n// Part of the private API\n[[nodiscard]] int64_t ComputeHash(int32_t a, int32_t b) noexcept;\n} // namespace _detail\n\n// Part of the public API\n[[nodiscard]] CatHerdClient CatHerdCreateClient(char* herdName);\n\n// Bad - private API in public namespace.\n[[nodiscard]] int64_t ComputeHash(int32_t a, int32_t b) noexcept;\n}}} // namespace Azure::Group::Service\n{% endhighlight %}"
  },
  {
    "id": "cpp-design-naming-functions-noexcept",
    "category": "Naming",
    "text": "YOU SHOULD declare all functions that can never throw exceptions noexcept."
  },
  {
    "id": "cpp-design-naming-variables-public-global",
    "category": "Naming",
    "text": "DO name namespace scope variables intended for user consumption with PascalCase."
  },
  {
    "id": "cpp-design-naming-variables-constants",
    "category": "Naming",
    "text": "DO name namespace scope const or constexpr variables intended for user consumption with PascalCase."
  },
  {
    "id": "cpp-design-naming-variables-public-global",
    "category": "Naming",
    "text": "DO name namespace scope non-constant variables intended only for internal consumption with a g_ prefix followed by camelCase. For example, g_applicationContext. Note that all such cases will be in a _detail namespace or an unnamed namespace."
  },
  {
    "id": "cpp-design-naming-variables-local",
    "category": "Naming",
    "text": "DO name local variables and parameters with camelCase.\n\n{% highlight cpp %}\n// Examples of the above naming rules:\n\nnamespace Azure { namespace Group { namespace Service {\nint PublicNamespaceScopeVariable; // these should be used sparingly\nconst int PublicNamespaceScopeConstant = 42;\nconstexpr int OtherPublicNamespaceScopeConstant = 42;\nconstexpr char * PublicNamespaceScopeConstantPointer = nullptr; // const pointer to modifiable\n\nvoid Function(int parameterName) {\nint localName;\n}\n\nnamespace _detail {\nextern int g_internalUseGlobal;\n} // namespace _detail\n\n}}} // namespace Azure::Group::Service\n{% endhighlight %}"
  },
  {
    "id": "cpp-design-naming-variables-typing-units",
    "category": "Naming",
    "text": "DO use types to enforce units where possible. For example, the C++ standard library provides std::chrono which makes time conversions automatic.\n{% highlight cpp %}\n// Bad\nuint32 Timeout;\n\n// Good\nstd::chrono::milliseconds Timeout;\n{% endhighlight %}"
  },
  {
    "id": "cpp-design-naming-naming-units",
    "category": "Naming",
    "text": "DO include units in names when a type based solution to enforce units is not present.  If a variable represents weight, or some other unit, then include the unit in the name so developers can more easily spot problems.  For example:\n\n{% highlight cpp %}\n// Bad\nuint32 Timeout;\nuint32 MyWeight;\n\n// Good\nstd::chrono::milliseconds Timeout;\nuint32 MyWeightKg;\n{% endhighlight %}"
  },
  {
    "id": "cpp-design-naming-variables-one-per-line",
    "category": "Naming",
    "text": "DO Declare or define each variable on its own line, except when declaring bitfields. An exception can be made when declaring bitfields (to clarify that the variable is a part of one bitfield). The use of bitfields in general is discouraged."
  },
  {
    "id": "cpp-service-methods-cancellation",
    "category": "Cancellation",
    "text": "DO ensure all service methods, both asynchronous and synchronous, take an optional Context parameter called context.\n\nThe context should be further passed to all calls that take a context. DO NOT check the context manually, except when running a significant amount of CPU-bound work within the library, e.g. a loop that can take more than a typical network call.\n\nTODO: This section needs to be driven by code in the Core library."
  },
  {
    "id": "cpp-design-client-return-types",
    "category": "Return Types",
    "text": "DO return Response<T> or Response from synchronous methods.\n\nT represents the content of the response, as described below.\n\nThe T can be either an unstructured payload (e.g. bytes of a storage blob) or a model type representing deserialized response content."
  },
  {
    "id": "cpp-design-client-return-unstructured-type",
    "category": "Return Types",
    "text": "DO use one of the following return types to represent an unstructured payload:\n\nTODO: What type should be used for large streaming payloads?\nTODO - for large payloads\nbyte[] - for small payloads"
  },
  {
    "id": "cpp-design-client-return-model-type",
    "category": "Return Types",
    "text": "DO return a model type if the content has a schema and can be deserialized.\n\nFor more information, see Model Types\n\nRequests to the service fall into two basic groups - methods that make a single logical request, or a deterministic sequence of requests.  An example of a single logical request is a request that may be retried inside the operation.  An example of a deterministic sequence of requests is a paged operation.\n\nThe logical entity is a protocol neutral representation of a response. For HTTP, the logical entity may combine data from headers, body and the status line. A common example is exposing an ETag header as a property on the logical entity in addition to any deserialized content from the body."
  },
  {
    "id": "cpp-design-logical-client-return-logical-entities",
    "category": "Return Types",
    "text": "DO optimize for returning the logical entity for a given request. The logical entity MUST represent the information needed in the 99%+ case."
  },
  {
    "id": "cpp-design-logical-client-expose-raw",
    "category": "Return Types",
    "text": "DO make it possible for a developer to get access to the complete response, including the status line, headers and body. The client library MUST follow the language specific guidance for accomplishing this.\n\nFor example, you may choose to do something similar to the following:\n\n{% highlight cpp %}\nnamespace Azure { namespace Group { namespace Service {\nstruct JsonShortItem {\n// JSON decoded structure.\n};\n\nstruct JsonShortPagedResults {\nuint32 Size;\nJsonShortItem* Items;\n};\n\nstruct JsonShortRawPagedResults {\nHTTP_HEADERS* Headers;\nuint16 StatusCode;\nbyte* RawBody;\nJsonShortPagedResults* Results;\n};\n\nclass ShortItemsClient {\nJsonShortPagedResults* JsonGetShortListItems() const;\nJsonShortRawPagedResults* JsonGetShortListItemsWithResponse(client, /* extra params */);\n};\n}}} // namespace Azure::Group::Service\n{% endhighlight %}"
  },
  {
    "id": "cpp-design-logical-client-document-raw-stream",
    "category": "Return Types",
    "text": "DO document and provide examples on how to access the raw and streamed response for a given request, where exposed by the client library.  We do not expect all methods to expose a streamed response.\n\nFor methods that combine multiple requests into a single call:"
  },
  {
    "id": "cpp-design-logical-client-no-headers-if-confusing",
    "category": "Return Types",
    "text": "DO NOT return headers and other per-request metadata unless it is obvious as to which specific HTTP request the methods return value corresponds to."
  },
  {
    "id": "cpp-design-logical-client-expose-data-for-composite-failures",
    "category": "Return Types",
    "text": "DO provide enough information in failure cases for an application to take appropriate corrective action."
  },
  {
    "id": "cpp-design-client-methods-thread-safety",
    "category": "Thread Safety",
    "text": "DO be thread-safe. All public members of the client type must be safe to call from multiple threads concurrently.\n\nTODO: This section needs to be driven by code in the Core library.\n\nThe service client will have several methods that perform requests on the service.  Service parameters are directly passed across the wire to an Azure service.  Client parameters are not passed directly to the service, but used within the client library to fulfill the request.  Examples of client parameters include values that are used to construct a URI, or a file that needs to be uploaded to storage."
  },
  {
    "id": "cpp-params-client-validation",
    "category": "Parameter Validation",
    "text": "DO validate client parameters."
  },
  {
    "id": "cpp-params-server-validation",
    "category": "Parameter Validation",
    "text": "DO NOT validate service parameters.  This includes null checks, empty strings, and other common validating conditions. Let the service validate any request parameters."
  },
  {
    "id": "cpp-params-check-devex",
    "category": "Parameter Validation",
    "text": "DO validate the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service.  If the developer experience is compromised due to service-side error messages, work with the service team to correct prior to release.\n\nAlthough object-orientated languages can eschew low-level pagination APIs in favor of high-level abstractions, C acts as a lower level language and thus embraces pagination APIs provided by the service.  You should work within the confines of the paging system provided by the service."
  },
  {
    "id": "cpp-design-logical-client-pagination-use-paging",
    "category": "Methods Returning Collections (Paging) {#cpp-paging}",
    "text": "DO export the same paging API as the service provides."
  },
  {
    "id": "cpp-design-logical-client-pagination-cpp-last-page",
    "category": "Methods Returning Collections (Paging) {#cpp-paging}",
    "text": "DO indicate in the return type if the consumer has reached the end of the result set."
  },
  {
    "id": "cpp-design-logical-client-pagination-size-of-page",
    "category": "Methods Returning Collections (Paging) {#cpp-paging}",
    "text": "DO indicate in the return type how many items were returned by the service, and have a list of those items for the consumer to iterate over.\n\nSome service operations, known as Long Running Operations or LROs take a long time (up to hours or days). Such operations do not return their result immediately, but rather are started, their progress is polled, and finally the result of the operation is retrieved.\n\nAzure::Core library exposes an abstract type called Operation<T>, which represents such LROs and supports operations for polling and waiting for status changes, and retrieving the final operation result.  A service method invoking a long running operation will return a subclass of Operation<T>, as shown below.\n\nTODO: This section needs to be driven by code in the Core library."
  },
  {
    "id": "cpp-lro-prefix",
    "category": "Methods Invoking Long Running Operations {#cpp-longrunning}",
    "text": "DO name all methods that start an LRO with the Start prefix."
  },
  {
    "id": "cpp-lro-return",
    "category": "Methods Invoking Long Running Operations {#cpp-longrunning}",
    "text": "DO return a subclass of Operation<T> from LRO methods."
  },
  {
    "id": "cpp-lro-subclass",
    "category": "Methods Invoking Long Running Operations {#cpp-longrunning}",
    "text": "YOU MAY add additional APIs to subclasses of Operation<T>.\nFor example, some subclasses add a constructor allowing to create an operation instance from a previously saved operation ID. Also, some subclasses are more granular states besides the IsDone and HasValue states that are present on the base class.\n\nTODO: This section needs to be driven by code in the Core library.\n\nTODO: This section needs to be driven by code in the Core library.\n\nIn addition to service client types, Azure SDK APIs provide and use other supporting types as well.\n\nThis section describes guidelines for the design model types and all their transitive closure of public dependencies (i.e. the model graph).  A model type is a representation of a REST service's resource."
  },
  {
    "id": "cpp-design-model-public-getters",
    "category": "Model Types {#cpp-model-types}",
    "text": "DO ensure model public properties are const if they aren't intended to be changed by the user.\n\nMost output-only models can be fully read-only. Models that are used as both outputs and inputs (i.e. received from and sent to the service) typically have a mixture of read-only and read-write properties.\n\nTODO: This section needs to be driven by code in the Core library.\n\nTODO: This section needs to be driven by code in the Core library.\n\nTODO: This section needs to be driven by code in the Core library."
  },
  {
    "id": "cpp-design-enums",
    "category": "Enumerations",
    "text": "DO use an enum for parameters, properties, and return types when values are known."
  },
  {
    "id": "cpp-design-enums-exception",
    "category": "Enumerations",
    "text": "YOU MAY use a struct in place of an enum class that declares well-known fields but can contain unknown values returned from the service, or user-defined values passed to the service.\n\nSee enumeration-like structure documentation for implementation details.\n\nThe azure-core package provides common functionality for client libraries.  Documentation and usage examples can be found in the azure/azure-sdk-for-cpp (https://github.com/Azure/azure-sdk-for-cpp/tree/main/sdk/core/azure-core) repository.\n\nTODO: This section needs to be driven by code in the Core library."
  },
  {
    "id": "cpp-primitives-etag",
    "category": "Using Primitive Types",
    "text": "DO use Azure::Core::ETag to represent ETags.\n\nThe Azure::Core::ETag type is located in azure-core package."
  },
  {
    "id": "cpp-primitives-uri",
    "category": "Using Primitive Types",
    "text": "DO use Azure::Core::Uri to represent URIs.\n\nThe Azure::Core::Uri type is located in azure-core package.\n\nError handling is an important aspect of implementing a client library. It is the primary method by which problems are communicated to the consumer. Because we intend for the C client libraries to be used on a wide range of devices with a wide range of reliability requirements, it's important to provide robust error handling.\n\nWe distinguish between several different types of errors:\nExhaustion / Act of God\n: errors like running out of stack space, or dealing with power failure that, in general, can not be anticipated and after which it may be hard to execute any more code, let alone recover. Code handling these errors needs to be written to very specific requirements, for example not doing any allocations and never growing the stack.\nPre-Conditions\n: Pre-Condition errors occur when a caller violates the expectations of a function, for example by passing an out-of-range value or a null pointer. These are always avoidable by the direct caller, and will always require a source code change (by the caller) to fix.\nPost-Conditions\n: Post-Condition violations happen when some function didn't do the correct thing, these are always bugs in the function itself, and users shouldn't be expected to handle them.\nHeap Exhaustion (Out of Memory)\n: Running out of memory.\nRecoverable Error\n: Things like trying to open a file that doesn't exist, or trying to write to a full disk. These kinds of errors can usually be handled by a function's caller directly, and need to be considered by callers that want to be robust.\n\nExhaustion / Act of God"
  },
  {
    "id": "cpp-design-logical-errorhandling-actofgod-no-return",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO NOT return an error to the caller."
  },
  {
    "id": "cpp-design-logical-errorhandling-actofgod-crash",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO crash, if possible. This means calling some form of fast failing function, like abort.\n\nNote: if your client library needs to be resilient to these kinds of errors you must either provide a fallback system, or construct your code in a way to facilitate proving that such errors can not occur.\n\nPre-conditions"
  },
  {
    "id": "cpp-design-logical-errorhandling-prec-check",
    "category": "Exceptions {#cpp-errors}",
    "text": "YOU MAY check preconditions on function entry."
  },
  {
    "id": "cpp-design-logical-errorhandling-prec-disablecheck",
    "category": "Exceptions {#cpp-errors}",
    "text": "YOU MAY privide a means to disable precondition checks in release / optimized builds."
  },
  {
    "id": "cpp-design-logical-errorhandling-prec-crash",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO crash, if possible. This means calling some form of fast failing function, like abort."
  },
  {
    "id": "cpp-design-logical-errorhandling-prec-exceptions",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO NOT throw a C++ exception.\n\nPost Conditions"
  },
  {
    "id": "cpp-design-logical-errorhandling-postc-check",
    "category": "Exceptions {#cpp-errors}",
    "text": "YOU SHOULD NOT check post-conditions in a way that changes the computational complexity of the function."
  },
  {
    "id": "cpp-design-logical-errorhandling-postc-disablecheck",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO provide a way to disable postcondition checks, and omit checking code from built binaries."
  },
  {
    "id": "cpp-design-logical-errorhandling-postc-crash",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO crash, if possible. This means calling some form of fast failing function, like abort."
  },
  {
    "id": "cpp-design-logical-errorhandling-postc-exceptions",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO NOT throw a C++ exception.\n\nHeap Exhaustion (Out of Memory)"
  },
  {
    "id": "cpp-design-logical-errorhandling-oom-crash",
    "category": "Exceptions {#cpp-errors}",
    "text": "YOU MAY crash. For example, this may mean dereferencing a nullptr returned by malloc, or explicitly checking and calling abort.\n\nNote that on some comonly deployed platforms like Linux, handling heap exhaustion from user mode is not possible in a default configuration."
  },
  {
    "id": "cpp-design-logical-errorhandling-oom-bad-alloc",
    "category": "Exceptions {#cpp-errors}",
    "text": "YOU MAY propagate a C++ exception of type std::bad_alloc when encountering an out of memory condition. We do not expect the program to continue in a recoverable state after this occurs. Note that most standard library facilities and the built in operator new do this automatically, and we want to allow use of other facilities that may throw here."
  },
  {
    "id": "cpp-design-logical-errorhandling-oom-throw",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO NOT throw bad_alloc from the SDK code itself.\n\nRecoverable errors"
  },
  {
    "id": "cpp-design-logical-errorhandling-recov-reporting",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO report errors by throwing C++ exceptions defined in the Azure C++ Core Library.\n\nTODO: The Core library needs to provide exceptions for the common failure modes, e.g. the same values as az_result in the C SDK.\n\nFor example:\n\n{% highlight cpp %}\nclass Herd {\nbool m_hasShyCats;\nint m_numCats;\npublic:\nvoid CountCats(int* cats) {\nif(m_hasShyCats) {\nthrow std::runtime_error(\"shy cats are not allowed\");\n}\n*cats = m_numCats;\n}\n};\n{% endhighlight %}"
  },
  {
    "id": "cpp-design-logical-errorhandling-recov-error",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO produce a recoverable error when any HTTP request fails with an HTTP status code that is not defined by the service/Swagger as a successful status code."
  },
  {
    "id": "cpp-design-logical-errorhandling-recov-document",
    "category": "Exceptions {#cpp-errors}",
    "text": "DO document all exceptions each function and its transitive dependencies may throw, except for std::bad_alloc."
  },
  {
    "id": "cpp-design-logical-errorhandling-exceptions-other",
    "category": "C++ Exceptions",
    "text": "DO NOT throw exceptions, except those from the Azure C++ Core library as described in the error handling section."
  },
  {
    "id": "cpp-design-logical-errorhandling-exceptions",
    "category": "C++ Exceptions",
    "text": "DO propagate exceptions thrown by user code, callbacks, or dependencies. Assume any user-provided callback will propagate C++ exceptions unless the SDK documents that the callback must be completely non-throwing.\n\n{% highlight cpp %}\ntemplate\nvoid ApiFunc(const Callback& c) {\n// best\nc();\n\n<code>// allowed, but results in a less pretty debugging experience for customers\ntry {\n    c();\n} catch (...) {\n    // clean up\n    throw; // throw; rethrows the original exception object\n}\n\n// prohibited\ntry {\n    c();\n} catch (...) {\n    // missing throw;\n}\n</code>\n\n}\n{% endhighlight %}\n\nAzure services use a variety of different authentication schemes to allow clients to access the service. Conceptually, there are two entities responsible in this process: a credential and an authentication policy.  Credentials provide confidential authentication data.  Authentication policies use the data provided by a credential to authenticate requests to the service."
  },
  {
    "id": "cpp-design-logical-client-support-all-auth-techniques",
    "category": "Authentication {#cpp-authentication}",
    "text": "DO support all authentication techniques that the service supports and are available to a client application (as opposed to service side).  C is used only for client applications when talking to Azure, so some authentication techniques may not be valid."
  },
  {
    "id": "cpp-design-logical-client-use-azure-core",
    "category": "Authentication {#cpp-authentication}",
    "text": "DO use credential and authentication policy implementations from the Azure Core library where available."
  },
  {
    "id": "cpp-design-logical-client-prefer-token-auth",
    "category": "Authentication {#cpp-authentication}",
    "text": "DO provide credential types that can be used to fetch all data needed to authenticate a request to the service in a non-blocking atomic manner for each authentication scheme that does not have an implementation in Azure Core."
  },
  {
    "id": "cpp-apisurface-auth-in-constructors",
    "category": "Authentication {#cpp-authentication}",
    "text": "DO provide service client constructors or factories that accept any supported authentication credentials."
  },
  {
    "id": "cpp-design-logical-client-surface-no-connection-strings",
    "category": "Authentication {#cpp-authentication}",
    "text": "YOU SHOULD NOT support providing credential data via a connection string. Connection string interfaces should be provided ONLY IF the service provides a connection string to users via the portal or other tooling."
  },
  {
    "id": "cpp-design-logical-client-surface-no-connection-string-ctors",
    "category": "Authentication {#cpp-authentication}",
    "text": "DO NOT support constructing a service client with a connection string unless such connection string. Provide a CreateFromConnectionString static member function which returns a client instead to encourage customers to choose non-connection-string-based authentication.\n\nWhen implementing authentication, don't open up the consumer to security holes like PII (personally identifiable information) leakage or credential leakage.  Credentials are generally issued with a time limit, and must be refreshed periodically to ensure that the service connection continues to function as expected.  Ensure your client library follows all current security recommendations and consider an independent security review of the client library to ensure you're not introducing potential security problems for the consumer."
  },
  {
    "id": "cpp-implementing-no-persistence-auth",
    "category": "Authentication {#cpp-authentication}",
    "text": "DO NOT\npersist, cache, or reuse security credentials.  Security credentials should be considered short lived to cover both security concerns and credential refresh situations.\n\nIf your service implements a non-standard credential system (one that is not supported by Azure Core), then you need to produce an authentication policy for the HTTP pipeline that can authenticate requests given the alternative credential types provided by the client library."
  },
  {
    "id": "cpp-implementing-secure-auth-erase",
    "category": "Authentication {#cpp-authentication}",
    "text": "DO Use a \"secure\" function to zero authentication or authorization credentials as soon as possible once they are no longer needed. Examples of such functions\ninclude: SecureZeroMemory, memset_s, and explicit_bzero. Examples of insecure functions include memset. An optimizer may notice that the credentials are\nnever accessed again, and optimize away the call to memset, resulting in the credentials remaining in memory."
  },
  {
    "id": "cpp-implementing-auth-policy",
    "category": "Authentication {#cpp-authentication}",
    "text": "DO\nprovide a suitable authentication policy that authenticates the HTTP request in the HTTP pipeline when using non-standard credentials.  This includes custom connection strings, if supported.\n\nGrouping services within a cloud infrastructure is common since it aids discoverability and provides structure to the reference documentation."
  },
  {
    "id": "cpp-design-naming-namespaces",
    "category": "Namespaces {#cpp-namespace-naming}",
    "text": "DO name namespaces using PascalCase."
  },
  {
    "id": "cpp-design-naming-namespaces-hierarchy",
    "category": "Namespaces {#cpp-namespace-naming}",
    "text": "DO use a root namespace of the form Azure::<Group>::<Service>[::<Feature>].\n\nFor example, Azure::Storage::Blobs or Azure::Storage::Files::Shares"
  },
  {
    "id": "cpp-namespaces-approved-list",
    "category": "Namespaces {#cpp-namespace-naming}",
    "text": "DO use one of the following pre-approved namespace groups:\nAzure::AI for artificial intelligence, including machine learning\nAzure::Analytics for client libraries that gather or process analytics data\nAzure::Communication communication services\nAzure::Core for libraries that aren't service specific\nAzure::Cosmos for object database technologies\nAzure::Data for client libraries that handle databases or structured data stores\nAzure::DigitalTwins for DigitalTwins related technologies\nAzure::Identity for authentication and authorization client libraries\nAzure::IoT for client libraries dealing with the Internet of Things.\n\nUse Iot for Pascal cased compound words, such as IotClient, otherwise follow language conventions.\nDo not use IoT more than once in a namespace.\n\n\nUse Iot for Pascal cased compound words, such as IotClient, otherwise follow language conventions.\nDo not use IoT more than once in a namespace.\nAzure::Management for client libraries accessing the control plane (Azure Resource Manager)\nAzure::Media for client libraries that deal with audio, video, or mixed reality\nAzure::Messaging for client libraries that provide messaging services, such as push notifications or pub-sub.\nAzure::Search for search technologies\nAzure::Security for client libraries dealing with security\nAzure::Storage for client libraries that handle unstructured data\nUse Iot for Pascal cased compound words, such as IotClient, otherwise follow language conventions.\nDo not use IoT more than once in a namespace.\n\nIf you think a new group should be added to the list, contact [adparch]."
  },
  {
    "id": "general-namespaces-shortened-name",
    "category": "Namespaces {#cpp-namespace-naming}",
    "text": "DO pick a shortened service name that allows the consumer to tie the package to the service being used.  As a default, use the compressed service name.  The namespace does NOT change when the branding of the product changes, so avoid the use of marketing names that may change.\n\nA compressed service name is the service name without spaces.  It may further be shortened if the shortened version is well known in the community.  For example, \"Azure Media Analytics\" would have a compressed service name of MediaAnalytics, whereas \"Azure Service Bus\" would become ServiceBus."
  },
  {
    "id": "general-namespaces-approved-list",
    "category": "Namespaces {#cpp-namespace-naming}",
    "text": "DO use the following list as the group of services:\n\n| Namespace Group  | Functional Area                                                           |\n|:-----------------|:--------------------------------------------------------------------------|\n| `AI`             | Artificial intelligence, including machine learning                       |\n| `Analytics`      | Gathering data for metrics or usage                                       |\n| `Data`           | Dealing with structured data stores like databases                        |\n| `Diagnostics`    | Gathering data for diagnosing issues                                      |\n| `DigitalTwins`   | Digital Twins, digital representations of physical spaces and IoT devices |\n| `Identity`       | Authentication and authorization                                          |\n| `IoT`            | Internet of Things                                                        |\n| `Management`     | Control Plane (Azure Resource Manager)                                    |\n| `Media`          | Audio, video, or mixed reality                                            |\n| `Messaging`      | Messaging services, like push notifications or pub-sub                    |\n| `Search`         | Search technologies                                                       |\n| `Security`       | Security and cryptography                                                 |\n| `Storage`        | Storage of unstructured data                                              |\n\n\nIf the client library does not seem to fit into the group list, contact the [Architecture Board] to discuss the namespace requirements."
  },
  {
    "id": "general-namespaces-mgmt",
    "category": "Namespaces {#cpp-namespace-naming}",
    "text": "DO place the management (Azure Resource Manager) API in the Management group.  Use the grouping Azure::Management::<Group>::<Service> for the namespace. Since more services require control plane APIs than data plane APIs, other namespaces may be used explicitly for control plane only.  Data plane usage is by exception only.  Additional namespaces that can be used for control plane SDKs include:\n\n| Namespace Group  | Functional Area                                          |\n|:-----------------|:---------------------------------------------------------|\n| `Appmodel`       | Application models, such as Functions or App Frameworks  |\n| `Compute`        | Virtual machines, containers, and other compute services |\n| `Integration`    | Integration services (such as Logic Apps)                |\n| `Management`     | Management services (such as Cost Analytics)             |\n| `Networking`     | Services such as VPN, WAN, and Networking                |\n\n\nMany management APIs do not have a data plane because they deal with management of the Azure account. Place the management library in the Azure::Management namespace.  For example, use Azure::Management::CostAnalysis instead of Azure::Management::Management::CostAnalysis."
  },
  {
    "id": "general-namespaces-similar-names",
    "category": "Namespaces {#cpp-namespace-naming}",
    "text": "DO NOT choose similar names for clients that do different things."
  },
  {
    "id": "general-namespaces-registration",
    "category": "Namespaces {#cpp-namespace-naming}",
    "text": "DO register the chosen namespace with the [Architecture Board].  Open an issue to request the namespace.  See the registered namespace list for a list of the currently registered namespaces."
  },
  {
    "id": "cpp-design-naming-namespaces-details",
    "category": "Namespaces {#cpp-namespace-naming}",
    "text": "DO place private implementation details in a _detail namespace.\n\n{% highlight cpp %}\nnamespace Azure { namespace Group { namespace Service {\nnamespace _detail {\n// Part of the private API\nstruct HashComputation {\nint InternalBookkeeping;\n};\n\nconst int g_privateConstant = 1729;\n} // namespace _detail\n\n// Part of the public API\nstruct UploadBlobRequest {\nunsigned char* Data;\nsize_t DataLength;\n};\n\n// Bad - private API in public namespace.\nstruct HashComputation {\nint InternalBookkeeping;\n};\nconst int g_privateConstant = 1729;\n}}} // namespace Azure::Group::Service\n{% endhighlight %}\n\nExample Namespaces\n\nHere are some examples of namespaces that meet these guidelines:\nAzure::Data::Cosmos\nAzure::Identity::ActiveDirectory\nAzure::IoT::DeviceProvisioning\nAzure::Storage::Blobs\nAzure::Messaging::NotificationHubs (the client library for Notification Hubs)\nAzure::Management::Messaging::NotificationHubs (the management library for Notification Hubs)\n\nHere are some namespaces that do not meet the guidelines:\nmicrosoft::azure::CosmosDB (not in the Azure namespace and does not use grouping, uses lowercase letters)\nazure::mixed_reality::kinect (the grouping is not in the approved list and uses snake_case)\nAzure::IoT::IoTHub::DeviceProvisioning (too many levels in the group)\n\nTODO: This section needs to be driven by code in the Core library."
  },
  {
    "id": "cpp-package-dynamic",
    "category": "Packaging {#cpp-packaging}",
    "text": "YOU SHOULD provide both dynamic and static linking options for your library.  Each has its own merits and use cases."
  },
  {
    "id": "cpp-package-source",
    "category": "Packaging {#cpp-packaging}",
    "text": "DO publish your package in source code format.  Due to differences in platforms, this is the most common publishing mechanism for C libraries."
  },
  {
    "id": "cpp-package-vcpkg",
    "category": "Packaging {#cpp-packaging}",
    "text": "DO publish your package to vcpkg (https://github.com/Microsoft/vcpkg)  a C++ library manager supporting Windows, Linux, and MacOS.\n\nTODO: This section needs to be driven by code in the Core library."
  },
  {
    "id": "cpp-versioning-backwards-compatibility",
    "category": "Client Versions",
    "text": "DO be 100% backwards compatible with older versions of the same package."
  },
  {
    "id": "cpp-versioning-new-package",
    "category": "Client Versions",
    "text": "DO introduce a new package (with new assembly names, new namespace names, and new type names) if you must do an API breaking change.\n\nBreaking changes should happen rarely, if ever.  Register your intent to do a breaking change with [adparch]. You'll need to have a discussion with the language architect before approval.\n\nConsistent version number scheme allows consumers to determine what to expect from a new version of the library."
  },
  {
    "id": "cpp-version-semver",
    "category": "Package Version Numbers {#cpp-versionnumbers}",
    "text": "DO use MAJOR.MINOR.PATCH format for the version of the library dll and the NuGet package.\n\nUse _-beta.N suffix for beta package versions. For example, 1.0.0-beta.2."
  },
  {
    "id": "cpp-version-change-on-release",
    "category": "Package Version Numbers {#cpp-versionnumbers}",
    "text": "DO change the version number of the client library when ANYTHING changes in the client library."
  },
  {
    "id": "cpp-version-patching",
    "category": "Package Version Numbers {#cpp-versionnumbers}",
    "text": "DO increment the patch version when fixing a bug."
  },
  {
    "id": "cpp-version-features-in-patch",
    "category": "Package Version Numbers {#cpp-versionnumbers}",
    "text": "DO NOT include new APIs in a patch release."
  },
  {
    "id": "cpp-version-add-feature",
    "category": "Package Version Numbers {#cpp-versionnumbers}",
    "text": "DO increment the major or minor version when adding support for a service API version."
  },
  {
    "id": "cpp-version-add-api",
    "category": "Package Version Numbers {#cpp-versionnumbers}",
    "text": "DO increment the major or minor version when adding a new method to the public API."
  },
  {
    "id": "cpp-version-major-changes",
    "category": "Package Version Numbers {#cpp-versionnumbers}",
    "text": "YOU SHOULD increment the major version when making large feature changes."
  },
  {
    "id": "cpp-version-change-on-release",
    "category": "Package Version Numbers {#cpp-versionnumbers}",
    "text": "DO select a version number greater than the highest version number of any other released Track 1 package for the service in any other scope or language.\n\nDependencies bring in many considerations that are often easily avoided by avoiding the\ndependency.\nVersioning - Many programming languages do not allow a consumer to load multiple versions of the same package. So, if we have an client library that requires v3 of package Foo and the consumer wants to use v5 of package Foo, then the consumer cannot build their application. This means that client libraries should not have dependencies by default.\nSize - Consumer applications must be able to deploy as fast as possible into the cloud and move in various ways across networks. Removing additional code (like dependencies) improves deployment performance.\nLicensing - You must be conscious of the licensing restrictions of a dependency and often provide proper attribution and notices when using them.\nCompatibility - Often times you do not control a dependency and it may choose to evolve in a direction that is incompatible with your original use.\nSecurity - If a security vulnerability is discovered in a dependency, it may be difficult or time consuming to get the vulnerability corrected if Microsoft does not control the dependencies code base."
  },
  {
    "id": "cpp-dependencies-stdlibcpp",
    "category": "Dependencies {#cpp-dependencies}",
    "text": "DO use the C++ standard library (https://en.cppreference.com/w/) "
  },
  {
    "id": "cpp-dependencies-azure-core",
    "category": "Dependencies {#cpp-dependencies}",
    "text": "DO depend on the Azure Core library for functionality that is common across all client libraries.  This library includes APIs for HTTP connectivity, global configuration, and credential handling."
  },
  {
    "id": "cpp-dependencies-approved-only",
    "category": "Dependencies {#cpp-dependencies}",
    "text": "DO NOT be dependent on any other packages within the client library distribution package. Dependencies are by-exception and need a thorough vetting through architecture review.  This does not apply to build dependencies, which are acceptable and commonly used."
  },
  {
    "id": "cpp-dependencies-vendoring",
    "category": "Dependencies {#cpp-dependencies}",
    "text": "YOU SHOULD consider copying or linking required code into the client library in order to avoid taking a dependency on another package that could conflict with the ecosystem. Make sure that you are not violating any licensing agreements and consider the maintenance that will be required of the duplicated code. [\"A little copying is better than a little dependency\"][1] (YouTube)."
  },
  {
    "id": "cpp-dependencies-concrete",
    "category": "Dependencies {#cpp-dependencies}",
    "text": "DO NOT depend on concrete logging, dependency injection, or configuration technologies (except as implemented in the Azure Core library).  The client library will be used in applications that might be using the logging, DI, and configuration technologies of their choice."
  },
  {
    "id": "cpp-docs-document-everything",
    "category": "Documentation Comments {#cpp-documentation}",
    "text": "DO document every exposed (public or protected) type and member within your library's code."
  },
  {
    "id": "cpp-docs-docstrings",
    "category": "Documentation Comments {#cpp-documentation}",
    "text": "DO use doxygen (http://www.doxygen.nl/index.html) comments for reference documentation.\n\nSee the [documentation guidelines]({{ site.baseurl }}/general_documentation.html) for language-independent guidelines for how to provide good documentation."
  },
  {
    "id": "cpp-general-repository",
    "category": "Repository Guidelines {#cpp-repository}",
    "text": "DO locate all source code and README in the [azure/azure-sdk-for-cpp] GitHub repository."
  },
  {
    "id": "cpp-general-engsys",
    "category": "Repository Guidelines {#cpp-repository}",
    "text": "DO follow Azure SDK engineering systems guidelines for working in the [azure/azure-sdk-for-cpp] GitHub repository.\n\nTODO: Content in this section below here should be moved to a better location."
  },
  {
    "id": "cpp-style-clang-format",
    "category": "Repository Guidelines {#cpp-repository}",
    "text": "DO format your source code with clang-format, using the configuration file located in the azure-sdk-for-cpp repo (https://github.com/Azure/azure-sdk-for-cpp/blob/main/.clang-format) "
  },
  {
    "id": "cpp-style-filenaming",
    "category": "Repository Guidelines {#cpp-repository}",
    "text": "DO name all files as lowercase, in a directory of the service short name. Separate words with underscores, and end with the appropriate extension (.cpp or .hpp). For example, iot_credential.cpp is valid, while IoTCredential.cl is not."
  },
  {
    "id": "cpp-style-privateapi-hdr",
    "category": "Repository Guidelines {#cpp-repository}",
    "text": "DO place an include file that is not part of the public API in an internal directory.  Do not include the service short name.  For example, <azure/internal/credential.hpp>."
  },
  {
    "id": "cpp-style-filenames",
    "category": "Repository Guidelines {#cpp-repository}",
    "text": "DO use characters in the range [a-z0-9_] for the name portion (before the file extension).  No other characters are permitted.\n\nFilenames should be concise, but convey what role the file plays within the library."
  },
  {
    "id": "cpp-style-headerguards",
    "category": "Repository Guidelines {#cpp-repository}",
    "text": "DO use #pragma once\n\n{% highlight cpp %}\n#pragma once\n\n// Contents of a given header\n{% endhighlight %}"
  },
  {
    "id": "cpp-style-whole-sdk-header",
    "category": "Repository Guidelines {#cpp-repository}",
    "text": "YOU MAY have a header file that includes an entire client library. For example, <azure/speech.hpp>."
  },
  {
    "id": "cpp-style-sub-sdk-header",
    "category": "Repository Guidelines {#cpp-repository}",
    "text": "YOU SHOULD have headers for smaller components that make sense to be used together. For example, <azure/speech/translation.hpp>."
  },
  {
    "id": "cpp-style-change-headers",
    "category": "Repository Guidelines {#cpp-repository}",
    "text": "DO NOT substantially change the names exposed by the header in response to macros or other controls. For example, NOMINMAX or WIN32_LEAN_AND_MEAN from <Windows.h>.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (docstrings), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information. ([example][README-EXAMPLE])\nAPI reference - Generated from the docstrings in your code; published on docs.microsoft.com.\nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, docstrings, and Quickstart.\nQuickstart - Article on docs.microsoft.com that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "cpp-docs-contentdev",
    "category": "Documentation Style",
    "text": "DO include your service's content developer in the Architecture Board review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "cpp-docs-contributors-guide",
    "category": "Documentation Style",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "cpp-docs-style-guide",
    "category": "Documentation Style",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the docstrings in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide].\n[Microsoft Cloud Style Guide]."
  },
  {
    "id": "cpp-docs-to-silence",
    "category": "Documentation Style",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the docstrings. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, doc it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service.\n\nDocstrings"
  },
  {
    "id": "cpp-docs-doxygen",
    "category": "Documentation Style",
    "text": "DO include docstrings compatible with the doxygen (http://www.doxygen.nl/index.html) tool for generating reference documentation.\n\nFor example, a (very) simple docstring might look like:\n{% highlight cpp %}\n/**\n@class client\n@brief The client represents the resources required for a connection to an Azure AppcConfiguration resource.\n*/\n{% endhighlight %}"
  },
  {
    "id": "cpp-docs-doxygen-cmd",
    "category": "Documentation Style",
    "text": "DO use doxygen's @cmd style docstrings"
  },
  {
    "id": "cpp-docs-doxygen-params",
    "category": "Documentation Style",
    "text": "DO format parameter documentation like the following:\n\n{% highlight cpp %}\n/* <....documentation....>\n@param[] <param_name> description\n<....documentation....>\n*/\n{% endhighlight %}\n\nFor example:\n{% highlight cpp %}\nnamespace azure::storage::blob {\n/**\n@brief execute a blocking get request\n\n@param[in] client\n@param[in] path_and_query The query to execute relative to the base url of the client\n@param[out] result\n@param[out] result_sz size of the result\n/\nvoid req_get(client client, const char* path_and_query, unsigned char** result, size_t* result_sz);\n} // namespace azure::storage::blob\n{% endhighlight %}"
  },
  {
    "id": "cpp-docs-doxygen-nullable",
    "category": "Documentation Style",
    "text": "DO document what happens to parameters that are set to null.\n\nFor example:\n\n{% highlight cpp %}\nnamespace azure::animals::cats {\n/**\n@brief get properties of a cat (e.g. hair color, weight, floof)\n\n@param[in] our_cat the cat to operate on\n@param[out] props pointer to an array of num_props, or null\n@param[in,out] num_props pointer to the number of properties to retrieve or to a location to store the number of\n\n                     properties queried as described below\n\n\n\nIf @p props is NULL then return the number of properties available in @p num_props,\notherwise return @p num_props into the array at @p props\n/\nvoid get_cat_properties(cat our_cat, cat_properties* props, size_t* num_props);\n} // namespace azure::animals::cats\n{% endhighlight %}\n\n<code>                     properties queried as described below\n</code>"
  },
  {
    "id": "cpp-docs-doxygen-failure",
    "category": "Documentation Style",
    "text": "DO document which exceptions your function can propagate.\n\nCode snippets"
  },
  {
    "id": "cpp-docs-include-snippets",
    "category": "Documentation Style",
    "text": "DO include example code snippets alongside your library's code within the repository. The snippets should clearly and succinctly demonstrate the operations most developers need to perform with your library. Include snippets for every common operation, and especially for those that are complex or might otherwise be difficult for new users of your library. At a bare minimum, include snippets for the champion scenarios you've identified for the library."
  },
  {
    "id": "cpp-docs-build-snippets",
    "category": "Documentation Style",
    "text": "DO build and test your example code snippets using the repository's continuous integration (CI) to ensure they remain functional."
  },
  {
    "id": "cpp-docs-snippets-in-docstrings",
    "category": "Documentation Style",
    "text": "DO include the example code snippets in your library's docstrings so they appear in its API reference. If the language and its tools support it, ingest these snippets directly into the API reference from within the docstrings.\n\nFor example, consider a function called do_something_or_other:\n{% highlight cpp %}\nnamespace azure::sdks::example {\n/**\n\n@brief some class type\n*/\nstruct some_class {\nint member;\n/**\n\n@brief do something, or maybe do some other thing\n/\nvoid do_something_or_other();\n};\n} // azure::sdks::example\n{% endhighlight %}\nIt can be used as follows:\n{% highlight cpp %}\n/*\n\n\n@brief do something, or maybe do some other thing\n/\nvoid do_something_or_other();\n};\n} // azure::sdks::example\n{% endhighlight %}\nIt can be used as follows:\n{% highlight cpp %}\n/*\n\n@example example_1.cpp\n*/\nint main() {\nusing azure::sdks::example::some_class;\nsome_class a;\na.do_something_or_other();\nreturn 1;\n}\n{% endhighlight %}\nWhen doxygen processes these files, it will see the @example command in example_1.cpp and\nadd it to the \"examples\" section of the documentation, it will also see the usage of\nsome_struct in the example and add a link from the documentation of some_struct to the\ndocumentation (including source code) for example_1.cpp.\n\n\n@brief some class type\n*/\nstruct some_class {\nint member;\n\n/**\n@brief do something, or maybe do some other thing\n/\nvoid do_something_or_other();\n};\n} // azure::sdks::example\n{% endhighlight %}\nIt can be used as follows:\n{% highlight cpp %}\n/*\n\n@example example_1.cpp\n*/\nint main() {\nusing azure::sdks::example::some_class;\nsome_class a;\na.do_something_or_other();\nreturn 1;\n}\n{% endhighlight %}\nWhen doxygen processes these files, it will see the @example command in example_1.cpp and\nadd it to the \"examples\" section of the documentation, it will also see the usage of\nsome_struct in the example and add a link from the documentation of some_struct to the\ndocumentation (including source code) for example_1.cpp.\n\nUse @include or @snippet to include examples directly in the documentation for a function or structure.\nFor example:\n\n{% highlight cpp %}\n//\n// @brief some structure type\n//\nstruct some_struct {\nint member;\n};\n\n//\n// @brief do something, or maybe do some other thing\n// see @snippet example_1.cpp use some_struct\n//\nvoid do_something_or_other(some_struct* s);\n{% endhighlight %}\nIt can be used as follows:\n{% highlight cpp %}\n/**\n@example example_1.cpp\n/\nint main() {\n/* [use some_struct] /\nsome_struct a;\ndo_something_or_other(&a);\n/* [use some_struct] */\nreturn 1;\n}\n{% endhighlight %}\n\nNote that automatic links from documentation to examples will only be generated in struct documentation,\nnot in function documentation. To generate a link from a function's documentation to an example use @dontinclude. For example:\n\n{% highlight cpp %}\n/**\n@brief do something, or maybe do some other thing\n@dontinclude example_1.cpp\n*/\nvoid do_something_or_other(const some_struct& s);\n{% endhighlight %}"
  },
  {
    "id": "cpp-docs-operation-combinations",
    "category": "Documentation Style",
    "text": "DO NOT combine more than one operation in a code snippet unless it's required for demonstrating the type or member, or it's in addition to existing snippets that demonstrate atomic operations. For example, a Cosmos DB code snippet should not include both account and container creation operations--create two different snippets, one for account creation, and one for container creation.\n\nCombined operations cause unnecessary friction for a library consumer by requiring knowledge of additional operations which might be outside their current focus. It requires them to first understand the tangential code surrounding the operation they're working on, then carefully extract just the code they need for their task. The developer can no longer simply copy and paste the code snippet into their project.\n\nBuildsystem integration"
  },
  {
    "id": "cpp-docs-buildsystem",
    "category": "Documentation Style",
    "text": "DO Provide a buildsystem target called \"docs\" to build\nthe documentation"
  },
  {
    "id": "cpp-docs-buildsystem-option",
    "category": "Documentation Style",
    "text": "DO Provide an option BUILD_DOCS to control\nbuilding of the docs, this should default to OFF\n\nTo provide this you can use the CMake FindDoxygen module as follows:\n\n{% highlight cmake %}\noption(BUILD_DOCS \"Build documentation\" OFF)\nif(BUILD_DOCS)\nfind_package(Doxygen REQUIRED doxygen)\n\n<code># note: DOXYGEN_ options are strings to cmake, not\n# booleans, thus use only YES and NO\nset(DOXYGEN_GENERATE_XML YES)\nset(DOXYGEN_GENERATE_HTML YES)\n\nset(DOXYGEN_EXTRACT_PACKAGE YES)\nset(DOXYGEN_INLINE_SIMPLE_STRUCTS YES)\nset(DOXYGEN_TYPEDEF_HIDES_STRUCT YES)\ndoxygen_add_docs(docs\n    ${PROJECT_SOURCE_DIR}/inc\n    ${PROJECT_SOURCE_DIR}/doc\n    ${PROJECT_SOURCE_DIR}/src\n    COMMENT \"Generate Documentation\")\n</code>\n\nendif()\n{% endhighlight %}\n\nFormatting"
  },
  {
    "id": "cpp-format-cpp",
    "category": "Documentation Style",
    "text": "DO use cpp-format (https://clang.llvm.org/docs/ClangFormat.html) for formatting your code. Use the .clang-format (https://github.com/Azure/azure-sdk-for-cpp/blob/main/.clang-format) options.\n\nIn general, cpp-format will format your code correctly and ensure consistency. However, these are few additional  rules to keep in mind."
  },
  {
    "id": "cpp-format-cpp-loops",
    "category": "Documentation Style",
    "text": "DO place all conditional or loop statements on one line, or add braces to identify the conditional/looping block.\n\n{%highlight c %}\nif (meow == 0) purr += 1; // OK\nif (meow == 0) {\npurr += 1; // OK\n}\nif (meow == 0) { purr += 1; } // OK (although will probably be changed by cpp-format)\nif (meow == 0)\npurr += 1; // NOT OK\n{% endhighlight %}"
  },
  {
    "id": "cpp-format-cpp-closing-braces",
    "category": "Documentation Style",
    "text": "DO add comments to closing braces.  Adding a comment to closing braces can help when you are reading code because you don't have to find the begin brace to know what is going on.\n\n{% highlight cpp %}\nwhile (1) {\nif (valid) {\n...\n} /* if valid */\nelse {\n\n<code>} /* not valid */\n</code>\n\n} /* end forever */\n{% endhighlight %}"
  },
  {
    "id": "cpp-format-cpp-closing-endif",
    "category": "Documentation Style",
    "text": "DO add comments to closing preprocessor directives to make them easier to understand.  For example:\n\n{% highlight cpp %}\n#if BEGIN_CODE\n\n#ifndef INTERNAL_CODE\n\n#endif /* INTERNAL_CODE */\n\n#endif /* BEGIN_CODE */\n{% endhighlight %}"
  },
  {
    "id": "cpp-format-cpp-space-return",
    "category": "Documentation Style",
    "text": "YOU SHOULD NOT use parens in return statements when it isn't necessary."
  },
  {
    "id": "cpp-format-cpp-no-yoda",
    "category": "Documentation Style",
    "text": "DO place constants on the right of comparisons. For example if (a == 0) and not if (0 == a)"
  },
  {
    "id": "cpp-format-cpp-comment-fallthru",
    "category": "Documentation Style",
    "text": "DO include a comment for falling through a non-empty case statement.  For example:\n\n{% highlight cpp %}\nswitch (...) {\ncase 1:\nDoSomething();\nbreak;\ncase 2:\nDoSomethingElse();\n/* fall through */\ncase 3:\n{\nint v;\n\n<code>        DoSomethingMore(v);\n    }\n    break;\ndefault:\n    Log(LOG_DEBUG, \"default case reached\");\n</code>\n\n}\n{% endhighlight %}"
  },
  {
    "id": "cpp-format-cpp-no-goto",
    "category": "Documentation Style",
    "text": "YOU SHOULD NOT use goto statements.  The main place where goto statements can be usefully employed is to break out of several levels of switch, for, or while nesting, although the need to do such a thing may indicate that the inner constructs should be broken out into a separate function with a success/failure return code.  When a goto is necessary, the accompanying label should be alone on a line and to the left of the code that follows.  The goto should be commented as to its utility and purpose."
  },
  {
    "id": "cpp-docs-readme",
    "category": "README {#cpp-repository-readme}",
    "text": "DO have a README.md file in the component root folder.\n\nAn example of a good README.md file can be found here (https://github.com/Azure/azure-sdk-for-cpp/blob/main/sdk/core/azure-core/README.md) "
  },
  {
    "id": "cpp-docs-readme-consumer",
    "category": "README {#cpp-repository-readme}",
    "text": "DO optimize the README.md for the consumer of the client library.\n\nThe contributor guide (CONTRIBUTING.md) should be a separate file linked to from the main component README.md.\n\nTODO: Provide sample guidelines.\n\nTODO: Provide C++ specific API design guidelines.  Example:"
  },
  {
    "id": "cpp-format-cpp-no-goto",
    "category": "Commonly Overlooked C++ API Design Guidelines {#cpp-appendix-overlookedguidelines}",
    "text": "YOU SHOULD NOT use goto statements.  The main place where goto statements can be usefully employed is to break out of several levels of switch, for, or while nesting, although the need to do such a thing may indicate that the inner constructs should be broken out into a separate function with a success/failure return code.  When a goto is necessary, the accompanying label should be alone on a line and to the left of the code that follows.  The goto should be commented as to its utility and purpose.\n\n[OpenTelemetry]: https://opentelemetry.io\n[Azure Monitor]: https://azure.microsoft.com/services/monitor/\n[Google Test]: https://github.com/google/googletest/releases/tag/release-1.10.0\n[1]: https://www.youtube.com/watch?v=PAAkCSZUG1c&t=9m28s\n"
  }
]