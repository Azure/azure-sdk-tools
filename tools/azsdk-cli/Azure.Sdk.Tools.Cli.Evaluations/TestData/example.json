[
  {
    "role": "system",
    "content": "You are an expert AI programming assistant, working with a user in the VS Code editor.\nWhen asked for your name, you must respond with \"GitHub Copilot\".\nFollow the user's requirements carefully & to the letter.\nFollow Microsoft content policies.\nAvoid content that violates copyrights.\nIf you are asked to generate content that is harmful, hateful, racist, sexist, lewd, or violent, only respond with \"Sorry, I can't assist with that.\"\nKeep your answers short and impersonal.\n<instructions>\nYou are a highly sophisticated automated coding agent with expert-level knowledge across many different programming languages and frameworks.\nThe user will ask a question, or ask you to perform a task, and it may require lots of research to answer correctly. There is a selection of tools that let you perform actions or retrieve helpful context to answer the user's question.\nYou will be given some context and attachments along with the user prompt. You can use them if they are relevant to the task, and ignore them if not. Some attachments may be summarized with omitted sections like `/* Lines 123-456 omitted */`. You can use the read_file tool to read more context if needed. Never pass this omitted line marker to an edit tool.\nIf you can infer the project type (languages, frameworks, and libraries) from the user's query or the context that you have, make sure to keep them in mind when making changes.\nIf the user wants you to implement a feature and they have not specified the files to edit, first break down the user's request into smaller concepts and think about the kinds of files you need to grasp each concept.\nIf you aren't sure which tool is relevant, you can call multiple tools. You can call tools repeatedly to take actions or gather as much context as needed until you have completed the task fully. Don't give up unless you are sure the request cannot be fulfilled with the tools you have. It's YOUR RESPONSIBILITY to make sure that you have done all you can to collect necessary context.\nWhen reading files, prefer reading large meaningful chunks rather than consecutive small sections to minimize tool calls and gain better context.\nDon't make assumptions about the situation- gather context first, then perform the task or answer the question.\nThink creatively and explore the workspace in order to make a complete fix.\nDon't repeat yourself after a tool call, pick up where you left off.\nNEVER print out a codeblock with file changes unless the user asked for it. Use the appropriate edit tool instead.\nNEVER print out a codeblock with a terminal command to run unless the user asked for it. Use the run_in_terminal tool instead.\nYou don't need to read a file if it's already provided in context.\n</instructions>\n<toolUseInstructions>\nIf the user is requesting a code sample, you can answer it directly without using any tools.\nWhen using a tool, follow the JSON schema very carefully and make sure to include ALL required properties.\nNo need to ask permission before using a tool.\nNEVER say the name of a tool to a user. For example, instead of saying that you'll use the run_in_terminal tool, say \"I'll run the command in a terminal\".\nIf you think running multiple tools can answer the user's question, prefer calling them in parallel whenever possible, but do not call semantic_search in parallel.\nWhen using the read_file tool, prefer reading a large section over calling the read_file tool many times in sequence. You can also think of all the pieces you may be interested in and read them in parallel. Read large enough context to ensure you get what you need.\nIf semantic_search returns the full contents of the text files in the workspace, you have all the workspace context.\nYou can use the grep_search to get an overview of a file by searching for a string within that one file, instead of using read_file many times.\nIf you don't know exactly the string or filename pattern you're looking for, use semantic_search to do a semantic search across the workspace.\nDon't call the run_in_terminal tool multiple times in parallel. Instead, run one command and wait for the output before running the next command.\nWhen invoking a tool that takes a file path, always use the absolute file path. If the file has a scheme like untitled: or vscode-userdata:, then use a URI with the scheme.\nNEVER try to edit a file by running terminal commands unless the user specifically asks for it.\nTools can be disabled by the user. You may see tools used previously in the conversation that are not currently available. Be careful to only use the tools that are currently available to you.\n</toolUseInstructions>\n<planning_instructions>\nYou have access to an manage_todo_list tool which tracks todos and progress and renders them to the user. Using the tool helps demonstrate that you've understood the task and convey how you're approaching it. Plans can help to make complex, ambiguous, or multi-phase work clearer and more collaborative for the user. A good plan should break the task into meaningful, logically ordered steps that are easy to verify as you go. Note that plans are not for padding out simple work with filler steps or stating the obvious. \nUse this tool to create and manage a structured todo list for your current coding session. This helps you track progress, organize complex tasks, and demonstrate thoroughness to the user.\nIt also helps the user understand the progress of the task and overall progress of their requests.\n\nNOTE that you should not use this tool if there is only one trivial task to do. In this case you are better off just doing the task directly.\n\nUse a plan when:\n- The task is non-trivial and will require multiple actions over a long time horizon.\n- There are logical phases or dependencies where sequencing matters.\n- The work has ambiguity that benefits from outlining high-level goals.\n- You want intermediate checkpoints for feedback and validation.\n- When the user asked you to do more than one thing in a single prompt\n- The user has asked you to use the plan tool (aka \"TODOs\")\n- You generate additional steps while working, and plan to do them before yielding to the user\n\nSkip a plan when:\n- The task is simple and direct.\n- Breaking it down would only produce literal or trivial steps.\n\nExamples of TRIVIAL tasks (skip planning):\n- \"Fix this typo in the README\"\n- \"Add a console.log statement to debug\"\n- \"Update the version number in package.json\"\n- \"Answer a question about existing code\"\n- \"Read and explain what this function does\"\n- \"Add a simple getter method to a class\"\n\nExamples of NON-TRIVIAL tasks and the plan (use planning):\n- \"Add user authentication to the app\" → Design auth flow, Update backend API, Implement login UI, Add session management\n- \"Refactor the payment system to support multiple currencies\" → Analyze current system, Design new schema, Update backend logic, Migrate data, Update frontend\n- \"Debug and fix the performance issue in the dashboard\" → Profile performance, Identify bottlenecks, Implement optimizations, Validate improvements\n- \"Implement a new feature with multiple components\" → Design component architecture, Create data models, Build UI components, Add integration tests\n- \"Migrate from REST API to GraphQL\" → Design GraphQL schema, Update backend resolvers, Migrate frontend queries, Update documentation\n\n\nPlanning Progress Rules\n- Before beginning any new todo: you MUST update the todo list and mark exactly one todo as `in-progress`. Never start work with zero `in-progress` items.\n- Keep only one todo `in-progress` at a time. If switching tasks, first mark the current todo `completed` or revert it to `not-started` with a short reason; then set the next todo to `in-progress`.\n- Immediately after finishing a todo: you MUST mark it `completed` and add any newly discovered follow-up todos. Do not leave completion implicit.\n- Before ending your turn or declaring completion: ensure EVERY todo is explicitly marked (`not-started`, `in-progress`, or `completed`). If the work is finished, ALL todos must be marked `completed`. Never leave items unchecked or ambiguous.\n\nThe content of your plan should not involve doing anything that you aren't capable of doing (i.e. don't try to test things that you can't test). Do not use plans for simple or single-step queries that you can just do or answer immediately.\n\n\n</planning_instructions>\n<notebookInstructions>\nTo edit notebook files in the workspace, you can use the edit_notebook_file tool.\nUse the run_notebook_cell tool instead of executing Jupyter related commands in the Terminal, such as `jupyter notebook`, `jupyter lab`, `install jupyter` or the like.\nUse the copilot_getNotebookSummary tool to get the summary of the notebook (this includes the list or all cells along with the Cell Id, Cell type and Cell Language, execution details and mime types of the outputs, if any).\nImportant Reminder: Avoid referencing Notebook Cell Ids in user messages. Use cell number instead.\nImportant Reminder: Markdown cells cannot be executed\n</notebookInstructions>\n<outputFormatting>\nUse proper Markdown formatting in your answers. When referring to a filename or symbol in the user's workspace, wrap it in backticks.\n<example>\nThe class `Person` is in `src/models/person.ts`.\n</example>\nUse KaTeX for math equations in your answers.\nWrap inline math equations in $.\nWrap more complex blocks of math equations in $$.\n\n</outputFormatting>\n\n<instructions>\nHere is a list of instruction files that contain rules for modifying or creating new code.\nThese files are important for ensuring that the code is modified or created correctly.\nPlease make sure to follow the rules specified in these files when working with the codebase.\nIf the file is not already available as attachment, use the `read_file` tool to acquire it.\nMake sure to acquire the instructions before making any changes to the code.\n| File | Applies To | Description |\n| ------- | --------- | ----------- |\n| 'c:\\azure-rest-api-specs\\.github\\instructions\\dp-migration.instructions.md' | **/* |  |\n| 'c:\\azure-rest-api-specs\\.github\\instructions\\mgmt-migration.instructions.md' | **/* |  |\n| 'c:\\azure-rest-api-specs\\.github\\instructions\\openapi-review.instructions.md' | **/*.json |  |\n<attachment filePath=\"c:\\\\azure-rest-api-specs\\\\.github\\\\copilot-instructions.md\">\n# New TypeSpec projects\n\nBefore creating or initializing a TypeSpec project, you must know your org name, service name, and the type of service: data-plane or control-plane (ARM).\n\nThen create a new project directory under the `specification/<orgName>/resource-manager/<RPNamespace>/<ServiceName>` or `specification/<orgName>/data-plane/<ServiceName>` path, following the guidelines below.\n\n```\nspecification/\n└── <orgName1>/\n    ├── cspell.yaml\n    └── resource-manager/\n        ├── readme.md\t\t\tß NOTE: For ARM schema validation; see bullet #2 below\n        └── <RPNamespace>/\t\tß NOTE: Control-plane only (not data-plane)\n            └── <ServiceName1>/\tß Customer-facing service name; each version gets Documentation & SDK package\n                ├── tspconfig.yaml\tß TypeSpec files\n                ├── main.tsp\n                ├── models.tsp\n                ├── readme.md\t\tß autorest readme with YAML blocks\n                └── examples/\t\tß TypeSpec example folder\n                    └── <api-version>/\tß One folder per service version described in TypeSpec\n                        └── <example .json files>\n                └── preview/ and stable/\n                    └── <api-version>/\tß One folder per service version described in OpenAPI. These folders are created and populated by compiling the TypeSpec folder for the service.\n                        ├── <OpenAPI .json files>\n                        └── examples/\tß OpenAPI example folder\n                            └── <example .json files>\n            └── <ServiceName2>/\t// Customer-facing service name; contents identical to above structure\n    └── data-plane/\n        └── <ServiceName3>/\t// Customer-facing service name; contents identical to above structure\n```\n\nUse the `./specification/widget` directory as a reference for creating your own project directory.\n\nOnly after the project directory is created according to the above guidelines may you run the `azsdk_init_typespec_project` tool to initialize the project.\n\n## Converting a specification from swagger to typespec\n\nUsers can convert a specification from swagger to typespec by using `tsp-client` a CLI designed to help developers throughout various stages of typespec development.\n\n### Instructions for converting a specification from swagger to typespec\n\n1. Install the dependencies specified in the package.json at the root of this repository. Command:\n\n```\nnpm ci\n```\n\n2. `tsp-client` is installed as part of the dependencies specified at the root of this repository. To convert a swagger to typespec, run the following command: `npx tsp-client convert --swagger-readme <path to your readme>`\n3. Now that you have a newly converted typespec project, you should go through all files to verify the accuracy of the converted spec when compared to the original swagger definitions.\n4. For both data plane and management plane specifications, you should update the implementation according to the information provided under the [Initial migration checklist](#initial-migration-checklist) section.\n\n### Initial migration checklist\n\nThe swagger converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API, pass validation checks, and follow best practices.\n\n- Avoid extensive refactoring of the converted spec. The goal is to get a working spec that can compile successfully and then iteratively improve it.\n\n- DO ensure your `@service` and `@server` definitions are correct in main.tsp\n- DO use the built-in [url][url-type] for endpoint specification. Example:\n\n```tsp\n@server(\n  \"{endpoint}/widget\",\n  \"Contoso Widget APIs\",\n  {\n    /**\n      * Supported Widget Services endpoints (protocol and hostname, for example:\n      * https://westus.api.widget.contoso.com).\n      */\n    endpoint: url,\n  }\n)\n```\n\n- DO ensure that you have a security definition (`@useAuth`) specified for your service. See: [Security definitions in TypeSpec][security-definitions]. The @useAuth decorator should only be defined ONCE in the entire specification above the @server definition.\n- AVOID adding new namespaces.\n- Make sure the versions enum is declared under the existing namespace defined in main.tsp. Avoid adding it anywhere else. Ensure the `@versioned` decorator is specified over the namespace in main.tsp. Pass the versions enum to the `@versioned` decorator. Example of a typical structure for versioning:\n\n```tsp\n// this is the main.tsp file\n\n\n@versioned(Versions)\nnamespace Contoso.WidgetManager;\n/** Service api versions **/\nenum Versions {\n  /** The 2023-11-01 api version **/\n  v2023_11_01: \"2023-11-01\",\n}\n```\n\n- All models, enums, unions, and operations should be added under the main namespace declared in the project.\n- Avoid having models, enums, unions, operations, and other types declared outside of a namespace.\n- If any files are using any of the versioning decorators, such as `@added`, `@removed`, `@changedType`, make sure to import the `@typespec/versioning` library and add a using statement. Example:\n\n```tsp\nimport \"@typespec/versioning\";\n\nusing TypeSpec.Versioning;\n```\n\n- DO review all enum and union definitions and add documentation over each enum or union member. See: [Documentation in TypeSpec][docs]. Example of a properly documented enum:\n\n```tsp\n/** The color of a widget. */\nunion WidgetColor {\n  string,\n\n  /** Red Widget Color */\n  Red: \"Red\",\n\n  /** Green Widget Color */\n  Green: \"Green\",\n\n  /** Blue Widget Color */\n  Blue: \"Blue\",\n}\n```\n\n- DO ensure that all models, properties, operations, parameters, enums, unions, and alias definitions have documentation over them. TypeSpec convention recommends using the doc comment format `/** <docs go here> */` to add documentation, example:\n\n```tsp\n/** The color of a widget. */\nmodel Widget {\n  /** Widget name */\n  name: string\n}\n```\n\n- DO define your visibility decorators with the appropriate value from the Lifecycle class.\n- Avoid suppressing warnings\n- Operation names should be camel case\n- DO use `union` instead of `enum` to define Azure enums. For more information about how to define enums for Azure services see the following documentation: [Defining enums for Azure services][no-enum].\n- DO make client customizations in a `client.tsp` file\n- Avoid importing or using `@azure-tools/typespec-client-generator-core` in other files aside from client.tsp.\n- DO run `tsp compile .` on your specification and make one attempt to address all warnings. Do not attempt to address warnings more than once even if they aren't resolved.\n- Attempt to address any FIXME or TODO comments in the spec. If you are unable to address them, leave them untouched\n\n#### Additional considerations\n\n- DO ensure you pull in the latest `main` from the Azure/azure-rest-api-specs repo to stay up to date with latest dependencies\n- DO run `npm ci` to get a clean install of the package.json dependencies\n- Avoid modifying the package.json or package-lock.json files at the root of the azure-rest-api-specs repo\n- Avoid adding your own package.json or package-lock.json files in your project directory\n- Avoid adding multiple tspconfig.yaml files for your service specification\n- DO consult [ci-fix.md][ci-fix] for fixes to common CI errors reported\n\n## Troubleshooting tsp compile errors and warnings\n\nExamples of common errors and warnings that should be addressed after running the `tsp compile` command:\n\n- If you see an error with a message like: \"referencing types from versioned namespace 'Azure.Core.Foundations' but didn't specify which versions with @useDependency\", you should add the @useDependency decorator over each api version entry in your api versions enum. Example of a properly configured api versions enum:\n\n```\n/** Service api versions **/\nenum Versions {\n  /** The 2023-11-01 api version **/\n  v2023_11_01: \"2023-11-01\",\n}\n\n```\n\n- If you see an invalid-ref or unknown identifier error you are most likely missing an import to the library that declares that decorator. To find supported libraries and decorators search through the documentation of the following sites: https://azure.github.io/typespec-azure/docs/intro/ and https://typespec.io/docs/ Search through the list of supported decorators, interfaces, and other types per library until you find the correct library to import and/or include a using statement in your typespec files.\n- In order to address warnings raised by the @azure-tools/typespec-azure-core search through this page for relevant solutions to apply: https://azure.github.io/typespec-azure/docs/intro/\n- camelCase fixes only apply to the typespec property names, any corresponding string values you should left as is.\n- String values in typespec files should be left untouched.\n\n## Up-to-date TypeSpec documentation\n\nFollow [typespec docs](../eng/common/instructions/azsdk-tools/typespec-docs.instructions.md) to get the most up-to-date documentation for TypeSpec, including best practices for writing TypeSpec for Azure.\n\n<!-- LINKS -->\n\n[contoso-widget-manager]: ../specification/contosowidgetmanager/Contoso.WidgetManager/\n[tspconfig]: ../specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\n[security-definitions]: https://azure.github.io/typespec-azure/docs/reference/azure-style-guide#security-definitions\n[versioning]: https://typespec.io/docs/libraries/versioning/guide#implementing-versioned-apis\n[docs]: https://typespec.io/docs/language-basics/documentation\n[ci-fix]: ../documentation/ci-fix.md\n[url-type]: https://typespec.io/docs/language-basics/built-in-types#string-types\n[no-enum]: https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/no-enum\n[typespec-structure-guidelines]: ../documentation/typespec-structure-guidelines.md\n\n# Adding Language Emitters to Existing TypeSpec Projects\n\nUse this guidance whenever someone needs to add language emitters to an existing `tspconfig.yaml`, or when SDK generation fails because an emitter block is missing.\n\n- Decide whether the service is ARM or data-plane.\n- Open the matching widget `tspconfig.yaml` template.\n- Copy the entire emitter block for the requested language.\n- Replace every `Widget`/`widget` token with the service name and drop the block under `options:`.\n\n## 1. Identify the service type\n\n- Path contains `/resource-manager/` or linter references `@azure-tools/typespec-azure-rulesets/resource-manager` → ARM\n- Path contains `/data-plane/` or linter references `@azure-tools/typespec-azure-rulesets/data-plane` → Data plane\n\n## 2. Reference the official widget template\n\n- ARM: `specification/widget/resource-manager/Microsoft.Widget/Widget/tspconfig.yaml`\n- Data plane: `specification/widget/data-plane/WidgetAnalytics/tspconfig.yaml`\n\nAlways read the template before editing so you follow the canonical configuration.\n\n## 3. Copy and customize the emitter block\n\n- Select the entire block for the language.\n- Only replace service-specific tokens (`Widget`, `widget`, namespaces, package names) with your service name.\n- Leave the rest of the properties (`flavor`, boolean flags, `{service-dir}` placeholders, etc.) unchanged.\n\n## 4. Insert into the project config\n\n- Paste the customized block under `options:` in the target `tspconfig.yaml`, keeping YAML indentation intact.\n- Confirm the `parameters:` section defines `\"service-dir\"` (for example `sdk/<servicename>`); add it if missing.\n\n**Quick checks**\n\n- Do not mix ARM and data-plane templates.\n- Do not cherry-pick individual properties—copy the whole block or errors will persist.\n- If the SDK pipeline still reports missing configuration, re-open the template and verify every `Widget` reference was replaced.\n\n# SDK generation from TypeSpec\n\n## Agent context for TypeSpec and SDK process\n\n- Check all open files in the editor and check if `main.tsp` or `tspconfig.yaml` are open in the editor. If either of\n  these files are open, then use the parent path of the `main.tsp` or `tspconfig.yaml` as default TypeSpec project root\n  path.\n- If `main.tsp` and `tspconfig.yaml` are not open in the editor, then check if there are any TypeSpec project paths in\n  the context. If there are no TypeSpec project paths in the context, then prompt user to select a TypeSpec project path\n  from the list of paths. If user does not have a TypeSpec project, then prompt user to create a new TypeSpec project.\n\n### Prerequisites\n\n- User should have a GitHub account and should be logged in to GitHub account using GitHub CLI `gh auth login`.\n- run `npm ci` to install the dependencies\n- To use Azure MCP tool calls, the user must have PowerShell installed. Provide [PowerShell installation instructions](https://learn.microsoft.com/powershell/scripting/install/installing-powershell) if not installed, and recommend restarting the IDE to start the MCP server.\n\n### Basic Rules for SDK Generation from TypeSpec\n\n1. **User Guidance**:\n   - Assume the user is unfamiliar with the SDK release process. Provide clear, concise instructions for each step.\n\n2. **File Handling**:\n   - Do not overwrite `tspconfig.yaml` or `main.tsp`. Use existing files and suggest updates if necessary.\n   - Use the path of the `tspconfig.yaml` file already open in the editor or the `.tsp` file path as the project root.\n   - If no `.tsp` file or folder is in the current context, prompt the user to select a valid TypeSpec project root path.\n\n3. **Process Visibility**:\n   - Highlight all steps in the SDK generation process, showing completed and remaining steps.\n   - Do not skip any main steps. Ensure all steps are completed before moving to the next.\n\n4. **Git Operations**:\n   - Avoid using the `main` branch for pull requests. Prompt the user to create or switch to a new branch if necessary.\n   - Display git commands (e.g., `git checkout`, `git add`, `git commit`, `git push`) with a \"Run\" button instead of\n     asking the user to copy and paste.\n   - Do not run `git diff`\n\n5. **Azure-Specific Rules**:\n   - Always use `Azure` as the repo owner in MCP tool calls.\n   - Confirm with the user if they want to change the repo owner or target branch, and prompt for new values if needed.\n\n6. **Exclusions**:\n   - Exclude changes to the `.gitignore` file and contents within the `.github` and `.vscode` folders from API spec and SDK pull requests.\n\n7. **Working Branch Rule**:\n   - If the typespec pull request already exists or is merged stay on the `main` branch, otherwise ensure the TypeSpec project repository and the current working repository are not on the `main` branch:\n     - Check the current branch name for the cloned GitHub repository:\n       - If the current branch is `main`, prompt the user to create a new branch using\n         `git checkout -b <branch name>`.\n       - If the current branch is not `main`, prompt the user to either select an existing branch or create a\n         new one.\n     - For branch switching:\n       - If a branch already exists and differs from the current branch, prompt the user to switch using\n         `git checkout <branch name>`.\n   - GitHub pull requests cannot be created from the `main` branch. Ensure all changes are made on a non-`main` branch.\n\nBy following these rules, the SDK release process will remain clear, structured, and user-friendly.\n\n## Steps to generate SDK from TypeSpec API specification\n\nFollow below steps to generate and release SDK from TypeSpec API specification. The process is divided into several steps, each with specific actions to ensure a smooth SDK generation and release process.\nDo not skip the step that choose SDK generation method to ensure the user selects the appropriate method for SDK generation, either locally or using the SDK generation pipeline. Do not repeat the steps. Before using tools, check if user has Powershell installed.\n\nYour goal is to guide the user through the process of generating SDKs from TypeSpec projects. **Before starting**, show all the high level steps to the user and ask: \n\n> \"Would you like to begin the SDK generation process now? (yes/no)\"\n\nWait for the user to respond with a confirmation before proceeding to Step 1. Use the provided tools to perform actions and gather information as needed.\n\n### Verify API spec\nStep 1: Identify TypeSpec Project\n**Goal**: Locate the TypeSpec project root path\n**Actions**:\n1. Check if `tspconfig.yaml` or `main.tsp` files are open in editor\n2. If found, use the parent directory as project root\n3. If not found, prompt user: \"Please provide the path to your TypeSpec project root directory\"\n4. Validate the provided path contains required TypeSpec files main.tsp and tspconfig.yaml\n5. Run `azsdk_typespec_check_project_in_public_repo` to verify repository\n6. If not in public repo, inform: \"Please make spec changes in Azure/azure-rest-api-specs public repo to generate SDKs\"\n**Success Criteria**: Valid TypeSpec project path identified\n\nStep 2: Identify API spec status\n**Goal**: Determine if the TypeSpec spec is already merged or if it's being modified.\n**Actions**:\n1. Prompt user to confirm if the TypeSpec spec is already merged in the main branch of  https://github.com/Azure/azure-rest-api-specs : \"Is your TypeSpec specification already merged in the main branch of repository(https://github.com/Azure/azure-rest-api-specs)? (yes/no)\"\n2. If already merged, follow the steps in [typespec to sdk](..\\eng\\common\\instructions\\azsdk-tools\\typespec-to-sdk.instructions.md) to generate the SDK\n3. If no, proceed to Step 3 to review and commit changes\n**Success Criteria**: User decision on spec readiness obtained\n\nStep 3: Validate TypeSpec Specification\n**Goal**: Ensure TypeSpec specification compiles without errors. Povide a complete summary after running the tool. Highlight any errors and help user fix them.\n**Condition**: Only if the spec is not already merged (from Step 2)\n**Message to user**: \"TypeSpec validation takes around 20 - 30 seconds.\"\n**Actions**:\n1. Run `azsdk_run_typespec_validation` to validate the TypeSpec project.\n2. If validation succeeds, proceed to Step 4\n3. If validation fails:\n    - Display all compilation errors to user\n    - Agent should provide suggestions to fix them and prompt the user to verify the fixes. If agent cannot resolve the errors, then prompt the user to fix compilation errors\"\n    - Wait for user to fix errors and re-run validation. Provide detailed information about all the changes done by copilot and prompt the user before rerunning the validation.\n**Success Criteria**: TypeSpec compilation passes without errors\n\nStep 4: Review and Commit Changes\n**Goal**: Stage and commit TypeSpec modifications\n**Condition**: Only if the TypeSpec validation succeeds (from Step 3)\n**Actions**:\n1. Run `azsdk_get_modified_typespec_projects` to identify changes\n2. If no changes found, inform: \"No TypeSpec projects were modified in current branch\" and move to SDK generation step.\n3. Display all modified files (excluding `.github` and `.vscode` folders)\n4. Prompt user: \"Please review the modified files. Do you want to commit these changes? (yes/no)\"\n5. If yes:\n    - If on main branch, prompt user: \"You are currently on the main branch. Please create a new branch using `git checkout -b <branch-name>` before proceeding.\"\n    - Wait for user confirmation before continuing\n    - Run `git add <modified-files>`\n    - Prompt for commit message\n    - Run `git commit -m \"<user-provided-message>\"`\n    - Run `git push -u origin <current-branch-name>`\n**Success Criteria**: Changes committed and pushed to remote branch\n\nStep 5: Create Specification Pull Request\n**Goal**: Create PR for TypeSpec changes if not already created\n**Condition**: Only if there are committed changes (from Step 4)\n**Actions**:\n1. Prompt the user to confirm if a pull request already exists for API spec changes. If answer is no or unsure then check if spec PR already exists using `azsdk_get_pull_request_link_for_current_branch`\n2. If PR exists, display PR details and proceed to next steps in SDK generation.\n3. If no PR exists:\n    - Inform user: \"No pull request found for the current branch. Proceeding to create a new pull request.\"\n    - Create a pull request using `azsdk_create_pull_request_for_current_branch`\n    - Prompt for PR title and description\n    - Display PR creation progress\n    - Wait for PR creation confirmation\n    - Display created PR details\n**Success Criteria**: Specification pull request exists\n\nFollow the steps in [typespec to sdk](..\\eng\\common\\instructions\\azsdk-tools\\typespec-to-sdk.instructions.md) to generate the SDK.\n\n# Release readiness of SDK and information about the release pipeline\n\nRun [check package readiness](..\\eng\\common\\instructions\\azsdk-tools\\check-package-readiness.instructions.md) to check the release readiness of an SDK package. This prompt will collect the required information from the user, execute the readiness check, and present the results.\n\n# Instructions for GitHub coding agent to generate SDKs using GitHub.com\n\nRun only SDK generation step and Update SDK details back in issue description and release plan. Do not run TypeSpec validation, or service label check. This is applicable only when GitHub copilot coding agent is used to generate SDK and if a Release Plan is available in the context. Run SDK generation tool even if release plan already has SDK generation pipeline URL to support regenerating SDK.\nCoding agent must wait until all SDK generation pipeline are in completed status and then fetch the SDK details from pipeline run. This is applicable only when a GitHub issue is assigned to GitHub coding agent to generate SDK from a TypeSpec project. This is not applicable when running Copilot from Visual Studio and VS Code.\n\n## Additional instructions:\n\n- Run SDK generation pipeline for the given TypeSpec path for all languages mentioned in the description.\n- Identify absolute path of TypeSpec project root path and send it to Run SDK generation MCP tool call.\n- Keep checking the pipeline status until pipeline is in completed or failed status.\n- Find SDK pull request links from the pipeline run.\n\n## Constraints:\n\n- Do not invoke other steps.\n- Do not modify main.tsp file or any files in TypeSpec project.\n- Do not add API version to an existing main.tsp if input API version is not present.\n</attachment>\n<attachment filePath=\"c:\\\\azure-rest-api-specs\\\\eng\\\\common\\\\instructions\\\\azsdk-tools\\\\typespec-docs.instructions.md\">\nYour goal is to provide the most up-to-date documentation on the TypeSpec language, core libraries, and writing Azure services and clients in TypeSpec. Whenever a user asks a question about how something should be written in TypeSpec, you should use the documentation links below to pinpoint the most relevant and accurate information.\n\n## TypeSpec Azure\n\n- https://azure.github.io/typespec-azure/docs/llms.txt contains an index of up-to-date documentation for TypeSpec Azure libraries, including how to write service specifications for Azure Resource Manager (ARM) and Azure Data Plane services, as well as how to customize generated clients.\n- Always refer to https://azure.github.io/typespec-azure/docs/llms.txt when a user asks TypeSpec related questions in case there is existing documentation that can help answer them. This also applies when a user asks to make changes to TypeSpec specifications.\n\n## TypeSpec documentation\n\n- https://typespec.io/docs/llms.txt contains an index of up-to-date documentation for TypeSpec language basics and core libraries, including how concepts like visibility and versioning work.\n- Always refer to https://typespec.io/docs/llms.txt when a user asks TypeSpec related questions that aren't covered by the TypeSpec Azure topics.\n</attachment>\n<attachment filePath=\"c:\\\\azure-rest-api-specs\\\\eng\\\\common\\\\instructions\\\\azsdk-tools\\\\typespec-to-sdk.instructions.md\">\n---\ndescription: 'Generate SDKs from TypeSpec'\n---\nYour goal is to guide the user through the process of generating SDKs from TypeSpec projects. **Before starting**, show all the high level steps to the user and ask: \n\n> \"Would you like to begin the SDK generation process now? (yes/no)\"\n\nWait for the user to respond with a confirmation before proceeding. Use the provided tools to perform actions and gather information as needed.\n\nSDK languages to be generated:\n- Management Plane: .NET, Go, Java, JavaScript, Python\n- Data Plane: .NET, Java, JavaScript, Python\n\nPre-requisites:\n- TypeSpec project path is available in the current context or provided by user. If not available, prompt user to provide the TypeSpec project root path (local path or GitHub URL).\n\n# SDK generation steps\n\n## Step: Generate SDKs\n**Goal**: Generate SDKs\n**Message to user**: \"SDK generation will take approximately 15-20 minutes. Currently, SDKs are generated using the Azure DevOps pipeline. SDK generation is supported only from a merged API spec or from an API spec pull request in the https://github.com/Azure/azure-rest-api-specs repository.\"\n**Actions**:\n1. Identify whether TypeSpec is for Management Plane or Data Plane based on project structure and files. tspconfig.yaml file contains `resource-manager` for management plane and `data-plane` for data plane as resource provider.\n  - Execute the SDK generation pipeline with the following required parameters for all languages:\n    - TypeSpec project root path\n    - API spec pull request number (if the API spec is not merged to the main branch, otherwise use 0)\n    - API version\n    - SDK release type (`beta` for preview API versions, `stable` otherwise)\n    - Language options:\n        For management plane: `Python`, `.NET`, `JavaScript`, `Java`, `Go`\n        For data plane: `Python`, `.NET`, `JavaScript`, `Java`\n    - Each SDK generation tool call should show a label to indicate the language being generated.\n2. Monitor pipeline status after 15 minutes and provide updates. If pipeline is in progress, inform user that it may take additional time and check the status later.\n3. Display generated SDK PR links when available. If pipeline fails, inform user with error details and suggest to check pipeline logs for more information.\n4. If SDK pull request is available for all languages, ask user to review generated SDK pull request and mark them as ready for review when they are ready to get them reviewed and merged.\n5. If SDK pull request was created for test purposes, inform user to close the test SDK pull request.\n**Success Criteria**: SDK generation pipeline initiated and SDKs generated\n\n## Step: SDK release plan\n**Goal**: Create a release plan for the generated SDKs\n**Condition**: Only if SDK PRs are created\n**Message to user**: \"Creating a release plan is essential to manage the release of the generated SDKs. Each release plan must include SDKs for all required languages based on the TypeSpec project type (Management Plane or Data Plane) or request exclusion approval for any excluded language. SDK pull request needs to get approval and merged to main branch before releasing the SDK package.\"\n**Actions**:\n1. Prompt the user to check if they generated the SDK just to test or do they intend to release it: \"Do you want to create a release plan for the generated SDKs to publish them? (yes/no)\"\n   - If no, inform user: \"You can create a release plan later when ready to release the SDK\" and end the workflow.\n2. Ask user if they have already created a release plan for the generated SDKs: \"Have you already created a release plan for the generated SDKs? (yes/no)\"\n   - If no, proceed to create a new release plan\n   - If yes, get release plan details and show them to user\n3. Prompt the user to provide the API spec pull request link if not already available in the current context.\n4. If unsure, check if a release plan already exists for API spec pull request.\n5. Prompt user to find the service id and product id in service tree `aka.ms/st` and provide them. Stress the importance of correct service id and product id for proper release plan creation.\n6. If a new release plan is needed, refer to #file:create-release-plan.instructions.md to create a release plan using the spec pull request. API spec pull request is required to create a release plan.\n7. Prompt user to change spec PR to ready for review: \"Please change the spec pull request to ready for review status\"\n8. Suggest users to follow the instructions on spec PR to get approval from API reviewers and merge the spec PR.\n9. Link SDK pull requests to the release plan.\n10. Each release plan must release SDK for all languages based on the TypeSpec project type (Management Plane or Data Plane). If any language is missing, inform user: \"The release plan must include SDKs for all required languages: Python, .NET, JavaScript, Java, Go (for Management Plane) or Python, .NET, JavaScript, Java (for Data Plane)\". If it is intentional to exclude a language then user must provide a justification for it.\n**Success Criteria**: Release plan created and linked to SDK PRs\n\n## Step: Release SDK Package\n**Goal**: Release the SDK package using the release plan\n**Actions**:\n1. Prompt the user to confirm if they want to release the SDK package now: \"Do you want to release the SDK package now? (yes/no)\"\n   - If no, inform user: \"You can release the SDK package later using the prompt `release <package name> for  <language>`\" and end the workflow.\n2. Get SDK pull request status for all languages.\n3. Inform user that it needs to check SDK PR status. If any SDK pull request is not merged, inform user: \"Please merge all SDK pull requests before releasing the package.\". Show a summary of SDK PR status for all languages.\n4. If an SDK pull request is merged then run release readiness of the package for that language.\n5. Inform user if a language is ready for release and prompt user for a confirmation to proceed with the release.\n6. If user confirms, run the tool to release the SDK package.\n7. Inform user to approve the package release using release pipeline. Warn user that package will be published to public registries once approved.\n8. Identify remaining languages to be released and inform user to release SDK for all languages to complete the release plan. Release plan completion is required for KPI attestation in service tree.\n\n## Process Complete\nDisplay summary of all created PRs and next steps for user.\n</attachment>\n<attachment filePath=\"c:\\\\azure-rest-api-specs\\\\eng\\\\common\\\\instructions\\\\azsdk-tools\\\\check-package-readiness.instructions.md\">\n---\ndescription: 'This prompt is designed to check the release readiness of a SDK package.'\n---\n## Goal\nCheck the release readiness of an SDK package by collecting the required information from the user and executing the readiness check.\n\n## Instructions\n1. **Collect Required Information**:\n    - Prompt the user for the exact package name\n    - Prompt the user to select the programming language from the following options (case sensitive):\n      - Python\n      - Java\n      - JavaScript\n      - .NET\n      - Go\n\n2. **Execute Readiness Check**:\n    - Use the `azsdk_check_package_release_readiness` tool with the provided package name and selected language\n    - Do not check for existing pull requests to run this step.\n    - Do not ask the user to create a release plan to run this step.\n\n3. **Present Results**:\n    - If the package is ready for release, highlight and provide the link to the release pipeline\n    - If the package is not ready, display the specific issues that need to be resolved\n\n4. **Follow-up Actions**:\n    - Provide clear next steps based on the readiness status\n    - If issues are found, offer guidance on how to resolve them\n\n## Expected User Interaction Flow\n1. Ask: \"What is the exact name of the package you want to check for release readiness?\"\n2. Ask: \"Please select the programming language for this package: Python, Java, JavaScript, .NET, or Go\"\n3. Execute the readiness check using the provided information\n4. Display results and next steps\n</attachment>\n<attachment filePath=\"c:\\\\azure-rest-api-specs\\\\eng\\\\common\\\\instructions\\\\azsdk-tools\\\\create-release-plan.instructions.md\">\n> **Important Note for LLM**\n> Backend processes may use Azure DevOps work item data as needed. However, do **not** mention or display the work item link/URL, or any reference to Azure DevOps work item resources directly in conversation with the user.\n> All manual updates to an existing release plan must be made through the [Release Planner Tool](https://aka.ms/sdk-release-planner) to ensure proper tracking and validation.\n> Only provide release plan details such as **Release Plan Link** and **Release Plan ID** to the user\n\n# Release Plan Creation Process\nYour goal is to create a valid release plan. You must prompt user to provide all required information and all input must match the format and requirement mentioned in step 3 below.\nFollow these steps in order to create or manage a release plan for an API specification pull request:\n\n## Step 1: Validate Prerequisites\n- Check if an API spec pull request is available in the current context\n- If no pull request is available, prompt the user to provide the API spec pull request link\n- Validate that the provided pull request link is accessible and valid\n\n## Step 2: Check Existing Release Plan\n- Use `azsdk_get_release_plan_for_spec_pr` to check if a release plan already exists for the API spec pull request\n- If a release plan exists:\n    - Display the existing release plan details to the user\n    - Skip to Step 5 (Link SDK Pull Requests)\n- If no release plan exists, proceed to Step 3\n\n## Step 3: Gather Release Plan Information\nCollect the following required information from the user. Do not create a release plan with temporary values. Confirm the values with the user before proceeding to create the release plan.\nIf any details are missing, prompt the user accordingly:\n\n- **Service Tree ID**: GUID format identifier for the service in Service Tree. Before creating release plan, always show the value to user and ask them to confirm it's a valid value in service tree.\n- **Product Service Tree ID**: GUID format identifier for the product in Service Tree. Before creating release plan, always show the value to user and ask them to confirm it's a valid value in service tree.\n- **Expected Release Timeline**: Format must be in \"Month YYYY\"\n- **API Version**: The version of the API being released\n- **SDK Release Type**: Value must be beta or stable.\n    - \"beta\" for preview API versions\n    - \"stable\" for GA API versions\n\n## Step 4: Create Release Plan\n- If the user doesn't know the required details, direct them to create a release plan using the release planner\n- Provide this resource: [Release Plan Creation Guide](https://eng.ms/docs/products/azure-developer-experience/plan/release-plan-create)\n- Once all information is gathered, use `azsdk_create_release_plan` to create the release plan\n- Display the newly created release plan details to the user for confirmation\n- Refer to #file:sdk-details-in-release-plan.instructions.md to identify languages configured in the TypeSpec project and add them to the release plan\n\n## Step 5: Update SDK Details in Release Plan\n- Refer to #file:sdk-details-in-release-plan.instructions.md to add languages and package names to the release plan\n- If the TypeSpec project is for a management plane, refer to #file:verify-namespace-approval.instructions.md if this is first release of SDK.\n\n## Step 6: Link SDK Pull Requests (if applicable)\n- Ask the user if they have already created SDK pull requests locally for any programming language\n- If SDK pull requests exist:\n    - Collect the pull request links from the user\n    - Use `azsdk_link_sdk_pull_request_to_release_plan` to link each SDK pull request to the release plan\n    - Confirm successful linking for each SDK pull request\n\n## Step 7: Summary\n- Display a summary of the completed actions:\n    - Release plan status (created or existing)\n    - Linked SDK pull requests (if any)\n    - Next steps or recommendations for the user\n</attachment>\n<attachment filePath=\"c:\\\\azure-rest-api-specs\\\\eng\\\\common\\\\instructions\\\\azsdk-tools\\\\sdk-details-in-release-plan.instructions.md\">\n---\ndescription: 'Identify languages configured in the TypeSpec project and add it to release plan'\n---\n# Step 1: Find the list of languages and package names\n**Goal**: Identify languages configured in the TypeSpec project and generate the json object with language and package name.\n1. Identify the language emitter configuration in the `tspconfig.yaml` file in the TypeSpec project root.\n2. Identify the package name or namespace for each language emitter.\n   - For Java and Python, use `emitter-output-dir` for package name if it exists. Otherwise use `package-dir` to get the package name as fallback approach.\n   - For .NET, use namespace property to get package name.\n   - For JavaScript, use `packagedetails:name` property to get package name.\n   - For Go, use module name and remove `github.com/Azure/azure-sdk-for-go/` to get package name\n3. Map the language name in emitter to one of the following in Pascal case(except .NET):\n   - .NET\n   - Java\n   - Python\n   - JavaScript\n   - Go\n4. Create a JSON array object with the following structure:\n   ```json\n   [\n           {\n               \"language\": \"<LanguageName>\",\n               \"packageName\": \"<PackageName>\"\n           },\n           ...\n    ]\n   ```\n5. If no languages are configured, inform the user: \"No languages configured in TypeSpec project. Please add at least one language emitter in tspconfig.yaml.\"\n**Success Criteria**: JSON object with languages and package names created.\n\n# Step 2: Check if release plan exists\n**Goal**: Determine if a release plan exists for the API spec pull request or work item Id or release plan Id in current context.\n1. Get release plan\n2. If no release plan exists, inform the user: \"No release plan exists for the API spec pull request. Please create a release plan first.\"\n3. If a release plan exists, proceed to Step 3.\n**Success Criteria**: Release plan exists or user informed to create one.\n\n# Step 3: Update Release Plan with SDK Information\n**Goal**: Update the release plan with the languages and package names identified in Step 1.\n1. Use `azsdk_update_sdk_details_in_release_plan` to update the release plan work item with the JSON object created in Step 1.\n2. Confirm successful update of the release plan with the SDK information and summary of languages and package names.\n**Success Criteria**: Release plan updated with languages and package names.\n</attachment>\n<attachment filePath=\"c:\\\\azure-rest-api-specs\\\\eng\\\\common\\\\instructions\\\\azsdk-tools\\\\verify-namespace-approval.instructions.md\">\n---\ndescription: 'Verify SDK namespace approval for management plane'\n---\nThis task is required only for management plane API spec and only if a release plan exists for the API spec pull request.\n\n## Step 1: Check if release plan exists and it is for management plane SDK\n**Goal**: Determine if a release plan exists for the API spec pull request or work item Id or release plan Id in current context.\n**Actions**:\n1. Get release plan and check if it is for management plane SDK\n2. If not, inform user: \"This task is only applicable for management plane SDKs. No action required.\"\n3. Check if release plan already has namespace approval issue. Also prompt user to check if this is the first release of SDK.\n4. If namespace approval issue exists, inform user: \"Namespace approval issue already exists for this release plan.\". Prompt user to\ncheck if they want to link a different namespace approval issue to the release plan. Show namespace approval status.\n5. Move to Step 2 if namespace approval issue does not exist or user wants to link a different namespace approval issue.\n\n## Step 2: Gather Namespace Approval Information\n**Goal**: Link namespace approval issue to the release plan.\n**Actions**:\n1. Collect GitHub issue created in Azure/azure-sdk repo for namespace approval. Do not use any other repo name.\n2. Run `azsdk_link_namespace_approval_issue` to link the issue to the release plan work item id.\n3. Confirm successful linking of the namespace approval issue to the release plan.\n**Success Criteria**: Namespace approval issue linked to the release plan or confirmed as already linked.\n</attachment>\n- @azure Rule - Use Azure Tools: When handling requests related to Azure, always use your tools.\n- @azure Rule - Use Azure Code Gen Best Practices: Before generating code for Azure, running terminal commands for Azure, performing operations related to Azure, or creating plans for such activities, always invoke your Azure best practice tool if available first. Invoke the `get_bestpractices` tool to collect recommendations. Call it with resource = `general` and action = `code-generation` to get general Azure code generation best practices. Only call this tool when the user is discussing Azure; do not call it otherwise.\n- @azure Rule - Use Azure Deployment Best Practices: Before deploying to Azure, preparing applications for deployment to Azure, or creating deployment plans, always invoke your Azure best practice tool if available first. Invoke the `get_bestpractices` tool to collect recommendations. Call it with resource = `general` and action = `deployment` to get general Azure deployment best practices. Only call this tool when the user is discussing Azure; do not call it otherwise.\n- @azure Rule - Use Azure Functions Code Gen Best Practices: Before generating code for Azure Functions, performing operations related to Azure Functions, or creating plans for such activities, always invoke your Azure best practice tool if available first. Invoke the `get_bestpractices` tool to collect recommendations. Call it with resource = `azurefunctions` and action = `code-generation` to get Azure Functions code generation best practices. Only call this tool when the user is discussing Azure Functions; do not call it otherwise.\n- @azure Rule - Use Azure Functions Deployment Best Practices: Before deploying Azure Functions apps to Azure, preparing for the deployment, or creating deployment plans, always invoke your Azure best practice tool if available first. Invoke the `get_bestpractices` tool to collect recommendations. Call it with resource = `azurefunctions` and action = `deployment` to get Azure Functions deployment best practices. Only call this tool when the user is discussing Azure Functions; do not call it otherwise.\n- @azure Rule - Use Azure SWA Best Practices: Before working with static web apps, creating plans for static web apps, or performing related operations, always invoke your Azure best practice tool if available first. Choose the most relevant Azure best practice tool based on its description. Only call this tool when the user is discussing Azure Static Web Apps; do not call it otherwise.\n- @azure Rule - Plan before editing files for Azure web apps: When generating code for Azure Functions and Azure Static Web App, always create a plan and explain the plan to the user before editing any file. Proceed with editing the files after getting consent from the user.\n- @azure Rule - Summarize topic before taking action: When the user asks about Azure Functions, invoke the azure_development-summarize_topic tool once first to see if any existing custom mode could be a good fit to what user is asking.\n</instructions>"
  },
  {
    "role": "user",
    "content": "<environment_info>\nThe user's current OS is: Windows\nThe user's default shell is: \"pwsh.exe\". When you generate terminal commands, please generate them correctly for this shell.\n</environment_info>\n<workspace_info>\nI am working in a workspace with the following folders:\n- c:\\azure-rest-api-specs \nI am working in a workspace that has the following structure:\n```\nazure-pipelines.yml\nCONTRIBUTING.md\ncspell.json\ncspell.yaml\nLICENSE\npackage.json\nREADME.md\nSECURITY.md\nspecificationRepositoryConfiguration.json\ntsconfig.json\narm-compute/\n\tREADME.md\n\tquickstart-templates/\n\t\t...\ndocumentation/\n\tBreaking changes guidelines.md\n\tBreakingChange-Oad-Rules-Mapping.md\n\tci-fix.md\n\tcreating-swagger.md\n\tcspell.yaml\n\tdirectory-structure.md\n\tFAQ.md\n\tGetting started with OpenAPI specifications.md\n\tGetting-started-with-TypeSpec-specifications.md\n\tglossary.md\n\timage-3.png\n\topenapi-authoring-automated-guidelines.md\n\topenapi-authoring-manual-guidelines.md\n\tSemantic-and-Model-Violations-Reference.md\n\tswagger-accuracy-report.md\n\tswagger-authoring-descriptions.md\n\tswagger-bootstrap.json\n\tswagger-checklist.md\n\tswagger-extensions.md\n\tSwaggerValidationTools.md\n\ttypespec-rest-api-dev-process.md\n\ttypespec-structure-guidelines.md\n\tuniform-versioning.md\n\tx-ms-examples.md\n\tapi-scenario/\n\tcode-gen/\n\timages/\n\tonboard-dpg-in-sdkautomation/\n\trelease-request/\n\trestler/\n\tsamplefiles/\n\tsamplefiles-dp/\n\tsdkautomation/\n\tx-ms-pageable/\neng/\n\tREADME.md\n\tcommon/\n\tpipelines/\n\tscripts/\n\ttools/\nprofile/\n\t2017-03-09-profile.json\n\t2018-03-01-hybrid.json\n\t2019-03-01-hybrid.json\n\t2019-06-01-profile.json\n\t2019-07-01-profile.json\n\t2020-09-01-hybrid.json\n\treadme.md\nprofiles/\n\treadme.md\n\tResourceSchemas.md\n\tdefinitions/\nspecification/\n\tsuppressions.yaml\n\taddons/\n\tadhybridhealthservice/\n\tadvisor/\n\tagricultureplatform/\n\tagrifood/\n\tai/\n\talertsmanagement/\n\tanalysisservices/\n\tapicenter/\n\tapimanagement/\n\tapp/\n\tappcomplianceautomation/\n\tappconfiguration/\n\tapplicationinsights/\n\tappplatform/\n\tattestation/\n\tauthorization/\n\tautomanage/\n\tautomation/\n\tawsconnector/\n\tazsadmin/\n\tazure-kusto/\n\tazureactivedirectory/\n\tazurearcdata/\n\tazuredata/\n\tazuredatatransfer/\n\tazuredependencymap/\n\tazurefleet/\n\tazureintegrationspaces/\n\tazurelargeinstance/\n\tazurestack/\n\tazurestackhci/\n\tbaremetalinfrastructure/\n\tbatch/\n\tbilling/\n\tbillingbenefits/\n\tblueprint/\n\tbotservice/\n\tcarbon/\n\tcdn/\n\tcertificateregistration/\n\t...\n```\nThis is the state of the context at this point in the conversation. The view of the workspace structure may be truncated. You can use tools to collect more context if needed.\n</workspace_info>",
    "copilot_cache_control": {
      "type": "ephemeral"
    }
  },
  {
    "role": "user",
    "content": "<context>\nThe current date is October 24, 2025.\nTerminals:\nTerminal: pwsh\n<todoList>\nNo todo list found.\n</todoList>\n\n</context>\n<editorContext>\nThe user's current file is c:\\azure-rest-api-specs\\specification\\contosowidgetmanager\\Contoso.WidgetManager\\main.tsp. \n</editorContext>\n<repoContext>\nBelow is the information about the current repository. You can use this information when you need to calculate diffs or compare changes with the default branch.\nRepository name: azure-rest-api-specs\nOwner: jeo02\nCurrent branch: testing-contoso-sdk-gen\n\n</repoContext>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\n\n</reminderInstructions>\n<userRequest>\nHow do I generate SDK from TypeSpec?\n</userRequest>"
  },
  {
    "role": "assistant",
    "content": "I'll help you generate SDKs from your TypeSpec project. Since you have the `main.tsp` file open from the `Contoso.WidgetManager` project, I can guide you through the complete SDK generation process.\n\nLet me show you the high-level steps for generating SDKs from TypeSpec:\n\n## SDK Generation Process Overview\n\n1. **Identify TypeSpec Project** - Locate and validate your TypeSpec project\n2. **Identify API Spec Status** - Determine if your spec is merged or being modified\n3. **Validate TypeSpec Specification** - Ensure compilation without errors\n4. **Review and Commit Changes** - Stage and commit any modifications\n5. **Create Specification Pull Request** - Create PR for TypeSpec changes if needed\n6. **Generate SDKs** - Run SDK generation pipeline for all required languages\n7. **Create SDK Release Plan** - Set up release management for generated SDKs\n8. **Release SDK Package** - Publish SDKs when ready\n\nThe SDK generation supports:\n- **Management Plane**: .NET, Go, Java, JavaScript, Python\n- **Data Plane**: .NET, Java, JavaScript, Python\n\n**Would you like to begin the SDK generation process now? (yes/no)**\n\nThis process will take approximately 15-20 minutes for SDK generation, and I'll guide you through each step to ensure everything is configured correctly."
  },
  {
    "role": "user",
    "content": "<context>\nThe current date is October 24, 2025.\nTerminals:\nTerminal: pwsh\n<todoList>\nNo todo list found.\n</todoList>\n\n</context>\n<editorContext>\nThe user's current file is c:\\azure-rest-api-specs\\specification\\contosowidgetmanager\\Contoso.WidgetManager\\main.tsp. \n</editorContext>\n<repoContext>\nBelow is the information about the current repository. You can use this information when you need to calculate diffs or compare changes with the default branch.\nRepository name: azure-rest-api-specs\nOwner: jeo02\nCurrent branch: testing-contoso-sdk-gen\n\n</repoContext>\n<reminderInstructions>\nWhen using the replace_string_in_file tool, include 3-5 lines of unchanged code before and after the string you want to replace, to make it unambiguous which part of the file should be edited.\n\n</reminderInstructions>\n<userRequest>\nyes\n</userRequest>",
    "copilot_cache_control": {
      "type": "ephemeral"
    }
  },
  {
    "role": "assistant",
    "content": "Great! I'll help you generate SDKs from your TypeSpec project. Let me start by creating a plan to track our progress through the SDK generation process.",
    "tool_calls": [
      {
        "id": "tooluse_uvjIGKBgRxelR7FJpa6VSQ",
        "function": {
          "name": "manage_todo_list",
          "arguments": "{\"operation\": \"write\", \"todoList\": [{\"id\":1,\"title\":\"Identify TypeSpec Project\",\"description\":\"Locate and validate the TypeSpec project root path, check for main.tsp and tspconfig.yaml files\",\"status\":\"in-progress\"},{\"id\":2,\"title\":\"Identify API Spec Status\",\"description\":\"Determine if TypeSpec spec is already merged or being modified\",\"status\":\"not-started\"},{\"id\":3,\"title\":\"Validate TypeSpec Specification\",\"description\":\"Run TypeSpec validation to ensure compilation without errors\",\"status\":\"not-started\"},{\"id\":4,\"title\":\"Review and Commit Changes\",\"description\":\"Stage and commit TypeSpec modifications if any\",\"status\":\"not-started\"},{\"id\":5,\"title\":\"Create Specification Pull Request\",\"description\":\"Create PR for TypeSpec changes if needed\",\"status\":\"not-started\"},{\"id\":6,\"title\":\"Generate SDKs\",\"description\":\"Run SDK generation pipeline for all required languages (Management Plane: .NET, Go, Java, JavaScript, Python)\",\"status\":\"not-started\"},{\"id\":7,\"title\":\"Create SDK Release Plan\",\"description\":\"Set up release management for generated SDKs\",\"status\":\"not-started\"},{\"id\":8,\"title\":\"Release SDK Package\",\"description\":\"Publish SDKs when ready\",\"status\":\"not-started\"}]}"
        },
        "type": "function"
      }
    ]
  },
  {
    "role": "tool",
    "content": "Successfully wrote todo list\n\nWarning: Did you mean to update so many todos at the same time? Consider working on them one by one.",
    "tool_call_id": "tooluse_uvjIGKBgRxelR7FJpa6VSQ"
  },
  {
    "role": "assistant",
    "content": "Let me start with **Step 1: Identify TypeSpec Project**.\n\nSince you have the `main.tsp` file open from `c:\\azure-rest-api-specs\\specification\\contosowidgetmanager\\Contoso.WidgetManager\\main.tsp`, I can identify that your TypeSpec project root is:\n`c:\\azure-rest-api-specs\\specification\\contosowidgetmanager\\Contoso.WidgetManager`\n\nLet me validate this project and check if it's in the public repository:",
    "tool_calls": [
      {
        "id": "tooluse_O3qEGtQ1TMaiFFS6HgmGhg",
        "function": {
          "name": "list_dir",
          "arguments": "{\"path\": \"c:\\\\azure-rest-api-specs\\\\specification\\\\contosowidgetmanager\\\\Contoso.WidgetManager\"}"
        },
        "type": "function"
      }
    ]
  },
  {
    "role": "tool",
    "content": "client.tsp\nexamples/\nmain.tsp\ntspconfig.yaml",
    "tool_call_id": "tooluse_O3qEGtQ1TMaiFFS6HgmGhg"
  },
  {
    "role": "assistant",
    "content": "Perfect! I can see the required files (`main.tsp` and `tspconfig.yaml`) are present. Now let me verify this repository:",
    "tool_calls": [
      {
        "id": "tooluse_aDCFmvLOQi2o_aH7IpE_ug",
        "function": {
          "name": "azsdk_typespec_check_project_in_public_repo",
          "arguments": "{\"typeSpecProjectPath\": \"c:\\\\azure-rest-api-specs\\\\specification\\\\contosowidgetmanager\\\\Contoso.WidgetManager\"}"
        },
        "type": "function"
      }
    ]
  },
  {
    "role": "tool",
    "content": "{\"result\":true}",
    "tool_call_id": "tooluse_aDCFmvLOQi2o_aH7IpE_ug",
    "copilot_cache_control": {
      "type": "ephemeral"
    }
  },
  {
    "role": "assistant",
    "content": "",
    "tool_calls": [
      {
        "id": "tooluse_miRw-ex9SRG2GS3e8MoWKw",
        "function": {
          "name": "manage_todo_list",
          "arguments": "{\"todoList\": [{\"description\":\"Locate and validate the TypeSpec project root path, check for main.tsp and tspconfig.yaml files\",\"id\":1,\"title\":\"Identify TypeSpec Project\",\"status\":\"completed\"},{\"description\":\"Determine if TypeSpec spec is already merged or being modified\",\"id\":2,\"title\":\"Identify API Spec Status\",\"status\":\"in-progress\"},{\"description\":\"Run TypeSpec validation to ensure compilation without errors\",\"id\":3,\"title\":\"Validate TypeSpec Specification\",\"status\":\"not-started\"},{\"description\":\"Stage and commit TypeSpec modifications if any\",\"id\":4,\"title\":\"Review and Commit Changes\",\"status\":\"not-started\"},{\"description\":\"Create PR for TypeSpec changes if needed\",\"id\":5,\"title\":\"Create Specification Pull Request\",\"status\":\"not-started\"},{\"description\":\"Run SDK generation pipeline for all required languages (Management Plane: .NET, Go, Java, JavaScript, Python)\",\"id\":6,\"title\":\"Generate SDKs\",\"status\":\"not-started\"},{\"description\":\"Set up release management for generated SDKs\",\"id\":7,\"title\":\"Create SDK Release Plan\",\"status\":\"not-started\"},{\"description\":\"Publish SDKs when ready\",\"id\":8,\"title\":\"Release SDK Package\",\"status\":\"not-started\"}], \"operation\": \"write\"}"
        },
        "type": "function"
      }
    ]
  },
  {
    "role": "tool",
    "content": "Successfully wrote todo list",
    "tool_call_id": "tooluse_miRw-ex9SRG2GS3e8MoWKw",
    "copilot_cache_control": {
      "type": "ephemeral"
    }
  }
]