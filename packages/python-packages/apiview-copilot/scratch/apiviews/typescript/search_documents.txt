 "."
	export function createSynonymMapFromFile(name: string, filePath: string): Promise<SynonymMap>;
	
	export function odata(strings: TemplateStringsArray, ...values: unknown[]): string;
	
	export default class GeographyPoint {
		latitude: number;
		longitude: number;
		constructor(geographyPoint: {
			        longitude: number;
			        latitude: number;
			    });
		toJSON(): Record<string, unknown>;
	}
	
	export declare class IndexDocumentsBatch<TModel> {
		readonly actions: IndexDocumentsAction<TModel>[];
		constructor(actions?: IndexDocumentsAction<TModel>[]);
		delete(keyName: keyof TModel, keyValues: string[]): void;
		delete(documents: TModel[]): void;
		merge(documents: TModel[]): void;
		mergeOrUpload(documents: TModel[]): void;
		upload(documents: TModel[]): void;
	}
	
	export declare class SearchClient<TModel extends object> implements IndexDocumentsClient<TModel> {
		readonly apiVersion: string;
		readonly endpoint: string;
		readonly indexName: string;
		readonly pipeline: Pipeline;
		readonly serviceVersion: string;
		constructor(endpoint: string, indexName: string, credential: KeyCredential | TokenCredential, options?: SearchClientOptions);
		autocomplete(searchText: string, suggesterName: string, options?: AutocompleteOptions<TModel>): Promise<AutocompleteResult>;
		deleteDocuments(documents: TModel[], options?: DeleteDocumentsOptions): Promise<IndexDocumentsResult>;
		deleteDocuments(keyName: keyof TModel, keyValues: string[], options?: DeleteDocumentsOptions): Promise<IndexDocumentsResult>;
		getDocument<TFields extends SelectFields<TModel>>(key: string, options?: GetDocumentOptions<TModel, TFields>): Promise<NarrowedModel<TModel, TFields>>;
		getDocumentsCount(options?: CountDocumentsOptions): Promise<number>;
		indexDocuments(batch: IndexDocumentsBatch<TModel>, options?: IndexDocumentsOptions): Promise<IndexDocumentsResult>;
		mergeDocuments(documents: TModel[], options?: MergeDocumentsOptions): Promise<IndexDocumentsResult>;
		mergeOrUploadDocuments(documents: TModel[], options?: MergeOrUploadDocumentsOptions): Promise<IndexDocumentsResult>;
		search<TFields extends SelectFields<TModel>>(searchText?: string, options?: SearchOptions<TModel, TFields>): Promise<SearchDocumentsResult<TModel, TFields>>;
		suggest<TFields extends SelectFields<TModel> = never>(searchText: string, suggesterName: string, options?: SuggestOptions<TModel, TFields>): Promise<SuggestDocumentsResult<TModel, TFields>>;
		uploadDocuments(documents: TModel[], options?: UploadDocumentsOptions): Promise<IndexDocumentsResult>;
	}
	
	export declare class SearchIndexClient {
		readonly apiVersion: string;
		readonly endpoint: string;
		readonly pipeline: Pipeline;
		readonly serviceVersion: string;
		constructor(endpoint: string, credential: KeyCredential | TokenCredential, options?: SearchIndexClientOptions);
		analyzeText(indexName: string, options: AnalyzeTextOptions): Promise<AnalyzeResult>;
		createAlias(alias: SearchIndexAlias, options?: CreateAliasOptions): Promise<SearchIndexAlias>;
		createIndex(index: SearchIndex, options?: CreateIndexOptions): Promise<SearchIndex>;
		createOrUpdateAlias(alias: SearchIndexAlias, options?: CreateOrUpdateAliasOptions): Promise<SearchIndexAlias>;
		createOrUpdateIndex(index: SearchIndex, options?: CreateOrUpdateIndexOptions): Promise<SearchIndex>;
		createOrUpdateSynonymMap(synonymMap: SynonymMap, options?: CreateOrUpdateSynonymMapOptions): Promise<SynonymMap>;
		createSynonymMap(synonymMap: SynonymMap, options?: CreateSynonymMapOptions): Promise<SynonymMap>;
		deleteAlias(alias: string | SearchIndexAlias, options?: DeleteAliasOptions): Promise<void>;
		deleteIndex(index: string | SearchIndex, options?: DeleteIndexOptions): Promise<void>;
		deleteSynonymMap(synonymMap: string | SynonymMap, options?: DeleteSynonymMapOptions): Promise<void>;
		getAlias(aliasName: string, options?: GetAliasOptions): Promise<SearchIndexAlias>;
		getIndex(indexName: string, options?: GetIndexOptions): Promise<SearchIndex>;
		getIndexStatistics(indexName: string, options?: GetIndexStatisticsOptions): Promise<SearchIndexStatistics>;
		getSearchClient<TModel extends object>(indexName: string, options?: GetSearchClientOptions): SearchClient<TModel>;
		getServiceStatistics(options?: GetServiceStatisticsOptions): Promise<SearchServiceStatistics>;
		getSynonymMap(synonymMapName: string, options?: GetSynonymMapsOptions): Promise<SynonymMap>;
		listAliases(options?: ListAliasesOptions): AliasIterator;
		listIndexes(options?: ListIndexesOptions): IndexIterator;
		listIndexesNames(options?: ListIndexesOptions): IndexNameIterator;
		listSynonymMaps(options?: ListSynonymMapsOptions): Promise<Array<SynonymMap>>;
		listSynonymMapsNames(options?: ListSynonymMapsOptions): Promise<Array<string>>;
	}
	
	export declare class SearchIndexerClient {
		readonly apiVersion: string;
		readonly endpoint: string;
		readonly pipeline: Pipeline;
		readonly serviceVersion: string;
		constructor(endpoint: string, credential: KeyCredential | TokenCredential, options?: SearchIndexerClientOptions);
		createDataSourceConnection(dataSourceConnection: SearchIndexerDataSourceConnection, options?: CreateDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
		createIndexer(indexer: SearchIndexer, options?: CreateIndexerOptions): Promise<SearchIndexer>;
		createOrUpdateDataSourceConnection(dataSourceConnection: SearchIndexerDataSourceConnection, options?: CreateorUpdateDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
		createOrUpdateIndexer(indexer: SearchIndexer, options?: CreateorUpdateIndexerOptions): Promise<SearchIndexer>;
		createOrUpdateSkillset(skillset: SearchIndexerSkillset, options?: CreateOrUpdateSkillsetOptions): Promise<SearchIndexerSkillset>;
		createSkillset(skillset: SearchIndexerSkillset, options?: CreateSkillsetOptions): Promise<SearchIndexerSkillset>;
		deleteDataSourceConnection(dataSourceConnection: string | SearchIndexerDataSourceConnection, options?: DeleteDataSourceConnectionOptions): Promise<void>;
		deleteIndexer(indexer: string | SearchIndexer, options?: DeleteIndexerOptions): Promise<void>;
		deleteSkillset(skillset: string | SearchIndexerSkillset, options?: DeleteSkillsetOptions): Promise<void>;
		getDataSourceConnection(dataSourceConnectionName: string, options?: GetDataSourceConnectionOptions): Promise<SearchIndexerDataSourceConnection>;
		getIndexer(indexerName: string, options?: GetIndexerOptions): Promise<SearchIndexer>;
		getIndexerStatus(indexerName: string, options?: GetIndexerStatusOptions): Promise<SearchIndexerStatus>;
		getSkillset(skillsetName: string, options?: GetSkillSetOptions): Promise<SearchIndexerSkillset>;
		listDataSourceConnections(options?: ListDataSourceConnectionsOptions): Promise<Array<SearchIndexerDataSourceConnection>>;
		listDataSourceConnectionsNames(options?: ListDataSourceConnectionsOptions): Promise<Array<string>>;
		listIndexers(options?: ListIndexersOptions): Promise<Array<SearchIndexer>>;
		listIndexersNames(options?: ListIndexersOptions): Promise<Array<string>>;
		listSkillsets(options?: ListSkillsetsOptions): Promise<Array<SearchIndexerSkillset>>;
		listSkillsetsNames(options?: ListSkillsetsOptions): Promise<Array<string>>;
		resetDocuments(indexerName: string, options?: ResetDocumentsOptions): Promise<void>;
		resetIndexer(indexerName: string, options?: ResetIndexerOptions): Promise<void>;
		resetSkills(skillsetName: string, options?: ResetSkillsOptions): Promise<void>;
		runIndexer(indexerName: string, options?: RunIndexerOptions): Promise<void>;
	}
	
	export declare class SearchIndexingBufferedSender<TModel extends object> {
		constructor(client: IndexDocumentsClient<TModel>, documentKeyRetriever: (document: TModel) => string, options?: SearchIndexingBufferedSenderOptions);
		deleteDocuments(documents: TModel[], options?: SearchIndexingBufferedSenderDeleteDocumentsOptions): Promise<void>;
		dispose(): Promise<void>;
		flush(options?: SearchIndexingBufferedSenderFlushDocumentsOptions): Promise<void>;
		mergeDocuments(documents: TModel[], options?: SearchIndexingBufferedSenderMergeDocumentsOptions): Promise<void>;
		mergeOrUploadDocuments(documents: TModel[], options?: SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions): Promise<void>;
		off(event: "batchAdded", listener: (e: {
			        action: string;
			        documents: TModel[];
			    }) => void): void;
		off(event: "beforeDocumentSent", listener: (e: IndexDocumentsAction<TModel>) => void): void;
		off(event: "batchSucceeded", listener: (e: IndexDocumentsResult) => void): void;
		off(event: "batchFailed", listener: (e: RestError) => void): void;
		on(event: "batchAdded", listener: (e: {
			        action: string;
			        documents: TModel[];
			    }) => void): void;
		on(event: "beforeDocumentSent", listener: (e: IndexDocumentsAction<TModel>) => void): void;
		on(event: "batchSucceeded", listener: (e: IndexDocumentsResult) => void): void;
		on(event: "batchFailed", listener: (e: RestError) => void): void;
		uploadDocuments(documents: TModel[], options?: SearchIndexingBufferedSenderUploadDocumentsOptions): Promise<void>;
	}
	
	export enum KnownAIStudioModelCatalogName {
		CohereEmbedV3English = "Cohere-embed-v3-english"
		CohereEmbedV3Multilingual = "Cohere-embed-v3-multilingual"
		FacebookDinoV2ImageEmbeddingsViTBase = "Facebook-DinoV2-Image-Embeddings-ViT-Base"
		FacebookDinoV2ImageEmbeddingsViTGiant = "Facebook-DinoV2-Image-Embeddings-ViT-Giant"
		OpenAIClipImageTextEmbeddingsVitBasePatch32 = "OpenAI-CLIP-Image-Text-Embeddings-vit-base-patch32"
		OpenAIClipImageTextEmbeddingsViTLargePatch14336 = "OpenAI-CLIP-Image-Text-Embeddings-ViT-Large-Patch14-336"
	}
	
	export enum KnownAnalyzerNames {
		ArLucene = "ar.lucene"
		ArMicrosoft = "ar.microsoft"
		BgLucene = "bg.lucene"
		BgMicrosoft = "bg.microsoft"
		BnMicrosoft = "bn.microsoft"
		CaLucene = "ca.lucene"
		CaMicrosoft = "ca.microsoft"
		CsLucene = "cs.lucene"
		CsMicrosoft = "cs.microsoft"
		DaLucene = "da.lucene"
		DaMicrosoft = "da.microsoft"
		DeLucene = "de.lucene"
		DeMicrosoft = "de.microsoft"
		ElLucene = "el.lucene"
		ElMicrosoft = "el.microsoft"
		EnLucene = "en.lucene"
		EnMicrosoft = "en.microsoft"
		EsLucene = "es.lucene"
		EsMicrosoft = "es.microsoft"
		EtMicrosoft = "et.microsoft"
		EuLucene = "eu.lucene"
		FaLucene = "fa.lucene"
		FiLucene = "fi.lucene"
		FiMicrosoft = "fi.microsoft"
		FrLucene = "fr.lucene"
		FrMicrosoft = "fr.microsoft"
		GaLucene = "ga.lucene"
		GlLucene = "gl.lucene"
		GuMicrosoft = "gu.microsoft"
		HeMicrosoft = "he.microsoft"
		HiLucene = "hi.lucene"
		HiMicrosoft = "hi.microsoft"
		HrMicrosoft = "hr.microsoft"
		HuLucene = "hu.lucene"
		HuMicrosoft = "hu.microsoft"
		HyLucene = "hy.lucene"
		IdLucene = "id.lucene"
		IdMicrosoft = "id.microsoft"
		IsMicrosoft = "is.microsoft"
		ItLucene = "it.lucene"
		ItMicrosoft = "it.microsoft"
		JaLucene = "ja.lucene"
		JaMicrosoft = "ja.microsoft"
		Keyword = "keyword"
		KnMicrosoft = "kn.microsoft"
		KoLucene = "ko.lucene"
		KoMicrosoft = "ko.microsoft"
		LtMicrosoft = "lt.microsoft"
		LvLucene = "lv.lucene"
		LvMicrosoft = "lv.microsoft"
		MlMicrosoft = "ml.microsoft"
		MrMicrosoft = "mr.microsoft"
		MsMicrosoft = "ms.microsoft"
		NbMicrosoft = "nb.microsoft"
		NlLucene = "nl.lucene"
		NlMicrosoft = "nl.microsoft"
		NoLucene = "no.lucene"
		PaMicrosoft = "pa.microsoft"
		Pattern = "pattern"
		PlLucene = "pl.lucene"
		PlMicrosoft = "pl.microsoft"
		PtBRLucene = "pt-BR.lucene"
		PtBRMicrosoft = "pt-BR.microsoft"
		PtPTLucene = "pt-PT.lucene"
		PtPTMicrosoft = "pt-PT.microsoft"
		RoLucene = "ro.lucene"
		RoMicrosoft = "ro.microsoft"
		RuLucene = "ru.lucene"
		RuMicrosoft = "ru.microsoft"
		Simple = "simple"
		SkMicrosoft = "sk.microsoft"
		SlMicrosoft = "sl.microsoft"
		SrCyrillicMicrosoft = "sr-cyrillic.microsoft"
		SrLatinMicrosoft = "sr-latin.microsoft"
		StandardAsciiFoldingLucene = "standardasciifolding.lucene"
		StandardLucene = "standard.lucene"
		Stop = "stop"
		SvLucene = "sv.lucene"
		SvMicrosoft = "sv.microsoft"
		TaMicrosoft = "ta.microsoft"
		TeMicrosoft = "te.microsoft"
		ThLucene = "th.lucene"
		ThMicrosoft = "th.microsoft"
		TrLucene = "tr.lucene"
		TrMicrosoft = "tr.microsoft"
		UkMicrosoft = "uk.microsoft"
		UrMicrosoft = "ur.microsoft"
		ViMicrosoft = "vi.microsoft"
		Whitespace = "whitespace"
		ZhHansLucene = "zh-Hans.lucene"
		ZhHansMicrosoft = "zh-Hans.microsoft"
		ZhHantLucene = "zh-Hant.lucene"
		ZhHantMicrosoft = "zh-Hant.microsoft"
	}
	
	export enum KnownAzureOpenAIModelName {
		TextEmbedding3Large = "text-embedding-3-large"
		TextEmbedding3Small = "text-embedding-3-small"
		TextEmbeddingAda002 = "text-embedding-ada-002"
	}
	
	export enum KnownBlobIndexerDataToExtract {
		AllMetadata = "allMetadata"
		ContentAndMetadata = "contentAndMetadata"
		StorageMetadata = "storageMetadata"
	}
	
	export enum KnownBlobIndexerImageAction {
		GenerateNormalizedImagePerPage = "generateNormalizedImagePerPage"
		GenerateNormalizedImages = "generateNormalizedImages"
		None = "none"
	}
	
	export enum KnownBlobIndexerParsingMode {
		Default = "default"
		DelimitedText = "delimitedText"
		Json = "json"
		JsonArray = "jsonArray"
		JsonLines = "jsonLines"
		Markdown = "markdown"
		Text = "text"
	}
	
	export enum KnownBlobIndexerPDFTextRotationAlgorithm {
		DetectAngles = "detectAngles"
		None = "none"
	}
	
	export enum KnownCharFilterNames {
		HtmlStrip = "html_strip"
	}
	
	export enum KnownCustomEntityLookupSkillLanguage {
		Da = "da"
		De = "de"
		En = "en"
		Es = "es"
		Fi = "fi"
		Fr = "fr"
		It = "it"
		Ko = "ko"
		Pt = "pt"
	}
	
	export enum KnownDocumentIntelligenceLayoutSkillMarkdownHeaderDepth {
		H1 = "h1"
		H2 = "h2"
		H3 = "h3"
		H4 = "h4"
		H5 = "h5"
		H6 = "h6"
	}
	
	export enum KnownDocumentIntelligenceLayoutSkillOutputMode {
		OneToMany = "oneToMany"
	}
	
	export enum KnownEntityCategory {
		Datetime = "datetime"
		Email = "email"
		Location = "location"
		Organization = "organization"
		Person = "person"
		Quantity = "quantity"
		Url = "url"
	}
	
	export enum KnownEntityRecognitionSkillLanguage {
		Ar = "ar"
		Cs = "cs"
		Da = "da"
		De = "de"
		El = "el"
		En = "en"
		Es = "es"
		Fi = "fi"
		Fr = "fr"
		Hu = "hu"
		It = "it"
		Ja = "ja"
		Ko = "ko"
		Nl = "nl"
		No = "no"
		Pl = "pl"
		PtBR = "pt-BR"
		PtPT = "pt-PT"
		Ru = "ru"
		Sv = "sv"
		Tr = "tr"
		ZhHans = "zh-Hans"
		ZhHant = "zh-Hant"
	}
	
	export enum KnownHybridCountAndFacetMode {
		CountAllResults = "countAllResults"
		CountRetrievableResults = "countRetrievableResults"
	}
	
	export enum KnownImageAnalysisSkillLanguage {
		Ar = "ar"
		Az = "az"
		Bg = "bg"
		Bs = "bs"
		Ca = "ca"
		Cs = "cs"
		Cy = "cy"
		Da = "da"
		De = "de"
		El = "el"
		En = "en"
		Es = "es"
		Et = "et"
		Eu = "eu"
		Fi = "fi"
		Fr = "fr"
		Ga = "ga"
		Gl = "gl"
		He = "he"
		Hi = "hi"
		Hr = "hr"
		Hu = "hu"
		Id = "id"
		It = "it"
		Ja = "ja"
		Kk = "kk"
		Ko = "ko"
		Lt = "lt"
		Lv = "lv"
		Mk = "mk"
		Ms = "ms"
		Nb = "nb"
		Nl = "nl"
		Pl = "pl"
		Prs = "prs"
		Pt = "pt"
		PtBR = "pt-BR"
		PtPT = "pt-PT"
		Ro = "ro"
		Ru = "ru"
		Sk = "sk"
		Sl = "sl"
		SrCyrl = "sr-Cyrl"
		SrLatn = "sr-Latn"
		Sv = "sv"
		Th = "th"
		Tr = "tr"
		Uk = "uk"
		Vi = "vi"
		Zh = "zh"
		ZhHans = "zh-Hans"
		ZhHant = "zh-Hant"
	}
	
	export enum KnownImageDetail {
		Celebrities = "celebrities"
		Landmarks = "landmarks"
	}
	
	export enum KnownIndexerExecutionEnvironment {
		Private = "private"
		Standard = "standard"
	}
	
	export enum KnownIndexerExecutionStatusDetail {
		ResetDocs = "resetDocs"
	}
	
	export enum KnownIndexingMode {
		IndexingAllDocs = "indexingAllDocs"
		IndexingResetDocs = "indexingResetDocs"
	}
	
	export enum KnownIndexProjectionMode {
		IncludeIndexingParentDocuments = "includeIndexingParentDocuments"
		SkipIndexingParentDocuments = "skipIndexingParentDocuments"
	}
	
	export enum KnownKeyPhraseExtractionSkillLanguage {
		Da = "da"
		De = "de"
		En = "en"
		Es = "es"
		Fi = "fi"
		Fr = "fr"
		It = "it"
		Ja = "ja"
		Ko = "ko"
		Nl = "nl"
		No = "no"
		Pl = "pl"
		PtBR = "pt-BR"
		PtPT = "pt-PT"
		Ru = "ru"
		Sv = "sv"
	}
	
	export enum KnownLexicalAnalyzerName {
		ArLucene = "ar.lucene"
		ArMicrosoft = "ar.microsoft"
		BgLucene = "bg.lucene"
		BgMicrosoft = "bg.microsoft"
		BnMicrosoft = "bn.microsoft"
		CaLucene = "ca.lucene"
		CaMicrosoft = "ca.microsoft"
		CsLucene = "cs.lucene"
		CsMicrosoft = "cs.microsoft"
		DaLucene = "da.lucene"
		DaMicrosoft = "da.microsoft"
		DeLucene = "de.lucene"
		DeMicrosoft = "de.microsoft"
		ElLucene = "el.lucene"
		ElMicrosoft = "el.microsoft"
		EnLucene = "en.lucene"
		EnMicrosoft = "en.microsoft"
		EsLucene = "es.lucene"
		EsMicrosoft = "es.microsoft"
		EtMicrosoft = "et.microsoft"
		EuLucene = "eu.lucene"
		FaLucene = "fa.lucene"
		FiLucene = "fi.lucene"
		FiMicrosoft = "fi.microsoft"
		FrLucene = "fr.lucene"
		FrMicrosoft = "fr.microsoft"
		GaLucene = "ga.lucene"
		GlLucene = "gl.lucene"
		GuMicrosoft = "gu.microsoft"
		HeMicrosoft = "he.microsoft"
		HiLucene = "hi.lucene"
		HiMicrosoft = "hi.microsoft"
		HrMicrosoft = "hr.microsoft"
		HuLucene = "hu.lucene"
		HuMicrosoft = "hu.microsoft"
		HyLucene = "hy.lucene"
		IdLucene = "id.lucene"
		IdMicrosoft = "id.microsoft"
		IsMicrosoft = "is.microsoft"
		ItLucene = "it.lucene"
		ItMicrosoft = "it.microsoft"
		JaLucene = "ja.lucene"
		JaMicrosoft = "ja.microsoft"
		Keyword = "keyword"
		KnMicrosoft = "kn.microsoft"
		KoLucene = "ko.lucene"
		KoMicrosoft = "ko.microsoft"
		LtMicrosoft = "lt.microsoft"
		LvLucene = "lv.lucene"
		LvMicrosoft = "lv.microsoft"
		MlMicrosoft = "ml.microsoft"
		MrMicrosoft = "mr.microsoft"
		MsMicrosoft = "ms.microsoft"
		NbMicrosoft = "nb.microsoft"
		NlLucene = "nl.lucene"
		NlMicrosoft = "nl.microsoft"
		NoLucene = "no.lucene"
		PaMicrosoft = "pa.microsoft"
		Pattern = "pattern"
		PlLucene = "pl.lucene"
		PlMicrosoft = "pl.microsoft"
		PtBrLucene = "pt-BR.lucene"
		PtBrMicrosoft = "pt-BR.microsoft"
		PtPtLucene = "pt-PT.lucene"
		PtPtMicrosoft = "pt-PT.microsoft"
		RoLucene = "ro.lucene"
		RoMicrosoft = "ro.microsoft"
		RuLucene = "ru.lucene"
		RuMicrosoft = "ru.microsoft"
		Simple = "simple"
		SkMicrosoft = "sk.microsoft"
		SlMicrosoft = "sl.microsoft"
		SrCyrillicMicrosoft = "sr-cyrillic.microsoft"
		SrLatinMicrosoft = "sr-latin.microsoft"
		StandardAsciiFoldingLucene = "standardasciifolding.lucene"
		StandardLucene = "standard.lucene"
		Stop = "stop"
		SvLucene = "sv.lucene"
		SvMicrosoft = "sv.microsoft"
		TaMicrosoft = "ta.microsoft"
		TeMicrosoft = "te.microsoft"
		ThLucene = "th.lucene"
		ThMicrosoft = "th.microsoft"
		TrLucene = "tr.lucene"
		TrMicrosoft = "tr.microsoft"
		UkMicrosoft = "uk.microsoft"
		UrMicrosoft = "ur.microsoft"
		ViMicrosoft = "vi.microsoft"
		Whitespace = "whitespace"
		ZhHansLucene = "zh-Hans.lucene"
		ZhHansMicrosoft = "zh-Hans.microsoft"
		ZhHantLucene = "zh-Hant.lucene"
		ZhHantMicrosoft = "zh-Hant.microsoft"
	}
	
	export enum KnownLexicalNormalizerName {
		AsciiFolding = "asciifolding"
		Elision = "elision"
		Lowercase = "lowercase"
		Standard = "standard"
		Uppercase = "uppercase"
	}
	
	export enum KnownMarkdownHeaderDepth {
		H1 = "h1"
		H2 = "h2"
		H3 = "h3"
		H4 = "h4"
		H5 = "h5"
		H6 = "h6"
	}
	
	export enum KnownMarkdownParsingSubmode {
		OneToMany = "oneToMany"
		OneToOne = "oneToOne"
	}
	
	export enum KnownOcrLineEnding {
		CarriageReturn = "carriageReturn"
		CarriageReturnLineFeed = "carriageReturnLineFeed"
		LineFeed = "lineFeed"
		Space = "space"
	}
	
	export enum KnownOcrSkillLanguage {
		Af = "af"
		Anp = "anp"
		Ar = "ar"
		Ast = "ast"
		Awa = "awa"
		Az = "az"
		Be = "be"
		BeCyrl = "be-cyrl"
		BeLatn = "be-latn"
		Bfy = "bfy"
		Bfz = "bfz"
		Bg = "bg"
		Bgc = "bgc"
		Bho = "bho"
		Bi = "bi"
		Bns = "bns"
		Br = "br"
		Bra = "bra"
		Brx = "brx"
		Bs = "bs"
		Bua = "bua"
		Ca = "ca"
		Ceb = "ceb"
		Ch = "ch"
		CnrCyrl = "cnr-cyrl"
		CnrLatn = "cnr-latn"
		Co = "co"
		Crh = "crh"
		Cs = "cs"
		Csb = "csb"
		Cy = "cy"
		Da = "da"
		De = "de"
		Dhi = "dhi"
		Doi = "doi"
		Dsb = "dsb"
		El = "el"
		En = "en"
		Es = "es"
		Et = "et"
		Eu = "eu"
		Fa = "fa"
		Fi = "fi"
		Fil = "fil"
		Fj = "fj"
		Fo = "fo"
		Fr = "fr"
		Fur = "fur"
		Fy = "fy"
		Ga = "ga"
		Gag = "gag"
		Gd = "gd"
		Gil = "gil"
		Gl = "gl"
		Gon = "gon"
		Gv = "gv"
		Gvr = "gvr"
		Haw = "haw"
		Hi = "hi"
		Hlb = "hlb"
		Hne = "hne"
		Hni = "hni"
		Hoc = "hoc"
		Hr = "hr"
		Hsb = "hsb"
		Ht = "ht"
		Hu = "hu"
		Ia = "ia"
		Id = "id"
		Is = "is"
		It = "it"
		Iu = "iu"
		Ja = "ja"
		Jns = "Jns"
		Jv = "jv"
		Kaa = "kaa"
		KaaCyrl = "kaa-cyrl"
		Kac = "kac"
		Kea = "kea"
		Kfq = "kfq"
		Kha = "kha"
		KkCyrl = "kk-cyrl"
		KkLatn = "kk-latn"
		Kl = "kl"
		Klr = "klr"
		Kmj = "kmj"
		Ko = "ko"
		Kos = "kos"
		Kpy = "kpy"
		Krc = "krc"
		Kru = "kru"
		Ksh = "ksh"
		KuArab = "ku-arab"
		KuLatn = "ku-latn"
		Kum = "kum"
		Kw = "kw"
		Ky = "ky"
		La = "la"
		Lb = "lb"
		Lkt = "lkt"
		Lt = "lt"
		Mi = "mi"
		Mn = "mn"
		Mr = "mr"
		Ms = "ms"
		Mt = "mt"
		Mww = "mww"
		Myv = "myv"
		Nap = "nap"
		Nb = "nb"
		Ne = "ne"
		Niu = "niu"
		Nl = "nl"
		No = "no"
		Nog = "nog"
		Oc = "oc"
		Os = "os"
		Pa = "pa"
		Pl = "pl"
		Prs = "prs"
		Ps = "ps"
		Pt = "pt"
		Quc = "quc"
		Rab = "rab"
		Rm = "rm"
		Ro = "ro"
		Ru = "ru"
		Sa = "sa"
		Sat = "sat"
		Sck = "sck"
		Sco = "sco"
		Sk = "sk"
		Sl = "sl"
		Sm = "sm"
		Sma = "sma"
		Sme = "sme"
		Smj = "smj"
		Smn = "smn"
		Sms = "sms"
		So = "so"
		Sq = "sq"
		Sr = "sr"
		SrCyrl = "sr-Cyrl"
		SrLatn = "sr-Latn"
		Srx = "srx"
		Sv = "sv"
		Sw = "sw"
		Tet = "tet"
		Tg = "tg"
		Thf = "thf"
		Tk = "tk"
		To = "to"
		Tr = "tr"
		Tt = "tt"
		Tyv = "tyv"
		Ug = "ug"
		Unk = "unk"
		Ur = "ur"
		Uz = "uz"
		UzArab = "uz-arab"
		UzCyrl = "uz-cyrl"
		Vo = "vo"
		Wae = "wae"
		Xnr = "xnr"
		Xsr = "xsr"
		Yua = "yua"
		Za = "za"
		ZhHans = "zh-Hans"
		ZhHant = "zh-Hant"
		Zu = "zu"
	}
	
	export enum KnownPIIDetectionSkillMaskingMode {
		None = "none"
		Replace = "replace"
	}
	
	export enum KnownQueryDebugMode {
		All = "all"
		Disabled = "disabled"
		QueryRewrites = "queryRewrites"
		Semantic = "semantic"
		Vector = "vector"
	}
	
	export enum KnownQueryLanguage {
		ArEg = "ar-eg"
		ArJo = "ar-jo"
		ArKw = "ar-kw"
		ArMa = "ar-ma"
		ArSa = "ar-sa"
		BgBg = "bg-bg"
		BnIn = "bn-in"
		CaEs = "ca-es"
		CsCz = "cs-cz"
		DaDk = "da-dk"
		DeDe = "de-de"
		ElGr = "el-gr"
		EnAu = "en-au"
		EnCa = "en-ca"
		EnGb = "en-gb"
		EnIn = "en-in"
		EnUs = "en-us"
		EsEs = "es-es"
		EsMx = "es-mx"
		EtEe = "et-ee"
		EuEs = "eu-es"
		FaAe = "fa-ae"
		FiFi = "fi-fi"
		FrCa = "fr-ca"
		FrFr = "fr-fr"
		GaIe = "ga-ie"
		GlEs = "gl-es"
		GuIn = "gu-in"
		HeIl = "he-il"
		HiIn = "hi-in"
		HrBa = "hr-ba"
		HrHr = "hr-hr"
		HuHu = "hu-hu"
		HyAm = "hy-am"
		IdId = "id-id"
		IsIs = "is-is"
		ItIt = "it-it"
		JaJp = "ja-jp"
		KnIn = "kn-in"
		KoKr = "ko-kr"
		LtLt = "lt-lt"
		LvLv = "lv-lv"
		MlIn = "ml-in"
		MrIn = "mr-in"
		MsBn = "ms-bn"
		MsMy = "ms-my"
		NbNo = "nb-no"
		NlBe = "nl-be"
		NlNl = "nl-nl"
		None = "none"
		NoNo = "no-no"
		PaIn = "pa-in"
		PlPl = "pl-pl"
		PtBr = "pt-br"
		PtPt = "pt-pt"
		RoRo = "ro-ro"
		RuRu = "ru-ru"
		SkSk = "sk-sk"
		SlSl = "sl-sl"
		SrBa = "sr-ba"
		SrMe = "sr-me"
		SrRs = "sr-rs"
		SvSe = "sv-se"
		TaIn = "ta-in"
		TeIn = "te-in"
		ThTh = "th-th"
		TrTr = "tr-tr"
		UkUa = "uk-ua"
		UrPk = "ur-pk"
		ViVn = "vi-vn"
		ZhCn = "zh-cn"
		ZhTw = "zh-tw"
	}
	
	export enum KnownQuerySpeller {
		Lexicon = "lexicon"
		None = "none"
	}
	
	export enum KnownRegexFlags {
		CanonEq = "CANON_EQ"
		CaseInsensitive = "CASE_INSENSITIVE"
		Comments = "COMMENTS"
		DotAll = "DOTALL"
		Literal = "LITERAL"
		Multiline = "MULTILINE"
		UnicodeCase = "UNICODE_CASE"
		UnixLines = "UNIX_LINES"
	}
	
	export enum KnownSearchAudience {
		AzureChina = "https://search.azure.cn"
		AzureGovernment = "https://search.azure.us"
		AzurePublicCloud = "https://search.azure.com"
	}
	
	export enum KnownSearchFieldDataType {
		Boolean = "Edm.Boolean"
		Byte = "Edm.Byte"
		Complex = "Edm.ComplexType"
		DateTimeOffset = "Edm.DateTimeOffset"
		Double = "Edm.Double"
		GeographyPoint = "Edm.GeographyPoint"
		Half = "Edm.Half"
		Int16 = "Edm.Int16"
		Int32 = "Edm.Int32"
		Int64 = "Edm.Int64"
		SByte = "Edm.SByte"
		Single = "Edm.Single"
		String = "Edm.String"
	}
	
	export enum KnownSearchIndexerDataSourceType {
		AdlsGen2 = "adlsgen2"
		AzureBlob = "azureblob"
		AzureSql = "azuresql"
		AzureTable = "azuretable"
		CosmosDb = "cosmosdb"
		MySql = "mysql"
		OneLake = "onelake"
	}
	
	export enum KnownSemanticErrorMode {
		Fail = "fail"
		Partial = "partial"
	}
	
	export enum KnownSemanticErrorReason {
		CapacityOverloaded = "capacityOverloaded"
		MaxWaitExceeded = "maxWaitExceeded"
		Transient = "transient"
	}
	
	export enum KnownSemanticFieldState {
		Partial = "partial"
		Unused = "unused"
		Used = "used"
	}
	
	export enum KnownSemanticQueryRewritesResultType {
		OriginalQueryOnly = "originalQueryOnly"
	}
	
	export enum KnownSemanticSearchResultsType {
		BaseResults = "baseResults"
		RerankedResults = "rerankedResults"
	}
	
	export enum KnownSentimentSkillLanguage {
		Da = "da"
		De = "de"
		El = "el"
		En = "en"
		Es = "es"
		Fi = "fi"
		Fr = "fr"
		It = "it"
		Nl = "nl"
		No = "no"
		Pl = "pl"
		PtPT = "pt-PT"
		Ru = "ru"
		Sv = "sv"
		Tr = "tr"
	}
	
	export enum KnownSplitSkillEncoderModelName {
		CL100KBase = "cl100k_base"
		P50KBase = "p50k_base"
		P50KEdit = "p50k_edit"
		R50KBase = "r50k_base"
	}
	
	export enum KnownSplitSkillLanguage {
		Am = "am"
		Bs = "bs"
		Cs = "cs"
		Da = "da"
		De = "de"
		En = "en"
		Es = "es"
		Et = "et"
		Fi = "fi"
		Fr = "fr"
		He = "he"
		Hi = "hi"
		Hr = "hr"
		Hu = "hu"
		Id = "id"
		Is = "is"
		It = "it"
		Ja = "ja"
		Ko = "ko"
		Lv = "lv"
		Nb = "nb"
		Nl = "nl"
		Pl = "pl"
		Pt = "pt"
		PtBr = "pt-br"
		Ru = "ru"
		Sk = "sk"
		Sl = "sl"
		Sr = "sr"
		Sv = "sv"
		Tr = "tr"
		Ur = "ur"
		Zh = "zh"
	}
	
	export enum KnownSplitSkillUnit {
		AzureOpenAITokens = "azureOpenAITokens"
		Characters = "characters"
	}
	
	export enum KnownTextSplitMode {
		Pages = "pages"
		Sentences = "sentences"
	}
	
	export enum KnownTextTranslationSkillLanguage {
		Af = "af"
		Ar = "ar"
		Bg = "bg"
		Bn = "bn"
		Bs = "bs"
		Ca = "ca"
		Cs = "cs"
		Cy = "cy"
		Da = "da"
		De = "de"
		El = "el"
		En = "en"
		Es = "es"
		Et = "et"
		Fa = "fa"
		Fi = "fi"
		Fil = "fil"
		Fj = "fj"
		Fr = "fr"
		Ga = "ga"
		He = "he"
		Hi = "hi"
		Hr = "hr"
		Ht = "ht"
		Hu = "hu"
		Id = "id"
		Is = "is"
		It = "it"
		Ja = "ja"
		Kn = "kn"
		Ko = "ko"
		Lt = "lt"
		Lv = "lv"
		Mg = "mg"
		Mi = "mi"
		Ml = "ml"
		Ms = "ms"
		Mt = "mt"
		Mww = "mww"
		Nb = "nb"
		Nl = "nl"
		Otq = "otq"
		Pa = "pa"
		Pl = "pl"
		Pt = "pt"
		PtBr = "pt-br"
		PtPT = "pt-PT"
		Ro = "ro"
		Ru = "ru"
		Sk = "sk"
		Sl = "sl"
		Sm = "sm"
		SrCyrl = "sr-Cyrl"
		SrLatn = "sr-Latn"
		Sv = "sv"
		Sw = "sw"
		Ta = "ta"
		Te = "te"
		Th = "th"
		Tlh = "tlh"
		TlhLatn = "tlh-Latn"
		TlhPiqd = "tlh-Piqd"
		To = "to"
		Tr = "tr"
		Ty = "ty"
		Uk = "uk"
		Ur = "ur"
		Vi = "vi"
		Yua = "yua"
		Yue = "yue"
		ZhHans = "zh-Hans"
		ZhHant = "zh-Hant"
	}
	
	export enum KnownTokenFilterNames {
		Apostrophe = "apostrophe"
		ArabicNormalization = "arabic_normalization"
		AsciiFolding = "asciifolding"
		CjkBigram = "cjk_bigram"
		CjkWidth = "cjk_width"
		Classic = "classic"
		CommonGram = "common_grams"
		EdgeNGram = "edgeNGram_v2"
		Elision = "elision"
		GermanNormalization = "german_normalization"
		HindiNormalization = "hindi_normalization"
		IndicNormalization = "indic_normalization"
		KeywordRepeat = "keyword_repeat"
		KStem = "kstem"
		Length = "length"
		Limit = "limit"
		Lowercase = "lowercase"
		NGram = "nGram_v2"
		PersianNormalization = "persian_normalization"
		Phonetic = "phonetic"
		PorterStem = "porter_stem"
		Reverse = "reverse"
		ScandinavianFoldingNormalization = "scandinavian_folding"
		ScandinavianNormalization = "scandinavian_normalization"
		Shingle = "shingle"
		Snowball = "snowball"
		SoraniNormalization = "sorani_normalization"
		Stemmer = "stemmer"
		Stopwords = "stopwords"
		Trim = "trim"
		Truncate = "truncate"
		Unique = "unique"
		Uppercase = "uppercase"
		WordDelimiter = "word_delimiter"
	}
	
	export enum KnownTokenizerNames {
		Classic = "classic"
		EdgeNGram = "edgeNGram"
		Keyword = "keyword_v2"
		Letter = "letter"
		Lowercase = "lowercase"
		MicrosoftLanguageStemmingTokenizer = "microsoft_language_stemming_tokenizer"
		MicrosoftLanguageTokenizer = "microsoft_language_tokenizer"
		NGram = "nGram"
		PathHierarchy = "path_hierarchy_v2"
		Pattern = "pattern"
		Standard = "standard_v2"
		UaxUrlEmail = "uax_url_email"
		Whitespace = "whitespace"
	}
	
	export enum KnownVectorEncodingFormat {
		PackedBit = "packedBit"
	}
	
	export enum KnownVectorFilterMode {
		PostFilter = "postFilter"
		PreFilter = "preFilter"
	}
	
	export enum KnownVectorQueryKind {
		ImageBinary = "imageBinary"
		ImageUrl = "imageUrl"
		Text = "text"
		Vector = "vector"
	}
	
	export enum KnownVectorSearchAlgorithmKind {
		ExhaustiveKnn = "exhaustiveKnn"
		Hnsw = "hnsw"
	}
	
	export enum KnownVectorSearchAlgorithmMetric {
		Cosine = "cosine"
		DotProduct = "dotProduct"
		Euclidean = "euclidean"
		Hamming = "hamming"
	}
	
	export enum KnownVectorSearchCompressionKind {
		BinaryQuantization = "binaryQuantization"
		ScalarQuantization = "scalarQuantization"
	}
	
	export enum KnownVectorSearchCompressionRescoreStorageMethod {
		DiscardOriginals = "discardOriginals"
		PreserveOriginals = "preserveOriginals"
	}
	
	export enum KnownVectorSearchCompressionTarget {
		Int8 = "int8"
	}
	
	export enum KnownVectorSearchVectorizerKind {
		AIServicesVision = "aiServicesVision"
		AML = "aml"
		AzureOpenAI = "azureOpenAI"
		CustomWebApi = "customWebApi"
	}
	
	export enum KnownVectorThresholdKind {
		SearchScore = "searchScore"
		VectorSimilarity = "vectorSimilarity"
	}
	
	export enum KnownVisualFeature {
		Adult = "adult"
		Brands = "brands"
		Categories = "categories"
		Description = "description"
		Faces = "faces"
		Objects = "objects"
		Tags = "tags"
	}
	
	export interface AIServicesAccountIdentity extends BaseCognitiveServicesAccount {
		identity?: SearchIndexerDataIdentity;
		odatatype: "#Microsoft.Azure.Search.AIServicesByIdentity";
		subdomainUrl: string;
	}
	
	export interface AIServicesAccountKey extends CognitiveServicesAccount {
		key: string;
		odatatype: "#Microsoft.Azure.Search.AIServicesByKey";
		subdomainUrl: string;
	}
	
	export interface AIServicesVisionParameters {
		apiKey?: string;
		authIdentity?: SearchIndexerDataIdentity;
		modelVersion?: string;
		resourceUri: string;
	}
	
	export interface AIServicesVisionVectorizer extends BaseVectorSearchVectorizer {
		kind: "aiServicesVision";
		parameters?: AIServicesVisionParameters;
	}
	
	export interface AnalyzedTokenInfo {
		readonly endOffset: number;
		readonly position: number;
		readonly startOffset: number;
		readonly token: string;
	}
	
	export interface AnalyzeRequest {
		analyzerName?: LexicalAnalyzerName;
		charFilters?: CharFilterName[];
		normalizerName?: LexicalNormalizerName;
		text: string;
		tokenFilters?: TokenFilterName[];
		tokenizerName?: LexicalTokenizerName;
	}
	
	export interface AnalyzeResult {
		tokens: AnalyzedTokenInfo[];
	}
	
	export interface AsciiFoldingTokenFilter extends TokenFilter {
		odatatype: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter";
		preserveOriginal?: boolean;
	}
	
	export interface AutocompleteItem {
		readonly queryPlusText: string;
		readonly text: string;
	}
	
	export interface AutocompleteRequest<TModel extends object> {
		autocompleteMode?: AutocompleteMode;
		filter?: string;
		highlightPostTag?: string;
		highlightPreTag?: string;
		minimumCoverage?: number;
		searchFields?: SearchFieldArray<TModel>;
		top?: number;
		useFuzzyMatching?: boolean;
	}
	
	export interface AutocompleteResult {
		readonly coverage?: number;
		readonly results: AutocompleteItem[];
	}
	
	export interface AzureActiveDirectoryApplicationCredentials {
		applicationId: string;
		applicationSecret?: string;
	}
	
	export interface AzureMachineLearningSkill extends SearchIndexerSkill {
		authenticationKey?: string;
		degreeOfParallelism?: number;
		odatatype: "#Microsoft.Skills.Custom.AmlSkill";
		region?: string;
		resourceId?: string;
		scoringUri?: string;
		timeout?: string;
	}
	
	export interface AzureMachineLearningVectorizer extends BaseVectorSearchVectorizer {
		amlParameters?: AzureMachineLearningVectorizerParameters;
		kind: "aml";
	}
	
	export interface AzureOpenAIEmbeddingSkill extends BaseSearchIndexerSkill, AzureOpenAIParameters {
		dimensions?: number;
		odatatype: "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill";
	}
	
	export interface AzureOpenAIParameters {
		apiKey?: string;
		authIdentity?: SearchIndexerDataIdentity;
		deploymentId?: string;
		modelName?: AzureOpenAIModelName;
		resourceUrl?: string;
	}
	
	export interface AzureOpenAITokenizerParameters {
		allowedSpecialTokens?: string[];
		encoderModelName?: SplitSkillEncoderModelName;
	}
	
	export interface AzureOpenAIVectorizer extends BaseVectorSearchVectorizer {
		kind: "azureOpenAI";
		parameters?: AzureOpenAIParameters;
	}
	
	export interface BaseAzureMachineLearningVectorizerParameters {
		modelName?: AIStudioModelCatalogName;
		timeout?: string;
	}
	
	export interface CharFilter {
		name: string;
		odatatype: "#Microsoft.Azure.Search.MappingCharFilter" | "#Microsoft.Azure.Search.PatternReplaceCharFilter";
	}
	
	export interface CognitiveServicesAccount {
		description?: string;
		odatatype: "#Microsoft.Azure.Search.DefaultCognitiveServices" | "#Microsoft.Azure.Search.CognitiveServicesByKey" | "#Microsoft.Azure.Search.AIServicesByKey" | "#Microsoft.Azure.Search.AIServicesByIdentity";
	}
	
	export interface DataChangeDetectionPolicy {
		odatatype: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy" | "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
	}
	
	export interface DataDeletionDetectionPolicy {
		odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy" | "#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy";
	}
	
	export interface LexicalAnalyzer {
		name: string;
		odatatype: "#Microsoft.Azure.Search.CustomAnalyzer" | "#Microsoft.Azure.Search.PatternAnalyzer" | "#Microsoft.Azure.Search.StandardAnalyzer" | "#Microsoft.Azure.Search.StopAnalyzer";
	}
	
	export interface LexicalNormalizer {
		name: string;
		odatatype: "#Microsoft.Azure.Search.CustomNormalizer";
	}
	
	export interface LexicalTokenizer {
		name: string;
		odatatype: "#Microsoft.Azure.Search.ClassicTokenizer" | "#Microsoft.Azure.Search.EdgeNGramTokenizer" | "#Microsoft.Azure.Search.KeywordTokenizer" | "#Microsoft.Azure.Search.KeywordTokenizerV2" | "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer" | "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer" | "#Microsoft.Azure.Search.NGramTokenizer" | "#Microsoft.Azure.Search.PathHierarchyTokenizerV2" | "#Microsoft.Azure.Search.PatternTokenizer" | "#Microsoft.Azure.Search.StandardTokenizer" | "#Microsoft.Azure.Search.StandardTokenizerV2" | "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
	}
	
	export interface ScoringFunction {
		boost: number;
		fieldName: string;
		interpolation?: ScoringFunctionInterpolation;
		type: "distance" | "freshness" | "magnitude" | "tag";
	}
	
	export interface SearchIndexerDataIdentity {
		odatatype: "#Microsoft.Azure.Search.DataNoneIdentity" | "#Microsoft.Azure.Search.DataUserAssignedIdentity";
	}
	
	export interface SearchIndexerSkill {
		context?: string;
		description?: string;
		inputs: InputFieldMappingEntry[];
		name?: string;
		odatatype: "#Microsoft.Skills.Util.ConditionalSkill" | "#Microsoft.Skills.Text.KeyPhraseExtractionSkill" | "#Microsoft.Skills.Vision.OcrSkill" | "#Microsoft.Skills.Vision.ImageAnalysisSkill" | "#Microsoft.Skills.Text.LanguageDetectionSkill" | "#Microsoft.Skills.Util.ShaperSkill" | "#Microsoft.Skills.Text.MergeSkill" | "#Microsoft.Skills.Text.EntityRecognitionSkill" | "#Microsoft.Skills.Text.SentimentSkill" | "#Microsoft.Skills.Text.V3.SentimentSkill" | "#Microsoft.Skills.Text.V3.EntityLinkingSkill" | "#Microsoft.Skills.Text.V3.EntityRecognitionSkill" | "#Microsoft.Skills.Text.PIIDetectionSkill" | "#Microsoft.Skills.Text.SplitSkill" | "#Microsoft.Skills.Text.CustomEntityLookupSkill" | "#Microsoft.Skills.Text.TranslationSkill" | "#Microsoft.Skills.Util.DocumentExtractionSkill" | "#Microsoft.Skills.Util.DocumentIntelligenceLayoutSkill" | "#Microsoft.Skills.Custom.WebApiSkill" | "#Microsoft.Skills.Custom.AmlSkill" | "#Microsoft.Skills.Text.AzureOpenAIEmbeddingSkill" | "#Microsoft.Skills.Vision.VectorizeSkill";
		outputs: OutputFieldMappingEntry[];
	}
	
	export interface BaseSearchRequestOptions<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> {
		facets?: string[];
		filter?: string;
		highlightFields?: string;
		highlightPostTag?: string;
		highlightPreTag?: string;
		hybridSearch?: HybridSearch;
		includeTotalCount?: boolean;
		minimumCoverage?: number;
		orderBy?: string[];
		queryLanguage?: QueryLanguage;
		queryType?: QueryType;
		scoringParameters?: string[];
		scoringProfile?: string;
		scoringStatistics?: ScoringStatistics;
		searchFields?: SearchFieldArray<TModel>;
		searchMode?: SearchMode;
		select?: SelectArray<TFields>;
		sessionId?: string;
		skip?: number;
		speller?: QuerySpeller;
		top?: number;
		vectorSearchOptions?: VectorSearchOptions<TModel>;
	}
	
	export interface TokenFilter {
		name: string;
		odatatype: "#Microsoft.Azure.Search.AsciiFoldingTokenFilter" | "#Microsoft.Azure.Search.CjkBigramTokenFilter" | "#Microsoft.Azure.Search.CommonGramTokenFilter" | "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter" | "#Microsoft.Azure.Search.EdgeNGramTokenFilter" | "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2" | "#Microsoft.Azure.Search.ElisionTokenFilter" | "#Microsoft.Azure.Search.KeepTokenFilter" | "#Microsoft.Azure.Search.KeywordMarkerTokenFilter" | "#Microsoft.Azure.Search.LengthTokenFilter" | "#Microsoft.Azure.Search.LimitTokenFilter" | "#Microsoft.Azure.Search.NGramTokenFilter" | "#Microsoft.Azure.Search.NGramTokenFilterV2" | "#Microsoft.Azure.Search.PatternCaptureTokenFilter" | "#Microsoft.Azure.Search.PatternReplaceTokenFilter" | "#Microsoft.Azure.Search.PhoneticTokenFilter" | "#Microsoft.Azure.Search.ShingleTokenFilter" | "#Microsoft.Azure.Search.SnowballTokenFilter" | "#Microsoft.Azure.Search.StemmerTokenFilter" | "#Microsoft.Azure.Search.StemmerOverrideTokenFilter" | "#Microsoft.Azure.Search.StopwordsTokenFilter" | "#Microsoft.Azure.Search.SynonymTokenFilter" | "#Microsoft.Azure.Search.TruncateTokenFilter" | "#Microsoft.Azure.Search.UniqueTokenFilter" | "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
	}
	
	export interface BaseVectorQuery<TModel extends object> {
		exhaustive?: boolean;
		fields?: SearchFieldArray<TModel>;
		filterOverride?: string;
		kind: VectorQueryKind;
		kNearestNeighborsCount?: number;
		oversampling?: number;
		threshold?: VectorThreshold;
		weight?: number;
	}
	
	export interface BaseVectorSearchAlgorithmConfiguration {
		kind: VectorSearchAlgorithmKind;
		name: string;
	}
	
	export interface VectorSearchCompression {
		compressionName: string;
		defaultOversampling?: number;
		kind: "scalarQuantization" | "binaryQuantization";
		rerankWithOriginalVectors?: boolean;
		rescoringOptions?: RescoringOptions;
		truncationDimension?: number;
	}
	
	export interface BaseVectorSearchVectorizer {
		kind: VectorSearchVectorizerKind;
		vectorizerName: string;
	}
	
	export interface BaseVectorThreshold {
		kind: "vectorSimilarity" | "searchScore";
	}
	
	export interface BinaryQuantizationCompression extends VectorSearchCompression {
		kind: "binaryQuantization";
	}
	
	export interface BM25Similarity extends Similarity {
		b?: number;
		k1?: number;
		odatatype: "#Microsoft.Azure.Search.BM25Similarity";
	}
	
	export interface CjkBigramTokenFilter extends TokenFilter {
		ignoreScripts?: CjkBigramTokenFilterScripts[];
		odatatype: "#Microsoft.Azure.Search.CjkBigramTokenFilter";
		outputUnigrams?: boolean;
	}
	
	export interface ClassicSimilarity extends Similarity {
		odatatype: "#Microsoft.Azure.Search.ClassicSimilarity";
	}
	
	export interface ClassicTokenizer extends LexicalTokenizer {
		maxTokenLength?: number;
		odatatype: "#Microsoft.Azure.Search.ClassicTokenizer";
	}
	
	export interface CognitiveServicesAccountKey extends CognitiveServicesAccount {
		key: string;
		odatatype: "#Microsoft.Azure.Search.CognitiveServicesByKey";
	}
	
	export interface CommonGramTokenFilter extends TokenFilter {
		commonWords: string[];
		ignoreCase?: boolean;
		odatatype: "#Microsoft.Azure.Search.CommonGramTokenFilter";
		useQueryMode?: boolean;
	}
	
	export interface ComplexField {
		fields?: SearchField[];
		name: string;
		type: ComplexDataType;
	}
	
	export interface ConditionalSkill extends SearchIndexerSkill {
		odatatype: "#Microsoft.Skills.Util.ConditionalSkill";
	}
	
	export interface CorsOptions {
		allowedOrigins: string[];
		maxAgeInSeconds?: number;
	}
	
	export interface CreateOrUpdateAliasOptions extends OperationOptions {
		onlyIfUnchanged?: boolean;
	}
	
	export interface CreateorUpdateDataSourceConnectionOptions extends OperationOptions {
		onlyIfUnchanged?: boolean;
		skipIndexerResetRequirementForCache?: boolean;
	}
	
	export interface CreateorUpdateIndexerOptions extends OperationOptions {
		disableCacheReprocessingChangeDetection?: boolean;
		onlyIfUnchanged?: boolean;
		skipIndexerResetRequirementForCache?: boolean;
	}
	
	export interface CreateOrUpdateIndexOptions extends OperationOptions {
		allowIndexDowntime?: boolean;
		onlyIfUnchanged?: boolean;
	}
	
	export interface CreateOrUpdateSkillsetOptions extends OperationOptions {
		disableCacheReprocessingChangeDetection?: boolean;
		onlyIfUnchanged?: boolean;
		skipIndexerResetRequirementForCache?: boolean;
	}
	
	export interface CreateOrUpdateSynonymMapOptions extends OperationOptions {
		onlyIfUnchanged?: boolean;
	}
	
	export interface CustomAnalyzer {
		charFilters?: CharFilterName[];
		name: string;
		odatatype: "#Microsoft.Azure.Search.CustomAnalyzer";
		tokenFilters?: TokenFilterName[];
		tokenizerName: LexicalTokenizerName;
	}
	
	export interface CustomEntity {
		accentSensitive?: boolean;
		aliases?: CustomEntityAlias[];
		caseSensitive?: boolean;
		defaultAccentSensitive?: boolean;
		defaultCaseSensitive?: boolean;
		defaultFuzzyEditDistance?: number;
		description?: string;
		fuzzyEditDistance?: number;
		id?: string;
		name: string;
		subtype?: string;
		type?: string;
	}
	
	export interface CustomEntityAlias {
		accentSensitive?: boolean;
		caseSensitive?: boolean;
		fuzzyEditDistance?: number;
		text: string;
	}
	
	export interface CustomEntityLookupSkill extends BaseSearchIndexerSkill {
		defaultLanguageCode?: CustomEntityLookupSkillLanguage;
		entitiesDefinitionUri?: string;
		globalDefaultAccentSensitive?: boolean;
		globalDefaultCaseSensitive?: boolean;
		globalDefaultFuzzyEditDistance?: number;
		inlineEntitiesDefinition?: CustomEntity[];
		odatatype: "#Microsoft.Skills.Text.CustomEntityLookupSkill";
	}
	
	export interface CustomNormalizer extends LexicalNormalizer {
		charFilters?: CharFilterName[];
		odatatype: "#Microsoft.Azure.Search.CustomNormalizer";
		tokenFilters?: TokenFilterName[];
	}
	
	export interface DebugInfo {
		readonly queryRewrites?: QueryRewritesDebugInfo;
	}
	
	export interface DefaultCognitiveServicesAccount extends CognitiveServicesAccount {
		odatatype: "#Microsoft.Azure.Search.DefaultCognitiveServices";
	}
	
	export interface DeleteAliasOptions extends OperationOptions {
		onlyIfUnchanged?: boolean;
	}
	
	export interface DeleteDataSourceConnectionOptions extends OperationOptions {
		onlyIfUnchanged?: boolean;
	}
	
	export interface DeleteIndexerOptions extends OperationOptions {
		onlyIfUnchanged?: boolean;
	}
	
	export interface DeleteIndexOptions extends OperationOptions {
		onlyIfUnchanged?: boolean;
	}
	
	export interface DeleteSkillsetOptions extends OperationOptions {
		onlyIfUnchanged?: boolean;
	}
	
	export interface DeleteSynonymMapOptions extends OperationOptions {
		onlyIfUnchanged?: boolean;
	}
	
	export interface DictionaryDecompounderTokenFilter extends TokenFilter {
		maxSubwordSize?: number;
		minSubwordSize?: number;
		minWordSize?: number;
		odatatype: "#Microsoft.Azure.Search.DictionaryDecompounderTokenFilter";
		onlyLongestMatch?: boolean;
		wordList: string[];
	}
	
	export interface DistanceScoringFunction extends ScoringFunction {
		parameters: DistanceScoringParameters;
		type: "distance";
	}
	
	export interface DistanceScoringParameters {
		boostingDistance: number;
		referencePointParameter: string;
	}
	
	export interface DocumentDebugInfo {
		readonly semantic?: SemanticDebugInfo;
		readonly vectors?: VectorsDebugInfo;
	}
	
	export interface DocumentExtractionSkill extends SearchIndexerSkill {
		configuration?: {
			        [propertyName: string]: any;
			    };
		dataToExtract?: string;
		odatatype: "#Microsoft.Skills.Util.DocumentExtractionSkill";
		parsingMode?: string;
	}
	
	export interface DocumentIntelligenceLayoutSkill extends BaseSearchIndexerSkill {
		markdownHeaderDepth?: DocumentIntelligenceLayoutSkillMarkdownHeaderDepth;
		odatatype: "#Microsoft.Skills.Util.DocumentIntelligenceLayoutSkill";
		outputMode?: DocumentIntelligenceLayoutSkillOutputMode;
	}
	
	export interface EdgeNGramTokenFilter {
		maxGram?: number;
		minGram?: number;
		name: string;
		odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenFilterV2" | "#Microsoft.Azure.Search.EdgeNGramTokenFilter";
		side?: EdgeNGramTokenFilterSide;
	}
	
	export interface EdgeNGramTokenizer extends LexicalTokenizer {
		maxGram?: number;
		minGram?: number;
		odatatype: "#Microsoft.Azure.Search.EdgeNGramTokenizer";
		tokenChars?: TokenCharacterKind[];
	}
	
	export interface ElisionTokenFilter extends TokenFilter {
		articles?: string[];
		odatatype: "#Microsoft.Azure.Search.ElisionTokenFilter";
	}
	
	export interface EntityLinkingSkill extends SearchIndexerSkill {
		defaultLanguageCode?: string;
		minimumPrecision?: number;
		modelVersion?: string;
		odatatype: "#Microsoft.Skills.Text.V3.EntityLinkingSkill";
	}
	
	export interface EntityRecognitionSkill extends BaseSearchIndexerSkill {
		categories?: EntityCategory[];
		defaultLanguageCode?: EntityRecognitionSkillLanguage;
		includeTypelessEntities?: boolean;
		minimumPrecision?: number;
		odatatype: "#Microsoft.Skills.Text.EntityRecognitionSkill";
	}
	
	export interface EntityRecognitionSkillV3 extends SearchIndexerSkill {
		categories?: string[];
		defaultLanguageCode?: string;
		minimumPrecision?: number;
		modelVersion?: string;
		odatatype: "#Microsoft.Skills.Text.V3.EntityRecognitionSkill";
	}
	
	export interface ExhaustiveKnnParameters {
		metric?: VectorSearchAlgorithmMetric;
	}
	
	export interface ExtractiveQueryAnswer {
		answerType: "extractive";
		count?: number;
		maxAnswerLength?: number;
		threshold?: number;
	}
	
	export interface ExtractiveQueryCaption {
		captionType: "extractive";
		highlight?: boolean;
		maxCaptionLength?: number;
	}
	
	export interface FacetResult {
		readonly count?: number;
		readonly facets?: {
			        [propertyName: string]: FacetResult[];
			    };
		[property: string]: any;
	}
	
	export interface FieldMapping {
		mappingFunction?: FieldMappingFunction;
		sourceFieldName: string;
		targetFieldName?: string;
	}
	
	export interface FieldMappingFunction {
		name: string;
		parameters?: {
			        [propertyName: string]: any;
			    };
	}
	
	export interface FreshnessScoringFunction extends ScoringFunction {
		parameters: FreshnessScoringParameters;
		type: "freshness";
	}
	
	export interface FreshnessScoringParameters {
		boostingDuration: string;
	}
	
	export interface GenerativeQueryRewrites {
		count?: number;
		rewritesType: "generative";
	}
	
	export interface GetDocumentOptions<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> extends OperationOptions {
		selectedFields?: SelectArray<TFields>;
	}
	
	export interface HighWaterMarkChangeDetectionPolicy extends DataChangeDetectionPolicy {
		highWaterMarkColumnName: string;
		odatatype: "#Microsoft.Azure.Search.HighWaterMarkChangeDetectionPolicy";
	}
	
	export interface HnswParameters {
		efConstruction?: number;
		efSearch?: number;
		m?: number;
		metric?: VectorSearchAlgorithmMetric;
	}
	
	export interface HybridSearch {
		countAndFacetMode?: HybridCountAndFacetMode;
		maxTextRecallSize?: number;
	}
	
	export interface ImageAnalysisSkill extends BaseSearchIndexerSkill {
		defaultLanguageCode?: ImageAnalysisSkillLanguage;
		details?: ImageDetail[];
		odatatype: "#Microsoft.Skills.Vision.ImageAnalysisSkill";
		visualFeatures?: VisualFeature[];
	}
	
	export interface IndexDocumentsClient<TModel extends object> {
		indexDocuments(batch: IndexDocumentsBatch<TModel>, options: IndexDocumentsOptions): Promise<IndexDocumentsResult>;
	}
	
	export interface IndexDocumentsOptions extends OperationOptions {
		throwOnAnyFailure?: boolean;
	}
	
	export interface IndexDocumentsResult {
		readonly results: IndexingResult[];
	}
	
	export interface IndexerExecutionResult {
		readonly currentState?: IndexerState;
		readonly endTime?: Date;
		readonly errorMessage?: string;
		readonly errors: SearchIndexerError[];
		readonly failedItemCount: number;
		readonly finalTrackingState?: string;
		readonly initialTrackingState?: string;
		readonly itemCount: number;
		readonly startTime?: Date;
		readonly status: IndexerExecutionStatus;
		readonly statusDetail?: IndexerExecutionStatusDetail;
		readonly warnings: SearchIndexerWarning[];
	}
	
	export interface IndexerState {
		readonly allDocumentsFinalChangeTrackingState?: string;
		readonly allDocumentsInitialChangeTrackingState?: string;
		readonly mode?: IndexingMode;
		readonly resetDatasourceDocumentIds?: string[];
		readonly resetDocumentKeys?: string[];
		readonly resetDocumentsFinalChangeTrackingState?: string;
		readonly resetDocumentsInitialChangeTrackingState?: string;
	}
	
	export interface IndexingParameters {
		batchSize?: number;
		configuration?: IndexingParametersConfiguration;
		maxFailedItems?: number;
		maxFailedItemsPerBatch?: number;
	}
	
	export interface IndexingParametersConfiguration {
		allowSkillsetToReadFileData?: boolean;
		dataToExtract?: BlobIndexerDataToExtract;
		delimitedTextDelimiter?: string;
		delimitedTextHeaders?: string;
		documentRoot?: string;
		excludedFileNameExtensions?: string;
		executionEnvironment?: IndexerExecutionEnvironment;
		failOnUnprocessableDocument?: boolean;
		failOnUnsupportedContentType?: boolean;
		firstLineContainsHeaders?: boolean;
		imageAction?: BlobIndexerImageAction;
		indexedFileNameExtensions?: string;
		indexStorageMetadataOnlyForOversizedDocuments?: boolean;
		markdownHeaderDepth?: MarkdownHeaderDepth;
		markdownParsingSubmode?: MarkdownParsingSubmode;
		parsingMode?: BlobIndexerParsingMode;
		pdfTextRotationAlgorithm?: BlobIndexerPDFTextRotationAlgorithm;
		queryTimeout?: string;
		[property: string]: any;
	}
	
	export interface IndexingResult {
		readonly errorMessage?: string;
		readonly key: string;
		readonly statusCode: number;
		readonly succeeded: boolean;
	}
	
	export interface IndexingSchedule {
		interval: string;
		startTime?: Date;
	}
	
	export interface InputFieldMappingEntry {
		inputs?: InputFieldMappingEntry[];
		name: string;
		source?: string;
		sourceContext?: string;
	}
	
	export interface KeepTokenFilter extends TokenFilter {
		keepWords: string[];
		lowerCaseKeepWords?: boolean;
		odatatype: "#Microsoft.Azure.Search.KeepTokenFilter";
	}
	
	export interface KeyAuthAzureMachineLearningVectorizerParameters extends BaseAzureMachineLearningVectorizerParameters {
		authenticationKey: string;
		authKind: "key";
		scoringUri: string;
	}
	
	export interface KeyPhraseExtractionSkill extends BaseSearchIndexerSkill {
		defaultLanguageCode?: KeyPhraseExtractionSkillLanguage;
		maxKeyPhraseCount?: number;
		modelVersion?: string;
		odatatype: "#Microsoft.Skills.Text.KeyPhraseExtractionSkill";
	}
	
	export interface KeywordMarkerTokenFilter extends TokenFilter {
		ignoreCase?: boolean;
		keywords: string[];
		odatatype: "#Microsoft.Azure.Search.KeywordMarkerTokenFilter";
	}
	
	export interface KeywordTokenizer {
		maxTokenLength?: number;
		name: string;
		odatatype: "#Microsoft.Azure.Search.KeywordTokenizerV2" | "#Microsoft.Azure.Search.KeywordTokenizer";
	}
	
	export interface LanguageDetectionSkill extends SearchIndexerSkill {
		defaultCountryHint?: string;
		modelVersion?: string;
		odatatype: "#Microsoft.Skills.Text.LanguageDetectionSkill";
	}
	
	export interface LengthTokenFilter extends TokenFilter {
		maxLength?: number;
		minLength?: number;
		odatatype: "#Microsoft.Azure.Search.LengthTokenFilter";
	}
	
	export interface LimitTokenFilter extends TokenFilter {
		consumeAllTokens?: boolean;
		maxTokenCount?: number;
		odatatype: "#Microsoft.Azure.Search.LimitTokenFilter";
	}
	
	export interface ListSearchResultsPageSettings {
		continuationToken?: string;
	}
	
	export interface LuceneStandardAnalyzer extends LexicalAnalyzer {
		maxTokenLength?: number;
		odatatype: "#Microsoft.Azure.Search.StandardAnalyzer";
		stopwords?: string[];
	}
	
	export interface LuceneStandardTokenizer {
		maxTokenLength?: number;
		name: string;
		odatatype: "#Microsoft.Azure.Search.StandardTokenizerV2" | "#Microsoft.Azure.Search.StandardTokenizer";
	}
	
	export interface MagnitudeScoringFunction extends ScoringFunction {
		parameters: MagnitudeScoringParameters;
		type: "magnitude";
	}
	
	export interface MagnitudeScoringParameters {
		boostingRangeEnd: number;
		boostingRangeStart: number;
		shouldBoostBeyondRangeByConstant?: boolean;
	}
	
	export interface MappingCharFilter extends CharFilter {
		mappings: string[];
		odatatype: "#Microsoft.Azure.Search.MappingCharFilter";
	}
	
	export interface MergeSkill extends SearchIndexerSkill {
		insertPostTag?: string;
		insertPreTag?: string;
		odatatype: "#Microsoft.Skills.Text.MergeSkill";
	}
	
	export interface MicrosoftLanguageStemmingTokenizer extends LexicalTokenizer {
		isSearchTokenizer?: boolean;
		language?: MicrosoftStemmingTokenizerLanguage;
		maxTokenLength?: number;
		odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageStemmingTokenizer";
	}
	
	export interface MicrosoftLanguageTokenizer extends LexicalTokenizer {
		isSearchTokenizer?: boolean;
		language?: MicrosoftTokenizerLanguage;
		maxTokenLength?: number;
		odatatype: "#Microsoft.Azure.Search.MicrosoftLanguageTokenizer";
	}
	
	export interface NativeBlobSoftDeleteDeletionDetectionPolicy extends DataDeletionDetectionPolicy {
		odatatype: "#Microsoft.Azure.Search.NativeBlobSoftDeleteDeletionDetectionPolicy";
	}
	
	export interface NGramTokenFilter {
		maxGram?: number;
		minGram?: number;
		name: string;
		odatatype: "#Microsoft.Azure.Search.NGramTokenFilterV2" | "#Microsoft.Azure.Search.NGramTokenFilter";
	}
	
	export interface NGramTokenizer extends LexicalTokenizer {
		maxGram?: number;
		minGram?: number;
		odatatype: "#Microsoft.Azure.Search.NGramTokenizer";
		tokenChars?: TokenCharacterKind[];
	}
	
	export interface NoAuthAzureMachineLearningVectorizerParameters extends BaseAzureMachineLearningVectorizerParameters {
		authKind: "none";
		scoringUri: string;
	}
	
	export interface OcrSkill extends BaseSearchIndexerSkill {
		defaultLanguageCode?: OcrSkillLanguage;
		lineEnding?: OcrLineEnding;
		odatatype: "#Microsoft.Skills.Vision.OcrSkill";
		shouldDetectOrientation?: boolean;
	}
	
	export interface OutputFieldMappingEntry {
		name: string;
		targetName?: string;
	}
	
	export interface PathHierarchyTokenizerV2 extends LexicalTokenizer {
		delimiter?: string;
		maxTokenLength?: number;
		numberOfTokensToSkip?: number;
		odatatype: "#Microsoft.Azure.Search.PathHierarchyTokenizerV2";
		replacement?: string;
		reverseTokenOrder?: boolean;
	}
	
	export interface PatternAnalyzer {
		flags?: RegexFlags[];
		lowerCaseTerms?: boolean;
		name: string;
		odatatype: "#Microsoft.Azure.Search.PatternAnalyzer";
		pattern?: string;
		stopwords?: string[];
	}
	
	export interface PatternCaptureTokenFilter extends TokenFilter {
		odatatype: "#Microsoft.Azure.Search.PatternCaptureTokenFilter";
		patterns: string[];
		preserveOriginal?: boolean;
	}
	
	export interface PatternReplaceCharFilter extends CharFilter {
		odatatype: "#Microsoft.Azure.Search.PatternReplaceCharFilter";
		pattern: string;
		replacement: string;
	}
	
	export interface PatternReplaceTokenFilter extends TokenFilter {
		odatatype: "#Microsoft.Azure.Search.PatternReplaceTokenFilter";
		pattern: string;
		replacement: string;
	}
	
	export interface PatternTokenizer {
		flags?: RegexFlags[];
		group?: number;
		name: string;
		odatatype: "#Microsoft.Azure.Search.PatternTokenizer";
		pattern?: string;
	}
	
	export interface PhoneticTokenFilter extends TokenFilter {
		encoder?: PhoneticEncoder;
		odatatype: "#Microsoft.Azure.Search.PhoneticTokenFilter";
		replaceOriginalTokens?: boolean;
	}
	
	export interface PIIDetectionSkill extends BaseSearchIndexerSkill {
		categories?: string[];
		defaultLanguageCode?: string;
		domain?: string;
		maskingCharacter?: string;
		maskingMode?: PIIDetectionSkillMaskingMode;
		minimumPrecision?: number;
		modelVersion?: string;
		odatatype: "#Microsoft.Skills.Text.PIIDetectionSkill";
	}
	
	export interface QueryAnswerResult {
		readonly highlights?: string;
		readonly key: string;
		readonly score: number;
		readonly text: string;
		[property: string]: any;
	}
	
	export interface QueryCaptionResult {
		readonly highlights?: string;
		readonly text?: string;
		[property: string]: any;
	}
	
	export interface QueryResultDocumentRerankerInput {
		readonly content?: string;
		readonly keywords?: string;
		readonly title?: string;
	}
	
	export interface QueryResultDocumentSemanticField {
		readonly name?: string;
		readonly state?: SemanticFieldState;
	}
	
	export interface QueryResultDocumentSubscores {
		readonly documentBoost?: number;
		readonly text?: TextResult;
		readonly vectors?: {
			        [propertyName: string]: SingleVectorFieldResult;
			    }[];
	}
	
	export interface QueryRewritesDebugInfo {
		readonly text?: QueryRewritesValuesDebugInfo;
		readonly vectors?: QueryRewritesValuesDebugInfo[];
	}
	
	export interface QueryRewritesValuesDebugInfo {
		readonly inputQuery?: string;
		readonly rewrites?: string[];
	}
	
	export interface RescoringOptions {
		defaultOversampling?: number;
		enableRescoring?: boolean;
		rescoreStorageMethod?: VectorSearchCompressionRescoreStorageMethod;
	}
	
	export interface ResetDocumentsOptions extends OperationOptions {
		datasourceDocumentIds?: string[];
		documentKeys?: string[];
		overwrite?: boolean;
	}
	
	export interface ResetSkillsOptions extends OperationOptions {
		skillNames?: string[];
	}
	
	export interface ResourceCounter {
		quota?: number;
		usage: number;
	}
	
	export interface ScalarQuantizationCompression extends VectorSearchCompression {
		kind: "scalarQuantization";
		parameters?: ScalarQuantizationParameters;
	}
	
	export interface ScalarQuantizationParameters {
		quantizedDataType?: VectorSearchCompressionTarget;
	}
	
	export interface ScoringProfile {
		functionAggregation?: ScoringFunctionAggregation;
		functions?: ScoringFunction[];
		name: string;
		textWeights?: TextWeights;
	}
	
	export interface SearchAlias {
		etag?: string;
		indexes: string[];
		name: string;
	}
	
	export interface SearchClientOptions extends ExtendedCommonClientOptions {
		apiVersion?: string;
		audience?: string;
		serviceVersion?: string;
	}
	
	export interface SearchDocumentsPageResult<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> extends SearchDocumentsResultBase {
		continuationToken?: string;
		readonly results: SearchResult<TModel, TFields>[];
	}
	
	export interface SearchDocumentsResult<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> extends SearchDocumentsResultBase {
		readonly results: SearchIterator<TModel, TFields>;
	}
	
	export interface SearchDocumentsResultBase {
		readonly answers?: QueryAnswerResult[];
		readonly count?: number;
		readonly coverage?: number;
		readonly debugInfo?: DebugInfo;
		readonly facets?: {
			        [propertyName: string]: FacetResult[];
			    };
		readonly semanticErrorReason?: SemanticErrorReason;
		readonly semanticQueryRewritesResultType?: SemanticQueryRewritesResultType;
		readonly semanticSearchResultsType?: SemanticSearchResultsType;
	}
	
	export interface SearchIndex {
		analyzers?: LexicalAnalyzer[];
		charFilters?: CharFilter[];
		corsOptions?: CorsOptions;
		defaultScoringProfile?: string;
		encryptionKey?: SearchResourceEncryptionKey;
		etag?: string;
		fields: SearchField[];
		name: string;
		normalizers?: LexicalNormalizer[];
		scoringProfiles?: ScoringProfile[];
		semanticSearch?: SemanticSearch;
		similarity?: SimilarityAlgorithm;
		suggesters?: SearchSuggester[];
		tokenFilters?: TokenFilter[];
		tokenizers?: LexicalTokenizer[];
		vectorSearch?: VectorSearch;
	}
	
	export interface SearchIndexClientOptions extends ExtendedCommonClientOptions {
		apiVersion?: string;
		audience?: string;
		serviceVersion?: string;
	}
	
	export interface SearchIndexer {
		cache?: SearchIndexerCache;
		dataSourceName: string;
		description?: string;
		encryptionKey?: SearchResourceEncryptionKey;
		etag?: string;
		fieldMappings?: FieldMapping[];
		isDisabled?: boolean;
		name: string;
		outputFieldMappings?: FieldMapping[];
		parameters?: IndexingParameters;
		schedule?: IndexingSchedule;
		skillsetName?: string;
		targetIndexName: string;
	}
	
	export interface SearchIndexerCache {
		enableReprocessing?: boolean;
		identity?: SearchIndexerDataIdentity;
		storageConnectionString?: string;
	}
	
	export interface SearchIndexerClientOptions extends ExtendedCommonClientOptions {
		apiVersion?: string;
		audience?: string;
		serviceVersion?: string;
	}
	
	export interface SearchIndexerDataContainer {
		name: string;
		query?: string;
	}
	
	export interface SearchIndexerDataNoneIdentity extends SearchIndexerDataIdentity {
		odatatype: "#Microsoft.Azure.Search.DataNoneIdentity";
	}
	
	export interface SearchIndexerDataSourceConnection {
		connectionString?: string;
		container: SearchIndexerDataContainer;
		dataChangeDetectionPolicy?: DataChangeDetectionPolicy;
		dataDeletionDetectionPolicy?: DataDeletionDetectionPolicy;
		description?: string;
		encryptionKey?: SearchResourceEncryptionKey;
		etag?: string;
		identity?: SearchIndexerDataIdentity;
		name: string;
		type: SearchIndexerDataSourceType;
	}
	
	export interface SearchIndexerDataUserAssignedIdentity extends SearchIndexerDataIdentity {
		odatatype: "#Microsoft.Azure.Search.DataUserAssignedIdentity";
		resourceId: string;
	}
	
	export interface SearchIndexerError {
		readonly details?: string;
		readonly documentationLink?: string;
		readonly errorMessage: string;
		readonly key?: string;
		readonly name?: string;
		readonly statusCode: number;
	}
	
	export interface SearchIndexerIndexProjection {
		parameters?: SearchIndexerIndexProjectionParameters;
		selectors: SearchIndexerIndexProjectionSelector[];
	}
	
	export interface SearchIndexerIndexProjectionParameters {
		projectionMode?: IndexProjectionMode;
		[property: string]: unknown;
	}
	
	export interface SearchIndexerIndexProjectionSelector {
		mappings: InputFieldMappingEntry[];
		parentKeyFieldName: string;
		sourceContext: string;
		targetIndexName: string;
	}
	
	export interface SearchIndexerKnowledgeStore {
		identity?: SearchIndexerDataIdentity;
		projections: SearchIndexerKnowledgeStoreProjection[];
		storageConnectionString: string;
	}
	
	export interface SearchIndexerKnowledgeStoreBlobProjectionSelector extends SearchIndexerKnowledgeStoreProjectionSelector {
		storageContainer: string;
	}
	
	export interface SearchIndexerKnowledgeStoreFileProjectionSelector extends SearchIndexerKnowledgeStoreBlobProjectionSelector { }
	
	export interface SearchIndexerKnowledgeStoreObjectProjectionSelector extends SearchIndexerKnowledgeStoreBlobProjectionSelector { }
	
	export interface SearchIndexerKnowledgeStoreParameters {
		synthesizeGeneratedKeyName?: boolean;
		[property: string]: unknown;
	}
	
	export interface SearchIndexerKnowledgeStoreProjection {
		files?: SearchIndexerKnowledgeStoreFileProjectionSelector[];
		objects?: SearchIndexerKnowledgeStoreObjectProjectionSelector[];
		tables?: SearchIndexerKnowledgeStoreTableProjectionSelector[];
	}
	
	export interface SearchIndexerKnowledgeStoreProjectionSelector {
		generatedKeyName?: string;
		inputs?: InputFieldMappingEntry[];
		referenceKeyName?: string;
		source?: string;
		sourceContext?: string;
	}
	
	export interface SearchIndexerKnowledgeStoreTableProjectionSelector extends SearchIndexerKnowledgeStoreProjectionSelector {
		tableName: string;
	}
	
	export interface SearchIndexerLimits {
		readonly maxDocumentContentCharactersToExtract?: number;
		readonly maxDocumentExtractionSize?: number;
		readonly maxRunTime?: string;
	}
	
	export interface SearchIndexerSkillset {
		cognitiveServicesAccount?: CognitiveServicesAccount;
		description?: string;
		encryptionKey?: SearchResourceEncryptionKey;
		etag?: string;
		indexProjection?: SearchIndexerIndexProjection;
		knowledgeStore?: SearchIndexerKnowledgeStore;
		name: string;
		skills: SearchIndexerSkill[];
	}
	
	export interface SearchIndexerStatus {
		readonly executionHistory: IndexerExecutionResult[];
		readonly lastResult?: IndexerExecutionResult;
		readonly limits: SearchIndexerLimits;
		readonly status: IndexerStatus;
	}
	
	export interface SearchIndexerWarning {
		readonly details?: string;
		readonly documentationLink?: string;
		readonly key?: string;
		readonly message: string;
		readonly name?: string;
	}
	
	export interface SearchIndexingBufferedSenderOptions {
		autoFlush?: boolean;
		flushWindowInMs?: number;
		initialBatchActionCount?: number;
		maxRetriesPerAction?: number;
		maxThrottlingDelayInMs?: number;
		throttlingDelayInMs?: number;
	}
	
	export interface SearchIndexStatistics {
		readonly documentCount: number;
		readonly storageSize: number;
		readonly vectorIndexSize: number;
	}
	
	export interface SearchResourceEncryptionKey {
		applicationId?: string;
		applicationSecret?: string;
		identity?: SearchIndexerDataIdentity;
		keyName: string;
		keyVersion: string;
		vaultUrl: string;
	}
	
	export interface SearchScoreThreshold extends BaseVectorThreshold {
		kind: "searchScore";
		value: number;
	}
	
	export interface SearchServiceStatistics {
		counters: ServiceCounters;
		limits: ServiceLimits;
	}
	
	export interface Suggester {
		name: string;
		searchMode: "analyzingInfixMatching";
		sourceFields: string[];
	}
	
	export interface SemanticConfiguration {
		name: string;
		prioritizedFields: SemanticPrioritizedFields;
	}
	
	export interface SemanticDebugInfo {
		readonly contentFields?: QueryResultDocumentSemanticField[];
		readonly keywordFields?: QueryResultDocumentSemanticField[];
		readonly rerankerInput?: QueryResultDocumentRerankerInput;
		readonly titleField?: QueryResultDocumentSemanticField;
	}
	
	export interface SemanticField {
		name: string;
	}
	
	export interface SemanticPrioritizedFields {
		contentFields?: SemanticField[];
		keywordsFields?: SemanticField[];
		titleField?: SemanticField;
	}
	
	export interface SemanticSearch {
		configurations?: SemanticConfiguration[];
		defaultConfigurationName?: string;
	}
	
	export interface SemanticSearchOptions {
		answers?: QueryAnswer;
		captions?: QueryCaption;
		configurationName?: string;
		debugMode?: QueryDebugMode;
		errorMode?: SemanticErrorMode;
		maxWaitInMilliseconds?: number;
		queryRewrites?: QueryRewrites;
		semanticFields?: string[];
		semanticQuery?: string;
	}
	
	export interface SentimentSkill extends BaseSearchIndexerSkill {
		defaultLanguageCode?: SentimentSkillLanguage;
		odatatype: "#Microsoft.Skills.Text.SentimentSkill";
	}
	
	export interface SentimentSkillV3 extends SearchIndexerSkill {
		defaultLanguageCode?: string;
		includeOpinionMining?: boolean;
		modelVersion?: string;
		odatatype: "#Microsoft.Skills.Text.V3.SentimentSkill";
	}
	
	export interface ServiceCounters {
		aliasCounter: ResourceCounter;
		dataSourceCounter: ResourceCounter;
		documentCounter: ResourceCounter;
		indexCounter: ResourceCounter;
		indexerCounter: ResourceCounter;
		skillsetCounter: ResourceCounter;
		storageSizeCounter: ResourceCounter;
		synonymMapCounter: ResourceCounter;
		vectorIndexSizeCounter: ResourceCounter;
	}
	
	export interface ServiceLimits {
		maxComplexCollectionFieldsPerIndex?: number;
		maxComplexObjectsInCollectionsPerDocument?: number;
		maxFieldNestingDepthPerIndex?: number;
		maxFieldsPerIndex?: number;
		maxStoragePerIndexInBytes?: number;
	}
	
	export interface ShaperSkill extends SearchIndexerSkill {
		odatatype: "#Microsoft.Skills.Util.ShaperSkill";
	}
	
	export interface ShingleTokenFilter extends TokenFilter {
		filterToken?: string;
		maxShingleSize?: number;
		minShingleSize?: number;
		odatatype: "#Microsoft.Azure.Search.ShingleTokenFilter";
		outputUnigrams?: boolean;
		outputUnigramsIfNoShingles?: boolean;
		tokenSeparator?: string;
	}
	
	export interface Similarity {
		odatatype: "#Microsoft.Azure.Search.ClassicSimilarity" | "#Microsoft.Azure.Search.BM25Similarity";
	}
	
	export interface SimpleField {
		analyzerName?: LexicalAnalyzerName;
		facetable?: boolean;
		filterable?: boolean;
		hidden?: boolean;
		indexAnalyzerName?: LexicalAnalyzerName;
		key?: boolean;
		name: string;
		normalizerName?: LexicalNormalizerName;
		searchable?: boolean;
		searchAnalyzerName?: LexicalAnalyzerName;
		sortable?: boolean;
		stored?: boolean;
		synonymMapNames?: string[];
		type: SearchFieldDataType;
		vectorEncodingFormat?: VectorEncodingFormat;
		vectorSearchDimensions?: number;
		vectorSearchProfileName?: string;
	}
	
	export interface SingleVectorFieldResult {
		readonly searchScore?: number;
		readonly vectorSimilarity?: number;
	}
	
	export interface SnowballTokenFilter extends TokenFilter {
		language: SnowballTokenFilterLanguage;
		odatatype: "#Microsoft.Azure.Search.SnowballTokenFilter";
	}
	
	export interface SoftDeleteColumnDeletionDetectionPolicy extends DataDeletionDetectionPolicy {
		odatatype: "#Microsoft.Azure.Search.SoftDeleteColumnDeletionDetectionPolicy";
		softDeleteColumnName?: string;
		softDeleteMarkerValue?: string;
	}
	
	export interface SplitSkill extends BaseSearchIndexerSkill {
		azureOpenAITokenizerParameters?: AzureOpenAITokenizerParameters;
		defaultLanguageCode?: SplitSkillLanguage;
		maximumPagesToTake?: number;
		maxPageLength?: number;
		odatatype: "#Microsoft.Skills.Text.SplitSkill";
		pageOverlapLength?: number;
		textSplitMode?: TextSplitMode;
		unit?: SplitSkillUnit;
	}
	
	export interface SqlIntegratedChangeTrackingPolicy extends DataChangeDetectionPolicy {
		odatatype: "#Microsoft.Azure.Search.SqlIntegratedChangeTrackingPolicy";
	}
	
	export interface StemmerOverrideTokenFilter extends TokenFilter {
		odatatype: "#Microsoft.Azure.Search.StemmerOverrideTokenFilter";
		rules: string[];
	}
	
	export interface StemmerTokenFilter extends TokenFilter {
		language: StemmerTokenFilterLanguage;
		odatatype: "#Microsoft.Azure.Search.StemmerTokenFilter";
	}
	
	export interface StopAnalyzer extends LexicalAnalyzer {
		odatatype: "#Microsoft.Azure.Search.StopAnalyzer";
		stopwords?: string[];
	}
	
	export interface StopwordsTokenFilter extends TokenFilter {
		ignoreCase?: boolean;
		odatatype: "#Microsoft.Azure.Search.StopwordsTokenFilter";
		removeTrailingStopWords?: boolean;
		stopwords?: string[];
		stopwordsList?: StopwordsList;
	}
	
	export interface SuggestDocumentsResult<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> {
		readonly coverage?: number;
		readonly results: SuggestResult<TModel, TFields>[];
	}
	
	export interface SuggestRequest<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> {
		filter?: string;
		highlightPostTag?: string;
		highlightPreTag?: string;
		minimumCoverage?: number;
		orderBy?: string[];
		searchFields?: SearchFieldArray<TModel>;
		select?: SelectArray<TFields>;
		top?: number;
		useFuzzyMatching?: boolean;
	}
	
	export interface SynonymMap {
		encryptionKey?: SearchResourceEncryptionKey;
		etag?: string;
		name: string;
		synonyms: string[];
	}
	
	export interface SynonymTokenFilter extends TokenFilter {
		expand?: boolean;
		ignoreCase?: boolean;
		odatatype: "#Microsoft.Azure.Search.SynonymTokenFilter";
		synonyms: string[];
	}
	
	export interface TagScoringFunction extends ScoringFunction {
		parameters: TagScoringParameters;
		type: "tag";
	}
	
	export interface TagScoringParameters {
		tagsParameter: string;
	}
	
	export interface TextResult {
		readonly searchScore?: number;
	}
	
	export interface TextTranslationSkill extends BaseSearchIndexerSkill {
		defaultFromLanguageCode?: TextTranslationSkillLanguage;
		defaultToLanguageCode: TextTranslationSkillLanguage;
		odatatype: "#Microsoft.Skills.Text.TranslationSkill";
		suggestedFrom?: TextTranslationSkillLanguage;
	}
	
	export interface TextWeights {
		weights: {
			        [propertyName: string]: number;
			    };
	}
	
	export interface TokenAuthAzureMachineLearningVectorizerParameters extends BaseAzureMachineLearningVectorizerParameters {
		authKind: "token";
		region?: string;
		resourceId: string;
	}
	
	export interface TruncateTokenFilter extends TokenFilter {
		length?: number;
		odatatype: "#Microsoft.Azure.Search.TruncateTokenFilter";
	}
	
	export interface UaxUrlEmailTokenizer extends LexicalTokenizer {
		maxTokenLength?: number;
		odatatype: "#Microsoft.Azure.Search.UaxUrlEmailTokenizer";
	}
	
	export interface UniqueTokenFilter extends TokenFilter {
		odatatype: "#Microsoft.Azure.Search.UniqueTokenFilter";
		onlyOnSamePosition?: boolean;
	}
	
	export interface VectorizableImageBinaryQuery<TModel extends object> extends BaseVectorQuery<TModel> {
		binaryImage: string;
		kind: "imageBinary";
	}
	
	export interface VectorizableImageUrlQuery<TModel extends object> extends BaseVectorQuery<TModel> {
		kind: "imageUrl";
		url: string;
	}
	
	export interface VectorizableTextQuery<TModel extends object> extends BaseVectorQuery<TModel> {
		kind: "text";
		queryRewrites?: QueryRewrites;
		text: string;
	}
	
	export interface VectorizedQuery<TModel extends object> extends BaseVectorQuery<TModel> {
		kind: "vector";
		vector: number[];
	}
	
	export interface VectorsDebugInfo {
		readonly subscores?: QueryResultDocumentSubscores;
	}
	
	export interface VectorSearch {
		algorithms?: VectorSearchAlgorithmConfiguration[];
		compressions?: VectorSearchCompression[];
		profiles?: VectorSearchProfile[];
		vectorizers?: VectorSearchVectorizer[];
	}
	
	export interface VectorSearchOptions<TModel extends object> {
		filterMode?: VectorFilterMode;
		queries: VectorQuery<TModel>[];
	}
	
	export interface VectorSearchProfile {
		algorithmConfigurationName: string;
		compressionName?: string;
		name: string;
		vectorizerName?: string;
	}
	
	export interface VectorSimilarityThreshold extends BaseVectorThreshold {
		kind: "vectorSimilarity";
		value: number;
	}
	
	export interface VisionVectorizeSkill extends BaseSearchIndexerSkill {
		modelVersion?: string;
		odatatype: "#Microsoft.Skills.Vision.VectorizeSkill";
	}
	
	export interface WebApiParameters {
		authIdentity?: SearchIndexerDataIdentity;
		authResourceId?: string;
		httpHeaders?: {
			        [propertyName: string]: string;
			    };
		httpMethod?: string;
		timeout?: string;
		uri?: string;
	}
	
	export interface WebApiSkill extends BaseSearchIndexerSkill {
		authIdentity?: SearchIndexerDataIdentity;
		authResourceId?: string;
		batchSize?: number;
		degreeOfParallelism?: number;
		httpHeaders?: {
			        [propertyName: string]: string;
			    };
		httpMethod?: string;
		odatatype: "#Microsoft.Skills.Custom.WebApiSkill";
		timeout?: string;
		uri: string;
	}
	
	export interface WebApiVectorizer extends BaseVectorSearchVectorizer {
		kind: "customWebApi";
		parameters?: WebApiParameters;
	}
	
	export interface WordDelimiterTokenFilter extends TokenFilter {
		catenateAll?: boolean;
		catenateNumbers?: boolean;
		catenateWords?: boolean;
		generateNumberParts?: boolean;
		generateWordParts?: boolean;
		odatatype: "#Microsoft.Azure.Search.WordDelimiterTokenFilter";
		preserveOriginal?: boolean;
		protectedWords?: string[];
		splitOnCaseChange?: boolean;
		splitOnNumerics?: boolean;
		stemEnglishPossessive?: boolean;
	}
	
	export type AIStudioModelCatalogName = string;
	
	export type AliasIterator = PagedAsyncIterableIterator<SearchIndexAlias, SearchIndexAlias[], {}>;
	
	export type AnalyzeTextOptions = OperationOptions & AnalyzeRequest;
	
	export type AutocompleteMode = "oneTerm" | "twoTerms" | "oneTermWithContext";
	
	export type AutocompleteOptions<TModel extends object> = OperationOptions & AutocompleteRequest<TModel>;
	
	export type AzureMachineLearningVectorizerParameters = NoAuthAzureMachineLearningVectorizerParameters | KeyAuthAzureMachineLearningVectorizerParameters | TokenAuthAzureMachineLearningVectorizerParameters;
	
	export type AzureOpenAIModelName = string;
	
	export type BlobIndexerDataToExtract = `${KnownBlobIndexerDataToExtract}`;
	
	export type BlobIndexerImageAction = `${KnownBlobIndexerImageAction}`;
	
	export type BlobIndexerParsingMode = `${KnownBlobIndexerParsingMode}`;
	
	export type BlobIndexerPDFTextRotationAlgorithm = `${KnownBlobIndexerPDFTextRotationAlgorithm}`;
	
	export type CharFilter = MappingCharFilter | PatternReplaceCharFilter;
	
	export type CharFilterName = string;
	
	export type CjkBigramTokenFilterScripts = "han" | "hiragana" | "katakana" | "hangul";
	
	export type CognitiveServicesAccount = DefaultCognitiveServicesAccount | CognitiveServicesAccountKey | AIServicesAccountKey | AIServicesAccountIdentity;
	
	export type ComplexDataType = "Edm.ComplexType" | "Collection(Edm.ComplexType)";
	
	export type CountDocumentsOptions = OperationOptions;
	
	export type CreateAliasOptions = OperationOptions;
	
	export type CreateDataSourceConnectionOptions = OperationOptions;
	
	export type CreateIndexerOptions = OperationOptions;
	
	export type CreateIndexOptions = OperationOptions;
	
	export type CreateSkillsetOptions = OperationOptions;
	
	export type CreateSynonymMapOptions = OperationOptions;
	
	export type CustomEntityLookupSkillLanguage = `${KnownCustomEntityLookupSkillLanguage}`;
	
	export type DataChangeDetectionPolicy = HighWaterMarkChangeDetectionPolicy | SqlIntegratedChangeTrackingPolicy;
	
	export type DataDeletionDetectionPolicy = SoftDeleteColumnDeletionDetectionPolicy | NativeBlobSoftDeleteDeletionDetectionPolicy;
	
	export type DeleteDocumentsOptions = IndexDocumentsOptions;
	
	export type DocumentIntelligenceLayoutSkillMarkdownHeaderDepth = string;
	
	export type DocumentIntelligenceLayoutSkillOutputMode = string;
	
	export type EdgeNGramTokenFilterSide = "front" | "back";
	
	export type EntityCategory = `${KnownEntityCategory}`;
	
	export type EntityRecognitionSkillLanguage = `${KnownEntityRecognitionSkillLanguage}`;
	
	export type ExcludedODataTypes = Date | GeographyPoint;
	
	export type ExhaustiveKnnAlgorithmConfiguration = BaseVectorSearchAlgorithmConfiguration & {
		    kind: "exhaustiveKnn";
		    parameters?: ExhaustiveKnnParameters;
		};
	
	export type ExtractDocumentKey<TModel> = {
		    [K in keyof TModel as TModel[K] extends string | undefined ? K : never]: TModel[K];
		};
	
	export type GetAliasOptions = OperationOptions;
	
	export type GetDataSourceConnectionOptions = OperationOptions;
	
	export type GetIndexerOptions = OperationOptions;
	
	export type GetIndexerStatusOptions = OperationOptions;
	
	export type GetIndexOptions = OperationOptions;
	
	export type GetIndexStatisticsOptions = OperationOptions;
	
	export type GetServiceStatisticsOptions = OperationOptions;
	
	export type GetSkillSetOptions = OperationOptions;
	
	export type GetSynonymMapsOptions = OperationOptions;
	
	export type HnswAlgorithmConfiguration = BaseVectorSearchAlgorithmConfiguration & {
		    kind: "hnsw";
		    parameters?: HnswParameters;
		};
	
	export type HybridCountAndFacetMode = string;
	
	export type ImageAnalysisSkillLanguage = `${KnownImageAnalysisSkillLanguage}`;
	
	export type ImageDetail = `${KnownImageDetail}`;
	
	export type IndexActionType = "upload" | "merge" | "mergeOrUpload" | "delete";
	
	export type IndexDocumentsAction<TModel> = {
		    __actionType: IndexActionType;
		} & Partial<TModel>;
	
	export type IndexerExecutionEnvironment = `${KnownIndexerExecutionEnvironment}`;
	
	export type IndexerExecutionStatus = "transientFailure" | "success" | "inProgress" | "reset";
	
	export type IndexerExecutionStatusDetail = string;
	
	export type IndexerStatus = "unknown" | "error" | "running";
	
	export type IndexingMode = string;
	
	export type IndexIterator = PagedAsyncIterableIterator<SearchIndex, SearchIndex[], {}>;
	
	export type IndexNameIterator = PagedAsyncIterableIterator<string, string[], {}>;
	
	export type IndexProjectionMode = string;
	
	export type KeyPhraseExtractionSkillLanguage = `${KnownKeyPhraseExtractionSkillLanguage}`;
	
	export type LexicalAnalyzer = CustomAnalyzer | PatternAnalyzer | LuceneStandardAnalyzer | StopAnalyzer;
	
	export type LexicalAnalyzerName = string;
	
	export type LexicalNormalizer = CustomNormalizer;
	
	export type LexicalNormalizerName = string;
	
	export type LexicalTokenizer = ClassicTokenizer | EdgeNGramTokenizer | KeywordTokenizer | MicrosoftLanguageTokenizer | MicrosoftLanguageStemmingTokenizer | NGramTokenizer | PathHierarchyTokenizer | PatternTokenizer | LuceneStandardTokenizer | UaxUrlEmailTokenizer;
	
	export type LexicalTokenizerName = string;
	
	export type ListAliasesOptions = OperationOptions;
	
	export type ListDataSourceConnectionsOptions = OperationOptions;
	
	export type ListIndexersOptions = OperationOptions;
	
	export type ListIndexesOptions = OperationOptions;
	
	export type ListSkillsetsOptions = OperationOptions;
	
	export type ListSynonymMapsOptions = OperationOptions;
	
	export type MarkdownHeaderDepth = string;
	
	export type MarkdownParsingSubmode = string;
	
	export type MergeDocumentsOptions = IndexDocumentsOptions;
	
	export type MergeOrUploadDocumentsOptions = IndexDocumentsOptions;
	
	export type MicrosoftStemmingTokenizerLanguage = "arabic" | "bangla" | "bulgarian" | "catalan" | "croatian" | "czech" | "danish" | "dutch" | "english" | "estonian" | "finnish" | "french" | "german" | "greek" | "gujarati" | "hebrew" | "hindi" | "hungarian" | "icelandic" | "indonesian" | "italian" | "kannada" | "latvian" | "lithuanian" | "malay" | "malayalam" | "marathi" | "norwegianBokmaal" | "polish" | "portuguese" | "portugueseBrazilian" | "punjabi" | "romanian" | "russian" | "serbianCyrillic" | "serbianLatin" | "slovak" | "slovenian" | "spanish" | "swedish" | "tamil" | "telugu" | "turkish" | "ukrainian" | "urdu";
	
	export type MicrosoftTokenizerLanguage = "bangla" | "bulgarian" | "catalan" | "chineseSimplified" | "chineseTraditional" | "croatian" | "czech" | "danish" | "dutch" | "english" | "french" | "german" | "greek" | "gujarati" | "hindi" | "icelandic" | "indonesian" | "italian" | "japanese" | "kannada" | "korean" | "malay" | "malayalam" | "marathi" | "norwegianBokmaal" | "polish" | "portuguese" | "portugueseBrazilian" | "punjabi" | "romanian" | "russian" | "serbianCyrillic" | "serbianLatin" | "slovenian" | "spanish" | "swedish" | "tamil" | "telugu" | "thai" | "ukrainian" | "urdu" | "vietnamese";
	
	export type NarrowedModel<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = (<T>() => T extends TModel ? true : false) extends <T>() => T extends never ? true : false ? TModel : (<T>() => T extends TModel ? true : false) extends <T>() => T extends object ? true : false ? TModel : (<T>() => T extends TModel ? true : false) extends <T>() => T extends any ? true : false ? TModel : (<T>() => T extends TModel ? true : false) extends <T>() => T extends unknown ? true : false ? TModel : (<T>() => T extends TFields ? true : false) extends <T>() => T extends never ? true : false ? never : (<T>() => T extends TFields ? true : false) extends <T>() => T extends SelectFields<TModel> ? true : false ? TModel : SearchPick<TModel, TFields>;
	
	export type OcrLineEnding = string;
	
	export type OcrSkillLanguage = `${KnownOcrSkillLanguage}`;
	
	export type PhoneticEncoder = "metaphone" | "doubleMetaphone" | "soundex" | "refinedSoundex" | "caverphone1" | "caverphone2" | "cologne" | "nysiis" | "koelnerPhonetik" | "haasePhonetik" | "beiderMorse";
	
	export type PIIDetectionSkillMaskingMode = `${KnownPIIDetectionSkillMaskingMode}`;
	
	export type QueryAnswer = ExtractiveQueryAnswer;
	
	export type QueryCaption = ExtractiveQueryCaption;
	
	export type QueryDebugMode = string;
	
	export type QueryLanguage = string;
	
	export type QueryRewrites = GenerativeQueryRewrites;
	
	export type QuerySpellerType = string;
	
	export type QueryType = "simple" | "full" | "semantic";
	
	export type RegexFlags = `${KnownRegexFlags}`;
	
	export type ResetIndexerOptions = OperationOptions;
	
	export type RunIndexerOptions = OperationOptions;
	
	export type ScoringFunction = DistanceScoringFunction | FreshnessScoringFunction | MagnitudeScoringFunction | TagScoringFunction;
	
	export type ScoringFunctionAggregation = "sum" | "average" | "minimum" | "maximum" | "firstMatching";
	
	export type ScoringFunctionInterpolation = "linear" | "constant" | "quadratic" | "logarithmic";
	
	export type ScoringStatistics = "local" | "global";
	
	export type SearchField = SimpleField | ComplexField;
	
	export type SearchFieldArray<TModel extends object = object> = (<T>() => T extends TModel ? true : false) extends <T>() => T extends object ? true : false ? readonly string[] : readonly SelectFields<TModel>[];
	
	export type SearchFieldDataType = Exclude<`${KnownSearchFieldDataType}` | `Collection(${KnownSearchFieldDataType})`, "Edm.ComplexType" | "Edm.Byte" | "Edm.Half" | "Edm.Int16" | "Edm.SByte" | "Edm.Single">;
	
	export type SearchIndexAlias = SearchAlias;
	
	export type SearchIndexerDataIdentity = SearchIndexerDataNoneIdentity | SearchIndexerDataUserAssignedIdentity;
	
	export type SearchIndexerDataSourceType = `${KnownSearchIndexerDataSourceType}`;
	
	export type SearchIndexerSkill = AzureMachineLearningSkill | AzureOpenAIEmbeddingSkill | ConditionalSkill | CustomEntityLookupSkill | DocumentExtractionSkill | DocumentIntelligenceLayoutSkill | EntityLinkingSkill | EntityRecognitionSkill | EntityRecognitionSkillV3 | ImageAnalysisSkill | KeyPhraseExtractionSkill | LanguageDetectionSkill | MergeSkill | OcrSkill | PIIDetectionSkill | SentimentSkill | SentimentSkillV3 | ShaperSkill | SplitSkill | TextTranslationSkill | VisionVectorizeSkill | WebApiSkill;
	
	export type SearchIndexingBufferedSenderDeleteDocumentsOptions = OperationOptions;
	
	export type SearchIndexingBufferedSenderFlushDocumentsOptions = OperationOptions;
	
	export type SearchIndexingBufferedSenderMergeDocumentsOptions = OperationOptions;
	
	export type SearchIndexingBufferedSenderMergeOrUploadDocumentsOptions = OperationOptions;
	
	export type SearchIndexingBufferedSenderUploadDocumentsOptions = OperationOptions;
	
	export type SearchIterator<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = PagedAsyncIterableIterator<SearchResult<TModel, TFields>, SearchDocumentsPageResult<TModel, TFields>, ListSearchResultsPageSettings>;
	
	export type SearchMode = "any" | "all";
	
	export type SearchOptions<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = OperationOptions & SearchRequestOptions<TModel, TFields>;
	
	export type SearchPick<TModel extends object, TFields extends SelectFields<TModel>> = (<T>() => T extends TModel ? true : false) extends <T>() => T extends object ? true : false ? TModel : (<T>() => T extends TFields ? true : false) extends <T>() => T extends any ? true : false ? TModel : (<T>() => T extends TFields ? true : false) extends <T>() => T extends never ? true : false ? TModel : // We're going to get a union of individual interfaces for each field in T that's selected, so convert that to an intersection.
		UnionToIntersection<TFields extends `${infer FieldName}/${infer RestPaths}` ? FieldName extends keyof TModel & string ? NonNullable<TModel[FieldName]> extends Array<infer Elem> ? Elem extends object ? RestPaths extends SelectFields<Elem> ? {
		    [Key in keyof TModel as Key & FieldName]: Array<SearchPick<Elem, RestPaths>>;
		} : never : never : NonNullable<TModel[FieldName]> extends object ? {
		    [Key in keyof TModel as Key & FieldName]: RestPaths extends SelectFields<TModel[Key] & {}> ? SearchPick<TModel[Key] & {}, RestPaths> | Extract<TModel[Key], null> : never;
		} : never : never : TFields extends keyof TModel ? Pick<TModel, TFields> | Extract<TModel, null> : never> & {};
	
	export type SearchRequestOptions<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = BaseSearchRequestOptions<TModel, TFields> & SearchRequestQueryTypeOptions;
	
	export type SearchRequestQueryTypeOptions = {
		    queryType: "semantic";
		    semanticSearchOptions: SemanticSearchOptions;
		} | {
		    queryType?: "simple" | "full";
		};
	
	export type SearchResult<TModel extends object, TFields extends SelectFields<TModel>= SelectFields<TModel>> = {
		    readonly score: number;
		    readonly rerankerScore?: number;
		    readonly highlights?: {
		        [k in SelectFields<TModel>]?: string[];
		    };
		    readonly captions?: QueryCaptionResult[];
		    document: NarrowedModel<TModel, TFields>;
		    readonly documentDebugInfo?: DocumentDebugInfo;
		};
	
	export type SelectArray<TFields = never> = [string] extends [TFields] ? readonly TFields[] : (<T>() => T extends TFields ? true : false) extends <T>() => T extends never ? true : false ? readonly string[] : readonly TFields[];
	
	export type SelectFields<TModel extends object> = (<T>() => T extends TModel ? true : false) extends <T>() => T extends never ? true : false ? string : (<T>() => T extends TModel ? true : false) extends <T>() => T extends any ? true : false ? string : (<T>() => T extends TModel ? true : false) extends <T>() => T extends object ? true : false ? string : TModel extends Array<infer Elem> ? Elem extends object ? SelectFields<Elem> : never : {
		    [Key in keyof TModel]: Key extends string ? NonNullable<TModel[Key]> extends object ? NonNullable<TModel[Key]> extends ExcludedODataTypes? Key : SelectFields<NonNullable<TModel[Key]>> extends infer NextPaths ? (<T>() => T extends NextPaths ? true : false) extends <T>() => T extends never ? true : false ? Key : NextPaths extends string ? Key | `${Key}/${NextPaths}` : Key : never : Key : never;
		}[keyof TModel & string] & string;
	
	export type SemanticErrorMode = `${KnownSemanticErrorMode}`;
	
	export type SemanticErrorReason = `${KnownSemanticErrorReason}`;
	
	export type SemanticFieldState = string;
	
	export type SemanticQueryRewritesResultType = string;
	
	export type SemanticSearchResultsType = `${KnownSemanticSearchResultsType}`;
	
	export type SentimentSkillLanguage = `${KnownSentimentSkillLanguage}`;
	
	export type SimilarityAlgorithm = ClassicSimilarity | BM25Similarity;
	
	export type SnowballTokenFilterLanguage = "armenian" | "basque" | "catalan" | "danish" | "dutch" | "english" | "finnish" | "french" | "german" | "german2" | "hungarian" | "italian" | "kp" | "lovins" | "norwegian" | "porter" | "portuguese" | "romanian" | "russian" | "spanish" | "swedish" | "turkish";
	
	export type SplitSkillEncoderModelName = string;
	
	export type SplitSkillLanguage = `${KnownSplitSkillLanguage}`;
	
	export type SplitSkillUnit = string;
	
	export type StemmerTokenFilterLanguage = "arabic" | "armenian" | "basque" | "brazilian" | "bulgarian" | "catalan" | "czech" | "danish" | "dutch" | "dutchKp" | "english" | "lightEnglish" | "minimalEnglish" | "possessiveEnglish" | "porter2" | "lovins" | "finnish" | "lightFinnish" | "french" | "lightFrench" | "minimalFrench" | "galician" | "minimalGalician" | "german" | "german2" | "lightGerman" | "minimalGerman" | "greek" | "hindi" | "hungarian" | "lightHungarian" | "indonesian" | "irish" | "italian" | "lightItalian" | "sorani" | "latvian" | "norwegian" | "lightNorwegian" | "minimalNorwegian" | "lightNynorsk" | "minimalNynorsk" | "portuguese" | "lightPortuguese" | "minimalPortuguese" | "portugueseRslp" | "romanian" | "russian" | "lightRussian" | "spanish" | "lightSpanish" | "swedish" | "lightSwedish" | "turkish";
	
	export type StopwordsList = "arabic" | "armenian" | "basque" | "brazilian" | "bulgarian" | "catalan" | "czech" | "danish" | "dutch" | "english" | "finnish" | "french" | "galician" | "german" | "greek" | "hindi" | "hungarian" | "indonesian" | "irish" | "italian" | "latvian" | "norwegian" | "persian" | "portuguese" | "romanian" | "russian" | "sorani" | "spanish" | "swedish" | "thai" | "turkish";
	
	export type SuggestNarrowedModel<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = (<T>() => T extends TModel ? true : false) extends <T>() => T extends never ? true : false ? TModel : (<T>() => T extends TModel ? true : false) extends <T>() => T extends object ? true : false ? TModel : (<T>() => T extends TFields ? true : false) extends <T>() => T extends never ? true : false ? keyof ExtractDocumentKey<TModel> extends never ? TModel : ExtractDocumentKey<TModel> : TFields extends SelectFields<TModel> ? NarrowedModel<TModel, TFields> : never;
	
	export type SuggestOptions<TModel extends object, TFields extends SelectFields<TModel> = SelectFields<TModel>> = OperationOptions & SuggestRequest<TModel, TFields>;
	
	export type SuggestResult<TModel extends object, TFields extends SelectFields<TModel>= SelectFields<TModel>> = {
		    readonly text: string;
		    document: SuggestNarrowedModel<TModel, TFields>;
		};
	
	export type TextSplitMode = `${KnownTextSplitMode}`;
	
	export type TextTranslationSkillLanguage = `${KnownTextTranslationSkillLanguage}`;
	
	export type TokenCharacterKind = "letter" | "digit" | "whitespace" | "punctuation" | "symbol";
	
	export type TokenFilter = AsciiFoldingTokenFilter | CjkBigramTokenFilter | CommonGramTokenFilter | DictionaryDecompounderTokenFilter | EdgeNGramTokenFilter | ElisionTokenFilter | KeepTokenFilter | KeywordMarkerTokenFilter | LengthTokenFilter | LimitTokenFilter | NGramTokenFilter | PatternCaptureTokenFilter | PatternReplaceTokenFilter | PhoneticTokenFilter | ShingleTokenFilter | SnowballTokenFilter | StemmerTokenFilter | StemmerOverrideTokenFilter | StopwordsTokenFilter | SynonymTokenFilter | TruncateTokenFilter | UniqueTokenFilter | WordDelimiterTokenFilter;
	
	export type TokenFilterName = string;
	
	export type UnionToIntersection<Union> = (Union extends unknown ? (_: Union) => unknown : never) extends (_: infer I) => unknown ? I : never;
	
	export type UploadDocumentsOptions = IndexDocumentsOptions;
	
	export type VectorEncodingFormat = string;
	
	export type VectorFilterMode = `${KnownVectorFilterMode}`;
	
	export type VectorQuery<TModel extends object> = VectorizedQuery<TModel> | VectorizableTextQuery<TModel> | VectorizableImageUrlQuery<TModel> | VectorizableImageBinaryQuery<TModel>;
	
	export type VectorQueryKind = `${KnownVectorQueryKind}`;
	
	export type VectorSearchAlgorithmConfiguration = HnswAlgorithmConfiguration | ExhaustiveKnnAlgorithmConfiguration;
	
	export type VectorSearchAlgorithmKind = `${KnownVectorSearchAlgorithmKind}`;
	
	export type VectorSearchAlgorithmMetric = `${KnownVectorSearchAlgorithmMetric}`;
	
	export type VectorSearchCompression = BinaryQuantizationCompression | ScalarQuantizationCompression;
	
	export type VectorSearchCompressionKind = string;
	
	export type VectorSearchCompressionRescoreStorageMethod = string;
	
	export type VectorSearchCompressionTarget = string;
	
	export type VectorSearchVectorizer = AIServicesVisionVectorizer | AzureMachineLearningVectorizer | AzureOpenAIVectorizer | WebApiVectorizer;
	
	export type VectorSearchVectorizerKind = string;
	
	export type VectorThreshold = VectorSimilarityThreshold | SearchScoreThreshold;
	
	export type VisualFeature = `${KnownVisualFeature}`;
	
	export const DEFAULT_BATCH_SIZE: number
	export const DEFAULT_FLUSH_WINDOW: number
	export const DEFAULT_RETRY_COUNT: number
