# -------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for
# license information.
# --------------------------------------------------------------------------

import asyncio
import re
import sys
from dataclasses import dataclass, field
from typing import Optional

import httpx
from azure.cosmos import CosmosClient
from azure.cosmos.exceptions import CosmosHttpResponseError
from src._credential import get_credential
from src._utils import get_language_pretty_name, to_iso8601

# Maps AICommentFeedbackReason enum values to human-readable messages.
# Mirrors the C# ApiView structure (CommentFeedbackRequest.cs).
FEEDBACK_REASON_MESSAGES = {
    "FactuallyIncorrect": "This comment is factually incorrect.",
    "RenderingBug": "This is a rendering bug in the associated language parser. Please open an issue to correct.",
    "AcceptedRenderingChoice": (
        "This is how things are deliberately rendered in APIView. It is not a valid comment."
    ),
    "AcceptedSDKPattern": "This is a pattern we accept and encourage in our SDKs. DO NOT suggest otherwise.",
    "OutdatedGuideline": (
        "This is a valid comment for the guideline listed, but this guideline itself is out-of-date."
        " Please open an issue."
    ),
}


def get_version_type(version: Optional[str]) -> str:
    """
    Determines if a version string represents a GA or beta version.

    GA versions follow the pattern X.X.X (only numbers and dots).
    Beta versions contain pre-release identifiers like:
    - Python: x.x.xbxxxx
    - Java: x.x.x-beta.x
    - C#: x.x.x-alpha.xxx or -beta.xxx or -dev.xxx
    - JavaScript: x.x.x-beta.x
    - Others: any version containing alpha, beta, rc, dev, preview, etc.

    Returns:
        "GA" for stable releases, "beta" for pre-release versions
    """
    if not version:
        return "unknown"

    version_lower = version.lower()

    # Check for common pre-release indicators
    pre_release_indicators = ["alpha", "beta", "rc", "dev", "preview", "snapshot", "nightly", "canary", "pre"]

    for indicator in pre_release_indicators:
        if indicator in version_lower:
            return "beta"

    # Check for Python-style beta versions (e.g., 1.0.0b1)
    if "b" in version_lower:
        # Check if 'b' appears after digits (indicating beta)
        if re.search(r"\d+b\d+", version_lower):
            return "beta"

    # Check for 0.x.x versions - these are not GA per semantic versioning
    if re.match(r"^0\.", version):
        return "beta"

    # If no pre-release indicators found, consider it GA
    return "GA"


_APIVIEW_COMMENT_SELECT_FIELDS = [
    "id",
    "CreatedOn",
    "CreatedBy",
    "CommentText",
    "IsResolved",
    "IsDeleted",
    "ElementId",
    "ReviewId",
    "APIRevisionId",
    "Upvotes",
    "Downvotes",
    "CommentType",
    "CommentSource",
]
APIVIEW_COMMENT_SELECT_FIELDS = [f"c.{field}" for field in _APIVIEW_COMMENT_SELECT_FIELDS]


@dataclass
class ActiveRevisionMetadata:
    """Metadata for an active revision grouped by package version."""

    revision_ids: list[str]
    package_version: Optional[str]
    approval: Optional[str] = None  # ISO datetime string if approved during period, None otherwise
    has_copilot_review: bool = False  # True if any revision has HasAutoGeneratedComments=true
    version_type: str = "unknown"  # "GA", "beta", or "unknown"


@dataclass
class ActiveReviewMetadata:
    review_id: str
    name: Optional[str]
    language: str
    revisions: list[ActiveRevisionMetadata] = field(default_factory=list)

    def __post_init__(self):
        # Ensure pretty language name normalization
        self.language = get_language_pretty_name(self.language)


selection_type = {
    "Latest": 1,
    "LatestApproved": 2,
    "LatestAutomatic": 3,
    "LatestManual": 4,
}


class ApiViewClient:
    """Client for interacting with the API View service."""

    def __init__(self, environment: str = "production"):
        self.environment = environment

    async def get_revision_text(
        self, *, revision_id: Optional[str] = None, review_id: Optional[str] = None, label: Optional[str] = None
    ) -> str:
        """
        Get the text of an API revision.
        Args:
            revision_id (str): The ID of the API revision to retrieve.
            review_id (str): The ID of the API review to retrieve.
            label (str): Used in conjunction with review_id to specify which revision to get. Defaults to "Latest".
        """
        endpoint = "/api/apirevisions/getRevisionContent?"

        if revision_id:
            if review_id or label:
                raise ValueError("revision_id cannot be used with review_id or label.")
            endpoint += f"apiRevisionId={revision_id}"
        elif review_id:
            if not label:
                label = "Latest"
            if label not in selection_type:
                raise ValueError(f"Invalid label '{label}'. Must be one of {list(selection_type.keys())}.")
            endpoint += f"apiReviewId={review_id}&label={selection_type[label]}"
        else:
            raise ValueError("Either revision_id or review_id must be provided.")
        return await self.send_request(endpoint)

    async def get_revision_outline(self, revision_id: str) -> str:
        """
        Get the outline for a given API revision.
        Args:
            revision_id (str): The ID of the API revision to retrieve.
        """
        return await self.send_request(f"/api/apirevisions/{revision_id}/outline")

    async def get_review_comments(self, revision_id: str) -> str:
        """
        Get the comments visible for a given API review.
        Args:
            revision_id (str): The ID of the API revision to retrieve comments for. Comments that are "visible"
                               from that revision will be returned.
        """
        endpoint = f"/api/comments/getRevisionComments?apiRevisionId={revision_id}"
        return await self.send_request(endpoint)

    async def send_request(self, endpoint: str):
        # strip leading /
        if endpoint.startswith("/"):
            endpoint = endpoint[1:]

        apiview_endpoints = {
            "production": "https://apiview.org",
            "staging": "https://apiviewstagingtest.com",
        }
        endpoint_root = apiview_endpoints.get(self.environment)
        endpoint = f"{endpoint_root}/{endpoint}"
        apiview_scopes = {
            "production": "api://apiview/.default",
            "staging": "api://apiviewstaging/.default",
        }
        credential = get_credential()
        scope = apiview_scopes.get(self.environment)
        token = await asyncio.to_thread(credential.get_token, scope)

        async with httpx.AsyncClient(timeout=30) as client:
            resp = await client.get(endpoint, headers={"Authorization": f"Bearer {token.token}"})
            resp.raise_for_status()
            return resp.json()


def get_apiview_cosmos_client(container_name: str, environment: str = "production", db_name: str = "APIViewV2"):
    """
    Returns the Cosmos DB container client for the specified container and environment.
    """
    apiview_account_names = {
        "production": "apiview-cosmos",
        "staging": "apiviewstaging",
    }
    try:
        cosmos_acc = apiview_account_names.get(environment)
        cosmos_db = db_name
        if not cosmos_acc:
            raise ValueError(
                # pylint: disable=line-too-long
                f"Unrecognized environment: {environment}. Valid options are: {', '.join(apiview_account_names.keys())}."
            )
        cosmos_url = f"https://{cosmos_acc}.documents.azure.com:443/"
        client = CosmosClient(url=cosmos_url, credential=get_credential())
        database = client.get_database_client(cosmos_db)
        container = database.get_container_client(container_name)
        return container
    except CosmosHttpResponseError as e:
        if e.status_code == 403:
            print(
                # pylint: disable=line-too-long
                "Error: You do not have permission to access Cosmos DB.\nTo grant yourself access, run: python scripts\\apiview_permissions.py"
            )
        sys.exit(1)


def get_active_reviews(
    start_date: str,
    end_date: str,
    *,
    environment: str = "production",
    omit_languages: Optional[list[str]] = None,
) -> list[ActiveReviewMetadata]:
    """
    Lists distinct active APIView review IDs in the specified environment during the specified period.
    The definition of "active" is any review that has comments created during the time period.
    For each active review, also returns the active revisions (those with comments in the period)
    along with their package versions.

    Returns:
        list[ActiveReviewMetadata] - list of metadata objects considered "active" during the query window,
                                     including active revisions with package versions.
    """
    metadata: list[ActiveReviewMetadata] = []

    # Get comments in the date range
    comments = get_comments_in_date_range(start_date, end_date, environment=environment)

    # Extract unique review IDs and revision IDs from comments
    review_ids = set()
    revision_ids = set()
    review_to_revisions = {}  # Maps review_id -> set of revision_ids

    for comment in comments:
        review_id = comment.get("ReviewId")
        revision_id = comment.get("APIRevisionId")

        if review_id:
            review_ids.add(review_id)

            if revision_id:
                revision_ids.add(revision_id)
                if review_id not in review_to_revisions:
                    review_to_revisions[review_id] = set()
                review_to_revisions[review_id].add(revision_id)

    if not review_ids:
        return metadata

    # Query Reviews container for review metadata
    reviews_container = get_apiview_cosmos_client(container_name="Reviews", environment=environment)

    # Build a parameterized OR query to fetch matching reviews
    params = []
    clauses = []
    for i, rid in enumerate(review_ids):
        param_name = f"@id_{i}"
        clauses.append(f"c.id = {param_name}")
        params.append({"name": param_name, "value": rid})

    query = f"SELECT c.id, c.PackageName, c.Language FROM c WHERE ({' OR '.join(clauses)})"
    review_results = list(
        reviews_container.query_items(query=query, parameters=params, enable_cross_partition_query=True)
    )

    # Query APIRevisions container for revision metadata
    revisions_container = get_apiview_cosmos_client(container_name="APIRevisions", environment=environment)

    revision_params = []
    revision_clauses = []
    for i, rev_id in enumerate(revision_ids):
        param_name = f"@rev_id_{i}"
        revision_clauses.append(f"c.id = {param_name}")
        revision_params.append({"name": param_name, "value": rev_id})

    revision_query = f"SELECT c.id, c.ReviewId, c.packageVersion, c.ChangeHistory, c.HasAutoGeneratedComments FROM c WHERE ({' OR '.join(revision_clauses)})"
    revision_results = list(
        revisions_container.query_items(
            query=revision_query, parameters=revision_params, enable_cross_partition_query=True
        )
    )

    # Convert date strings to ISO format for comparison
    start_iso = to_iso8601(start_date)
    end_iso = to_iso8601(end_date, end_of_day=True)

    # Build a map of revision_id -> revision metadata including approval
    revision_map = {}
    for rev in revision_results:
        approval = None
        change_history = rev.get("ChangeHistory", [])

        # Find the most recent approval within the date range
        if change_history and isinstance(change_history, list):
            for change in sorted(change_history, key=lambda x: x.get("ChangedOn", ""), reverse=True):
                if change.get("ChangeAction") == "Approved":
                    changed_on = change.get("ChangedOn")
                    # Check if approval is within the date window
                    if changed_on and start_iso <= changed_on <= end_iso:
                        approval = changed_on
                        break

        pkg_version = rev.get("packageVersion")
        revision_map[rev["id"]] = {
            "review_id": rev.get("ReviewId"),
            "package_version": pkg_version,
            "approval": approval,
            "has_auto_generated_comments": rev.get("HasAutoGeneratedComments", False),
            "version_type": get_version_type(pkg_version),
        }

    # Build metadata for each review
    for result in review_results:
        review_id = result["id"]
        review_name = result.get("PackageName")
        language = get_language_pretty_name(result.get("Language", "Unknown"))

        if language == "Java" and review_name and review_name.startswith("com.azure.android:"):
            # APIView does not distinguish between Java and Android at the review level, but we need to
            language = "Android"

        # Get active revisions for this review, grouped by package_version
        active_revisions = []
        if review_id in review_to_revisions:
            # Group revision IDs by package version
            version_to_revisions = {}
            for rev_id in review_to_revisions[review_id]:
                if rev_id in revision_map:
                    rev_data = revision_map[rev_id]
                    pkg_version = rev_data["package_version"]
                    if pkg_version not in version_to_revisions:
                        version_to_revisions[pkg_version] = []
                    version_to_revisions[pkg_version].append(rev_id)

            # Create ActiveRevisionMetadata for each package version
            for pkg_version, rev_ids in version_to_revisions.items():
                # Get the most recent approval timestamp from all revisions in this package version
                approvals = [revision_map[rev_id].get("approval") for rev_id in rev_ids if rev_id in revision_map]
                most_recent_approval = max((a for a in approvals if a is not None), default=None)

                # Check if any revision in this package version has auto-generated comments
                has_copilot = any(
                    revision_map[rev_id].get("has_auto_generated_comments", False)
                    for rev_id in rev_ids
                    if rev_id in revision_map
                )

                active_revisions.append(
                    ActiveRevisionMetadata(
                        revision_ids=rev_ids,
                        package_version=pkg_version,
                        approval=most_recent_approval,
                        has_copilot_review=has_copilot,
                        version_type=get_version_type(pkg_version),
                    )
                )

        metadata.append(
            ActiveReviewMetadata(review_id=review_id, name=review_name, language=language, revisions=active_revisions)
        )

    # Filter out omitted languages if specified
    if omit_languages:
        omit_lower = {l.lower() for l in omit_languages}
        metadata = [r for r in metadata if r.language.lower() not in omit_lower]

    return metadata


def get_active_review_ids(start_date: str, end_date: str, environment: str = "production") -> list:
    """
    Lists distinct active APIView review IDs in the specified environment during the specified period.
    The definition of "active" is any review that has comments created during the time period.

    Returns:
        list[str] - list of unique ReviewId values considered "active" during the query window.
    """
    try:
        comments = get_comments_in_date_range(start_date, end_date, environment=environment)
    except Exception as e:
        print(f"Error retrieving active reviews: {e}")
        return []

    review_ids = set()
    for comment in comments:
        review_id = comment.get("ReviewId")
        if review_id:
            review_ids.add(review_id)

    return list(review_ids)


def get_comments_in_date_range(start_date: str, end_date: str, environment: str = "production") -> list:
    """
    Retrieves all comments created within the specified date range in the given environment.
    Applies ISO8601 midnight/end-of-day formatting to start_date and end_date.
    """
    start_iso = to_iso8601(start_date)
    end_iso = to_iso8601(end_date, end_of_day=True)

    comments_client = get_apiview_cosmos_client(container_name="Comments", environment=environment)
    result = comments_client.query_items(
        query=f"SELECT {', '.join(APIVIEW_COMMENT_SELECT_FIELDS)} FROM c WHERE c.CreatedOn >= @start_date AND c.CreatedOn <= @end_date",
        parameters=[
            {"name": "@start_date", "value": start_iso},
            {"name": "@end_date", "value": end_iso},
        ],
        enable_cross_partition_query=True,
    )
    return list(result)


def get_approvers(*, language: str = None, environment: str = "production") -> set[str]:
    """
    Retrieves the set of profile ids for approvers based on ApprovedLanguages.
    If language is specified, returns profile ids where ApprovedLanguages contains the language.
    If no language is specified, returns all profile ids with non-empty ApprovedLanguages.
    """
    profiles_client = get_apiview_cosmos_client(container_name="Profiles", environment=environment, db_name="APIView")
    query = "SELECT c.id, c.Preferences FROM c"
    parameters = []
    result = profiles_client.query_items(
        query=query,
        parameters=parameters,
        enable_cross_partition_query=True,
    )

    approver_ids = set()
    for item in result:
        preferences = item.get("Preferences", {})
        approved_languages = preferences.get("ApprovedLanguages", [])
        if not approved_languages:
            continue
        if language:
            if language in approved_languages:
                approver_ids.add(item.get("id"))
        else:
            approver_ids.add(item.get("id"))

    return approver_ids


def get_ai_comment_feedback(
    language: str,
    start_date: str,
    end_date: str,
    exclude: Optional[list[str]] = None,
    environment: str = "production",
) -> list[dict]:
    """
    Retrieves AI-generated comments that received feedback within the specified date range.

    The date range filters by when feedback was submitted:
    - For detailed feedback: checks Feedback[].SubmittedOn
    - For deletions: checks ChangeHistory[].ChangedOn where ChangeAction='Deleted'

    Note: Upvotes/Downvotes lists don't have timestamps, so comments with only
    upvotes/downvotes (and no Feedback entries or deletion events in the date range)
    will not be returned.

    Args:
        language: Language to filter by (e.g., 'python', 'java')
        start_date: Start date in YYYY-MM-DD format (filters by feedback submission time)
        end_date: End date in YYYY-MM-DD format (filters by feedback submission time)
        exclude: List of feedback types to exclude. Can include 'good', 'bad', 'delete'.
        environment: The APIView environment ('production' or 'staging')

    Returns:
        List of dicts containing comment info and feedback, preserving database field names
    """
    exclude = exclude or []
    start_iso = to_iso8601(start_date)
    end_iso = to_iso8601(end_date, end_of_day=True)

    # Query for AI-generated comments that have feedback submitted in the date range
    # Uses EXISTS to check Feedback[].SubmittedOn or ChangeHistory[].ChangedOn
    comments_client = get_apiview_cosmos_client(container_name="Comments", environment=environment)

    query = """
        SELECT c.id, c.ReviewId, c.APIRevisionId, c.ElementId, c.ThreadId,
               c.CommentText, c.CorrelationId, c.ChangeHistory, c.IsResolved,
               c.Upvotes, c.Downvotes, c.TaggedUsers, c.CommentType, c.Severity,
               c.CommentSource, c.ResolutionLocked, c.CreatedBy, c.CreatedOn,
               c.IsDeleted, c.IsGeneric, c.GuidelineIds, c.MemoryIds,
               c.ConfidenceScore, c.Feedback
        FROM c 
        WHERE c.CommentSource = 'AIGenerated'
        AND (
            EXISTS(SELECT VALUE f FROM f IN c.Feedback 
                   WHERE f.SubmittedOn >= @start_date AND f.SubmittedOn <= @end_date)
            OR EXISTS(SELECT VALUE ch FROM ch IN c.ChangeHistory 
                      WHERE ch.ChangedOn >= @start_date AND ch.ChangedOn <= @end_date
                      AND ch.ChangeAction = 'Deleted')
        )
    """

    comments = list(
        comments_client.query_items(
            query=query,
            parameters=[
                {"name": "@start_date", "value": start_iso},
                {"name": "@end_date", "value": end_iso},
            ],
            enable_cross_partition_query=True,
        )
    )

    # Get review IDs to look up languages
    review_ids = set(c.get("ReviewId") for c in comments if c.get("ReviewId"))

    # Query Reviews container for language info
    reviews_container = get_apiview_cosmos_client(container_name="Reviews", environment=environment)
    review_lang_map = {}

    if review_ids:
        params = []
        clauses = []
        for i, rid in enumerate(review_ids):
            param_name = f"@id_{i}"
            clauses.append(f"c.id = {param_name}")
            params.append({"name": param_name, "value": rid})

        review_query = f"SELECT c.id, c.Language FROM c WHERE ({' OR '.join(clauses)})"
        review_results = list(
            reviews_container.query_items(query=review_query, parameters=params, enable_cross_partition_query=True)
        )
        review_lang_map = {r["id"]: get_language_pretty_name(r.get("Language", "")) for r in review_results}

    # Normalize target language
    target_language = get_language_pretty_name(language).lower()

    # Filter comments by language and feedback presence
    result = []
    for comment in comments:
        # Check language
        review_id = comment.get("ReviewId", "")
        comment_language = review_lang_map.get(review_id, "").lower()
        if comment_language != target_language:
            continue

        # Determine feedback type based on Upvotes, Downvotes, and IsDeleted
        upvotes = comment.get("Upvotes") or []
        downvotes = comment.get("Downvotes") or []
        is_deleted = comment.get("IsDeleted", False)

        has_good = len(upvotes) > 0
        has_bad = len(downvotes) > 0
        has_delete = is_deleted is True

        # Skip if no feedback at all
        if not (has_good or has_bad or has_delete):
            continue

        # Determine feedback categories for this comment
        feedback_types = []
        if has_good:
            feedback_types.append("good")
        if has_bad:
            feedback_types.append("bad")
        if has_delete:
            feedback_types.append("delete")

        # Apply exclude filters - skip if ALL feedback types are excluded
        remaining_feedback = [ft for ft in feedback_types if ft not in exclude]
        if not remaining_feedback:
            continue

        # Return the comment with original field names, adding feedback_types for filtering convenience
        comment["FeedbackTypes"] = feedback_types
        result.append(comment)

    return result


def resolve_package(
    package_query: str, language: str, version: Optional[str] = None, environment: str = "production"
) -> Optional[dict]:
    """
    Resolves package information from a package query and language.

    Args:
        package_query: Package name or description to search for
        language: Language of the package (e.g., 'python', 'java')
        version: Optional version to filter by. If omitted, the latest revision will be returned.
        environment: The APIView environment ('production' or 'staging')

    Returns:
        A dict containing:
        - package_name: The actual package name
        - review_id: The review ID
        - language: The language
        - version: The package version, if available
        - revision_id: The relevant revision ID, if available
        - revision_label: The associated revision label, if available

        Returns None if no matching package is found.
    """
    from src._utils import run_prompty

    try:
        reviews_container = get_apiview_cosmos_client(container_name="Reviews", environment=environment)

        # Normalize the language for comparison
        pretty_language = get_language_pretty_name(language)

        # Fetch all packages for this language in a single query
        all_packages_query = """
            SELECT c.id, c.PackageName, c.Language, c.packageVersion
            FROM c 
            WHERE c.Language = @language
        """
        all_packages_params = [{"name": "@language", "value": pretty_language}]

        all_results = list(
            reviews_container.query_items(
                query=all_packages_query, parameters=all_packages_params, enable_cross_partition_query=True
            )
        )

        if not all_results:
            return {"error": "no_packages_for_language", "language": pretty_language}

        # Check for exact match first (case-insensitive)
        selected_review = None
        package_query_lower = package_query.lower()
        for result in all_results:
            if result.get("PackageName", "").lower() == package_query_lower:
                selected_review = result
                break

        # If no exact match, use LLM to find best match
        if not selected_review:
            # Extract package names
            available_packages = [r.get("PackageName", "") for r in all_results if r.get("PackageName")]

            # Use LLM to find the best match
            try:
                llm_result = run_prompty(
                    folder="other",
                    filename="resolve_package.prompty",
                    inputs={
                        "package_query": package_query,
                        "language": pretty_language,
                        "available_packages": available_packages,
                    },
                )

                matched_package = llm_result.strip()

                if matched_package == "NO_MATCH":
                    return None

                # Find the review for the matched package (case-insensitive, like exact match above)
                matched_package_lower = matched_package.lower()
                for result in all_results:
                    if result.get("PackageName", "").lower() == matched_package_lower:
                        selected_review = result
                        break
            except Exception as e:
                print(f"Error using LLM for package matching: {e}")
                return None

        if not selected_review:
            return None

        review_id = selected_review["id"]
        package_name = selected_review.get("PackageName", "")

        # Now get the revisions for this review from the APIRevisions container
        revisions_container = get_apiview_cosmos_client(container_name="APIRevisions", environment=environment)

        selected_revision = None

        # If version is specified, query directly for that version
        if version:
            versioned_query = """
                SELECT c.id, c.Name, c.Label, c.CreatedOn, c.packageVersion, c._ts
                FROM c
                WHERE c.ReviewId = @review_id AND c.packageVersion = @version
                ORDER BY c._ts DESC
            """
            versioned_params = [{"name": "@review_id", "value": review_id}, {"name": "@version", "value": version}]

            versioned_revisions = list(
                revisions_container.query_items(
                    query=versioned_query, parameters=versioned_params, enable_cross_partition_query=True
                )
            )

            if versioned_revisions:
                selected_revision = versioned_revisions[0]  # Most recent with matching version

        # If no version specified or no match found, get the most recent revision with a packageVersion
        if not selected_revision:
            latest_query = """
                SELECT c.id, c.Name, c.Label, c.CreatedOn, c.packageVersion, c._ts
                FROM c
                WHERE c.ReviewId = @review_id 
                AND IS_DEFINED(c.packageVersion) 
                AND c.packageVersion != null 
                AND c.packageVersion != ""
                ORDER BY c._ts DESC
            """
            latest_params = [{"name": "@review_id", "value": review_id}]

            latest_revisions = list(
                revisions_container.query_items(
                    query=latest_query, parameters=latest_params, enable_cross_partition_query=True
                )
            )

            if not latest_revisions:
                return {
                    "package_name": package_name,
                    "review_id": review_id,
                    "revision_id": None,
                    "language": pretty_language,
                    "version": None,
                    "revision_label": None,
                }

            selected_revision = latest_revisions[0]

        # Get the version from the selected revision
        revision_version = selected_revision.get("packageVersion", "")

        return {
            "package_name": package_name,
            "review_id": review_id,
            "revision_id": selected_revision["id"],
            "language": pretty_language,
            "version": revision_version,
            "revision_label": selected_revision.get("Label", ""),
        }
    except Exception as e:
        print(f"Error resolving package: {e}")
        return None


def _extract_code_for_element(full_text: str, element_id: Optional[str], context_lines: int = 5) -> Optional[str]:
    """
    Extract the code line matching the ElementId from the full APIView revision text,
    plus surrounding context lines.

    The APIView text has lines of the form "123: <code>" where 123 is a line number.
    The ElementId is a semantic identifier (e.g.,
    "com.azure.cosmos.models.QuantizerType.public-String-toString()") that encodes part
    of the code on the line it's attached to.

    If no match is found, falls back to the ElementId itself.

    Args:
        full_text: The full APIView revision text
        element_id: The ElementId from the comment
        context_lines: Number of lines of context to include before and after the matched line

    Returns:
        The extracted code snippet, or None if no text is available
    """
    if not full_text:
        return None

    if not element_id:
        return None

    lines = full_text.splitlines()

    # Build search terms from the ElementId by extracting the meaningful parts.
    # ElementIds look like:
    #   "com.azure.cosmos.models.QuantizerType.public-String-toString()"
    #   "maven-lineid-properties-com.azure:azure-json:1.5.1"
    # We replace hyphens with spaces so that hyphen-separated tokens become
    # individual search words, then score each APIView line by how many of
    # those words it contains.  The line with the highest score wins.
    search_parts = element_id.replace("-", " ").replace("(", " ").replace(")", " ")

    best_idx = None
    best_score = 0
    search_words = [w.lower() for w in search_parts.split() if len(w) > 1]

    for i, line in enumerate(lines):
        # Strip the line number prefix if present (e.g., "123: ")
        stripped = re.sub(r"^\d+:\s*", "", line).strip()
        if not stripped:
            continue

        # Score: count how many words from the search_parts appear in the line
        line_lower = stripped.lower()
        score = sum(1 for w in search_words if w in line_lower)

        if score > best_score:
            best_score = score
            best_idx = i

    if best_idx is not None and best_score > 0:
        start = max(0, best_idx - context_lines)
        end = min(len(lines), best_idx + context_lines + 1)
        return "\n".join(lines[start:end])

    # Fallback: return the ElementId as-is for context
    return element_id


def get_comment_with_context(comment_id: str, environment: str = "production") -> Optional[dict]:
    """
    Retrieves a comment by its ID from the APIView database along with its related context
    (language, package_name, code, feedback).

    This is useful for processing feedback on AI-generated comments that were recorded
    in the database but not acted upon.

    Args:
        comment_id: The unique identifier of the comment
        environment: The APIView environment ('production' or 'staging')

    Returns:
        A dict containing:
        - comment: The full comment object from the database
        - language: The pretty language name (e.g., "Python")
        - package_name: The package name from the review
        - code: The API code from the revision (if available)
        - feedback_text: A manufactured feedback message based on the Feedback entries

        Returns None if the comment is not found.
    """
    try:
        # Fetch the comment from the Comments container
        comments_container = get_apiview_cosmos_client(container_name="Comments", environment=environment)

        query = """
            SELECT c.id, c.ReviewId, c.APIRevisionId, c.ElementId, c.ThreadId,
                   c.CommentText, c.CorrelationId, c.ChangeHistory, c.IsResolved,
                   c.Upvotes, c.Downvotes, c.TaggedUsers, c.CommentType, c.Severity,
                   c.CommentSource, c.ResolutionLocked, c.CreatedBy, c.CreatedOn,
                   c.IsDeleted, c.IsGeneric, c.GuidelineIds, c.MemoryIds,
                   c.ConfidenceScore, c.Feedback
            FROM c WHERE c.id = @comment_id
        """
        results = list(
            comments_container.query_items(
                query=query,
                parameters=[{"name": "@comment_id", "value": comment_id}],
                enable_cross_partition_query=True,
            )
        )

        if not results:
            return None

        comment = results[0]
        review_id = comment.get("ReviewId")
        revision_id = comment.get("APIRevisionId")

        # Get language and package name from Reviews container
        language = None
        package_name = None
        if review_id:
            reviews_container = get_apiview_cosmos_client(container_name="Reviews", environment=environment)
            review_query = "SELECT c.Language, c.PackageName FROM c WHERE c.id = @review_id"
            review_results = list(
                reviews_container.query_items(
                    query=review_query,
                    parameters=[{"name": "@review_id", "value": review_id}],
                    enable_cross_partition_query=True,
                )
            )
            if review_results:
                language = get_language_pretty_name(review_results[0].get("Language", ""))
                package_name = review_results[0].get("PackageName", "")

        # Get code from the revision - extract only the line matching the ElementId
        code = None
        element_id = comment.get("ElementId")
        if revision_id:
            try:
                client = ApiViewClient(environment=environment)
                full_text = asyncio.run(client.get_revision_text(revision_id=revision_id))
                code = _extract_code_for_element(full_text, element_id)
            except Exception as e:
                print(f"Warning: Could not fetch revision content: {e}")
                code = None

        feedback_entries = comment.get("Feedback") or []
        feedback_messages = []

        for fb in feedback_entries:
            fb_user = fb.get("SubmittedBy", "unknown")
            reasons = fb.get("Reasons") or []
            is_delete = fb.get("IsDelete", False)
            fb_comment = (fb.get("Comment") or "").strip()

            parts = []
            # Map each reason to its human-readable message
            for reason in reasons:
                msg = FEEDBACK_REASON_MESSAGES.get(reason, reason)
                parts.append(msg)

            # Flag deletion
            if is_delete:
                parts.append(
                    "This comment was flagged for deletion by the user, which means it was so egregiously bad"
                    " that they didn't even want the service team to see it."
                )

            # Append additional comment text
            if fb_comment:
                parts.append(f"Additional feedback: {fb_comment}")

            if parts:
                feedback_text_block = (
                    f"@azure-sdk user '{fb_user}' has provided the following feedback"
                    f" on your previous comment:\n\n" + "\n".join(f"- {p}" for p in parts)
                )
                feedback_messages.append(feedback_text_block)

        feedback_text = "\n\n".join(feedback_messages) if feedback_messages else "No feedback entries found."

        return {
            "comment": comment,
            "language": language,
            "package_name": package_name,
            "code": code,
            "feedback_text": feedback_text,
        }

    except Exception as e:
        print(f"Error fetching comment with context: {e}")
        return None
