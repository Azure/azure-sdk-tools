import argparse
import pdb
import os

# by default, yaml does not maintain insertion order of the dicts
# The drop-in replacement oyaml does handily for us.
import oyaml as yaml

from reference_yaml import ReferenceYaml


# recursive function that returns whether or not
# a given dictionary contains `children` elements that
# map to a namespace
def filter_walk(dict, namespaces):
    print(namespaces)

# recursive walk algo, finds all `children` lists and adds their 
# values to a completed list
def grep_children_namespaces(autogenerated_toc_yml):
    return [top_level_namespace["name"] for top_level_namespace in autogenerated_toc_yml]

# This script is intended for use in intermediate doc repos generated from docs.ms CI.
# Given that a reference ToC, and a set of namespaces, limit the reference to ToC entries that contain
# namespaces in our set.

# The "reference_toc" is the table of contents layout that we will base our generated
# "target" ToC from. It should mirror the "reference" ToC in structure, omitting any nodes
# where the target namespace/package is present in the "target" namespaces set.
# This is intended to to be used to generate the "preview" ToCs from the "latest" ToC. This means
# that we can keep both up to date and clean, with no orphaned children or parentless packages.

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="""
      Combines a reference and target ToC. The new target ToC mirrors the reference, omitting ToC
      entries that are NOT present in the preview output.
      """
    )

    parser.add_argument("-r", "--reference", help="The source ToC.yml", required=True)

    parser.add_argument("-t", "--target", help="The target ToC.yml", required=True)

    parser.add_argument(
        "-n",
        "--namespaces",
        help="The ToC.yml where target autogenerated documentation exists",
        required=True,
    )

    parser.add_argument(
        "-d",
        "--docrepo",
        help="The root directory of the documentation repository containing the reference and target",
        required=True,
    )

    args = parser.parse_args()

    with open(args.reference, "r") as reference_yml:
        base_reference_toc = yaml.safe_load(reference_yml)

    with open(args.namespaces, "r") as target_autogenerated_toc_yml:
        target_autogenerated_toc = yaml.safe_load(target_autogenerated_toc_yml)

    present_in_target = grep_children_namespaces(target_autogenerated_toc)

    print("Visible Namespaces in target:")
    for ns in present_in_target:
        print(" |__ " + ns)

    # # yaml is loaded as a single object list, can safely assume the following structure
    # top_level_accessor = base_reference_toc[0]["items"]

    # for index, top_level_toc_item in enumerate(top_level_accessor):
    #     if (top_level_toc_item["name"] == "Storage"):
    #         print(top_level_toc_item["name"])
    #         print(index)
    #         top_level_accessor.remove(top_level_toc_item)

    # # filter the reference toc by the namespaces that we have
    # appended_content = yaml.dump(base_reference_toc, default_flow_style=False)

    # with open("dump.yml", 'w') as f:
    #     f.write(appended_content)
