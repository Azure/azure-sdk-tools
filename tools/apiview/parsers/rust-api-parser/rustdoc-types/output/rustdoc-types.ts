/*
 * This file is generated from the Rust rustdoc-types crate for use in the rust-api-parser.
 * The original Rust types are located in the vendor/rustdoc-types directory.
 * 
 * DO NOT EDIT THIS FILE DIRECTLY.
 * Changes should be made to:
 * - post-processing.ts script for TypeScript transformations
 * - add-typeshare.rs for typeshare annotations
 * - Or update the rustdoc-types version in Cargo.toml for upstream changes
 *
 * Licensing:
 * This file includes transformed types derived from the rust-lang/rust repository,
 * specifically from the rustdoc-json-types crate, dual-licensed under MIT and Apache 2.0 licenses.
 * See NOTICE.txt at the root of this repository for details.
 */
export const FORMAT_VERSION = 37;

export type Id = number;
export type GenericArgs = {
    "angle_bracketed": {
        /**
         * The list of each argument on this type.
         * ```text
         * <'a, 32, B: Copy, C = u32>
         * ^^^^^^
         * ```
         */
        args: GenericArg[];
        /** Associated type or constant bindings (e.g. `Item=i32` or `Item: Clone`) for this type. */
        constraints: AssocItemConstraint[];
    }
}
    | {
        "parenthesized": {
            /** The input types, enclosed in parentheses. */
            inputs: Type[];
            /** The output type provided after the `->`, if present. */
            output?: Type;
        }
    };
export type AssocItemConstraintKind = { "equality": Term }
    | { "constraint": GenericBound[] };
export type Visibility = "public"
    | "default"
    | "crate"
    | {
        "restricted": {
            /** ID of the module to which this visibility restricts items. */
            parent: Id;
            /**
             * The path with which [`parent`] was referenced
             * (like `super::super` or `crate::foo::bar`).
             * 
             * [`parent`]: Visibility::Restricted::parent
             */
            path: string;
        }
    };
export type ItemEnum = { "module": Module }
    | {
        "extern_crate": {
            /** The name of the imported crate. */
            name: string;
            /** If the crate is renamed, this is its name in the crate. */
            rename?: string;
        }
    }
    | { "use": Use }
    | { "union": Union }
    | { "struct": Struct }
    | { "struct_field": Type }
    | { "enum": Enum }
    | { "variant": Variant }
    | { "function": Function }
    | { "trait": Trait }
    | { "trait_alias": TraitAlias }
    | { "impl": Impl }
    | { "type_alias": TypeAlias }
    | {
        "constant": {
            /** The type of the constant. */
            type: Type;
            /** The declared constant itself. */
            const: Constant;
        }
    }
    | { "static": Static }
    | "extern_type"
    | { "macro": string }
    | { "proc_macro": ProcMacro }
    | { "primitive": Primitive }
    | {
        "assoc_const": {
            /** The type of the constant. */
            type: Type;
            /**
             * Inside a trait declaration, this is the default value for the associated constant,
             * if provided.
             * Inside an `impl` block, this is the value assigned to the associated constant,
             * and will always be present.
             * 
             * The representation is implementation-defined and not guaranteed to be representative of
             * either the resulting value or of the source code.
             * 
             * ```rust
             * const X: usize = 640 * 1024;
             * //               ^^^^^^^^^^
             * ```
             */
            value?: string;
        }
    }
    | {
        "assoc_type": {
            /** The generic parameters and where clauses on ahis associated type. */
            generics: Generics;
            /**
             * The bounds for this associated type. e.g.
             * ```rust
             * trait IntoIterator {
             * type Item;
             * type IntoIter: Iterator<Item = Self::Item>;
             * //                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^
             * }
             * ```
             */
            bounds: GenericBound[];
            /**
             * Inside a trait declaration, this is the default for the associated type, if provided.
             * Inside an impl block, this is the type assigned to the associated type, and will always
             * be present.
             * 
             * ```rust
             * type X = usize;
             * //       ^^^^^
             * ```
             */
            type?: Type;
        }
    };
export type GenericParamDefKind = {
    "lifetime": {
        /**
         * Lifetimes that this lifetime parameter is required to outlive.
         * 
         * ```rust
         * fn f<'a, 'b, 'resource: 'a + 'b>(a: &'a str, b: &'b str, res: &'resource str) {}
         * //                      ^^^^^^^
         * ```
         */
        outlives: string[];
    }
}
    | {
        "type": {
            /**
             * Bounds applied directly to the type. Note that the bounds from `where` clauses
             * that constrain this parameter won't appear here.
             * 
             * ```rust
             * fn default2<T: Default>() -> [T; 2] where T: Clone { todo!() }
             * //             ^^^^^^^
             * ```
             */
            bounds: GenericBound[];
            /**
             * The default type for this parameter, if provided, e.g.
             * 
             * ```rust
             * trait PartialEq<Rhs = Self> {}
             * //                    ^^^^
             * ```
             */
            default?: Type;
            /**
             * This is normally `false`, which means that this generic parameter is
             * declared in the Rust source text.
             * 
             * If it is `true`, this generic parameter has been introduced by the
             * compiler behind the scenes.
             * 
             * # Example
             * 
             * Consider
             * 
             * ```ignore (pseudo-rust)
             * pub fn f(_: impl Trait) {}
             * ```
             * 
             * The compiler will transform this behind the scenes to
             * 
             * ```ignore (pseudo-rust)
             * pub fn f<impl Trait: Trait>(_: impl Trait) {}
             * ```
             * 
             * In this example, the generic parameter named `impl Trait` (and which
             * is bound by `Trait`) is synthetic, because it was not originally in
             * the Rust source text.
             */
            is_synthetic: boolean;
        }
    }
    | {
        "const": {
            /** The type of the constant as declared. */
            type: Type;
            /**
             * The stringified expression for the default value, if provided. It's not guaranteed that
             * it'll match the actual source code for the default value.
             */
            default?: string;
        }
    };
export type WherePredicate = {
    "bound_predicate": {
        /**
         * The type that's being constrained.
         * 
         * ```rust
         * fn f<T>(x: T) where for<'a> &'a T: Iterator {}
         * //                              ^
         * ```
         */
        type: Type;
        /**
         * The set of bounds that constrain the type.
         * 
         * ```rust
         * fn f<T>(x: T) where for<'a> &'a T: Iterator {}
         * //                                 ^^^^^^^^
         * ```
         */
        bounds: GenericBound[];
        /**
         * Used for Higher-Rank Trait Bounds (HRTBs)
         * ```rust
         * fn f<T>(x: T) where for<'a> &'a T: Iterator {}
         * //                  ^^^^^^^
         * ```
         */
        generic_params: GenericParamDef[];
    }
}
    | {
        "lifetime_predicate": {
            /** The name of the lifetime. */
            lifetime: string;
            /** The lifetimes that must be encompassed by the lifetime. */
            outlives: string[];
        }
    }
    | {
        "eq_predicate": {
            /** The left side of the equation. */
            lhs: Type;
            /** The right side of the equation. */
            rhs: Term;
        }
    };
export type Type = { "resolved_path": Path }
    | { "dyn_trait": DynTrait }
    | { "generic": string }
    | { "primitive": string }
    | { "function_pointer": FunctionPointer }
    | { "tuple": Type[] }
    | { "slice": Type }
    | {
        "array": {
            /** The type of the contained element. */
            type: Type;
            /**
             * The stringified expression that is the length of the array.
             * 
             * Keep in mind that it's not guaranteed to match the actual source code of the expression.
             */
            len: string;
        }
    }
    | {
        "pat": {
            /** The base type, e.g. the `u32` in `u32 is 1..` */
            type: Type;
            __pat_unstable_do_not_use: string;
        }
    }
    | { "impl_trait": GenericBound[] }
    | "infer"
    | {
        "raw_pointer": {
            /** This is `true` for `*mut _` and `false` for `*const _`. */
            is_mutable: boolean;
            /** The type of the pointee. */
            type: Type;
        }
    }
    | {
        "borrowed_ref": {
            /** The name of the lifetime of the reference, if provided. */
            lifetime?: string;
            /** This is `true` for `&mut i32` and `false` for `&i32` */
            is_mutable: boolean;
            /** The type of the pointee, e.g. the `i32` in `&'a mut i32` */
            type: Type;
        }
    }
    | {
        "qualified_path": {
            /**
             * The name of the associated type in the parent type.
             * 
             * ```ignore (incomplete expression)
             * <core::array::IntoIter<u32, 42> as Iterator>::Item
             * //                                            ^^^^
             * ```
             */
            name: string;
            /**
             * The generic arguments provided to the associated type.
             * 
             * ```ignore (incomplete expression)
             * <core::slice::IterMut<'static, u32> as BetterIterator>::Item<'static>
             * //                                                          ^^^^^^^^^
             * ```
             */
            args: GenericArgs;
            /**
             * The type with which this type is associated.
             * 
             * ```ignore (incomplete expression)
             * <core::array::IntoIter<u32, 42> as Iterator>::Item
             * // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
             * ```
             */
            self_type: Type;
            /** `None` iff this is an *inherent* associated type. */
            trait?: Path;
        }
    };
export type Abi = "Rust"
    | {
        "C": {
            unwind: boolean;
        }
    }
    | {
        "Cdecl": {
            unwind: boolean;
        }
    }
    | {
        "Stdcall": {
            unwind: boolean;
        }
    }
    | {
        "Fastcall": {
            unwind: boolean;
        }
    }
    | {
        "Aapcs": {
            unwind: boolean;
        }
    }
    | {
        "Win64": {
            unwind: boolean;
        }
    }
    | {
        "SysV64": {
            unwind: boolean;
        }
    }
    | {
        "System": {
            unwind: boolean;
        }
    }
    | { "Other": string };
export type StructKind = "unit"
    | { "tuple": Id[] }
    | {
        "plain": {
            /**
             * The list of fields in the struct.
             * 
             * All of the corresponding [`Item`]s are of kind [`ItemEnum::StructField`].
             */
            fields: Id[];
            /** Whether any fields have been removed from the result, due to being private or hidden. */
            has_stripped_fields: boolean;
        }
    };
export type GenericBound = {
    "trait_bound": {
        /** The full path to the trait. */
        trait: Path;
        /**
         * Used for Higher-Rank Trait Bounds (HRTBs)
         * ```text
         * where F: for<'a, 'b> Fn(&'a u8, &'b u8)
         * ^^^^^^^^^^^
         * |
         * this part
         * ```
         */
        generic_params: GenericParamDef[];
        /** The context for which a trait is supposed to be used, e.g. `const */
        modifier: TraitBoundModifier;
    }
}
    | { "outlives": string }
    | { "use": string[] };
export type VariantKind = "plain"
    | { "tuple": Id[] }
    | {
        "struct": {
            /**
             * The list of variants in the enum.
             * All of the corresponding [`Item`]s are of kind [`ItemEnum::Variant`].
             */
            fields: Id[];
            /** Whether any variants have been removed from the result, due to being private or hidden. */
            has_stripped_fields: boolean;
        }
    };
export type GenericArg = { "lifetime": string }
    | { "type": Type }
    | { "const": Constant }
    | "infer";
export type Term = { "type": Type }
    | { "constant": Constant };
export interface AssocItemConstraint {
    /** The name of the associated type/constant. */
    name: string;
    /** Arguments provided to the associated type/constant. */
    args: GenericArgs;
    /** The kind of bound applied to the associated type/constant. */
    binding: AssocItemConstraintKind;
}
export interface Constant {
    /**
     * The stringified expression of this constant. Note that its mapping to the original
     * source code is unstable and it's not guaranteed that it'll match the source code.
     */
    expr: string;
    /**
     * The value of the evaluated expression for this constant, which is only computed for numeric
     * types.
     */
    value?: string;
    /** Whether this constant is a bool, numeric, string, or char literal. */
    is_literal: boolean;
}
export interface Deprecation {
    /** Usually a version number when this [`Item`] first became deprecated. */
    since?: string;
    /** The reason for deprecation and/or what alternatives to use. */
    note?: string;
}
export interface Item {
    /** The unique identifier of this item. Can be used to find this item in various mappings. */
    id: Id;
    /**
     * This can be used as a key to the `external_crates` map of [`Crate`] to see which crate
     * this item came from.
     */
    crate_id: number;
    /** Some items such as impls don't have names. */
    name?: string;
    /**
     * By default all documented items are public, but you can tell rustdoc to output private items
     * so this field is needed to differentiate.
     */
    visibility: Visibility;
    /**
     * The full markdown docstring of this item. Absent if there is no documentation at all,
     * Some("") if there is some documentation but it is empty (EG `#[doc = ""]`).
     */
    docs?: string;
    /** This mapping resolves [intra-doc links](https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md) from the docstring to their IDs */
    links: Record<string, Id>;
    /** Stringified versions of the attributes on this item (e.g. `"#[inline]"`) */
    attrs: string[];
    /** Information about the item’s deprecation, if present. */
    deprecation?: Deprecation;
    /** The type-specific fields describing this item. */
    inner: ItemEnum;
}
export enum ItemKind {
    /** A module declaration, e.g. `mod foo;` or `mod foo {}` */
    Module = "module",
    /** A crate imported via the `extern crate` syntax. */
    ExternCrate = "extern_crate",
    /** An import of 1 or more items into scope, using the `use` keyword. */
    Use = "use",
    /** A `struct` declaration. */
    Struct = "struct",
    /** A field of a struct. */
    StructField = "struct_field",
    /** A `union` declaration. */
    Union = "union",
    /** An `enum` declaration. */
    Enum = "enum",
    /** A variant of a enum. */
    Variant = "variant",
    /** A function declaration, e.g. `fn f() {}` */
    Function = "function",
    /** A type alias declaration, e.g. `type Pig = std::borrow::Cow<'static, str>;` */
    TypeAlias = "type_alias",
    /** The declaration of a constant, e.g. `const GREETING: &str = "Hi :3";` */
    Constant = "constant",
    /** A `trait` declaration. */
    Trait = "trait",
    /**
     * A trait alias declaration, e.g. `trait Int = Add + Sub + Mul + Div;`
     * 
     * See [the tracking issue](https://github.com/rust-lang/rust/issues/41517)
     */
    TraitAlias = "trait_alias",
    /** An `impl` block. */
    Impl = "impl",
    /** A `static` declaration. */
    Static = "static",
    /**
     * `type`s from an `extern` block.
     * 
     * See [the tracking issue](https://github.com/rust-lang/rust/issues/43467)
     */
    ExternType = "extern_type",
    /**
     * A macro declaration.
     * 
     * Corresponds to either `ItemEnum::Macro(_)`
     * or `ItemEnum::ProcMacro(ProcMacro { kind: MacroKind::Bang })`
     */
    Macro = "macro",
    /**
     * A procedural macro attribute.
     * 
     * Corresponds to `ItemEnum::ProcMacro(ProcMacro { kind: MacroKind::Attr })`
     */
    ProcAttribute = "proc_attribute",
    /**
     * A procedural macro usable in the `#[derive()]` attribute.
     * 
     * Corresponds to `ItemEnum::ProcMacro(ProcMacro { kind: MacroKind::Derive })`
     */
    ProcDerive = "proc_derive",
    /** An associated constant of a trait or a type. */
    AssocConst = "assoc_const",
    /** An associated type of a trait or a type. */
    AssocType = "assoc_type",
    /**
     * A primitive type, e.g. `u32`.
     * 
     * [`Item`]s of this kind only come from the core library.
     */
    Primitive = "primitive",
    /**
     * A keyword declaration.
     * 
     * [`Item`]s of this kind only come from the come library and exist solely
     * to carry documentation for the respective keywords.
     */
    Keyword = "keyword",
}
export interface ItemSummary {
    /**
     * Can be used to look up the name and html_root_url of the crate this item came from in the
     * `external_crates` map.
     */
    crate_id: number;
    /**
     * The list of path components for the fully qualified path of this item (e.g.
     * `["std", "io", "lazy", "Lazy"]` for `std::io::lazy::Lazy`).
     * 
     * Note that items can appear in multiple paths, and the one chosen is implementation
     * defined. Currently, this is the full path to where the item was defined. Eg
     * [`String`] is currently `["alloc", "string", "String"]` and [`HashMap`][`std::collections::HashMap`]
     * is `["std", "collections", "hash", "map", "HashMap"]`, but this is subject to change.
     */
    path: string[];
    /** Whether this item is a struct, trait, macro, etc. */
    kind: ItemKind;
}
export interface ExternalCrate {
    /** The name of the crate. */
    name: string;
    /** The root URL at which the crate's documentation lives. */
    html_root_url?: string;
}
export interface Crate {
    /** The id of the root [`Module`] item of the local crate. */
    root: Id;
    /** The version string given to `--crate-version`, if any. */
    crate_version?: string;
    /** Whether or not the output includes private items. */
    includes_private: boolean;
    /**
     * A collection of all items in the local crate as well as some external traits and their
     * items that are referenced locally.
     */
    index: Record<Id, Item>;
    /** Maps IDs to fully qualified paths and other info helpful for generating links. */
    paths: Record<Id, ItemSummary>;
    /** Maps `crate_id` of items to a crate name and html_root_url if it exists. */
    external_crates: Record<number, ExternalCrate>;
    /**
     * A single version number to be used in the future when making backwards incompatible changes
     * to the JSON output.
     */
    format_version: number;
}
export interface Discriminant {
    /**
     * The expression that produced the discriminant.
     * 
     * Unlike `value`, this preserves the original formatting (eg suffixes,
     * hexadecimal, and underscores), making it unsuitable to be machine
     * interpreted.
     * 
     * In some cases, when the value is too complex, this may be `"{ _ }"`.
     * When this occurs is unstable, and may change without notice.
     */
    expr: string;
    /**
     * The numerical value of the discriminant. Stored as a string due to
     * JSON's poor support for large integers, and the fact that it would need
     * to store from [`i128::MIN`] to [`u128::MAX`].
     */
    value: string;
}
export interface Path {
    /**
     * The name of the type as declared, e.g. in
     * 
     * ```rust
     * mod foo {
     * struct Bar;
     * }
     * ```
     * 
     * for `foo::Bar`, this field will be `Bar`.
     */
    name: string;
    /** The ID of the type. */
    id: Id;
    /**
     * Generic arguments to the type.
     * 
     * ```ignore (incomplete expression)
     * std::borrow::Cow<'static, str>
     * //              ^^^^^^^^^^^^^^
     * ```
     */
    args?: GenericArgs;
}
export interface GenericParamDef {
    /**
     * Name of the parameter.
     * ```rust
     * fn f<'resource, Resource>(x: &'resource Resource) {}
     * //    ^^^^^^^^  ^^^^^^^^
     * ```
     */
    name: string;
    /**
     * The kind of the parameter and data specific to a particular parameter kind, e.g. type
     * bounds.
     */
    kind: GenericParamDefKind;
}
export interface PolyTrait {
    /** The path to the trait. */
    trait: Path;
    /**
     * Used for Higher-Rank Trait Bounds (HRTBs)
     * ```text
     * dyn for<'a> Fn() -> &'a i32"
     * ^^^^^^^
     * ```
     */
    generic_params: GenericParamDef[];
}
export interface DynTrait {
    /** All the traits implemented. One of them is the vtable, and the rest must be auto traits. */
    traits: PolyTrait[];
    /**
     * The lifetime of the whole dyn object
     * ```text
     * dyn Debug + 'static
     * ^^^^^^^
     * |
     * this part
     * ```
     */
    lifetime?: string;
}
export interface Generics {
    /** A list of generic parameter definitions (e.g. `<T: Clone + Hash, U: Copy>`). */
    params: GenericParamDef[];
    /** A list of where predicates (e.g. `where T: Iterator, T::Item: Copy`). */
    where_predicates: WherePredicate[];
}
export interface Enum {
    /** Information about the type parameters and `where` clauses of the enum. */
    generics: Generics;
    /** Whether any variants have been removed from the result, due to being private or hidden. */
    has_stripped_variants: boolean;
    /**
     * The list of variants in the enum.
     * 
     * All of the corresponding [`Item`]s are of kind [`ItemEnum::Variant`]
     */
    variants: Id[];
    /** `impl`s for the enum. */
    impls: Id[];
}
export interface FunctionHeader {
    /** Is this function marked as `const`? */
    is_const: boolean;
    /** Is this function unsafe? */
    is_unsafe: boolean;
    /** Is this function async? */
    is_async: boolean;
    /** The ABI used by the function. */
    abi: Abi;
}
export interface Function {
    /** Information about the function signature, or declaration. */
    sig: FunctionSignature;
    /** Information about the function’s type parameters and `where` clauses. */
    generics: Generics;
    /** Information about core properties of the function, e.g. whether it's `const`, its ABI, etc. */
    header: FunctionHeader;
    /** Whether the function has a body, i.e. an implementation. */
    has_body: boolean;
}
export interface FunctionPointer {
    /** The signature of the function. */
    sig: FunctionSignature;
    /**
     * Used for Higher-Rank Trait Bounds (HRTBs)
     * 
     * ```ignore (incomplete expression)
     * for<'c> fn(val: &'c i32) -> i32
     * // ^^^^^^^
     * ```
     */
    generic_params: GenericParamDef[];
    /** The core properties of the function, such as the ABI it conforms to, whether it's unsafe, etc. */
    header: FunctionHeader;
}
export interface Impl {
    /** Whether this impl is for an unsafe trait. */
    is_unsafe: boolean;
    /** Information about the impl’s type parameters and `where` clauses. */
    generics: Generics;
    /**
     * The list of the names of all the trait methods that weren't mentioned in this impl but
     * were provided by the trait itself.
     * 
     * For example, for this impl of the [`PartialEq`] trait:
     * ```rust
     * struct Foo;
     * 
     * impl PartialEq for Foo {
     * fn eq(&self, other: &Self) -> bool { todo!() }
     * }
     * ```
     * This field will be `["ne"]`, as it has a default implementation defined for it.
     */
    provided_trait_methods: string[];
    /**
     * The trait being implemented or `None` if the impl is inherent, which means
     * `impl Struct {}` as opposed to `impl Trait for Struct {}`.
     */
    trait?: Path;
    /** The type that the impl block is for. */
    for: Type;
    /** The list of associated items contained in this impl block. */
    items: Id[];
    /** Whether this is a negative impl (e.g. `!Sized` or `!Send`). */
    is_negative: boolean;
    /**
     * Whether this is an impl that’s implied by the compiler
     * (for autotraits, e.g. `Send` or `Sync`).
     */
    is_synthetic: boolean;
    blanket_impl?: Type;
}
export interface Module {
    /**
     * Whether this is the root item of a crate.
     * 
     * This item doesn't correspond to any construction in the source code and is generated by the
     * compiler.
     */
    is_crate: boolean;
    /** [`Item`]s declared inside this module. */
    items: Id[];
    /**
     * If `true`, this module is not part of the public API, but it contains
     * items that are re-exported as public API.
     */
    is_stripped: boolean;
}
export interface Primitive {
    /** The name of the type. */
    name: string;
    /** The implementations, inherent and of traits, on the primitive type. */
    impls: Id[];
}
export enum MacroKind {
    /** A bang macro `foo!()`. */
    Bang = "bang",
    /** An attribute macro `#[foo]`. */
    Attr = "attr",
    /** A derive macro `#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]` */
    Derive = "derive",
}
export interface ProcMacro {
    /** How this macro is supposed to be called: `foo!()`, `#[foo]` or `#[derive(foo)]` */
    kind: MacroKind;
    /**
     * Helper attributes defined by a macro to be used inside it.
     * 
     * Defined only for derive macros.
     * 
     * E.g. the [`Default`] derive macro defines a `#[default]` helper attribute so that one can
     * do:
     * 
     * ```rust
     * #[derive(Default)]
     * enum Option<T> {
     * #[default]
     * None,
     * Some(T),
     * }
     * ```
     */
    helpers: string[];
}
export interface Static {
    /** The type of the static. */
    type: Type;
    /** This is `true` for mutable statics, declared as `static mut X: T = f();` */
    is_mutable: boolean;
    /**
     * The stringified expression for the initial value.
     * 
     * It's not guaranteed that it'll match the actual source code for the initial value.
     */
    expr: string;
    /**
     * Is the static `unsafe`?
     * 
     * This is only true if it's in an `extern` block, and not explicity marked
     * as `safe`.
     * 
     * ```rust
     * unsafe extern {
     * static A: i32;      // unsafe
     * safe static B: i32; // safe
     * }
     * 
     * static C: i32 = 0;     // safe
     * static mut D: i32 = 0; // safe
     * ```
     */
    is_unsafe: boolean;
}
export interface Struct {
    /**
     * The kind of the struct (e.g. unit, tuple-like or struct-like) and the data specific to it,
     * i.e. fields.
     */
    kind: StructKind;
    /** The generic parameters and where clauses on this struct. */
    generics: Generics;
    /**
     * All impls (both of traits and inherent) for this struct.
     * All of the corresponding [`Item`]s are of kind [`ItemEnum::Impl`].
     */
    impls: Id[];
}
export interface Trait {
    /**
     * Whether the trait is marked `auto` and is thus implemented automatically
     * for all applicable types.
     */
    is_auto: boolean;
    /** Whether the trait is marked as `unsafe`. */
    is_unsafe: boolean;
    /**
     * Whether the trait is [dyn compatible](https://doc.rust-lang.org/reference/items/traits.html#object-safety)[^1].
     * 
     * [^1]: Formerly known as "object safe".
     */
    is_dyn_compatible: boolean;
    /** Associated [`Item`]s that can/must be implemented by the `impl` blocks. */
    items: Id[];
    /** Information about the type parameters and `where` clauses of the trait. */
    generics: Generics;
    /** Constraints that must be met by the implementor of the trait. */
    bounds: GenericBound[];
    /** The implementations of the trait. */
    implementations: Id[];
}
export interface TraitAlias {
    /** Information about the type parameters and `where` clauses of the alias. */
    generics: Generics;
    /** The bounds that are associated with the alias. */
    params: GenericBound[];
}
export interface TypeAlias {
    /** The type referred to by this alias. */
    type: Type;
    /** Information about the type parameters and `where` clauses of the alias. */
    generics: Generics;
}
export interface Union {
    /** The generic parameters and where clauses on this union. */
    generics: Generics;
    /** Whether any fields have been removed from the result, due to being private or hidden. */
    has_stripped_fields: boolean;
    /**
     * The list of fields in the union.
     * 
     * All of the corresponding [`Item`]s are of kind [`ItemEnum::StructField`].
     */
    fields: Id[];
    /**
     * All impls (both of traits and inherent) for this union.
     * 
     * All of the corresponding [`Item`]s are of kind [`ItemEnum::Impl`].
     */
    impls: Id[];
}
export interface Use {
    /** The full path being imported. */
    source: string;
    /**
     * May be different from the last segment of `source` when renaming imports:
     * `use source as name;`
     */
    name: string;
    /**
     * The ID of the item being imported. Will be `None` in case of re-exports of primitives:
     * ```rust
     * pub use i32 as my_i32;
     * ```
     */
    id?: Id;
    /** Whether this statement is a wildcard `use`, e.g. `use source::*;` */
    is_glob: boolean;
}
export interface Variant {
    /** Whether the variant is plain, a tuple-like, or struct-like. Contains the fields. */
    kind: VariantKind;
    /** The discriminant, if explicitly specified. */
    discriminant?: Discriminant;
}
export enum TraitBoundModifier {
    /** Marks the absence of a modifier. */
    None = "none",
    /**
     * Indicates that the trait bound relaxes a trait bound applied to a parameter by default,
     * e.g. `T: Sized?`, the `Sized` trait is required for all generic type parameters by default
     * unless specified otherwise with this modifier.
     */
    Maybe = "maybe",
    /**
     * Indicates that the trait bound must be applicable in both a run-time and a compile-time
     * context.
     */
    MaybeConst = "maybe_const",
}

export interface FunctionSignature {
    output?: Type;
    is_c_variadic: boolean;
    inputs: Array<[string, Type]>;
}
