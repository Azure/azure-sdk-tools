// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

namespace Azure.Sdk.Tools.Cli.Prompts.Templates;

/// <summary>
/// Error-driven template for Java customization patch generation.
/// Scope: deterministic, mechanical fixes only (remove duplicates, update references).
/// </summary>
public class JavaErrorDrivenPatchTemplate(
    string buildError,
    string packagePath,
    string customizationContent,
    string customizationRoot,
    List<string> customizationFiles) : BasePromptTemplate
{
    public override string TemplateId => "java-error-driven-patch";
    public override string Version => "1.0.0";
    public override string Description => "Analyze build error and apply targeted fix to Java customization code";

    public override string BuildPrompt() =>
        BuildStructuredPrompt(BuildTaskInstructions(), BuildTaskConstraints(), BuildExamples(), BuildOutputRequirements());

    private string BuildTaskInstructions()
    {
        var fileList = string.Join("\n", customizationFiles.Select(f => $"  - {f}"));
        
        return $"""
        ## BUILD ERROR TO FIX
        ```
        {buildError}
        ```
        
        ## YOUR TASK
        Analyze the build error above and apply a targeted fix to the customization code.
        
        ## SCOPE LIMITATIONS
        You may ONLY perform these types of fixes:
        - Remove duplicate field/method definitions
        - Update references after TypeSpec renames (e.g., method name changes)
        - Add missing import statements
        - Fix reserved keyword conflicts
        
        You may NOT:
        - Add new methods or functionality
        - Restructure code architecture
        - Change method visibility (use TypeSpec @access instead)
        - Add error handling or new logic
        
        ## FILE STRUCTURE
        - Package Path (ReadFile base): {packagePath}
        - Customization Root: {customizationRoot}
        - Customization Files:
        {fileList}
        
        ## CUSTOMIZATION CODE (to fix):
        ```java
        {customizationContent}
        ```
        
        ## WORKFLOW
        1. **Parse the error**: Identify the exact issue (duplicate field, undefined reference, etc.)
        2. **Locate the problem**: Find the problematic code in customization files
        3. **Determine fix type**: Is it within scope (remove/update only)?
        4. **Apply fix**: Use ClientCustomizationCodePatch tool with exact replacement
        5. **Return result**: true if fix applied, false if unable to fix
        """;
    }

    private static string BuildTaskConstraints()
    {
        return """
        ## CRITICAL CONSTRAINTS
        
        **Scope Check - Before attempting ANY fix, verify:**
        - Is this a mechanical fix? (removing duplicate, updating reference, adding import)
        - Is this <20 lines of change?
        - Am I removing/updating code, NOT adding new logic?
        
        If ANY answer is NO → Return false immediately. Do not attempt the fix.
        
        **Safety Guidelines:**
        - Only modify customization files, NEVER generated code
        - Use exact string matching for replacements
        - Include enough context to uniquely identify the location
        - Preserve code formatting and indentation
        - If uncertain about the fix → Return false (let human review)
        
        **Common Patterns:**
        
        1. DUPLICATE FIELD: Error says "variable X is already defined"
           → Remove the duplicate definition from customization file
           
        2. UNDEFINED REFERENCE: Error says "cannot find symbol X"  
           → Check if TypeSpec renamed it, update the reference
           
        3. MISSING IMPORT: Error says "cannot find symbol" for a type
           → Add the missing import statement
           
        4. RESERVED KEYWORD: Error about using reserved word
           → Rename the identifier (check if TypeSpec caused this)
        """;
    }

    private static string BuildExamples()
    {
        return """
        ## EXAMPLE SCENARIOS
        
        **Example 1: Duplicate Field**
        Build error: `[ERROR] DocumentIntelligenceCustomizations.java:[178,20] variable operationId is already defined`
        
        Analysis: TypeSpec now generates `operationId`, but customization also adds it.
        Fix: Remove the duplicate field injection from customization.
        
        ```
        ClientCustomizationCodePatch(
            FilePath: 'src/main/java/.../DocumentIntelligenceCustomizations.java',
            OldContent: '    .addField("operationId", ...)',
            NewContent: '    // Removed: operationId now generated by TypeSpec'
        )
        ```
        
        **Example 2: Undefined Reference**
        Build error: `[ERROR] Customizations.java:[42,15] cannot find symbol: method getItems()`
        
        Analysis: TypeSpec renamed `getItems()` to `listItems()`.
        Fix: Update the method reference in customization.
        
        ```
        ClientCustomizationCodePatch(
            FilePath: 'src/main/java/.../Customizations.java',
            OldContent: '.getItems()',
            NewContent: '.listItems()'
        )
        ```
        
        **Example 3: Out of Scope - Return False**
        Build error: `Need to add convenience method for batch operations`
        
        Analysis: This requires adding new functionality, not removing/updating.
        Action: Return false - this is out of scope for automatic repair.
        """;
    }

    private static string BuildOutputRequirements()
    {
        return """
        ## TOOL USAGE
        
        **ReadFile tool:**
        - Use to examine generated code if needed to understand the change
        - Relative paths from package path: `src/main/java/com/azure/...`
        
        **ClientCustomizationCodePatch tool:**
        - FilePath: relative to customization root
        - OldContent: exact text to replace (include context for uniqueness)
        - NewContent: replacement text
        
        ## DECISION FLOW
        
        1. Can I identify the exact error location? 
           NO → Return false
           
        2. Is the fix mechanical (remove/update, not add)?
           NO → Return false
           
        3. Am I confident the fix is correct?
           NO → Return false
           
        4. Apply the fix with ClientCustomizationCodePatch
        
        5. Return true if patch succeeded, false otherwise
        
        ## FINAL RESULT
        - Return true: Fix was applied successfully
        - Return false: Unable to fix (out of scope, uncertain, or error applying patch)
        
        It is BETTER to return false than to apply an incorrect fix.
        """;
    }
}
