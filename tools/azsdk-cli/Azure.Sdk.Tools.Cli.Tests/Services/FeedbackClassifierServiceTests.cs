// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using Azure.Sdk.Tools.Cli.CopilotAgents;
using Azure.Sdk.Tools.Cli.Helpers;
using Azure.Sdk.Tools.Cli.Models;
using Azure.Sdk.Tools.Cli.Services;
using Azure.Sdk.Tools.Cli.Tests.TestHelpers;
using GitHub.Copilot.SDK;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;

namespace Azure.Sdk.Tools.Cli.Tests.Services;

/// <summary>
/// Tests for FeedbackClassifierService batch classification and parsing logic.
/// Includes both mocked unit tests and live integration tests.
/// </summary>
[TestFixture]
public class FeedbackClassifierServiceTests
{
    private Mock<ICopilotAgentRunner> _mockAgentRunner = null!;
    private Mock<ITypeSpecHelper> _mockTypeSpecHelper = null!;
    private ILoggerFactory _loggerFactory = null!;
    private string _testTspPath = null!;
    private string _specRepoRoot = null!;
    private string _typeSpecProjectPath = null!;

    [OneTimeSetUp]
    public void OneTimeSetUp()
    {
        // Path to the test TypeSpec project for live tests
        _typeSpecProjectPath = Path.Combine(
            TestContext.CurrentContext.TestDirectory,
            "TypeSpecTestData",
            "specification",
            "testcontoso",
            "Contoso.Management");

        // Create the customization guide file that live tests require
        // The TypeSpecHelper looks for this at <specRepoRoot>/eng/common/knowledge/customizing-client-tsp.md
        var testDataRoot = Path.Combine(TestContext.CurrentContext.TestDirectory, "TypeSpecTestData");
        var liveTestGuidePath = Path.Combine(testDataRoot, "eng", "common", "knowledge", "customizing-client-tsp.md");
        Directory.CreateDirectory(Path.GetDirectoryName(liveTestGuidePath)!);
        if (!File.Exists(liveTestGuidePath))
        {
            File.WriteAllText(liveTestGuidePath, "# TypeSpec Client Customizations\nTest reference content for live tests.");
        }
    }

    [SetUp]
    public void Setup()
    {
        _mockAgentRunner = new Mock<ICopilotAgentRunner>();
        _mockTypeSpecHelper = new Mock<ITypeSpecHelper>();
        _loggerFactory = LoggerFactory.Create(builder => builder.AddConsole());
        
        // Set up a fake tsp project path for mocked tests
        _specRepoRoot = Path.Combine(Path.GetTempPath(), "test-spec-repo-" + Guid.NewGuid().ToString("N")[..8]);
        _testTspPath = Path.Combine(_specRepoRoot, "specification", "widget", "Widget.Management");
        
        // Mock the spec repo root detection
        _mockTypeSpecHelper.Setup(x => x.GetSpecRepoRootPath(_testTspPath)).Returns(_specRepoRoot);
        
        // Create the customization guide file that the service expects
        var guidePath = Path.Combine(_specRepoRoot, "eng", "common", "knowledge", "customizing-client-tsp.md");
        Directory.CreateDirectory(Path.GetDirectoryName(guidePath)!);
        File.WriteAllText(guidePath, "# TypeSpec Client Customizations\nTest reference content.");
    }

    [TearDown]
    public void TearDown()
    {
        _loggerFactory?.Dispose();
        
        // Clean up temp files
        if (Directory.Exists(_specRepoRoot))
        {
            try { Directory.Delete(_specRepoRoot, recursive: true); } catch { }
        }
    }

    #region Mocked Test Helpers

    private FeedbackClassifierService CreateMockedService(string? packagePath = null)
    {
        return new FeedbackClassifierService(
            _mockAgentRunner.Object,
            _loggerFactory,
            _mockTypeSpecHelper.Object,
            _testTspPath,
            packagePath);
    }

    private static FeedbackItem CreateTestItem(string text, string? id = null)
    {
        var item = new FeedbackItem { Text = text };
        if (id != null) item.Id = id;
        return item;
    }

    #endregion

    #region Live Test Helpers

    private static GitHelper CreateRealGitHelper()
    {
        var rawOutputHelper = Mock.Of<IRawOutputHelper>();
        var gitCommandHelper = new GitCommandHelper(
            new TestLogger<GitCommandHelper>(),
            rawOutputHelper);
        return new GitHelper(
            Mock.Of<IGitHubService>(),
            gitCommandHelper,
            new TestLogger<GitHelper>());
    }

    private FeedbackClassifierService CreateRealService()
    {
        var rawOutputHelper = Mock.Of<IRawOutputHelper>();
        var gitHelper = CreateRealGitHelper();
        var typeSpecHelper = new TypeSpecHelper(gitHelper);

        var copilotClient = new CopilotClient(new CopilotClientOptions
        {
            UseStdio = true,
            AutoStart = true
        });
        var copilotClientWrapper = new CopilotClientWrapper(copilotClient);
        var tokenUsageHelper = new TokenUsageHelper(rawOutputHelper);
        var copilotAgentRunner = new CopilotAgentRunner(
            copilotClientWrapper,
            tokenUsageHelper,
            new TestLogger<CopilotAgentRunner>());

        return new FeedbackClassifierService(
            copilotAgentRunner,
            LoggerFactory.Create(builder => builder.AddConsole()),
            typeSpecHelper,
            _typeSpecProjectPath,
            packagePath: null);
    }

    private static FeedbackItem CreateLiveTestItem(string text, string context = "")
    {
        var id = Guid.NewGuid().ToString();
        return new FeedbackItem
        {
            Id = id,
            Text = text,
            Context = context
        };
    }

    private static void LogClassificationResults(List<FeedbackItem> items)
    {
        TestContext.WriteLine("Classification results:");
        foreach (var item in items)
        {
            TestContext.WriteLine($"  [{item.Id}] Status: {item.Status}, Reason: {item.ClassificationReason}");
        }
    }

    #endregion

    #region ClassifyAsync Flow Tests

    [Test]
    public async Task ClassifyAsync_EmptyList_ReturnsTrue()
    {
        // Arrange
        var service = CreateMockedService();
        var items = new List<FeedbackItem>();

        // Act
        var result = await service.ClassifyAsync(items, "global context");

        // Assert
        Assert.That(result, Is.True);
        _mockAgentRunner.Verify(x => x.RunAsync(It.IsAny<CopilotAgent<string>>(), It.IsAny<CancellationToken>()), Times.Never);
    }

    [Test]
    public async Task ClassifyAsync_AllItemsResolved_ReturnsTrue()
    {
        // Arrange
        var service = CreateMockedService();
        // Non-actionable API review comment -> SUCCESS
        var item1 = CreateTestItem("LGTM, the API surface looks appropriate for this service", "item-1");
        // Requires code-level implementation (no TypeSpec decorator exists for this) -> FAILURE
        var item2 = CreateTestItem("Please add a convenience method that combines getDocument and analyzeDocument into a single call", "item-2");
        var items = new List<FeedbackItem> { item1, item2 };

        // Mock the batch classification response
        // Per FeedbackClassificationTemplate:
        // - SUCCESS: non-actionable (LGTM, keep as is, build succeeding)
        // - FAILURE: actionable but requires code changes (no TypeSpec decorator applies)
        var batchResponse = """
            [item-1]
            Classification: SUCCESS
            Reason: Non-actionable feedback - approval comment with no requested changes

            [item-2]
            Classification: FAILURE
            Reason: Convenience methods combining multiple operations require code-level implementation; no TypeSpec decorator can create new composite operations
            """;
        _mockAgentRunner
            .Setup(x => x.RunAsync(It.IsAny<CopilotAgent<string>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(batchResponse);

        // Act
        var result = await service.ClassifyAsync(items, "global context");

        // Assert
        Assert.That(result, Is.True, "All items resolved (SUCCESS or FAILURE) should return true");
        Assert.That(item1.Status, Is.EqualTo(FeedbackStatus.SUCCESS));
        Assert.That(item2.Status, Is.EqualTo(FeedbackStatus.FAILURE));
    }

    [Test]
    public async Task ClassifyAsync_ItemsStillTspApplicable_ReturnsFalse()
    {
        // Arrange
        var service = CreateMockedService();
        // API review feedback requesting a rename - addressable via @clientName decorator -> TSP_APPLICABLE
        var item1 = CreateTestItem("Rename 'DocumentIntelligenceClient' to 'DocumentAnalysisClient' for consistency with other Azure AI services", "item-1");
        var items = new List<FeedbackItem> { item1 };

        // Mock response with TSP_APPLICABLE classification
        // Per FeedbackClassificationTemplate:
        // - TSP_APPLICABLE: actionable AND TypeSpec decorators can address it
        var batchResponse = """
            [item-1]
            Classification: TSP_APPLICABLE
            Reason: Can use @@clientName(DocumentIntelligenceClient, "DocumentAnalysisClient") to rename the client
            """;
        _mockAgentRunner
            .Setup(x => x.RunAsync(It.IsAny<CopilotAgent<string>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(batchResponse);

        // Act
        var result = await service.ClassifyAsync(items, "global context");

        // Assert
        Assert.That(result, Is.False, "Items still TSP_APPLICABLE should return false");
        Assert.That(item1.Status, Is.EqualTo(FeedbackStatus.TSP_APPLICABLE));
    }

    [Test]
    public async Task ClassifyAsync_FailureItems_GeneratesNextAction()
    {
        // Arrange
        var service = CreateMockedService();
        // API review feedback requesting streaming support - requires code-level changes -> FAILURE
        var item1 = CreateTestItem("Add support for streaming responses with progress callbacks when uploading large documents", "item-1");
        var items = new List<FeedbackItem> { item1 };

        // First call returns batch classification
        // Second call returns guidance for FAILURE item
        var callCount = 0;
        _mockAgentRunner
            .Setup(x => x.RunAsync(It.IsAny<CopilotAgent<string>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(() =>
            {
                callCount++;
                if (callCount == 1)
                {
                    return """
                        [item-1]
                        Classification: FAILURE
                        Reason: Streaming support with progress callbacks requires code-level implementation; no TypeSpec decorator can add streaming behavior
                        """;
                }
                return "Implement streaming in the SDK by creating a custom operation wrapper that handles chunked uploads and emits progress events.";
            });

        // Act
        var result = await service.ClassifyAsync(items, "global context", language: "python");

        // Assert
        Assert.That(item1.Status, Is.EqualTo(FeedbackStatus.FAILURE));
        Assert.That(item1.NextAction, Is.Not.Null.And.Not.Empty);
        Assert.That(item1.NextAction, Does.Contain("streaming").Or.Contains("upload").Or.Contains("progress"));
    }

    #endregion

    #region Parsing and Edge Case Tests

    [Test]
    public async Task ClassifyAsync_ValidFormat_UpdatesReasonAndContext()
    {
        // Arrange
        var service = CreateMockedService();
        // Non-actionable API review comment -> SUCCESS
        var item = CreateTestItem("The error handling looks good, approved", "item-abc");
        var items = new List<FeedbackItem> { item };

        var batchResponse = """
            [item-abc]
            Classification: SUCCESS
            Reason: Non-actionable feedback - approval comment with no requested changes
            """;
        _mockAgentRunner
            .Setup(x => x.RunAsync(It.IsAny<CopilotAgent<string>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(batchResponse);

        // Act
        await service.ClassifyAsync(items, "global context");

        // Assert
        Assert.That(item.ClassificationReason, Is.EqualTo("Non-actionable feedback - approval comment with no requested changes"));
        Assert.That(item.Context, Does.Contain("Classification: SUCCESS"));
        Assert.That(item.Context, Does.Contain("Reason: Non-actionable feedback - approval comment with no requested changes"));
    }

    [Test]
    public async Task ClassifyAsync_MissingItemInResponse_DefaultsToFailure()
    {
        // Arrange
        var service = CreateMockedService();
        // Non-actionable -> SUCCESS
        var item1 = CreateTestItem("Looks good to me", "item-1");
        // Actionable -> would be TSP_APPLICABLE, but response is missing
        var item2 = CreateTestItem("Make the 'InternalMetrics' operation internal so it's not exposed publicly", "item-2");
        var items = new List<FeedbackItem> { item1, item2 };

        // Response only contains item-1, missing item-2
        var batchResponse = """
            [item-1]
            Classification: SUCCESS
            Reason: Non-actionable feedback - approval
            """;
        _mockAgentRunner
            .Setup(x => x.RunAsync(It.IsAny<CopilotAgent<string>>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(batchResponse);

        // Act
        await service.ClassifyAsync(items, "global context");

        // Assert
        Assert.That(item1.Status, Is.EqualTo(FeedbackStatus.SUCCESS));
        Assert.That(item2.Status, Is.EqualTo(FeedbackStatus.FAILURE), "Missing items should default to FAILURE");
        Assert.That(item2.Context, Does.Contain("missing from batch LLM response"));
    }

    #endregion

    #region Live Integration Tests

    /// <summary>
    /// Live integration test that classifies a comprehensive mix of API review feedback.
    /// Tests all three classification categories:
    /// - TSP_APPLICABLE: @clientName (renames), @access (visibility)
    /// - SUCCESS: Non-actionable (LGTM, keep as is, approvals)
    /// - FAILURE: Code-level changes (custom retry, serialization)
    /// </summary>
    [Test]
    public async Task Live_ClassifyAsync_AllFeedbackCategories_ClassifiesCorrectly()
    {
        if (!await CopilotTestHelper.IsCopilotAvailableAsync())
        {
            Assert.Ignore("Skipping test as GitHub Copilot CLI is either not installed or not authenticated.");
        }

        var service = CreateRealService();

        var items = new List<FeedbackItem>
        {
            // TSP_APPLICABLE: @clientName for renames
            CreateLiveTestItem("Rename 'EmployeeClient' to 'StaffClient' for consistency with the service branding"),
            // TSP_APPLICABLE: @access for visibility
            CreateLiveTestItem("Make the 'PurgeDocuments' operation internal - it should not be exposed in the public SDK"),
            // SUCCESS: Non-actionable approval
            CreateLiveTestItem("LGTM - the pagination follows Azure SDK guidelines"),
            // SUCCESS: Keep as is
            CreateLiveTestItem("No changes needed - the model hierarchy follows Azure best practices"),
            // FAILURE: Requires code-level implementation
            CreateLiveTestItem("Add support for custom retry policies with circuit breaker pattern for transient failures")
        };

        await service.ClassifyAsync(
            items,
            globalContext: "Testing comprehensive feedback classification",
            language: "python",
            serviceName: "TestService");

        LogClassificationResults(items);

        Assert.That(items, Has.All.Property("ClassificationReason").Not.Null.And.Not.Empty,
            "All items should have a reason after classification");

        // TSP_APPLICABLE assertions - check status and that reason mentions the appropriate decorator
        Assert.That(items[0].Status, Is.EqualTo(FeedbackStatus.TSP_APPLICABLE),
            "Client rename should be TSP_APPLICABLE");
        Assert.That(items[0].ClassificationReason, Does.Contain("clientName").IgnoreCase,
            "Rename reason should mention @clientName decorator");

        Assert.That(items[1].Status, Is.EqualTo(FeedbackStatus.TSP_APPLICABLE),
            "Making operation internal should be TSP_APPLICABLE");
        Assert.That(items[1].ClassificationReason, Does.Contain("access").IgnoreCase,
            "Visibility change reason should mention @access decorator");

        // SUCCESS assertions - just check status (reason existence already verified above)
        Assert.That(items[2].Status, Is.EqualTo(FeedbackStatus.SUCCESS),
            "LGTM approval should be SUCCESS - non-actionable");
        Assert.That(items[3].Status, Is.EqualTo(FeedbackStatus.SUCCESS),
            "'No changes needed' should be SUCCESS - non-actionable");

        // FAILURE assertion
        Assert.That(items[4].Status, Is.EqualTo(FeedbackStatus.FAILURE),
            "Custom retry with circuit breaker requires code implementation -> FAILURE");
    }

    /// <summary>
    /// Live test: Verifies items with prior compilation error context are classified as FAILURE.
    /// This represents a retry scenario where previous TypeSpec customization attempt failed.
    /// </summary>
    [Test]
    public async Task Live_ClassifyAsync_WithErrorContext_ClassifiedAsFailure()
    {
        if (!await CopilotTestHelper.IsCopilotAvailableAsync())
        {
            Assert.Ignore("Skipping test as GitHub Copilot CLI is either not installed or not authenticated.");
        }

        var service = CreateRealService();

        // Represents a retry scenario: originally TSP_APPLICABLE but failed compilation
        var id = Guid.NewGuid().ToString();
        var items = new List<FeedbackItem>
        {
            new FeedbackItem
            {
                Id = id,
                Text = "Rename the 'Items' property to 'Documents' for consistency",
                Context = "COMPILATION ERROR: @@clientName target not found - property 'Items' does not exist in model 'ListResponse'"
            }
        };

        await service.ClassifyAsync(
            items,
            globalContext: $"--- TYPESPEC CUSTOMIZATIONS ---\nId: {id}\nText: Rename the 'Items' property to 'Documents'\nContext: COMPILATION ERROR: @@clientName target not found - property 'Items' does not exist in model 'ListResponse'",
            language: "python",
            serviceName: "TestService");

        LogClassificationResults(items);

        Assert.That(items[0].Status, Is.EqualTo(FeedbackStatus.FAILURE),
            "Items with prior compilation errors should be classified as FAILURE - indicates TypeSpec cannot address this");
    }

    /// <summary>
    /// Live test: Verifies FAILURE items generate NextAction guidance for manual implementation.
    /// </summary>
    [Test]
    public async Task Live_ClassifyAsync_FailureItems_GenerateNextActionGuidance()
    {
        if (!await CopilotTestHelper.IsCopilotAvailableAsync())
        {
            Assert.Ignore("Skipping test as GitHub Copilot CLI is either not installed or not authenticated.");
        }

        var service = CreateRealService();

        // Request that requires code-level SDK implementation - no TypeSpec decorator can address
        var items = new List<FeedbackItem>
        {
            CreateLiveTestItem("Add support for streaming responses with progress callbacks when downloading large blobs")
        };

        await service.ClassifyAsync(
            items,
            globalContext: "Testing manual guidance generation for code-level changes",
            language: "python",
            serviceName: "StorageBlob",
            codeCustomizationDocUrl: "https://aka.ms/azsdk/python/customization");

        LogClassificationResults(items);

        Assert.That(items[0].Status, Is.EqualTo(FeedbackStatus.FAILURE),
            "Streaming with progress callbacks requires code implementation -> FAILURE");
        Assert.That(items[0].NextAction, Is.Not.Null.And.Not.Empty,
            "FAILURE items should have NextAction guidance for manual implementation");

        TestContext.WriteLine($"NextAction guidance:\n{items[0].NextAction}");
    }

    #endregion
}
