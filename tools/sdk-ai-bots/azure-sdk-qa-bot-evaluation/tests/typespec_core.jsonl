{"testcase": "What decorator should be used in this case?", "query": "title: What decorator should be used in this case?\n\nquestion: Hi team,\nIn version v2, we introduced a new model model2 and updated featureA (originally added in v1) to use model2 as its parameter. In v1, featureA used model1 at the same position.\nHere’s the setup I tried (using @typeChangedFrom):\n```\n@added(v1)\nmodel1;\n@added(v2)\nmodel2;\n@added(v1)\nfeatureA {\n@typeChangedFrom(v1, model1)\nbody: model2;\n}\n```\nHowever, this shows the error: \"model2 does not exist in v1\".\nWhat would be the correct decorator to use in this situation?\nThank you!", "ground_truth": "it should be `typedChangedFrom(v2, model1)` here otherwise you are saying in v1 you changed from using model1 to model2 which then of course doesn't exists", "context": "", "response_length": 155}
{"testcase": "Hi team, could someone please help grant me permission to view the workflow for my Azure REST API PR?", "query": "title: Hi team, could someone please help grant me permission to view the workflow for my Azure REST API PR?\n\nquestion: Right now, after pushing my commit, I’m unable to see the error details for the validation checks, it just says “at least one review required to see the workflow.” This makes it difficult to verify if my changes are passing validation before the final review.\nWould it be possible to enable workflow visibility for me so I can debug and ensure everything is in order ahead of time? PR link: [Stable version 2025-09-01 with prevalidation and autoscale changes by prachinandi · Pull Request #3…](https://github.com/Azure/azure-rest-api-specs/pull/37218)", "ground_truth": "You need to get the necessary permissions, see here: https://aka.ms/azsdk/access", "context": "", "response_length": 80}
{"testcase": "Service under conversation label", "query": "title: Service under conversation label\n\nquestion: My team currently has a PR open to release a new stable API. However, due to backend delays, it’s been open since July. During that time, the [typespec migration PR](https://github.com/Azure/azure-rest-api-specs/pull/36556) was drafted against our preview API. Now, the service-under-conversion label has been added to our stable PR. I’d like to understand does this label indicate a delay in merging in our [stable api PR](https://github.com/Azure/azure-rest-api-specs/pull/36219), or will we need to make additional changes?", "ground_truth": "The label should not impact your previous PR, and , if this is a later api-version thatn the conversion PR, the conversion would normally be based on that version once checked in.", "context": "", "response_length": 179}
{"testcase": "Design question about suppression rules", "query": "title: Design question about suppression rules\n\nquestion: Hi team,\nWe're working to put together a TypeSpec definitions package for OpenAI API surface.\nThis will then get consumed by teams authoring Azure APIs. As such, they have the Azure linting in place (naming conventions and whatnot).\nWe wanted to know whether definitions can also come with suppressions (not inline, as this definition is auto-importer on a regular basis), which would apply ONLY to the definitions we share, not to the rest of the consumer's project?\nThanks!", "ground_truth": "suppression can only be provided inline for now. Linter rules can be disabled globally but that would apply to the whole project, can't filter by files", "context": "", "response_length": 151}
{"testcase": "what's typespec", "query": "title: what's typespec\n\nquestion: what's typespec?", "ground_truth": "TypeSpec is a language and toolset developed by Microsoft for defining APIs and data models in a structured, reusable, and extensible way. It is similar to TypeScript in syntax, but is specifically designed for describing the shape and behavior of APIs (such as REST, gRPC, or GraphQL), not for general-purpose programming.\nTypeSpec allows you to:\nDefine the interface of your API, including operations, request/response models, and error handling.\nGenerate artifacts such as OpenAPI (Swagger) specifications, SDKs, and documentation from a single source of truth.\nEnforce API design consistency and reduce errors, especially in large organizations or when following strict guidelines (like Azure's API standards).\nReuse and extend models and patterns using TypeSpec libraries and templates.\nFor Azure, TypeSpec has dedicated extensions and libraries that help you follow Azure API guidelines and make it easier to build ARM (Azure Resource Manager) and data-plane services. Using TypeSpec leads to APIs that are easier to review, more consistent, and better supported by tooling.\nYou can get started by installing the TypeSpec CLI and using templates to quickly scaffold a project. For more information, see the official documentation linked below.", "context": "", "response_length": 1249}