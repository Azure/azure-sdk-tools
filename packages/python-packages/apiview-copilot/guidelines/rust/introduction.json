[
  {
    "id": "rust_introduction.html#rust-general-follow-general-guidelines",
    "category": "General Guidelines {#rust-general}",
    "text": "DO follow the [General Azure SDK Guidelines]."
  },
  {
    "id": "rust_introduction.html#rust-general-pipeline",
    "category": "General Guidelines {#rust-general}",
    "text": "DO use azure_core::Pipeline to implement all methods that call Azure REST services."
  },
  {
    "id": "rust_introduction.html#rust-general-idiomatic-code",
    "category": "General Guidelines {#rust-general}",
    "text": "DO write idiomatic Rust code. If you\u2019re not familiar with the language, a great place to start is https://www.rust-lang.org/learn (https://www.rust-lang.org/learn)  Do NOT simply attempt to translate your language of choice into Rust."
  },
  {
    "id": "rust_introduction.html#rust-general-version",
    "category": "General Guidelines {#rust-general}",
    "text": "DO NOT use grammar or features newer than the rust-version declared in the root Cargo.toml workspace."
  },
  {
    "id": "rust_introduction.html#rust-general-dependencies",
    "category": "General Guidelines {#rust-general}",
    "text": "DO NOT unconditionally depend on any particular async runtime or HTTP stack."
  },
  {
    "id": "rust_introduction.html#rust-general-dependencies-default",
    "category": "General Guidelines {#rust-general}",
    "text": "YOU SHOULD depend on tokio (async runtime) and reqwest (HTTP stack) in the default feature for crates e.g.:\n\n```toml\n[dependencies]\nreqwest = { workspace = true, optional = true }\n\n[features]\ndefault = [ \"reqwest\" ]\nreqwest = [ \"dep:reqwest\" ]\n\n```\n\nDefault features can be ignored by consumers and individual features enabled as needed. This allows consumers to ignore default features and use their own HTTP stack and/or async runtime to implement a client."
  },
  {
    "id": "rust_introduction.html#rust-general-unwrap",
    "category": "General Guidelines {#rust-general}",
    "text": "DO NOT call unwrap(), expect(), or other functions that may panic unless you are absolutely sure they never will. It's almost always better to use map(), unwrap_or_else(), or a myriad of related functions to remap errors, return suitable defaults, etc."
  },
  {
    "id": "rust_introduction.html#rust-general-prelude",
    "category": "General Guidelines {#rust-general}",
    "text": "DO NOT define a prelude module.\n\nThese may lead to name collisions, especially when multiple versions of a crate are imported.\n\nThis document contains guidelines developed primarily for typical Azure REST services i.e., stateless services with request-response based interaction model. Many of the guidelines in this document are more broadly applicable, but some might be specific to such REST services.\n\nThe API surface of your client library must have the most thought as it is the primary interaction that the consumer has with your service."
  },
  {
    "id": "rust_introduction.html#rust-api-naming-concise",
    "category": "Azure SDK API Design {#rust-api}",
    "text": "DO use clear, concise, and meaningful names."
  },
  {
    "id": "rust_introduction.html#rust-api-naming-standard",
    "category": "Azure SDK API Design {#rust-api}",
    "text": "DO follow [Rust naming conventions][rust-lang-naming]."
  },
  {
    "id": "rust_introduction.html#rust-api-naming-abbreviation",
    "category": "Azure SDK API Design {#rust-api}",
    "text": "YOU SHOULD NOT use abbreviations unless necessary or when they are commonly used and understood. For example, iot is used since it is a commonly understood industry term; however, using kv for Key Vault would not be allowed since kv is not commonly used to refer to Key Vault.\n\nWith mixed casing like \"IoT\", consider the following guidelines:\nFor module and method names, always use lowercase e.g., get_secret().\nFor type names, use PascalCase e.g., SecretClient."
  },
  {
    "id": "rust_introduction.html#rust-api-dependencies",
    "category": "Azure SDK API Design {#rust-api}",
    "text": "DO consult the [Architecture Board] if you wish to use a dependency that is not on the list of [centrally managed dependencies][rust-lang-workspace-dependencies].\n\nService clients are the main starting points for developers calling Azure services with the Azure SDK. Each client library should have at least one client in its main namespace, so it\u2019s easy to discover. The guidelines in this section describe patterns for the design of a service client.\n\nThere exists a distinction that must be made clear with service clients: not all classes that perform HTTP (or otherwise) requests to a service are automatically designated as a service client. A service client designation is only applied to classes that are able to be directly constructed because they are uniquely represented on the service. Additionally, a service client designation is only applied if there is a specific scenario that applies where the direct creation of the client is appropriate. If a resource can not be uniquely identified or there is no need for direct creation of the type, then the service client designation should not apply."
  },
  {
    "id": "rust_introduction.html#rust-client-name",
    "category": "Service Client {#rust-client}",
    "text": "DO name service client types with the Client suffix e.g., SecretClient.\n\nClient names are specific to the service to avoid ambiguity when using multiple clients without requiring as to change the binding name when importing e.g.,\n\n```text\nerror[E0252]: the name `Client` is defined multiple times\n  --&gt; src/main.rs:2:38\n   |\n1  |     use azure_storage_blob::Client;\n   |         ----------- previous import of the type `Client` here\n2  |     use azure_security_keyvault_secrets::Client;\n   |         ^^^^^^^^^^^ `Client` reimported here\n   |\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-client-namespace",
    "category": "Service Client {#rust-client}",
    "text": "DO export all service client and their client options that the consumer can create and is most likely to interact with in the root module of the client library e.g., azure_security_keyvault_secrets."
  },
  {
    "id": "rust_introduction.html#rust-client-clients-module",
    "category": "Service Client {#rust-client}",
    "text": "DO export all clients, subclients, and their client options from a clients submodule of the crate root e.g., azure_security_keyvault_secrets::clients. Clients that can be created directly as described above should be re-exported from the crate root."
  },
  {
    "id": "rust_introduction.html#rust-client-models-module",
    "category": "Service Client {#rust-client}",
    "text": "DO export all models and client method options from a models submodule of the crate root e.g., azure_security_keyvault_secrets::models e.g.,\n\n```rust\n// lib.rs\npub mod clients;\npub mod models;\n\npub use clients::SecretClient;\n\n```\n\nSee [Rust modules][rust-modules] for more information."
  },
  {
    "id": "rust_introduction.html#rust-client-immutable",
    "category": "Service Client {#rust-client}",
    "text": "DO ensure that all service client methods are thread safe (usually by making them immutable and stateless)."
  },
  {
    "id": "rust_introduction.html#rust-client-endpoint",
    "category": "Service Client {#rust-client}",
    "text": "DO define a public endpoint(&self) -> &azure_core::Url method to get the endpoint used to create the client."
  },
  {
    "id": "rust_introduction.html#rust-client-internal-fields",
    "category": "Service Client {#rust-client}",
    "text": "DO define all fields within a client struct with pub(crate) accessibility. This allows the fields e.g., the pipeline, to be used in [convenience clients' extension methods][rust-client-convenience]."
  },
  {
    "id": "rust_introduction.html#rust-client-constructors-new",
    "category": "Service Client Constructors {#rust-client-constructors}",
    "text": "DO define a public function new that takes the following form and returns Self or azure_core::Result<Self> if the function may fail.\n\n```rust\nimpl SecretClient {\n    pub fn new(endpoint: impl AsRef&lt;str&gt;, credential: std::sync::Arc&lt;dyn azure_core::TokenCredential&gt;, options: Option&lt;SecretClientOptions&gt;) -&gt; azure_core::Result&lt;Self&gt; {\n        let endpoint = azure_core::Url::parse(endpoint.as_ref())?;\n        let options = options.unwrap_or_default();\n\n        todo!()\n    }\n}\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-client-constructors-credential",
    "category": "Service Client Constructors {#rust-client-constructors}",
    "text": "YOU MAY accept a different credential type if the service does not support AAD authentication."
  },
  {
    "id": "rust_introduction.html#rust-client-constructors-multiple-credentials",
    "category": "Service Client Constructors {#rust-client-constructors}",
    "text": "DO define a new function that takes a TokenCredential and a with_{credential_type} function e.g., with_key_credential if a client supports both AAD authentication and other token credentials that do not implement TokenCredential.\n\nIn cases when different credential types are supported, we want the primary use case to support AAD authentication over other authentication schemes.\n\nClient options should be plain old data structures to allow easy, idiomatic creation of options and to easily share these options across multiple clients as needed."
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-name",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "DO define a client options struct with the same as the client name + \"Options\" e.g., a SecretClient takes a SecretClientOptions."
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-namespace",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "YOU SHOULD export client option structs from the same module(s) from which clients and subclients are exported e.g., azure_security_keyvault_secrets and azure_security_keyvault_secrets::clients for SecretClient.\n\nSee [Rust modules][rust-modules] for more information."
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-fields",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "DO define all client-specific fields of client option structs as public and of type Option<T> except for api_version of type String, if applicable."
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-fields-options",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "DO define an client_options: azure_core::ClientOptions public field."
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-clone",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "DO derive Clone to support cloning client configuration for other clients."
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-debug",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "YOU SHOULD NOT derive Debug since this may inadvertently leak PII. Derive [azure_core::fmt::SafeDebug][rust-safety-debug] instead."
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-default",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "DO implement Default to support creating default client configuration including the default api_version used when calling into the service.\n\nThe requirements above would define an example client options struct like:\n\n```rust\nuse azure_core::{ClientOptions, fmt::SafeDebug};\n\n#[derive(Clone, SafeDebug)]\npub struct SecretClientOptions {\n    pub api_version: String,\n    pub client_options: ClientOptions,\n}\n\nimpl Default for SecretClientOptions {\n    fn default() -&gt; Self {\n        Self {\n            api_version: \"7.5\".to_string(),\n            options: ClientOptions::default(),\n        }\n    }\n}\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-env",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "DO NOT use client library-specific runtime configuration such as environment variables or configuration files. Some environments e.g., WASM or many IoT devices won't have access to an environment block or file system."
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-env-sys",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "DO NOT change the default values of the client options based on system or program state."
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-env-build",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "DO NOT change the default values of the client options based on how the client library was built."
  },
  {
    "id": "rust_introduction.html#rust-client-configuration-immutable",
    "category": "Client Configuration {#rust-client-configuration}",
    "text": "DO NOT change the behavior of the client after the client is constructed with the following exceptions:\nLog level, which must take effect immediately across all client libraries.\nTracing on or off, which must take effect immediately across all client libraries."
  },
  {
    "id": "rust_introduction.html#rust-client-api-version-latest",
    "category": "Service Versions {#rust-client-api-version}",
    "text": "DO call the latest supported service API version by default. Typically this will be the API version from which the client library was generated."
  },
  {
    "id": "rust_introduction.html#rust-client-api-version-override",
    "category": "Service Versions {#rust-client-api-version}",
    "text": "DO allow the consumer to explicitly set a service API version when instantiating the service client.\n\nWe are reevaluating options for mocking to provide the best experience for API consumers whether or not they plan to utilize mocks or fakes."
  },
  {
    "id": "rust_introduction.html#rust-client-methods",
    "category": "Service Methods {#rust-client-methods}",
    "text": "DO take a body: RequestContent<T> if and only if the service method accepts a request body e.g., POST or PUT."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-params",
    "category": "Service Methods {#rust-client-methods}",
    "text": "DO use the service specified name of all parameters."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-configuration-name",
    "category": "Service Methods {#rust-client-methods}",
    "text": "DO define a client method options struct with the same name as the client, client method name, and \"Options\" e.g., a set_secret takes an Option<SecretClientSetSecretOptions> as the last parameter.\nThis is required even if the service method does not currently take any options because - should it ever add options - the client method signature does not have to change and will not break callers."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-configuration-namespace",
    "category": "Service Methods {#rust-client-methods}",
    "text": "DO export client method option structs from the models module e.g., azure_security_keyvault_secrets::models.\n\nSee [Rust modules][rust-modules] for more information."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-configuration-fields",
    "category": "Service Methods {#rust-client-methods}",
    "text": "DO define all client method-specific fields of method option structs as public and of type Option<T>."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-configuration-fields-options",
    "category": "Service Methods {#rust-client-methods}",
    "text": "DO define a method_options: azure_core::ClientMethodOptions public field."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-configuration-clone",
    "category": "Service Methods {#rust-client-methods}",
    "text": "DO derive Clone to support cloning method configuration for additional client method invocations."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-configuration-debug",
    "category": "Service Methods {#rust-client-methods}",
    "text": "DO derive Debug since this may inadvertently leak PII. Derive [azure_core::fmt::SafeDebug][rust-safety-debug] instead."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-configuration-default",
    "category": "Service Methods {#rust-client-methods}",
    "text": "DO derive or implement Default to support creating default method configuration.\n\nThe requirements above would define an example client options struct like:\n\n```rust\nuse azure_core::{ClientMethodOptions, fmt::SafeDebug};\n\nimpl SecretClientMethods for SecretClient {\n    async fn set_secret(\n        &amp;self,\n        name: &amp;str,\n        options: Option&lt;SecretClientSetSecretOptions&gt;,\n    ) -&gt; azure_core::Result&lt;Response&lt;KeyVaultSecret&gt;&gt; {\n        todo!()\n    }\n}\n\n#[derive(Clone, SafeDebug, Default)]\npub struct SecretClientSetSecretOptions {\n    pub enabled: Option&lt;bool&gt;,\n    pub method_options: ClientMethodOptions,\n}\n\n```\n\nThe Rust SDK is designed for asynchronous API calls. Customers who need synchronous calls may use something like futures::executor::block_on (https://docs.rs/futures/latest/futures/executor/fn.block_on.html) to wait synchronously on a Future."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-async-api",
    "category": "Sync and Async {#rust-client-methods-async}",
    "text": "DO provide an asynchronous programming model for service methods."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-async-nosync",
    "category": "Sync and Async {#rust-client-methods-async}",
    "text": "DO NOT provide a synchronous programming model for service methods."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-naming-case",
    "category": "Naming {#rust-client-methods-naming}",
    "text": "DO use snake_case method names converted from likely either camelCase or PascalCase declared in the service specification e.g., getResource would be declared as get_resource."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-naming-verbs",
    "category": "Naming {#rust-client-methods-naming}",
    "text": "DO use the following verb patterns for CRUD operations:\n\n| Pattern       | HTTP Method  | Comments\n| ------------- | ------------ | --------\n| add_{noun}    | POST or PUT  | Add a resource to a collection. Fails if the resource exists.\n| delete_{noun} | DELETE       | Delete a resource. Does not fail if the resource does not exist.\n| get_{noun}    | GET          | Get a resource. Fails if the resource does not exist.\n| list_{noun}   | GET          | {#rust-client-methods-naming-list} Get a collection of resources. May be in zero or may pages of results. Returns an empty list if no resources exist.\n| {noun}exists | GET or HEAD  | Check if a resource exists.\n| set{noun}    | POST or PUT  | Adds a new or updates an existing resource.\n| update_{noun} | PATCH or PUT | Updates existing resources. Fails if resource does not exist."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-naming-conversion-prefix",
    "category": "Naming {#rust-client-methods-naming}",
    "text": "DO use the following prefixes in the described scenarios:\n\n| Prefix | Scenario | Example |\n| ------ | -------- | ------- |\n| (none) | field getter | field_name(&self) -> FieldType |\n| with_ | non-default constructor or field setter returning Self - typically used in builders | with_field_name(&mut self, value: FieldType) -> &mut Self |\n| set_ | field setter returning nothing or anything else | set_field_name(&mut self, value: FieldType) |"
  },
  {
    "id": "rust_introduction.html#rust-client-methods-options-separate",
    "category": "Operation Options {#rust-client-methods-options}",
    "text": "DO separate the Context containing client method options from service method options. See example above.\n\nThe azure_core::Pipeline is constructed when the service client constructed, and because the clients must be immutable the pipeline cannot be altered directly.\nAny data passed to client methods to alter the pipeline e.g., retry policy options, must be passed to pipeline policies via the Context."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-options-context",
    "category": "Operation Options {#rust-client-methods-options}",
    "text": "DO pass pipeline policy options in the Context passed to each pipeline policy."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-options-pipeline",
    "category": "Operation Options {#rust-client-methods-options}",
    "text": "DO clone the azure_core::Pipeline if the list of pipeline policies is altered by a client method e.g., a custom pipeline policy is added per-call."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-options-api-version",
    "category": "Operation Options {#rust-client-methods-options}",
    "text": "YOU MAY allow the caller to change the API version e.g., api-version when calling the endpoint."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-return-pageable",
    "category": "Return Types {#rust-client-methods-return}",
    "text": "DO return an azure_core::Result<azure_core::Pager<T>> from an async fn when the service returns a pageable response."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-return-lro",
    "category": "Return Types {#rust-client-methods-return}",
    "text": "DO return an azure_core::Result<azure_core::Poller<T>> from an async fn when the service implements the operation a long-running operation."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-return-result",
    "category": "Return Types {#rust-client-methods-return}",
    "text": "DO return an azure_core::Result<azure_core::Response<T>> from an async fn for all other service responses.\nIf the service method does not return any content e.g., HTTP 204, the client method should return a Result<Response<()>> containing the () unit type."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-return-raw-response",
    "category": "Return Types {#rust-client-methods-return}",
    "text": "DO provide the status code, headers, and self-consuming async raw response stream from all return types e.g.,\n\n```rust\nimpl&lt;T&gt; Response&lt;T&gt; {\n    pub fn status(&amp;self) -&gt; &amp;StatusCode {\n        todo!()\n    }\n\n    pub fn headers(&amp;self) -&gt; &amp;Headers {\n        todo!()\n    }\n\n    pub async fn into_content(self) -&gt; ResponseContent {\n        todo!()\n    }\n}\n\n```\n\nThis is equivalent to returning an impl Future<Output = azure_core::Result<azure_core::Response<T>>> from an fn."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-return-headers-methods",
    "category": "Return Types {#rust-client-methods-return}",
    "text": "DO must export extension method traits for defined headers from the models module on Response<T> where T is a model type.\nIf the method does not return a model and would other return the unit type Response<()>, you should instead return an empty struct using the same naming convention has options: client name + method name + \"Result\" e.g.,\n\n```rust\n#[derive(SafeDebug)]\npub struct SecretClientSetSecretResult;\n\n```\n\nThis should be treated as a model, so derive the same traits and export from models as you would any other model."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-return-headers-methods-name",
    "category": "Return Types {#rust-client-methods-return}",
    "text": "DO name the trait similar to options: client name + method name + \"Ext\" e.g., SecretClientSetSecretExt."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-return-headers-methods-return",
    "category": "Return Types {#rust-client-methods-return}",
    "text": "DO return an azure_core::Result<Option<T>> where T is an appropriate type for the header e.g., usize for content-length, azure_core::Etag for etags, etc.\nThe implementation can simply call methods like Headers::get_optional_as() or Headers::get_optional_string() as appropriate."
  },
  {
    "id": "rust_introduction.html#rust-client-methods-return-headers-methods-sealed",
    "category": "Return Types {#rust-client-methods-return}",
    "text": "DO seal the trait to prevent it from being implemented by other types as shown in the example below.\nImplementations should use a single definition of private::Sealed for all such traits that require it.\n\n```rust\npub trait SecretClientSetSecretExt: private::Sealed {\n    fn content_type_header(&amp;self) -&gt; azure_core::Result&lt;Option&lt;String&gt;&gt;;\n}\n\nimpl SecretClientSetSecretExt for Response&lt;SecretBundle&gt; {\n    fn content_type_header(&amp;self) -&gt; azure_core::Result&lt;Option&lt;String&gt;&gt; {\n        Ok(self.headers().get_optional_string(&amp;headers::CONTENT_TYPE))\n    }\n}\n\nmod private {\n    pub trait Sealed {}\n    impl Sealed for Response&lt;SecretBundle&gt; {}\n}\n\n```\n\nCancelling an asynchronous method call in Rust is done by dropping the Future.\n\nThe Rust std crate itself does not implement an async runtime, so different async runtimes must be chosen by the caller and may support cancellation different. tokio is common and should be the default, but not required.\nVarious extensions also exist that the caller may use that may otherwise not work with passing in a cancellation token like in some other Azure SDK languages."
  },
  {
    "id": "rust_introduction.html#rust-parameters-self",
    "category": "Service Method Parameters {#rust-parameters}",
    "text": "DO take a &self as the first parameter. All service clients must be immutable"
  },
  {
    "id": "rust_introduction.html#rust-parameters-into",
    "category": "Service Method Parameters {#rust-parameters}",
    "text": "DO declare parameter types as reference types e.g., &str (or any reference to type &T)` when the data only needs to be borrowed e.g., a URL parameter.\n\n```rust\nimpl SecretClient {\n    pub fn new(endpoint: &amp;str) -&gt; Result&lt;Self&gt; {\n        let endpoint = azure_core::Url::parse(endpoint)?;\n\n        todo!()\n    }\n}\n\n```\n\nThe endpoint parameter is never saved so a reference is fine. Except for possible body parameters, any parameter should typically be borrowed since required parameters comprise URL path segments or query parameters."
  },
  {
    "id": "rust_introduction.html#rust-parameters-request-content",
    "category": "Service Method Parameters {#rust-parameters}",
    "text": "DO declare a parameter named content of type RequestContent<T>, where T is the service-defined request model."
  },
  {
    "id": "rust_introduction.html#rust-parameters-request-content-convert",
    "category": "Service Method Parameters {#rust-parameters}",
    "text": "DO support converting to a RequestContent<T> from a T, Stream, or AsRef<str>."
  },
  {
    "id": "rust_introduction.html#rust-parameters-interior-mutability",
    "category": "Service Method Parameters {#rust-parameters}",
    "text": "YOU MAY use interior mutability e.g., std::sync::OnceLock for single-resource caching e.g., a single key-specific CryptographyClient that attempts to download the public key material for subsequent public key operations.\n\nThe service client will have several methods that perform requests on the service. Service parameters are directly passed across the wire to an Azure service. Client parameters are not passed directly to the service, but used within the client library to fulfill the request. Examples of client parameters include values that are used to construct a URI or a file that needs to be uploaded to storage."
  },
  {
    "id": "rust_introduction.html#rust-parameters-validation-client",
    "category": "Parameter Validation {#rust-parameters-validation}",
    "text": "DO validate client parameters."
  },
  {
    "id": "rust_introduction.html#rust-parameters-validation-server",
    "category": "Parameter Validation {#rust-parameters-validation}",
    "text": "DO NOT validate service parameters. This includes null checks, empty strings, and other common validating conditions. Let the service validate any request parameters."
  },
  {
    "id": "rust_introduction.html#rust-parameters-validation-server-defaults",
    "category": "Parameter Validation {#rust-parameters-validation}",
    "text": "DO NOT encode service parameter default values. These values may change from version to version and may cause unexpected results when calling older versions from a newer client. Let the service apply default parameter values."
  },
  {
    "id": "rust_introduction.html#rust-parameters-validation-check-devex",
    "category": "Parameter Validation {#rust-parameters-validation}",
    "text": "DO validate the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. If the developer experience is compromised due to service-side error messages, work with the service team to correct prior to release.\n\nRust is a lower-level language but often provides higher-level, zero-cost abstractions such as iterators. Iterators are an idiomatic way to enumerate vectors or streams such as futures::Stream."
  },
  {
    "id": "rust_introduction.html#rust-paging-pageable",
    "category": "Methods Returning Collections (Paging) {#rust-paging}",
    "text": "DO return an azure_core::Pager<T> from pageable service client methods where T is model type being enumerated."
  },
  {
    "id": "rust_introduction.html#rust-paging-pageable-stream",
    "category": "Methods Returning Collections (Paging) {#rust-paging}",
    "text": "DO implement futures::Stream for azure_core::Pager<T>. This defines a poll_next() method that returns an Option<T> that returns None when the consumer has reached the end of the result set. This will enumerate all items for all pages."
  },
  {
    "id": "rust_introduction.html#rust-paging-pageable-page",
    "category": "Methods Returning Collections (Paging) {#rust-paging}",
    "text": "DO implement an to_page(&self) -> &azure_core::Page<T> for azure_core::Pager<T> that returns the current page of items."
  },
  {
    "id": "rust_introduction.html#rust-paging-pageable-page-iter",
    "category": "Methods Returning Collections (Paging) {#rust-paging}",
    "text": "DO implement IntoIterator on azure_core::Page<T>. This allows customers to enumerate each page separately, and to enumerate each page of items therein."
  },
  {
    "id": "rust_introduction.html#rust-paging-pageable-page-iter-size",
    "category": "Methods Returning Collections (Paging) {#rust-paging}",
    "text": "DO implement Iterator::size_hint() on the returned IntoIterator for azure_core::Page<T>."
  },
  {
    "id": "rust_introduction.html#rust-paging-pageable-restart",
    "category": "Methods Returning Collections (Paging) {#rust-paging}",
    "text": "DO support reconstructing an azure_core::Pager<T> so that a caller can start paging from a previous state.\n\nSome service operations, known as [Long-running Operations][rest-lro] or LROs take a long time to execute - up to hours or even days. Such operations do not return their result immediately but rather are started and their progressed polled until the operation reaches a terminal state including Succeeded, Failed, or Canceled.\n\nThe azure_core crate exposes an abstract type called azure_core::Poller<T>, which represents LROs and supports operations for polling and waiting for status changes, and retrieving the final operation result. A service method invoking a long-running operation will return an azure_core::Poller<T> as described below."
  },
  {
    "id": "rust_introduction.html#rust-lro-prefix",
    "category": "Methods Invoking Long-running Operations {#rust-lro}",
    "text": "DO name all methods that start an LRO with the begin_ prefix."
  },
  {
    "id": "rust_introduction.html#rust-lro-stream",
    "category": "Methods Invoking Long-running Operations {#rust-lro}",
    "text": "DO implement futures::Stream for azure_core::Poller<T>. This defines a poll_next() method that returns an Option<T> that returns None when the polling has terminated."
  },
  {
    "id": "rust_introduction.html#rust-lro-restart",
    "category": "Methods Invoking Long-running Operations {#rust-lro}",
    "text": "DO support reconstructing an azure_core::Poller<T> so that a caller can start polling from a previous state."
  },
  {
    "id": "rust_introduction.html#rust-etag-options",
    "category": "Conditional Request Methods {#rust-etag}",
    "text": "DO define ETag-related options e.g., if_match, if_none_match, etc., in the service method options e.g.:\n\n```rust\nuse azure_core::SafeDebug;\n\n#[derive(Clone, SafeDebug)]\npub struct SetSecretOptions {\n    enabled: Option&lt;bool&gt;,\n    if_match: Option&lt;azure_core::ETag&gt;,\n}\n\n```\n\nSubclients can only be returned by other clients and cannot be constructed by developers using our crates. See [General Azure SDK Terminology] general guidelines."
  },
  {
    "id": "rust_introduction.html#rust-subclients-return",
    "category": "Hierarchical Clients {#rust-subclients}",
    "text": "YOU MAY return clients from other clients e.g., a DatabaseClient from a CosmosClient."
  },
  {
    "id": "rust_introduction.html#rust-subclients-create",
    "category": "Hierarchical Clients {#rust-subclients}",
    "text": "DO NOT define constructors on subclients. They must be constructed only from other clients."
  },
  {
    "id": "rust_introduction.html#rust-subclients-suffix",
    "category": "Hierarchical Clients {#rust-subclients}",
    "text": "DO name all client methods returning a client with the _client suffix e.g., CosmosClient::database_client()."
  },
  {
    "id": "rust_introduction.html#rust-subclients-export",
    "category": "Hierarchical Clients {#rust-subclients}",
    "text": "DO NOT export subclients from the crate root. They should be exported from a clients submodule of the crate root example azure_security_keyvault_secrets::clients.\n\nSee [Rust modules][rust-modules] for more information."
  },
  {
    "id": "rust_introduction.html#rust-subclients-noasync",
    "category": "Hierarchical Clients {#rust-subclients}",
    "text": "DO NOT define client methods returning a client as asynchronous."
  },
  {
    "id": "rust_introduction.html#rust-subclients-pipeline",
    "category": "Hierarchical Clients {#rust-subclients}",
    "text": "DO clone the parent client azure_core::Pipeline so that lifetime parameters and guarantees are not required.\n\nIn addition to service client types, Azure SDK APIs provide and use other supporting types as well.\n\nThis section describes guidelines for the design model types and all their transitive closure of public dependencies (i.e. the model graph). A model type is a representation of a REST service's resource."
  },
  {
    "id": "rust_introduction.html#rust-model-types-derive",
    "category": "Model Types {#rust-model-types}",
    "text": "DO derive or implement Clone and Default for all model structs."
  },
  {
    "id": "rust_introduction.html#rust-model-types-serde",
    "category": "Model Types {#rust-model-types}",
    "text": "DO derive or implement serde::Serialize and/or serde::Deserialize as appropriate i.e., if the model is input (serializable), output (deserializable), or both."
  },
  {
    "id": "rust_introduction.html#rust-model-types-serde",
    "category": "Model Types {#rust-model-types}",
    "text": "DO derive or implement azure_core::Model for HTTP response models. Your crate must also have a direct dependency on typespec_client_core."
  },
  {
    "id": "rust_introduction.html#rust-model-types-serde",
    "category": "Model Types {#rust-model-types}",
    "text": "DO attribute models with #[typespec(format = \"...\")] if the response containing the model uses a format other than JSON.\n\n```rust\n#[derive(azure_core::Model)]\n#[typespec(format = \"xml\")]\nstruct Example {\n    pub foo: String\n}\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-model-types-public",
    "category": "Model Types {#rust-model-types}",
    "text": "DO define all fields as pub."
  },
  {
    "id": "rust_introduction.html#rust-model-types-optional",
    "category": "Model Types {#rust-model-types}",
    "text": "DO define all non-vector fields using Option<T>."
  },
  {
    "id": "rust_introduction.html#rust-model-types-vectors",
    "category": "Model Types {#rust-model-types}",
    "text": "DO define all vector fields as Vec<T>.\nThese must deserialize as empty (non-allocating) if the vector they are deserializing is missing or empty, and should serialize as empty except in JSON merge+patch payloads.\n\nThough uncommon, service definitions do not always match the service implementation when it comes to required fields. Upon the recommendation of the Breaking Change Reviewers, the specification is often changed to reflect the service if the service has already been deployed."
  },
  {
    "id": "rust_introduction.html#rust-model-types-serde-optional",
    "category": "Model Types {#rust-model-types}",
    "text": "DO attribute fields with #[serde(skip_serializing_if = \"Option::is_none\")] unless an explicit null must be serialized."
  },
  {
    "id": "rust_introduction.html#rust-model-types-non-exhaustive",
    "category": "Model Types {#rust-model-types}",
    "text": "DO attribute response-only model structs with #[non_exhaustive].\n\nThis forces all downstream crates, for example, to use the .. operator to match any remaining fields that may be added in the future for pattern binding:\n\n```rust\n// struct Example {\n//     pub foo: Option&lt;String&gt;,\n//     pub bar: Option&lt;i32&gt;,\n// }\n\nlet { foo, bar, .. } = client.method().await?.try_into()?;\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-model-types-not-non-exhaustive",
    "category": "Model Types {#rust-model-types}",
    "text": "DO NOT attribute request-only or request-response model structs with #[non_exhaustive].\n\nThis prevents downstream crates from creating types even when using the ..Default::default() expression, which means developers cannot construct models as plain data objects.\n\nSee [RFC 2008][rust-lang-rfc-2008] for more information."
  },
  {
    "id": "rust_introduction.html#rust-model-names-type",
    "category": "Model Type Naming {#rust-model-names}",
    "text": "DO define models using the names from TypeSpec unless those names conflict with keywords or common types from std, futures, or other common dependencies.\n\nIf name collisions are likely and the TypeSpec cannot be changed, you can either use the @clientName TypeSpec decorator or update a client .tsp file."
  },
  {
    "id": "rust_introduction.html#rust-model-names-fields",
    "category": "Model Type Naming {#rust-model-names}",
    "text": "DO define model fields using \"camelCase\".\n\nTo facilitate this, attribute the model type:\n\n```rust\n#[derive(serde::Serialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Example {\n    pub compound_name: String, // -&gt; \"compoundName\"\n}\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-model-names-rename",
    "category": "Model Type Naming {#rust-model-names}",
    "text": "DO NOT rename fields using the #[serde] attribute or by other means. All model changes must only be done in TypeSpec.\n\nThough we prefer a new() constructor function to create instances, builders are still an idiomatic pattern in Rust, such as the [typestate builder pattern][rust-lang-typestate] that can help guide developers into constructing a valid type variants."
  },
  {
    "id": "rust_introduction.html#rust-builders-support",
    "category": "Builders {#rust-builders}",
    "text": "YOU MAY implement builders for special cases e.g., URI builders.\n\nIf you do implement a builder, it must be defined according to the following guidelines:"
  },
  {
    "id": "rust_introduction.html#rust-builders-factory",
    "category": "Builders {#rust-builders}",
    "text": "DO define a builder() factory method on the type to be constructed that returns a struct with the same as the type + \"Builder\" e.g., Model::builder() returns a ModelBuilder."
  },
  {
    "id": "rust_introduction.html#rust-builders-self",
    "category": "Builders {#rust-builders}",
    "text": "DO consume mut self in with_ setter methods and return Self except in the final build(&self) method."
  },
  {
    "id": "rust_introduction.html#rust-builders-return",
    "category": "Builders {#rust-builders}",
    "text": "DO return an owned value from the final build(&self) method."
  },
  {
    "id": "rust_introduction.html#rust-builders-return-params",
    "category": "Builders {#rust-builders}",
    "text": "DO define required parameters in the final build(&self) method if not using a typestate pattern e.g., build(&self, endpoint: &str)."
  },
  {
    "id": "rust_introduction.html#rust-enums-names",
    "category": "Enumerations {#rust-enums}",
    "text": "DO implement all enumeration variations as PascalCase."
  },
  {
    "id": "rust_introduction.html#rust-enums-derive",
    "category": "Enumerations {#rust-enums}",
    "text": "DO derive or implement Clone, Eq, and PartialEq for all enums."
  },
  {
    "id": "rust_introduction.html#rust-enums-debug",
    "category": "Enumerations {#rust-enums}",
    "text": "YOU SHOULD NOT derive Debug since this may inadvertently leak PII. Derive [azure_core::fmt::SafeDebug][rust-safety-debug] instead."
  },
  {
    "id": "rust_introduction.html#rust-enums-derive-copy",
    "category": "Enumerations {#rust-enums}",
    "text": "DO derive Copy for all fixed enums."
  },
  {
    "id": "rust_introduction.html#rust-enums-serde",
    "category": "Enumerations {#rust-enums}",
    "text": "DO derive or implement serde::Serialize and/or serde::Deserialize as appropriate i.e., if the enum is used in input (serializable), output (deserializable), or both."
  },
  {
    "id": "rust_introduction.html#rust-enums-non-exhaustive",
    "category": "Enumerations {#rust-enums}",
    "text": "DO attribute all enums with #[non_exhaustive].\n\nThis forces all downstream crates, for example, to use the _ match arm to match any remaining enums that may be added in the future for pattern binding:\n\n```rust\n// enum Example {\n//     Foo,\n//     Bar,\n// }\n\nlet value = match model.kind {\n    Example:Foo =&gt; todo!(),\n    Example::Bar =&gt; todo!(),\n    _ =&gt; todo!(),\n};\n\n```\n\nThis is necessary for both fixed enums and extensible enums since new variants may be added and matched during deserialization.\n\nSee [RFC 2008][rust-lang-rfc-2008] for more information."
  },
  {
    "id": "rust_introduction.html#rust-enum-fixed",
    "category": "Enumerations {#rust-enums}",
    "text": "DO implement all fixed enumerations using only defined variants:\n\n```rust\nuse azure_core::SafeDebug;\n\n#[derive(Clone, Copy, SafeDebug, Eq, PartialEq, Deserialize, Serialize)]\n#[non_exhaustive]\npub enum FixedEnum {\n    #[serde(rename = \"foo\")]\n    Foo,\n    #[serde(rename = \"bar\")]\n    Bar,\n}\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-enum-extensible",
    "category": "Enumerations {#rust-enums}",
    "text": "DO implement all extensible enumerations - those which may take a variant that is not defined - using defined variants and an untagged UnknownValue:\n\n```rust\nuse azure_core::SafeDebug;\n\n#[derive(Clone, SafeDebug, Eq, PartialEq, Deserialize, Serialize)]\n#[non_exhaustive]\npub enum ExtensibleEnum {\n    #[serde(rename = \"foo\")]\n    Foo,\n    #[serde(rename = \"bar\")]\n    Bar,\n    #[serde(untagged)]\n    UnknownValue(String),\n}\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-enum-serialize",
    "category": "Enumerations {#rust-enums}",
    "text": "YOU MAY implement serde::Deserialize, serde::Serialize, or both as appropriate depending on whether the enumeration is found only in responses, requests, or both, respectively."
  },
  {
    "id": "rust_introduction.html#rust-enum-generated-attributes",
    "category": "Enumerations {#rust-enums}",
    "text": "YOU SHOULD define variant attribute #[serde(rename = \"name\")] for generated code for each variant."
  },
  {
    "id": "rust_introduction.html#rust-enum-convenience-attributes",
    "category": "Enumerations {#rust-enums}",
    "text": "YOU MAY use container attribute #[serde(rename_all = \"camelCase\")] for convenience layers, or whatever casing is appropriate.\n\nThe azure_core package provides common functionality for client libraries. Documentation and usage examples can be found in the Azure/azure-sdk-for-rust (https://github.com/Azure/azure-sdk-for-rust/tree/main/sdk/core) repository."
  },
  {
    "id": "rust_introduction.html#rust-errors-core",
    "category": "Errors {#rust-errors}",
    "text": "DO return an azure_core::Result<T> which uses azure_core::Error."
  },
  {
    "id": "rust_introduction.html#rust-errors-core-methods",
    "category": "Errors {#rust-errors}",
    "text": "DO call appropriate methods on azure_core::Error to wrap or otherwise convert to an appropriate azure_core::ErrorKind."
  },
  {
    "id": "rust_introduction.html#rust-errors-into",
    "category": "Errors {#rust-errors}",
    "text": "YOU MAY implement Into<azure_core::Error> for any other error type returned by functions you call if not already defined to support the ? operator.\n\nSince your crate will define neither azure_core::Error or likely the error being returned to you from another dependency, you will need to use the [newtype][rust-lang-newtype] idiom e.g.:\n\n```rust\n#[derive(Debug)]\npub struct Error(dependency::Error);\n\nimpl std::error::Error for Error {\n    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; {\n        self.0.source()\n    }\n}\n\nimpl std::fmt::Display for Error {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {\n        self.0.fmt(f)\n    }\n}\n\nimpl Into&lt;azure_core::Error&gt; for Error {\n    fn into(self) -&gt; azure_core::Error {\n        azure_core::Error::new(azure_core::ErrorKind::Other, Box::new(self))\n    }\n}\n\n```\n\nAzure services use a variety of different authentication schemes to allow clients to access the service. Conceptually, there are two entities responsible in this process: a credential and an authentication policy. Credentials provide confidential authentication data. Authentication policies use the data provided by a credential to authenticate requests to the service."
  },
  {
    "id": "rust_introduction.html#rust-authentication-all-supported-schemes",
    "category": "Authentication {#rust-authentication}",
    "text": "DO support all authentication schemes supported by the service and implemented in azure_core and azure_identity."
  },
  {
    "id": "rust_introduction.html#rust-authentication-azure-core",
    "category": "Authentication {#rust-authentication}",
    "text": "YOU SHOULD use only credentials and authentication policies defined in azure_core.\n\nCrates support different types of [dependencies][rust-lang-dependencies] e.g., [dependencies] for code linked into applications and [dev-dependencies] used for tests, examples, etc."
  },
  {
    "id": "rust_introduction.html#rust-authentication-azure-identity-dependency",
    "category": "Authentication {#rust-authentication}",
    "text": "DO NOT take a dependency on azure_identity."
  },
  {
    "id": "rust_introduction.html#rust-authentication-azure-identity-dev-dependency",
    "category": "Authentication {#rust-authentication}",
    "text": "YOU MAY take a development dependency on azure_identity for tests and examples."
  },
  {
    "id": "rust_introduction.html#rust-authentication-prefer-token-auth",
    "category": "Authentication {#rust-authentication}",
    "text": "DO provide credential types that can be used to fetch all data needed to authenticate a request to the service in a non-blocking atomic manner for each authentication scheme that does not have an implementation in azure_core."
  },
  {
    "id": "rust_introduction.html#rust-authentication-constructors",
    "category": "Authentication {#rust-authentication}",
    "text": "DO provide service client constructors or factories that accept any supported authentication credentials."
  },
  {
    "id": "rust_introduction.html#rust-authentication-connection-strings",
    "category": "Authentication {#rust-authentication}",
    "text": "YOU SHOULD NOT support providing credential data via a connection string. Connection string interfaces should be provided ONLY IF the service provides a connection string to users via the Portal or other tooling. Use a with_connection_string() function to construct a client in that case e.g.:\n\n```rust\nimpl ExampleClient {\n    pub fn with_connection_string(connection_string: &amp;str, options: Option&lt;ExampleClientOptions&gt;) {\n        todo!()\n    }\n}\n\n```\n\nWhen implementing authentication, don't open up the consumer to security holes like PII (personally identifiable information) leakage or credential leakage. Credentials are generally issued with a time limit and must be refreshed periodically to ensure that the service connection continues to function as expected. Ensure your client library follows all current security recommendations and consider an independent security review of the client library to ensure you're not introducing potential security problems for the consumer."
  },
  {
    "id": "rust_introduction.html#rust-authentication-persistence",
    "category": "Authentication {#rust-authentication}",
    "text": "DO NOT persist, cache, or reuse security credentials. Security credentials should be considered short lived to cover both security concerns and credential refresh situations.\n\nIf your service implements a non-standard credential system - one not supported by azure_core - then you need to implement an authentication policy for the HTTP pipeline that can authenticate requests given the alternative credential types provided by the client library."
  },
  {
    "id": "rust_introduction.html#rust-authentication-custom",
    "category": "Authentication {#rust-authentication}",
    "text": "YOU MAY implement an authentication policy and credential in a client library crate if the authentication scheme is supported only by the service."
  },
  {
    "id": "rust_introduction.html#rust-authentication-erase",
    "category": "Authentication {#rust-authentication}",
    "text": "DO securely free and zero authentication tokens and other credential data as soon as they are no longer needed."
  },
  {
    "id": "rust_introduction.html#rust-namespace-naming-typespec",
    "category": "Namespaces {#rust-namespace-naming}",
    "text": "DO use namespaces as defined by TypeSpecs for the service using all lowercase characters and underscores:\n\n```typespec\nnamespace Azure.Security.KeyVault;\n// crate: azure_security_keyvault\nnamespace Azure.Security.KeyVault.Secrets {\n    // module azure_security_keyvault_secrets\n}\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-namespace-naming-internals",
    "category": "Namespaces {#rust-namespace-naming}",
    "text": "YOU SHOULD NOT export modules used only within the crate. You may use pub(crate) when declaring these modules to export public types within that module to other types and functions within the crate:\n\n```rust\n// lib.rs\npub(crate) mod helpers;\n\n// helpers.rs\npub fn helper() {} // not exported publicly\n\n```\n\nPackages in Rust are called \"crates\". Crate names follow the same [general guidance on namespaces][general-design-namespaces] using underscores as a separator e.g., azure_core, azure_security_keyvault, etc."
  },
  {
    "id": "rust_introduction.html#rust-packaging-prefix",
    "category": "Packaging {#rust-packaging}",
    "text": "DO start the crate name with azure_ for data plane crates or azure_resourcemanager_ for control plane (ARM) crates.\n\nTODO: Now that RFC 3243 (https://github.com/rust-lang/rfcs/pull/3243) is merged, having already-reserved azure_mgmt_* crates matters less; however, we should revisit using \"mgmt\" if the RFC hasn't been implemented by the time we need it."
  },
  {
    "id": "rust_introduction.html#rust-packaging-name",
    "category": "Packaging {#rust-packaging}",
    "text": "DO construct the crate name with all lowercase characters and underscores in the form azure_<group>_<service>. Uppercase characters and dashes are not allowed. For example, azure_security_keyvault.\n\nRust does support dashes in crate names, but it may create confusion with customers to reference a crate like azure-core then import a module like azure_core. Many older crates do this, but the trend has been to use underscores in both cases to avoid confusion."
  },
  {
    "id": "rust_introduction.html#rust-packaging-feature-name",
    "category": "Packaging {#rust-packaging}",
    "text": "DO use underscores, when necessary, in feature names e.g., reqwest_rustls to enable the reqwest-based HTTP client with rustls support for TLS.\n\nDashes are supported in feature names as well as crate names, but using underscores in both crate names and feature names provides a consistent experience for developers."
  },
  {
    "id": "rust_introduction.html#rust-packaging-registration",
    "category": "Packaging {#rust-packaging}",
    "text": "DO register the chosen crate name with the [Architecture Board]. Open an issue to request the crate name. See the [registered package list] for a list of the currently registered packages."
  },
  {
    "id": "rust_introduction.html#rust-packaging-project",
    "category": "Packaging {#rust-packaging}",
    "text": "DO define a separate crate for each [TypeSpec project][rust-lang-typespec-config] within a service directory e.g.,\nspecification/keyvault/data-plane/Microsoft.KeyVault/Security.KeyVault.Secrets -> sdk/keyvault/azure_security_keyvault_secrets\nspecification/keyvault/data-plane/Microsoft.KeyVault/Security.KeyVault.Keys -> sdk/keyvault/azure_security_keyvault_keys\nspecification/keyvault/data-plane/Microsoft.KeyVault/Security.KeyVault.Certificates -> sdk/keyvault/azure_security_keyvault_certificates"
  },
  {
    "id": "rust_introduction.html#rust-packaging-common-project",
    "category": "Packaging {#rust-packaging}",
    "text": "YOU MAY define a common crate under the service directory that all service client crates use. Unless there's a name conflict, this should use the \"common\" suffix e.g., azure_security_keyvault_common. The API must be public but you MAY document that those APIs are not intended for public use, similar to some other languages' common libraries."
  },
  {
    "id": "rust_introduction.html#rust-packaging-independent",
    "category": "Packaging {#rust-packaging}",
    "text": "DO NOT package multiple service specifications that version independently within the same crate."
  },
  {
    "id": "rust_introduction.html#directory-structure-root",
    "category": "Directory Structure",
    "text": "DO place all service directories under the sdk/ root directory e.g., sdk/keyvault. The service directory name will often match what is in the Azure/azure-rest-api-specs (https://github.com/Azure/azure-rest-api-specs) repository and will most often be the same across Azure SDK languages."
  },
  {
    "id": "rust_introduction.html#directory-structure-crate",
    "category": "Directory Structure",
    "text": "DO put all crate source under the service directory in a subdirectory using the name of the crate e.g., sdk/keyvault/azure_security_keyvault_secrets/Cargo.toml. This crate directory should correspond to a TypeSpec project and the crate name configured in the TypeSpec project's [tspconfig.yaml][rust-lang-typespec-config]."
  },
  {
    "id": "rust_introduction.html#directory-structure-lib",
    "category": "Directory Structure",
    "text": "YOU SHOULD only export public APIs from the crate lib.rs and define all other types in suitable [modules][rust-lang-modules]:"
  },
  {
    "id": "rust_introduction.html#directory-structure-build-script",
    "category": "Directory Structure",
    "text": "DO NOT include a build.rs build script in the crate root.\nSingle-file modules should be declared in a file next to their parent module.\nMulti-file modules should be declared in a directory next to their parent module with a mod.rs file.\n\nFor example:\n\n```text\nsrc/\n  policies/\n    client_id.rs\n    mod.rs\n    retry.rs\n    transport.rs\n  error.rs\n  lib.rs\nCargo.lock\nCargo.toml\n\n```\n\nYou can find a complete example of our directory structure in our [implementation documentation][rust-directories]."
  },
  {
    "id": "rust_introduction.html#rust-common-macros-review",
    "category": "Common Libraries",
    "text": "DO review new macros with your language architect(s)."
  },
  {
    "id": "rust_introduction.html#rust-common-macros-core",
    "category": "Common Libraries",
    "text": "YOU MAY use common procedural macros from azure_core."
  },
  {
    "id": "rust_introduction.html#rust-versioning-backwards-compatibility",
    "category": "Client Versions",
    "text": "DO be 100% backwards compatible with older versions of the same package."
  },
  {
    "id": "rust_introduction.html#rust-versioning-major-version",
    "category": "Client Versions",
    "text": "DO increase the major semantic version number if an API breaking change is required.\n\nSee https://semver.org (https://semver.org) for more information."
  },
  {
    "id": "rust_introduction.html#rust-versioning-breaking-change-review",
    "category": "Client Versions",
    "text": "DO discuss breaking changes with the language architect before making changes.\n\nNote there are different types of breaking changes:\nThe service introduced breaking changes that the client library must reflect in code. Approval may still be required, but should not burden code owner(s).\nThe client library introduced breaking changes for good reason.\n\nBreaking changes introduced by the client library should happen rarely, if ever. Register your intent to make client breaking changes with the [Architecture Board].\n\nConsistent version number scheme allows consumers to determine what to expect from a new version of the library."
  },
  {
    "id": "rust_introduction.html#rust-package-versions-semver",
    "category": "Package Version Numbers {#rust-package-versions}",
    "text": "DO use MAJOR.MINOR.PATCH format for the version of the crate.\n\nUse _-beta.N suffix for beta package versions. For example, 1.0.0-beta.2.\n\nSee https://semver.org (https://semver.org) for more information."
  },
  {
    "id": "rust_introduction.html#rust-package-versions-change-on-release",
    "category": "Package Version Numbers {#rust-package-versions}",
    "text": "DO change the version number of the client library when ANYTHING changes in the client library."
  },
  {
    "id": "rust_introduction.html#rust-package-versions-patching",
    "category": "Package Version Numbers {#rust-package-versions}",
    "text": "DO increment the patch version when fixing a bug."
  },
  {
    "id": "rust_introduction.html#rust-package-versions-features-in-patch",
    "category": "Package Version Numbers {#rust-package-versions}",
    "text": "DO NOT include new APIs in a patch release."
  },
  {
    "id": "rust_introduction.html#rust-package-versions-add-feature",
    "category": "Package Version Numbers {#rust-package-versions}",
    "text": "DO increment the major or minor version when adding support for a service API version."
  },
  {
    "id": "rust_introduction.html#rust-package-versions-add-api",
    "category": "Package Version Numbers {#rust-package-versions}",
    "text": "DO increment the major or minor version when adding a new method to the public API."
  },
  {
    "id": "rust_introduction.html#rust-package-versions-major-changes",
    "category": "Package Version Numbers {#rust-package-versions}",
    "text": "YOU SHOULD increment the major version when making large feature changes.\n\nDependencies bring in many considerations that are often easily avoided by avoiding the dependency.\nVersioning - Though Rust allows a consumer to build multiple versions of the same crate, directly depending on different versions of the same crate, or importing types or calling functions from different versions of the same crate may be unintuitive.\nSize - Consumer applications must be able to deploy as fast as possible into the cloud and move in various ways across networks. Removing additional code (like dependencies) improves deployment performance.\nLicensing - You must be conscious of the licensing restrictions of a dependency and often provide proper attribution and notices when using them.\nCompatibility - Often times you do not control a dependency and it may choose to evolve in a direction that is incompatible with your original use.\nSecurity - If a security vulnerability is discovered in a dependency, it may be difficult or time consuming to get the vulnerability corrected if Microsoft does not control the dependencies code base."
  },
  {
    "id": "rust_introduction.html#rust-dependencies-centralized",
    "category": "Dependencies {#rust-dependencies}",
    "text": "DO declare all dependencies in the repository root Cargo.toml workspace in the [dependencies] section regardless of which type of dependency crates will inherit, e.g.:\n\n```toml\n[workspace.dependencies]\nazure_core = { version = \"0.1.0\", path = \"sdk/core\" }\nfutures = \"0.3.30\"\ntokio = { version = \"1.36.0\", features = [\"macros\", \"rt-multi-thread\"] }\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-dependencies-inherit",
    "category": "Dependencies {#rust-dependencies}",
    "text": "DO inherit all dependencies from the workspace in individual creates' Cargo.toml files e.g.:\n\n```toml\n[dependencies]\nazure_core = { workspace = true }\nfutures = { workspace = true }\n\n[dev-dependencies]\ntokio = { workspace = true }\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-dependencies-features",
    "category": "Dependencies {#rust-dependencies}",
    "text": "YOU MAY override the features required for a crate."
  },
  {
    "id": "rust_introduction.html#rust-linting-centralized",
    "category": "Code Lints {#rust-linting}",
    "text": "DO centralized general linting rules, whether allowed or denied, into the root workspace Cargo.toml e.g.:\n\n```toml\n[workspace.lints.rust]\ndead_code = \"allow\"\n\n[workspace.lints.clippy]\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-linting-inherit",
    "category": "Code Lints {#rust-linting}",
    "text": "DO inherit linting rules from the workspace in each member crate e.g., :\n\n```toml\n[lints]\nworkspace = true\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-linting-source",
    "category": "Code Lints {#rust-linting}",
    "text": "YOU MAY define source-specific lint rules in .rs source files if they can't be mitigated."
  },
  {
    "id": "rust_introduction.html#rust-linting-crate",
    "category": "Code Lints {#rust-linting}",
    "text": "DO NOT define crate-specific lint rules in Cargo.toml files since these will apply to all source and should not be so pervasive.\n\nDocumentation comments in Rust not only support markdown, but can contain examples that are optionally runnable as tests when executing cargo test. Read [the rustdoc book][rust-lang-rustdoc] for more information,\nespecially about [tests in doc comments][rust-lang-rustdoc-tests]."
  },
  {
    "id": "rust_introduction.html#rust-documentation-api",
    "category": "Documentation Comments {#rust-documentation}",
    "text": "DO document all public APIs prior to General Availability (GA). This includes functions, structs, methods, fields, and traits, e.g.:\n\n```rust\n/// A secret stored in Key Vault.\npub struct Secret {\n    /// The name of the secret.\n    pub name: String,\n\n    // ...\n}\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-documentation-readme",
    "category": "Documentation Comments {#rust-documentation}",
    "text": "DO include the crate README.md in the root lib.rs to provide an overview of the crate in rendered documentation e.g.:\n\n```rust\n// near the top of lib.rs:\n#![doc = include_str!(\"../README.md\")]\n\n```\n\nThis will impact line numbers, so you should only export APIs publicly from lib.rs."
  },
  {
    "id": "rust_introduction.html#rust-documentation-module-readme",
    "category": "Documentation Comments {#rust-documentation}",
    "text": "YOU MAY include a separate README.md for a module as module documentation e.g., for module http defined in http/mod.rs:\n\n```rust\n#![doc = include_str!(\"README.md\")]`\n\n```\n\nThis would include the contents of http/README.md, which would render documentation for developers browing in the GitHub web UI, as well as compile and potentially run any tests you have defined as examples in the README.md e.g.,\n\n```markdown\nThis is how you would construct a client:\n\n```rust no_run\nlet client = SecretClient::new(...);\n```\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-documentation-parameters",
    "category": "Documentation Comments {#rust-documentation}",
    "text": "DO document all parameters. Prior to [conventional doc comment markdown headers][rust-lang-rustdoc-headings], declare an Arguments heading as needed (not needed for &self):\n\n```rust\n/// Sets a secret and returns more information about the secret from the service.\n///\n/// # Arguments\n///\n/// * `name` - The name of the secret.\n/// * `options` - Optional properties of the secret.\nasync fn set_secret(\n    &amp;self,\n    name: &amp;str,\n    options: Option&lt;SetSecretMethodOptions&gt;,\n) -&gt; Result&lt;Response&gt;;\n\n```\n\nSee [Rust by Example: Documentation][rust-lang-doc-meta] for more information."
  },
  {
    "id": "rust_introduction.html#rust-documentation-tests",
    "category": "Documentation Comments {#rust-documentation}",
    "text": "YOU SHOULD use testable examples in documentation which improve test coverage and show callers runnable examples."
  },
  {
    "id": "rust_introduction.html#rust-documentation-expect",
    "category": "Documentation Comments {#rust-documentation}",
    "text": "YOU MAY use expect(&str) to unwrap a value or panic with an explanation useful to consumers only in doc comments."
  },
  {
    "id": "rust_introduction.html#rust-repository-repository",
    "category": "Repository Guidelines {#rust-repository}",
    "text": "DO locate all source code and READMEs in the [Azure/azure-sdk-for-rust] GitHub repository."
  },
  {
    "id": "rust_introduction.html#rust-repository-engsys",
    "category": "Repository Guidelines {#rust-repository}",
    "text": "DO follow Azure SDK engineering systems guidelines for working in the [Azure/azure-sdk-for-rust] GitHub repository."
  },
  {
    "id": "rust_introduction.html#rust-repository-cargo-lock",
    "category": "Repository Guidelines {#rust-repository}",
    "text": "DO commit Cargo.lock to the repository.\n\nThere are several documentation deliverables that must be included in or as a companion to your client library. Beyond complete and helpful API documentation within the code itself (doc comments), you need a great README and other supporting documentation.\nREADME.md - Resides in the root of your library's directory within the SDK repository; includes package installation and client library usage information.\nAPI reference - Generated from the doc comments in your code; published on https://learn.microsoft.com (https://learn.microsoft.com) and https://docs.rs (https://docs.rs) \nCode snippets - Short code examples that demonstrate single (atomic) operations for the champion scenarios you've identified for your library; included in your README, doc comments, and Quickstart.\nQuickstart - Article on https://learn.microsoft.com (https://learn.microsoft.com) that is similar to but expands on the README content; typically written by your service's content developer.\nConceptual - Long-form documentation like Quickstarts, Tutorials, How-to guides, and other content on docs.microsoft.com; typically written by your service's content developer."
  },
  {
    "id": "rust_introduction.html#rust-repo-docs-contentdev",
    "category": "Documentation Style {#rust-repo-docs}",
    "text": "DO include your service's content developer in the [Architecture Board] review for your library. To find the content developer you should work with, check with your team's Program Manager."
  },
  {
    "id": "rust_introduction.html#rust-repo-docs-contributors-guide",
    "category": "Documentation Style {#rust-repo-docs}",
    "text": "DO follow the [Azure SDK Contributors Guide]. (MICROSOFT INTERNAL)"
  },
  {
    "id": "rust_introduction.html#rust-repo-docs-style-guide",
    "category": "Documentation Style {#rust-repo-docs}",
    "text": "DO adhere to the specifications set forth in the Microsoft style guides when you write public-facing documentation. This applies to both long-form documentation like a README and the doc comments in your code. (MICROSOFT INTERNAL)\n[Microsoft Writing Style Guide]\n[Microsoft Cloud Style Guide]"
  },
  {
    "id": "rust_introduction.html#rust-repo-docs-to-silence",
    "category": "Documentation Style {#rust-repo-docs}",
    "text": "YOU SHOULD attempt to document your library into silence. Preempt developers' usage questions and minimize GitHub issues by clearly explaining your API in the doc comments. Include information on service limits and errors they might hit, and how to avoid and recover from those errors.\n\nAs you write your code, document it so you never hear about it again. The less questions you have to answer about your client library, the more time you have to build new features for your service."
  },
  {
    "id": "rust_introduction.html#rust-doc-samples-runnable",
    "category": "Code Snippets {#rust-doc-samples}",
    "text": "YOU SHOULD include [runnable examples in documentation][rust-lang-rustdoc-tests] for client methods or convenience layers that may require additional explanation specific to those members."
  },
  {
    "id": "rust_introduction.html#rust-doc-samples-no-run",
    "category": "Code Snippets {#rust-doc-samples}",
    "text": "DO add no_run to the code fence for documentation examples if that code requirements external resources."
  },
  {
    "id": "rust_introduction.html#rust-doc-samples-unwrap",
    "category": "Code Snippets {#rust-doc-samples}",
    "text": "YOU SHOULD use unwrap() or expect(&str) in examples and not the [question mark operator ?][rust-lang-question-mark-operator], which requires additional setup."
  },
  {
    "id": "rust_introduction.html#rust-doc-samples-main",
    "category": "Code Snippets {#rust-doc-samples}",
    "text": "YOU SHOULD NOT include the main function in the signature, if even necessary e.g., for showing async examples.\n\n```rust\n/// ``` no_run\n/// # async fn main() {\n///     let client = SecretClient::new(\"https://myvault.vault.azure.net\", Arc::new(DefaultAzureCredential::default()), None).unwrap();\n///     let secret = client.set_secret(\"name\", \"value\", None, None).await.unwrap();\n///     println!(\"{secret:?}\");\n/// # }\n/// ```\n\n```"
  },
  {
    "id": "rust_introduction.html#rust-doc-samples-no-run",
    "category": "Code Snippets {#rust-doc-samples}",
    "text": "DO attribute code fences with no_run if the code cannot or should not run when running cargo test. There are additional [documentation test attributes][rust-lang-rustdoc-tests-attributes] that may be of interest."
  },
  {
    "id": "rust_introduction.html#rust-engsys-stable",
    "category": "Build System Integration {#rust-engsys}",
    "text": "DO test all crates impacted by a Pull Request (PR) using the minimum supported Rust version (MSRV) from the stable channel i.e., azure_core's rust-version in its Cargo.toml."
  },
  {
    "id": "rust_introduction.html#rust-engsys-nightly",
    "category": "Build System Integration {#rust-engsys}",
    "text": "DO test all crates impacted by a PR using the latest nightly toolchain."
  },
  {
    "id": "rust_introduction.html#rust-engsys-async",
    "category": "Build System Integration {#rust-engsys}",
    "text": "DO test azure_core and any other crates that implement async functions separate from azure_core::Pipeline using tokio (https://tokio.rs) and monoio (https://github.com/bytedance/monoio) in both single- and multi-threaded configurations. These tests do not necessarily have to run for every PR e.g., they may run nightly or weekly."
  },
  {
    "id": "rust_introduction.html#rust-engsys-partner-policies",
    "category": "Build System Integration {#rust-engsys}",
    "text": "YOU SHOULD test some partner Pipeline policies in nightly or weekly runs."
  },
  {
    "id": "rust_introduction.html#rust-repo-formatting-rustfmt",
    "category": "Formatting {#rust-repo-formatting}",
    "text": "DO format all source using rustfmt. .vscode/settings.json will do this automatically for Visual Studio Code."
  },
  {
    "id": "rust_introduction.html#rust-repo-formatting-engsys",
    "category": "Formatting {#rust-repo-formatting}",
    "text": "DO check that all source is formatted in build pipelines.\n\nThis prevents noisy subsequent pull requests if another maintainer formats source, which is always recommended. All source should be formatted the same based on rustfmt defaults and any repo overrides that may be set."
  },
  {
    "id": "rust_introduction.html#rust-repository-readme-file",
    "category": "README {#rust-repository-readme}",
    "text": "DO have a README.md file in the component root folder.\n\nAn example of a good README.md file can be found here (https://github.com/Azure/azure-sdk-for-rust/blob/main/sdk/core/azure_core/README.md) "
  },
  {
    "id": "rust_introduction.html#rust-repository-readme-consumer",
    "category": "README {#rust-repository-readme}",
    "text": "DO optimize the README.md for the consumer of the client library.\n\nThe contributor guide (CONTRIBUTING.md) should be a separate file."
  },
  {
    "id": "rust_introduction.html#rust-repo-samples-examples",
    "category": "Samples {#rust-repo-samples}",
    "text": "DO include runnable examples using azure_identity::DefaultAzureCredential and library-specific environment variables e.g., AZURE_KEYVAULT_URL in crates' examples/ directory."
  },
  {
    "id": "rust_introduction.html#rust-repo-samples-unique",
    "category": "Samples {#rust-repo-samples}",
    "text": "DO use unique example file names throughout the workspace.\n\nThe example file names are compiled into executes with the same name as the source file; thus, they must have unique names throughout the workspace.\nTo facilitate this, preface your example name with the client name - converting PascalCase type name to snake_case - or, if still ambiguous, the service directory or crate name e.g., secret_client_set_secret.rs or keyvault_secret_client_set_secret.rs.\n\nSee Cargo's [project layout][rust-lang-project-layout] for more information about conventional directories."
  },
  {
    "id": "rust_introduction.html#rust-repo-samples-question-operator",
    "category": "Samples {#rust-repo-samples}",
    "text": "YOU SHOULD use the ? operator to handle errors or optional values as much as possible.\nThis does mean that your sample method - including main - should return a Result<T, E>. This can be specific like azure_core::Result<T> if suitable,\nor generic like std::result::Result<(), Box<dyn std::error::Error>> (std::result::Result is imported by default) e.g.,\n\n```markdown\n```rust\nuse azure_identity::DefaultAzureCredential;\nuse azure_security_keyvault_secrets::SecretClient;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let credential = DefaultAzureCredential::new()?;\n    let client = SecretClient::new(\"https://my-vault.vault.azure.net\", credential.clone(), None)?;\n    // ...\n\n    Ok(())\n}\n```\n\n```\n\n<!-- General Rust Language links should start with \"rust-lang-\" -->\n<!-- Links within site -->\n<p>[general-design-namespaces]: {{ site.baseurl }}{% link docs/general/design.md %}#namespaces\n[general-recorded-tests]: {{ site.baseurl }}{% link docs/general/implementation.md %}#recorded-tests\n[registered package list]: {{ site.baseurl }}{% link docs/tables/registered_namespaces.md %}\n[rust-client-convenience]: {{ site.baseurl }}{% link docs/rust/implementation.md %}#rust-client-convenience\n[rust-directories]: {{ site.baseurl }}{% link docs/rust/implementation.md %}#rust-directories\n[rust-safety-debug]: {{ site.baseurl }}{% link docs/rust/implementation.md %}#rust-safety-debug\n[rust-modules]: {{ site.baseurl }}{% link docs/rust/implementation.md %}#rust-modules</p>\n"
  }
]