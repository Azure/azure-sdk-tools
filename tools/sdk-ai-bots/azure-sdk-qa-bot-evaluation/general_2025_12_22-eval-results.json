{"rows": [{"inputs.query": "title: SDK Validation - .NET\n\nquestion: I have an open PR inital genome api spec by samira-farhin · Pull Request #25097 · Azure/azure-rest-api-specs-pr that's currently failing on SDK Validation - .NET - PR. My latest changes to resolve SDK Validation in \"tspconfig.yaml\" are included below. After these updates, the SDK validation issues for Go and Java were resolved, but the C# issue still remains. I'm unsure what else needs to be addressed.\ninital genome api spec by samira-farhin · Pull Request #25097 · Azure/azure-rest-api-specs-pr\ninital genome api spec by samira-farhin · Pull Request #25097 · Azure/azure-rest-api-specs-pr\n```\ncommand  pwsh ./eng/scripts/Automation-Sdk-Init.ps1 ../azure-sdk-for-net-pr_tmp/initInput.json ../azure-sdk-for-net-pr_tmp/initOutput.json\ncommand  pwsh ./eng/scripts/Invoke-GenerateAndBuildV2.ps1 ../azure-sdk-for-net-pr_tmp/generateInput.json ../azure-sdk-for-net-pr_tmp/generateOutput.json\ncmdout  [.Net] Start to call tsp-client to generate package:Azure.ResourceManager.Genome\ncmdout  [.Net] Start to build sdk project: /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net]     8 Error(s)\ncmdout  [.Net] [ERROR] Failed to build the sdk project: Azure.ResourceManager.Genome for service: genome. Exit code: False. Please review the detail errors for potential fixes. If the issue persists, contact the DotNet language support channel at https://aka.ms/azsdk/dotnet-teams-channel and include this spec pull request.\n```", "inputs.ground_truth": "This has been fixed in azure-sdk-for-net, and will be synced to azure-sdk-for-net-pr during the day. Your spec is in private repo, after the sync rerun should resolve this. And meanwhile, .NET SDK validation is optional for your spec PR merge, you can ignore it for now.", "inputs.response": "Based on the error message, the CS0122 error ('GeneratorPageableHelpers' is inaccessible due to its protection level) in your C# SDK build is almost always due to incorrect or missing configuration for paging in your TypeSpec models and operations. The .NET SDK generator expects paging to be defined using the Azure.Core.Page<T> template and the appropriate decorators for the 'value' and 'nextLink' properties in the response model.\n\nHere’s what you need to do:\n\n1. **Update your response model for pageable operations**:\n   - Ensure that any model returned by a pageable operation is either based on `Azure.Core.Page<T>` or follows the pattern with explicit `@TypeSpec.pageItems` and `@TypeSpec.nextLink` decorators.\n   - Example:\n   ```tsp\n   model GenomeAccountList {\n     @TypeSpec.pageItems\n     value: GenomeAccount[];\n\n     @TypeSpec.nextLink\n     nextLink?: string;\n   }\n   ```\n   Or, if you use the template:\n   ```tsp\n   model GenomeAccountList is Azure.Core.Page<GenomeAccount>;\n   ```\n\n2. **Decorate the corresponding operation as pageable**:\n   - Use `@TypeSpec.list` on the operation if it is a list/get all operation.\n   ```tsp\n   @TypeSpec.list\n   listGenomeAccounts is ArmResourceActionSync<\n     GenomeResource,\n     void,\n     ArmResponse<GenomeAccountList>,\n     Parameters\n   >;\n   ```\n\n3. **Double-check your tspconfig.yaml**:\n   - Ensure you are using the latest versions of all TypeSpec and Azure SDK emitters.\n   - The C# emitter should have `flavor: azure` and the correct `package-dir` and `namespace` settings, following the ARM template examples.\n   - Example:\n   ```yaml\n   options:\n     \"@azure-tools/typespec-csharp\":\n       flavor: azure\n       package-dir: \"Azure.ResourceManager.Genome\"\n       clear-output-folder: true\n       model-namespace: true\n       namespace: \"Azure.ResourceManager.Genome\"\n   ```\n\n4. **Regenerate the SDK after updating your TypeSpec models and config**:\n   - Run `npm ci` or `tsp install` to ensure all dependencies are up to date, then recompile and rerun the SDK generation pipeline.\n\nIf you still see the CS0122 error after these fixes, double-check that none of your pageable response models are missing the decorators or are shared with non-pageable operations (see references below for this migration pitfall).\n\n**Summary:** The .NET generator relies on proper paging schema in TypeSpec. Update your models and operations to use the Azure paging templates and decorators. This should resolve the CS0122 errors in the generated C# code.", "inputs.context": "[{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#generate-client-libraries#00howtogen.mdx\",\"document_title\":\"How to generate client libraries\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/00howtogen\",\"content\":\"# howtos#generate-client-libraries#00howtogen.mdx\\n\\n# How to generate client libraries\\n\\nimport { ClientTabs, ClientTabItem } from \\\"@components/client-tabs\\\";\\r\\n\\r\\nThis page outlines the steps to build a client library based on your TypeSpec specification. It provides a guide for the whole process from initial API design to the release of SDKs. please visit https://aka.ms/azsdk/dpcodegen.\\r\\n\\r\\nThe best documentation on how to generate can be found using those links:\\r\\n\\r\\n- https://aka.ms/azsdk/dpcodegen/net\\r\\n- https://aka.ms/azsdk/dpcodegen/python\\r\\n- https://aka.ms/azsdk/dpcodegen/java\\r\\n- https://aka.ms/azsdk/rlc/js\\r\\n- https://aka.ms/azsdk/dpcodegen/js (do not use unless told to do so by the archboard)\\r\\n- https://aka.ms/azsdk/dpcodegen/go\\r\\n\\r\\nAt a glance, add your emitter name to your `package.json`, along with the right options in the `tspconfig.yaml`.\\r\\n\\r\\n\\u003e **NOTE:** Generating all languages from the same folder may be complicated due to the preview status of the emitters and TypeSpec libraries, such as `typespec-azure-core` and `typespec-azure-resource-manager`.\\r\\n\\u003e It is recommended to have a unique language emitter in each `package.json` to avoid conflicts until all emitters and the TypeSpec libraries reach their first stable release.\\r\\n\\r\\nModify your `package.json` to include the necessary dependencies for the language emitter(s). Remember to run `npm install` after making changes to the file:\\r\\n\\r\\n```json\\r\\n{\\r\\n  \\\"name\\\": \\\"clients\\\",\\r\\n  \\\"dependencies\\\": {\\r\\n    \\\"@typespec/compiler\\\": \\\"latest\\\",\\r\\n    \\\"@typespec/rest\\\": \\\"latest\\\",\\r\\n    \\\"@typespec/http\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-azure-core\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-autorest\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-python\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-java\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-csharp\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-ts\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-go\\\": \\\"latest\\\"\\r\\n  },\\r\\n  \\\"private\\\": true\\r\\n}\\r\\n```\\r\\n\\r\\nAlways update your `tspconfig.yaml` file rather than passing options through the command line.\\r\\n\\r\\n```yaml\\r\\nemit:\\n\\n\\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-azure-core\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-autorest\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-python\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-java\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-csharp\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-ts\\\": \\\"latest\\\",\\r\\n    \\\"@azure-tools/typespec-go\\\": \\\"latest\\\"\\r\\n  },\\r\\n  \\\"private\\\": true\\r\\n}\\r\\n```\\r\\n\\r\\nAlways update your `tspconfig.yaml` file rather than passing options through the command line.\\r\\n\\r\\n```yaml\\r\\nemit:\\r\\n  # Emitter for Swagger files with Autorest Extensions\\r\\n  - \\\"@azure-tools/typespec-autorest\\\"\\r\\n  # add \\\"@azure-tools/typespec-python\\\" to your package.json to generate Python code\\r\\n  - \\\"@azure-tools/typespec-python\\\"\\r\\n  # add \\\"@azure-tools/typespec-java\\\" to your package.json to generate Java code\\r\\n  - \\\"@azure-tools/typespec-java\\\"\\r\\n  # add \\\"@azure-tools/typespec-csharp\\\" to your package.json to generate C# code\\r\\n  - \\\"@azure-tools/typespec-csharp\\\"\\r\\n  # add \\\"@azure-tools/typespec-ts\\\" to your package.json to generate Typescript code\\r\\n  - \\\"@azure-tools/typespec-ts\\\"\\r\\n  # add \\\"@azure-tools/typespec-go\\\" to your package.json to generate Go code\\r\\n  - \\\"@azure-tools/typespec-go\\\"\\r\\noptions:\\r\\n  \\\"@azure-tools/typespec-python\\\":\\r\\n    flavor: azure\\r\\n  \\\"@azure-tools/typespec-java\\\":\\r\\n    flavor: azure\\r\\n  \\\"@azure-tools/typespec-csharp\\\":\\r\\n    flavor: azure\\r\\n  \\\"@azure-tools/typespec-ts\\\":\\r\\n    flavor: azure\\r\\n  \\\"@azure-tools/typespec-go\\\":\\r\\n    flavor: azure\\r\\n```\\r\\n\\r\\nSeveral language repositories utilize the `tsp-client` tool to simplify generating client libraries. For more information on the tool, see [Getting started with `tsp-client`](\\u003c./../Generating with tsp-client/tsp_client.md\\u003e).\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#createproject.md\",\"document_title\":\"Creating a project\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/createproject\",\"content\":\"# getstarted#createproject.md\\n\\n# Creating a project\\n\\nIf you've installed TypeSpec on your local machine, you can create a new TypeSpec project by following these steps:\\r\\n1. **Open your command prompt** (PowerShell, cmd.exe, bash, etc.), create an empty folder for your new project, and `cd` into it.\\r\\n2. If creating a new service in the [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) repository, create the new service folder following our [directory structure guidelines](https://aka.ms/azsdk/spec-dirs).\\r\\n3. To create a new Azure service specification, use the `tsp init` command:\\r\\n```bash\\r\\ntsp init https://aka.ms/typespec/azure-init\\r\\n```\\r\\nYou will be prompted with a few questions regarding the service template, project name, and library updates.\\n\\n### Understanding Project Templates\\n\\nWhen initializing a new project, you'll encounter four templates:\\r\\n| Template Name                                                   | Description                                                                                                                                                                          |\\r\\n| --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\\r\\n| **(rest-api-spec repo) Azure Data Plane Service Project**       | This template is configured for projects within the `azure-rest-api-specs` repository, with settings that comply with the repo's requirements, such as file paths and linting rules. |\\r\\n| **(rest-api-spec repo) Azure Resource Manager Service Project** | Similar to the above, but tailored for Azure Resource Manager services within the `azure-rest-api-specs` repository.                                                                 |\\r\\n| **(standalone) Azure Data Plane Service Project**               | This template is configured for local use or in a personal repo, allowing for API development without the specific directory structure of the `azure-rest-api-specs` repo.           |\\r\\n| **(standalone) Azure Resource Manager Service Project**         | Similar to the above but designed for Azure Resource Manager services, configured for local use or in a personal repo.                                                               |\\n\\n### Target Users\\n\\n- **Rest-API-Spec Repo Projects**: Ideal for those contributing directly to the Azure REST API specifications, ensuring production-quality SDK generation.\\r\\n- **Standalone Projects**: Suited for API-first development, allowing users to generate OpenAPI specs, service code, and clients without conforming to the specs repo's structure.\\n\\n### Install the dependencies\\n\\nNow that the new project has been created, you can install the dependencies by running the following command:\\r\\n- `npm ci` - If in the `azure-rest-api-specs` repo.\\r\\n- `tsp install` - If a standalone project\\r\\nAfter setting up your project, run `tsp install` to install dependencies. You can then open the file `main.tsp` to continue with the tutorial. Choose the tutorial that matches your chosen project template:\\r\\n| Azure Service Type       | Tutorial                                      | Produces                   |\\r\\n| ------------------------ | --------------------------------------------- | -------------------------- |\\r\\n| Azure Data-Plane Service | [Azure-Core tutorial](azure-core/step01)      | OpenApi 2.0 (Swagger) spec |\\r\\n| Azure Management Service | [ARM tutorial](azure-resource-manager/step00) | OpenApi 2.0 (Swagger) spec |\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"troubleshoot#suppresswarnings.md\",\"document_title\":\"How to suppress warnings\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/troubleshoot/suppresswarnings\",\"content\":\"# troubleshoot#suppresswarnings.md\\n\\n# How to suppress warnings\\n\\nThis article helps you to suppress warning messages generated by TypeSpec and libraries.\\n\\n## Symptoms\\n\\nTypeSpec core and libraries could generate and output warning messages based on linting rules.\\n\\n## Cause\\n\\nThese linting rules are introduced to ensure high-quality specs being generated. Sometimes they are used to call out areas needs developer attention to meet library or organization guidelines.\\n\\n## Workaround\\n\\nSome of the rules after review can be suppressed to get clean compile outputs using `#suppress ErrCode ReasonMsg` statement. The error code is the string reported in compiler output.\\r\\n\\r\\nFor example:\\r\\n\\r\\n```tsp\\r\\n#suppress \\\"@azure-tools/typespec-providerhub/no-identifier-property-in-array-item\\\" \\\"Error items have no unique identifier.\\\"\\r\\n/** An array of details about specific errors that led to this reported error. */\\r\\ndetails: Error[];\\r\\n```\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Deprecating-Preview-APIs.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs\",\"content\":\"# Deprecating-Preview-APIs.md\\n\\nSpec owners are encouraged to remove old preview API versions from the specs repo, once they are retired from the service.\\n\\n## Policies\\n\\n* General\\r\\n  * https://eng.ms/docs/products/azure-developer-experience/retirement/api-retirement\\r\\n    * _Once a service API version is fully retired, the corresponding API spec should be removed from the specs repo_\\r\\n  * https://aka.ms/cpexretirementsprocess\\r\\n* ARM (resource-manager)\\r\\n  * https://armwiki.azurewebsites.net/api_contracts/APIDeprecationPolicy.html\\r\\n    * _Preview APIs have a life-span of not more than 12 months, after which they must be retired._\\n\\n## Process\\n\\n1. Open a PR deleting one (or more) previews.  All of:\\r\\n   1. TypeSpec sources (`*.tsp`)\\r\\n   2. Example sources (examples closest to `*.tsp` files)\\r\\n   3. Generated swaggers and examples (`preview/YYYY-MM-DD-preview/**`)\\r\\n   4. readme.md (remove tags)\\r\\n2. PR should fail check `Swagger BreakingChange`, but pass all other checks.\\r\\n3. Request approval following the normal process for breaking changes\\r\\n   - https://aka.ms/brch\\r\\n   - azbreakchangereview@microsoft.com\\n\\n## Example\\n\\n* [[widget] Remove resource-manager preview #39095](https://github.com/Azure/azure-rest-api-specs/pull/39095)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# design#specs-pr-guides#pr-suppressions.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-suppressions](https://aka.ms/azsdk/pr-suppressions) |\\r\\n|--|--|\\n\\n# Suppress validation failures on a PR\\n\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nOn your Azure REST API specs PR, some of the GitHub check failures (see the `Checks` tab on your PR) can be suppressed.\\r\\nThe suppression can be either just for the PR, or permanent.\\n\\n## To suppress given validation failure\\n\\n1. Determine which failing check you want to suppress: see its name in the `Checks` tab in your PR.\\r\\n1. Determine if you have one of the [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. Determine if you want to suppress the failure only for the PR, or permanently.\\r\\n1. Consult [the suppression cases table](#suppression-cases-table) for instructions corresponding to your case.\\r\\n1. If you want to apply temporary suppression:\\r\\n   1. Mention in a comment on your PR the PR assignee asking to apply the suppression. Provide justification.\\r\\n      See [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. If you applied permanent suppression:\\r\\n   1. It will manifest by the PR getting a label `SuppressionReviewRequired`.\\r\\n   1. Verify the suppression works by the check changing from **failed** to **neutral**.\\r\\n   1. Wait until your suppression is reviewed. If it is approved, the approved will add the `Approved-Suppression` label.\\r\\n   1. Understand the suppression won't be approved if it is not one of the  \\r\\n      [valid suppression reasons](#valid-suppression-reasons) as explained in relevant section.\\n\\n## Suppression cases table\\n\\n|\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met | Not possible                              |                                                      | Not possible                                                    |\\r\\n\\r\\n[1] Applies only if the SDK generation check failed with a breaking change. For details of SDK breaking change suppression, see https://aka.ms/azsdk/sdk-suppression.\\r\\nGeneral SDK generation check failure suppressions are not supported. See [#6509].\\n\\n|\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger SemanticValidation         | See [aka.ms/ci-fix]                       | `Approved-SemanticValidation`                        | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger ModelValidation            | See [aka.ms/ci-fix]                       | `Approved-ModelValidation`                           | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger Breaking Change            | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Breaking Change(Cross-Version)     | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              |\\n\\nTable legend:\\r\\n\\r\\n- `Check name`: Check to suppress.\\r\\n- `PR suppression`: instructions to obtain suppression for given check for given PR only.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n- `Label`: the label your PR will get if your suppression is approved.\\r\\n- `Permanent suppression`: instructions how to get permanent suppression.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n\\r\\n| Check name                         | PR suppression                            | Label                                                | Permanent suppression                                           |\\r\\n|------------------------------------|-------------------------------------------|------------------------------------------------------|-----------------------------------------------------------------|\\r\\n| TypeSpec Requirement               | Not possible                              |                                                      | [suppressions.yaml](#suppressionsyaml)                      |\\r\\n| TypeSpec Validation                | Not possible                              |                                                      | Not possible                                                    |\\r\\n| license/cla                        | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 |\\n\\n|\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-net-track2       | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-go               | See [step 3 in the diagram] but note [1]. | `BreakingChange-Go-Sdk-Suppression-Approved`         | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-java             | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-js               | See [step 3 in the diagram] but note [1]. | `BreakingChange-JavaScript-Sdk-Suppression-Approved` | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met |\\n\\n## suppressions.yaml\\n\\nFile `suppressions.yaml` is used for all checks created in 2024 or later, like\\r\\n`TypeSpec Requirement` and `TypeSpec Validation`.\\r\\n\\r\\nFor simplicity, we recommend adding all suppressions to a single file at the root of your spec folder:\\r\\n\\r\\n```\\r\\nspecification/myservice/suppressions.yaml\\r\\n```\\r\\n\\r\\nAlternatively, you can use multiple files in separate folders.  Currently, tools will use the first\\r\\ninstance of `suppressions.yaml` found walking up the directory tree.  We are planning\\r\\nfuture support for \\\"merging\\\" files up the hierarchy.\\r\\n\\r\\nA suppression follows this general format:\\r\\n\\r\\n```\\r\\n- tool: ToolName\\r\\n  path: applies/to/**/*.json\\r\\n  reason: Why this can't be fixed\\r\\n```\\r\\n\\r\\n`path` uses \\\"glob\\\" matching.  For syntax, see https://www.npmjs.com/package/minimatch.\\r\\n\\r\\nScope your `path` as narrowly as possible.  For example, if a suppression only applies\\r\\nto a single version of your spec:\\r\\n\\r\\n```\\r\\n# good\\r\\n- path: data-plane/Azure.Contoso.WidgetManager/preview/2022-11-01-preview/**/*.json\\r\\n\\r\\n# bad\\r\\n- path: data-plane/**/*.json\\r\\n```\\r\\n\\r\\nWhen in doubt, search the repo for examples:\\r\\n\\r\\nhttps://github.com/search?q=repo%3AAzure%2Fazure-rest-api-specs+path%3A%2F%28%5E%7C%5C%2F%29suppressions%5C.yaml%24%2F\\u0026type=code\\n\\n### `TypeSpec Requirement` check\\n\\nTo suppress `TypeSpec Requirement` check for given pattern of OpenAPI spec .json file paths, provide an entry with\\r\\n`tool` set to `TypeSpecRequirement`. Provide the pattern as `path` and provide a `reason`.\\r\\n\\r\\nExample:\\r\\n\\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: data-plane/**/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## Suppress AutoRest extension\\n\\nTo suppress tooling that is an AutoRest extension (see [the suppressio\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-09-12.md\",\"document_title\":\"missing readonly property for page response value\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-09-12.md\\n\\n# missing readonly property for page response value\\n\\n## question\\n\\nHow to resolve 'missing readonly property for page response value'?\\n\\n## answer\\n\\nadd readonly visibility for paging model value\\r\\nspecification/databoxedge/DataBoxEdge.Management/models.tsp:\\r\\n```diff\\r\\n  model ServiceSpecification {\\r\\n    /**\\r\\n     * Metric specification as defined by shoebox.\\r\\n     */\\r\\n    @OpenAPI.extension(\\\"x-ms-identifiers\\\", #[\\\"name\\\"])\\r\\n-   metricSpecifications?: MetricSpecificationV1[];\\r\\n+   metricSpecifications?: MetricSpecification_V1[];\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n   * Metric specification version 1.\\r\\n   */\\r\\n- model MetricSpecificationV1 {\\r\\n+ model MetricSpecification_V1 {\\r\\n\\r\\n    @OpenAPI.extension(\\\"x-ms-identifiers\\\", #[\\\"name\\\"])\\r\\n-   dimensions?: MetricDimensionV1[];\\r\\n+   dimensions?: MetricDimension_V1[];\\r\\n```\\r\\n...\\r\\n```diff\\r\\n- model MetricDimensionV1 {\\r\\n+ model MetricDimension_V1 {\\r\\n```\\r\\n...\\r\\n```diff\\r\\n+ \\r\\n+ /**\\r\\n+  * The list of operations supported by Microsoft.DataBoxEdge resource provider.\\r\\n+  */\\r\\n+ model OperationsList {\\r\\n+   /**\\r\\n+    * The list of operations.\\r\\n+    */\\r\\n+   @OpenAPI.extension(\\\"x-ms-identifiers\\\", #[\\\"name\\\"])\\r\\n+   @pageItems\\r\\n+   value: Operation[];\\r\\n+ \\r\\n+   /**\\r\\n+    * The URL to get the next page of operations.\\r\\n+    */\\r\\n+   @nextLink\\r\\n+   nextLink?: url;\\r\\n+ }\\r\\n+ \\r\\n+ @@visibility(Azure.Core.Page.value, Lifecycle.Read);\\r\\n+ @@visibility(OperationsList.value, Lifecycle.Read);\\r\\n```\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-08-07.md\",\"document_title\":\"Same response model is used both in pageable operation and non-pageable operation\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-08-07.md\\n\\n# Same response model is used both in pageable operation and non-pageable operation\\n\\n## question\\n\\nSame response model is used both in pageable operation and non-pageable operation\\n\\n## answer\\n\\n[ref link](https://github.com/Azure/typespec-azure/issues/2932):\\r\\n```\\r\\nissue title: Same response model is used both in pageable operation and non-pageable operation\\r\\n\\r\\ncontent: \\r\\nThis is an example,\\r\\npageable operation[https://github.com/Azure/azure-rest-api-specs/blob/03a6598cdc38924f9eaaeb03f8ef151f5aeff449/specification/guestconfiguration/resource-manager/Microsoft.GuestConfiguration/stable/2024-04-05/guestconfiguration.json#L1046]\\r\\nnon-pageable operation[https://github.com/Azure/azure-rest-api-specs/blob/03a6598cdc38924f9eaaeb03f8ef151f5aeff449/specification/guestconfiguration/resource-manager/Microsoft.GuestConfiguration/stable/2024-04-05/guestconfiguration.json#L358]\\r\\nThey share the same response model GuestConfigurationAssignmentReportList.\\r\\nIn swagger, pageable is marked at operation level, while in TypeSpec pageable is marked at model level. We need to figure out a way for this case.\\r\\n\\r\\nsolution:\\r\\nAs discussed, TypeSpec’s core paging system supports both client-driven and server-driven paging, but it requires explicit specification—there is no default assumption like nextLink. If a response model lacks nextLink, it’s not considered pageable in the traditional sense, and setting x-ms-pageable would be a misinterpretation.\\r\\n\\r\\nThe recommendation is to use the standard ARM paging mechanism. Since nextLink is optional, adding it is not a breaking change. This ensures that if paging is implemented later, it follows the standard. Ultimately, the solution agreed upon is to add nextLink and use the core paging schema in TypeSpec.\\r\\n```\\r\\n\\r\\n```diff\\r\\n#suppress \\\"@azure-tools/typespec-azure-core/documentation-required\\\" \\\"For backward compatibility\\\"\\r\\n- model ListAppIdResponse is Azure.Core.Page\\u003cAppId\\u003e;\\r\\n+ model ListAppIdResponse {\\r\\n+    /*\\r\\n+    * List of AppIds\\r\\n+    */\\r\\n+    @TypeSpec.pageItems\\r\\n+    value: string[];\\r\\n+\\r\\n+    /*\\r\\n+    * next Link\\r\\n+    */\\r\\n+    @TypeSpec.nextLink\\r\\n+    nextLink?: string;\\r\\n+ }\\r\\n```\\r\\n\\r\\n```diff\\n\\nUltimately, the solution agreed upon is to add nextLink and use the core paging schema in TypeSpec.\\r\\n```\\r\\n\\r\\n```diff\\r\\n#suppress \\\"@azure-tools/typespec-azure-core/documentation-required\\\" \\\"For backward compatibility\\\"\\r\\n- model ListAppIdResponse is Azure.Core.Page\\u003cAppId\\u003e;\\r\\n+ model ListAppIdResponse {\\r\\n+    /*\\r\\n+    * List of AppIds\\r\\n+    */\\r\\n+    @TypeSpec.pageItems\\r\\n+    value: string[];\\r\\n+\\r\\n+    /*\\r\\n+    * next Link\\r\\n+    */\\r\\n+    @TypeSpec.nextLink\\r\\n+    nextLink?: string;\\r\\n+ }\\r\\n```\\r\\n\\r\\n```diff\\r\\n  #suppress \\\"@azure-tools/typespec-azure-core/no-openapi\\\" \\\"non-standard operations\\\"\\r\\n  @operationId(\\\"LocalRulestacks_listAppIds\\\")\\r\\n+ @TypeSpec.list\\r\\n  listAppIds is ArmResourceActionSync\\u003c\\r\\n      LocalRulestackResource,\\r\\n      void,\\r\\n      ArmResponse\\u003cListAppIdResponse\\u003e,\\r\\n      Parameters = {\\r\\n          #suppress \\\"@azure-tools/typespec-azure-core/documentation-required\\\" \\\"For backward compatibility\\\"\\r\\n          @query(\\\"appIdVersion\\\")\\r\\n          appIdVersion?: string;\\r\\n\\r\\n          #suppress \\\"@azure-tools/typespec-azure-core/documentation-required\\\" \\\"For backward compatibility\\\"\\r\\n          @query(\\\"appPrefix\\\")\\r\\n          appPrefix?: string;\\r\\n      }\\r\\n  };\\r\\n```\\r\\nif it's pageable, then add decorator @TypeSpec.List to the operation\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-08-07.md\",\"document_title\":\"Same response model is used both in pageable operation and non-pageable operation\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-08-07.md\\n\\n# Same response model is used both in pageable operation and non-pageable operation\\n\\n## question\\n\\nSame response model is used both in pageable operation and non-pageable operation\\n\\n## answer\\n\\n[ref link](https://github.com/Azure/typespec-azure/issues/2932):\\r\\n```\\r\\nissue title: Same response model is used both in pageable operation and non-pageable operation\\r\\n\\r\\ncontent: \\r\\nThis is an example,\\r\\npageable operation[https://github.com/Azure/azure-rest-api-specs/blob/03a6598cdc38924f9eaaeb03f8ef151f5aeff449/specification/guestconfiguration/resource-manager/Microsoft.GuestConfiguration/stable/2024-04-05/guestconfiguration.json#L1046]\\r\\nnon-pageable operation[https://github.com/Azure/azure-rest-api-specs/blob/03a6598cdc38924f9eaaeb03f8ef151f5aeff449/specification/guestconfiguration/resource-manager/Microsoft.GuestConfiguration/stable/2024-04-05/guestconfiguration.json#L358]\\r\\nThey share the same response model GuestConfigurationAssignmentReportList.\\r\\nIn swagger, pageable is marked at operation level, while in TypeSpec pageable is marked at model level. We need to figure out a way for this case.\\r\\n\\r\\nsolution:\\r\\nAs discussed, TypeSpec’s core paging system supports both client-driven and server-driven paging, but it requires explicit specification—there is no default assumption like nextLink. If a response model lacks nextLink, it’s not considered pageable in the traditional sense, and setting x-ms-pageable would be a misinterpretation.\\r\\n\\r\\nThe recommendation is to use the standard ARM paging mechanism. Since nextLink is optional, adding it is not a breaking change. This ensures that if paging is implemented later, it follows the standard. Ultimately, the solution agreed upon is to add nextLink and use the core paging schema in TypeSpec.\\r\\n```\\r\\n\\r\\n```diff\\r\\n#suppress \\\"@azure-tools/typespec-azure-core/documentation-required\\\" \\\"For backward compatibility\\\"\\r\\n- model ListAppIdResponse is Azure.Core.Page\\u003cAppId\\u003e;\\r\\n+ model ListAppIdResponse {\\r\\n+    /*\\r\\n+    * List of AppIds\\r\\n+    */\\r\\n+    @TypeSpec.pageItems\\r\\n+    value: string[];\\r\\n+\\r\\n+    /*\\r\\n+    * next Link\\r\\n+    */\\r\\n+    @TypeSpec.nextLink\\r\\n+    nextLink?: string;\\r\\n+ }\\r\\n```\\r\\n\\r\\n```diff\\n\\nUltimately, the solution agreed upon is to add nextLink and use the core paging schema in TypeSpec.\\r\\n```\\r\\n\\r\\n```diff\\r\\n#suppress \\\"@azure-tools/typespec-azure-core/documentation-required\\\" \\\"For backward compatibility\\\"\\r\\n- model ListAppIdResponse is Azure.Core.Page\\u003cAppId\\u003e;\\r\\n+ model ListAppIdResponse {\\r\\n+    /*\\r\\n+    * List of AppIds\\r\\n+    */\\r\\n+    @TypeSpec.pageItems\\r\\n+    value: string[];\\r\\n+\\r\\n+    /*\\r\\n+    * next Link\\r\\n+    */\\r\\n+    @TypeSpec.nextLink\\r\\n+    nextLink?: string;\\r\\n+ }\\r\\n```\\r\\n\\r\\n```diff\\r\\n  #suppress \\\"@azure-tools/typespec-azure-core/no-openapi\\\" \\\"non-standard operations\\\"\\r\\n  @operationId(\\\"LocalRulestacks_listAppIds\\\")\\r\\n+ @TypeSpec.list\\r\\n  listAppIds is ArmResourceActionSync\\u003c\\r\\n      LocalRulestackResource,\\r\\n      void,\\r\\n      ArmResponse\\u003cListAppIdResponse\\u003e,\\r\\n      Parameters = {\\r\\n          #suppress \\\"@azure-tools/typespec-azure-core/documentation-required\\\" \\\"For backward compatibility\\\"\\r\\n          @query(\\\"appIdVersion\\\")\\r\\n          appIdVersion?: string;\\r\\n\\r\\n          #suppress \\\"@azure-tools/typespec-azure-core/documentation-required\\\" \\\"For backward compatibility\\\"\\r\\n          @query(\\\"appPrefix\\\")\\r\\n          appPrefix?: string;\\r\\n      }\\r\\n  };\\r\\n```\\r\\nif it's pageable, then add decorator @TypeSpec.List to the operation\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Typespec Validation required check\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Typespec Validation required check\\n\\n## question\\n\\n\\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\". Please add \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-fakes\\\". Please add \\\"options.@azure-tools/typespec-go.generate-fakes\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.head-as-boolean\\\". Please add \\\"options.@azure-tools/typespec-go.head-as-boolean\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.inject-spans\\\". Please add \\\"options.@azure-tools/typespec-go.inject-spans\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-python.package-dir\\\". Please add \\\"options.@azure-tools/typespec-python.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-csharp.namespace \\\"Microsoft.Azure.Management.DevTestLabs\\\" does not match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter. Please update the value of \\\"options.@azure-tools/typespec-csharp.namespace\\\" to match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter.\\r\\nPlease see https://aka.ms/azsdk/spec-gen-sdk-config for more info.\\r\\nFor additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.\\r\\n```\\r\\nI have copied the namespace from the autorest readme files that we had before and it was responsible  to generate SDKs. Is it a requirement to update the namespace as suggested given we have already published the SDK before?\\n\\nPR: https://github.com/Azure/azure-rest-api-specs/pull/35346\\r\\nThis PR only has typespec conversion change and no API update. It is currently failing for required check - Typespec validation. When I run the npx tsmv command locally then I see the following error.\\r\\n```\\r\\nExecuting rule: SdkTspConfigValidation\\r\\nValidation on option \\\"options.@azure-tools/typespec-csharp.namespace\\\" in \\\"@azure-tools/typespec-csharp\\\" are failed. However, per @azure-tools/typespec-csharp’s decision, we will treat it as passed.\\r\\n[SdkTspConfigValidation]: validation failed.\\r\\n- Failed to find \\\"parameters.service-dir.default\\\". Please add \\\"parameters.service-dir.default\\\".\\r\\n- The value of options.@azure-tools/typespec-java.package-dir \\\"azure-mgmt-devtestlabs\\\" does not match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.package-dir\\\" to match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\".\\r\\n- The value of options.@azure-tools/typespec-java.namespace \\\"com.microsoft.azure.management.devtestlabs\\\" does not match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.namespace\\\" to match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.service-dir\\\". Please add \\\"options.@azure-tools/typespec-go.service-dir\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.package-dir\\\". Please add \\\"options.@azure-tools/typespec-go.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-go.module \\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\n\\n## answer\\n\\ntypeSpec validation is failing, but not for that reason.  The configuration for c-sharp emitter is a warning only.  The current failure is caused by diffs between the generated swagger included in your PR and the generated swagger when the ci compiles your spec.\\r\\n \\r\\nUsually this indicates that your local dependencies are out of date, and you need to pull the latest into your local branch and re-install at thetop level:\\r\\n \\r\\ngit fetch upstream main\\r\\ngit pull upstream main\\r\\nnpm ci\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_12.md\",\"document_title\":\"SDK Validation steps are failing with not much helpful logs\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_12.md\\n\\n# SDK Validation steps are failing with not much helpful logs\\n\\n## question\\n\\nWe’re in the process of creating a new API version within our RP. However, all SDK-related checks are currently failing, and we’re unable to identify any issues flagged in our changes.\\r\\n \\r\\nCould you please assist us in resolving these failures at the earliest? Your support will help us move forward without further delays.\\r\\n\\r\\n```\\r\\nErrors occurred while generating SDK from specification/advisor. Follow the steps at https://aka.ms/azsdk/sdk-automation-faq#how-to-view-the-detailed-sdk-generation-errors to view detailed errors.\\r\\n[ERROR] total 1 error(s):\\r\\n[ERROR] failed to execute `tsp-client init --update-if-exists --tsp-config /mnt/vss/_work/1/s/azure-rest-api-specs-pr/specification/advisor/Advisor.Management/tspconfig.yaml --commit 028d4d7cae9471f24a06aea6a1f60bf01f37f567 --repo Azure/azure-rest-api-specs-pr --local-spec-repo /mnt/vss/_work/1/s/azure-rest-api-specs-pr/specification/advisor/Advisor.Management --emitter-options module-version=0.1.0 --debug`\\r\\n[ERROR] Please update your tspconfig.yaml to include the \\\"emitter-output-dir\\\" option under the \\\"@azure-tools/typespec-go\\\" emitter options. \\\"package-dir\\\" support is deprecated and will be removed in future versions.\\r\\n[ERROR] Error reading tsp-location.yaml: Error: ENOENT: no such file or directory, stat '/mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/tsp-location.yaml'\\r\\n[ERROR] Diagnostics were reported during compilation. Use the `--debug` flag to see if there is warning diagnostic output.\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\n\\noutput.\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:10:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:10:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n```\\r\\n\\r\\n```\\r\\nSome checks were not successful\\r\\n7 failing, 2 pending, 1 queued, 31 successful checks\\r\\n\\r\\n7 failing checks\\r\\nprivate.rest-api-specs-pr Failing after 1m — Build #Azure OpenAPI failed\\r\\nprivate.rest-api-specs-pr (BranchProtectionForPrivateRepo) Failing after 1m — BranchProtectionForPriv...\\r\\nSDK Validation - .NET - PR Failing after 7m — Build #20250911.25 failed\\r\\nSDK Validation - Go - PR Failing after 4m — Build #20250911.25 failed\\r\\nSDK Validation - Java - PR Failing after 4m — Build #20250911.25 failed\\r\\nSDK Validation - JS - PR Failing after 3m — Build #20250911.25 failed\\r\\nSDK Validation - Python - PR Failing after 7m — Build #20250911.25 failed\\r\\n\\r\\nMerging is blocked\\r\\n```\\r\\n\\r\\nPR: [Advisor Risks : 2025-09-01-preview by pranatiy0701 · Pull Request #24395 · Azure/azure-rest-api-spe…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24395)\\n\\n## answer\\n\\nIt looks like your PR is against the main branch of the private repo - we don't check api specs into this branch.  The sdk failures for flattenProperty are due to those SDKs not being up-to-date with the latest version of typespec-client-generator-core, which was released earlier this week.  Since you are not checking this spec in to the main branch of the private repo, these can be safely ignored.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Swagger breaking change\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Swagger breaking change\\n\\n## question\\n\\nPR check run: https://github.com/Azure/azure-rest-api-specs/pull/35346/checks?check_run_id=44501918225\\r\\nMy typespec conversion PR is failing in swagger breaking change check with the following error: \\r\\n\\\"new\\\":\\\"https://github.com/Azure/azure-rest-api-specs/blob/a1ac3f6f98bb1ea3583b765d00dfceab6d85654f/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json\\\",\\r\\n\\\"old\\\":\\\"https://github.com/Azure/azure-rest-api-specs/blob/main/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json\\\",\\r\\n\\\"details\\\":\\\"incompatible properties : tags\\\\n definitions/TrackedResource/properties/tags\\\\n at file:///mnt/vss/_work/1/azure-rest-api-specs/specification/common-types/resource-management/v3/types.json#L489:8\\\\n definitions/Resource/properties/tags\\\\n at file:///mnt/vss/_work/1/azure-rest-api-specs/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json#L12397:8\\\" \\r\\nThis PR is just having typespec conversion change and I am avoiding any change to the swagger file that is generated as part of typespec conversion. In the old swagger there is a Resource definitionwhich is similar Azure resource definition. Should I suppress this check and how to do it?\\n\\n## answer\\n\\nThis occurs because in your original swagger, you did not use swagger common-types. \\r\\nThe 'tags' definitions are compatible, so there is no change in the actual api from this.  This could result in changes in some management sdks, although this change to using the common resource types has generally been accepted. \\r\\ndocs on suppressions for false positives are here: [Suppress validation failures on a PR](https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions) \\r\\nNote that it is important to go through these violations, as the conversion is not guaranteed to be 100% accurate.\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-09-05.md\",\"document_title\":\"Extra \\\"TypeSpec.Http.OkResponse\\\" schema in new Swagger\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-09-05.md\\n\\n# Extra \\\"TypeSpec.Http.OkResponse\\\" schema in new Swagger\\n\\n## question\\n\\nNew Swagger contains \\\"TypeSpec.Http.OkResponse\\\" schema\\n\\n## answer\\n\\nIt is typically generated from LRO operation that returns 200 without body.\\r\\n\\r\\nChange the op to e.g.\\r\\n\\r\\n  restoreFiles is ArmResourceActionAsync\\u003c\\r\\n    Snapshot,\\r\\n    SnapshotRestoreFiles,\\r\\n    {\\r\\n      @body body: void;\\r\\n    },\\r\\n    LroHeaders = ArmLroLocationHeader\\u003cFinalResult = void\\u003e \\u0026\\r\\n      Azure.Core.Foundations.RetryAfterHeader\\r\\n  \\u003e;\\r\\n\\r\\nExample https://github.com/Azure/azure-rest-api-specs/pull/36876/commits/78feeb1eaca3a500d3bf2bab68034178f06afa1b\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-spec-gen-sdk-config.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-spec-gen-sdk-config\",\"content\":\"# SDK generation configuration\\n## Enable SDK generation\\n### [TypeSpec](#tab/typespec)\\nAdd the specific SDK language emitter settings to `tspconfig.yaml`. For example, to generate CSharp SDK code from your TypeSpecs:\\r\\n\\r\\n1. Add `@azure-tools/typespec-csharp` to the `options` settings in `tspconfig.yaml`.\\r\\n2. Refer to the 'ContosoWidgetManager' samples to set the default values for each SDK language emitter:\\r\\n    - For management plane TypeSpecs, refer to [Contoso.Management tspconfig.yaml](https://aka.ms/azsdk/tspconfig-sample-mpg).\\r\\n    - For data plane TypeSpecs, refer to [Contoso.WidgetManager tspconfig.yaml](https://aka.ms/azsdk/tspconfig-sample-dpg).\\r\\n\\r\\n````\\r\\n\\\"@azure-tools/typespec-csharp\\\":\\r\\n    flavor: azure\\r\\n    package-dir: \\\"Azure.ResourceManager.Contoso\\\"\\r\\n    clear-output-folder: true\\r\\n    model-namespace: true\\r\\n    namespace: \\\"{package-dir}\\\"\\r\\n````\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#breakingchange.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# Resolving OpenAPI Breaking Change Violations\\n## Migrating ARM Specifications\\n### Visibility Changes for `nextLink` and `value` Properties\\nFor the `nextLink` and `value` properties of pageable operation response model, some older specifications marked these values as `readOnly`. This has no impact on the API or on SDKs, you can safely ignore this difference in the spec, and any resulting breaking change violation.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Validation.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation\",\"content\":\"# Table of Contents\\n- [How to Re-run SDK Validation Checks](#how-to-re-run-sdk-validation-checks)\\r\\n- [How to Re-evaluate `SDK Validation Status` Check](#how-to-re-evaluate-sdk-validation-status-check)\\r\\n- [How to Download the Generated Artifacts](#how-to-download-the-generated-artifacts)\\r\\n  - [Prerequisites](#prerequisites)\\r\\n  - [Steps to Download Artifacts](#steps-to-download-artifacts)\\r\\n- [How to View the Html Report of `SDK Validation` Checks Result](#how-to-view-the-html-report-of-sdk-validation-checks-result)\\r\\n- [How to View the Detailed SDK Generation Errors](#how-to-view-the-detailed-sdk-generation-errors)\\r\\n- [Use Pipeline to Create SDK Pull Request from Your API Specs](#use-pipeline-to-create-sdk-pull-request-from-your-api-specs)\\r\\n- [Common Error Fix Guidance](#common-error-fix-guidance)\\r\\n - [Import Resolution Errors](#import-resolution-errors)\\r\\n   - [Error Pattern: `import-not-found`](#error-pattern-import-not-found)\\r\\n- [.NET SDK Generation Error Fix Guidance](#net-sdk-generation-error-fix-guidance)\\r\\n  - [How to Fix Naming Violations for Management Plane SDK](#how-to-fix-naming-violations-for-management-plane-sdk)\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Validation.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation\",\"content\":\"# Table of Contents\\n## Use Pipeline to Create SDK Pull Request from Your API Specs\\nFor detailed instructions, please refer to [Using the SDK Generation Pipelines](https://aka.ms/azsdk/spec-gen-sdk-pipeline-doc).\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"ARM-Auto-SignOff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/ARM-Auto-SignOff\",\"content\":\"## Test PRs\\n- RM TSP: https://github.com/Azure/azure-rest-api-specs/pull/32545\\r\\n- DP TSP: https://github.com/Azure/azure-rest-api-specs/pull/32694\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-spec-gen-sdk-config.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-spec-gen-sdk-config\",\"content\":\"# SDK generation configuration\\nTo generate SDK code based on REST API specifications, you need to configure the corresponding files.\\r\\n\\r\\n- For TypeSpec, the configuration file is `tspconfig.yaml`.\\r\\n- For OpenAPI, the configuration file is `readme.md`.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Branch protection rules table\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\nThis table shows which GitHub checks are marked as `required` on respective branches. Even when a check is marked as ❌\\r\\nit **may** still be running on given branch; just that if it fails, the PR won't be blocked from merging.\\r\\n\\r\\n| Branch | Merge | SDK | TSVal | BrCh | BrChC | LintRPaaS | LintDiff | Model | Semantic | Spell | Prettier | license | approver |\\r\\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\\r\\n| public `main`                  | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSMaster`         | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| public/private `release-*`     | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSDev`            | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `InternalARMContracts` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `ARMCoreRPDev`         | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n\\r\\nLegend:\\r\\n\\r\\n| Column name | Full GitHub check name               |\\r\\n|-------------|--------------------------------------|\\r\\n| `BrCh`      | `Swagger BreakingChange`             |\\r\\n| `BrChC`     | `Breaking Change(Cross-Version)`     |\\r\\n| `license`   | `license/cla`                        |\\r\\n| `LintDiff`  | `Swagger LintDiff`                   |\\r\\n| `LintRPaaS` | `Swagger Lint(RPaaS)`                |\\r\\n| `Merge`     | `Automated merging requirements met` |\\r\\n| `Model`     | `Swagger ModelValidation`            |\\r\\n| `Prettier`  | `PrettierCheck`                      |\\r\\n| `SDK`       | `SDK azure-sdk-for-go`               |\\r\\n| `Semantic`  | `Swagger SemanticValidation`         |\\r\\n| `Spell`     | `SpellCheck`                         |\\r\\n| `TSVal`     | `TypeScript Validation`              |\\r\\n| `approver`  | Requires team member approval        |\\r\\n\\r\\nFor more information on these checks, see:\\r\\n\\r\\n- https://aka.ms/azsdk/pr-getting-help\\r\\n- https://aka.ms/ci-fix\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Addressing `BreakingChangeReviewRequired`\\n### `BreakingChange-Approved-Previously`\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-spec-gen-sdk-config.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-spec-gen-sdk-config\",\"content\":\"# SDK generation configuration\\n## Enable SDK generation\\n\\u003e[!IMPORTANT]\\r\\n\\u003e You cannot enable SDK generation for both TypeSpec and OpenAPI simultaneously. Disable one before enabling the other.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#specs-pr-guides.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/specs-pr-guides\",\"content\":\"# Azure REST API specs PRs Guides\\nThis section contains articles with detailed guidance for various aspects of getting your  \\r\\n[Azure REST API specs PR](xref:api-specs-pr) merged.\\r\\n\\r\\nBy design, you are expected to be linked to these articles from your specs PR. As such, these articles assume\\r\\nvery specific context which may not be evident if you read them without having a corresponding PR.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Addressing `BreakingChangeReviewRequired`\\n### `BreakingChange-Approved-Benign`\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-spec-gen-sdk-config.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-spec-gen-sdk-config\",\"content\":\"# SDK generation configuration\\n## Enable SDK generation\\n### [OpenAPI](#tab/openapi)\\nConfigure the `swagger-to-sdk` section in `readme.md`. For example, to generate CSharp SDK code for your OpenAPIs:\\r\\n\\r\\n1. Add `azure-sdk-for-net` to the list.\\r\\n2. Add detailed settings to a separate file `readme.csharp.md` and place it in the same folder as `readme.md`.\\r\\n\\r\\n````\"}]", "inputs.latency": 60.911438941955566, "inputs.response_length": 2504, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange", "https://eng.ms/docs/products/azure-developer-experience/design/api-spec-gen-sdk-config"], "inputs.testcase": "SDK Validation - .NET", "outputs.similarity.similarity": 3.0, "outputs.similarity.gpt_similarity": 3.0, "outputs.similarity.similarity_result": "fail", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 3561, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 3562, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: SDK Validation - .NET\\\\n\\\\nquestion: I have an open PR inital genome api spec by samira-farhin \\\\u00b7 Pull Request #25097 \\\\u00b7 Azure/azure-rest-api-specs-pr that's currently failing on SDK Validation - .NET - PR. My latest changes to resolve SDK Validation in \\\\\\\"tspconfig.yaml\\\\\\\" are included below. After these updates, the SDK validation issues for Go and Java were resolved, but the C# issue still remains. I'm unsure what else needs to be addressed.\\\\ninital genome api spec by samira-farhin \\\\u00b7 Pull Request #25097 \\\\u00b7 Azure/azure-rest-api-specs-pr\\\\ninital genome api spec by samira-farhin \\\\u00b7 Pull Request #25097 \\\\u00b7 Azure/azure-rest-api-specs-pr\\\\n```\\\\ncommand\\\\u2003\\\\u2003pwsh ./eng/scripts/Automation-Sdk-Init.ps1 ../azure-sdk-for-net-pr_tmp/initInput.json ../azure-sdk-for-net-pr_tmp/initOutput.json\\\\ncommand\\\\u2003\\\\u2003pwsh ./eng/scripts/Invoke-GenerateAndBuildV2.ps1 ../azure-sdk-for-net-pr_tmp/generateInput.json ../azure-sdk-for-net-pr_tmp/generateOutput.json\\\\ncmdout\\\\u2003\\\\u2003[.Net] Start to call tsp-client to generate package:Azure.ResourceManager.Genome\\\\ncmdout\\\\u2003\\\\u2003[.Net] Start to build sdk project: /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net]     8 Error(s)\\\\ncmdout\\\\u2003\\\\u2003[.Net] [ERROR] Failed to build the sdk project: Azure.ResourceManager.Genome for service: genome. Exit code: False. Please review the detail errors for potential fixes. If the issue persists, contact the DotNet language support channel at https://aka.ms/azsdk/dotnet-teams-channel and include this spec pull request.\\\\n```\\\", \\\"response\\\": \\\"Based on the error message, the CS0122 error ('GeneratorPageableHelpers' is inaccessible due to its protection level) in your C# SDK build is almost always due to incorrect or missing configuration for paging in your TypeSpec models and operations. The .NET SDK generator expects paging to be defined using the Azure.Core.Page<T> template and the appropriate decorators for the 'value' and 'nextLink' properties in the response model.\\\\n\\\\nHere\\\\u2019s what you need to do:\\\\n\\\\n1. **Update your response model for pageable operations**:\\\\n   - Ensure that any model returned by a pageable operation is either based on `Azure.Core.Page<T>` or follows the pattern with explicit `@TypeSpec.pageItems` and `@TypeSpec.nextLink` decorators.\\\\n   - Example:\\\\n   ```tsp\\\\n   model GenomeAccountList {\\\\n     @TypeSpec.pageItems\\\\n     value: GenomeAccount[];\\\\n\\\\n     @TypeSpec.nextLink\\\\n     nextLink?: string;\\\\n   }\\\\n   ```\\\\n   Or, if you use the template:\\\\n   ```tsp\\\\n   model GenomeAccountList is Azure.Core.Page<GenomeAccount>;\\\\n   ```\\\\n\\\\n2. **Decorate the corresponding operation as pageable**:\\\\n   - Use `@TypeSpec.list` on the operation if it is a list/get all operation.\\\\n   ```tsp\\\\n   @TypeSpec.list\\\\n   listGenomeAccounts is ArmResourceActionSync<\\\\n     GenomeResource,\\\\n     void,\\\\n     ArmResponse<GenomeAccountList>,\\\\n     Parameters\\\\n   >;\\\\n   ```\\\\n\\\\n3. **Double-check your tspconfig.yaml**:\\\\n   - Ensure you are using the latest versions of all TypeSpec and Azure SDK emitters.\\\\n   - The C# emitter should have `flavor: azure` and the correct `package-dir` and `namespace` settings, following the ARM template examples.\\\\n   - Example:\\\\n   ```yaml\\\\n   options:\\\\n     \\\\\\\"@azure-tools/typespec-csharp\\\\\\\":\\\\n       flavor: azure\\\\n       package-dir: \\\\\\\"Azure.ResourceManager.Genome\\\\\\\"\\\\n       clear-output-folder: true\\\\n       model-namespace: true\\\\n       namespace: \\\\\\\"Azure.ResourceManager.Genome\\\\\\\"\\\\n   ```\\\\n\\\\n4. **Regenerate the SDK after updating your TypeSpec models and config**:\\\\n   - Run `npm ci` or `tsp install` to ensure all dependencies are up to date, then recompile and rerun the SDK generation pipeline.\\\\n\\\\nIf you still see the CS0122 error after these fixes, double-check that none of your pageable response models are missing the decorators or are shared with non-pageable operations (see references below for this migration pitfall).\\\\n\\\\n**Summary:** The .NET generator relies on proper paging schema in TypeSpec. Update your models and operations to use the Azure paging templates and decorators. This should resolve the CS0122 errors in the generated C# code.\\\", \\\"ground_truth\\\": \\\"This has been fixed in azure-sdk-for-net, and will be synced to azure-sdk-for-net-pr during the day. Your spec is in private repo, after the sync rerun should resolve this. And meanwhile, .NET SDK validation is optional for your spec PR merge, you can ignore it for now.\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"}, {"inputs.query": "title: Permission to merge to RPSaaSMaster\n\nquestion: Hi\nGeneral\n,\nDue to recent team reorganization I am now in charge of my team and I need to get permission to merge changes to RPSaaSMaster, e.g. I need to merge this PR - Small fix for Dsts Sci Groups by Alessar · Pull Request #24977 · Azure/azure-rest-api-specs-pr\nCould you please help me with that?\nThank you", "inputs.ground_truth": "https://aka.ms/azsdk/access", "inputs.response": "To obtain permission to merge changes into the RPSaaSMaster branch of the Azure/azure-rest-api-specs-pr repository, you must first ensure you have write access to the repository. Write access is granted through membership in the appropriate Azure GitHub organization and the azure-sdk-partners team. Here’s what you need to do:\n\n1. Request to join the Azure SDK Partners group at https://aka.ms/azsdk/join/azuresdkpartners and have your manager approve your request. Once approved, you’ll be automatically added to the azure-sdk-partners GitHub team, which gives you write access to all Azure SDK-related repositories.\n2. Write access will allow you to merge to the 'main' branch and protected branches such as RPSaaSMaster, but you still need CODEOWNERS approval for your PRs. Ensure you have all required approvals before merging.\n3. If you have recently taken on responsibility for your team due to reorganization, you may also need to update the CODEOWNERS file to reflect your new role so you are recognized as an approver for relevant files and folders.\n4. After joining the appropriate teams and updating CODEOWNERS (if necessary), you will have the permissions needed to merge your PRs (e.g., PR #24977) to RPSaaSMaster, as long as all required CI checks and approvals are met.\n\nPlease follow these steps to get the necessary access. If you encounter any issues with the process or require additional assistance, refer to the official onboarding and access documentation provided below.", "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"Create a PR against main\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\\n\\n# Create a PR against main\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nWhen you're ready for a final review, it's time to create a pull request (PR) from your release branch you created\\r\\noriginally to the `main` branch on [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n* :warning: Do not merge `main` or other release branches unless you know there are changes required.\\r\\n* :white_check_mark: Rebase on `main` if changes are required in a separate topic branch.\\n\\n## Clean PR against main\\n\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\\n\\n## Update your branch with changes from main\\n\\nIf you know there are other changes in the `main` branch or that other services have updated shared files in `main`\\r\\nalready and you need to pick up changes before merging, we recommend you take a merge from main. This is particularly interesting\\r\\nfor common infrastructure changes that are committed in the repo (i.e. github actions, tools, etc). Depending on how old your\\r\\nbranch is some of the pull request checks may not correctly function without taking a merge from main. \\r\\n\\r\\nIf you are working in a non-protected branch you can do a `git merge main` like you would normally do a merge and then push\\r\\nyour changes to your remote branch. However, if you are working in a branch with branch protection enabled (i.e. `release-*`) then\\r\\nyou will need to make a pull request to your branch with the merge. Depending on how out-of-date your branch is from `main` your \\r\\nmerge may have a lot of unwanted and unnecessary changes and the checks not pass. In such cases see below on how to [update the infrastructure](#updating-only-the-infrastructure-changes-from-main).\\n\\n### Updating only the infrastructure changes from main\\n\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\\n\\n## Next steps\\n\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# design#api-specs-pr#api-versions-and-branches.md\\n\\n| Short Link: | [aka.ms/azsdk/api-versions](https://aka.ms/azsdk/api-versions) |\\r\\n|--|--|\\n\\n# API versions and branches\\n\\nThis article explains the various lifecycle stages of spec API versions and how do they relate to git branches of the  \\r\\n[specs repositories](xref:api-repos).\\n\\n## Spec repos branches table\\n\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\n| Branch                 | [Public repository][public specs repo]        | [Private repository][private specs repo]              |\\r\\n|------------------------|-----------------------------------------------|-------------------------------------------------------|\\r\\n| `main`                 | All API versions in `GA` and `public preview` | Mirrored from public `main`                           |\\r\\n| `RPSaaSMaster`         | N/A                                           | For RPaaS-based specs in `private preview`   |\\r\\n| `RPSaaSDev`            | N/A                                           | For dogfooding RPaaS-based specs.                     |\\r\\n| `release-*`            | Feature branches.                             | Feature branches.                                     |\\r\\n| `dev-*`                | Obsolete. Use `release-*` instead.            | Obsolete. Use `release-*` instead.                    |\\r\\n| `ARMCoreRPDev`         | N/A                                           | [Obsolete ShiftLeft branch]. Use `release-*` instead. |\\r\\n| `InternalARMContracts` | N/A                                           | For ARM-internal APIs, never published to customers.  |\\r\\n\\r\\nIf a given branch in the public or private spec repos is not listed in the table above, then most likely\\r\\nit is obsolete, deprecated, or otherwise not recommended for use.\\n\\n## Branch protection rules table\\n\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\nThis table shows which GitHub checks are marked as `required` on respective branches. Even when a check is marked as ❌\\r\\nit **may** still be running on given branch; just that if it fails, the PR won't be blocked from merging.\\r\\n\\r\\n| Branch | Merge | SDK | TSVal | BrCh | BrChC | LintRPaaS | LintDiff | Model | Semantic | Spell | Prettier | license | approver |\\r\\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\\r\\n| public `main`                  | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSMaster`         | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| public/private `release-*`     | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSDev`            | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `InternalARMContracts` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `ARMCoreRPDev`         | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n\\r\\nLegend:\\r\\n\\r\\n| Column name | Full GitHub check name               |\\r\\n|-------------|--------------------------------------|\\r\\n| `BrCh`      | `Swagger BreakingChange`             |\\r\\n| `BrChC`     | `Breaking Change(Cross-Version)`     |\\r\\n| `license`   | `license/cla`                        |\\r\\n| `LintDiff`  | `Swagger LintDiff`                   |\\r\\n| `LintRPaaS` | `Swagger Lint(RPaaS)`                |\\r\\n| `Merge`     | `Automated merging requirements met` |\\r\\n| `Model`     | `Swagger ModelValidation`            |\\r\\n| `Prettier`  | `PrettierCheck`                      |\\r\\n| `SDK`       | `SDK azure-sdk-for-go`               |\\r\\n| `Semantic`  | `Swagger SemanticValidation`         |\\r\\n| `Spell`     | `SpellCheck`                         |\\r\\n| `TSVal`     | `TypeScript Validation`              |\\r\\n| `approver`  | Requires team member approval        |\\r\\n\\r\\nFor more information on these checks, see:\\r\\n\\r\\n- https://aka.ms/azsdk/pr-getting-help\\r\\n- https://aka.ms/ci-fix\\n\\n## API version lifecycle stages\\n\\nAn API version is a TypeSpec/OpenAPI specification contract identified by its `api-version` value.\\r\\n\\r\\nGiven API version is located in its own directory in the specs repositories. It can be in following lifecycle stages:\\r\\n\\r\\n- `generally available` (aka `GA`, `stable`)\\r\\n- `public preview`\\r\\n- `private preview`\\r\\n- `in development`\\r\\n- `closing down`\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e A `closing down` API spec version need to be kept in the spec repository until it is fully `deprecated`. A `deprecated` API spec version need to be removed from the spec repository, with removal initiated by the service to begin deprecating related APIs, SDKs, and CLIs.\\r\\n\\r\\nThese stages corresponds to [service tree lifecycle stages] as elaborated on in [ARM lifecycle stages requirements].\\n\\n### Generally available\\n\\n**GA** API versions have been released to all Azure customers.\\r\\n\\r\\nFor an API version to be in GA it must:\\r\\n\\r\\n- Be present in the `main` branch of the [public specs repo].\\r\\n- Be in a parent `stable` folder and without a `-preview` suffix. See [spec directory structure] for full details.\\r\\n- Not be gated by any feature flags, including Azure Feature Exposure Control ([AFEC]) flags.\\n\\n### Public preview\\n\\n**Public preview** API versions have been released to all Azure customers, but are not yet GA.\\r\\nFor an API version to be in `public preview`, it must:\\r\\n\\r\\n- Not yet be GA.\\r\\n- Be present in the `main` branch of the [public specs repo].\\r\\n- Be in a parent `preview` folder and have `-preview` suffix in its folder name.\\r\\n  See [spec directory structure] and [ARM preview guidelines] for full details.\\r\\n- Not be gated by any feature flags, including [AFEC] flags.\\n\\n### Private preview\\n\\n**Private preview** API versions have been released to a limited set of Azure customers.\\r\\n\\r\\nUsually API versions are in `private preview` for following reasons:\\r\\n\\r\\n- The spec API version preview cannot yet be made public due to business or marketing reasons.\\r\\n- Early customer feedback is being gathered for given API version preview.\\r\\n\\r\\nFor an API version to be in `private preview`, it must:\\r\\n\\r\\n- Not yet be `GA` or in `public preview`.\\r\\n- Not be present in the [public specs repo] `main` branch or any other branch in that repo.\\r\\n- Be in a parent `preview` folder and have `-prefix` in its folder name.\\r\\n  See [spec directory structure] and [ARM preview guidelines] for full details.\\r\\n- Have at least one customer. If an API version has no customers, it is `in development`, not in `private preview`.\\r\\n- In case of ARM specs:\\r\\n  - Be present in the `RPSaaSMaster` branch of the [private specs repo].\\r\\n    See [ARM branches] and [ARM lifecycle stages requirements] for details.\\r\\n  - Be under access control done with [AFEC] flags.\\r\\n- In case of data-plane specs:\\r\\n  - Can be in any branch in the [private specs repo], except `main` or `RPaaS*` branches,\\r\\n    as there is no designated branch like `RPSaaSMaster` for ARM specs.\\r\\n  - There is no need for access control done with [AFEC] flags, as data plane services should have some mechanism\\r\\n    for allowing `private preview` customers to onboard the preview.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e A `private preview` API spec version can be published as `public preview` by following  \\r\\n\\u003e [this how-to](xref:pr-move-private-to-public).\\n\\n### In development\\n\\n**In development** API versions are all API versions that are not `GA`, in `public preview` or in `private preview`.\\r\\nNotably, such API versions are not present in the [public specs repo] `main` branch and do not have any customers.\\r\\nHowever, they may be present in the public repo feature branches.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e REST API definitions for a service or API version that is `in development` MUST NOT be present in the  \\r\\n\\u003e [public specs repo] `main` at all.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e ARM spec API version, while `in development`, should not be trying to merge into `RPSaaSMaster`.\\r\\n\\u003e The ARM guidance for this is in [ARM spec onboarding] article.\\r\\n\\r\\n**Special cases** There are few special situations that do not fit in the API versioning model described above.\\r\\nIn such situations, attend appropriate office hours:\\r\\n\\r\\n- In case of ARM specs, **ARM API Review Office Hours** in [aka.ms/armofficehoursinfo].\\r\\n- In case of data-plane specs, [aka.ms/azapi/officehours].\\n\\n## Spec repos branches\\n\\n### Public specs repo `main` branch\\n\\nAll API versions in the [public specs repo] `main` branch are published to all Azure customers.\\r\\nThis branch includes `GA` and `public preview` API versions.\\r\\n\\r\\n\\u003e [!CAUTION]\\r\\n\\u003e This is not a dev branch. It should contain **only** finished specs that represent services deployed to customers.\\n\\n### Private specs repo `main` branch\\n\\n[Private specs repo] `main` branch is mirrored from [public specs repo] `main` branch by a CI job on a regular basis.\\r\\nAs such, it is **read only**.\\n\\n### Private specs repo `RPSaaSMaster` branch\\n\\n[Private specs repo] `RPSaaSMaster` contains RPaaS-based ARM specifications.\\r\\n\\r\\nWhen an RPaaS-based ARM API goes into `public preview` or `GA` lifecycle stage it must be merged to [public specs repo]\\r\\n`main` as well.\\r\\n\\r\\nSome parts of this branch are being mirrored from public `main` branch\\r\\nby the [mirror-repos] pipeline, triggered manually on at least daily basis.\\r\\n\\r\\nService teams are responsible for keeping their API specifications in this branch synchronized with\\r\\nthe public specs repo `main` branch.\\r\\n\\r\\nSee also [ARM lifecycle stages requirements] and [ARM branches].\\n\\n### `RPSaaSDev` branch\\n\\nUsed for internal ARM dogfooding. See `RPSaaSDev` in [ARM branches].\\r\\n\\r\\nSome parts of this branch are being mirrored from public `main` branch\\r\\nby the [mirror-repos] pipeline, triggered manually on at least daily basis.\\r\\n\\r\\nService teams are responsible for keeping their API specifications in this branch synchronized with\\r\\nthe public specs repo `main` branch.\\r\\n\\r\\nSee also [ARM lifecycle stages requirements] and [ARM branches].\\n\\n### `release-*` branches\\n\\nAll branches with prefix `release-`, both in public and private specs repos. Also known as \\\"feature\\\" branches.\\r\\n\\r\\nThese branches are used for col\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"onboard#access.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/onboard/access\",\"content\":\"# onboard#access.md\\n\\n| Short Link: | [aka.ms/azsdk/access](https://aka.ms/azsdk/access) |\\r\\n| --- | --- |\\n\\n## Request access to Azure REST API and SDK repositories\\n\\nRequest access to Azure REST API and SDK repositories on GitHub so that you can leverage our tooling to check-in your\\r\\nfiles, assign issues, and more.\\n\\n### Before you begin\\n\\nYou'll need a [GitHub](https://github.com) account to contribute to Azure REST API and SDK repositories.\\r\\nBefore you get started, be sure that you also:\\r\\n\\r\\n- Join the [Microsoft](https://repos.opensource.microsoft.com/orgs/Microsoft) organization on GitHub.\\r\\n- Join the [Azure](https://repos.opensource.microsoft.com/orgs/Azure) organization.\\r\\n- Check the visibility of your Microsoft and Azure org memberships.\\r\\n\\r\\nYour GitHub memberships must be set to **Public**. For more information, see  \\r\\n[Changing the visibility for your organization membership](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-personal-account-on-github/managing-your-membership-in-organizations/publicizing-or-hiding-organization-membership#changing-the-visibility-of-your-organization-membership).\\n\\n### Request access to REST API or SDK repositories\\n\\nIf you are working on your [REST API spec](xref:api-repos) or building client libraries (SDKs) for your service you will\\r\\nneed to request the appropriate permissions needed for that work.\\r\\n\\r\\nThese permissions control access to the repositories such as `Azure/azure-rest-api-specs[-pr]` or `Azure/azure-sdk-for-[lang][-pr]`.\\n\\n### Write access\\n\\nIf you're working on branches in the main repo for your spec, or working in the Azure SDK repositories to submit pull\\r\\nrequests or serving as the support contact for issues, you'll need write access so that you can apply or dismiss labels,\\r\\ncreate or modify issues, and assign issues to others. It also allows you to add/update test recordings in the test assets repo.\\r\\n\\r\\nTo get access to Azure SDK repos, request to join the [Azure SDK Partners](https://aka.ms/azsdk/join/azuresdkpartners) \\r\\nand have the request approved by your manager.  *After your manager approves*, it may take up to one day for you to automatically\\r\\nbe added to the [azure-sdk-partners](https://github.com/orgs/Azure/teams/azure-sdk-partners) GitHub team. This will get you\\r\\nwrite access to all Azure SDK related repos. These membership requests will need to be renewed every 180 days.\\r\\n\\r\\nNote that write access will also give you the ability to merge to the 'main' branch in each of the Azure SDK repos. However,\\r\\nthrough branch protection rules, CODEOWNERS approval of PRs is required. This means that for each file/folder your PR has\\r\\nmodified you will need to get approval from the corresponding people listed in the repo's  \\r\\n[CODEOWNERS file](https://github.com/Azure/azure-sdk/blob/main/docs/policies/opensource.md#codeowners). GitHub will automatically\\r\\nadd all matching CODEOWNERS as reviewers to the PR. You need approval from one CODEOWNER in each area in order to merge.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# design#api-specs-pr#api-specs-pr.md\\n\\n| Short Link: | [aka.ms/azsdk/specreview](https://aka.ms/azsdk/specreview) |\\r\\n|--|--|\\n\\n# Create a pull request with your Azure REST API spec update\\n\\nThis article explains how to create a pull request (PR) in the [Azure REST API specification repositories](xref:api-repos).\\r\\nSuch PR is a part of the [release plan](xref:release-plan).\\n\\n## Before you begin\\n\\nEnsure that:\\r\\n\\r\\n- You have onboarded to Azure SDK team processes by following our [onboarding process](xref:onboard).\\r\\n- You have [access](xref:access) to the GitHub repositories and respective Azure open source organization.\\r\\n- You understand the conventions for the [Azure REST API specs GitHub repositories](xref:api-repos).\\r\\n- You have reviewed and validated your REST API spec updates within your team, using a development branch in one of\\r\\n  the specs repos.\\r\\n- You are ready to release the features described in your REST API spec updates in a private preview, public preview,\\r\\n  or GA release.\\r\\n\\r\\n\\u003e[!TIP]\\r\\n\\u003e We are piloting our new AzSDK tools MCP server which includes the ability to generate the SDKs and\\r\\n\\u003e create a draft pull request in the respective language repository. Refer to [AzSDK tools MCP server](xref:azsdk-tools-mcp)\\r\\n\\u003e for instructions on how to install it and use it.\\n\\n## Create a PR against a specs repo\\n\\n\\u003e [!TIP]\\r\\n\\u003e If you have an existing PR in the private repo and you want to move it to the public repo, refer to [this guide](xref:pr-move-private-to-public).\\r\\n\\r\\nWhen you are ready to submit your REST API spec updates for review, you must create a pull request (PR) in either the  \\r\\n[public or private specs repository](xref:api-repos). When creating the PR, you should select either the\\r\\n**Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API spec updates you are\\r\\nsubmitting.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e The PR template and comments added by the PR automation will guide you through the process of getting your PR reviewed,\\r\\napproved, and merged.\\n\\n## Get your PR merged\\n\\n| Short Link: | [aka.ms/azsdk/specreview/merge](https://aka.ms/azsdk/specreview/merge) |\\r\\n|-|-|\\r\\n\\r\\nTo get your PR merged:\\r\\n\\r\\n1. Ensure the `Next Steps to Merge` comment and `Automated merging requirements met` check are green. \\r\\n1. Ensure at least one person has approved your PR. Generally another person from your team that has [write access] to the repo.\\r\\n1. Ensure all required checks are passing and at least investigate to understand any other non-required checks that may be failing. \\r\\n1. Once all required checks are green and any other issues understood you can merge the PR yourself as long as you have [write access] to the repo.\\r\\n1. If your PR is targeting public `main` you will need to first apply the `PublishToCustomers` label to acknowledge you understand this \\r\\n   will cause your spec to be published so customers can consume it.\\r\\n1. If your PR is targeting private repo `main` branch, it **cannot** be merged.\\r\\n   Instead, you can publish your changes to customers by following the guide at [aka.ms/azsdk/move-pr].\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"mcp#mcp-contribution-rules.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/mcp/mcp-contribution-rules\",\"content\":\"# Contribution model for the Azure MCP Server\\n## Contributing process\\n1. Ensure you have access to the internal repository by following the instructions in our [Getting Started](xref:mcp-getting-started) doc.\\r\\n2. Create an onboarding issue in our private repo at [aka.ms/azmcp/onboarding](https://aka.ms/azmcp/onboarding).\\r\\n3. After the issue is created, you will be assigned an onboarding buddy. Your onboarding buddy will help you get started contributing to the repository. Check the issue opened to identify your onboarding buddy.\\r\\n4. Work on your contributions and submit a PR. If you have any questions about getting started, reach out to your onboarding buddy or the \\\"azmcp@microsoft.com\\\" alias. Our [CONTRIBUTING.md file in our GitHub Repository](https://github.com/microsoft/mcp/blob/main/CONTRIBUTING.md) has more specific details.\\r\\n5. Our team will work with you to ensure your changes align with our design guidelines.\\r\\n\\r\\nTo find out more about the Azure SDK release process, you can find the Azure SDK team guidance [here.](xref:onboard)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-review\",\"content\":\"# Schedule a data plane REST API spec review\\n## Prepare for API review\\nWhen you have your REST API definition ready for review, [create a pull request with your Azure REST API spec update](xref:api-specs-pr).\\r\\n\\r\\nYou should prepare and be ready to present the following information during your review:\\r\\n\\r\\n| Title | Importance | Brief description | Example and support documentation |\\r\\n| --- | --- | --- | --- |\\r\\n\\r\\nAPI spec PR link | Must Have | PR with your API spec definition against [azure/azure-rest-api-specs-pr](https://github.com/azure/azure-rest-api-specs-pr) or [azure/azure-rest-api-specs](https://github.com/azure/azure-rest-api-specs) | In order to access the PR, it may be necessary to join the [Azure GitHub organization](https://repos.opensource.microsoft.com/orgs/Azure). \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to https://repos.opensource.microsoft.com/orgs/Azure\\u003c/li\\u003e\\u003cli\\u003eClick **Join Organization**.\\u003c/li\\u003e\\u003c/ol\\u003e\\u003cp\\u003e\\u003cp\\u003eThe PR should be linked to the issue no less than 2 days before your meeting. To properly link your PR, in the issue click on the settings icon next to `Development` on the right side:\\u003cp\\u003e\\u003cp\\u003e![Screenshot](../img/link-pr.png)  |\\r\\nAPI spec PR CI checks | Important |Make sure all CI is passing before requesting a review. | [ci-fix](https://aka.ms/ci-fix) |\\r\\nCore concepts | Must have | A glossary of nouns and verbs  | [Example](https://github.com/Azure/azure-sdk-pr/blob/main/onboarding/Core_Concepts.pdf)\\r\\nAPI reference docs | Good to have | Your API documentation consists of two parts, the API spec document (TypeSpec/OpenAPI spec), and the generated developer docs. These docs are often the first experience a developer will have with your service. Make a good first impression!!| **Recommended for OpenAPI spec**: [VS Code extension](https://marketplace.visualstudio.com/items?itemName=42Crunch.vscode-openapi) load this extension and then open your OpenAPI spec file in VS Code and select **Preview**. \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to your PR and look for the comment added by the `openapi-pipeline-app bot` and title `Swagger Generation Artifacts`.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Breaking changes and versioning issues\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial\",\"content\":\"# Tutorial: Create a new service spec\\n## Why work in a separate branch?\\nThe [Microsoft Azure REST API Guidelines state](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-versioning),\\r\\n\\r\\n\\u003e Azure services need to change over time. However, when changing a service, there are 2 requirements:\\r\\n\\u003e\\r\\n\\u003e 1. Already-running customer workloads must not break due to a service change.\\r\\n\\u003e 2. Customers can adopt a new service version without requiring any code changes.\\r\\n\\u003e    Of course, the customer must modify code to leverage any new service features.\\r\\n\\r\\nTogether with the [Breaking Changes Policy](http://aka.ms/AzBreakingChangesPolicy/), it effectively means that any\\r\\nchanges you merge directly into the `main` branch in  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) must be supported for 90 days for preview\\r\\nversions, and 3 years for stable versions at a minimum.\\r\\n\\r\\nWorking in a separate branch allows your team to iterate on a design, make changes to the REST API definition or\\r\\neven the service as needed, and merge those changes to `main` - effectively publishing that service version -\\r\\nwhen you're ready.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#supporting-sdk-customers#codeowners.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/supporting-sdk-customers/codeowners\",\"content\":\"# CODEOWNERS\\n## Creating and editing a service in CODEOWNERS files\\npull request will then be reviewed by our team. If we have any questions, we will leave them in the comments of the pull request so please monitor the pull request until it is merged.\\r\\n   Once the pull request is reviewed and merged, you will start being mentioned in customer issues and added as a reviewer to PRs that contain changes to the files in the directory location you specified.\\r\\n10. Repeat these steps for the API Specs repo and each language repository you want to make changes to.\\r\\n\\r\\n[Common Repo Labels]: https://github.com/Azure/azure-sdk-tools/blob/main/tools/github/data/common-labels.csv\\r\\n[Ronnie Geraghty]: mailto:rgeraghty@microsoft.com\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-1-branch.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-1-branch\",\"content\":\"# Create a new branch\\n## How to create a new release branch\\n### [Private repo](#tab/private-repo)\\nIn the private repo you can use `main`, `RPSaaSMaster` or `RPSaaSDev` as the base branch.\\r\\n\\r\\n```\\r\\ngit branch \\u003cbranch-name\\u003e \\u003cbase-branch\\u003e\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"faqs#faqs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/faqs/faqs\",\"content\":\"# Azure SDK frequently asked questions\\n## Azure REST API specs PRs\\n### The pull request I created at azure-rest-api-specs[-pr] fails validation, what to do?\\nCarefully follow the guidance provided in the PR description and in the `Next Steps to Merge` comment added to it\\r\\nby the automation.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"faqs#faqs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/faqs/faqs\",\"content\":\"# Azure SDK frequently asked questions\\n## Azure REST API specs PRs\\nThis FAQ pertains to [Azure REST API specs PRs](xref:api-specs-pr).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-repos.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-repos\",\"content\":\"# Azure REST API specs repositories on GitHub\\nThe REST API descriptions for all Azure services should be published in the Azure REST API specs GitHub repositories.\\r\\n\\r\\nThe [Azure/azure-rest-api-specs] is the public repository. All work done in this repository is public, i.e. visible to\\r\\neveryone, including people outside of Microsoft. Any Azure REST API specification updates must be merged to the `main`\\r\\nbranch as part of the process of releasing those updates to Microsoft customers.\\r\\n\\r\\nThe [Azure/azure-rest-api-specs-pr] is the private repository (the \\\"pr\\\" stands for \\\"private\\\"). It is for work that must\\r\\nremain private until it is ready to be published. For example, if your team is working on a new product with a new Azure\\r\\nResource Manager (ARM) or Resource Provider (RP) namespace, you want to keep developing it in the private repository\\r\\nuntil you have drafted, tested and went through the API review process. Only after this is done, you must merge your\\r\\nchanges to the `main` branch in the public repository.\\r\\n\\r\\nThe `main` branch in the private repository is read-only, as it is mirrored from the public repository `main` branch.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-2-update.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-2-update\",\"content\":\"# Work against the release branch\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nNow that you've created a release branch, let people know the branch name you created above. They should create topic\\r\\nbranches against that branch - just like they would against the `main` branch - and submit pull requests (PR).\\r\\nRead about [API design](xref:api-design) for guidelines and more information.\\r\\n\\r\\n- :white_check_mark: Create a topic branch from the upstream release branch.\\r\\n- :white_check_mark: Submit a PR when ready against the upstream release branch.\\r\\n- :x: Do not merge the `main` branch into your topic branch. If you need specific changes, you can cherry-pick them,\\r\\n  or simply copy and paste.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release\",\"content\":\"# Release SDK\\n## Before you begin\\n- You have [access](xref:access) to the GitHub repositories, respective GitHub groups, and release security groups.\\r\\n- You have a [release plan](xref:release-plan) created to manage and understand the steps required to generate,\\r\\ntest, and release an SDK.\\r\\n- The REST API specs need to be merged in the main branch of the public repository [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n- Ensure to complete all tasks outlined on this page [Prerequisites to release SDKs](xref:sdk-release-prerequisites).\\r\\n- Breaking changes to GAed SDKs are not permitted as they conflict with the  \\r\\n[Azure SDK design principle](https://azure.github.io/azure-sdk/general_introduction.html#dependable).\\r\\nIf breaking changes are inevitable, ensure to get approval from [Azure Breaking Changes Board](https://aka.ms/azbreakingchangespolicy)\\r\\nin your service API Spec review.\\r\\n- Ensure your service is available to the public before the SDK release date.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-arm-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-arm-review\",\"content\":\"# Get your PR reviewed by ARM\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nIf your Azure REST API specs PR pertains to ARM (see [glossary](xref:glossary#arm)) specs,\\r\\nthen the second step of the PR approval process per the [PR workflow diagram] (https://aka.ms/azsdk/pr-diagram)\\r\\nis the ARM review. The overall PR approval process is explained at https://aka.ms/azsdk/specreview/merge.\\r\\n\\r\\nIf your PR does not pertain to ARM specs, then this article won't be relevant to you.\\r\\nSee instead [`Getting help` section] on your PR (https://aka.ms/azsdk/pr-getting-help).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#specs-pr-guides.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/specs-pr-guides\",\"content\":\"# Azure REST API specs PRs Guides\\nThis section contains articles with detailed guidance for various aspects of getting your  \\r\\n[Azure REST API specs PR](xref:api-specs-pr) merged.\\r\\n\\r\\nBy design, you are expected to be linked to these articles from your specs PR. As such, these articles assume\\r\\nvery specific context which may not be evident if you read them without having a corresponding PR.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial\",\"content\":\"# Tutorial: Create a new service spec\\nWhen [working on a new REST API definition](xref:api-design) for a new or existing REST API definition, it's best to\\r\\nwork in a topic branch in git and on GitHub so you can later submit a pull request (PR) and iterate on feedback.\\r\\nWhen a team is involved, you'll need a branch everyone can target that can also validate and find errors early.\\r\\n\\r\\nThis tutorial is recommended for anyone working on a new REST API definition, especially as part of a team.\\r\\nIt will guide you through the entire process from creating the branch to merging in into main.\"}]", "inputs.latency": 109.70395302772522, "inputs.response_length": 1494, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://eng.ms/docs/products/azure-developer-experience/onboard/access", "https://eng.ms/docs/products/azure-developer-experience/develop/supporting-sdk-customers/codeowners"], "inputs.testcase": "Permission to merge to RPSaaSMaster", "outputs.similarity.similarity": 3.0, "outputs.similarity.gpt_similarity": 3.0, "outputs.similarity.similarity_result": "fail", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1236, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1237, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Permission to merge to RPSaaSMaster\\\\n\\\\nquestion: Hi\\\\nGeneral\\\\n,\\\\nDue to recent team reorganization I am now in charge of my team and I need to get permission to merge changes to RPSaaSMaster, e.g. I need to merge this PR - Small fix for Dsts Sci Groups by Alessar \\\\u00b7 Pull Request #24977 \\\\u00b7 Azure/azure-rest-api-specs-pr\\\\nCould you please help me with that?\\\\nThank you\\\", \\\"response\\\": \\\"To obtain permission to merge changes into the RPSaaSMaster branch of the Azure/azure-rest-api-specs-pr repository, you must first ensure you have write access to the repository. Write access is granted through membership in the appropriate Azure GitHub organization and the azure-sdk-partners team. Here\\\\u2019s what you need to do:\\\\n\\\\n1. Request to join the Azure SDK Partners group at https://aka.ms/azsdk/join/azuresdkpartners and have your manager approve your request. Once approved, you\\\\u2019ll be automatically added to the azure-sdk-partners GitHub team, which gives you write access to all Azure SDK-related repositories.\\\\n2. Write access will allow you to merge to the 'main' branch and protected branches such as RPSaaSMaster, but you still need CODEOWNERS approval for your PRs. Ensure you have all required approvals before merging.\\\\n3. If you have recently taken on responsibility for your team due to reorganization, you may also need to update the CODEOWNERS file to reflect your new role so you are recognized as an approver for relevant files and folders.\\\\n4. After joining the appropriate teams and updating CODEOWNERS (if necessary), you will have the permissions needed to merge your PRs (e.g., PR #24977) to RPSaaSMaster, as long as all required CI checks and approvals are met.\\\\n\\\\nPlease follow these steps to get the necessary access. If you encounter any issues with the process or require additional assistance, refer to the official onboarding and access documentation provided below.\\\", \\\"ground_truth\\\": \\\"https://aka.ms/azsdk/access\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"}, {"inputs.query": "title: MSWB API spec removal\n\nquestion: The Azure Modeling and Simulation Workbench (MSWB) preview service has been retired, so I'm trying to remove its related API specs from the REST API specs repository.\nPR Deleting 5 API specs for the deprecated MSWB service - RPSaaSDev by yochu-msft · Pull Request #2508… targets RPSaaSDev to delete 5 API specs.\nI want to move forward with merging this PR without resolving the Swagger LintDiff failure since the specs are being removed.\n'Next Steps to Merge' says \"If you still want to proceed merging this PR without addressing the above failures, refer to step 4 in the PR workflow diagram.\" but 'PR workflow diagram' step 4 loops back that \"Follow the instructions in the Next Steps to Merge comment.\" How should I merge the PR without fixing the failure?\ncc Mick Zaffke", "inputs.ground_truth": "PRs to RPSaaSDev have no required checks, so you can merge this as-is.\nIf you need to remove this spec from another branch like public/main or private/RPSaaSMaster, you will need more approvals.", "inputs.response": "You can proceed to merge your PR deleting the MSWB API specs—even if the Swagger LintDiff check is failing—because Azure REST API guidelines specifically allow breaking changes when removing retired preview APIs. The documented process is:\n\n1. Open a PR deleting the preview specs (TypeSpec sources, example sources, generated swagger/examples, and remove tags from readme.md).\n2. The PR should fail the Swagger BreakingChange check, but it's expected and allowed for API deprecation/removal. All other checks should pass.\n3. Request approval for the breaking change using the standard process:\n   - Submit for approval at https://aka.ms/brch\n   - Email azbreakchangereview@microsoft.com\n\nOnce you receive approval for the breaking change, you can merge the PR regardless of the LintDiff failure. This workflow is supported by the Azure REST API specs wiki. The loop in the workflow diagram is intentional: it requires explicit breaking change approval before merging. You do NOT need to fix the LintDiff failure for removed APIs; you only need the breaking change review approval.\n\nIn summary:\n- Get breaking change approval via the official process\n- Merge the PR once approval is granted, ignoring the LintDiff failure for the deleted specs", "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"Create a PR against main\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\\n\\n# Create a PR against main\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nWhen you're ready for a final review, it's time to create a pull request (PR) from your release branch you created\\r\\noriginally to the `main` branch on [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n* :warning: Do not merge `main` or other release branches unless you know there are changes required.\\r\\n* :white_check_mark: Rebase on `main` if changes are required in a separate topic branch.\\n\\n## Clean PR against main\\n\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\\n\\n## Update your branch with changes from main\\n\\nIf you know there are other changes in the `main` branch or that other services have updated shared files in `main`\\r\\nalready and you need to pick up changes before merging, we recommend you take a merge from main. This is particularly interesting\\r\\nfor common infrastructure changes that are committed in the repo (i.e. github actions, tools, etc). Depending on how old your\\r\\nbranch is some of the pull request checks may not correctly function without taking a merge from main. \\r\\n\\r\\nIf you are working in a non-protected branch you can do a `git merge main` like you would normally do a merge and then push\\r\\nyour changes to your remote branch. However, if you are working in a branch with branch protection enabled (i.e. `release-*`) then\\r\\nyou will need to make a pull request to your branch with the merge. Depending on how out-of-date your branch is from `main` your \\r\\nmerge may have a lot of unwanted and unnecessary changes and the checks not pass. In such cases see below on how to [update the infrastructure](#updating-only-the-infrastructure-changes-from-main).\\n\\n### Updating only the infrastructure changes from main\\n\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\\n\\n## Next steps\\n\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# design#api-specs-pr#api-specs-pr.md\\n\\n| Short Link: | [aka.ms/azsdk/specreview](https://aka.ms/azsdk/specreview) |\\r\\n|--|--|\\n\\n# Create a pull request with your Azure REST API spec update\\n\\nThis article explains how to create a pull request (PR) in the [Azure REST API specification repositories](xref:api-repos).\\r\\nSuch PR is a part of the [release plan](xref:release-plan).\\n\\n## Before you begin\\n\\nEnsure that:\\r\\n\\r\\n- You have onboarded to Azure SDK team processes by following our [onboarding process](xref:onboard).\\r\\n- You have [access](xref:access) to the GitHub repositories and respective Azure open source organization.\\r\\n- You understand the conventions for the [Azure REST API specs GitHub repositories](xref:api-repos).\\r\\n- You have reviewed and validated your REST API spec updates within your team, using a development branch in one of\\r\\n  the specs repos.\\r\\n- You are ready to release the features described in your REST API spec updates in a private preview, public preview,\\r\\n  or GA release.\\r\\n\\r\\n\\u003e[!TIP]\\r\\n\\u003e We are piloting our new AzSDK tools MCP server which includes the ability to generate the SDKs and\\r\\n\\u003e create a draft pull request in the respective language repository. Refer to [AzSDK tools MCP server](xref:azsdk-tools-mcp)\\r\\n\\u003e for instructions on how to install it and use it.\\n\\n## Create a PR against a specs repo\\n\\n\\u003e [!TIP]\\r\\n\\u003e If you have an existing PR in the private repo and you want to move it to the public repo, refer to [this guide](xref:pr-move-private-to-public).\\r\\n\\r\\nWhen you are ready to submit your REST API spec updates for review, you must create a pull request (PR) in either the  \\r\\n[public or private specs repository](xref:api-repos). When creating the PR, you should select either the\\r\\n**Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API spec updates you are\\r\\nsubmitting.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e The PR template and comments added by the PR automation will guide you through the process of getting your PR reviewed,\\r\\napproved, and merged.\\n\\n## Get your PR merged\\n\\n| Short Link: | [aka.ms/azsdk/specreview/merge](https://aka.ms/azsdk/specreview/merge) |\\r\\n|-|-|\\r\\n\\r\\nTo get your PR merged:\\r\\n\\r\\n1. Ensure the `Next Steps to Merge` comment and `Automated merging requirements met` check are green. \\r\\n1. Ensure at least one person has approved your PR. Generally another person from your team that has [write access] to the repo.\\r\\n1. Ensure all required checks are passing and at least investigate to understand any other non-required checks that may be failing. \\r\\n1. Once all required checks are green and any other issues understood you can merge the PR yourself as long as you have [write access] to the repo.\\r\\n1. If your PR is targeting public `main` you will need to first apply the `PublishToCustomers` label to acknowledge you understand this \\r\\n   will cause your spec to be published so customers can consume it.\\r\\n1. If your PR is targeting private repo `main` branch, it **cannot** be merged.\\r\\n   Instead, you can publish your changes to customers by following the guide at [aka.ms/azsdk/move-pr].\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"Table of Contents\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# Swagger-LintDiff.md\\n\\n# Table of Contents\\n\\n- [Running Locally](#running-locally)\\r\\n- [Adding Scoped Suppressions](#adding-scoped-suppressions)\\r\\n- [TypeSpec](#typespec)\\n\\n# Running Locally\\n\\nhttps://github.com/Azure/azure-openapi-validator/wiki#usage\\n\\n# Adding Scoped Suppressions\\n\\nWhen adding suppressions for LintDiff (https://github.com/Azure/autorest/blob/main/docs/generate/suppress-warnings.md), it's recommened to use a `where` clause to scope the suppression to one instance of the error  How to find the JSON path to use for the suppression.\\r\\n1. In the raw log for the \\\"LintDiff\\\" step of the \\\"LintDiff\\\" check, find the line containing the JSON object representing your error.  For example:\\r\\n```\\r\\n{\\\"pluginName\\\":\\\"spectral\\\",\\\"extensionName\\\":\\\"@microsoft.azure/openapi-validator\\\",\\\"level\\\":\\\"error\\\",\\\"message\\\":\\\"Properties of a PATCH request body must not be required, property:endpointType.\\\",\\\"code\\\":\\\"PatchBodyParametersSchema\\\",\\\"details\\\":{\\\"jsonpath\\\":[\\\"paths\\\",\\\"/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}\\\",\\\"patch\\\",\\\"parameters\\\",\\\"2\\\",\\\"schema\\\",\\\"properties\\\",\\\"deadLetterDestination\\\"],\\\"validationCategory\\\":\\\"\\\",\\\"providerNamespace\\\":false,\\\"resourceType\\\":false,\\\"rpcGuidelineCode\\\":\\\"RPC-Patch-V1-10\\\",\\\"range\\\":{\\\"start\\\":{\\\"line\\\":1,\\\"column\\\":0},\\\"end\\\":{\\\"line\\\":1,\\\"column\\\":0}}},\\\"source\\\":[{\\\"document\\\":\\\"file:///mnt/vss/_work/1/azure-rest-api-specs/specification/eventgrid/resource-manager/Microsoft.EventGrid/stable/2025-02-15/EventGrid.json\\\",\\\"position\\\":{\\\"line\\\":2908,\\\"column\\\":13}}]}\\r\\n```\\r\\n2. Paste into VSCode (or another editor) to format for readability.  We are focused on the `jsonpath` property.\\r\\n```\\r\\n{\\r\\n    \\\"pluginName\\\": \\\"spectral\\\",\\r\\n    \\\"extensionName\\\": \\\"@microsoft.azure/openapi-validator\\\",\\r\\n    \\\"level\\\": \\\"error\\\",\\r\\n    \\\"message\\\": \\\"Properties of a PATCH request body must not be required, property:endpointType.\\\",\\r\\n    \\\"code\\\": \\\"PatchBodyParametersSchema\\\",\\r\\n    \\\"details\\\": {\\r\\n        \\\"jsonpath\\\": [\\r\\n            \\\"paths\\\",\\r\\n            \\\"/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}\\\",\\r\\n            \\\"patch\\\",\\r\\n            \\\"parameters\\\",\\r\\n            \\\"2\\\",\\r\\n            \\\"schema\\\",\\r\\n            \\\"properties\\\",\\r\\n            \\\"deadLetterDestination\\\"\\r\\n        ],\\r\\n        ...\\r\\n    },\\r\\n    \\\"source\\\": [\\r\\n        {\\r\\n            \\\"documen\\n\\nrequest body must not be required, property:endpointType.\\\",\\r\\n    \\\"code\\\": \\\"PatchBodyParametersSchema\\\",\\r\\n    \\\"details\\\": {\\r\\n        \\\"jsonpath\\\": [\\r\\n            \\\"paths\\\",\\r\\n            \\\"/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}\\\",\\r\\n            \\\"patch\\\",\\r\\n            \\\"parameters\\\",\\r\\n            \\\"2\\\",\\r\\n            \\\"schema\\\",\\r\\n            \\\"properties\\\",\\r\\n            \\\"deadLetterDestination\\\"\\r\\n        ],\\r\\n        ...\\r\\n    },\\r\\n    \\\"source\\\": [\\r\\n        {\\r\\n            \\\"document\\\": \\\"file:///mnt/vss/_work/1/azure-rest-api-specs/specification/eventgrid/resource-manager/Microsoft.EventGrid/stable/2025-02-15/EventGrid.json\\\",\\r\\n            \\\"position\\\": {\\r\\n                \\\"line\\\": 2908,\\r\\n                \\\"column\\\": 13\\r\\n            }\\r\\n        }\\r\\n    ]\\r\\n}\\r\\n```\\r\\n3. Convert the `jsonpath` array to a string, and add to your suppression:\\r\\n```\\r\\n  - code: PatchBodyParametersSchema\\r\\n    from: EventGrid.json\\r\\n    where: $.paths[\\\"/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}\\\"].patch.parameters[2].schema.properties.deadLetterDestination\\r\\n```\\n\\n# TypeSpec\\n\\nCheck `Swagger LintDiff` may fail for the OpenAPI generated from TypeSpec, even if there are no warnings or errors reported from the TypeSpec compiler.  Causes include bugs in the TypeSpec OpenAPI emitter, bugs in LintDiff rules, incompatibilities between TypeSpec and LintDiff, or checks duplicated in TypeSpec and LintDiff.\\r\\nWe are working to address the root causes (where possible).  Until then, we recommend you [suppress](https://aka.ms/pr-suppressions) these LintDiff errors, using a \\\"permanent suppression\\\" with a descriptive \\\"reason\\\".\\n\\n## `AvoidAdditionalProperties`\\n\\nThe use of `Record\\u003cunknown\\u003e` in TypeSpec is discouraged, and there is a TypeSpec lint rule to enforce this.  If you still need to use `Record\\u003cunknown\\u003e`, the OpenAPI spec generated will cause many LintDiff errors of types `AvoidAdditionalProperties` and `PropertiesTypeObjectNoDefinition`.  You will need to suppress both the TypeSpec violation (in TypeSpec source code) and the LintDiff violations.\\n\\n## `AvoidAnonymousParameter`\\n\\n### data-plane\\n\\nData-plane specs can suppress violations of this rule, since it only exists for the benefit of SDKs generated from swagger, and data-plane SDKs are generated directly from TypeSpec.  Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\\n\\n### resource-manager\\n\\nAs an exception to the previous note, resource-manager specs **may** be able to suppress `AvoidAnonymousTypes`, but only if the error is inside a 202 response from a long-running operation (LRO).  It is known that SDKs do not need to generate type names for such responses.\\n\\n## `AvoidAnonymousTypes`\\n\\nData-plane specs can suppress violations of this rule, since it only exists for the benefit of SDKs generated from swagger, and data-plane SDKs are generated directly from TypeSpec.  Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\\n\\n### `LongRunningResourceAction`\\n\\nThere is a known issue where `LongRunningResourceAction` in TypeSpec, generates swagger that causes `AvoidAnonymousTypes`.  These errors should be suppressed until the root cause is fixed.  https://github.com/Azure/typespec-azure-pr/issues/3349\\n\\n## `EvenSegmentedPathForPutOperation`\\n\\nIf `EvenSegmentedPathForPutOperation` is failing for OpenAPI generated from TypeSpec using `@singleton` (OpenAPI path ends with `/default`), we believe this is a false positive: https://github.com/Azure/azure-openapi-validator/issues/646\\n\\n## `IntegerTypeMustHaveFormat`\\n\\nData-plane specs can suppress violations of this rule, since it only exists for the benefit of SDKs generated from swagger, and data-plane SDKs are generated directly from TypeSpec.  Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\\n\\n## `PatchBodyParameterSchema`\\n\\nThe root cause is a bug in typespec-azure:\\r\\nhttps://github.com/Azure/typespec-azure/issues/383.\\r\\nPlease see the issue above for the suggested workaround and apply it directly to the spec TypeSpec sources.  The LintDiff error should **not** be ignored or suppressed.\\n\\n## `PatchPropertiesCorrespondToPutProperties`\\n\\nWe believe this is a false positive: https://github.com/Azure/azure-openapi-validator/issues/642\\n\\n## `PropertiesTypeObjectNoDefinition`\\n\\nThe use of `Record\\u003cunknown\\u003e` in TypeSpec is discouraged, and there is a TypeSpec lint rule to enforce this.  If you still need to use `Record\\u003cunknown\\u003e`, the OpenAPI spec generated will cause many LintDiff errors of types `AvoidAdditionalProperties` and `PropertiesTypeObjectNoDefinition`.  You will need to suppress both the TypeSpec violation (in TypeSpec source code) and the LintDiff violations.\\n\\n## `ProvisioningStateMustBeReadOnly`\\n\\nThe root cause is a limitation in how `azure-openapi-validator` and `oav` handle `$ref` siblings:\\r\\n- https://github.com/Azure/azure-openapi-validator/issues/637\\r\\n- https://github.com/Azure/oav/issues/848\\r\\nThe recommended workaround is to add `use-read-only-status-schema: true` to your `tspconfig.yaml`.\\n\\n## `RequestBodyMustExistForPutPatch`\\n\\nWe believe this is a false positive: https://github.com/Azure/azure-openapi-validator/issues/641\\n\\n## `ResourceNameRestriction`\\n\\nWhether `ResourceNameRestriction` should be applied to enums is an open question:\\r\\nhttps://github.com/Azure/azure-openapi-validator/issues/501\\r\\nhttps://github.com/Azure/azure-openapi-validator/pull/714\\r\\nUntil this is resolved, suppress the errors and discuss with your ARM reviewer.\\n\\n## `XmsEnumValidation`\\n\\nTypeSpec using `OAuth2Auth` may generate the following OpenAPI:\\r\\n``` yaml\\r\\n\\\"type\\\": {\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"description\\\": \\\"OAuth2 authentication\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"oauth2\\\"\\r\\n  ]\\r\\n},\\r\\n```\\r\\n\\r\\nWhich causes error `XmsEnumValidation`.  The recommended workaround is to add `omit-unreachable-types: true` to your `tspconfig.yaml`.\\r\\n\\r\\n## `XmsPageableForListCalls`\\r\\nIf `XmsPageableForListCalls` are failing for OpenAPI generated from TypeSpec using `@singleton` (OpenAPI path ends with `/default`), we believe this is a false positive: https://github.com/Azure/azure-openapi-validator/issues/646\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"troubleshoot#status-read-only-error.md\",\"document_title\":\"`ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error\",\"content\":\"# troubleshoot#status-read-only-error.md\\n\\n# `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\\n\\nWhen trying to check in an ARM specification to the `azure-rest-api-specs` repository, your specification\\r\\nshows violations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\\n\\n## Symptoms\\n\\nIn the `Swagger LintDiff` or `Swagger(RPaaS) LintDiff` checks, your specification shows one or more\\r\\nviolations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\\n\\n## Cause\\n\\nThe LintDiff swagger scripts use an old validation mechanism that does not detect `readOnly` properties, but requires the\\r\\ntype schema referenced by the properties to be `readOnly` instead.\\n\\n## Workaround\\n\\nUntil this validation is fixed, you can configure the `@azure-tools/typespec-autorest` emitter in `tspConfig.yaml`\\r\\nto always output any `ProvisioningState` schema as readOnly, using the `read-only-status-schema` option. This\\r\\nresolves the LintDiff violation. Note that if you use the scaffolding template for `ARM`, this configuration is\\r\\nenabled automatically.\\r\\n\\r\\n```diff lang=yaml title=tspconfig.yaml\\r\\nemit:\\r\\n  - \\\"@azure-tools/typespec-autorest\\\"\\r\\noptions:\\r\\n  \\\"@azure-tools/typespec-autorest\\\":\\r\\n+    use-read-only-status-schema: true\\r\\n```\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#azure-portal#default-experiences.md\",\"document_title\":\"Generating experiences in Azure Portal with TypeSpec\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/azure-portal/default-experiences\",\"content\":\"# howtos#azure-portal#default-experiences.md\\n\\n# Generating experiences in Azure Portal with TypeSpec\\n\\nGo to the [TypeSpec guide](https://eng.ms/docs/products/azure-portal-framework-ibizafx/declarative/typespec) to learn how to customize your Azure Portal experience, generated by default for your ARM resource type. Azure Resource Providers can apply TypeSpec decorators to generate and brand Azure Portal experiences.\\r\\n\\r\\n![ts6 (1)](https://github.com/user-attachments/assets/ba080602-0edb-4317-bcae-7dffce687a80)\\n\\n## About Default Experiences\\n\\nparams)      |\\r\\n| \\u003e Tabs:                       | Get Started template, Properties, Monitoring, Recommendations                     |\\r\\n| \\u003e Essentials                  | _Enable essentials control_                                                       |\\r\\n| **Resource Menu**             |                                                                                   |\\r\\n| \\u003e Standard Framework Options: | Support + Troubleshooting, Activity Log, IAM, Tags, Monitoring, Diagnostics, etc. |\\r\\n| \\u003e Properties view             | _Enable properties view for resource_                                             |\\r\\n| \\u003e CLI / PS view               | _Enable CLI / PS view for resource_                                               |\\r\\n| \\u003e Child Browse views          | _View child resources in menu_                                                    |\\r\\n\\r\\n![alt-text](https://github.com/Azure/portaldocs/raw/main/portal-sdk/media/top-extensions-autogeneration/GeneratedOverviewTabs.jpg \\\"Overview blade breakdown\\\")\\n\\nAzure Portal generates end-to-end experiences automatically, providing Resource Providers with immediate UX in Azure Portal for their resource types. This pipeline runs offline and generates views and an asset for your resource type. These generated experiences done by Azure Portal based on resource type metadata are called \\\"Default Experiences\\\". Leveraging TypeSpec affords Resource Providers with an easy, declarative way of branding and promoting these experiences, as the generated default experience is hidden by default. [Learn more](https://eng.ms/docs/products/azure-portal-framework-ibizafx/declarative/generated)\\r\\n\\r\\n#### Default experiences include:\\r\\n\\r\\n| **Browse + Management**       |                                                                                   |\\r\\n| ----------------------------- | --------------------------------------------------------------------------------- |\\r\\n| \\u003e Global Search               | _Discover resource instances and browse view through search_                      |\\r\\n| \\u003e All Resources               | _Discover resource instances in All Resources and launch Overview UX_             |\\r\\n| \\u003e Browse                      | _Browse and manage resource instances in standard browse view_                    |\\r\\n| **Overview UX**               |                                                                                   |\\r\\n| \\u003e Commands:                   | Refresh, Delete, Create, Open in mobile, CMD by REST-API-SPEC (w/out params)      |\\r\\n| \\u003e Tabs:                       | Get Started template, Properties, Monitoring, Recommendations                     |\\r\\n| \\u003e Essentials                  | _Enable essentials control_                                                       |\\r\\n| **Resource Menu**             |                                                                                   |\\r\\n| \\u003e Standard Framework Options: | Support + Troubleshooting, Activity Log, IAM, Tags, Monitoring, Diagnostics, etc. |\\r\\n|\\n\\n## Promoting generated experiences to production\\n\\nSee [Promoting Default Experiences](https://eng.ms/docs/products/azure-portal-framework-ibizafx/declarative/promotion) to learn how to promote your default generated Portal experience using\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_19.md\",\"document_title\":\"Swagger LintDiff validation for certain models\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_19.md\\n\\n# Swagger LintDiff validation for certain models\\n\\n## question\\n\\nI have the below PR [adding shared limit typespec by parthshah2305 · Pull Request #24115 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/24115) where some of the LintDiff validations are failing with the exception \\r\\n``` \\r\\n  Violation: file:///home/runner/work/azure-rest-api-specs-pr/azure-rest-api-specs-pr/after/specification/limit/resource-manager/Microsoft.Limit/Limit/stable/2025-08-15/Limit.json:578\\r\\n    Level: error\\r\\n    Code: RequiredPropertiesMissingInResourceModel\\r\\n    Message: Model definition 'SharingDetail' must have the properties 'name', 'id' and 'type' in its hierarchy and these properties must be marked as readonly.\\r\\n```\\r\\n\\r\\nThis particular model is defined as follows - \\r\\n\\r\\n```\\r\\nmodel SharingDetail {\\r\\n  role: SharingRole;\\r\\n  sharedLimits?: QuotaLimitProperties[];\\r\\n  guestSubscriptions?: string[];\\r\\n  host?: string;\\r\\n}\\r\\n```\\r\\n \\r\\nIs it possible have a suppression for this validation? If so, how?\\r\\n\\r\\n## answer\\r\\nthe link for lintdiff suppressions:\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff#adding-scoped-suppressions\\r\\n \\r\\nyou probably want to fix this in your spec, not suppress the error\\r\\n \\r\\nYou need to fix check \\\"TypeSpec Validation\\\" in your PR, before other check results will even be valid.  This is documented in the \\\"next steps to merge\\\" comment in your PR.\\r\\n\\r\\n# Model validations are failing although am referring from common-types\\r\\n\\r\\n## question \\r\\n1. I have reused the model Private endpoint connection resource from the commonTypes/v5. However the model validation is failing. In example PrivateEndpointConnections_ListByCodeSigningAccount, its giving the below errors. In the PrivateEndpointConnection tsp file, I have kept the resource name as is and havent renamed, would this cause any issue? Would there be any problem while updating it from Rpaas? Have observed some RPs have leveraged from commonTypes but renamed as PrivateEndpointConnectionResource in their tsp file.\\n\\nendpoint connection resource from the commonTypes/v5. However the model validation is failing. In example PrivateEndpointConnections_ListByCodeSigningAccount, its giving the below errors. In the PrivateEndpointConnection tsp file, I have kept the resource name as is and havent renamed, would this cause any issue? Would there be any problem while updating it from Rpaas? Have observed some RPs have leveraged from commonTypes but renamed as PrivateEndpointConnectionResource in their tsp file.\\r\\n \\r\\n2. Avocado error: I have removed an API revokeCertificate and added a new api revokeCertificates which takes an array. \\r\\n \\r\\nHow do I fix both errors?\\r\\n \\r\\n [Added private endpoint connection, bulk revocation and c2pa certificate type by amritas · Pull Requ…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24553)\\r\\n \\r\\nModel validation Error - Additional properties not allowed: groupIds, privateLinkServiceConnectionState,privateEndpoint,provisioningState\\r\\n \\r\\nPEC contract - \\r\\n```\\r\\nnamespace Microsoft.CodeSigning;\\r\\n\\r\\n@doc(\\\"Private endpoint connection resource.\\\")\\r\\n@added(Versions.v2025_09_15_preview)\\r\\n@parentResource(CodeSigningAccount)\\r\\nmodel PrivateEndpointConnection\\r\\n    is ProxyResource\\u003cPrivateEndpointConnectionProperties\\u003e {\\r\\n    ...PrivateEndpointConnectionParameter;\\r\\n}\\r\\n\\r\\n@added(Versions.v2025_09_15_preview)\\r\\n@armResourceOperations(PrivateEndpointConnection)\\r\\ninterface PrivateEndpointConnections {\\r\\n  /** Get a specific private connection */\\r\\n  get is ArmResourceRead\\u003cPrivateEndpointConnection\\u003e;\\r\\n\\r\\n  /** Create a Private endpoint connection */\\r\\n  create is ArmResourceCreateOrReplaceAsync\\u003cPrivateEndpointConnection\\u003e;\\r\\n\\r\\n  /** Delete the private endpoint connection */\\r\\n  delete is ArmResourceDeleteWithoutOkAsync\\u003cPrivateEndpointConnection\\u003e;\\r\\n\\r\\n  /** List private endpoint connections on the given resource */\\r\\n  list is ArmResourceListByParent\\u003cPrivateEndpointConnection\\u003e;\\r\\n}\\r\\n\\r\\n@added(Versions.v2025_09_15_preview)\\r\\n@parentResource(CodeSigningAccount)\\n\\n/** Create a Private endpoint connection */\\r\\n  create is ArmResourceCreateOrReplaceAsync\\u003cPrivateEndpointConnection\\u003e;\\r\\n\\r\\n  /** Delete the private endpoint connection */\\r\\n  delete is ArmResourceDeleteWithoutOkAsync\\u003cPrivateEndpointConnection\\u003e;\\r\\n\\r\\n  /** List private endpoint connections on the given resource */\\r\\n  list is ArmResourceListByParent\\u003cPrivateEndpointConnection\\u003e;\\r\\n}\\r\\n\\r\\n@added(Versions.v2025_09_15_preview)\\r\\n@parentResource(CodeSigningAccount)\\r\\nmodel PrivateLink is ProxyResource\\u003cPrivateLinkResourceProperties\\u003e {\\r\\n  ...PrivateLinkResourceParameter;\\r\\n}\\r\\n```\\r\\n updated the operationId and it worked. Let me know if the PrivateEndpointConnection should be a customized name or can retain same name as in commonTypes?\\r\\n Would this be guided by the reviewer?\\r\\n\\r\\n## answer\\r\\nLooking at your PR, it seems that the avocado error is the only remaining one - this is just reporting that you have removed an API.  If you do not need to continue supporting the older preview, you might consider removing it,  otherwise, this is an error you can safely suppress (https://aka.ms/ci-fix is a great link to remember, as it has links to all kinds of useful info about ci errors, including a link to the suppression guides).\\r\\n \\r\\nFor PrivateEndpointConnections, RPs have done both, as the name of the private endpoint connection type doesn't really matter to the API, however, there is a new template that greatly simplifies adding private endpoint connection operations to any resourc,e see: \\r\\n[typespec-azure/packages/samples/specs/resource-manager/resource-types/private-endpoints/private-end…](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/resource-types/private-endpoints/private-endpoints.tsp#L69-L94)\\r\\n```\\r\\nmodel PrivateEndpointConnection is PrivateEndpointConnectionResource;\\r\\nalias PrivateEndpointOperations = PrivateEndpoints\\u003cPrivateEndpointConnection\\u003e;\\r\\n\\r\\n@armResourceOperations\\r\\ninterface Employees {\\n\\noperations to any resourc,e see: \\r\\n[typespec-azure/packages/samples/specs/resource-manager/resource-types/private-endpoints/private-end…](https://github.com/Azure/typespec-azure/blob/main/packages/samples/specs/resource-manager/resource-types/private-endpoints/private-endpoints.tsp#L69-L94)\\r\\n```\\r\\nmodel PrivateEndpointConnection is PrivateEndpointConnectionResource;\\r\\nalias PrivateEndpointOperations = PrivateEndpoints\\u003cPrivateEndpointConnection\\u003e;\\r\\n\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n  update is ArmCustomPatchSync\\u003c\\r\\n    Employee,\\r\\n    Azure.ResourceManager.Foundations.ResourceUpdateModel\\u003cEmployee, EmployeeProperties\\u003e\\r\\n  \\u003e;\\r\\n  delete is ArmResourceDeleteSync\\u003cEmployee\\u003e;\\r\\n  listByResourceGroup is ArmResourceListByParent\\u003cEmployee\\u003e;\\r\\n  listBySubscription is ArmListBySubscription\\u003cEmployee\\u003e;\\r\\n  /** A sample resource action that move employee to different location */\\r\\n  move is ArmResourceActionSync\\u003cEmployee, MoveRequest, MoveResponse\\u003e;\\r\\n\\r\\n  /** A sample HEAD operation to check resource existence */\\r\\n  checkExistence is ArmResourceCheckExistence\\u003cEmployee\\u003e;\\r\\n\\r\\n  getPrivateEndpointConnection is PrivateEndpointOperations.Read\\u003cEmployee\\u003e;\\r\\n  createOrUpdatePrivateEndpointConnection is PrivateEndpointOperations.CreateOrUpdateAsync\\u003cEmployee\\u003e;\\r\\n  updatePrivateEndpointConnection is PrivateEndpointOperations.CustomPatchAsync\\u003cEmployee\\u003e;\\r\\n  deletePrivateEndpointConnection is PrivateEndpointOperations.DeleteAsync\\u003cEmployee\\u003e;\\r\\n  listPrivateEndpointConnections is PrivateEndpointOperations.ListByParent\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\r\\nSee here for the Avocado error.  We need to find a better way to handle intentionally removed APIs in Avocado.\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#known-issues\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Swagger LintDiff failed\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Swagger LintDiff failed\\n\\n## question\\n\\nI have many lintDiff failures in this [PR](https://github.com/Azure/azure-rest-api-specs/pull/34318). The interesting thing is, the place I'm violating the rules, its swagger is the same as before. Why these violations are not reported before?\\n\\n## answer\\n\\nThe LintDiff errors in your PR are not necessarily new violations. Many of them already existed in the main branch, but previously, CI failures weren’t blocking, so these issues were effectively allowed to persist unnoticed.\\r\\n\\r\\nNow, because your PR is part of a TypeSpec (TSP) migration, the generated Swagger includes many differences—over 3,000 diffs in total—due to normalization by the AutoRest emitter. These changes are functionally equivalent but not textually identical, which makes it hard for the LintDiff auto-baselining algorithm to recognize unchanged areas. As a result, you’re seeing errors flagged as new, even if the same issues existed in main.\\r\\n\\r\\nGiven the unreliability of the auto-baselining mechanism, we recommend not depending on it. Instead, all LintDiff errors—regardless of whether they are newly introduced or pre-existing—should be explicitly suppressed in the `readme.md` file. This is the mitigation approach we advise for all PRs, especially TSP migrations.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_03.md\",\"document_title\":\"Need help with PR checks\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_03.md\\n\\n# Need help with PR checks\\n\\n## question\\n\\n`Swagger LintDiff`: Fails with `AvoidAnonymousTypes`, [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267/checks?check_run_id=44598262474).\\r\\nThe `Swagger LintDiff` seems to be related with this question: [Emilio D'Angelo: Asynchronous resource delete | Azure SDK \\u003e TypeSpec Discussion | Microsoft Teams](https://teams.microsoft.com/l/message/19:906c1efbbec54dc8949ac736633e6bdf@thread.skype/1750334021292?tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\u0026groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026parentMessageId=1750334021292\\u0026teamName=Azure%20SDK\\u0026channelName=TypeSpec%20Discussion\\u0026createdTime=1750334021292).\\r\\nThe error appears when using this pattern:\\r\\n```\\r\\n@resource(\\\"operations\\\")\\r\\n@added(Versions.v2025_09_30_Preview)\\r\\n@doc(\\\"An AI Workflow delete operation.\\\")\\r\\nmodel AiWorkflowOperationStatus is Foundations.OperationStatus\\u003cnever\\u003e;\\r\\n\\r\\n@tag(\\\"AI Workflows\\\")\\r\\n@route(\\\"ai\\\")\\r\\n@added(Versions.v2025_09_30_Preview)\\r\\ninterface AiWorkflowOperations {\\r\\n  get is StandardOperations.ResourceRead\\u003cAiWorkflowOperationStatus\\u003e;\\r\\n}\\r\\n\\r\\n@tag(\\\"AI Workflows\\\")\\r\\n@route(\\\"ai\\\")\\r\\n@added(Versions.v2025_09_30_Preview)\\r\\ninterface AiWorkflows {\\r\\n  ...\\r\\n\\r\\n  @pollingOperation(AiWorkflowOperations.get)\\r\\n  delete is StandardOperations.LongRunningResourceDelete\\u003cAiWorkflow\\u003e;\\r\\n\\r\\n  ...\\r\\n}\\r\\n```\\n\\nHi, need help with some failures I'm getting when running a PR against `azure-api-specs-pr`. This is the PR: [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267) and I'm getting the following errors when running the PR checks:\\r\\n`private.rest-api-specs-pr`: Failing with the message `the branch is protected`, [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267/checks?check_run_id=44598442126). I assume this is expected since the PR is against the main branch of the private repo.\\r\\n`private.rest-api-specs-pr (BranchProtectionForPrivateRepo)`: Same error as above.\\r\\n`Swagger ModelValidation`: Fails with error `unacceptable kind of an object to dump [object Error]`, [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267/checks?check_run_id=44598262948).\\r\\n`Swagger SemanticValidation`: Failing with `INTERNAL_ERROR`, part of the message is `Must have text between two parameters, missing text after \\\"2x\\\" at safePattern`, [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267/checks?check_run_id=44598263149).\\r\\n`Swagger LintDiff`: Fails with `AvoidAnonymousTypes`, [Microsoft Planetary Computer Pro - AI Workflows by emiliodangelo · Pull Request #23267 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23267/checks?check_run_id=44598262474).\\r\\nThe `Swagger LintDiff` seems to be related with this question: [Emilio D'Angelo: Asynchronous resource delete | Azure SDK \\u003e TypeSpec Discussion |\\n\\n## answer\\n\\nThe issue you're encountering is caused by a regression in the path-to-regexp dependency used by oav. Specifically, patterns like {width}x{height} or {x}/{y}@{scale}x in your API paths are now breaking validation due to stricter parsing rules introduced in path-to-regexp@6.2.1.\\r\\n\\r\\nPreviously, your spec passed validation because older versions of path-to-regexp were more lenient. The recent update introduced security fixes that inadvertently caused this break.\\r\\n\\r\\nTo unblock your PR, we’ve deployed a temporary fix that pins path-to-regexp to an older version. This means your Swagger checks should no longer crash. Meanwhile, we’re working on a permanent solution that doesn’t rely on pinning old code.\\r\\n\\r\\nIf you still need to validate locally, you can manually install the older version and run oav like this:\\r\\n```\\r\\n\\u003cinstall node 20\\u003e\\r\\nmkdir testdirectory\\r\\ncd testdirectory\\r\\nnpm i oav path-to-regexp@6.2.2\\r\\nnpx oav validate-example /path/to/your/openapi.json\\r\\n```\\r\\nAlternatively, you can use validate-spec instead of validate-example if you're checking the spec directly. This workaround has been confirmed to pass for your PR.\\r\\n\\r\\nWe’ve also applied the approved-modelvalidation and approved-semanticvalidation labels to your PR to unblock progress. Just note that if other issues surface later due to this regression, you may need to address them in a follow-up PR.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_26.md\",\"document_title\":\"Is TypeSpec migration complete for folder: recoveryservicesbackup.\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_26.md\\n\\n# Is TypeSpec migration complete for folder: recoveryservicesbackup.\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\nWe had PR in flight: [Adding stable 2025 08 01 for completeness by risraj10 · Pull Request #37381 · Azure/azure-rest-api-…](https://github.com/Azure/azure-rest-api-specs/pull/37381)\\r\\nHowever, I see that TypeSpec migration was done couple of days ago for this folder. \\r\\nI have cancelled the above PR and trying to raise a new PR. However, just running npx tsp compile without any change is giving errors.\\r\\nAnd also it is making unintended change to OpenAPI json file even to existing version. I guess the tsp and OpenAPI json are not in sync.\\r\\nHence, wanted to check if the migration is really complete for this folder.\\n\\n## answer\\n\\nMain typespec validation should always be passing are you sure you are up you are with dependencies locally?\\r\\nMake sure to follow instructions here https://aka.ms/ci-fix\\r\\nJust to reiterate, this is almost always because you need to pull the latest from the target branch into your local clone of the repo, and re-install dependencies at the root.\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Typespec Validation required check\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Typespec Validation required check\\n\\n## question\\n\\n\\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\". Please add \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-fakes\\\". Please add \\\"options.@azure-tools/typespec-go.generate-fakes\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.head-as-boolean\\\". Please add \\\"options.@azure-tools/typespec-go.head-as-boolean\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.inject-spans\\\". Please add \\\"options.@azure-tools/typespec-go.inject-spans\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-python.package-dir\\\". Please add \\\"options.@azure-tools/typespec-python.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-csharp.namespace \\\"Microsoft.Azure.Management.DevTestLabs\\\" does not match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter. Please update the value of \\\"options.@azure-tools/typespec-csharp.namespace\\\" to match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter.\\r\\nPlease see https://aka.ms/azsdk/spec-gen-sdk-config for more info.\\r\\nFor additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.\\r\\n```\\r\\nI have copied the namespace from the autorest readme files that we had before and it was responsible  to generate SDKs. Is it a requirement to update the namespace as suggested given we have already published the SDK before?\\n\\nPR: https://github.com/Azure/azure-rest-api-specs/pull/35346\\r\\nThis PR only has typespec conversion change and no API update. It is currently failing for required check - Typespec validation. When I run the npx tsmv command locally then I see the following error.\\r\\n```\\r\\nExecuting rule: SdkTspConfigValidation\\r\\nValidation on option \\\"options.@azure-tools/typespec-csharp.namespace\\\" in \\\"@azure-tools/typespec-csharp\\\" are failed. However, per @azure-tools/typespec-csharp’s decision, we will treat it as passed.\\r\\n[SdkTspConfigValidation]: validation failed.\\r\\n- Failed to find \\\"parameters.service-dir.default\\\". Please add \\\"parameters.service-dir.default\\\".\\r\\n- The value of options.@azure-tools/typespec-java.package-dir \\\"azure-mgmt-devtestlabs\\\" does not match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.package-dir\\\" to match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\".\\r\\n- The value of options.@azure-tools/typespec-java.namespace \\\"com.microsoft.azure.management.devtestlabs\\\" does not match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.namespace\\\" to match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.service-dir\\\". Please add \\\"options.@azure-tools/typespec-go.service-dir\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.package-dir\\\". Please add \\\"options.@azure-tools/typespec-go.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-go.module \\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\n\\n## answer\\n\\ntypeSpec validation is failing, but not for that reason.  The configuration for c-sharp emitter is a warning only.  The current failure is caused by diffs between the generated swagger included in your PR and the generated swagger when the ci compiles your spec.\\r\\n \\r\\nUsually this indicates that your local dependencies are out of date, and you need to pull the latest into your local branch and re-install at thetop level:\\r\\n \\r\\ngit fetch upstream main\\r\\ngit pull upstream main\\r\\nnpm ci\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_17.md\",\"document_title\":\"Many Swagger ModelValidation Error:　XMS_EXAMPLE_NOTFOUND_ERROR\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_17.md\\n\\n# Many Swagger ModelValidation Error:　XMS_EXAMPLE_NOTFOUND_ERROR\\n\\n## question\\n\\nThis is my [PR](https://github.com/Azure/azure-rest-api-specs/pull/36687). And I got so many Swagger ModelValidation errors : XMS_EXAMPLE_NOTFOUND_ERROR ,  please check the [link](https://github.com/Azure/azure-rest-api-specs/actions/runs/18519995562/job/52777696829?pr=36687).\\r\\n```\\r\\nError reported:\\r\\n\\r\\n{\\r\\n  code: 'XMS_EXAMPLE_NOTFOUND_ERROR',\\r\\n  message: 'x-ms-example not found in Provider_GetAvailableStacks.',\\r\\n  schemaUrl: 'specification/web/resource-manager/Microsoft.Web/AppService/stable/2025-03-01/openapi.json',\\r\\n  exampleUrl: undefined,\\r\\n  schemaPosition: { line: 456, column: 14 },\\r\\n  schemaJsonPath: undefined,\\r\\n  examplePosition: undefined,\\r\\n  exampleJsonPath: undefined,\\r\\n  severity: 0,\\r\\n  source: 'global',\\r\\n  operationId: 'Provider_GetAvailableStacks',\\r\\n  level: '\\\\x1B[31merror\\\\x1B[39m'\\r\\n}\\r\\n...\\r\\n``` \\r\\nActually, there is not any related example in the operation in the origin swagger.  \\r\\nI could find the latest merged [PR](https://github.com/Azure/azure-rest-api-specs/pull/37883)  and it does not have the same problem. \\r\\nThanks for your support.\\n\\n## answer\\n\\nThe errors are indicating that your operations are missing examples. ModelValidation requires an example for each operation, so the next steps are either to add examples or apply a suppression. Since ModelValidation has bugs in suppressions, you can unblock the PR by using the label Approved-ModelValidation, or alternatively, generate the missing examples.\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-08-07.md\",\"document_title\":\"Additional \\\"consumes\\\": [  \\\"text/plain\\\"  ], in operation\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-08-07.md\\n\\n# Additional \\\"consumes\\\": [  \\\"text/plain\\\"  ], in operation\\n\\n## question\\n\\n```\\r\\n\\\"consumes\\\": [\\r\\n    \\\"text/plain\\\"\\r\\n],\\r\\n```\\n\\n## answer\\n\\n```\\r\\n{\\r\\n    \\\"name\\\": \\\"body\\\",\\r\\n    \\\"in\\\": \\\"body\\\",\\r\\n    \\\"schema\\\": {\\r\\n        \\\"$ref\\\": \\\"#/definitions/email\\\"\\r\\n    }\\r\\n}\\r\\n```\\r\\nBecause TypeSpec wants to reproduce this part of the content from the original swagger, but once the parameter in body is a basic type (string, int32, scalar, etc.), it will cause this extra part to appear. The TypeSpec code is as follows\\r\\n```\\r\\n@action(\\\"listConnectedPartnerResources\\\")\\r\\nlist is ArmResourceActionSync\\u003c\\r\\n    NewRelicMonitorResource,\\r\\n    {\\r\\n        /**\\r\\n         * Email Id of the user\\r\\n         */\\r\\n        @bodyRoot\\r\\n        body?: email;\\r\\n    },\\r\\n    ArmResponse\\u003cConnectedPartnerResourcesListResponse\\u003e\\r\\n\\u003e;\\r\\n}\\r\\n```\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-09-12.md\",\"document_title\":\"rename model `KeyEncryptionKeyIdentity` and `KeyEncryptionKeyIdentityType` of common-types\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-09-12.md\\n\\n# rename model `KeyEncryptionKeyIdentity` and `KeyEncryptionKeyIdentityType` of common-types\\n\\n## question\\n\\nHow to rename model `KeyEncryptionKeyIdentity` and `KeyEncryptionKeyIdentityType` of common-types for python?\\n\\n## answer\\n\\nspecification/devcenter/DevCenter.Management/back-compatible.tsp:\\r\\n```diff\\r\\n+ import \\\"@azure-tools/typespec-azure-resource-manager\\\";\\r\\n\\r\\n+ @@clientName(Azure.ResourceManager.CommonTypes.KeyEncryptionKeyIdentity,\\r\\n+   \\\"CustomerManagedKeyEncryptionKeyIdentity\\\",\\r\\n+   \\\"python\\\"\\r\\n+ );\\r\\n+ @@clientName(Azure.ResourceManager.CommonTypes.KeyEncryptionKeyIdentityType,\\r\\n+   \\\"IdentityType\\\",\\r\\n+   \\\"python\\\"\\r\\n+ );\\r\\n```\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-09-05.md\",\"document_title\":\"Extra \\\"TypeSpec.Http.OkResponse\\\" schema in new Swagger\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-09-05.md\\n\\n# Extra \\\"TypeSpec.Http.OkResponse\\\" schema in new Swagger\\n\\n## question\\n\\nNew Swagger contains \\\"TypeSpec.Http.OkResponse\\\" schema\\n\\n## answer\\n\\nIt is typically generated from LRO operation that returns 200 without body.\\r\\n\\r\\nChange the op to e.g.\\r\\n\\r\\n  restoreFiles is ArmResourceActionAsync\\u003c\\r\\n    Snapshot,\\r\\n    SnapshotRestoreFiles,\\r\\n    {\\r\\n      @body body: void;\\r\\n    },\\r\\n    LroHeaders = ArmLroLocationHeader\\u003cFinalResult = void\\u003e \\u0026\\r\\n      Azure.Core.Foundations.RetryAfterHeader\\r\\n  \\u003e;\\r\\n\\r\\nExample https://github.com/Azure/azure-rest-api-specs/pull/36876/commits/78feeb1eaca3a500d3bf2bab68034178f06afa1b\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#VersioningGuidelines.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/VersioningGuidelines.md\",\"content\":\"# Azure Versioning Guidelines\\n## Guidelines\\n**DO** remove retired API versions from the azure-rest-api-specs repo.\\r\\n\\r\\n:white_check_mark: **DO** review any change to service behavior that could disrupt customers with the Azure Breaking Changes review board, even if the change is not part of the API definition.\\r\\n\\r\\nSome examples of behavior changes that must be reviewed are:\\r\\n- Introducing or changing rate limits to be more restrictive than previously\\r\\n- Changing the permissions required to successfully execute an operation\\r\\n\\r\\n:no_entry: **DO NOT** change the behavior of an API version that is available to customers either in public preview or GA.\\r\\nChanges in behavior should always be introduced in a new API version, with prior versions working as before.\\r\\n\\r\\n:no_entry: **DO NOT** introduce breaking changes from a prior GA version just to satisfy ARM or Azure API guidelines.\\r\\n\\r\\nAvoiding breaking changes in a GA API takes precedence over adherence to API guidelines and resolving linter errors.\\r\\n\\r\\n:no_entry: **DO NOT** keep a preview feature in preview for more than 1 year; it must go GA (or be removed) within 1 year after introduction.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Deprecating-Preview-APIs.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs\",\"content\":\"## Process\\n1. Open a PR deleting one (or more) previews.  All of:\\r\\n   1. TypeSpec sources (`*.tsp`)\\r\\n   2. Example sources (examples closest to `*.tsp` files)\\r\\n   3. Generated swaggers and examples (`preview/YYYY-MM-DD-preview/**`)\\r\\n   4. readme.md (remove tags)\\r\\n2. PR should fail check `Swagger BreakingChange`, but pass all other checks.\\r\\n3. Request approval following the normal process for breaking changes\\r\\n   - https://aka.ms/brch\\r\\n   - azbreakchangereview@microsoft.com\"},{\"document_source\":\"typespec_azure_http_specs\",\"document_filename\":\"azure#client-generator-core#client-default-value#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/typespec-azure/blob/main/packages/azure-http-specs/specs/azure/client-generator-core/client-default-value/main.tsp\",\"content\":\"# Usages for Test for `@clientDefaultValue` decorator.\\n## Scenario: Test case 1: `@clientDefaultValue` for model property.\\nThis scenario tests that client default values are correctly applied to model properties.\\r\\n``` typespec\\r\\n@route(\\\"/model-property\\\")\\r\\n@put\\r\\nop putModelProperty(@body body: ModelWithDefaultValues): ModelWithDefaultValues;\\r\\n```\\r\\n\\r\\n## Scenario: Test case 2: `@clientDefaultValue` for operation parameter.\\r\\nThis scenario tests that client default values are correctly applied to operation parameters.\\r\\n```\"},{\"document_source\":\"typespec_azure_http_specs\",\"document_filename\":\"azure#client-generator-core#override#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/typespec-azure/blob/main/packages/azure-http-specs/specs/azure/client-generator-core/override/main.tsp\",\"content\":\"# Usages for Test scenarios for client override behavior.\\n## Scenario: Verify that after `@override` the parameters are reordered correctly in the client method signature.\\n``` typespec\\r\\ninterface ReorderParameters {  \\r\\n    @route(\\\"/reorder/{param2}/{param1}\\\")\\r\\n  @get\\r\\n  reorder(@path param2: string, @path param1: string): void;\\r\\n}\\r\\n```\\r\\n\\r\\n## Scenario: Verify that after `@override` the parameters are grouped correctly to `GroupParametersOptions` in the client method signature.\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#diagnostics.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/diagnostics\",\"content\":\"# Diagnostics\\n## invalid-schema\\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors\",\"content\":\"# Resolving Folder Migration Conflicts: A Guide for PR Authors\\n## The impact to ongoing PRs\\n### After Resolution\\nMake sure to compile the TypeSpec project so that the TypeSpec Validation could pass.\\r\\n\\r\\n1. **Comprehensive validation**:\\r\\n   ```bash\\r\\n   # Run full validation suite\\r\\n   npm ci\\r\\n   npm run lint\\r\\n   npm run validate\\r\\n   \\r\\n   # Test TypeSpec compilation for your service\\r\\n   cd specification/app/data-plane/DynamicSessions/\\r\\n   npx tsp compile .\\r\\n   npx tsp compile . --emit @azure-tools/typespec-autorest\\r\\n   \\r\\n   # Verify generated files match expectations by checking if there's any diff with the OpenAPI json files.\\r\\n   ```\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Requirement.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Requirement\",\"content\":\"# Suppressing Failures\\nIf you need to suppress this check (instead of converting to TypeSpec), add entries to the `suppressions.yaml` for your spec.  Example:\\r\\n\\r\\n```\\r\\n# specification/widget/resource-manager/Microsoft.Widget/Widget/suppressions.yaml\\r\\n- tool: TypeSpecRequirement\\r\\n  paths: \\r\\n    - preview/2022-08-01-preview/**/*.json\\r\\n    - preview/2023-02-01-preview/**/*.json\\r\\n```\\r\\n\\r\\nMore examples: https://github.com/search?q=TypeSpecRequirement+repo%3Aazure%2Fazure-rest-api-specs+path%3A**%2Fsuppressions.yaml\\u0026type=code\"},{\"document_source\":\"typespec_http_specs\",\"document_filename\":\"type#model#inheritance#not-discriminated#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/type/model/inheritance/not-discriminated/main.tsp\",\"content\":\"# Usages for Illustrates not-discriminated inheritance model.\\n## Scenario: Generate and send model.\\n``` typespec\\r\\n@route(\\\"/valid\\\")\\r\\n@post\\r\\nop postValid(@body input: Siamese): NoContentResponse;\\r\\n```\\r\\n\\r\\n## Scenario: Generate and receive model.\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_http_specs\",\"document_filename\":\"payload#xml#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/payload/xml/main.tsp\",\"content\":\"# Usages for Sends and receives bodies in XML format.\\n## Scenario: Response body\\nReturns a response with Content-Type application/xml and a body containing the specified model encoded as XML.\\r\\n``` typespec\\r\\n@doc(\\\"Template for XML operations\\\")\\r\\ninterface XmlOperations\\u003cTModel, TDoc extends valueof string\\u003e {  \\r\\n    @get\\r\\n  get(): {\\r\\n    @header(\\\"content-type\\\") contentType: \\\"application/xml\\\";\\r\\n    @body body: TModel;\\r\\n  };\\r\\n```\\r\\n\\r\\n## Scenario: Request body\\r\\nSends a request with Content-Type application/xml and a body containing the specified model encoded as XML.\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Addressing `BreakingChangeReviewRequired`\\n### `BreakingChange-Approved-Previously`\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"# Convert OpenAPI specs to TypeSpec\\n## Conversion scope\\n- Horizontal conversion: Converting existing Azure OpenAPI specs to TypeSpec should not introduce any changes to the API.\\r\\n- No version revving: No version revving will occur during this process. The focus is solely on converting the existing\\r\\nspecifications to TypeSpec.\\r\\n- SDKs generated for validation only: The SDKs generated from the converted TypeSpec files will be used for validation\\r\\npurposes only. They are not intended for production release.\"}]", "inputs.latency": 165.01478600502014, "inputs.response_length": 1243, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs", "https://github.com/microsoft/api-guidelines/blob/vNext/azure/VersioningGuidelines.md"], "inputs.testcase": "MSWB API spec removal", "outputs.similarity.similarity": 3.0, "outputs.similarity.gpt_similarity": 3.0, "outputs.similarity.similarity_result": "fail", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1303, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1304, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: MSWB API spec removal\\\\n\\\\nquestion: The Azure Modeling and Simulation Workbench (MSWB) preview service has been retired, so I'm trying to remove its related API specs from the REST API specs repository.\\\\nPR Deleting 5 API specs for the deprecated MSWB service - RPSaaSDev by yochu-msft \\\\u00b7 Pull Request #2508\\\\u2026 targets RPSaaSDev to delete 5 API specs.\\\\nI want to move forward with merging this PR without resolving the Swagger LintDiff failure since the specs are being removed.\\\\n'Next Steps to Merge' says \\\\\\\"If you still want to proceed merging this PR without addressing the above failures, refer to step 4 in the PR workflow diagram.\\\\\\\" but 'PR workflow diagram' step 4 loops back that \\\\\\\"Follow the instructions in the Next Steps to Merge comment.\\\\\\\" How should I merge the PR without fixing the failure?\\\\ncc Mick Zaffke\\\", \\\"response\\\": \\\"You can proceed to merge your PR deleting the MSWB API specs\\\\u2014even if the Swagger LintDiff check is failing\\\\u2014because Azure REST API guidelines specifically allow breaking changes when removing retired preview APIs. The documented process is:\\\\n\\\\n1. Open a PR deleting the preview specs (TypeSpec sources, example sources, generated swagger/examples, and remove tags from readme.md).\\\\n2. The PR should fail the Swagger BreakingChange check, but it's expected and allowed for API deprecation/removal. All other checks should pass.\\\\n3. Request approval for the breaking change using the standard process:\\\\n   - Submit for approval at https://aka.ms/brch\\\\n   - Email azbreakchangereview@microsoft.com\\\\n\\\\nOnce you receive approval for the breaking change, you can merge the PR regardless of the LintDiff failure. This workflow is supported by the Azure REST API specs wiki. The loop in the workflow diagram is intentional: it requires explicit breaking change approval before merging. You do NOT need to fix the LintDiff failure for removed APIs; you only need the breaking change review approval.\\\\n\\\\nIn summary:\\\\n- Get breaking change approval via the official process\\\\n- Merge the PR once approval is granted, ignoring the LintDiff failure for the deleted specs\\\", \\\"ground_truth\\\": \\\"PRs to RPSaaSDev have no required checks, so you can merge this as-is.\\\\nIf you need to remove this spec from another branch like public/main or private/RPSaaSMaster, you will need more approvals.\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"}, {"inputs.query": "title: Deprecation of PostgreSql Single Server and its SDK Guidance\n\nquestion: Hi, PostgreSql Single Server officially deprecated in March 2025 with support completely ending September 2025. Efforts these past few months have been made to migrate users to PostgreSql Flexible Server.\nWe wish to remove the operations associated with single server found here: https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/postgresql/Azure.ResourceManager.PostgreSql/src/PostgreSql\nWant to confirm what is the exact process to remove the operations:\nIs official request needed?\nDo we manually remove the files associated to the resource?\nThank you for the help.", "inputs.ground_truth": "You will need to update the libraries for all 5 languages, not just .NET, to support the deprecation / retirement and migration.\nFor .NET, does the library currently contain operations for both the single server and flexible server?  If so, the REST API version(s) in question would need to be retired first, and then new SDK libraries would need to be generated.\nFor some of the other languages (like Python, Go, and Java), were there separate libraries for single server and flexible server?\nI'm looping in our Shanghai team for assistance - Josephine, Arthur, and Renhe.\nOnce we work out how the libraries map to the different service versions, the instructions on how to deprecate an entire library for each language are here: [Deprecating Azure SDKs](https://eng.ms/docs/products/azure-developer-experience/retirement/sdk-deprecation)", "inputs.response": "To remove operations and code associated with PostgreSql Single Server from the Azure SDK for .NET, you must follow the official Azure SDK deprecation and retirement process. This process is tightly governed to ensure proper notification and support for customers.\n\n**Process Overview:**\n1. **Official Request & Approval:**\n   - Yes, you need an official approval. Removing SDK operations for a deprecated service requires going through the Azure SDK deprecation process, which is aligned with the broader Microsoft API retirement policy. If Single Server is GA, you must ensure breaking change approval and customer communication per the [CPEX Breaking Changes Process](https://aka.ms/CPEXBreakingChangesProcess).\n   - For management plane (.NET), any breaking change (such as removing operations/resources) requires explicit approval from the Azure SDK Architecture Team (azsdkarch@microsoft.com) and adherence to the [Azure Breaking Changes Policy](http://aka.ms/AzBreakingChangesPolicy).\n\n2. **Deprecation Documentation:**\n   - Update the SDK status in the Azure SDK inventory dashboard by modifying the relevant CSV file (dotnet-packages.csv) in the azure-sdk repo. Mark the package as deprecated, set the EOLDate, provide a replacement package name (if any), and a migration guide link.\n   - Update the NuGet package metadata and README to indicate deprecation and point to Flexible Server as the replacement.\n\n3. **Code Removal:**\n   - You may remove code from the repo **after** the official deprecation and retirement process is complete, and all customer notifications and migration windows have been honored. For Track 1 libraries, code removal typically happens after 18 months post-deprecation; for Track 2, follow the standard 3-year notification as per Azure Retirement Guidelines.\n   - Do NOT manually delete files without following the above process. All changes must be tracked, reviewed, and approved.\n\n**Actionable Next Steps:**\n- Begin with an official request and breaking change review if needed.\n- Follow the SDK deprecation guidelines: update CSV inventory, package manager, README, and communicate with customers.\n- Only remove code after the official retirement process is complete and approvals are granted.\n\nFor more help or clarification, reach out to the [Azure SDK Onboarding channel](https://aka.ms/azsdk/support/onboarding-channel).\n", "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"retirement#api-retirement.md\",\"document_title\":\"Retiring Azure APIs\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/retirement/api-retirement\",\"content\":\"# retirement#api-retirement.md\\n\\n# Retiring Azure APIs\\n\\nNote: In this documentation, the words \\\"retirement\\\" and \\\"deprecation\\\" are used interchangeably. Both terms refer to the process of phasing out support for SDKs and APIs.\\r\\nAzure services may retire the entire service (and therefore all service API versions) or may retire a subset of service API versions.\\r\\nTo see general information about retiring REST APIs visit [CPEX Retirement Process Overview](https://aka.ms/cpexretirementsprocess).\\r\\nTo see ARM-specific information about retiring ARM APIs visit [API Deprecation Policy](https://armwiki.azurewebsites.net/api_contracts/APIDeprecationPolicy.html).\\r\\nIf you want to retire GA APIs, you can only do so if you introduced an approved breaking change in a new GA version and retire the old GA version. This process requires going through the breaking changes approval process and the subsequent breaking changes customer communication process. To learn more visit [CPEX Breaking Change Process](https://aka.ms/CPEXBreakingChangesProcess)\\r\\nOnce a service API version is fully retired, the corresponding API spec should be removed from the [REST API specs repo](https://github.com/azure/azure-rest-api-specs).\\n\\n## Removing published REST API reference documentation\\n\\nBefore removing the corresponding API spec from the GitHub repo, the REST API reference documentation need to be unpublished. Please reach out to the Learn API Reference Docs team first and/or fill out [this template.](https://dev.azure.com/msft-skilling/Content/_workitems/create/User%20Story?templateId=b10b9359-9b36-46ba-9840-848ce407a8b3\\u0026ownerId=c4a28f90-17ae-4384-b514-7273392b082b)\\n\\n## Deprecating Preview REST APIs\\n\\nFollow the process described in the [Azure REST API wiki](https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs) to remove your REST API spec from the specs repository.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"retirement#sdk-deprecation.md\",\"document_title\":\"Deprecating Azure SDKs\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/retirement/sdk-deprecation\",\"content\":\"# retirement#sdk-deprecation.md\\n\\n# Deprecating Azure SDKs\\n\\nThis section describes the process of marking SDK packages as deprecated on the Azure SDK inventory dashboard and on\\r\\npackage managers that host the packages.\\r\\n\\r\\nIt does not cover the wider retirement or deprecation process defined by Microsoft. For information on that process,\\r\\nrefer to the [Retirement Process and Policy Overview](https://aka.ms/aprwiki). The Retirement Process and Policy\\r\\nOverview uses the term \\\"retirement\\\" instead of \\\"deprecation,\\\" but we use the terms interchangeably.\\n\\n## Before you begin\\n\\n- You are familiarized with the [Azure SDK deprecation guidelines](xref:sdk-deprecation-guidelines).\\n\\n## Azure SDK deprecation process\\n\\nusing a PowerShell terminal:\\r\\n\\r\\n```\\r\\ngit clone https://github.com/Azure/azure-sdk.git\\r\\n```\\r\\n\\r\\n- Create a branch in your local copy of our repo:\\r\\n\\r\\n```\\r\\ngit checkout -b package_deprecation\\r\\n```\\r\\n\\r\\n- Launch VS Code and open the local repo folder:\\r\\n\\r\\n```\\r\\nFile -\\u003e Open Folder -\\u003e \\u003cSelect your local repo folder\\u003e\\r\\n```\\r\\n\\r\\n- Open the relevant CSV file in VS Code, located under the following directory:\\r\\n\\r\\n```\\r\\n\\u003cyour local path\\u003e\\\\azure-sdk\\\\_data\\\\releases\\\\latest\\\\\\r\\n   android-packages.csv\\r\\n   c-packages.csv\\r\\n   cpp-packages.csv\\r\\n   dotnet-packages.csv\\r\\n   go-packages.csv\\r\\n   ios-packages.csv\\r\\n   java-packages.csv\\r\\n   js-packages.csv\\r\\n   python-packages.csv\\r\\n```\\r\\n\\r\\n- Right click on the file in the Explorer window and select `Edit csv`. Find your package(s) in the CSV editor.\\r\\nPackage names are listed in the leftmost column.\\r\\n- Update the following mandatory fields:\\r\\n\\r\\n| Field | Description |\\r\\n| --- | --- |\\r\\n| `EOLDate` | Date your package will officially be deprecated in `mm/dd/yyyy` format |\\r\\n| `Support` | Change the value to **deprecated** |\\r\\n| `Replace` | Name of the package meant to replace the package being deprecated |\\r\\n| `ReplaceGuide` | Link to a migration guide in the following format: `aka.ms/azsdk/\\u003clanguage\\u003e/migrate/\\u003clibrary\\u003e` |\\r\\n\\r\\nIf an SDK deprecation is due to a service retirement, the end-of-life date (`EOLDate`) should match the service final\\r\\nretirement date.\\r\\n\\r\\n- Commit your changes to your local repository:\\r\\n\\r\\n```\\r\\ngit add .\\r\\ngit commit -m \\\"Update CSV files for package deprecation\\\"\\r\\n```\\r\\n\\r\\n- Push your changes to GitHub:\\r\\n\\r\\n```\\r\\ngit push origin package_deprecation\\r\\n```\\r\\n\\r\\n- Create a pull request. The previous push command output will include a link to your new branch on the console.\\r\\nOpen the link in your browser and click the green **Create Pull request** button.\\r\\n\\r\\nOnce the pull request is created, checks will run to verify the change and notify the repo owners to review your commit.\\r\\nOnce the change has been reviewed and approved, it can be merged.\\n\\nThe Azure SDK team maintains a publicly-facing [dashboard](https://aka.ms/azsdk) for Azure SDK packages for all languages.\\r\\nDeprecating a package in this context means:\\r\\n\\r\\n1. Update the dashboard to move an SDK from the [active release page](https://azure.github.io/azure-sdk/) to the  \\r\\n[deprecated release page](https://azure.github.io/azure-sdk/releases/deprecated/index.html).\\r\\n2. Update the package manager download page to reflect the deprecated status, along with the name of the replacement\\r\\npackage (if available) and a link to the migration guide (if available).\\r\\n\\r\\nThe Azure SDK dashboard is populated using data stored in [CSV files](https://github.com/Azure/azure-sdk/tree/main/_data/releases/latest)\\r\\nin the Azure SDK GitHub repo. These CSV files are the source of truth for the status of the Azure SDKs.\\r\\n\\r\\nDeprecate an SDK by updating the language CSV files:\\r\\n\\r\\n- Install [Git](https://git-scm.com/downloads), [Visual Studio Code](https://code.visualstudio.com/Download), and the  \\r\\n[Edit CSV](https://marketplace.visualstudio.com/items?itemName=janisdd.vscode-edit-csv) extension for VS Code.\\r\\n- Configure the `Edit CSV` extension. Open the VS Code Settings (File-\\u003ePreferences-\\u003eSettings) and search for\\r\\n`csv-edit`. Set the following configuration options:\\r\\n\\r\\n```\\r\\n\\\"csv-edit.quoteAllFields\\\": \\\"true\\\",\\r\\n\\\"csv-edit.quoteEmptyOrNullFields\\\": \\\"true\\\",\\r\\n\\\"csv-edit.readOption_hasHeader\\\": \\\"true\\\",\\r\\n\\\"csv-edit.writeOption_hasHeader\\\": \\\"true\\\"\\r\\n```\\r\\n\\r\\n- Clone the repo on your local machine using a PowerShell terminal:\\r\\n\\r\\n```\\r\\ngit clone https://github.com/Azure/azure-sdk.git\\r\\n```\\r\\n\\r\\n- Create a branch in your local copy of our repo:\\r\\n\\r\\n```\\r\\ngit checkout -b package_deprecation\\r\\n```\\r\\n\\r\\n- Launch VS Code and open the local repo folder:\\r\\n\\r\\n```\\r\\nFile -\\u003e Open Folder -\\u003e \\u003cSelect your local repo folder\\u003e\\r\\n```\\r\\n\\r\\n- Open the relevant CSV file in VS Code, located under the following directory:\\r\\n\\r\\n```\\r\\n\\u003cyour local path\\u003e\\\\azure-sdk\\\\_data\\\\releases\\\\latest\\\\\\r\\n   android-packages.csv\\r\\n   c-packages.csv\\n\\n## Update package managers\\n\\nThe Azure SDKs are hosted on public package managers:\\r\\n\\r\\n| **Language** | **Package Manager** |\\r\\n| --- | --- |\\r\\n| **.NET** | [NuGet](https://nuget.org) |\\r\\n| **Python** | [PyPI](https://pypi.org/) |\\r\\n| **JavaScript** | [NPM](https://www.npmjs.com/) |\\r\\n| **Java** | [Maven](https://search.maven.org/) |\\r\\n| **Go** | [pkg.go.dev](https://pkg.go.dev/) |\\r\\n\\r\\nThe download page for each deprecated package on each package manager needs to be updated with a deprecation message.\\n\\n### Deprecation message\\n\\n| **Package Status** | **Message** |\\r\\n| --- | --- |\\r\\n| Deprecated with differently named replacement | This package has been deprecated and will no longer be maintained after `\\u003cEOLDate\\u003e`. Upgrade to the replacement package, `\\u003cReplace\\u003e`, to continue receiving updates. Refer to the migration guide (`\\u003cReplaceGuide\\u003e`) for guidance on upgrading. Refer to our deprecation policy (link) for more details. |\\r\\n| Deprecated with same name | This package has been deprecated and will no longer be maintained after `\\u003cEOLDate\\u003e`. Upgrade to the latest version to continue receiving updates. Refer to the migration guide (`\\u003cReplaceGuilde\\u003e`) for guidance on upgrading. Refer to our [deprecation policy](https://aka.ms/azsdk/support-policies) for more details. |\\n\\n### Package specific requirements\\n\\n| **Package Manager** | **Deprecation Process** |\\r\\n| --- | --- |\\r\\n| **NuGet**           | If you are deprecating .NET packages, there is automation in the Azure SDK GitHub repo that will update NuGet after your dotnet CSV commit is merged. You will need to have the NuGet search popularity for the deprecated package forwarded to the new replacement package to ensure it shows up in search results. This is a manual step and requires sending an email to account@nuget.org with the names of deprecated packages whose popularity should be transferred, and the list of stable packages that should receive the popularity transfer for each deprecated package. If deprecating more than ten packages, list them in tabular form using two columns: new ID, old ID. After the application is submitted, the NuGet team will notify you of the application's acceptance or rejection status (with the criteria that caused rejection).\\u003cbr\\u003e \\u003cbr\\u003ePopularity transfer requirements:\\u003cbr\\u003e- The legacy packages and new packages must share all owners.\\u003cbr\\u003e- The new packages must be clearly related to the legacy packages in naming and function (i.e., an evolution or next generation).\\u003cbr\\u003e- All versions of the legacy packages must be deprecated and point to the new packages receiving the transfer.\\u003cbr\\u003e- The popularity transfer must not cause confusion for NuGet users or worsen the NuGet search experience.\\u003cbr\\u003e- The new packages must have a stable version.\\u003cbr\\u003e- The legacy package must not receive popularity transfers from another deprecated package.\\r\\n**PyPI**            | Follow the process outlined in the [package deprecation wiki](https://aka.ms/azsdk/python/deprecation-process) located in the Azure SDK for Python GitHub repo.                       |\\r\\n**NPM**             |File a deprecation issue  on the Azure SDK for JS GitHub [repo](https://github.com/Azure/azure-sdk-for-js/issues/new?assignees=xirzec\\u0026labels=bug%2Cneeds-triage\\u0026projects=\\u0026template=deprecation_request.yaml\\u0026title=%5BDeprecate%5D%3A).|\\n\\nfrom another deprecated package.\\r\\n**PyPI**            | Follow the process outlined in the [package deprecation wiki](https://aka.ms/azsdk/python/deprecation-process) located in the Azure SDK for Python GitHub repo.                       |\\r\\n**NPM**             |File a deprecation issue  on the Azure SDK for JS GitHub [repo](https://github.com/Azure/azure-sdk-for-js/issues/new?assignees=xirzec\\u0026labels=bug%2Cneeds-triage\\u0026projects=\\u0026template=deprecation_request.yaml\\u0026title=%5BDeprecate%5D%3A).|\\r\\n**Maven**            |Follow the process outlined in the package deprecation wiki  located in the Azure SDK for Java GitHub [repo](https://aka.ms/azsdk/java/deprecation-process).    |\\r\\n**pkg.go.dev**    |Follow the process outlined in the package deprecation wiki  located in the Azure SDK for Go GitHub [repo](https://aka.ms/azsdk/go/deprecation-process).    |\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"retirement#sdk-deprecation-guidelines.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/retirement/sdk-deprecation-guidelines\",\"content\":\"# retirement#sdk-deprecation-guidelines.md\\n\\n| Short Link: | [aka.ms/azsdk/deprecation](https://aka.ms/azsdk/deprecation) |\\r\\n|--|--|\\n\\n# Azure SDK deprecation guidelines\\n\\nfixes. Track 2 libraries must follow the standard 3-year notification as per the Azure Retirement Guidelines linked at the top of this document. |\\r\\n| **After 12 months** | \\u003cul\\u003e\\u003cli\\u003eTrack 1 library no longer builds in the engineering system.\\u003c/li\\u003e\\u003cli\\u003eOnly high-impact customer-impacting (i.e., Sev1) bugs are addressed in Track 1 when no mitigation to Track 2 is acceptable. This would require re-creating or fixing the engineering system for that one fix.\\u003c/li\\u003e\\u003cli\\u003eDo a telemetry search on the old SDK. Any subscription that is currently submitted via the old SDK will receive an email informing you that the old SDK is being deprecated and points to the blog post for upgrade information.\\u003c/li\\u003e\\u003cli\\u003eGet Azure Advisor involved to show an alert saying that an app accessing resource X is using an SDK that will soon be deprecated, and they should upgrade. If it’s an internal resource, identify the resource making the call. |\\r\\n| **After 18 months** | \\u003cul\\u003e\\u003cli\\u003eTrack 1 library code moved out of the repository.\\u003c/li\\u003e\\u003cli\\u003eThis can mean that either the code is deleted from the repo or archived. Note: As we have release tags, the code will continue to be available when directly accessing the release tag. |\\r\\n| **Beta libraries less than one year old** | \\u003cul\\u003e\\u003cli\\u003eBeta packages with a later GA library release are automatically considered deprecated\\u003cli\\u003eBeta packages with no planned future development can be marked deprecated at any time\\u003c/li\\u003e\\u003cul\\u003e\\u003cli\\u003eUpdate README if available and package manager with deprecation notice\\u003c/li\\u003e\\u003cli\\u003eIf a GA release is available, direct customers to it in the README and package managers\\u003c/li\\u003e\\u003c/ul\\u003e\\u003cli\\u003eBeta packages have no obligation to receive support once marked deprecated\\u003cli\\u003e\\u003c/ul\\u003e\\r\\n| **Beta libraries older than one year** | \\u003cp\\u003eBeta packages with a GA release can follow the same guidance as provided for betas less than one year old, once the following requirements are met:\\u003c/p\\u003e\\u003cul\\u003e\\u003cli\\u003eInform customers that the library is deprecated.\\n\\nNote: In this documentation, the words \\\"retirement\\\" and \\\"deprecation\\\" are used interchangeably. Both terms refer to the process of phasing out support for SDKs and APIs.\\r\\n\\r\\n| **Lifecycle Stage** | **Action** |\\r\\n| --- | --- |\\r\\n| **GA libraries that have a Track 2 library available** | \\u003cul\\u003e\\u003cli\\u003e Update the old package to point to the new Track 2 library.\\u003c/li\\u003e\\u003cli\\u003eUpdate the package manager of the old package as per guidance above on updating package managers. if the package has a README in the Azure SDK language repo, update the README with the same message as the package manager.\\u003c/li\\u003e\\u003cli\\u003ePost a blog on the Azure Blog, essentially stating that a new package is available which replaces the old package, the old package is scheduled to be deprecated on a specific date, and guidance on adjusting code to use the new package.\\u003c/li\\u003e\\u003cli\\u003eNo new features should be added in Track 1. If the feature request is valid for the new SDK, transition the issue to the new SDK.\\u003c/li\\u003e\\u003cli\\u003eMajor customer-impacting bugs should continue to be addressed in both Track 1 and Track 2, including security vulnerabilities.\\u003c/li\\u003e\\u003cli\\u003eSerious security vulnerabilities in dependent libraries are addressed in both Track 1 and Track 2.\\u003c/li\\u003e\\u003cli\\u003eFor Track 1 SDK libraries, the EOLDate must be slated for 12 months after a replacement Track 2 library is available. Support during the first year may be limited to critical security fixes. Track 2 libraries must follow the standard 3-year notification as per the Azure Retirement Guidelines linked at the top of this document. |\\r\\n| **After 12 months** | \\u003cul\\u003e\\u003cli\\u003eTrack 1 library no longer builds in the engineering system.\\u003c/li\\u003e\\u003cli\\u003eOnly high-impact customer-impacting (i.e., Sev1) bugs are addressed in Track 1 when no mitigation to Track 2 is acceptable. This would require re-creating or fixing the engineering system for that one fix.\\u003c/li\\u003e\\u003cli\\u003eDo a telemetry search on the old SDK.\\n\\nand package manager with deprecation notice\\u003c/li\\u003e\\u003cli\\u003eIf a GA release is available, direct customers to it in the README and package managers\\u003c/li\\u003e\\u003c/ul\\u003e\\u003cli\\u003eBeta packages have no obligation to receive support once marked deprecated\\u003cli\\u003e\\u003c/ul\\u003e\\r\\n| **Beta libraries older than one year** | \\u003cp\\u003eBeta packages with a GA release can follow the same guidance as provided for betas less than one year old, once the following requirements are met:\\u003c/p\\u003e\\u003cul\\u003e\\u003cli\\u003eInform customers that the library is deprecated. The GA library should have an updated README and package manager\\u003c/li\\u003e\\u003cli\\u003eProvide customers with a link to GA library (via README and package manager)\\u003c/li\\u003e\\u003c/ul\\u003e\\u003cp\\u003eBeta packages without a GA release can be marked deprecated when the following requirements are met:\\u003c/p\\u003e\\u003cul\\u003e\\u003cli\\u003eInform customers that the library is deprecated (update README and package manager)\\u003c/li\\u003e\\u003cli\\u003eProvide customers with a link to alternative library (if available)\\u003c/li\\u003e\\u003cli\\u003eProvide customers with a migration guide (if alternative library is available)\\u003c/li\\u003e\\u003cli\\u003eInform customers that source is available for those that want to continue using the library\\u003c/li\\u003e\\u003c/ul\\u003e\\u003cp\\u003eDeprecated beta packages have no obligation to receive support once marked deprecated. Source code will remain available for those that want to continue using and maintaining the library themselves.\\u003c/p\\u003e\\n\\n## Next steps\\n\\n- [Deprecating Azure SDKs](xref:sdk-deprecation)\\n\\n## Get help\\n\\nIf you have general questions about the deprecation guidelines and process, reach out to us on the  \\r\\n[Azure SDK / Azure SDK Onboarding] channel.\\r\\n\\r\\n[Azure SDK / Azure SDK Onboarding]: https://aka.ms/azsdk/support/onboarding-channel\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-prerequisites.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites\",\"content\":\"# Prerequisites to release client libraries (SDK)\\n## Resolve Breaking Changes\\nThe automation that generates the SDKs detect and report any breaking changes in the APIs to maintain backward compatibility.\\r\\nIt is necessary to review these breaking changes, retaining only those that are unavoidable and have been evaluated and\\r\\napproved through the [CPEX Breaking Changes Review Process](https://eng.ms/docs/cloud-ai-platform/azure-core/azure-core-product/product-lifecycle-management-plm/service-lifecycle-and-actions-team/service-lifecycle-actions-team/cpex/media/overview_breaking_changes#cpex-breaking-changes-review-process).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e CPEX (Cloud Product Excellence) Breaking Change Policy documentation covers Azure's requirements on service versioning and breaking changes. Generally, we must avoid introducing any breaking changes into our services, products, APIs, or SDKs. If a breaking change is unavoidable, we must provide customers a three-year notification for migration and fully support the prior versions during that period. More details about CPEX Breaking Changes Review Process can be found at this [Azure Breaking Changes](https://eng.ms/docs/cloud-ai-platform/azure-core/azure-core-product/product-lifecycle-management-plm/service-lifecycle-and-actions-team/service-lifecycle-actions-team/cpex/media/overview_breaking_changes) page.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release\",\"content\":\"# Release SDK\\n## Get help\\n### [Management plane (ARM)](#tab/management)\\n[Azure SDK - SDK Release Support](https://teams.microsoft.com/l/channel/19%3A084875bb626242ed95f3ac8dddfaa12a%40thread.skype/SDK%20release%20support?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release\",\"content\":\"# Release SDK\\n## Breaking change policy\\n- Requires approval from Azure SDK Architecture Team \\u003cazsdkarch@microsoft.com\\u003e\\r\\n- More information: http://aka.ms/AzBreakingChangesPolicy/\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-mgmt-dotnet.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-mgmt-dotnet\",\"content\":\"# Prerequisites to release .NET management plane SDK\\n| Short Link: | [azsdk/releases/mgmtnet](https://aka.ms/azsdk/releases/mgmtnet) |\\r\\n| --- | --- |\\r\\n\\r\\nAzure services are required to work on .NET management plane SDKs.\\r\\n\\r\\n\\u003e[!IMPORTANT]\\r\\n\\u003e This guidance is only applicable for OpenAPI API specs.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-develop.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop\",\"content\":\"# Develop client libraries (SDK)\\n## Get help\\n- If you need help with an automation tool or the Release planner, reach out to \\r\\n[Azure SDK / Azure SDK Onboarding](https://aka.ms/azsdk/support/onboarding-channel) channel.\\r\\n- If you need help with the development of the SDKs reach out to the [language specific Team's channel](xref:support#get-help-with-the-azure-sdks-development).\\r\\n- If you need to request an exception for a language review the [request release exception](xref:request-exception).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-prerequisites.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites\",\"content\":\"# Prerequisites to release client libraries (SDK)\\n## Get SDK pull request merged\\nOnce you confirm\\r\\n\\r\\n:white_check_mark: your SDK libraries are generated\\r\\n\\r\\n:white_check_mark: tests and samples are added\\r\\n\\r\\n:white_check_mark:`CHANGELOG.md` is up to date\\r\\n\\r\\nAll changes should be committed to the pull request generated by the SDK generation automation (if not already present).\\r\\nMonitor and address review comments from the SDK engineer for each language as needed until approval is granted to merge\\r\\nthe pull request.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e For GA releases, .NET requires APIView approval from the .NET SDK owner on the SDK pull request for release.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#support.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/support\",\"content\":\"# Get help and support\\n\\u003c!-- A short description of this page (fewer than 50 words) that describes the main learning goal or task that readers\\r\\nwill complete. --\\u003e\\r\\n\\r\\nIf you have problems or questions when using Azure SDK tools or releasing your updates, you can get help by following\\r\\nguidance provided in this article.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"plan#upcoming_release_planner_change.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/plan/upcoming_release_planner_change\",\"content\":\"# SDK self-serve for TypeSpec generated management plane SDKs\\n## Get help\\n[Azure SDK - SDK Release Support](https://teams.microsoft.com/l/channel/19%3A084875bb626242ed95f3ac8dddfaa12a%40thread.skype/SDK%20release%20support?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-pipeline.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-pipeline\",\"content\":\"# Run release SDK pipeline\\n## Before you begin\\n\\u003e [!NOTE]\\r\\n\\u003e These instructions are for packages that are built and release from our mono repos (i.e. `azure-sdk-for-\\u003clang\\u003e`).\\r\\nIf you are a partner that is trying to release a package from outside of those repos follow the instructions at  \\r\\n[Partner Release Pipelines](https://aka.ms/azsdk/partner-release-pipeline).\\r\\n\\r\\n- You have a [release plan](xref:release-plan) for the release.\\r\\n- You have [access to the Azure SDK DevOps](xref:access#request-access-to-azure-sdk-devops).\\r\\n- You have read and understood the [Azure SDK approval release guidelines](xref:sdk-approval-release-guidelines).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-mgmt-dotnet.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-mgmt-dotnet\",\"content\":\"# Prerequisites to release .NET management plane SDK\\n## Get help\\n[Azure SDK Code Generation - .NET](https://teams.microsoft.com/l/channel/19%3Aacbd512e57bd475198ea6bf4564599e3%40thread.skype/Code%20Generation%20-%20.NET?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-develop.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop\",\"content\":\"# Develop client libraries (SDK)\\n## Before you begin\\n- You have [access](xref:access) to the GitHub repositories and respective GitHub groups.\\r\\n- You read our [repository branches strategy](https://azure.github.io/azure-sdk/policies_repobranching.html).\\r\\n- You are familiarized with the [Azure SDK Architecture design guidelines](https://azure.github.io/azure-sdk/general_introduction.html).\\r\\n- You have a [release plan](xref:release-plan) created to manage and understand the steps required to generate,\\r\\ntest, and release an SDK.\\r\\n- [Request a namespace review](xref:namespace-review). This review process take 1-2 weeks to complete or longer\\r\\ndepending on the complexity of the review.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#known-issues.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/known-issues\",\"content\":\"# Known issues and limitations\\n## Limitations\\nConsider the following limitations as you use Azure SDK tools.\\r\\n\\r\\nNo limitations to report here as of 8/31/2023.\"}]", "inputs.latency": 229.5728964805603, "inputs.response_length": 2367, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://eng.ms/docs/products/azure-developer-experience/retirement/sdk-deprecation", "https://eng.ms/docs/products/azure-developer-experience/retirement/api-retirement", "https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites"], "inputs.testcase": "Deprecation of PostgreSql Single Server and its SDK Guidance", "outputs.similarity.similarity": 4.0, "outputs.similarity.gpt_similarity": 4.0, "outputs.similarity.similarity_result": "pass", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1594, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1595, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Deprecation of PostgreSql Single Server and its SDK Guidance\\\\n\\\\nquestion: Hi, PostgreSql Single Server officially deprecated in March 2025 with support completely ending September 2025. Efforts these past few months have been made to migrate users to PostgreSql Flexible Server.\\\\nWe wish to remove the operations associated with single server found here: https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/postgresql/Azure.ResourceManager.PostgreSql/src/PostgreSql\\\\nWant to confirm what is the exact process to remove the operations:\\\\nIs official request needed?\\\\nDo we manually remove the files associated to the resource?\\\\nThank you for the help.\\\", \\\"response\\\": \\\"To remove operations and code associated with PostgreSql Single Server from the Azure SDK for .NET, you must follow the official Azure SDK deprecation and retirement process. This process is tightly governed to ensure proper notification and support for customers.\\\\n\\\\n**Process Overview:**\\\\n1. **Official Request & Approval:**\\\\n   - Yes, you need an official approval. Removing SDK operations for a deprecated service requires going through the Azure SDK deprecation process, which is aligned with the broader Microsoft API retirement policy. If Single Server is GA, you must ensure breaking change approval and customer communication per the [CPEX Breaking Changes Process](https://aka.ms/CPEXBreakingChangesProcess).\\\\n   - For management plane (.NET), any breaking change (such as removing operations/resources) requires explicit approval from the Azure SDK Architecture Team (azsdkarch@microsoft.com) and adherence to the [Azure Breaking Changes Policy](http://aka.ms/AzBreakingChangesPolicy).\\\\n\\\\n2. **Deprecation Documentation:**\\\\n   - Update the SDK status in the Azure SDK inventory dashboard by modifying the relevant CSV file (dotnet-packages.csv) in the azure-sdk repo. Mark the package as deprecated, set the EOLDate, provide a replacement package name (if any), and a migration guide link.\\\\n   - Update the NuGet package metadata and README to indicate deprecation and point to Flexible Server as the replacement.\\\\n\\\\n3. **Code Removal:**\\\\n   - You may remove code from the repo **after** the official deprecation and retirement process is complete, and all customer notifications and migration windows have been honored. For Track 1 libraries, code removal typically happens after 18 months post-deprecation; for Track 2, follow the standard 3-year notification as per Azure Retirement Guidelines.\\\\n   - Do NOT manually delete files without following the above process. All changes must be tracked, reviewed, and approved.\\\\n\\\\n**Actionable Next Steps:**\\\\n- Begin with an official request and breaking change review if needed.\\\\n- Follow the SDK deprecation guidelines: update CSV inventory, package manager, README, and communicate with customers.\\\\n- Only remove code after the official retirement process is complete and approvals are granted.\\\\n\\\\nFor more help or clarification, reach out to the [Azure SDK Onboarding channel](https://aka.ms/azsdk/support/onboarding-channel).\\\\n\\\", \\\"ground_truth\\\": \\\"You will need to update the libraries for all 5 languages, not just .NET, to support the deprecation / retirement and migration.\\\\nFor .NET, does the library currently contain operations for both the single server and flexible server?  If so, the REST API version(s) in question would need to be retired first, and then new SDK libraries would need to be generated.\\\\nFor some of the other languages (like Python, Go, and Java), were there separate libraries for single server and flexible server?\\\\nI'm looping in our Shanghai team for assistance - Josephine, Arthur, and Renhe.\\\\nOnce we work out how the libraries map to the different service versions, the instructions on how to deprecate an entire library for each language are here: [Deprecating Azure SDKs](https://eng.ms/docs/products/azure-developer-experience/retirement/sdk-deprecation)\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"}, {"inputs.query": "title: Confirm deprecation workflow for HDInsightOnAks (Preview, usage = 0): API & SDK\n\nquestion: Hi team,\nHDInsightOnAks service is already in deprecation, which is Preview and currently has 0 usage. We need to retire both API and SDKs. After reviewing some discussions about Deprecation of PostgreSql, I’ve drafted the following workflow and would like the SDK team to confirm and help clarify a few questions.\nWorkflow and Questions:\n1. Remove the HDInsightOnAks spec folder from azure-rest-api-specs\n2. After removing the HDInsightOnAks API, send SDK deprecation email to Josephine\na) For SDK deprecation, do we only need to send an email? Is there a recommended email template?\nb) For each language repo, should I manually remove the code, or will the SDK team handle the removal?\nc) Is the final deprecation outcome to add a Deprecated annotation?\nPlease confirm and add any missing steps. Thanks!", "inputs.ground_truth": "Before you remove the specs folder, you need to make sure that any REST API docs on Learn are moved first:  Retiring Azure APIs.\nDetails on how to mark each SDK library as deprecated are here:  Deprecating Azure SDKs.  If you have already emails your service customers as part of the service deprecation, no separate email for SDKs is required.\nJosephine can assist with coordinating on the removal of code (but you should be able to submit PRs after all other work is done).", "inputs.response": "Based on the Azure SDK onboarding and retirement guidelines, here is the recommended and complete workflow for deprecating and retiring both the HDInsightOnAks API (Preview, usage = 0) and its SDKs:\n\n1. **API Spec Removal**:\n   - For a preview REST API, follow the process described in the Azure REST API wiki to remove your REST API spec from the azure-rest-api-specs repository. This is the correct first step for API retirement. For GA APIs, you must follow the breaking change and customer communication process before removal, but for Preview and zero usage, the wiki process is sufficient.\n   - Before removing the spec, ensure that any published REST API reference documentation is unpublished. Contact the Learn API Reference Docs team and/or fill out the official deprecation template.\n\n2. **SDK Deprecation Process**:\n   - Sending an email is **not sufficient** for official SDK deprecation. The correct process is:\n     - Clone the azure-sdk repo, create a branch, and update the relevant CSV files for each language under `_data/releases/latest/` (e.g., dotnet-packages.csv, python-packages.csv, etc.).\n     - For each SDK package:\n       - Set `Support` to `deprecated`\n       - Specify `EOLDate` (end-of-life date)\n       - Provide a replacement package name if applicable (if not, leave blank)\n       - Add a link to a migration guide or alternative (if available)\n     - Commit and push your changes, then create a pull request. Repo owners will review and merge.\n   - There is **no prescribed email template** in the provided knowledge for deprecation notifications. All official actions are managed via the CSV and repo process.\n\n3. **Code Removal in Language Repos**:\n   - The code removal is not always immediate and is subject to the lifecycle stage. For preview SDKs, you can mark them as deprecated and update README/package manager messages. For older betas or Track 1 libraries, code is eventually removed or archived (usually after 12-18 months for GA, less strict for preview/beta). \n   - You should coordinate with the SDK team for code removal or archiving. If you want immediate code removal, discuss with repo maintainers, but marking as deprecated in the CSV is the official first step.\n\n4. **Deprecation Outcome and Required Actions**:\n   - The official deprecation outcome is:\n     - SDK packages are marked as deprecated in the dashboard and package managers (NuGet, PyPI, NPM, Maven, Go).\n     - Update the README in each language repo with a deprecation notice and migration guidance if applicable.\n     - Add deprecation notices to the package manager download page (see language-specific instructions).\n     - Optionally, annotate the code with `@Deprecated` or equivalent (language-specific) and update release notes.\n   - For NuGet, you may need to request search popularity transfer to the replacement package (if one exists).\n   - For preview SDKs with zero usage, support obligations are minimal and you may proceed quickly, but still must update all the above documentation and metadata.\n\n**Missing Steps and Team Responsibilities:**\n- Coordinate with the Learn API Reference Docs team to unpublish reference documentation before spec removal.\n- Update the Azure SDK dashboard via CSV update (not just email).\n- For each language, follow the specific package manager deprecation process (NuGet, PyPI, NPM, Maven, Go).\n- Update the README files in the SDK repos to reflect deprecation.\n- For preview SDKs, code removal is possible, but you must coordinate with repo maintainers.\n- There is no official requirement for a deprecation email template, but internal communication is recommended.\n\n**Summary:**\n- Do not rely solely on email for SDK deprecation; update the CSVs in azure-sdk, README, and package managers.\n- Removal of API spec is correct for preview/unused APIs, but reference docs must be unpublished first.\n- SDK code removal should be coordinated, but dashboard/package manager deprecation is required.\n- Deprecation annotation in code is recommended, but not the only step; package metadata, documentation, and release notes must also be updated.\n\nFor detailed steps, refer to the provided references below.", "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"retirement#api-retirement.md\",\"document_title\":\"Retiring Azure APIs\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/retirement/api-retirement\",\"content\":\"# retirement#api-retirement.md\\n\\n# Retiring Azure APIs\\n\\nNote: In this documentation, the words \\\"retirement\\\" and \\\"deprecation\\\" are used interchangeably. Both terms refer to the process of phasing out support for SDKs and APIs.\\r\\nAzure services may retire the entire service (and therefore all service API versions) or may retire a subset of service API versions.\\r\\nTo see general information about retiring REST APIs visit [CPEX Retirement Process Overview](https://aka.ms/cpexretirementsprocess).\\r\\nTo see ARM-specific information about retiring ARM APIs visit [API Deprecation Policy](https://armwiki.azurewebsites.net/api_contracts/APIDeprecationPolicy.html).\\r\\nIf you want to retire GA APIs, you can only do so if you introduced an approved breaking change in a new GA version and retire the old GA version. This process requires going through the breaking changes approval process and the subsequent breaking changes customer communication process. To learn more visit [CPEX Breaking Change Process](https://aka.ms/CPEXBreakingChangesProcess)\\r\\nOnce a service API version is fully retired, the corresponding API spec should be removed from the [REST API specs repo](https://github.com/azure/azure-rest-api-specs).\\n\\n## Removing published REST API reference documentation\\n\\nBefore removing the corresponding API spec from the GitHub repo, the REST API reference documentation need to be unpublished. Please reach out to the Learn API Reference Docs team first and/or fill out [this template.](https://dev.azure.com/msft-skilling/Content/_workitems/create/User%20Story?templateId=b10b9359-9b36-46ba-9840-848ce407a8b3\\u0026ownerId=c4a28f90-17ae-4384-b514-7273392b082b)\\n\\n## Deprecating Preview REST APIs\\n\\nFollow the process described in the [Azure REST API wiki](https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs) to remove your REST API spec from the specs repository.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"retirement#sdk-deprecation.md\",\"document_title\":\"Deprecating Azure SDKs\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/retirement/sdk-deprecation\",\"content\":\"# retirement#sdk-deprecation.md\\n\\n# Deprecating Azure SDKs\\n\\nThis section describes the process of marking SDK packages as deprecated on the Azure SDK inventory dashboard and on\\r\\npackage managers that host the packages.\\r\\n\\r\\nIt does not cover the wider retirement or deprecation process defined by Microsoft. For information on that process,\\r\\nrefer to the [Retirement Process and Policy Overview](https://aka.ms/aprwiki). The Retirement Process and Policy\\r\\nOverview uses the term \\\"retirement\\\" instead of \\\"deprecation,\\\" but we use the terms interchangeably.\\n\\n## Before you begin\\n\\n- You are familiarized with the [Azure SDK deprecation guidelines](xref:sdk-deprecation-guidelines).\\n\\n## Azure SDK deprecation process\\n\\nusing a PowerShell terminal:\\r\\n\\r\\n```\\r\\ngit clone https://github.com/Azure/azure-sdk.git\\r\\n```\\r\\n\\r\\n- Create a branch in your local copy of our repo:\\r\\n\\r\\n```\\r\\ngit checkout -b package_deprecation\\r\\n```\\r\\n\\r\\n- Launch VS Code and open the local repo folder:\\r\\n\\r\\n```\\r\\nFile -\\u003e Open Folder -\\u003e \\u003cSelect your local repo folder\\u003e\\r\\n```\\r\\n\\r\\n- Open the relevant CSV file in VS Code, located under the following directory:\\r\\n\\r\\n```\\r\\n\\u003cyour local path\\u003e\\\\azure-sdk\\\\_data\\\\releases\\\\latest\\\\\\r\\n   android-packages.csv\\r\\n   c-packages.csv\\r\\n   cpp-packages.csv\\r\\n   dotnet-packages.csv\\r\\n   go-packages.csv\\r\\n   ios-packages.csv\\r\\n   java-packages.csv\\r\\n   js-packages.csv\\r\\n   python-packages.csv\\r\\n```\\r\\n\\r\\n- Right click on the file in the Explorer window and select `Edit csv`. Find your package(s) in the CSV editor.\\r\\nPackage names are listed in the leftmost column.\\r\\n- Update the following mandatory fields:\\r\\n\\r\\n| Field | Description |\\r\\n| --- | --- |\\r\\n| `EOLDate` | Date your package will officially be deprecated in `mm/dd/yyyy` format |\\r\\n| `Support` | Change the value to **deprecated** |\\r\\n| `Replace` | Name of the package meant to replace the package being deprecated |\\r\\n| `ReplaceGuide` | Link to a migration guide in the following format: `aka.ms/azsdk/\\u003clanguage\\u003e/migrate/\\u003clibrary\\u003e` |\\r\\n\\r\\nIf an SDK deprecation is due to a service retirement, the end-of-life date (`EOLDate`) should match the service final\\r\\nretirement date.\\r\\n\\r\\n- Commit your changes to your local repository:\\r\\n\\r\\n```\\r\\ngit add .\\r\\ngit commit -m \\\"Update CSV files for package deprecation\\\"\\r\\n```\\r\\n\\r\\n- Push your changes to GitHub:\\r\\n\\r\\n```\\r\\ngit push origin package_deprecation\\r\\n```\\r\\n\\r\\n- Create a pull request. The previous push command output will include a link to your new branch on the console.\\r\\nOpen the link in your browser and click the green **Create Pull request** button.\\r\\n\\r\\nOnce the pull request is created, checks will run to verify the change and notify the repo owners to review your commit.\\r\\nOnce the change has been reviewed and approved, it can be merged.\\n\\nThe Azure SDK team maintains a publicly-facing [dashboard](https://aka.ms/azsdk) for Azure SDK packages for all languages.\\r\\nDeprecating a package in this context means:\\r\\n\\r\\n1. Update the dashboard to move an SDK from the [active release page](https://azure.github.io/azure-sdk/) to the  \\r\\n[deprecated release page](https://azure.github.io/azure-sdk/releases/deprecated/index.html).\\r\\n2. Update the package manager download page to reflect the deprecated status, along with the name of the replacement\\r\\npackage (if available) and a link to the migration guide (if available).\\r\\n\\r\\nThe Azure SDK dashboard is populated using data stored in [CSV files](https://github.com/Azure/azure-sdk/tree/main/_data/releases/latest)\\r\\nin the Azure SDK GitHub repo. These CSV files are the source of truth for the status of the Azure SDKs.\\r\\n\\r\\nDeprecate an SDK by updating the language CSV files:\\r\\n\\r\\n- Install [Git](https://git-scm.com/downloads), [Visual Studio Code](https://code.visualstudio.com/Download), and the  \\r\\n[Edit CSV](https://marketplace.visualstudio.com/items?itemName=janisdd.vscode-edit-csv) extension for VS Code.\\r\\n- Configure the `Edit CSV` extension. Open the VS Code Settings (File-\\u003ePreferences-\\u003eSettings) and search for\\r\\n`csv-edit`. Set the following configuration options:\\r\\n\\r\\n```\\r\\n\\\"csv-edit.quoteAllFields\\\": \\\"true\\\",\\r\\n\\\"csv-edit.quoteEmptyOrNullFields\\\": \\\"true\\\",\\r\\n\\\"csv-edit.readOption_hasHeader\\\": \\\"true\\\",\\r\\n\\\"csv-edit.writeOption_hasHeader\\\": \\\"true\\\"\\r\\n```\\r\\n\\r\\n- Clone the repo on your local machine using a PowerShell terminal:\\r\\n\\r\\n```\\r\\ngit clone https://github.com/Azure/azure-sdk.git\\r\\n```\\r\\n\\r\\n- Create a branch in your local copy of our repo:\\r\\n\\r\\n```\\r\\ngit checkout -b package_deprecation\\r\\n```\\r\\n\\r\\n- Launch VS Code and open the local repo folder:\\r\\n\\r\\n```\\r\\nFile -\\u003e Open Folder -\\u003e \\u003cSelect your local repo folder\\u003e\\r\\n```\\r\\n\\r\\n- Open the relevant CSV file in VS Code, located under the following directory:\\r\\n\\r\\n```\\r\\n\\u003cyour local path\\u003e\\\\azure-sdk\\\\_data\\\\releases\\\\latest\\\\\\r\\n   android-packages.csv\\r\\n   c-packages.csv\\n\\n## Update package managers\\n\\nThe Azure SDKs are hosted on public package managers:\\r\\n\\r\\n| **Language** | **Package Manager** |\\r\\n| --- | --- |\\r\\n| **.NET** | [NuGet](https://nuget.org) |\\r\\n| **Python** | [PyPI](https://pypi.org/) |\\r\\n| **JavaScript** | [NPM](https://www.npmjs.com/) |\\r\\n| **Java** | [Maven](https://search.maven.org/) |\\r\\n| **Go** | [pkg.go.dev](https://pkg.go.dev/) |\\r\\n\\r\\nThe download page for each deprecated package on each package manager needs to be updated with a deprecation message.\\n\\n### Deprecation message\\n\\n| **Package Status** | **Message** |\\r\\n| --- | --- |\\r\\n| Deprecated with differently named replacement | This package has been deprecated and will no longer be maintained after `\\u003cEOLDate\\u003e`. Upgrade to the replacement package, `\\u003cReplace\\u003e`, to continue receiving updates. Refer to the migration guide (`\\u003cReplaceGuide\\u003e`) for guidance on upgrading. Refer to our deprecation policy (link) for more details. |\\r\\n| Deprecated with same name | This package has been deprecated and will no longer be maintained after `\\u003cEOLDate\\u003e`. Upgrade to the latest version to continue receiving updates. Refer to the migration guide (`\\u003cReplaceGuilde\\u003e`) for guidance on upgrading. Refer to our [deprecation policy](https://aka.ms/azsdk/support-policies) for more details. |\\n\\n### Package specific requirements\\n\\n| **Package Manager** | **Deprecation Process** |\\r\\n| --- | --- |\\r\\n| **NuGet**           | If you are deprecating .NET packages, there is automation in the Azure SDK GitHub repo that will update NuGet after your dotnet CSV commit is merged. You will need to have the NuGet search popularity for the deprecated package forwarded to the new replacement package to ensure it shows up in search results. This is a manual step and requires sending an email to account@nuget.org with the names of deprecated packages whose popularity should be transferred, and the list of stable packages that should receive the popularity transfer for each deprecated package. If deprecating more than ten packages, list them in tabular form using two columns: new ID, old ID. After the application is submitted, the NuGet team will notify you of the application's acceptance or rejection status (with the criteria that caused rejection).\\u003cbr\\u003e \\u003cbr\\u003ePopularity transfer requirements:\\u003cbr\\u003e- The legacy packages and new packages must share all owners.\\u003cbr\\u003e- The new packages must be clearly related to the legacy packages in naming and function (i.e., an evolution or next generation).\\u003cbr\\u003e- All versions of the legacy packages must be deprecated and point to the new packages receiving the transfer.\\u003cbr\\u003e- The popularity transfer must not cause confusion for NuGet users or worsen the NuGet search experience.\\u003cbr\\u003e- The new packages must have a stable version.\\u003cbr\\u003e- The legacy package must not receive popularity transfers from another deprecated package.\\r\\n**PyPI**            | Follow the process outlined in the [package deprecation wiki](https://aka.ms/azsdk/python/deprecation-process) located in the Azure SDK for Python GitHub repo.                       |\\r\\n**NPM**             |File a deprecation issue  on the Azure SDK for JS GitHub [repo](https://github.com/Azure/azure-sdk-for-js/issues/new?assignees=xirzec\\u0026labels=bug%2Cneeds-triage\\u0026projects=\\u0026template=deprecation_request.yaml\\u0026title=%5BDeprecate%5D%3A).|\\n\\nfrom another deprecated package.\\r\\n**PyPI**            | Follow the process outlined in the [package deprecation wiki](https://aka.ms/azsdk/python/deprecation-process) located in the Azure SDK for Python GitHub repo.                       |\\r\\n**NPM**             |File a deprecation issue  on the Azure SDK for JS GitHub [repo](https://github.com/Azure/azure-sdk-for-js/issues/new?assignees=xirzec\\u0026labels=bug%2Cneeds-triage\\u0026projects=\\u0026template=deprecation_request.yaml\\u0026title=%5BDeprecate%5D%3A).|\\r\\n**Maven**            |Follow the process outlined in the package deprecation wiki  located in the Azure SDK for Java GitHub [repo](https://aka.ms/azsdk/java/deprecation-process).    |\\r\\n**pkg.go.dev**    |Follow the process outlined in the package deprecation wiki  located in the Azure SDK for Go GitHub [repo](https://aka.ms/azsdk/go/deprecation-process).    |\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"retirement#sdk-deprecation-guidelines.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/retirement/sdk-deprecation-guidelines\",\"content\":\"# retirement#sdk-deprecation-guidelines.md\\n\\n| Short Link: | [aka.ms/azsdk/deprecation](https://aka.ms/azsdk/deprecation) |\\r\\n|--|--|\\n\\n# Azure SDK deprecation guidelines\\n\\nfixes. Track 2 libraries must follow the standard 3-year notification as per the Azure Retirement Guidelines linked at the top of this document. |\\r\\n| **After 12 months** | \\u003cul\\u003e\\u003cli\\u003eTrack 1 library no longer builds in the engineering system.\\u003c/li\\u003e\\u003cli\\u003eOnly high-impact customer-impacting (i.e., Sev1) bugs are addressed in Track 1 when no mitigation to Track 2 is acceptable. This would require re-creating or fixing the engineering system for that one fix.\\u003c/li\\u003e\\u003cli\\u003eDo a telemetry search on the old SDK. Any subscription that is currently submitted via the old SDK will receive an email informing you that the old SDK is being deprecated and points to the blog post for upgrade information.\\u003c/li\\u003e\\u003cli\\u003eGet Azure Advisor involved to show an alert saying that an app accessing resource X is using an SDK that will soon be deprecated, and they should upgrade. If it’s an internal resource, identify the resource making the call. |\\r\\n| **After 18 months** | \\u003cul\\u003e\\u003cli\\u003eTrack 1 library code moved out of the repository.\\u003c/li\\u003e\\u003cli\\u003eThis can mean that either the code is deleted from the repo or archived. Note: As we have release tags, the code will continue to be available when directly accessing the release tag. |\\r\\n| **Beta libraries less than one year old** | \\u003cul\\u003e\\u003cli\\u003eBeta packages with a later GA library release are automatically considered deprecated\\u003cli\\u003eBeta packages with no planned future development can be marked deprecated at any time\\u003c/li\\u003e\\u003cul\\u003e\\u003cli\\u003eUpdate README if available and package manager with deprecation notice\\u003c/li\\u003e\\u003cli\\u003eIf a GA release is available, direct customers to it in the README and package managers\\u003c/li\\u003e\\u003c/ul\\u003e\\u003cli\\u003eBeta packages have no obligation to receive support once marked deprecated\\u003cli\\u003e\\u003c/ul\\u003e\\r\\n| **Beta libraries older than one year** | \\u003cp\\u003eBeta packages with a GA release can follow the same guidance as provided for betas less than one year old, once the following requirements are met:\\u003c/p\\u003e\\u003cul\\u003e\\u003cli\\u003eInform customers that the library is deprecated.\\n\\nNote: In this documentation, the words \\\"retirement\\\" and \\\"deprecation\\\" are used interchangeably. Both terms refer to the process of phasing out support for SDKs and APIs.\\r\\n\\r\\n| **Lifecycle Stage** | **Action** |\\r\\n| --- | --- |\\r\\n| **GA libraries that have a Track 2 library available** | \\u003cul\\u003e\\u003cli\\u003e Update the old package to point to the new Track 2 library.\\u003c/li\\u003e\\u003cli\\u003eUpdate the package manager of the old package as per guidance above on updating package managers. if the package has a README in the Azure SDK language repo, update the README with the same message as the package manager.\\u003c/li\\u003e\\u003cli\\u003ePost a blog on the Azure Blog, essentially stating that a new package is available which replaces the old package, the old package is scheduled to be deprecated on a specific date, and guidance on adjusting code to use the new package.\\u003c/li\\u003e\\u003cli\\u003eNo new features should be added in Track 1. If the feature request is valid for the new SDK, transition the issue to the new SDK.\\u003c/li\\u003e\\u003cli\\u003eMajor customer-impacting bugs should continue to be addressed in both Track 1 and Track 2, including security vulnerabilities.\\u003c/li\\u003e\\u003cli\\u003eSerious security vulnerabilities in dependent libraries are addressed in both Track 1 and Track 2.\\u003c/li\\u003e\\u003cli\\u003eFor Track 1 SDK libraries, the EOLDate must be slated for 12 months after a replacement Track 2 library is available. Support during the first year may be limited to critical security fixes. Track 2 libraries must follow the standard 3-year notification as per the Azure Retirement Guidelines linked at the top of this document. |\\r\\n| **After 12 months** | \\u003cul\\u003e\\u003cli\\u003eTrack 1 library no longer builds in the engineering system.\\u003c/li\\u003e\\u003cli\\u003eOnly high-impact customer-impacting (i.e., Sev1) bugs are addressed in Track 1 when no mitigation to Track 2 is acceptable. This would require re-creating or fixing the engineering system for that one fix.\\u003c/li\\u003e\\u003cli\\u003eDo a telemetry search on the old SDK.\\n\\nand package manager with deprecation notice\\u003c/li\\u003e\\u003cli\\u003eIf a GA release is available, direct customers to it in the README and package managers\\u003c/li\\u003e\\u003c/ul\\u003e\\u003cli\\u003eBeta packages have no obligation to receive support once marked deprecated\\u003cli\\u003e\\u003c/ul\\u003e\\r\\n| **Beta libraries older than one year** | \\u003cp\\u003eBeta packages with a GA release can follow the same guidance as provided for betas less than one year old, once the following requirements are met:\\u003c/p\\u003e\\u003cul\\u003e\\u003cli\\u003eInform customers that the library is deprecated. The GA library should have an updated README and package manager\\u003c/li\\u003e\\u003cli\\u003eProvide customers with a link to GA library (via README and package manager)\\u003c/li\\u003e\\u003c/ul\\u003e\\u003cp\\u003eBeta packages without a GA release can be marked deprecated when the following requirements are met:\\u003c/p\\u003e\\u003cul\\u003e\\u003cli\\u003eInform customers that the library is deprecated (update README and package manager)\\u003c/li\\u003e\\u003cli\\u003eProvide customers with a link to alternative library (if available)\\u003c/li\\u003e\\u003cli\\u003eProvide customers with a migration guide (if alternative library is available)\\u003c/li\\u003e\\u003cli\\u003eInform customers that source is available for those that want to continue using the library\\u003c/li\\u003e\\u003c/ul\\u003e\\u003cp\\u003eDeprecated beta packages have no obligation to receive support once marked deprecated. Source code will remain available for those that want to continue using and maintaining the library themselves.\\u003c/p\\u003e\\n\\n## Next steps\\n\\n- [Deprecating Azure SDKs](xref:sdk-deprecation)\\n\\n## Get help\\n\\nIf you have general questions about the deprecation guidelines and process, reach out to us on the  \\r\\n[Azure SDK / Azure SDK Onboarding] channel.\\r\\n\\r\\n[Azure SDK / Azure SDK Onboarding]: https://aka.ms/azsdk/support/onboarding-channel\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-prerequisites.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites\",\"content\":\"# Prerequisites to release client libraries (SDK)\\n## Before you begin\\n- You have completed [the SDK generation](xref:sdk-generate) and created an SDK pull requests to the respective Azure SDK repository.\\r\\n- For an initial SDK release of your service, ensure that the [review of your SDK package\\r\\n  name](xref:namespace-review) — specified in the tspconfig.yaml configuration file — has been completed.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release\",\"content\":\"# Release SDK\\n## Get help\\n### [Management plane (ARM)](#tab/management)\\n[Azure SDK - SDK Release Support](https://teams.microsoft.com/l/channel/19%3A084875bb626242ed95f3ac8dddfaa12a%40thread.skype/SDK%20release%20support?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release\",\"content\":\"# Release SDK\\n## Breaking change policy\\n- Requires approval from Azure SDK Architecture Team \\u003cazsdkarch@microsoft.com\\u003e\\r\\n- More information: http://aka.ms/AzBreakingChangesPolicy/\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-prerequisites.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites\",\"content\":\"# Prerequisites to release client libraries (SDK)\\nAfter [executing the automation to generate SDKs](xref:sdk-generate) directly from your API\\r\\nspecification in TypeSpec, it is necessary to perform all required tasks outlined on this page before \\r\\n[initiating the SDK release pipeline](xref:sdk-release-pipeline) for publication.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-develop.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop\",\"content\":\"# Develop client libraries (SDK)\\n## Before you begin\\n- You have [access](xref:access) to the GitHub repositories and respective GitHub groups.\\r\\n- You read our [repository branches strategy](https://azure.github.io/azure-sdk/policies_repobranching.html).\\r\\n- You are familiarized with the [Azure SDK Architecture design guidelines](https://azure.github.io/azure-sdk/general_introduction.html).\\r\\n- You have a [release plan](xref:release-plan) created to manage and understand the steps required to generate,\\r\\ntest, and release an SDK.\\r\\n- [Request a namespace review](xref:namespace-review). This review process take 1-2 weeks to complete or longer\\r\\ndepending on the complexity of the review.\"}]", "inputs.latency": 299.5752546787262, "inputs.response_length": 4166, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://eng.ms/docs/products/azure-developer-experience/retirement/api-retirement", "https://eng.ms/docs/products/azure-developer-experience/retirement/sdk-deprecation"], "inputs.testcase": "Confirm deprecation workflow for HDInsightOnAks (Preview, usage = 0): API & SDK", "outputs.similarity.similarity": 4.0, "outputs.similarity.gpt_similarity": 4.0, "outputs.similarity.similarity_result": "pass", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1995, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1996, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Confirm deprecation workflow for HDInsightOnAks (Preview, usage = 0): API & SDK\\\\n\\\\nquestion: Hi team,\\\\nHDInsightOnAks service is already in deprecation, which is Preview and currently has 0 usage. We need to retire both API and SDKs. After reviewing some discussions about Deprecation of PostgreSql, I\\\\u2019ve drafted the following workflow and would like the SDK team to confirm and help clarify a few questions.\\\\nWorkflow and Questions:\\\\n1. Remove the HDInsightOnAks spec folder from azure-rest-api-specs\\\\n2. After removing the HDInsightOnAks API, send SDK deprecation email to Josephine\\\\na) For SDK deprecation, do we only need to send an email? Is there a recommended email template?\\\\nb) For each language repo, should I manually remove the code, or will the SDK team handle the removal?\\\\nc) Is the final deprecation outcome to add a Deprecated annotation?\\\\nPlease confirm and add any missing steps. Thanks!\\\", \\\"response\\\": \\\"Based on the Azure SDK onboarding and retirement guidelines, here is the recommended and complete workflow for deprecating and retiring both the HDInsightOnAks API (Preview, usage = 0) and its SDKs:\\\\n\\\\n1. **API Spec Removal**:\\\\n   - For a preview REST API, follow the process described in the Azure REST API wiki to remove your REST API spec from the azure-rest-api-specs repository. This is the correct first step for API retirement. For GA APIs, you must follow the breaking change and customer communication process before removal, but for Preview and zero usage, the wiki process is sufficient.\\\\n   - Before removing the spec, ensure that any published REST API reference documentation is unpublished. Contact the Learn API Reference Docs team and/or fill out the official deprecation template.\\\\n\\\\n2. **SDK Deprecation Process**:\\\\n   - Sending an email is **not sufficient** for official SDK deprecation. The correct process is:\\\\n     - Clone the azure-sdk repo, create a branch, and update the relevant CSV files for each language under `_data/releases/latest/` (e.g., dotnet-packages.csv, python-packages.csv, etc.).\\\\n     - For each SDK package:\\\\n       - Set `Support` to `deprecated`\\\\n       - Specify `EOLDate` (end-of-life date)\\\\n       - Provide a replacement package name if applicable (if not, leave blank)\\\\n       - Add a link to a migration guide or alternative (if available)\\\\n     - Commit and push your changes, then create a pull request. Repo owners will review and merge.\\\\n   - There is **no prescribed email template** in the provided knowledge for deprecation notifications. All official actions are managed via the CSV and repo process.\\\\n\\\\n3. **Code Removal in Language Repos**:\\\\n   - The code removal is not always immediate and is subject to the lifecycle stage. For preview SDKs, you can mark them as deprecated and update README/package manager messages. For older betas or Track 1 libraries, code is eventually removed or archived (usually after 12-18 months for GA, less strict for preview/beta). \\\\n   - You should coordinate with the SDK team for code removal or archiving. If you want immediate code removal, discuss with repo maintainers, but marking as deprecated in the CSV is the official first step.\\\\n\\\\n4. **Deprecation Outcome and Required Actions**:\\\\n   - The official deprecation outcome is:\\\\n     - SDK packages are marked as deprecated in the dashboard and package managers (NuGet, PyPI, NPM, Maven, Go).\\\\n     - Update the README in each language repo with a deprecation notice and migration guidance if applicable.\\\\n     - Add deprecation notices to the package manager download page (see language-specific instructions).\\\\n     - Optionally, annotate the code with `@Deprecated` or equivalent (language-specific) and update release notes.\\\\n   - For NuGet, you may need to request search popularity transfer to the replacement package (if one exists).\\\\n   - For preview SDKs with zero usage, support obligations are minimal and you may proceed quickly, but still must update all the above documentation and metadata.\\\\n\\\\n**Missing Steps and Team Responsibilities:**\\\\n- Coordinate with the Learn API Reference Docs team to unpublish reference documentation before spec removal.\\\\n- Update the Azure SDK dashboard via CSV update (not just email).\\\\n- For each language, follow the specific package manager deprecation process (NuGet, PyPI, NPM, Maven, Go).\\\\n- Update the README files in the SDK repos to reflect deprecation.\\\\n- For preview SDKs, code removal is possible, but you must coordinate with repo maintainers.\\\\n- There is no official requirement for a deprecation email template, but internal communication is recommended.\\\\n\\\\n**Summary:**\\\\n- Do not rely solely on email for SDK deprecation; update the CSVs in azure-sdk, README, and package managers.\\\\n- Removal of API spec is correct for preview/unused APIs, but reference docs must be unpublished first.\\\\n- SDK code removal should be coordinated, but dashboard/package manager deprecation is required.\\\\n- Deprecation annotation in code is recommended, but not the only step; package metadata, documentation, and release notes must also be updated.\\\\n\\\\nFor detailed steps, refer to the provided references below.\\\", \\\"ground_truth\\\": \\\"Before you remove the specs folder, you need to make sure that any REST API docs on Learn are moved first:  Retiring Azure APIs.\\\\nDetails on how to mark each SDK library as deprecated are here:  Deprecating Azure SDKs.  If you have already emails your service customers as part of the service deprecation, no separate email for SDKs is required.\\\\nJosephine can assist with coordinating on the removal of code (but you should be able to submit PRs after all other work is done).\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"}, {"inputs.query": "title: Official API documentation publishing\n\nquestion: General,\nHow do we generate official API documentation like below?\nAzure REST API reference documentation | Microsoft Learn\nFor a new RP like below. Is this done by the SDK team?\n[azure-rest-api-specs/specification/cdn/resource-manager/Microsoft.Cdn/Cdn/preview/2024-07-22-previe…](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/cdn/resource-manager/Microsoft.Cdn/Cdn/preview/2024-07-22-preview/edgeaction.json)", "inputs.ground_truth": "You can find information about this here: https://eng.ms/docs/products/azure-developer-experience/design/api-docs", "inputs.response": "The process for generating and publishing official Azure REST API reference documentation on Microsoft Learn is a coordinated effort between the service team (who authors the spec) and the Content Publishing Services team. It is NOT solely done by the SDK team.\n\nHere’s how the process works for a new Resource Provider (RP):\n\n1. **Author the REST API spec in TypeSpec Azure**: All new Azure RPs must describe their REST APIs using TypeSpec Azure (OpenAPI is supported only by exception). This spec is placed in the correct directory structure within the `azure-rest-api-specs` repo, such as the path you provided for `edgeaction.json`.\n\n2. **Merge the spec and README into the repo**: Once your TypeSpec (and generated OpenAPI) files are reviewed and merged into the `main` branch of the `Azure/azure-rest-api-specs` repository, you’re ready for publishing.\n\n3. **Onboard to Content Publishing Services**: After merging, the service team (not the SDK team) must submit an onboarding request to the Content Publishing Services team via the official onboarding portal. This is required for the API reference docs to be published on Microsoft Learn. You need a README configuration file with a default tag that refers to all spec files of the latest API version.\n\n   - Onboarding portal: https://learn.microsoft.com/help/onboard/reference?branch=main\n\n4. **Automatic Weekly Refresh**: Once onboarded, API references will be automatically refreshed every week (Tuesday) if the README configuration is set up correctly. Any subsequent spec changes merged to `main` will be picked up and published automatically.\n\n5. **Manual/Out-of-Band Publishing**: If you used alternative publishing configuration or need a manual refresh, you can submit a work item in Azure DevOps or create a PR in the REST API documentation repo to update publishing configuration.\n\n**Summary:**\n- The service team authors the spec and initiates onboarding.\n- The Content Publishing Services team handles publishing to Microsoft Learn after onboarding.\n- The SDK team is not responsible for publishing API reference documentation.\n\nSee the full process and onboarding instructions in the references below.", "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"Create a PR against main\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\\n\\n# Create a PR against main\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nWhen you're ready for a final review, it's time to create a pull request (PR) from your release branch you created\\r\\noriginally to the `main` branch on [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n* :warning: Do not merge `main` or other release branches unless you know there are changes required.\\r\\n* :white_check_mark: Rebase on `main` if changes are required in a separate topic branch.\\n\\n## Clean PR against main\\n\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\\n\\n## Update your branch with changes from main\\n\\nIf you know there are other changes in the `main` branch or that other services have updated shared files in `main`\\r\\nalready and you need to pick up changes before merging, we recommend you take a merge from main. This is particularly interesting\\r\\nfor common infrastructure changes that are committed in the repo (i.e. github actions, tools, etc). Depending on how old your\\r\\nbranch is some of the pull request checks may not correctly function without taking a merge from main. \\r\\n\\r\\nIf you are working in a non-protected branch you can do a `git merge main` like you would normally do a merge and then push\\r\\nyour changes to your remote branch. However, if you are working in a branch with branch protection enabled (i.e. `release-*`) then\\r\\nyou will need to make a pull request to your branch with the merge. Depending on how out-of-date your branch is from `main` your \\r\\nmerge may have a lot of unwanted and unnecessary changes and the checks not pass. In such cases see below on how to [update the infrastructure](#updating-only-the-infrastructure-changes-from-main).\\n\\n### Updating only the infrastructure changes from main\\n\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\\n\\n## Next steps\\n\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"API-Spec-Review-FAQ.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ\",\"content\":\"# API-Spec-Review-FAQ.md\\n\\nAnswers to frequently asked questions in the [Api Spec Review](https://teams.microsoft.com/l/channel/19%3A0351f5f9404446e4b4fd4eaf2c27448d%40thread.skype/API%20Spec%20Review?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47). Within that channel, EngSys should be answering questions about validation pipelines and tools that run in those pipelines. Specific questions about typespec, the API Review process, etc. should be answered by others who specialize in those topics. \\r\\n\\r\\n| If the question is about | The answer should be | \\r\\n| --- | --- | \\r\\n| Authoring typespec | Send to [TypeSpec Discussions](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) | \\r\\n| My PR is ready to review, will someone review it? | See the \\\"Next steps to merge\\\" comment in your PR and follow directions to ensure you're in the review queue. No need to post here. | \\r\\n| API Doc Preview is broken | If the error message linked doesn't make sense, follow instructions at [Troubleshooting REST API documentation](https://eng.ms/docs/products/azure-developer-experience/design/api-docs-troubleshooting). API Doc Preview is not a required check so you can ignore the failure if it's not relevant to your documentation needs. |\\r\\n| My PR needs to be reviewed by the ARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this.\\n\\nARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this. See documentation: [Update your branch with changes from main](https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish#update-your-branch-with-changes-from-main). |\\r\\n| I need to set up suppressions for LintDiff violations in my PR | See [Adding Scoped Suppressions](https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff) | \\r\\n| I have specific questions about the inner workings of ARM, testing changes to APIs, or rollout/release schedules | Talk to the ARM team: https://aka.ms/armofficehoursinfo |\\r\\n| I see an Avocado error `MULTIPLE_API_VERSION` | There is a coordinated effort to fix this. Reach out to the relevant parties. [This PR](https://github.com/Azure/avocado/pull/157) gives more context on why this was upgraded to an error. If relevant parties agree, the PR can be unblocked by adding the `Approved-Avocado` label to the PR. |\\r\\n| I merged a PR, when does the REST API documentation update on the Learn site? | Docs are published every week on Tuesdays | \\r\\n| If the specs in the standard branches of `RPSaaSMaster` and `RPSaaSDev` are out of sync, who is responsible for syncing them with main? | The spec owner is responsible for syncing their service’s spec files from `main` to `RPSaaSMaster/RPSaaSDev` to ensure consistency across branches. |\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-specs.md\",\"document_title\":\"Create or update an Azure REST API spec\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-specs\",\"content\":\"# design#api-specs#api-specs.md\\n\\n# Create or update an Azure REST API spec\\n\\nEvery Azure service must describe its REST APIs using [TypeSpec Azure](xref:api-typespec)  \\r\\n([OpenAPI](xref:api-openapi) is supported on an exception basis only).\\r\\nAs of October 2023, Azure has adopted [TypeSpec](xref:api-typespec) as the preferred means for defining REST APIs.\\n\\n## Before you begin\\n\\nEnsure that:\\r\\n\\r\\n- You have onboarded to Azure SDK team processes by following our [onboarding process](xref:onboard).\\r\\n- You have developed a [high-level design for your REST API](xref:api-design).\\r\\n- You have [access](xref:access) to the GitHub repositories and respective Azure open source organization.\\r\\n- You understand the conventions for the [Azure REST API specs GitHub repositories](xref:api-repos).\\n\\n## Create a branch in the specs repo\\n\\nYou first need to create a branch for you and your team to update the specifications.\\r\\n\\r\\n1. Clone the [repository](xref:api-repos) where you want the API spec to be published\\r\\n2. Create a new branch and make sure to include your GitHub alias as the prefix for the branch name.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e If multiple people will work on the same branch consider using a `release` branch.\\r\\n\\u003e Go to [API versions and branches](xref:api-versions-and-branches) to learn more about\\r\\n\\u003e branch protection rules in the repos.\\n\\n## Create your REST API definition\\n\\nAll new services must use [TypeSpec Azure](xref:api-typespec) to create their REST API definition.\\r\\nIf you are working on an existing service, you should consider converting your existing REST API definition to TypeSpec Azure.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e TypeSpec Azure usage for API definition is a mandatory requirement for all new (greenfield) data plane and management plane\\r\\n\\u003e services. This requirement is enforced by the ARM API Review Board for management plane services and by the API\\r\\n\\u003e Stewardship Board for data plane services.\\r\\n\\u003e Brownfield services will eventually be required to transition to TypeSpec Azure as well.  PRs for brownfields services\\r\\n\\u003e that have not transitioned to TypeSpec Azure will receive notices in FY2024, followed by warnings in FY2025 and\\r\\n\\u003e errors in FY2027. The requirement to move to TypeSpec Azure will ensure a consistent, high-quality developer experience across\\r\\n\\u003e Azure that aligns with Azure SDK guidelines. For more information on TypeSpec Azure, visit [here](xref:api-typespec).\\n\\n### [TypeSpec](#tab/typespec)\\n\\nServices that use TypeSpec Azure to describe their REST API must include both the TypeSpec source spec and generated OpenAPI\\r\\nspecs in the specs repo.\\r\\n\\r\\nIt is good practice to create a new branch in the specs repo for each new REST API definition that you create.\\r\\nUse this branch to iterate on your REST API definition until it is ready for review.\\r\\n\\r\\n- [Spec directory structure]\\r\\n- See our [tutorial](xref:api-tutorial) for more help.\\n\\n### [OpenAPI Specs](#tab/openapi)\\n\\n| Short Link: | [https://aka.ms/azsdkdocs/createopenapispec](https://aka.ms/azsdkdocs/createopenapispec) |\\r\\n| --- | --- |\\r\\n\\r\\nTo update an existing OpenAPI specification, just edit the specification file and skip to the [Next steps](##next-steps) section.\\r\\nTo create a new OpenAPI spec, additional steps must be taken for services that still rely on OpenAPI:\\r\\n\\r\\n#### Create new OpenAPI specs\\r\\n\\r\\nTo create a new OpenAPI specs version you need to create a new directory with all the specs files, examples,\\r\\nand update the readme configuration file manually.\\r\\n\\r\\n#### Required steps for new OpenAPI versions\\r\\n\\r\\nWhen creating a new OpenAPI spec version, you'll need to:\\r\\n\\r\\n- Create a new directory that will include all the OpenAPI spec files and examples.\\r\\n- Copy the OpenAPI specs files from an existing version to use it as a base for your new work, and update all the\\r\\n  old version references in said specs files to the new version.\\r\\n- Update the Autorest configuration readme with the new version Tag.\\r\\n\\r\\nAfter making these changes, commit them to your branch and make the wanted changes in the specification files.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-review\",\"content\":\"# design#api-review.md\\n\\n| Short Link: | [azsdk/onboarding/restapischedule](https://aka.ms/azsdk/onboarding/restapischedule) |\\r\\n| --- | --- |\\n\\n# Schedule a data plane REST API spec review\\n\\n## Purpose\\n\\nA data plane REST API review is designed to help you create developer-friendly and consistent REST (data plane) APIs\\r\\nfor your service. All Azure REST APIs need to be reviewed and approved prior to publication.\\n\\n## Before you begin\\n\\n\\u003e [!NOTE]\\r\\n\\u003e For management plane (ARM-based) APIs, you need to create a pull request (PR) in the [Azure REST API specification repositories](xref:api-repos).\\r\\n\\u003e Such PR is a part of the [release plan](xref:release-plan). The ARM review will happen during the [PR process](xref:api-specs-pr).\\r\\n\\r\\nEnsure that:\\r\\n\\r\\n- You have [access](xref:access) to the GitHub repositories and respective Azure open source organization.\\n\\n## Prepare for API review\\n\\nWhen you have your REST API definition ready for review, [create a pull request with your Azure REST API spec update](xref:api-specs-pr).\\r\\n\\r\\nYou should prepare and be ready to present the following information during your review:\\r\\n\\r\\n| Title | Importance | Brief description | Example and support documentation |\\r\\n| --- | --- | --- | --- |\\r\\n\\r\\nAPI spec PR link | Must Have | PR with your API spec definition against [azure/azure-rest-api-specs-pr](https://github.com/azure/azure-rest-api-specs-pr) or [azure/azure-rest-api-specs](https://github.com/azure/azure-rest-api-specs) | In order to access the PR, it may be necessary to join the [Azure GitHub organization](https://repos.opensource.microsoft.com/orgs/Azure). \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to https://repos.opensource.microsoft.com/orgs/Azure\\u003c/li\\u003e\\u003cli\\u003eClick **Join Organization**.\\u003c/li\\u003e\\u003c/ol\\u003e\\u003cp\\u003e\\u003cp\\u003eThe PR should be linked to the issue no less than 2 days before your meeting. To properly link your PR, in the issue click on the settings icon next to `Development` on the right side:\\u003cp\\u003e\\u003cp\\u003e![Screenshot](../img/link-pr.png)  |\\r\\nAPI spec PR CI checks | Important |Make sure all CI is passing before requesting a review. | [ci-fix](https://aka.ms/ci-fix) |\\r\\nCore concepts | Must have | A glossary of nouns and verbs  | [Example](https://github.com/Azure/azure-sdk-pr/blob/main/onboarding/Core_Concepts.pdf)\\r\\nAPI reference docs | Good to have | Your API documentation consists of two parts, the API spec document (TypeSpec/OpenAPI spec), and the generated developer docs. These docs are often the first experience a developer will have with your service. Make a good first impression!!| **Recommended for OpenAPI spec**: [VS Code extension](https://marketplace.visualstudio.com/items?itemName=42Crunch.vscode-openapi) load this extension and then open your OpenAPI spec file in VS Code and select **Preview**. \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to your PR and look for the comment added by the `openapi-pipeline-app bot` and title `Swagger Generation Artifacts`.\\n\\ngenerated developer docs. These docs are often the first experience a developer will have with your service. Make a good first impression!!| **Recommended for OpenAPI spec**: [VS Code extension](https://marketplace.visualstudio.com/items?itemName=42Crunch.vscode-openapi) load this extension and then open your OpenAPI spec file in VS Code and select **Preview**. \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to your PR and look for the comment added by the `openapi-pipeline-app bot` and title `Swagger Generation Artifacts`. In the comment posted by the bot, you will find a link to your generated documentation under `ApiDocPreview`.\\u003c/li\\u003e\\u003cli\\u003eExpand `Detail` and look for `Click here to preview`.\\u003c/li\\u003e\\u003cli\\u003eReview your docs! Ensure that `Summary` and `Description` fields are accurate and complete.\\u003c/li\\u003e\\u003c/ol\\u003e|\\r\\nHero scenarios | Good to have | Top scenarios on how service is consumed. | [Guidelines on how to identify hero scenarios](https://github.com/Azure/azure-sdk-pr/blob/main/training/azure-sdk-apis/principles/approachable/README.md#hero-scenarios)\\u003cp\\u003e\\u003cp\\u003e [Examples](https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/appconfiguration/Azure.Data.AppConfiguration#examples)\\r\\nReview [API style guidelines](https://aka.ms/azapi/style) | Good to do | Review to learn about the Spectral linting tool that can be used inside of VS Code. Running this tool will help you identify and address many of the common issues and greatly improve your OpenAPI spec. | [API style guidelines](https://aka.ms/azapi/style)|\\n\\n### Join the REST API Stewardship Teams channel\\n\\nThe meeting chat is mirrored in the [General channel](https://teams.microsoft.com/l/channel/19%3a3ebb18fded0e47938f998e196a52952f%40thread.tacv2/General?groupId=1a10b50c-e870-4fe0-8483-bf5542a8d2d8\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\\r\\nof the [API Stewardship Team room](https://teams.microsoft.com/l/team/19%3a3ebb18fded0e47938f998e196a52952f%40thread.tacv2/conversations?groupId=1a10b50c-e870-4fe0-8483-bf5542a8d2d8\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\\r\\n\\r\\nTo participate in the chat:\\r\\n\\r\\n1. Go to [Discover Teams](https://teams.microsoft.com/_#/discover)\\r\\n2. Enter the code `uprrab9` to join the team.\\n\\n### Review our style guide\\n\\nReview the [API style guidelines](https://aka.ms/azapi/style) to learn about the Spectral linting tool that can be used\\r\\ninside of VS Code. Running this tool will help you identify and address many of the common issues and greatly improve\\r\\nyour OpenAPI spec.\\n\\n## Schedule a meeting\\n\\nOne of the tasks of your release plan is to **Schedule REST API review meeting** with the Azure REST API Stewardship board.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e Reviews must be scheduled ideally at least two days in advance to give the team time to prepare.\\r\\n\\u003e \\u003e\\r\\n\\u003e For small changes, consider asking for an offline review. See the\\r\\n\\u003e [Requesting an offline REST API review](#requesting-an-offline-rest-api-review) section below.\\r\\n\\r\\n1. Log in to [Azure SDK Release Planner](https://aka.ms/azsdk/sdk-release-planner).\\r\\n2. Choose the top-level service that your product is associated with.\\r\\n3. Click **Your release plans** and select the release plan you are interested in.\\r\\n4. The **Summary** view will provide information about where you are in the process and who the contacts are.\\r\\n5. Click on **Milestones** and select **Data-plane API Readiness**. This will open the app with the specific task to\\r\\naccomplish before you schedule the meeting.\\r\\n6. The **Schedule a REST API review** task contains the information to schedule the meeting with the  \\r\\n[Azure SDK Scheduler](https://aka.ms/azsdk/scheduleapi) app.\\r\\n7. Once in the scheduler app click **Create new**.\\r\\n8. Choose a meeting slot and select meeting attendees.\\r\\nIn the **Meeting attendees** field, be sure to include the Cloud Product Excellence (CPEX) PM or owner who is\\r\\nresponsible for updating your product in Cloud Lifecycle, as well as any engineering team members that will be\\r\\ngenerating or updating SDKs.\\r\\n9. Indicate whether your REST API changes will be public or private.\\r\\n10. Provide a link to the REST API specs pull request that contains your latest changes.\\r\\n11. Provide links to your [hero scenarios](xref:api-design#start-with-hero-scenarios) and [core concepts](xref:api-design#define-terms-and-concepts).\\r\\nThese fields will be auto populated if you have provided these documents when you [onboarded to the Azure SDK team](xref:onboard).\\n\\n## Requesting an offline REST API review\\n\\nFor small changes, consider asking for an offline review. This may be a better use of your time and leave the meeting\\r\\ntime for teams with larger changes - especially important prior to large customer engagements like Build or Ignite.\\n\\n### When offline reviews are appropriate\\n\\nAn offline review is appropriate when the following conditions hold:\\r\\n\\r\\n- The prior API version was reviewed and approved by the API Stewardship board.\\r\\n- The new API version makes only minor changes to the prior API version, such as\\r\\n  - Fields added to an API response\\r\\n  - Optional parameters or fields added to a request\\r\\n- The PR for the new API version is passing all PR pipeline checks.\\r\\n- The TypeSpec and OpenAPI APIViews for the PR were successfully generated and clearly show\\r\\nthe changes without extra \\\"noise\\\".\\n\\n### How to request an offline review\\n\\nThe service team should schedule a review meeting using the scheduling tool for the next available open review slot.\\r\\nThis will create an API review issue that will record the progress / status of the API review.\\r\\n\\r\\nMake sure that the API review issue contains:\\r\\n\\r\\n- A link to the PR for the new API version\\r\\n- Links to design docs / hero scenarios (even if these are unchanged)\\r\\n\\r\\nThen the service team should post a comment in the API review issue with the following information:\\r\\n\\r\\n- A link to the API review issue for the prior API version\\r\\n- A description of the changes being made in the new API version\\r\\n\\r\\nThen send a e-mail to the Azure review board core e-mail alias\\r\\n[azureapirbcore@microsoft.com](mailto:azureapirbcore@microsoft.com) including the link to the review issue and\\r\\nrequesting an offline review.\\r\\n\\r\\nAdd the `offline-review-requested` label to the PR to make it easier for API reviewers to search for PRs to\\r\\nbe reviewed offline.\\n\\n### Conducting the offline review\\n\\nUpon receiving the email requesting offline review, API Stewardship board members may review the PR and leave comments.\\r\\nThe service team may use the Teams chat for the meeting to communicate with the review board\\r\\nto recruit reviewers or answer questions.\\r\\n\\r\\nWhen an API Steward has reviewed the PR and has no concerns they submit an \\\"Approved\\\" review.\\r\\nWhen at least two API stewards have approved and none have requested changes, any member of the Stewardship board\\r\\ncan add the \\\"signedOff\\\" label and the review is complete.\\n\\n### Following a completed offline review\\n\\nOnce the PR has received sign off, the service team should cancel the review meeting\\r\\nto free up the slot for another team.\\r\\n\\r\\nThe signedOff label will unblock merge for the PR, but merging should be done only when the API version is ready\\r\\nto be released to customers.\\n\\n## What happens during the review\\n\\n\\u003e [!NOTE]\\r\\n\\u003e The m\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-docs.md\",\"document_title\":\"Publish REST API reference docs\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-docs\",\"content\":\"# design#api-docs.md\\n\\n# Publish REST API reference docs\\n\\n## Before you begin\\n\\nA valid and reviewed REST API spec is __required__ for API reference to be published on  \\r\\n[learn.microsoft.com](https://learn.microsoft.com) for your service.\\r\\nFor a sample REST API spec, refer to [Sample OpenAPI spec].\\n\\n## Onboard to the content publishing services team\\n\\nAfter your REST API spec and README configuration file are merged into the [Azure/azure-rest-api-specs]  \\r\\nrepository (usually the __main__ branch), create an onboarding request to the Content Publishing Services team.\\r\\nTo create an onboarding request, visit [Onboard reference content on Microsoft Learn](https://learn.microsoft.com/help/onboard/reference?branch=main).  If you get a 404, you need to click on \\\"Sign In\\\" on the upper right to authenticate as a Microsoft employee.\\n\\n### Automatic refresh\\n\\nAPI references can be automatically refreshed on the latest API version after first time onboarding.\\r\\nTo enable automatic refresh, a README configuration file with a default tag referring to all spec files of the latest\\r\\nAPI version is __required__. See the [sample README].\\n\\n## Update an existing API reference\\n\\nIf your service is __already using README__ for publishing configuration and utilizing automatic refresh, as long as the\\r\\nREADME is properly updated, any API updates merged to the [Azure/azure-rest-api-specs] repository\\r\\nwill be automatically picked up by the [Azure REST API reference site on Microsoft Learn](https://learn.microsoft.com/rest/api/)  \\r\\nweekly (on Tuesdays).\\r\\nRequest an OOB publishing by [creating a Work Item in Azure DevOps]  \\r\\n(https://dev.azure.com/msft-skilling/Content/_workitems/create/User%20Story?templateId=39fb91e3-64a2-4c8a-83db-b2bdf3603dd3\\u0026ownerId=c4a28f90-17ae-4384-b514-7273392b082b),  \\r\\nif needed.\\r\\nIf you had to use the __alternative publishing configuration__ with direct paths to the OpenAPI spec files, you’ll need\\r\\nto have the publishing configuration manually updated to document any API updates in the [Azure/azure-rest-api-specs] repository.\\r\\nThe easiest way is to create a publishing request by [submitting a User Story in Azure DevOps]  \\r\\n(https://dev.azure.com/msft-skilling/Content/_workitems/create/User%20Story?templateId=39fb91e3-64a2-4c8a-83db-b2bdf3603dd3\\u0026ownerId=c4a28f90-17ae-4384-b514-7273392b082b).  \\r\\nOr you can create a pull request into the [REST API documentation repository]  \\r\\n(https://github.com/Azure/azure-docs-rest-apis) and update the publishing configuration.\\r\\nRead [this document on publishing configurations]  \\r\\n(https://learn.microsoft.com/help/onboard/admin/reference/rest/api-publishing-configuration)  \\r\\nfor more details on the recommended and alternative publishing configurations.\\n\\n## More info\\n\\n* Learn more about [onboarding reference content to Microsoft Learn](https://learn.microsoft.com/help/onboard/reference?branch=main).\\r\\n* For help and support, you can ask questions in the [\\\"API reference and Samples\\\" Teams Channel](https://teams.microsoft.com/dl/launcher/launcher.html?url=%2F_%23%2Fl%2Fchannel%2F19%3A7506cc3e220f430ab89d992c7db5284f%40thread.skype%2FAPI%2520Reference%2520and%2520Samples%3FgroupId%3Dde9ddba4-2574-4830-87ed-41668c07a1ca%26tenantId%3D72f988bf-86f1-41af-91ab-2d7cd011db47\\u0026type=channel\\u0026deeplinkId=4d931d59-a8ff-489e-a010-100f7f950bd6\\u0026directDl=true\\u0026msLaunch=true\\u0026enableMobilePage=true\\u0026suppressPrompt=true).\\r\\n[Sample OpenAPI spec]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/Microsoft.YourServiceName/stable/YYYY-MM-DD/YourServiceName.json\\r\\n[sample README]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/README.md\\r\\n[Azure/azure-rest-api-specs]: https://github.com/Azure/azure-rest-api-specs\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"Azure REST API, SDK development process with TypeSpec\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure-REST-API,-SDK-development-process-with-TypeSpec.md\\n\\n# Azure REST API, SDK development process with TypeSpec\\n\\n## Table Of Content\\n\\n1. Introduction\\r\\n2. Repo setup \\u0026 prerequisites\\r\\n3. Creating a new TypeSpec project\\r\\n4. Prepare and submit a Pull Request for reviewing\\r\\n5. Generate SDK code from a TypeSpec project\\n\\n### 1. Introduction\\n\\nThis document describes the processes of developing Azure REST APIs and SDKs with TypeSpec language. The steps below\\r\\n assumes that you are developing TypeSpec API specifications in the `azure-rest-api-specs` and `azure-rest-api-specs-pr`repos.\\r\\nIf you are developing within your own ADO repo first and then submitting into `azure-rest-api-specs` repos for review and\\r\\n release, you will need to copy the TypeSpec files over.\\n\\n### 2. Repo setup \\u0026 prerequisites\\n\\n- The main repos for Azure REST APIs are [azure-rest-api-specs](https://github.com/azure/azure-rest-api-specs) and [azure-rest-api-specs-pr](https://github.com/azure/azure-rest-api-specs-pr)\\r\\n repos. The `-pr` repo contains `RPSaaSMaster` and `RPSaaSDev` branches for ProviderHub based ARM service specs.\\r\\n#### 2.1 With local machine development\\r\\n- [Node.js LTS](https://nodejs.org/en) version 18 or above (LTS Recommended).\\r\\n Ensure you can run the npm command in a command prompt:\\r\\n  ```npm\\r\\n    npm --version\\r\\n  ```\\r\\n- Run following command in the **repository root folder**. This will install required packages such as TypeSpec\\r\\n compilers and Azure Library packages.\\r\\n  ```npm\\r\\n     npm ci\\r\\n  ```\\r\\n- Ensure you can run TypeSpec command within the repo folders.\\r\\n  ```npm\\r\\n     npx tsp --version\\r\\n  ```\\r\\n- One-time set up: Install TypeSpec VisualStudio or VS Code extensions to get syntex highlighting, tool tips in IDE:  \\r\\n  ```npm\\r\\n    npx tsp code install\\r\\n  ```\\r\\n  OR\\r\\n    ```npm\\r\\n      npx tsp vs install\\r\\n    ```\\r\\n#### 2.2  VS Code with local docker .devcontainer\\r\\nAll prerequisites have been installed in the dev container. You should to have `Docker Desktop` and `WSL2` running if\\r\\n you are on Windows machine.\\r\\nTo start, you just need to install `Dev Containers` VS code extension, then open the repo path.\\r\\n- VS Code will detect the .devcontainer and prompt you to reopen the workspace.\\r\\n- Alternatively, you can use Command Palette -\\u003e Dev Containers: Reopen in Container.  \\r\\nOnce VS Code reopened in Container, you can run any of the program below in the VS Code integrated terminal.\\r\\n#### 2.2 VS Code in browser via GitHub codespaces\\r\\nGitHub codespaces leverage the same dev container in the repo. The difference is it is hosted in cloud with VS Code in\\r\\n browser.\\r\\nTo start, you just need to browse to the `azure-rest-api-specs` repo, select `\\u003c\\u003e Code` drop down and follow `Codespaces`\\r\\n instructions.\\n\\n### 3. Creating a new TypeSpec project\\n\\nPlease first review recommended folder structure detailed in [this document](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/directory-structure.md).\\r\\n1. Under `[reporoot]\\\\specification`, create service folder directly.\\r\\n   - Select `(rest-api-spec repo) ARM` or `(rest-api-spec repo) Data-plane` and answer appropriate naming questions.\\r\\n   - If it's ARM service, the service folder would be `specification/{organization}/resource-manager/\\u003cRPNS\\u003e/{service}`.\\r\\n   - If it's Data Plane service, the service folder would be `specification/{organization}/data-plane/{service}`\\r\\n2. Create a new TypeSpec project based on Azure template with command:\\r\\n    ```cli\\r\\n       npx tsp init https://aka.ms/typespec/azure-init\\r\\n    ```\\r\\n3. Compile the generated TypeSpec project with command:\\r\\n    ```cli\\r\\n      npx tsp compile .\\r\\n    ```\\r\\n    The generated OpenAPI files should be correctly placed in the `{service}`folders following the naming conventions.\\r\\n4. Now the project has been set up. You can modify the sample and develop your own APIs with TypeSpec.\\n\\n### 4. Prepare and submit a Pull Request for reviewing\\n\\n1. Create a branch in your local repository for your changes.\\r\\n2. Create or update the TypeSpec files for your service.\\r\\n3. Add or update 'examples' files for each operation of your OpenAPI file.\\r\\n   The [oav](https://github.com/Azure/oav) provides two ways to generate OpenAPI examples:\\r\\n   1. Generating basic examples and then manually modify the values. It will generate two examples for each operation:\\r\\n    one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated\\r\\n     examples consist of random values for most types, you need replace them with meaningful values.\\r\\n       ```bash\\r\\n       oav generate-examples openapi.json\\r\\n       ```\\r\\n    Note, latest OAV tool should automatically generate the following. However, if you are generating the examples manually,\\r\\n     please ensure you have:\\r\\n    - include `title` field and make sure it is descriptive and unique for each operation.\\r\\n    - include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in OpenAPI.\\r\\n4. Add/update the `readme.md` file in the `{service}` folder to specify the version and location of the OpenAPI files. The `readme.md` is needed for both management-plane and data-plane services for REST API Docs generation.\\r\\n   Example:[sample-readme](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/readme.md)\\r\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\n\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\r\\n   - send a pull request to the original repo from your forked repo.\\r\\n   See the ARM Wiki for information on the [supported repos and branches for management-plane services](https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches).\\r\\n#### 4.1 Fix the errors of PR reviewing CI checks\\r\\nThe CI checks result will be commented on the PR. you can refer to the [CI fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\\r\\nNote:\\r\\nSince the OpenAPI is generated from TypeSpec, to change the OpenAPI, you must update the TypeSpec file and regenerate the\\r\\n OpenAPI and avoid updating OpenAPI directly to keep the consistency between OpenAPI and TypeSpec.\\r\\nFor support \\u0026 help, you can post a message to [TypeSpec Discussion - teams channel](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\\n\\n### 5. Generate SDK code from a TypeSpec project\\n\\nRefer to [Develop client libraries](https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop?tabs=management) for more details.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_07.md\",\"document_title\":\"How to create an Example for a typespec model?\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_07.md\\n\\n# How to create an Example for a typespec model?\\n\\n## question\\n\\nI was going through my Typespec file and adding @example() decorators on top of models but then I was informed by Azure SDK Q\\u0026A Bot that Azure API Spec doesn't support the @example() decorator? Instead I'm supposed to create .json files in the examples folder and link it by operaiton id. However, models don't have operation ids? or do they?\\n\\n## answer\\n\\nHere is some documentation on generating required examples: [x-ms-examples example files | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/x-ms-examples/).  \\r\\nNote that the examples that are required for specs at this point are operation examples (which include examples of model serialization in the operations that include those models).  The workflow is:\\r\\nDesign your API in TypeSpec\\r\\nGenerate an OpenApi doc by compiling your spec\\r\\nRun oav to generate examples for each of the operations (oav generates syntactically valid examples with the 'operationId'  and 'title' fields filled in)\\r\\nGo through the examples, replace values to make the examples more useful as documentation, and feel free to add  any examples for important scenarios that might be difficult to understand otherwise, or remove redundant examples (although you will need at least one per operation)\\r\\nCopy the examples into the `examples/\\u003capi-version\\u003e/` folder inside your typespec directory and the OpenApi emitter will automatically associate the examples with  the appropriate operatiosn through the 'operationId' in the example file,  using the 'title' field as the title of the example.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_21.md\",\"document_title\":\"Generating readme and examples files\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_21.md\\n\\n# Generating readme and examples files\\n\\n## question\\n\\nHi TypeSpec Discussion\\r\\n\\r\\nI have this PR [adding shared limit typespec by parthshah2305 · Pull Request #24115 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/24115) to add a new resource provider's typespec.\\r\\n\\r\\nTwo of the validations that are failing are due to missing readme and example files.\\r\\nCould anyone point me to some documentation around generating readme files?\\r\\n\\r\\nI also tried generating the example files locally, but it throws the below exception . I am not sure where this path to common-types is specified to change it to point it correctly.\\r\\n\\r\\n```\\r\\noav generate-examples .\\\\resource-manager\\\\Microsoft.Limit\\\\Limit\\\\stable\\\\2025-08-15\\\\Limit.json\\r\\n{\\r\\n  message: `fatal error: ENOENT: no such file or directory, open 'D:\\\\\\\\repos\\\\\\\\azure-rest-api-specs-pr\\\\\\\\common-types\\\\\\\\resource-management\\\\\\\\v5\\\\\\\\types.json', {\\\"errno\\\":-4058,\\\"code\\\":\\\"ENOENT\\\",\\\"syscall\\\":\\\"open\\\",\\\"path\\\":\\\"D:\\\\\\\\\\\\\\\\repos\\\\\\\\\\\\\\\\azure-rest-api-specs-pr\\\\\\\\\\\\\\\\common-types\\\\\\\\\\\\\\\\resource-management\\\\\\\\\\\\\\\\v5\\\\\\\\\\\\\\\\types.json\\\"}`,\\r\\n  level: '\\\\x1B[31merror\\\\x1B[39m'\\r\\n}\\r\\n```\\n\\n## answer\\n\\nThere're several problems with your PR. \\r\\n1.the folder structure is incorrect with your *.tsp files, you should put them under specification/limit/resource-manager/Microsoft.Limit/Limit/ as well as the tspconfig.yaml, you can take the widget specs as an example https://github.com/Azure/azure-rest-api-specs/tree/main/specification/widget/resource-manager \\r\\n2.Assuming you are an RPaaS services (because you are a new service and in azure-rest-api-specs-pr repo), you have to have a readme.md under resource-manager folder and which should contains the minimal information which is required from RPaaS to know that your service is a RPaaS services, you can also take a look at widget's example\\r\\n```\\r\\nopenapi-type: arm\\r\\nopenapi-subtype: rpaas\\r\\n```\\r\\nYou need to pay attention to the output file path in your tspconfig.yaml under the `@azure-tools/typespec-autorest` section https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/tspconfig.yaml#L9-L13 \\r\\n```\\r\\n    emitter-output-dir: \\\"{project-root}\\\"\\r\\n    # TODO: Does anything need this set, if it's not used in output-file?  Currently required by TSV.\\r\\n    azure-resource-provider-folder: \\\"resource-manager\\\"\\r\\n    output-file: \\\"{version-status}/{version}/widget.json\\\"\\r\\n    arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n```\\r\\n1.because this is the file oav is trying to find https://github.com/Azure/azure-rest-api-specs-pr/blob/d1fd46b8d93ae2cdd50e282768fe5e82e718e893/specification/common-types/resource-management/v5/types.json\\r\\n2.You also need to have a readme.md under specification/limit/resource-manager/Microsoft.Limit/Limit/ ,  similar like this one https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/readme.md where you have to have references to all your swagger files with tags and its input-files\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Resources\\n### Other sites\\n- [private specs repo]\\r\\n- [public specs repo]\\r\\n- [Service Tree lifecycle stages][service tree lifecycle stages]\\r\\n- [Spec directory structure]\\r\\n- [Versioning policy for Azure services, SDKs, and CLI tools]\\r\\n\\r\\n[AFEC]: https://armwiki.azurewebsites.net/rp_onboarding/afec/FeatureExposureControl.html\\r\\n[aka.ms/armofficehoursinfo]: https://aka.ms/armofficehoursinfo\\r\\n[aka.ms/azapi/officehours]: https://aka.ms/azapi/officehours\\r\\n[ARM branches]: https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches\\r\\n[ARM lifecycle stages requirements]: https://eng.ms/docs/products/arm/rp_onboarding/process/onboarding#5-lifecycle-stages-requirements\\r\\n[ARM preview guidelines]: https://armwiki.azurewebsites.net/rp_onboarding/process/onboarding.html#a-private-preview\\r\\n[ARM Resource Provider onboarding]: https://armwiki.azurewebsites.net/rp_onboarding/process/onboarding.html\\r\\n[ARM spec onboarding]: https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html\\r\\n[issue #7411]: https://github.com/Azure/azure-sdk-tools/issues/7411\\r\\n[mirror-repos]: https://dev.azure.com/azure-sdk/internal/_build?definitionId=1752\\u0026_a=summary\\r\\n[Obsolete ShiftLeft branch]: https://dev.azure.com/azure-sdk/internal/_wiki/wikis/internal.wiki/606/Enable-API-Spec-Pipeline\\r\\n[private specs repo]: https://github.com/Azure/azure-rest-api-specs-pr\\r\\n[public specs repo]: https://github.com/Azure/azure-rest-api-specs\\r\\n[service tree lifecycle stages]: https://eng.ms/docs/cloud-ai-platform/azure-edge-platform-aep/aep-engineering-systems/engineering-intelligence-standards/service-tree/service-trees-team-doc/metaconcepts/lifecycle\\r\\n[Spec directory structure]: https://aka.ms/azsdk/spec-dirs\\r\\n[Versioning policy for Azure services, SDKs, and CLI tools]: https://learn.microsoft.com/en-us/azure/developer/intro/azure-service-sdk-tool-versioning\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#azure-resource-manager#step05.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step05\",\"content\":\"# 6. Complete Example and Generate OpenApi 2.0 spec\\nTo generate an OpenAPI v2 (Swagger) specification from the service definition, run the following command inside of the project folder:\\r\\n\\r\\n```\\r\\ntsp compile . --emit @azure-tools/typespec-autorest\\r\\n```\\r\\n\\r\\nThis will create a file in the `tsp-output` subfolder called `openapi.json`.\\r\\n\\r\\nYou can learn more about the `typespec-autorest` emitter and its options by reading its [README.md](https://github.com/Azure/typespec-azure/blob/main/packages/typespec-autorest/README.md).\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#createproject.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/createproject\",\"content\":\"# Creating a project\\n### Target Users\\n- **Rest-API-Spec Repo Projects**: Ideal for those contributing directly to the Azure REST API specifications, ensuring production-quality SDK generation.\\r\\n- **Standalone Projects**: Suited for API-first development, allowing users to generate OpenAPI specs, service code, and clients without conforming to the specs repo's structure.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#createproject.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/createproject\",\"content\":\"# Creating a project\\nIf you've installed TypeSpec on your local machine, you can create a new TypeSpec project by following these steps:\\r\\n1. **Open your command prompt** (PowerShell, cmd.exe, bash, etc.), create an empty folder for your new project, and `cd` into it.\\r\\n2. If creating a new service in the [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) repository, create the new service folder following our [directory structure guidelines](https://aka.ms/azsdk/spec-dirs).\\r\\n3. To create a new Azure service specification, use the `tsp init` command:\\r\\n```bash\\r\\ntsp init https://aka.ms/typespec/azure-init\\r\\n```\\r\\nYou will be prompted with a few questions regarding the service template, project name, and library updates.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#getting-started-rest#01-setup-basic-syntax.mdx\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/getting-started/getting-started-rest/01-setup-basic-syntax\",\"content\":\"# Getting Started with TypeSpec For REST APIs\\n## Introduction\\n### What is TypeSpec?\\nTypeSpec is a language and toolset developed by Microsoft for defining data models and service APIs. It provides a structured way to describe the shape and behavior of data and services, ensuring consistency and reducing errors in API development. With TypeSpec, you can generate code, documentation, and other artifacts from your API definitions, making it easier to maintain and evolve your services. Microsoft uses TypeSpec internally to define APIs for various products and services, including Azure.\\r\\n\\r\\nTypeSpec is used to define the **interface** of your API, which clients will use to interact with resources provided by your service. This includes specifying the operations, request and response models, and error handling mechanisms. The actual API logic is implemented in the backend service, which processes the requests and communicates with the database.\\r\\n\\r\\nBefore we start writing TypeSpec code, we need to set up our development environment. For detailed instructions on setting up your environment, please refer to the [Installation Guide](../../../).\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"API-Doc-Preview.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/API-Doc-Preview\",\"content\":\"## How do I onboard my API to publish docs?\\nFollow instructions at [Publish REST API reference docs\\r\\n](https://eng.ms/docs/products/azure-developer-experience/design/api-docs)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-repos.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-repos\",\"content\":\"# Azure REST API specs repositories on GitHub\\nThe REST API descriptions for all Azure services should be published in the Azure REST API specs GitHub repositories.\\r\\n\\r\\nThe [Azure/azure-rest-api-specs] is the public repository. All work done in this repository is public, i.e. visible to\\r\\neveryone, including people outside of Microsoft. Any Azure REST API specification updates must be merged to the `main`\\r\\nbranch as part of the process of releasing those updates to Microsoft customers.\\r\\n\\r\\nThe [Azure/azure-rest-api-specs-pr] is the private repository (the \\\"pr\\\" stands for \\\"private\\\"). It is for work that must\\r\\nremain private until it is ready to be published. For example, if your team is working on a new product with a new Azure\\r\\nResource Manager (ARM) or Resource Provider (RP) namespace, you want to keep developing it in the private repository\\r\\nuntil you have drafted, tested and went through the API review process. Only after this is done, you must merge your\\r\\nchanges to the `main` branch in the public repository.\\r\\n\\r\\nThe `main` branch in the private repository is read-only, as it is mirrored from the public repository `main` branch.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# Create a pull request with your Azure REST API spec update\\n## Before you begin\\nEnsure that:\\r\\n\\r\\n- You have onboarded to Azure SDK team processes by following our [onboarding process](xref:onboard).\\r\\n- You have [access](xref:access) to the GitHub repositories and respective Azure open source organization.\\r\\n- You understand the conventions for the [Azure REST API specs GitHub repositories](xref:api-repos).\\r\\n- You have reviewed and validated your REST API spec updates within your team, using a development branch in one of\\r\\n  the specs repos.\\r\\n- You are ready to release the features described in your REST API spec updates in a private preview, public preview,\\r\\n  or GA release.\\r\\n\\r\\n\\u003e[!TIP]\\r\\n\\u003e We are piloting our new AzSDK tools MCP server which includes the ability to generate the SDKs and\\r\\n\\u003e create a draft pull request in the respective language repository. Refer to [AzSDK tools MCP server](xref:azsdk-tools-mcp)\\r\\n\\u003e for instructions on how to install it and use it.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-tooling.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-tooling\",\"content\":\"# Use tools to create and validate Azure REST APIs specs\\n## [Author With TypeSpec](#tab/author-with-typespec)\\nAuthor specs with TypeSpec (**recommended approach**)\\r\\n\\r\\nREST APIs authored in [TypeSpec](xref:api-typespec) with the [Azure TypeSpec libraries] have validation built in.\\r\\nCompiling the TypeSpec definition will validate the REST API against the Azure API guidelines.\\r\\nThe TypeSpec compiler will also generate an [OpenAPI](xref:api-openapi) definition for the REST API.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e TypeSpec has [plugins for Visual Studio and Visual Studio Code][TypeSpec plugins] that will highlight errors and\\r\\nwarnings in your TypeSpec definition.\\r\\n\\r\\nTypeSpec is the recommended way for generating OpenAPI specs.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-repos.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-repos\",\"content\":\"# Azure REST API specs repositories on GitHub\\n## Publishing your spec to the spec repos\\nTo publish your spec to the API specs repositories, you must first understand what kind of API version you are\\r\\ntrying to publish and make a PR to appropriate branch based on that. Read about this in [this article](xref:pr-move-private-to-public).\\r\\n\\r\\n\\u003c!-- links --\\u003e\\r\\n[Azure/azure-rest-api-specs]: https://github.com/Azure/azure-rest-api-specs\\r\\n[Azure/azure-rest-api-specs-pr]: https://github.com/Azure/azure-rest-api-specs-pr\"}]", "inputs.latency": 356.6647894382477, "inputs.response_length": 2174, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://eng.ms/docs/products/azure-developer-experience/design/api-docs", "https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-specs", "https://github.com/Azure/azure-rest-api-specs/wiki/API-Doc-Preview"], "inputs.testcase": "Official API documentation publishing", "outputs.similarity.similarity": 2.0, "outputs.similarity.gpt_similarity": 2.0, "outputs.similarity.similarity_result": "fail", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1392, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1393, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Official API documentation publishing\\\\n\\\\nquestion: General,\\\\nHow do we generate official API documentation like below?\\\\nAzure REST API reference documentation | Microsoft Learn\\\\nFor a new RP like below. Is this done by the SDK team?\\\\n[azure-rest-api-specs/specification/cdn/resource-manager/Microsoft.Cdn/Cdn/preview/2024-07-22-previe\\\\u2026](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/cdn/resource-manager/Microsoft.Cdn/Cdn/preview/2024-07-22-preview/edgeaction.json)\\\", \\\"response\\\": \\\"The process for generating and publishing official Azure REST API reference documentation on Microsoft Learn is a coordinated effort between the service team (who authors the spec) and the Content Publishing Services team. It is NOT solely done by the SDK team.\\\\n\\\\nHere\\\\u2019s how the process works for a new Resource Provider (RP):\\\\n\\\\n1. **Author the REST API spec in TypeSpec Azure**: All new Azure RPs must describe their REST APIs using TypeSpec Azure (OpenAPI is supported only by exception). This spec is placed in the correct directory structure within the `azure-rest-api-specs` repo, such as the path you provided for `edgeaction.json`.\\\\n\\\\n2. **Merge the spec and README into the repo**: Once your TypeSpec (and generated OpenAPI) files are reviewed and merged into the `main` branch of the `Azure/azure-rest-api-specs` repository, you\\\\u2019re ready for publishing.\\\\n\\\\n3. **Onboard to Content Publishing Services**: After merging, the service team (not the SDK team) must submit an onboarding request to the Content Publishing Services team via the official onboarding portal. This is required for the API reference docs to be published on Microsoft Learn. You need a README configuration file with a default tag that refers to all spec files of the latest API version.\\\\n\\\\n   - Onboarding portal: https://learn.microsoft.com/help/onboard/reference?branch=main\\\\n\\\\n4. **Automatic Weekly Refresh**: Once onboarded, API references will be automatically refreshed every week (Tuesday) if the README configuration is set up correctly. Any subsequent spec changes merged to `main` will be picked up and published automatically.\\\\n\\\\n5. **Manual/Out-of-Band Publishing**: If you used alternative publishing configuration or need a manual refresh, you can submit a work item in Azure DevOps or create a PR in the REST API documentation repo to update publishing configuration.\\\\n\\\\n**Summary:**\\\\n- The service team authors the spec and initiates onboarding.\\\\n- The Content Publishing Services team handles publishing to Microsoft Learn after onboarding.\\\\n- The SDK team is not responsible for publishing API reference documentation.\\\\n\\\\nSee the full process and onboarding instructions in the references below.\\\", \\\"ground_truth\\\": \\\"You can find information about this here: https://eng.ms/docs/products/azure-developer-experience/design/api-docs\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"2\"}]"}, {"inputs.query": "title: Problem with merging PR into target branch\n\nquestion: Hello team,\nI am having trouble merging my PR. It seems I am being blocked by breaking changes errors. After consulting with the breaking changes team, they say the pr pipeline must be bust. Can you please help on this.\nPR: Enabling free services acquisition via APIs by adrianta · Pull Request #25230 · Azure/azure-rest-ap…", "inputs.ground_truth": "You are confusing two checks:\nBreaking Changes(Cross-Version) - Analyze Code\nimplementation detail\nnot required\nBreaking Changes(Cross-Version)\nrequired\npassing due to label\nI suspect your PR cannot be merged, because your github account is missing one or more required permissions. https://aka.ms/azsdk/access\nThis must be public, not private: https://github.com/orgs/Azure/people?query=adrianta\nOnce your permissions are fixed, push a change to your PR (empty commit is fine) to rerun checks.", "inputs.response": "Based on your description, your PR is blocked due to breaking changes errors reported by the CI pipeline. Here is how you should proceed:\n\n1. **Understand the Breaking Changes Policy**: According to Azure's guidelines, any breaking changes—whether across API versions or within a single API version—are strictly controlled. You cannot merge a PR with unresolved breaking changes into a production branch (such as `main`). This is enforced by the automated CI checks. See references for policy details.\n\n2. **Diagnose the Pipeline Failure**:\n   - The error is not a pipeline bug, but the intended behavior of the system to protect customers from accidental breaking changes. The pipeline checks are required and must pass.\n   - Review the detailed error report in your PR. If you are introducing a new API version, ensure that all breaking changes (e.g., removing properties, changing required/optional status, etc.) are either intentional and approved or fixed.\n\n3. **Resolution Steps**:\n   - If all reported breaking changes are intentional, you must follow the official Azure Breaking Change Review process. Go to https://aka.ms/brch, submit your request, and obtain approval from the Breaking Change Review Board. Once approved, apply the relevant approval label (such as `BreakingChange-Approved-BugFix`, `BreakingChange-Approved-UserImpact`, etc.) to your PR as instructed in the \"Next Steps to Merge\" comment.\n   - If the breaking changes are not intentional, update your TypeSpec files to resolve the breaking changes, regenerate your OpenAPI specs, and re-run the pipeline. Never edit the OpenAPI directly; always fix the source TypeSpec files.\n   - If you believe the pipeline is reporting a false positive (for example, if the breaking change is actually not breaking, or due to a migration scenario), review the [Resolving Pipeline Failures guide](https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline) and validate locally using `npm ci` and `npx tsv`.\n\n4. **You Cannot Suppress Required CI Checks**: Azure guidelines do not allow suppression or bypassing of breaking change checks for PRs targeting production branches unless you have explicit approval from the review board.\n\n5. **If Still Blocked**: If you have completed all the above and the checks still fail unexpectedly, verify your branch is up to date with the latest `main` and re-run the validation locally. If the issue persists and is reproducible on a clean machine, request help via the TypeSpec Discussion Teams channel (link below).\n\n**Summary**: You must resolve or get approval for all breaking changes before you can merge your PR. This is not a pipeline bug, but the required policy for Azure REST API specs. Follow the official review and approval process for breaking changes.\n", "inputs.context": "[{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"API-Spec-Review-FAQ.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ\",\"content\":\"# API-Spec-Review-FAQ.md\\n\\nAnswers to frequently asked questions in the [Api Spec Review](https://teams.microsoft.com/l/channel/19%3A0351f5f9404446e4b4fd4eaf2c27448d%40thread.skype/API%20Spec%20Review?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47). Within that channel, EngSys should be answering questions about validation pipelines and tools that run in those pipelines. Specific questions about typespec, the API Review process, etc. should be answered by others who specialize in those topics. \\r\\n\\r\\n| If the question is about | The answer should be | \\r\\n| --- | --- | \\r\\n| Authoring typespec | Send to [TypeSpec Discussions](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) | \\r\\n| My PR is ready to review, will someone review it? | See the \\\"Next steps to merge\\\" comment in your PR and follow directions to ensure you're in the review queue. No need to post here. | \\r\\n| API Doc Preview is broken | If the error message linked doesn't make sense, follow instructions at [Troubleshooting REST API documentation](https://eng.ms/docs/products/azure-developer-experience/design/api-docs-troubleshooting). API Doc Preview is not a required check so you can ignore the failure if it's not relevant to your documentation needs. |\\r\\n| My PR needs to be reviewed by the ARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this.\\n\\nARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this. See documentation: [Update your branch with changes from main](https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish#update-your-branch-with-changes-from-main). |\\r\\n| I need to set up suppressions for LintDiff violations in my PR | See [Adding Scoped Suppressions](https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff) | \\r\\n| I have specific questions about the inner workings of ARM, testing changes to APIs, or rollout/release schedules | Talk to the ARM team: https://aka.ms/armofficehoursinfo |\\r\\n| I see an Avocado error `MULTIPLE_API_VERSION` | There is a coordinated effort to fix this. Reach out to the relevant parties. [This PR](https://github.com/Azure/avocado/pull/157) gives more context on why this was upgraded to an error. If relevant parties agree, the PR can be unblocked by adding the `Approved-Avocado` label to the PR. |\\r\\n| I merged a PR, when does the REST API documentation update on the Learn site? | Docs are published every week on Tuesdays | \\r\\n| If the specs in the standard branches of `RPSaaSMaster` and `RPSaaSDev` are out of sync, who is responsible for syncing them with main? | The spec owner is responsible for syncing their service’s spec files from `main` to `RPSaaSMaster/RPSaaSDev` to ensure consistency across branches. |\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Breaking-Changes.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Breaking-Changes\",\"content\":\"# SDK-Breaking-Changes.md\\n\\n| Short Link: | [aka.ms/azsdk/sdk-suppression](https://aka.ms/azsdk/sdk-suppression) |\\r\\n|--|--|\\n\\n# Table of Contents\\n\\n- [Overview](#overview)\\r\\n- [How to Suppress the SDK Breaking Changes](#how-to-suppress-the-sdk-breaking-changes)\\r\\n- [How Does the Suppression Work](#how-does-the-suppression-work)\\r\\n- [How to Get the Suppression Reviewed](#how-to-get-the-suppression-reviewed)\\n\\n## Overview\\n\\nWhen a specification pull request has breaking change for a specific SDK language, such as `Go`, the pull request will be labelled with \\\"BreakingChange-Go-Sdk\\\". According to [the design principles of Azure SDK](https://azure.github.io/azure-sdk/general_introduction.html#dependable), breaking changes are more harmful to a user’s experience than most new features and improvements are beneficial. Therefore, the pull request author will be strongly encouraged to update the API specification to remove the breaking changes for the SDK. If the breaking change cannot be mitigated by a specification change, the author will need to suppress the breaking changes and have the suppression reviewed. See the following section for details on how to suppress breaking changes.\\r\\n\\r\\nOnce the suppression is added to the pull request, SDK reviewers will evaluate the suppressions and either provide feedback or approve the suppressions. When the suppressions have been approved, the SDK breaking change review is complete and the pull request can proceed to the next stage.\\r\\n\\r\\n\\u003e Note: both the suppressions review and the SDK breaking change review will be conducted proactively by SDK reviewers, and the expected completion time is around 48 business hours.\\n\\n## How to Suppress the SDK Breaking Changes\\n\\nTo suppress SDK breaking changes, go to the `SDK Validation *` CI check result for a specific SDK language, such as \\\"SDK Validation - Go\\\". Click on the link of **View more details on Azure Pipelines** to browse to the azure pipeline result page. Then download the artifact of **spec-gen-sdk logs**. There is a html report with the name ended by \\\"-gen-result.html\\\". Open the html report then look for the `Absent SDK breaking changes suppressions` section, as shown in the following code block:\\r\\n\\r\\n```yaml\\r\\nAbsent SDK breaking changes suppressions\\r\\n- Function `*LinkerClient.BeginCreateOrUpdate` has been removed\\r\\n- Function `*LinkerClient.NewListPager` has been removed\\r\\n```\\r\\n\\r\\n\\u003e Note: refer to https://aka.ms/azsdk/sdk-automation-faq to download the html report.\\n\\n### Next Steps\\n\\n1. The pull request authors create a file called `sdk-suppressions.yaml` if it doesn't already exist in your service folder in the `azure-rest-api-specs` repository.\\r\\n    - For TypeSpec scenarios, `sdk-suppressions.yaml` should be placed in the root folder of the TypeSpec project, which also contains the `tspconfig.yaml` file. For example, refers to the location for [Contoso.Management](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/Contoso.Management).\\r\\n    - For OpenAPI scenarios, `sdk-suppressions.yaml` should be placed in the `{service}\\\\resource-manager` folder. For example, see the location for the [contosowidgetmanager resource provider](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/resource-manager).\\r\\n\\r\\n2. The pull request authors copy every line under the `Absent SDK breaking changes suppressions` section to the suppression file in the following format:\\r\\n\\r\\n``` yaml\\r\\nsuppressions:\\r\\n  azure-sdk-for-go:\\r\\n    - package: 'sdk/resourcemanager/servicelinker/armservicelinker'\\r\\n      breaking-changes:\\r\\n        - Function `*LinkerClient.BeginCreateOrUpdate` has been removed\\r\\n        - Function `*LinkerClient.NewListPager` has been removed\\r\\n```\\r\\n\\r\\n3. The pull request authors add this suppression file change to your spec pull request. Then the suppressions will be recognized by the bot, and the corresponding suppression label will be added to the spec pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression` will be added to the pull request.\\r\\n\\r\\n4. The SDK reviewers will evaluate the suppressions and either approve them or provide feedback. If the suppressions are approved, the corresponding approval label will be added to the pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression-Approved` will be added to the pull request.\\n\\n## How Does the Suppression Work\\n\\nThe suppression file will remain with the specification move with it to other branches or repositories(such as from the private specification repository to the public specification repository). The suppressions can be deleted after the SDK has been released to the public.\\n\\n## How to Get the Suppression Reviewed\\n\\nSDK reviewers will monitor the specification pull requests with breaking change suppression lables. For example, for the  `azure-sdk-for-go`, the label is `BreakingChange-Go-Sdk-Suppression`. They will evaluate the suppressions and either approve them or provide feedback. If the suppressions are approved, the corresponding approval label will be added to the pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression-Approved` will be added to the pull request. Once the suppression review is complete, the pull request can proceed to the next stage.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#pipeline.md\",\"document_title\":\"Resolving Pipeline Failures\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline\",\"content\":\"# migrate-swagger#faq#pipeline.md\\n\\n# Resolving Pipeline Failures\\n\\nThis document explains how to resolve pipeline failures in TypeSpec migration PRs.\\n\\n## Swagger BreakingChange\\n\\n### Multiple OpenAPI Files Before Migration\\n\\nThis pipeline will fail if there is more than one OpenAPI file in the latest version. See the detailed explanation in this [issue](https://github.com/Azure/typespec-azure/issues/2194#issue-2844564216).\\r\\n\\r\\nTo properly identify real breaking changes, use the \\\"TypeSpec Migration Validation\\\" pipeline instead:\\r\\n\\r\\n1. Navigate to the TypeSpec Migration Validation pipeline\\r\\n2. Check the report on the \\\"Summary\\\" page\\r\\n3. The output should match exactly what you see in [this step](../01-get-started.md#review-and-adjust-the-typespec) on the local machine\\r\\n4. Review the changes to verify they are expected\\n\\n### Single OpenAPI File Before Migration\\n\\nIf you have only one OpenAPI file in the latest version, use this pipeline to detect breaking changes. If it fails, refer to [Resolving OpenAPI Breaking Change Violations](./faq/breakingchange.md).\\r\\n\\r\\n**Known Issues**: The following pipeline failures are false alerts and can be safely ignored:\\r\\n\\r\\n#### 1017 - ReferenceRedirection\\r\\n\\r\\nThis typically occurs when an inlined anonymous enum becomes a named enum.\\r\\n\\r\\n**Before:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"enumProperty\\\": {\\r\\n    \\\"type\\\": \\\"string\\\",\\r\\n    \\\"enum\\\": [\\r\\n      \\\"If\\\",\\r\\n      \\\"Else\\\",\\r\\n      \\\"None\\\"\\r\\n    ],\\r\\n    \\\"x-ms-enum\\\": {\\r\\n      \\\"name\\\": \\\"EnumType\\\",\\r\\n      \\\"modelAsString\\\": true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n**After:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"enumProperty\\\": {\\r\\n    \\\"$ref\\\": \\\"#/definitions/EnumType\\\"\\r\\n  }\\r\\n},\\r\\n\\\"EnumType\\\": {\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"If\\\",\\r\\n    \\\"Else\\\",\\r\\n    \\\"None\\\"\\r\\n  ],\\r\\n  \\\"x-ms-enum\\\": {\\r\\n    \\\"name\\\": \\\"EnumType\\\",\\r\\n    \\\"modelAsString\\\": true\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n#### 1023 - TypeFormatChanged\\r\\n\\r\\nThe error message `The new version has a different format 'uri' than the previous one ''.` on the `nextLink` property is expected because the [page template defines the `nextLink` as `uri`](./mustread.md#using-page-model-from-azurecore-library).\\r\\n\\r\\n#### 1047 - XmsEnumChanged\\r\\n\\r\\nAfter migration, all models (including enums) will have capitalized names.\\r\\n\\r\\n**Before:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"someProperty\\\": {\\r\\n    \\\"type\\\": \\\"string\\\",\\r\\n    \\\"enum\\\": [\\r\\n      \\\"If\\\"\\r\\n    ],\\r\\n    \\\"x-ms-enum\\\": {\\r\\n      \\\"name\\\": \\\"someName\\\",\\r\\n      \\\"modelAsString\\\": true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n**After:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"someProperty\\\": {\\r\\n    \\\"$ref\\\": \\\"#/definitions/SomeName\\\"\\r\\n  }\\r\\n},\\r\\n\\\"SomeName\\\": {\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"If\\\"\\r\\n  ],\\r\\n  \\\"x-ms-enum\\\": {\\r\\n    \\\"name\\\": \\\"SomeName\\\",\\r\\n    \\\"modelAsString\\\": true\\r\\n  }\\r\\n}\\r\\n```\\n\\n## Swagger ModelValidation\\n\\nSome validation rules may fail because TypeSpec fixes certain legacy patterns. Review the known issues below and take appropriate action.\\n\\n### INVALID_FORMAT: Object didn't pass validation for format uri: {nextlink}\\n\\n#### Root Cause\\r\\n\\r\\nThe response model of a pageable operation uses the Azure.Core.Page template:\\r\\n\\r\\n```typespec\\r\\nmodel ResponseModel is Azure.Core.Page\\u003cItemType\\u003e;\\r\\n```\\r\\n\\r\\nThis standardized approach changes the `nextLink` type from plain `string` to `uri`. If previous example's `nextLink` value isn't a valid URI, it will cause a validation error.\\r\\n\\r\\n#### Resolution\\r\\n\\r\\nChoose one of the following options:\\r\\n\\r\\n1. **Update your example** to include a valid URI value, or\\r\\n2. **Modify your TypeSpec response model** to use a custom definition if the nextLink returned by the service is not a URI:\\r\\n\\r\\n```typespec\\r\\nmodel ResponseModel {\\r\\n  @pageItems\\r\\n  value: ItemType[];\\r\\n\\r\\n  @nextLink\\r\\n  nextLink?: string;\\r\\n}\\r\\n```\\n\\n### INVALID_FORMAT: Object didn't pass validation for format arm-id\\n\\n#### Root Cause\\r\\n\\r\\nThis error typically occurs when a custom resource definition is mapped to a resource defined in common-types. See [this section](./breakingchange.md#using-resources-from-common-types) for details. The `id` property for `Resource` in common-types may use the `arm-id` format, depending on the version of common-types used.\\r\\n\\r\\n#### Resolution\\r\\n\\r\\nUpdate the value in the example file to meet the `arm-id` format requirements.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Validation.md\",\"document_title\":\"Table of Contents\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation\",\"content\":\"# TypeSpec-Validation.md\\n\\n# Table of Contents\\n\\n- [Running Locally](#running-locally)\\r\\n- [Examples Source and Destination](#examples-source-and-destination)\\r\\n- [Validation Rule Suppression](#validation-rule-suppression)\\r\\n- [Rules](#rules)\\r\\n  - [SdkTspConfigValidation](#SdkTspConfigValidation)\\r\\n    - [JavaScript](#JavaScript-Sub-Rules)\\r\\n    - [Python](#Python-Sub-Rules)\\r\\n    - [Go](#Go-Sub-Rules)\\r\\n    - [Java](#Java-Sub-Rules)\\r\\n    - [.Net](#Net-Sub-Rules)\\n\\n# Running Locally\\n\\nTo ensure you see the same results from TypeSpecValidation in your PR check and `tsv` on your local machine:\\r\\n1. Merge latest from parent (e.g. `main` or `RPSaaSMaster`) to your PR branch\\r\\n2. Run locally\\r\\n   1. `git clean -xdf` (may revert any local changes)\\r\\n   2. `git pull`\\r\\n   3. `npm ci`\\r\\n   4. `npx tsv specification/widget/resource-manager/Microsoft.Widget/Widget`\\r\\n   5. `git status`\\r\\n   6. If any changes, `git add`, `git commit`, `git push` to update your PR.\\r\\n3. If you are still having problems, try cloning your branch to a new folder, or try on another machine.\\r\\n4. If the problem can be reproduced on a clean machine, request assistance from the [TypeSpec Discussion](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) teams channel.\\n\\n# Examples Source and Destination\\n\\nIf you are having problems with diffs from \\\"tsp compile\\\" related to examples, ensure you understand how examples flow from source to destination.\\r\\nThe **source** of examples is under your TypeSpec source code folder, and the **destination** of examples is under the Swagger folder.  The TypeSpec compiler copies from source to destination.  In our sample: \\r\\n* source\\r\\n  * https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/Contoso.Management/examples/2021-10-01-preview \\r\\n* destination\\r\\n  * https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/resource-manager/Microsoft.Contoso/preview/2021-10-01-preview/examples\\r\\nIf you are changing examples, you must **first** change the copy under your TypeSpec folder, and then run `tsp compile` (or `tsv` which calls `compile`) to update the copies in your Swagger folder.\\n\\n# Validation Rule Suppression\\n\\nYou can suppress specific validation rules within `TypeSpecValidation` by creating or modifying a `suppressions.yaml` file in the root directory of your service specification.\\r\\n\\u003e **Note:** Currently, only the `SdkTspConfigValidation` rule supports suppression.\\n\\n## Suppressing SdkTspConfigValidation Rules\\n\\nThe `SdkTspConfigValidation` rule is responsible for validating emitter options and parameters defined in your `tspconfig.yaml` file. You have the flexibility to suppress this rule entirely or target specific sub-rules within it.\\n\\n### Suppress the Entire SdkTspConfigValidation Rule\\n\\nIf you need to skip **all** validation checks for emitter options and parameters within a particular `tspconfig.yaml` file, you can suppress the entire `SdkTspConfigValidation` rule.\\r\\nTo do this, add or update the `suppressions.yaml` file in your service's root folder with the following content:\\r\\n```yaml\\r\\n- tool: TypeSpecValidation\\r\\n  paths:\\r\\n    # Specify the path to the tspconfig.yaml file where suppression should apply\\r\\n    - /path/to/tspconfig.yaml\\r\\n  rules:\\r\\n    - SdkTspConfigValidation\\r\\n  reason: the-reason-you-want-to-suppress # Explain why this suppression is necessary\\r\\n```\\n\\n### Suppress Specific Sub-rules within SdkTspConfigValidation\\n\\nIf you only need to bypass validation for **specific** emitter options or parameters, you can suppress individual sub-rules.\\r\\nAdd or update your `suppressions.yaml` file with the following structure, specifying the sub-rules to ignore:\\r\\nSub-rule Syntax:\\r\\n- For parameters: `parameters.\\u003cparameter-key\\u003e.default`\\r\\n- For emitter options: `options.\\u003cemitter-name\\u003e.\\u003coption-key\\u003e`\\r\\n- For nested options (e.g., `package-details: name: \\\"xxx\\\"`), use dot notation: `options.\\u003cemitter-name\\u003e.package-details.name`\\r\\n```yaml\\r\\n- tool: TypeSpecValidation\\r\\n  paths:\\r\\n    # Specify the path to the tspconfig.yaml file where suppression should apply\\r\\n    - /path/to/tspconfig.yaml\\r\\n  rules:\\r\\n    - SdkTspConfigValidation\\r\\n  sub-rules:\\r\\n    # Example: Suppress validation for a specific parameter's default value\\r\\n    - parameters.\\u003ckey-to-validate\\u003e.default \\r\\n    # Example: Suppress validation for a specific emitter option\\r\\n    - options.\\u003cemitter-name\\u003e.\\u003ckey-to-validate\\u003e\\r\\n    # Example: Suppress validation for a nested emitter option\\r\\n    - options.\\u003cemitter-name\\u003e.package-details.name \\r\\n  reason: the-reason-you-want-to-suppress # Explain why this suppression is necessary\\r\\n```\\n\\n# Rules\\n\\n## SdkTspConfigValidation\\n\\n### Parameters\\n\\n- **`parameters.default.service-dir`**\\r\\n  - Allowed values: strings that matches the regex `/^sdk\\\\/.*$/`\\r\\n  - example: `sdk/aaa`\\n\\n### JavaScript Sub Rules\\n\\nPlane\\r\\n- [**`@azure-tools/typespec-ts.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L33)\\r\\n  - Allowed values: strings that matches the regex `/^(?:[a-z]+-)+rest$/`\\r\\n  - example: `arm-aaa-rest`\\r\\n- [**`@azure-tools/typespec-ts.options.package-details.name`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L35)\\r\\n  - Allowed values: strings that matches the regex `/^\\\\@azure-rest\\\\/[a-z]+(?:-[a-z]+)*$/`\\r\\n  - example: `@azure-rest/aaa-bbb`\\n\\n\\u003e Please follow the below steps to configure. If you encounter any issues, please seek help in the \\u003ca href=\\\"https://teams.microsoft.com/l/channel/19%3A408c5f1322ee4303b02b5da9c5ff6137%40thread.skype/Language%20-%20JavaScript%20-%20Reviews?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" rel=\\\"noreferrer noopener\\\" title=\\\"https://teams.microsoft.com/l/channel/19%3a408c5f1322ee4303b02b5da9c5ff6137%40thread.skype/language%20-%20javascript%20-%20reviews?groupid=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantid=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" target=\\\"_blank\\\"\\u003eJS channel\\u003c/a\\u003e\\r\\n#### Management Plane\\r\\n- [**`@azure-tools/typespec-ts.options.experimental-extensible-enums`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L32)\\r\\n  - Allowed values: `true`\\r\\n- [**`@azure-tools/typespec-ts.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L30)\\r\\n  - Allowed values: strings that matches the regex `/^arm-[^\\\\/]+$/`\\r\\n  - example: `arm-aaa-bbb`\\r\\n- [**`@azure-tools/typespec-ts.options.package-details.name`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L34)\\r\\n  - Allowed values: strings that matches the regex `/^\\\\@azure\\\\/arm(?:-[a-z]+)+$/`\\r\\n  - example: `@azure/arm-aaa-bbb`\\r\\n#### Data Plane\\r\\n- [**`@azure-tools/typespec-ts.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L33)\\r\\n  - Allowed values: strings that matches the regex `/^(?:[a-z]+-)+rest$/`\\r\\n  - example: `arm-aaa-rest`\\r\\n- [**`@azure-tools/typespec-ts.options.package-details.name`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L35)\\n\\n### Python Sub Rules\\n\\n\\u003e Please follow the below steps to configure. If you encounter any issues, please seek help in the \\u003ca href=\\\"https://teams.microsoft.com/l/channel/19%3A4175567f1e154a80ab5b88cbd22ea92f%40thread.skype/Language%20-%20Python%20-%20Reviews?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" rel=\\\"noreferrer noopener\\\" title=\\\"https://teams.microsoft.com/l/channel/19%3A4175567f1e154a80ab5b88cbd22ea92f%40thread.skype/Language%20-%20Python%20-%20Reviews?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" target=\\\"_blank\\\"\\u003epython channel\\u003c/a\\u003e\\r\\n#### Management Plane\\r\\n- [**`@azure-tools/typespec-python.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L19)\\r\\n  - Allowed values: strings that matches the regex `/^azure-mgmt(-[a-z]+){1,2}$/`\\r\\n  - example: `azure-mgmt-aaa`\\r\\n- [**`@azure-tools/typespec-python.options.namespace`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L20)\\r\\n  - Allowed values: strings that matches the regex `/^azure\\\\.mgmt(\\\\.[a-z]+){1,2}$/`\\r\\n  - example: `azure.mgmt.aaa`\\r\\n- [**`@azure-tools/typespec-python.options.generate-test`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L21)\\r\\n  - Allowed values: `true`\\r\\n- [**`@azure-tools/typespec-python.options.generate-sample`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L22)\\r\\n  - Allowed values: `true`\\r\\n#### Data Plane\\r\\n- [**`@azure-tools/typespec-python.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L18)\\r\\n  - Allowed values: strings that matches the regex `/^azure(-[a-z]+){1,3}$/`\\n\\n- Allowed values: `true`\\r\\n#### Data Plane\\r\\n- [**`@azure-tools/typespec-python.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L18)\\r\\n  - Allowed values: strings that matches the regex `/^azure(-[a-z]+){1,3}$/`\\r\\n  - example: `azure-aaa-bbb-ccc`\\n\\n### Go Sub Rules\\n\\n\\u003e Please follow the below steps to configure. If you encounter any issues, please \"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# design#specs-pr-guides#pr-brch-deep.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-brch-deep](https://aka.ms/azsdk/pr-brch-deep) |\\r\\n| --- | --- |\\n\\n# Deep-dive into breaking changes on spec PRs\\n\\n## Important information about this article\\n\\nThis article provides a deep-dive into breaking changes on spec PRs. It applies if your spec PR has\\r\\n`BreakingChangeReviewRequired` or `VersioningReviewRequired` label.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e This is an advanced deep-dive. If your PR is blocked on breaking changes or versioning issues, you should always\\r\\n\\u003e start by following the guidance at [aka.ms/brch].\\n\\n### Prerequisites\\n\\nThis article assumes you are familiar with [API versions and branches](xref:api-versions-and-branches).\\n\\n### Video overview and slides\\n\\nFor video overview of the breaking changes process, see this [Azure Core Day of Learning talk from March 6, 2024].\\r\\nSlides for the talk are available [here][talk slides].\\n\\n### Summary\\n\\nPer the [PR diagram], the first step of getting your specs PR approved is ensuring your PR obeys the  \\r\\n[Azure Versioning and Breaking Changes Policy]. Relevant details of this policy follow.\\r\\n\\r\\n- Once published, no changes to given API version are allowed, except when fixing the spec to match\\r\\nactual implementation (see the `-Approved-BugFix` labels in this doc).\\r\\nThis applies regardless of whether the API version is for `private preview`, `public preview`, or `GA`.\\r\\n- When introducing a new API version (any `preview` or `GA`), the new API version must be backwards compatible with\\r\\nthe previous, latest `GA` API version.\\r\\n- During a (`private` or `public`) `preview` cycle, a new `preview` API version does not have to be backwards\\r\\ncompatible with the previous `preview` API version.\\r\\n- The rules listed above are checked by automated GitHub checks. The exact ruleset is given in [`oadMessagesRuleMap.ts`].\\r\\nDetails follow.\\n\\n## Breaking changes and versioning issues\\n\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\\n\\n### `BreakingChangeReviewRequired` label\\n\\nThe label `BreakingChangeReviewRequired` is added to your PR if the tooling detects a change that could\\r\\nbe breaking for customers. This can happen in two cases:\\r\\n\\r\\n- In your PR you have possibly introduced a breaking change in a new API version, placed in a new folder,\\r\\nas compared to most recent previous `GA`.\\r\\nThe new API version can be either `preview` or `GA`.\\r\\n  - For example, an existing `GA` API version in leaf folder of `2023-11-15`\\r\\nmay contain API route of `GET .../resoruces/{resourceName}`, but a new `preview` API version of `2024-03-15-preview`\\r\\nmay no longer have this route (REST API path), because you are removing the `resoruces` typo and instead introducing\\r\\n`GET .../resources/{resourceName}` route.\\r\\n- In your PR you are modifying existing `GA` API version in-place. For example, you have recently released\\r\\n`2024-03-18` API version and realized you made a typo and are editing the contents of the leaf folder `2024-03-18`\\r\\ncontaining that API version.\\n\\n### `VersioningReviewRequired` label\\n\\nThe label `VersioningReviewRequired` denotes that your PR has a **versioning issue** possibly violating the  \\r\\n[Azure Versioning and Breaking Changes Policy]. This happens when you made a **non-breaking change**,\\r\\naka **compatible change** to an API version that was already published (merged to a production branch).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e According to [the policy][Azure Versioning and Breaking Changes Policy], compatible (non-breaking changes) are not\\r\\n\\u003e allowed within an existing API version. You must create a new API version. Otherwise, we would confuse our customers\\r\\n\\u003e by having to explain \\\"which version of given API version\\\" has a particular change/feature.\\r\\n\\r\\n`VersioningReviewRequired` label is added by automation if:\\r\\n\\r\\n- You made any compatible changes **within** any API version, `GA` or `preview`.\\r\\n- You made any breaking changes in a `preview` API version.\\r\\n\\r\\nIf your PR has both breaking changes and versioning issues, only `BreakingChangeReviewRequired` label\\r\\nis added to it.\\n\\n### In case there is no latest GA API version\\n\\nIf there is no latest GA OpenAPI spec, then the the cross-version check is instead comparing to\\r\\nlatest available preview if it more than 1 year old.\\r\\n\\r\\nIf neither a GA API version or at least 1 year old preview version exists, then the cross-version check automatically\\r\\npasses.\\n\\n### Diagram explaining breaking changes and versioning issues\\n\\nThe logic for automation adding `BreakingChangeReviewRequired` and `VersioningReviewRequired` labels explained above\\r\\ncan be summarized in the following diagram:\\r\\n\\r\\n![Breaking Changes Confusion Matrix](../../img/breaking_changes_confusion_matrix.png)\\n\\n## Addressing `BreakingChangeReviewRequired`\\n\\nIf your PR is labelled with `BreakingChangeReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the breaking changes in your PR are acceptable, they will be\\r\\napproved by one of these labels:\\n\\n### `BreakingChange-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `BreakingChange-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-UserImpact`\\n\\n- The spec PR describes actual breaking changes to the service.\\r\\n- This is the only case that triggers customer notifications, a 3 year migration period (possibly shorter), etc.\\r\\n- Within this set, the changes may be distinguished further for security or legal compliance, which may be granted\\r\\na shorter migration period.\\r\\n- Details at [aka.ms/brch].\\n\\n### `BreakingChange-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Addressing `VersioningReviewRequired`\\n\\nIf your PR is labelled with `VersioningReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the versioning issue in your PR caused by non-breaking (compatible)\\r\\nchanges is acceptable, the board will approve it by one of these labels:\\n\\n### `Versioning-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `Versioning-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-PrivatePreview`\\n\\nThe API version change that triggered the review is in `private preview`, and non-breaking changes are permitted\\r\\nin the same API version during `private preview`.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-PrivatePreview` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Common misconceptions\\n\\n### FALSE: compatible (non-breaking) changes are allowed in published API versions\\n\\n**Why?**\\r\\n\\r\\nAn API version is a contract, and once the contract is published it cannot be changed.\\r\\nOtherwise, it would create customer confusion about \\\"which version of this API version\\\" are they using.\\r\\n\\r\\nAny change of this kind w\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_14.md\",\"document_title\":\"Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_14.md\\n\\n# Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221\\n\\n## question\\n\\nHi I'm looking for someone to help suppress CI Failure on this PR [new addProxyAgentExtension property for proxyagentsettings by huiminyan2017 · Pull Request #36221 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/36221)\\r\\n \\r\\nCompute has multiple API versions so the Avacado check failure is expected.\\n\\n## answer\\n\\nYour PR is to a feature branch, so no checks are required.\\r\\n \\r\\nHowever, your PR may be blocked when you try to merge to main, so I recommend following the instructions here now:\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#multiple_api_version\\r\\n```\\r\\nMULTIPLE_API_VERSION\\r\\nRule MULTIPLE_API_VERSION was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this Uniform Versioning Violation Guide wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Breaking Change(Cross-Version) failure\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Breaking Change(Cross-Version) failure\\n\\n## question\\n\\nWe have the [PR](https://github.com/Azure/azure-rest-api-specs-pr/pull/22834) to introduce new API version with new features for existing RP. The [Breaking Changes(Cross-Version) detected problems](https://github.com/Azure/azure-rest-api-specs-pr/pull/22834/checks?check_run_id=43004413278). How to fix it?\\n\\n## answer\\n\\nIt depends.  Even across versions, some changes are discouraged/disallowed.  If the breaking changes reported in your PR are all intentional, then you just need to follow the instructions in the \\\"next steps to merge\\\" comment to work with the breaking changes board for approval: https://aka.ms/brch\\r\\nGenerally, breaking changes between preview api-versions are allowed if there are good reasons,  breaking changes relative to a stable api-version are more of a concern.  Also, if preview api-versions are old enough, they count as stable api-versions (I doubt that is the case here).\\r\\nThe case here is a preview with breaking changes relative to the last stable. And in this case, making a property optional would be considered breaking if the property occurs in responses.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Typespec Validation issue\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Typespec Validation issue\\n\\n## question\\n\\nI've a PR where the Typespec validation is failing with some weird error. This is not being reproduced locally - \\r\\n```\\r\\n  specification/storagedatamanagementrp/Private.StorageDataManagement.Management/main.tsp:17:10 - error expect-value: Is a model expression type, but is being used as a value here. Use #{} to create an object value.\\r\\n53  \\u003e 17 | @service({\\r\\n54       |          ^\\r\\n55  \\u003e 18 |   title: \\\"Storage Data Management Resource Provider\\\",\\r\\n56       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n57  \\u003e 19 | })\\r\\n58       | ^^\\r\\n```\\r\\n```\\r\\nspecification/storagedatamanagementrp/Private.StorageDataManagement.Management/Connectors/connectorModels.tsp:19:15 - error invalid-argument: Argument of type '\\\"read\\\"' is not assignable to parameter of type 'valueof EnumMember'\\r\\n60  \\u003e 19 |   @visibility(\\\"read\\\")\\r\\n61       |               ^^^^^^\\r\\n```\\r\\nI'm not sure how to resolve this error. Could someone please help here?\\r\\n[Update Connector and DataShare Swagger by ujjawaljain-msft · Pull Request #21997 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/21997)\\n\\n## answer\\n\\nYou may need to update to the latest typespec version - some of these particular properties have changed in a recent version. What you are using here isn't the latest style to specify these things.\\r\\nDoc for future reference: https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally :\\r\\n```\\r\\nRunning Locally\\r\\nTo ensure you see the same results from TypeSpecValidation in your PR check and tsv on your local machine:\\r\\nMerge latest from parent (e.g. main or RPSaaSMaster) to your PR branch\\r\\nRun locally\\r\\ngit clean -xdf (may revert any local changes)\\r\\ngit pull\\r\\nnpm ci\\r\\nnpx tsv specification/contosowidgetmanager/Contoso.Management\\r\\ngit status\\r\\nIf any changes, git add, git commit, git push to update your PR.\\r\\nIf you are still having problems, try cloning your branch to a new folder, or try on another machine.\\r\\nIf the problem can be reproduced on a clean machine, request assistance from the TypeSpec Discussion teams channel.\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# Create a PR against main\\n## Update your branch with changes from main\\n### Updating only the infrastructure changes from main\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Validation.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation\",\"content\":\"# Table of Contents\\n## How to Re-evaluate `SDK Validation Status` Check\\nRe-running any `SDK Validation` checks will automatically re-evaluate the `SDK Validation Status` check. If you don't see any `SDK Validation - {Language}` checks in your PR's checklist, it means you don't have the required permission to trigger them. Refer to the instructions at https://aka.ms/azsdk/access to get the necessary write access. Additionally, make sure your membership in the `Azure` GitHub organization is set to _public_, for example, you can verify your membership visibility on [Azure](https://github.com/orgs/Azure/people?query=) page.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#pipeline.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline\",\"content\":\"# Resolving Pipeline Failures\\n## Swagger BreakingChange\\n### Multiple OpenAPI Files Before Migration\\nThis pipeline will fail if there is more than one OpenAPI file in the latest version. See the detailed explanation in this [issue](https://github.com/Azure/typespec-azure/issues/2194#issue-2844564216).\\r\\n\\r\\nTo properly identify real breaking changes, use the \\\"TypeSpec Migration Validation\\\" pipeline instead:\\r\\n\\r\\n1. Navigate to the TypeSpec Migration Validation pipeline\\r\\n2. Check the report on the \\\"Summary\\\" page\\r\\n3. The output should match exactly what you see in [this step](../01-get-started.md#review-and-adjust-the-typespec) on the local machine\\r\\n4. Review the changes to verify they are expected\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure REST API, SDK development process with TypeSpec\\n## Table Of Content\\n### 4. Prepare and submit a Pull Request for reviewing\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\r\\n   - send a pull request to the original repo from your forked repo.\\r\\n   See the ARM Wiki for information on the [supported repos and branches for management-plane services](https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches).\\r\\n#### 4.1 Fix the errors of PR reviewing CI checks\\r\\nThe CI checks result will be commented on the PR. you can refer to the [CI fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\\r\\nNote:\\r\\nSince the OpenAPI is generated from TypeSpec, to change the OpenAPI, you must update the TypeSpec file and regenerate the\\r\\n OpenAPI and avoid updating OpenAPI directly to keep the consistency between OpenAPI and TypeSpec.\\r\\nFor support \\u0026 help, you can post a message to [TypeSpec Discussion - teams channel](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-BreakingChange.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-BreakingChange\",\"content\":\"# AutoRest Exceptions\\nIf `Swagger BreakingChange` fails with `AutoRest threw a runtime error`, the root cause is likely a problem in your spec causing AutoRest to crash.  To debug (all commands run from repo root):\\r\\n\\r\\n1. Determine if the problem is \\\"before\\\" or \\\"after\\\" your PR (or both)\\r\\n   1. Checkout the target branch of your PR (likely `main` or `RPSaaSMaster`)\\r\\n   2. `npm i`\\r\\n   3. Run `@azure/oad` against the copy of your spec in the target branch.  Specify the same path twice, which should always pass unless AutoRest crashes.\\r\\n    ```\\r\\n    $ npx @azure/oad compare \\\\\\r\\n        specification/contosowidgetmanager/resource-manager/Microsoft.Contoso/stable/2021-11-01/contoso.json \\\\\\r\\n        specification/contosowidgetmanager/resource-manager/Microsoft.Contoso/stable/2021-11-01/contoso.json\\r\\n    ```\\r\\n   4. If your spec is valid, this should return `\\\"code\\\":\\\"NoVersionChange\\\"`, since you are comparing the spec to itself.  If your spec is invalid, this will fail with `AutoRest threw a runtime error`, and the stack trace should include `path` properties pointing to the error.  For instance, here's a failure caused by example with a disallowed property:\\r\\n\\r\\n    ```\\r\\n    code: 'OBJECT-ADDITIONAL-PROPERTIES'\\r\\n    params: [ [Array] ]\\r\\n    message: 'Additional properties not allowed: headers'\\r\\n    path: '#/paths/~1executions/post/x-ms-examples/CodeExecution-Execute-Async-Running'\\r\\n    ```\\r\\n\\r\\n   5. If `@azure/oad compare` passed on the copy of your spec in the target branch, repeat these steps on the copy of your spec in the source branch.\\r\\n2. If the problem is \\\"before\\\" your PR, open another PR dedicated to fixing just this problem.  BreakingChanges may fail in this fixup PR, but should pass going forward.\\r\\n3. If the problem is \\\"after\\\" your PR, just fix the problem in your PR.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-arm-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-arm-review\",\"content\":\"# Get your PR reviewed by ARM\\n## Getting help for your ARM review\\n\\u003e [!IMPORTANT]\\r\\n\\u003e If your PR has breaking changes you must solve them before asking the on-call ARM reviewer for help.\\r\\n\\r\\nIf you need help from the ARM reviewer, book the **ARM API Review Office Hours** per https://aka.ms/armofficehoursinfo.\\r\\n\\r\\nFor help with other topics, please use the prescribed methods mentioned in the [PR workflow diagram] and your\\r\\nPR description [`Getting help` section].\\r\\n\\r\\n[PR workflow diagram]: https://aka.ms/azsdk/pr-diagram\\r\\n[ARM review queue]: https://github.com/search?q=org%3AAzure+is%3Apr+is%3Aopen+label%3AWaitForARMFeedback+-label%3AIDCDevDiv++draft%3Afalse+sort%3Acreated-asc+\\u0026type=pullrequests\\r\\n[IcM]: https://portal.microsofticm.com/imp/v3/oncall/current?serviceId=20371\\u0026teamIds=51358\\u0026scheduleType=timeline\\u0026shiftType=current\\u0026viewType=1\\r\\n[`Getting help` section]: https://aka.ms/azsdk/pr-getting-help\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\n## MULTIPLE_API_VERSION\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors\",\"content\":\"# Resolving Folder Migration Conflicts: A Guide for PR Authors\\n## The impact to ongoing PRs\\n### After Resolution\\nMake sure to compile the TypeSpec project so that the TypeSpec Validation could pass.\\r\\n\\r\\n1. **Comprehensive validation**:\\r\\n   ```bash\\r\\n   # Run full validation suite\\r\\n   npm ci\\r\\n   npm run lint\\r\\n   npm run validate\\r\\n   \\r\\n   # Test TypeSpec compilation for your service\\r\\n   cd specification/app/data-plane/DynamicSessions/\\r\\n   npx tsp compile .\\r\\n   npx tsp compile . --emit @azure-tools/typespec-autorest\\r\\n   \\r\\n   # Verify generated files match expectations by checking if there's any diff with the OpenAPI json files.\\r\\n   ```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Branch protection rules table\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\nThis table shows which GitHub checks are marked as `required` on respective branches. Even when a check is marked as ❌\\r\\nit **may** still be running on given branch; just that if it fails, the PR won't be blocked from merging.\\r\\n\\r\\n| Branch | Merge | SDK | TSVal | BrCh | BrChC | LintRPaaS | LintDiff | Model | Semantic | Spell | Prettier | license | approver |\\r\\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\\r\\n| public `main`                  | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSMaster`         | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| public/private `release-*`     | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSDev`            | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `InternalARMContracts` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `ARMCoreRPDev`         | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n\\r\\nLegend:\\r\\n\\r\\n| Column name | Full GitHub check name               |\\r\\n|-------------|--------------------------------------|\\r\\n| `BrCh`      | `Swagger BreakingChange`             |\\r\\n| `BrChC`     | `Breaking Change(Cross-Version)`     |\\r\\n| `license`   | `license/cla`                        |\\r\\n| `LintDiff`  | `Swagger LintDiff`                   |\\r\\n| `LintRPaaS` | `Swagger Lint(RPaaS)`                |\\r\\n| `Merge`     | `Automated merging requirements met` |\\r\\n| `Model`     | `Swagger ModelValidation`            |\\r\\n| `Prettier`  | `PrettierCheck`                      |\\r\\n| `SDK`       | `SDK azure-sdk-for-go`               |\\r\\n| `Semantic`  | `Swagger SemanticValidation`         |\\r\\n| `Spell`     | `SpellCheck`                         |\\r\\n| `TSVal`     | `TypeScript Validation`              |\\r\\n| `approver`  | Requires team member approval        |\\r\\n\\r\\nFor more information on these checks, see:\\r\\n\\r\\n- https://aka.ms/azsdk/pr-getting-help\\r\\n- https://aka.ms/ci-fix\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# Create a pull request with your Azure REST API spec update\\n## Get your PR merged\\n| Short Link: | [aka.ms/azsdk/specreview/merge](https://aka.ms/azsdk/specreview/merge) |\\r\\n|-|-|\\r\\n\\r\\nTo get your PR merged:\\r\\n\\r\\n1. Ensure the `Next Steps to Merge` comment and `Automated merging requirements met` check are green. \\r\\n1. Ensure at least one person has approved your PR. Generally another person from your team that has [write access] to the repo.\\r\\n1. Ensure all required checks are passing and at least investigate to understand any other non-required checks that may be failing. \\r\\n1. Once all required checks are green and any other issues understood you can merge the PR yourself as long as you have [write access] to the repo.\\r\\n1. If your PR is targeting public `main` you will need to first apply the `PublishToCustomers` label to acknowledge you understand this \\r\\n   will cause your spec to be published so customers can consume it.\\r\\n1. If your PR is targeting private repo `main` branch, it **cannot** be merged.\\r\\n   Instead, you can publish your changes to customers by following the guide at [aka.ms/azsdk/move-pr].\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"# Convert OpenAPI specs to TypeSpec\\n## Conversion process\\n### Merge the PR\\n- Review feedback: Go through all comments and feedback provided by the reviewers. Ensure that any requested changes\\r\\n have been made.\\r\\n- Confirm approvals: Verify that all required approvals have been obtained.\\r\\n- Ensure CI required jobs are green: Make sure that all Continuous Integration (CI) required jobs have passed successfully.\\r\\n The PR cannot be merged until these jobs are green.\\r\\n- Merge the pull request.\"}]", "inputs.latency": 422.35981249809265, "inputs.response_length": 2782, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep", "https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec", "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline"], "inputs.testcase": "Problem with merging PR into target branch", "outputs.similarity.similarity": 3.0, "outputs.similarity.gpt_similarity": 3.0, "outputs.similarity.similarity_result": "fail", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1582, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1583, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Problem with merging PR into target branch\\\\n\\\\nquestion: Hello team,\\\\nI am having trouble merging my PR. It seems I am being blocked by breaking changes errors. After consulting with the breaking changes team, they say the pr pipeline must be bust. Can you please help on this.\\\\nPR: Enabling free services acquisition via APIs by adrianta \\\\u00b7 Pull Request #25230 \\\\u00b7 Azure/azure-rest-ap\\\\u2026\\\", \\\"response\\\": \\\"Based on your description, your PR is blocked due to breaking changes errors reported by the CI pipeline. Here is how you should proceed:\\\\n\\\\n1. **Understand the Breaking Changes Policy**: According to Azure's guidelines, any breaking changes\\\\u2014whether across API versions or within a single API version\\\\u2014are strictly controlled. You cannot merge a PR with unresolved breaking changes into a production branch (such as `main`). This is enforced by the automated CI checks. See references for policy details.\\\\n\\\\n2. **Diagnose the Pipeline Failure**:\\\\n   - The error is not a pipeline bug, but the intended behavior of the system to protect customers from accidental breaking changes. The pipeline checks are required and must pass.\\\\n   - Review the detailed error report in your PR. If you are introducing a new API version, ensure that all breaking changes (e.g., removing properties, changing required/optional status, etc.) are either intentional and approved or fixed.\\\\n\\\\n3. **Resolution Steps**:\\\\n   - If all reported breaking changes are intentional, you must follow the official Azure Breaking Change Review process. Go to https://aka.ms/brch, submit your request, and obtain approval from the Breaking Change Review Board. Once approved, apply the relevant approval label (such as `BreakingChange-Approved-BugFix`, `BreakingChange-Approved-UserImpact`, etc.) to your PR as instructed in the \\\\\\\"Next Steps to Merge\\\\\\\" comment.\\\\n   - If the breaking changes are not intentional, update your TypeSpec files to resolve the breaking changes, regenerate your OpenAPI specs, and re-run the pipeline. Never edit the OpenAPI directly; always fix the source TypeSpec files.\\\\n   - If you believe the pipeline is reporting a false positive (for example, if the breaking change is actually not breaking, or due to a migration scenario), review the [Resolving Pipeline Failures guide](https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline) and validate locally using `npm ci` and `npx tsv`.\\\\n\\\\n4. **You Cannot Suppress Required CI Checks**: Azure guidelines do not allow suppression or bypassing of breaking change checks for PRs targeting production branches unless you have explicit approval from the review board.\\\\n\\\\n5. **If Still Blocked**: If you have completed all the above and the checks still fail unexpectedly, verify your branch is up to date with the latest `main` and re-run the validation locally. If the issue persists and is reproducible on a clean machine, request help via the TypeSpec Discussion Teams channel (link below).\\\\n\\\\n**Summary**: You must resolve or get approval for all breaking changes before you can merge your PR. This is not a pipeline bug, but the required policy for Azure REST API specs. Follow the official review and approval process for breaking changes.\\\\n\\\", \\\"ground_truth\\\": \\\"You are confusing two checks:\\\\nBreaking Changes(Cross-Version) - Analyze Code\\\\nimplementation detail\\\\nnot required\\\\nBreaking Changes(Cross-Version)\\\\nrequired\\\\npassing due to label\\\\nI suspect your PR cannot be merged, because your github account is missing one or more required permissions. https://aka.ms/azsdk/access\\\\nThis must be public, not private: https://github.com/orgs/Azure/people?query=adrianta\\\\nOnce your permissions are fixed, push a change to your PR (empty commit is fine) to rerun checks.\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"}, {"inputs.query": "title: Clarification on Folder Structure Alignment for CP and DP SDKs\n\nquestion: Hi\nGeneral\n,\nOur CP SDKs for both .NET and JavaScript are currently placed under the playwright folder.\njs->azure-sdk-for-js/sdk/playwright at main · Azure/azure-sdk-for-js\nnet->azure-sdk-for-net/sdk/playwright at main · Azure/azure-sdk-for-net\nwhile the non-Azure (DP) SDKs are placed under the loadtesting folder.\njs->azure-sdk-for-js/sdk/loadtesting at main · Azure/azure-sdk-for-js\nnet->azure-sdk-for-net/sdk/loadtestservice at main · Azure/azure-sdk-for-net\nwe wanted to confirm:\nIs it important or recommended to move the DP SDKs under the playwright folder to align with the CP SDK structure or the current structure is fine?\nIf yes, could you please guide us on the recommended process or steps to make this shift (e.g., repo structure changes, PR approach, or naming conventions to follow)?\nContext:\nAs part of the retirement of Microsoft Playwright Testing (MPT) and its merger into Azure App Testing, we deprecated the old SDK packages associated with MPT and created new alternative packages about whose folder structure I mentioned above.\nMPT’s core web testing capabilities are being integrated into Azure App Testing to provide a unified experience for both Load Testing and Playwright-based web testing. The standalone MPT service will be retired, and customers will need to migrate to Azure App Testing.\nQiaoqiao Zhang Please help us with this.\nThanks\ncc Madhuri", "inputs.ground_truth": "I think this should be a cross-language issue as in your tspconfig, the service-dir is sdk/playwrite which means all languages will generate the code under sdk/playwript. So you should update it in your tspconfig first. Then we can move the generated package into sdk/loadtesting folder in sdk repo\ntspconfig:\n```\nparameters:\n\"service-dir\":\ndefault: \"sdk/playwright\"\n```\nFor Java, I see you already had a GA release in\nhttps://github.com/Azure/azure-sdk-for-java/tree/main/sdk/playwright/azure-resourcemanager-playwright\nIf this is your SDK, please do not modify the directory on Java. If you update the service-dir in parameters, please add a line\n```\nservice-dir: sdk/playwright\n```\nunder \"@azure-tools/typespec-java\":\nGenerally, diretory in Java repo follows your package name and namespace, which both is playwright. Unless your package be e.g. azure-resourcemanager-loadtesting-playwright, the folder won't be loadtesting.", "inputs.response": "Based on the provided Azure SDK onboarding and development guidelines, the folder structure for SDKs in Azure SDK repositories should be logical, consistent, and follow established conventions to ensure maintainability and discoverability. However, there is no explicit requirement or recommendation in the provided knowledge base that mandates aligning Data Plane (DP) SDKs under the same folder (e.g., 'playwright') as Control Plane (CP) SDKs if their functionality or API surface is distinct. \n\nGiven your context—retirement of Microsoft Playwright Testing (MPT), merger into Azure App Testing, and creation of new packages—it is important to ensure that:\n- SDKs are named and organized to clearly reflect their service and functionality (see: naming conventions and namespace review).\n- The folder structure should make it easy for customers and contributors to locate the relevant SDKs for a service.\n\nIf the Load Testing and Playwright-based web testing are now unified under Azure App Testing, and both DP and CP SDKs serve the same logical service, it is **recommended** to consider aligning them under a common folder (e.g., 'playwright' or a new 'app-testing' folder) to reflect the unified service. This alignment will:\n- Improve clarity for customers migrating from MPT to Azure App Testing.\n- Make maintenance and future onboarding processes easier.\n\n**Recommended Process and Steps:**\n1. **Decide on the unified folder name:** If the service is now Azure App Testing, consider renaming to `sdk/app-testing` (preferred) or keep `sdk/playwright` if that best matches the API surface.\n2. **Move DP SDKs:** Move the folders for DP SDKs (`loadtesting`, `loadtestservice`) under the chosen folder. Update all internal references and documentation.\n3. **Update Namespace/Package Names:** If moving results in a namespace change, request a namespace review (see: 'namespace review').\n4. **Deprecation Notice:** Clearly document the migration and folder change in the repo README and migration guides.\n5. **Pull Request Approach:**\n   - Create a PR in the relevant repo (e.g., azure-sdk-for-net, azure-sdk-for-js).\n   - Move the folders and update references.\n   - Add reviewers from CODEOWNERS (see: 'CODEOWNERS' guidelines).\n   - Ensure all CI checks pass and required approvals are obtained.\n   - Reference the retirement of MPT and merger into Azure App Testing in the PR description.\n6. **Coordinate with SDK and service teams:** Announce the planned change in relevant Teams channels to ensure downstream tools and documentation are updated.\n\n**Naming conventions:**\n- Follow the Azure SDK naming guidelines for class, package, and namespace names.\n- If creating a new folder (e.g., 'app-testing'), ensure the name matches the service branding.\n\nIf the DP SDKs continue to represent a distinct logical API surface, the current structure is also acceptable as long as it is clearly documented and follows naming conventions.\n\n**Summary:**\n- If DP and CP SDKs are now part of the same unified Azure App Testing service, move DP SDKs under the same folder as CP SDKs for clarity and consistency.\n- Follow the steps above to migrate and coordinate the change.\n- If they are logically distinct, the current structure is acceptable provided it is well-documented and follows naming conventions.", "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-docs.md\",\"document_title\":\"Publish SDK reference docs\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-docs\",\"content\":\"# develop#sdk-docs.md\\n\\n# Publish SDK reference docs\\n\\n## Before you begin\\n\\n- You have [access](xref:access) to the GitHub repositories and respective GitHub groups.\\r\\nbe added to the [azure-sdk-write](https://github.com/orgs/MicrosoftDocs/teams/azure-sdk-write) GitHub group. This group\\r\\nis in the **MicrosoftDocs** org, not the **Azure** org.\\n\\n## Onboard a released package\\n\\nFollow these steps to onboard a released package to Azure SDK reference docs on Microsoft Learn.\\r\\n\\r\\nDocs are built using CI pipelines maintained by the Docs team. Builds generate docs for all packages onboarded, run on\\r\\na schedule, and take several hours to complete. Changes can be viewed on the reference review site.\\r\\n\\r\\n\\u003e Note: Android reference docs are not yet supported on Microsoft Learn. You will need to follow the [Android guidelines](./sdk-android-docs.md)\\r\\n\\u003e for publishing said documentation instead.\\n\\n### Packages released through the Azure SDK engineering system\\n\\nduring business hours on weekdays. If your data is\\r\\nnot updated and you don't want to wait, [run the job manually](https://dev.azure.com/azure-sdk/internal/_build?definitionId=1284).\\r\\nThis will update the metadata PR.\\r\\n\\r\\nIf you find anything unexpected in the table of contents or service README, check the\\r\\n[metadata CSV file](https://github.com/Azure/azure-sdk/tree/main/_data/releases/latest) to ensure that the metadata is\\r\\ncorrect. If the metadata is not correct, open a PR with corrections.\\r\\n\\r\\nOnce merged your changes will be released on the next available documentation release.\\r\\n\\r\\n##### Update a published Package-level Overview\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e For packages released using the Azure SDK EngSys, changes need to be synchronized between the source SDK repo and the docs\\r\\n\\u003e repo. Changes to the docs repo that are not mirrored to the source SDK repo will be overwritten by content from the source\\r\\n\\u003e SDK repo on the next package release.\\r\\n\\r\\n1. Find the Package-level overview using the table from [Package-level overviews](#package-level-overviews).\\r\\n2. Find the corresponding README.md file for the library in the SDK repo (e.g. [azure-sdk-for-net](https://github.com/azure/azure-sdk-for-net)).\\r\\n3. Update the \\\"front matter\\\" date field at the beginning of the file to today's date. To update other front matter metadata, see [Ensure CSV metadata is correct](#ensure-csv-metadata-is-correct).\\r\\n4. Copy changed content from step 2 into the Package-level overview from step 1.\\r\\n5. Open a pull request for the update file in the docs repo\\n\\nIf your package is released through the Azure SDK engineering system, almost everything is automated. You'll need to\\r\\ntake action if this is your first time releasing a package.\\r\\n\\r\\nWhen releasing a package for the first time:\\r\\n\\r\\n1. Ensure that your package is tracked in the  \\r\\n[release work items](https://dev.azure.com/azure-sdk/Release/_queries/query/7d106acd-a1c2-47b9-9676-996422328397/). This can be done by running the [**Prepare-Release.ps1** script](https://aka.ms/azsdk/mark-release-status).\\r\\n\\r\\nIn each item for your release, you should have a value for **Service Name** and **Package Display Name**. The docs table of contents is generated from this data.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e Do not skip this step. If you skip the service name, your item will appear in the TOC in the **Other** \\u003e **Uncategorized** section.\\r\\n\\r\\n1. Ensure that your package-level overview file (the README.md file for your package in the SDK source repo) is up to date\\r\\n*before* releasing.\\r\\n\\r\\nIn general, the automated system will ensure that updated docs are onboarded within a day or two of your release.\\r\\n\\r\\nTo customize information about your package outside of the engineering system consult documentation for [CSV fields](https://github.com/Azure/azure-sdk/blob/main/eng/README.md#csv-fields)\\r\\nand [Service Level Overview](#service-level-overview) and [Package Level Overview](#package-level-overview).\\r\\n\\r\\n#### Troubleshooting automated documentation updates\\r\\n\\r\\nAn automation job runs every 2 hours during business hours on weekdays. If your data is\\r\\nnot updated and you don't want to wait, [run the job manually](https://dev.azure.com/azure-sdk/internal/_build?definitionId=1284).\\r\\nThis will update the metadata PR.\\r\\n\\r\\nIf you find anything unexpected in the table of contents or service README, check the\\r\\n[metadata CSV file](https://github.com/Azure/azure-sdk/tree/main/_data/releases/latest) to ensure that the metadata is\\r\\ncorrect. If the metadata is not correct, open a PR with corrections.\\n\\n### Packages released outside the Azure SDK engineering system\\n\\n- **ServiceDirectory** -- Name of the service (e.g. `storage`).\\r\\n- **DirectoryPath** -- Path from the root of the `azure-sdk-for-*` repo to the package. If unknown or the package is not released from an `azure-sdk-for-*` repo, use the value `\\\"\\\"`\\r\\n- **SdkType** -- Use values `client` or `mgmt` to place the package in the appropriate location in the table of contents.\\r\\n- **IsNewSdk** -- Use `true` if the package is a track 2 SDK, otherwise use `false`.\\r\\n- **Group** -- Required *only for Java*\\r\\n\\r\\nPlace the metadata JSON file in the `metadata/\\u003cmoniker\\u003e` folder with the name of the package. For example, the metadata\\r\\nJSON file for the `Azure.Storage.Blobs` package would be named\\r\\n[`Azure.Storage.Blobs.json`](https://github.com/MicrosoftDocs/azure-docs-sdk-dotnet/blob/main/metadata/latest/Azure.Storage.Blobs.json).\\r\\nFor Java packages, name the file for the artifact and omit the group ID (e.g.\\r\\n[`azure-storage-blob.json`](https://github.com/MicrosoftDocs/azure-docs-sdk-java/blob/main/metadata/latest/azure-storage-blob.json)).\\r\\n\\r\\n|  | .NET | Java | JS | Python |\\r\\n| --- | --- | --- | --- | --- |\\r\\n| Metadata Location | [Link](https://github.com/MicrosoftDocs/azure-docs-sdk-dotnet/tree/main/metadata) | [Link](https://github.com/MicrosoftDocs/azure-docs-sdk-java/tree/main/metadata) | [Link](https://github.com/MicrosoftDocs/azure-docs-sdk-node/tree/main/metadata) | [Link](https://github.com/MicrosoftDocs/azure-docs-sdk-python/tree/main/metadata) |\\n\\nFor more information on CSV fields, see: [metadata CSV readme](https://github.com/Azure/azure-sdk/blob/main/eng/README.md#csv-fields)\\r\\n\\r\\n\\u003ca id=\\\"service-level-overview\\\"\\u003e\\u003c/a\\u003e\\r\\n\\r\\n#### Service-level overviews \\r\\n\\r\\nService-level overviews provide a list of relevant packages. Service-level overview pages are generated automatically\\r\\nfor each service and contain a list of packages.\\r\\n\\r\\nService teams can create their own service-level overview pages which contain more information. Service teams that\\r\\ncreate their own service-level overview pages are responsible for updating those pages.\\r\\n\\r\\nTo create a service-level overview page, look for the relevant markdown for your service. Service-level markdown files\\r\\nare named in the format `service-name.md` where spaces are replaced with dashes (`-`). For example the service-level\\r\\noverview for the `Key Vault` service would be named `key-vault.md`.\\r\\n\\r\\nAn `[!INCLUDE]` directive can be used to include a list of packages which will be automatically updated as metadata\\r\\nabout new packages is available.\\r\\n\\r\\n```md\\r\\n[!INCLUDE [packages](advisor-index.md)]\\r\\n```\\r\\n\\r\\nThe list of packages is in a file whose name is of the form `\\u003cservice\\u003e-index.md`.\\r\\n\\r\\nService-level overview examples:\\r\\n\\r\\n- Custom service-level overview requiring manual edits: [Python Storage](https://github.com/MicrosoftDocs/azure-docs-sdk-python/blob/main/docs-ref-services/latest/storage.md)\\r\\n- Service-level overview generated automatically: [Python Advisor](https://github.com/MicrosoftDocs/azure-docs-sdk-python/blob/main/docs-ref-services/latest/advisor.md)\\r\\n\\r\\n\\u003ca id=\\\"package-level-overview\\\"\\u003e\\u003c/a\\u003e\\r\\n\\r\\n#### Package-level overviews\\r\\n\\r\\nPackage level overviews are generated from the README.md file in the package source as part of the\\r\\nrelease process. For\\r\\nexample:\\r\\n[JavaScript storage blob package README.md in SDK repo](https://github.com/Azure/azure-sdk-for-js/blob/main/sdk/storage/storage-blob/README.md).\\n\\nupdate the data and [run the automation again](https://dev.azure.com/azure-sdk/internal/_build?definitionId=1284).\\r\\n\\r\\nFor information about the CSV fields see the [CSV field README](https://github.com/Azure/azure-sdk/blob/main/eng/README.md#csv-fields).\\r\\n\\r\\n##### CSV fields\\r\\n\\r\\nRelevant fields in the CSV for docs generation are:\\r\\n\\r\\n- **Package** -- Name of the package (e.g. `Azure.Storage.Blobs`)\\r\\n- **VersionGA** -- The latest GA version of the package (e.g. `12.8.0`)\\r\\n- **VersionPreview** -- The latest preview version of the package (e.g. `12.9.0-beta.1`)\\r\\n- **DisplayName** -- Display name of the package in the table of contents (e.g. `Storage - Blobs`)\\r\\n- **ServiceName** -- Name of the service (e.g. `Storage`)\\r\\n- **MSDocService** -- Used to ensure correct metadata for the docs site. Use an appropriate value for the service as\\r\\ndefined in the [taxonomy service (filtered by **ms.service**)](https://taxonomy.learn.microsoft.com/TaxonomyServiceAdminPage/#/taxonomy/detail/2023-01-27T09:00:06.1263332Z!5a3ccca6-19ce-4f32-b516-88038fa259ae/ms.service)\\r\\n(Related: [taxonomy documentation](https://review.learn.microsoft.com/en-us/help/platform/metadata-taxonomies?branch=main#msservice)).\\r\\n- **Type** -- Use values `client` or `mgmt` to place the package in the appropriate location in the table of contents.\\r\\n\\r\\nFor more information on CSV fields, see: [metadata CSV readme](https://github.com/Azure/azure-sdk/blob/main/eng/README.md#csv-fields)\\r\\n\\r\\n\\u003ca id=\\\"service-level-overview\\\"\\u003e\\u003c/a\\u003e\\r\\n\\r\\n#### Service-level overviews \\r\\n\\r\\nService-level overviews provide a list of relevant packages. Service-level overview pages are generated automatically\\r\\nfor each service and contain a list of packages.\\r\\n\\r\\nService teams can create their own service-level overview pages which contain more information. Service teams that\\n\\n|\\r\\n| Python | `azure-ai-formrecognizer` | `ai-formrecognizer-readme.md` | [`docs-ref-services/\\u003cmoniker\\u003e/`](https://github.com/MicrosoftDocs/azure-docs-sdk-python/tree/main/docs-ref-services) |\\r\\n\\r\\n##### Monikers\\r\\n\\r\\nThe **\\\\\\u003cmoniker\\\\\\u003e** should be one of \\\"preview\\\" for pre-\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#supporting-sdk-customers#codeowners.md\",\"document_title\":\"CODEOWNERS\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/supporting-sdk-customers/codeowners\",\"content\":\"# develop#supporting-sdk-customers#codeowners.md\\n\\n# CODEOWNERS\\n\\nThe `CODEOWNERS` file in a GitHub repository is used to define individuals or teams that are responsible for code in a repository. The Azure SDK team uses additional meta data in the `CODEOWNERS` file to do things like, auto assign issues and mention services teams in customer issues that require their assistance to resolve.\\n\\n## Where are the CODEOWNERS files\\n\\nThe `CODEOWNERS` files live in the `.github` directory, located at the root of each repository. You can also use the links below to quickly get to the files.\\r\\n\\r\\n- [C++](https://github.com/Azure/azure-sdk-for-cpp/blob/main/.github/CODEOWNERS)\\r\\n- [Go](https://github.com/Azure/azure-sdk-for-go/blob/main/.github/CODEOWNERS)\\r\\n- [Java](https://github.com/Azure/azure-sdk-for-java/blob/main/.github/CODEOWNERS)\\r\\n- [JavaScript/TypeScript](https://github.com/Azure/azure-sdk-for-js/blob/main/.github/CODEOWNERS)\\r\\n- [.NET](https://github.com/Azure/azure-sdk-for-net/blob/main/.github/CODEOWNERS)\\r\\n- [Python](https://github.com/Azure/azure-sdk-for-python/blob/main/.github/CODEOWNERS)\\r\\n- [REST API Specs](https://github.com/Azure/azure-rest-api-specs/blob/main/.github/CODEOWNERS)\\r\\n- [Rust](https://github.com/Azure/azure-sdk-for-rust/blob/main/.github/CODEOWNERS)\\n\\n## Validating your alias in CODEOWNERS\\n\\nFor your GitHub alias to be valid you must complete the tasks for [Requesting access to Azure REST API and SDK repositories](xref:access#request-access-to-azure-rest-api-and-sdk-repositories).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e Ensure that your organization visibility is set to **public** before proceeding.\\r\\n\\r\\nIf you're unsure if your GitHub alias is a part of the right orgs and has the proper permissions, you can verify the state of your alias by running the [Validate-AzsdkCodeOwner](https://github.com/Azure/azure-sdk-tools/blob/main/tools/github/scripts/Validate-AzsdkCodeOwner.ps1) script from the Azure SDK tools repository.\\n\\n## Getting mentioned on issues\\n\\nOur repositories have automated processes for adding comments to issues when certain labels are added. Your team can automatically have a GitHub alias or GitHub team mentioned in an issue if the service's label and the `Service Attention` label are added to the issue. The `Service Attention` label signifies that the issue cannot be resolved by the Azure SDK team. The responsibility to resolve the issue will be on your team.\\r\\n\\r\\nTo update who gets automatically mentioned in issues related to your service, locate the relevant block in the `CODEOWNERS` file by searching for the `service label` and update the GitHub aliases listed:\\r\\n\\r\\n```text\\r\\n# ServiceLabel: %\\u003cService-Label\\u003e\\r\\n# ServiceOwners:                                        @fakeUser1 @Azure/fakeTeam1\\r\\n```\\r\\n\\r\\nSee the [Creating and editing a service in CODEOWNERS files](#creating-and-editing-a-service-in-codeowners-files) section to properly update your service's entry.\\n\\n## Getting assigned as a reviewer on pull requests\\n\\nThe Azure SDK and Azure REST API Specs GitHub repositories utilize GitHub's built-in features for automatically adding PR (Pull Request) reviewers using the `CODEOWNERS` file.\\r\\n\\r\\nTo update who is automatically added as a reviewer when PRs are opened to your service's API Spec or libraries, locate the relevant block in the `CODEOWNERS` file by searching for the `service label` and update the GitHub aliases listed:\\r\\n\\r\\n```text\\r\\n# PRLabel: %\\u003cService-Label\\u003e\\r\\n/sdk/\\u003cyour-service-library-directory\\u003e/                  @fakeUser1 @Azure/fakeTeam1\\r\\n```\\r\\n\\r\\nSee the [Creating and editing a service in CODEOWNERS files](#creating-and-editing-a-service-in-codeowners-files) section to properly update your service's entry.\\n\\n## Creating and editing a service in CODEOWNERS files\\n\\nTo edit the `CODEOWNERS` files in each SDK repository and the API Specs repository, follow these steps:\\r\\n\\r\\n1. Go to the `CODEOWNERS` file you plan to edit. *Use the [Where are the CODEOWNERS files](#where-are-the-codeowners-files) list.*\\r\\n2. Click the pencil icon on the top right to edit this file. This will open the GitHub browser editor.\\r\\n3. In the `CODEOWNERS` file, locate the lines that follow the pattern below, replacing `\\u003cService-Label\\u003e` with the associated GitHub label for your Azure service and `\\u003cyour-service-library-directory\\u003e` with the directory your service library's source code is located. This entire code block will be your service's entry within the `CODEOWNERS` file.\\r\\n\\r\\n   ```text\\r\\n   # PRLabel: %\\u003cService-Label\\u003e\\r\\n   /sdk/\\u003cyour-service-library-directory\\u003e/                    @fakeUser1 @Azure/fakeTeam1\\r\\n\\r\\n   # ServiceLabel: %\\u003cService-Label\\u003e\\r\\n   # ServiceOwners:                                          @fakeUser1 @Azure/fakeTeam1\\r\\n   ```\\r\\n\\r\\n   \\u003e [!TIP]\\r\\n   \\u003e If you don't know what your service label is, see the [Common Repo Labels] CSV file and look for a row whose first column contains your service's name. If you don't see a row for your service, contact [Ronnie Geraghty].  \\r\\n   \\u003e **DO NOT** add labels for your service directly to the SDK repositories.\\r\\n\\r\\n   If you were able to locate lines that **completely match** the pattern above, proceed to the next step.\\r\\n\\r\\n   If you were able to locate lines that **partially match** the pattern above, add lines and information as needed to adhere to the required format. Then, proceed to the next step.\\r\\n\\r\\n   If **no lines** match the pattern above, create a new entry for your service. Insert the above pattern into the file and replace:\\r\\n\\r\\n   - `\\u003cService-Label\\u003e` with the associated GitHub label for your Azure service\\r\\n   - `\\u003cyour-service-library-directory\\u003e` with the directory your service library's source code is located\\r\\n   - Fake GitHub aliases with your own alias and/or your team's.\\n\\npull request will then be reviewed by our team. If we have any questions, we will leave them in the comments of the pull request so please monitor the pull request until it is merged.\\r\\n   Once the pull request is reviewed and merged, you will start being mentioned in customer issues and added as a reviewer to PRs that contain changes to the files in the directory location you specified.\\r\\n10. Repeat these steps for the API Specs repo and each language repository you want to make changes to.\\r\\n\\r\\n[Common Repo Labels]: https://github.com/Azure/azure-sdk-tools/blob/main/tools/github/data/common-labels.csv\\r\\n[Ronnie Geraghty]: mailto:rgeraghty@microsoft.com\\n\\nabove, add lines and information as needed to adhere to the required format. Then, proceed to the next step.\\r\\n\\r\\n   If **no lines** match the pattern above, create a new entry for your service. Insert the above pattern into the file and replace:\\r\\n\\r\\n   - `\\u003cService-Label\\u003e` with the associated GitHub label for your Azure service\\r\\n   - `\\u003cyour-service-library-directory\\u003e` with the directory your service library's source code is located\\r\\n   - Fake GitHub aliases with your own alias and/or your team's. For GitHub teams you'll need to prefix the team name with the GitHub organization it was created under (Ex: `@\\u003cGitHub-Org\\u003e/\\u003cGitHub-Team\\u003e`)\\r\\n\\r\\n   \\u003e [!NOTE]\\r\\n   \\u003e Service entries in `CODEOWNERS` should be ordered and inserted alphabetically by the service label.\\r\\n\\r\\n4. Update your service's entry as needed, ensuring that the standards below are maintained and always met:\\r\\n\\r\\n   - There are at least 2 valid aliases for both the SDK directory and `#ServiceOwners:`. See the [Validating your CODEOWNERS](#validating-your-alias-in-codeowners) section to see how you can check codeowner aliases and what you need to do to make them valid.\\r\\n   - The placement of your GitHub alias(es) is vertically aligned with others in the file.\\r\\n   - Entries are listed alphabetically by service label.\\r\\n   - An empty line separates your service entry from other service entries in the file. For example:\\r\\n\\r\\n   ```text\\r\\n   # PRLabel: %Other Service Label\\r\\n   /sdk/\\u003cother-service-library-directory\\u003e/                    @fakeUser1 @Azure/fakeTeam1\\r\\n\\r\\n   # ServiceLabel: %Other Service Label\\r\\n   # ServiceOwners:                                          @fakeUser1 @Azure/fakeTeam1\\r\\n\\r\\n   # PRLabel: %Your Service Label\\r\\n   /sdk/\\u003cyour-service-library-directory\\u003e/                    @myalias @Azure/myTeam1\\r\\n\\r\\n   # ServiceLabel: %Your Service Label\\r\\n   # ServiceOwners:                                          @myalias @Azure/myTeam1\\r\\n\\r\\n   # PRLabel: %Another Service Label\\n\\n@fakeUser1 @Azure/fakeTeam1\\r\\n\\r\\n   # ServiceLabel: %Other Service Label\\r\\n   # ServiceOwners:                                          @fakeUser1 @Azure/fakeTeam1\\r\\n\\r\\n   # PRLabel: %Your Service Label\\r\\n   /sdk/\\u003cyour-service-library-directory\\u003e/                    @myalias @Azure/myTeam1\\r\\n\\r\\n   # ServiceLabel: %Your Service Label\\r\\n   # ServiceOwners:                                          @myalias @Azure/myTeam1\\r\\n\\r\\n   # PRLabel: %Another Service Label\\r\\n   /sdk/\\u003canother-service-library-directory\\u003e/                    @fakeUser2 @Azure/fakeTeam2\\r\\n\\r\\n   # ServiceLabel: %Another Service Label\\r\\n   # ServiceOwners:                                          @fakeUser2 @Azure/fakeTeam2\\r\\n   ```\\r\\n\\r\\n5. Click on the green **Commit changes...** button at the top right.\\r\\n6. In the pop-up, change the **Commit message** text box to `Update for \\u003cService-Label\\u003e CODEOWNERS`.\\r\\n   Replace `\\u003cService-Label\\u003e` with the same service label you used in the previous steps.\\r\\n7. Add a description with any relevant information and click **Propose changes**.\\r\\n   Note the name of the new branch created for your changes. The branch name is shown in the bottom text box and usually follows the pattern `\\u003cgithub-alias\\u003e-patch-1`.\\r\\n8. Review the pull request form that appears making sure that the base branch is `main` and the compare branch is the one you just created in the previous step. Then click the **Create pull request** button.\\r\\n9. The pull request will then be reviewed by our team. If we have any questions, we will leave them in the comments of the pull request so please monitor the pull request until it is merged.\\r\\n   Once the pull request is reviewed and merged, you will start being mentioned in\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-test.md\",\"document_title\":\"Test your SDK\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-test\",\"content\":\"# develop#sdk-test.md\\n\\n# Test your SDK\\n\\nUsability is a critical factor in the success of SDKs for our customers, which is why our SDKs must include tests.\\n\\n## Before you begin\\n\\n- You have [access](xref:access) to the GitHub repositories and respective GitHub groups.\\r\\n- You are familiarized with the [Azure SDK Architecture design guidelines](https://azure.github.io/azure-sdk/general_introduction.html).\\r\\n- You read our [repository branches strategy](https://azure.github.io/azure-sdk/policies_repobranching.html).\\r\\n- You need to have an SDK to write tests against.\\n\\n### [Management plane (ARM)](#tab/management)\\n\\nFor a GA (stable) SDK release, .NET recommends to include live tests to verify that the SDK functions correctly with\\r\\nthe targeted new service version.\\r\\n\\r\\n:point_right: [.NET](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/resourcemanager/Azure.ResourceManager/docs/TestGuide.md)\\r\\n\\r\\n:point_right: [Java](https://github.com/Azure/azure-sdk-for-java/wiki/TypeSpec-Java-Quickstart#adding-tests)\\r\\n\\r\\n:point_right: [JavaScript](https://github.com/Azure/azure-sdk-for-js/blob/main/CONTRIBUTING.md#testing)\\r\\n\\r\\n:point_right: [Python](https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/mgmt/tests.md)\\r\\n\\r\\n:point_right: [Go](https://github.com/Azure/autorest.go/blob/main/packages/autorest.gotest/doc/gotest_howto.md#generate-mock-test-and-execute)\\n\\n### [Data plane](#tab/dataplane)\\n\\nAccording to the target phase of your SDK, these are the requirements you will need to accomplish so you can release your SDK:\\r\\n\\r\\n- Public preview: at least one test per language for the most common usage scenario.\\r\\n- GA: at least one test per shipped method.\\r\\n\\r\\nTutorials to add tests:\\r\\n\\r\\n:point_right: [.NET](https://github.com/Azure/azure-sdk-for-net/blob/main/doc/DataPlaneCodeGeneration/Azure_SDK_Package_Ship_Requirements.md#tests)\\r\\n\\r\\n:point_right: [Java](https://aka.ms/azsdk/dpg/java/tests)\\r\\n\\r\\n:point_right: [JavaScript](https://aka.ms/azsdk/dpg/js/tests)\\r\\n\\r\\n:point_right: [Python](https://aka.ms/azsdk/dpg/python/tests)\\r\\n\\r\\n:point_right: [Go (optional)](https://github.com/Azure/azure-sdk-for-go/blob/main/documentation/developer_setup.md#write-tests).\\n\\n## Get help\\n\\nReach out to the specific language Teams channel under our [Azure SDK channel](https://teams.microsoft.com/l/team/19%3af6d52ac6465c40ea80dc86b8be3825aa%40thread.skype/conversations?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-develop.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop\",\"content\":\"# develop#sdk-develop.md\\n\\n| Short Link: | [aka.ms/azsdk/dpcodegen](https://aka.ms/azsdk/dpcodegen) |\\r\\n| --- | --- |\\n\\n# Develop client libraries (SDK)\\n\\nOnce your [REST API specification](xref:api-design) defined using [TypeSpec](xref:api-typespec) is approved,\\r\\nyou can generate client libraries and reference documentation for each supported SDK language.\\r\\nYour Azure SDKs should be designed to enhance the productivity of developers connecting to Azure services.\\r\\nThey must follow the [Azure SDK Architecture design guidelines](https://azure.github.io/azure-sdk/general_introduction.html)\\r\\nand specific language guidelines.\\r\\n\\u003e [!NOTE]\\r\\n\\u003e - Azure services are required to release client libraries for all Tier 1 SDK languages for Public Preview and GA, which include .NET, Python,\\r\\n\\u003e Java, JavaScript, and Go (optional for data plane SDKs).\\r\\n\\u003e - Avoiding breaking changes under most circumstances. The Azure SDK team recommends on the SDK release cycle can be\\r\\n\\u003e found in [Release Cycle and Package Versioning](https://azure.github.io/azure-sdk/policies_releases.html#release-cycle).\\r\\n\\u003e - Azure services must have a beta release available for at least one month to allow for community feedback before\\r\\n\\u003e graduating to stable. For more details, may refer to [Beta Releases and Stable Graduation](https://azure.github.io/azure-sdk/policies_releases.html#beta-releases-and-stable-graduation)\\n\\n## Before you begin\\n\\n- You have [access](xref:access) to the GitHub repositories and respective GitHub groups.\\r\\n- You read our [repository branches strategy](https://azure.github.io/azure-sdk/policies_repobranching.html).\\r\\n- You are familiarized with the [Azure SDK Architecture design guidelines](https://azure.github.io/azure-sdk/general_introduction.html).\\r\\n- You have a [release plan](xref:release-plan) created to manage and understand the steps required to generate,\\r\\ntest, and release an SDK.\\r\\n- [Request a namespace review](xref:namespace-review). This review process take 1-2 weeks to complete or longer\\r\\ndepending on the complexity of the review.\\n\\n## Generate SDK\\n\\nYour Azure SDKs will be generated from the configurations you set on your TypeSpec project.\\r\\n1. Locate or create the `tspconfig.yaml` file in your TypeSpec project.\\r\\n2. There are emitters per SDK language supported. Add the required emitters with their respective options.\\r\\n  - [Management plane tspconfig.yaml sample](https://aka.ms/azsdk/tspconfig-sample-mpg).\\r\\n  - [Data plane tspconfig.yaml sample](https://aka.ms/azsdk/tspconfig-sample-dpg).\\r\\nFor OpenAPI, the configurations should be in `readme.md`. Refer to the [Sample Readme](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/README.md#swagger-to-sdk).\\r\\n\\u003e[!TIP]\\r\\n\\u003e We are piloting our new AzSDK tools MCP server which includes the ability to generate the SDKs and\\r\\n\\u003e create a draft pull request in the respective language repository. Refer to [AzSDK tools MCP server](xref:azsdk-tools-mcp)\\r\\n\\u003e for instructions on how to install it and use it.\\n\\n### [Management plane (ARM)](#tab/management)\\n\\n\\u003e[!NOTE]\\r\\n\\u003e The process for generating management plane SDK from TypeSpec has changed. Learn more about our [latest changes](xref:upcoming_release_planner_change).\\r\\nA release plan is required to generate and release the SDK. If the API spec is written using *TypeSpec* then you\\r\\ncan generate the SDK for all tier-1 in *Generate SDK* step in the release planner.\\r\\nIf API spec is written using *Open API* SDK generation happens when you [request a release](xref:sdk-release) for all\\r\\ntier-1 languages except .NET. For .NET, follow the steps in the [Generate .NET management plane SDK](xref:sdk-generate-mgmt-dotnet).\\r\\nAlthough the SDK is autogenerated for you, you can also generate it manually and locally by following the steps outlined\\r\\nin the linked documentation:\\r\\n:point_right: [.NET](xref:sdk-generate-mgmt-dotnet)\\r\\n:point_right: [Go](https://aka.ms/azsdk/mpg/go)\\r\\n:point_right: [Java](https://aka.ms/azsdk/mpg/java)\\r\\n:point_right: [JavaScript](https://aka.ms/azsdk/mpg/js)\\r\\n:point_right: [Python](https://aka.ms/azsdk/mpg/python)\\n\\n### [Data plane](#tab/dataplane)\\n\\nThe following information will guide you from your data plane REST API spec, to code in the respective SDK repositories\\r\\nwith the generated SDK:\\r\\n:point_right: [.NET](https://aka.ms/azsdk/dpcodegen/net)\\r\\n:point_right: [Java](https://aka.ms/azsdk/dpcodegen/java)\\r\\n:point_right: [JavaScript DPG](https://aka.ms/azsdk/dpcodegen/js) (aka modular). This is the preferred JS flavor for codegen.\\r\\n:point_right: [JavaScript RLC](https://aka.ms/azsdk/rlc/js) (aka Rest Level Client). You must not attempt to generate RLC unless SDK archboard told you to.\\r\\n:point_right: [Python](https://aka.ms/azsdk/dpcodegen/python)\\r\\n:point_right: [Go (optional)](https://aka.ms/azsdk/dpcodegen/go).\\n\\n## Get help\\n\\n- If you need help with an automation tool or the Release planner, reach out to \\r\\n[Azure SDK / Azure SDK Onboarding](https://aka.ms/azsdk/support/onboarding-channel) channel.\\r\\n- If you need help with the development of the SDKs reach out to the [language specific Team's channel](xref:support#get-help-with-the-azure-sdks-development).\\r\\n- If you need to request an exception for a language review the [request release exception](xref:request-exception).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-generate-mgmt-dotnet.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-generate-mgmt-dotnet\",\"content\":\"# Generate .NET management plane SDK\\n## Generate SDKs with OpenAPI\\n- Specify a target version using `tag` as belows if you don't want to use the default tag in [the README configuration file](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/README.md). For example,\\r\\n\\r\\n```\\r\\ntag: package-2022-01-01-preview\\r\\n```\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e To ensure the preview of the corresponding .NET SDK in the API Spec PR, refrain from adding the tag here. Instead, use the default tag to generate the SDK and preview it as desired.\\r\\n\\r\\n2. Run `dotnet build` command to generate the SDK code, then AutoRest will create your .NET SDK using the latest version of your API specs.\\r\\n\\r\\n```\\r\\ndotnet build /t:GenerateCode\\r\\n```\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e Currently there could be some compatibility issues that the AutoRest tool can't handle. If you encounter generation errors, file an issue in the GitHub Repo [Azure/azure-sdk-for-net](https://github.com/Azure/azure-sdk-for-net) to get support.\\r\\n\\r\\n3. Generate the API file with the following command, review it and update any SDK API if it does not follow the [.NET Azure SDK Design Guidelines](https://azure.github.io/azure-sdk/dotnet_introduction.html) with [mgmt configurations](https://github.com/Azure/autorest.csharp/blob/feature/v3/docs/mgmt/readme.md#management-plane-configurations) in `autorest.md`. Then regenerate the API file.\\r\\n\\r\\n```\\r\\n\\u003cRepoRoot\\u003e\\\\eng\\\\scripts\\\\Export-API.ps1 servicelinker\\r\\n```\\r\\n\\r\\n:point_right: Replace `servicelinker` with your SDK service directory name under azure-sdk-for-net\\\\sdk.\\r\\n\\r\\n4. Once the SDK is generated, build your project either in VS or from command line (follow steps in the section [Build \\u0026 test SDKs](#build--test-sdks)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-prerequisites.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites\",\"content\":\"# Prerequisites to release client libraries (SDK)\\n## Customize SDKs\\nAfter generating client code with automation, it may be necessary to rename models, attributes, operations,\\r\\nor parameters to maintain consistent naming conversions.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e Azure SDK mandates adherence to a consistent set of naming conventions, which significantly enhances the overall usability of the SDK. For instance, in the case of Azure SDK for .NET, developers are required not only to follow the [general naming conventions of .NET](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions), but also to comply with specific guidelines regarding the naming of classes, properties, and methods. Further information is available at [Azure SDK for .NET – naming conventions](https://github.com/Azure/azure-sdk-for-net/blob/main/doc/dev/Mgmt-Naming-Conventions.md). Guidelines for additional languages are available at the [Azure SDKs site](https://azure.github.io/azure-sdk/general_introduction.html)\\r\\n\\r\\nTo customize the SDK as needed, you need to configure `client.tsp`. More details can be found at the \\r\\n[setup for SDK customization]( https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/01setup/)\\r\\nand [renaming types](https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/09renaming/#customizations). \\r\\n\\r\\nAfter set up SDK customization and apply renaming, ensure to re-run the SDK generation to regenerate the client libraries.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"retirement#sdk-deprecation.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/retirement/sdk-deprecation\",\"content\":\"# Deprecating Azure SDKs\\n## Azure SDK deprecation process\\nusing a PowerShell terminal:\\r\\n\\r\\n```\\r\\ngit clone https://github.com/Azure/azure-sdk.git\\r\\n```\\r\\n\\r\\n- Create a branch in your local copy of our repo:\\r\\n\\r\\n```\\r\\ngit checkout -b package_deprecation\\r\\n```\\r\\n\\r\\n- Launch VS Code and open the local repo folder:\\r\\n\\r\\n```\\r\\nFile -\\u003e Open Folder -\\u003e \\u003cSelect your local repo folder\\u003e\\r\\n```\\r\\n\\r\\n- Open the relevant CSV file in VS Code, located under the following directory:\\r\\n\\r\\n```\\r\\n\\u003cyour local path\\u003e\\\\azure-sdk\\\\_data\\\\releases\\\\latest\\\\\\r\\n   android-packages.csv\\r\\n   c-packages.csv\\r\\n   cpp-packages.csv\\r\\n   dotnet-packages.csv\\r\\n   go-packages.csv\\r\\n   ios-packages.csv\\r\\n   java-packages.csv\\r\\n   js-packages.csv\\r\\n   python-packages.csv\\r\\n```\\r\\n\\r\\n- Right click on the file in the Explorer window and select `Edit csv`. Find your package(s) in the CSV editor.\\r\\nPackage names are listed in the leftmost column.\\r\\n- Update the following mandatory fields:\\r\\n\\r\\n| Field | Description |\\r\\n| --- | --- |\\r\\n| `EOLDate` | Date your package will officially be deprecated in `mm/dd/yyyy` format |\\r\\n| `Support` | Change the value to **deprecated** |\\r\\n| `Replace` | Name of the package meant to replace the package being deprecated |\\r\\n| `ReplaceGuide` | Link to a migration guide in the following format: `aka.ms/azsdk/\\u003clanguage\\u003e/migrate/\\u003clibrary\\u003e` |\\r\\n\\r\\nIf an SDK deprecation is due to a service retirement, the end-of-life date (`EOLDate`) should match the service final\\r\\nretirement date.\\r\\n\\r\\n- Commit your changes to your local repository:\\r\\n\\r\\n```\\r\\ngit add .\\r\\ngit commit -m \\\"Update CSV files for package deprecation\\\"\\r\\n```\\r\\n\\r\\n- Push your changes to GitHub:\\r\\n\\r\\n```\\r\\ngit push origin package_deprecation\\r\\n```\\r\\n\\r\\n- Create a pull request. The previous push command output will include a link to your new branch on the console.\\r\\nOpen the link in your browser and click the green **Create Pull request** button.\\r\\n\\r\\nOnce the pull request is created, checks will run to verify the change and notify the repo owners to review your commit.\\r\\nOnce the change has been reviewed and approved, it can be merged.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"onboard#access.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/onboard/access\",\"content\":\"## Request access to Azure REST API and SDK repositories\\n### Write access\\nIf you're working on branches in the main repo for your spec, or working in the Azure SDK repositories to submit pull\\r\\nrequests or serving as the support contact for issues, you'll need write access so that you can apply or dismiss labels,\\r\\ncreate or modify issues, and assign issues to others. It also allows you to add/update test recordings in the test assets repo.\\r\\n\\r\\nTo get access to Azure SDK repos, request to join the [Azure SDK Partners](https://aka.ms/azsdk/join/azuresdkpartners) \\r\\nand have the request approved by your manager.  *After your manager approves*, it may take up to one day for you to automatically\\r\\nbe added to the [azure-sdk-partners](https://github.com/orgs/Azure/teams/azure-sdk-partners) GitHub team. This will get you\\r\\nwrite access to all Azure SDK related repos. These membership requests will need to be renewed every 180 days.\\r\\n\\r\\nNote that write access will also give you the ability to merge to the 'main' branch in each of the Azure SDK repos. However,\\r\\nthrough branch protection rules, CODEOWNERS approval of PRs is required. This means that for each file/folder your PR has\\r\\nmodified you will need to get approval from the corresponding people listed in the repo's  \\r\\n[CODEOWNERS file](https://github.com/Azure/azure-sdk/blob/main/docs/policies/opensource.md#codeowners). GitHub will automatically\\r\\nadd all matching CODEOWNERS as reviewers to the PR. You need approval from one CODEOWNER in each area in order to merge.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# Create a pull request with your Azure REST API spec update\\n## Get your PR merged\\n| Short Link: | [aka.ms/azsdk/specreview/merge](https://aka.ms/azsdk/specreview/merge) |\\r\\n|-|-|\\r\\n\\r\\nTo get your PR merged:\\r\\n\\r\\n1. Ensure the `Next Steps to Merge` comment and `Automated merging requirements met` check are green. \\r\\n1. Ensure at least one person has approved your PR. Generally another person from your team that has [write access] to the repo.\\r\\n1. Ensure all required checks are passing and at least investigate to understand any other non-required checks that may be failing. \\r\\n1. Once all required checks are green and any other issues understood you can merge the PR yourself as long as you have [write access] to the repo.\\r\\n1. If your PR is targeting public `main` you will need to first apply the `PublishToCustomers` label to acknowledge you understand this \\r\\n   will cause your spec to be published so customers can consume it.\\r\\n1. If your PR is targeting private repo `main` branch, it **cannot** be merged.\\r\\n   Instead, you can publish your changes to customers by following the guide at [aka.ms/azsdk/move-pr].\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#support.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/support\",\"content\":\"# Get help and support\\n## Get help with the Azure SDKs development\\nIf you need help with the development or testing of the SDK refer to the language-specific teams channels:\\r\\n\\r\\n- [.NET Teams channel]\\r\\n- [C Teams channel]\\r\\n- [C++ Teams channel]\\r\\n- [Java Teams channel]\\r\\n- [Go Teams channel]\\r\\n- [Mobile Teams Channel]\\r\\n- [Python Teams channel]\\r\\n- [Rust Teams channel]\\r\\n- [TypeScript/JS Teams channel]\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#pr-move-private-to-public.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/pr-move-private-to-public\",\"content\":\"| Short Link: | [aka.ms/azsdk/move-pr](https://aka.ms/azsdk/move-pr) |\\r\\n|--|--|\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Advanced cases\\n### Internal-only services\\nThere are some services that are \\\"internal only\\\" - none of their API versions are published in the public specs repo.\\r\\nThe Azure SDK team tooling running on the specs PRs may need to be updated to handle such cases.  \\r\\n[source](https://github.com/Azure/azure-sdk-tools/issues/7697#issuecomment-1980956741).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#namespace-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/namespace-review\",\"content\":\"# Review SDK package names\\n## Request a namespace review\\n### [Data plane](#tab/data)\\nPackage namespace are reviewed during the [SDK review meeting](xref:sdk-review), more concretely in the **Beta SDK review meeting**\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"retirement#sdk-deprecation.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/retirement/sdk-deprecation\",\"content\":\"# Deprecating Azure SDKs\\nThis section describes the process of marking SDK packages as deprecated on the Azure SDK inventory dashboard and on\\r\\npackage managers that host the packages.\\r\\n\\r\\nIt does not cover the wider retirement or deprecation process defined by Microsoft. For information on that process,\\r\\nrefer to the [Retirement Process and Policy Overview](https://aka.ms/aprwiki). The Retirement Process and Policy\\r\\nOverview uses the term \\\"retirement\\\" instead of \\\"deprecation,\\\" but we use the terms interchangeably.\"}]", "inputs.latency": 492.40868496894836, "inputs.response_length": 3299, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://eng.ms/docs/products/azure-developer-experience/develop/namespace-review", "https://eng.ms/docs/products/azure-developer-experience/develop/supporting-sdk-customers/codeowners", "https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites", "https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop"], "inputs.testcase": "Clarification on Folder Structure Alignment for CP and DP SDKs", "outputs.similarity.similarity": 3.0, "outputs.similarity.gpt_similarity": 3.0, "outputs.similarity.similarity_result": "fail", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 2021, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 2022, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Clarification on Folder Structure Alignment for CP and DP SDKs\\\\n\\\\nquestion: Hi\\\\nGeneral\\\\n,\\\\nOur CP SDKs for both .NET and JavaScript are currently placed under the playwright folder.\\\\njs->azure-sdk-for-js/sdk/playwright at main \\\\u00b7 Azure/azure-sdk-for-js\\\\nnet->azure-sdk-for-net/sdk/playwright at main \\\\u00b7 Azure/azure-sdk-for-net\\\\nwhile the non-Azure (DP) SDKs are placed under the loadtesting folder.\\\\njs->azure-sdk-for-js/sdk/loadtesting at main \\\\u00b7 Azure/azure-sdk-for-js\\\\nnet->azure-sdk-for-net/sdk/loadtestservice at main \\\\u00b7 Azure/azure-sdk-for-net\\\\nwe wanted to confirm:\\\\nIs it important or recommended to move the DP SDKs under the playwright folder to align with the CP SDK structure or the current structure is fine?\\\\nIf yes, could you please guide us on the recommended process or steps to make this shift (e.g., repo structure changes, PR approach, or naming conventions to follow)?\\\\nContext:\\\\nAs part of the retirement of Microsoft Playwright Testing (MPT) and its merger into Azure App Testing, we deprecated the old SDK packages associated with MPT and created new alternative packages about whose folder structure I mentioned above.\\\\nMPT\\\\u2019s core web testing capabilities are being integrated into Azure App Testing to provide a unified experience for both Load Testing and Playwright-based web testing. The standalone MPT service will be retired, and customers will need to migrate to Azure App Testing.\\\\nQiaoqiao Zhang Please help us with this.\\\\nThanks\\\\ncc Madhuri\\\", \\\"response\\\": \\\"Based on the provided Azure SDK onboarding and development guidelines, the folder structure for SDKs in Azure SDK repositories should be logical, consistent, and follow established conventions to ensure maintainability and discoverability. However, there is no explicit requirement or recommendation in the provided knowledge base that mandates aligning Data Plane (DP) SDKs under the same folder (e.g., 'playwright') as Control Plane (CP) SDKs if their functionality or API surface is distinct. \\\\n\\\\nGiven your context\\\\u2014retirement of Microsoft Playwright Testing (MPT), merger into Azure App Testing, and creation of new packages\\\\u2014it is important to ensure that:\\\\n- SDKs are named and organized to clearly reflect their service and functionality (see: naming conventions and namespace review).\\\\n- The folder structure should make it easy for customers and contributors to locate the relevant SDKs for a service.\\\\n\\\\nIf the Load Testing and Playwright-based web testing are now unified under Azure App Testing, and both DP and CP SDKs serve the same logical service, it is **recommended** to consider aligning them under a common folder (e.g., 'playwright' or a new 'app-testing' folder) to reflect the unified service. This alignment will:\\\\n- Improve clarity for customers migrating from MPT to Azure App Testing.\\\\n- Make maintenance and future onboarding processes easier.\\\\n\\\\n**Recommended Process and Steps:**\\\\n1. **Decide on the unified folder name:** If the service is now Azure App Testing, consider renaming to `sdk/app-testing` (preferred) or keep `sdk/playwright` if that best matches the API surface.\\\\n2. **Move DP SDKs:** Move the folders for DP SDKs (`loadtesting`, `loadtestservice`) under the chosen folder. Update all internal references and documentation.\\\\n3. **Update Namespace/Package Names:** If moving results in a namespace change, request a namespace review (see: 'namespace review').\\\\n4. **Deprecation Notice:** Clearly document the migration and folder change in the repo README and migration guides.\\\\n5. **Pull Request Approach:**\\\\n   - Create a PR in the relevant repo (e.g., azure-sdk-for-net, azure-sdk-for-js).\\\\n   - Move the folders and update references.\\\\n   - Add reviewers from CODEOWNERS (see: 'CODEOWNERS' guidelines).\\\\n   - Ensure all CI checks pass and required approvals are obtained.\\\\n   - Reference the retirement of MPT and merger into Azure App Testing in the PR description.\\\\n6. **Coordinate with SDK and service teams:** Announce the planned change in relevant Teams channels to ensure downstream tools and documentation are updated.\\\\n\\\\n**Naming conventions:**\\\\n- Follow the Azure SDK naming guidelines for class, package, and namespace names.\\\\n- If creating a new folder (e.g., 'app-testing'), ensure the name matches the service branding.\\\\n\\\\nIf the DP SDKs continue to represent a distinct logical API surface, the current structure is also acceptable as long as it is clearly documented and follows naming conventions.\\\\n\\\\n**Summary:**\\\\n- If DP and CP SDKs are now part of the same unified Azure App Testing service, move DP SDKs under the same folder as CP SDKs for clarity and consistency.\\\\n- Follow the steps above to migrate and coordinate the change.\\\\n- If they are logically distinct, the current structure is acceptable provided it is well-documented and follows naming conventions.\\\", \\\"ground_truth\\\": \\\"I think this should be a cross-language issue as in your tspconfig, the service-dir is sdk/playwrite which means all languages will generate the code under sdk/playwript. So you should update it in your tspconfig first. Then we can move the generated package into sdk/loadtesting folder in sdk repo\\\\ntspconfig:\\\\n```\\\\nparameters:\\\\n\\\\\\\"service-dir\\\\\\\":\\\\ndefault: \\\\\\\"sdk/playwright\\\\\\\"\\\\n```\\\\nFor Java, I see you already had a GA release in\\\\nhttps://github.com/Azure/azure-sdk-for-java/tree/main/sdk/playwright/azure-resourcemanager-playwright\\\\nIf this is your SDK, please do not modify the directory on Java. If you update the service-dir in parameters, please add a line\\\\n```\\\\nservice-dir: sdk/playwright\\\\n```\\\\nunder \\\\\\\"@azure-tools/typespec-java\\\\\\\":\\\\nGenerally, diretory in Java repo follows your package name and namespace, which both is playwright. Unless your package be e.g. azure-resourcemanager-loadtesting-playwright, the folder won't be loadtesting.\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"}, {"inputs.query": "title: Error running \"npx prettier\": Cannot find module 'prettier/plugins/estree'\n\nquestion: $  npx prettier --write specification/maps/data-plane/Weather/stable/1.1/weather.json\n[error] Cannot find module 'prettier/plugins/estree'\n[error] Require stack:\n[error] - C:\\github\\azure-rest-api-specs\\eng\\scripts\\prettier-swagger-plugin.js\n[error] - C:\\github\\azure-rest-api-specs\\node_modules\\prettier\\index.js\n[error] - C:\\github\\azure-rest-api-specs\\node_modules\\prettier\\cli.js\n[error] - C:\\github\\azure-rest-api-specs\\node_modules\\prettier\\bin-prettier.js", "inputs.ground_truth": "you should't need to install prettier yourself in any way.  Just run npm ci from the specs repo root.\nIf you've installed prettier globally, using either npx prettier or npm install -g prettier, they might interfere.  I believe npm/npx are supposed to handle this, and prefer the local install from the specs repo, but maybe that wasn't happening on your dev machine.", "inputs.response": "This issue is not directly related to TypeSpec, but I'll guide you based on the Azure REST API specs tooling knowledge. The error \"Cannot find module 'prettier/plugins/estree'\" when running `npx prettier` is commonly caused by a mismatch or corruption in your local node_modules, or by using an unsupported version of Prettier or its plugins.\n\nTo fix this, follow these steps:\n\n1. **Clean your repository dependencies:**\n   - Ensure you are on the correct branch (typically main or your PR target).\n   - Run:\n     ```sh\n     git clean -xdf\n     npm ci\n     ```\n   This will remove all old node_modules and install the exact dependencies as specified in package-lock.json.\n\n2. **Retry your command:**\n   - After cleaning and reinstalling, run your `npx prettier` command again.\n\n3. **Check Prettier Version:**\n   - The Azure REST API specs repo often uses a specific Prettier version with custom plugins. Make sure you have not globally installed a different Prettier version interfering with local usage.\n\nIf the error persists, make sure your repo is up to date with the latest from main and that you have no leftover files from previous installations.\n\nFor further troubleshooting steps, see the official guidance:\n- https://github.com/Azure/azure-rest-api-specs/wiki/Contributing#update-toolchain\n\nIf you still experience issues, open a new issue on the repo describing your environment and steps you've taken.", "inputs.context": "[{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#rest-api-publish#buildpipelines.md\",\"document_title\":\"Using Build Pipelines with TypeSpec\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/rest-api-publish/buildpipelines\",\"content\":\"# howtos#rest-api-publish#buildpipelines.md\\n\\n# Using Build Pipelines with TypeSpec\\n\\nThis doc will help you get started with using TypeSpec in your build pipelines in your own repository. [See here for more how to use in the azure-rest-api-specs repo](./checking-in-api-specs-guide.md)\\n\\n## Table of Contents\\n\\n1. [Introduction](#introduction)\\r\\n1. [Azure DevOps Pipelines](#azure-devops-pipelines)\\n\\n## Introduction\\n\\n### Dependencies\\n\\nIn order to build TypeSpec in your build pipeline, you will need to ensure that the following are available or are automatically installed by your project:\\r\\n\\r\\n1. NodeJS 22.x LTS (Recommended)\\r\\n2. TypeSpec compilation tools (via npm package)\\n\\n## Azure DevOps Pipelines\\n\\nDepending on your project, you may need to add NodeJS and install NPM packages for TypeSpec.\\r\\nThe following Azure Devops Pipeline tasks can be modified and added to your pipeline yaml file if you do not already utilize NodeJS in your project.\\r\\n\\r\\n```yaml title=\\\".azure-pipelines.yml\\\"\\n\\n# Install NodeJS\\n\\n- task: NodeTool@0\\r\\n  inputs:\\r\\n    versionSpec: \\\"22.x\\\"\\r\\n    checkLatest: false\\n\\n# Install dependencies\\n\\n- script: npm install\\r\\n  workingDir: path/to/typespec/project # This is where package.json lives for your TypeSpec project\\n\\n# Build\\n\\n- script: npx tsp compile .\\r\\n  workingDir: path/to/typespec/project # This is where package.json lives for your TypeSpec project\\r\\n```\\r\\n\\r\\nThis is sufficient if you are building via a csproj file which triggers the tsp compile and finds the tsp compiler itself.\\r\\n\\r\\nYou may also need to add additional steps to compile your typespec files separately. An example of a basic pipeline is provided below.\\r\\n\\r\\n### Example Pipeline Configuration\\r\\n\\r\\nNote: This example assumes that your TypeSpec folder is at the root of your repository.\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#configuration#configuration.mdx\",\"document_title\":\"Configuration\",\"document_link\":\"https://typespec.io/docs/handbook/configuration/configuration\",\"content\":\"# handbook#configuration#configuration.mdx\\n\\n# Configuration\\n\\nimport { FileTree } from \\\"@astrojs/starlight/components\\\";\\r\\n\\r\\nThe TypeSpec compiler and libraries can be configured either via a configuration-file or command line flags.\\n\\n## Configuration file\\n\\nTypeSpec configuration can be provided via the `tspconfig.yaml` configuration file.\\n\\n### Discovery\\n\\nThe TypeSpec compiler will look for the closest `tspconfig.yaml` file located in the same directory or closest parent directory from the TypeSpec entrypoint.\\r\\n\\r\\nFor example if running `tsp compile /dev/foo/bar/main.tsp`, the compiler will lookup the file at the folllowing paths (in order):\\r\\n\\r\\n- `/dev/foo/bar/tspconfig.yaml`\\r\\n- `/dev/foo/tspconfig.yaml`\\r\\n- `/dev/tspconfig.yaml`\\r\\n- `/tspconfig.yaml`\\n\\n### Schema\\n\\nThe file is a `yaml` document with the following structure. See the [next section](#typespec-configuration-options) for details on each option.\\r\\n\\r\\n```typespec\\r\\nmodel TypeSpecProjectSchema {\\r\\n  extends?: string;\\r\\n  parameters?: Record\\u003c{default: string}\\u003e\\r\\n  `environment-variables`?: Record\\u003c{default: string}\\u003e\\r\\n  `warn-as-error`?: boolean;\\r\\n  `output-dir`?: string;\\r\\n  `trace`?: string | string[];\\r\\n  imports?: string[];\\r\\n  emit?: string[];\\r\\n  `dry-run`?: boolean;\\r\\n  options?: Record\\u003cunknown\\u003e;\\r\\n  linter?: LinterConfig;\\r\\n}\\r\\n\\r\\nmodel LinterConfig {\\r\\n  extends?: RuleRef[];\\r\\n  enable?: Record\\u003cRuleRef, boolean\\u003e;\\r\\n  disable?: Record\\u003cRuleRef, string\\u003e;\\r\\n}\\r\\n```\\n\\n### Extending Project Files\\n\\nThere may be instances where you want to build different folders with varying options (such as different emitters), but still want to share some common configurations.\\r\\n\\r\\nIn such cases, you can use the `extends` property in the configuration file.\\r\\n\\r\\nFor instance, in `\\u003cmy-pkg\\u003e/tspconfig.yaml`:\\r\\n\\r\\n```yaml title=tspconfig.yaml\\r\\noptions:\\r\\n  emitter1:\\r\\n    some-option: my-name\\r\\n  emitter2:\\r\\n    some-other-option: This is a title\\r\\n```\\r\\n\\r\\nin `\\u003cmy-pkg\\u003e/proj2/tspconfig.yaml`, enable `emitter1` using the options specified in the parent `tspconfig.yaml`\\r\\n\\r\\n```\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Requirement.md\",\"document_title\":\"Table of Contents\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Requirement\",\"content\":\"# TypeSpec-Requirement.md\\n\\n# Table of Contents\\n\\n- [Overview](#overview)\\r\\n- [Suppressing Failures](#suppressing-failures)\\r\\n- [Renaming Specs](#renaming-specs)\\n\\n# Overview\\n\\nCheck `TypeSpec Requirement` enforces the rule that all \\\"new\\\" specs must use TypeSpec (instead of hand-written Swagger).  A \\\"new\\\" spec is defined as any spec that does **not** have a `stable` version in `main`.\\n\\n# Suppressing Failures\\n\\nIf you need to suppress this check (instead of converting to TypeSpec), add entries to the `suppressions.yaml` for your spec.  Example:\\r\\n\\r\\n```\\r\\n# specification/widget/resource-manager/Microsoft.Widget/Widget/suppressions.yaml\\r\\n- tool: TypeSpecRequirement\\r\\n  paths: \\r\\n    - preview/2022-08-01-preview/**/*.json\\r\\n    - preview/2023-02-01-preview/**/*.json\\r\\n```\\r\\n\\r\\nMore examples: https://github.com/search?q=TypeSpecRequirement+repo%3Aazure%2Fazure-rest-api-specs+path%3A**%2Fsuppressions.yaml\\u0026type=code\\n\\n# Renaming Specs\\n\\nThe check may return a \\\"false positive\\\" if you rename an existing spec folder in a PR, since the new name doesn't exist in `main`.  You can use a suppression in these cases.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-tooling.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-tooling\",\"content\":\"# design#api-specs#api-tooling.md\\n\\n| Short Link: | [aka.ms/azsdk/specprtools](https://aka.ms/azsdk/specprtools) |\\r\\n|--|--|\\n\\n# Use tools to create and validate Azure REST APIs specs\\n\\n## [Author With TypeSpec](#tab/author-with-typespec)\\n\\nAuthor specs with TypeSpec (**recommended approach**)\\r\\n\\r\\nREST APIs authored in [TypeSpec](xref:api-typespec) with the [Azure TypeSpec libraries] have validation built in.\\r\\nCompiling the TypeSpec definition will validate the REST API against the Azure API guidelines.\\r\\nThe TypeSpec compiler will also generate an [OpenAPI](xref:api-openapi) definition for the REST API.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e TypeSpec has [plugins for Visual Studio and Visual Studio Code][TypeSpec plugins] that will highlight errors and\\r\\nwarnings in your TypeSpec definition.\\r\\n\\r\\nTypeSpec is the recommended way for generating OpenAPI specs.\\n\\n## [Author with OpenAPI](#tab/author-with-openapi)\\n\\nAuthor specs with OpenAPI (**legacy approach**)\\r\\n\\r\\nFor REST APIs that cannot be written in TypeSpec and still must be written directly in the OpenAPI format, you can:\\r\\n\\r\\n- Use [OpenAPI Initiative Swagger editor] for basic authoring.\\r\\n- Learn about the [spec directory structure].\\r\\n- Use the [Spectral linter] and the [Azure Spectral ruleset] to validate your OpenAPI definition against the Azure API\\r\\n  guidelines.\\r\\n  - Spectral provides a [VSCode plugin][Spectral VSCode plugin] that will highlight errors and warnings in your\\r\\n    OpenAPI definition in VSCode.\\r\\n\\r\\nYour OpenAPI definitions, to be published, will have to end up in the specs repos as explained in  \\r\\n[this article](xref:api-specs). As such, they will be subject to additional mandatory validation requirements.\\r\\nSee [validate your REST API](#validate-your-rest-api-specs) section to learn about them.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Duplicate model definition errors on compilation with TypeSpec Compiler v1.0.0 - Microsoft.Mission\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Duplicate model definition errors on compilation with TypeSpec Compiler v1.0.0 - Microsoft.Mission\\n\\n## question\\n\\nDuplicate type name: 'Approver'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 65 | model Approver {\\r\\n       |       ^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/shared/principal.tsp:5:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'Principal'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 5 | model Principal {\\r\\n      |       ^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/virtualEnclave/virtualenclave.tsp:32:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'SubnetConfiguration'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 32 | model SubnetConfiguration {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/shared/governedserviceitem.tsp:5:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'ServiceIdentifier'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 5 | union ServiceIdentifier {\\r\\n      |       ^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/community/community.tsp:31:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'ApprovalPolicy'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 31 | union ApprovalPolicy {\\r\\n       |       ^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/community/community.tsp:43:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'MandatoryApprover'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 43 | model MandatoryApprover {\\r\\n       |       ^^^^^^^^^^^^^^^^^\\n\\n@friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 5 | model RoleAssignmentItem {\\r\\n      |       ^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/shared/governedserviceitem.tsp:55:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'GovernedServiceItem'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 55 | model GovernedServiceItem {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/transitHub/transitHub.tsp:10:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'TransitHubState'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 10 | union TransitHubState {\\r\\n       |       ^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/transitHub/transitHub.tsp:53:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'TransitOption'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 53 | model TransitOption {\\r\\n       |       ^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/enclaveEndpoint/enclaveEndpoint.tsp:36:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'EnclaveEndpointDestinationRule'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 36 | model EnclaveEndpointDestinationRule {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/communityEndpoint/communityEndpoint.tsp:59:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'CommunityEndpointDestinationRule'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 59 | model CommunityEndpointDestinationRule {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\\nCheck @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 36 | model EnclaveEndpointDestinationRule {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/communityEndpoint/communityEndpoint.tsp:59:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'CommunityEndpointDestinationRule'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 59 | model CommunityEndpointDestinationRule {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/virtualEnclave/virtualenclave.tsp:32:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'SubnetConfiguration'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 32 | model SubnetConfiguration {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/shared/principal.tsp:5:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'Principal'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 5 | model Principal {\\r\\n      |       ^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/shared/governedserviceitem.tsp:5:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'ServiceIdentifier'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 5 | union ServiceIdentifier {\\r\\n      |       ^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/transitHub/transitHub.tsp:30:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'TransitOptionType'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 30 | union TransitOptionType {\\r\\n       |       ^^^^^^^^^^^^^^^^^\\n\\nCheck @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 44 | model TransitOptionParams {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/enclaveEndpoint/enclaveEndpoint.tsp:13:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'EnclaveEndpointProtocol'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 13 | union EnclaveEndpointProtocol {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/communityEndpoint/communityEndpoint.tsp:42:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'DestinationType'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 42 | union DestinationType {\\r\\n       |       ^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/communityEndpoint/communityEndpoint.tsp:13:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'CommunityEndpointProtocol'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 13 | union CommunityEndpointProtocol {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/approvals/approvals.tsp:32:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'ActionPerformedEnum'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 32 | union ActionPerformedEnum {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^\\r\\n  \\r\\n  Found 50 errors.\\r\\n```\\n\\nCheck @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 5 | union ServiceIdentifier {\\r\\n      |       ^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/transitHub/transitHub.tsp:30:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'TransitOptionType'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 30 | union TransitOptionType {\\r\\n       |       ^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/transitHub/transitHub.tsp:44:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'TransitOptionParams'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 44 | model TransitOptionParams {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/enclaveEndpoint/enclaveEndpoint.tsp:13:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'EnclaveEndpointProtocol'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 13 | union EnclaveEndpointProtocol {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/communityEndpoint/communityEndpoint.tsp:42:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'DestinationType'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 42 | union DestinationType {\\r\\n       |       ^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/communityEndpoint/communityEndpoint.tsp:13:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'CommunityEndpointProtocol'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 13 | union CommunityEndpointProtocol {\\r\\n       |       ^^^^^^^^^^^^^^^^^^^^^^^^^\\n\\n'TransitHubState'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 10 | union TransitHubState {\\r\\n       |       ^^^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/transitHub/transitHub.tsp:53:7 - error @typespec/openapi/duplicate-type-name: Duplicate type name: 'TransitOption'. Check @friendlyName decorators and overlap with types in TypeSpec or service namespace.\\r\\n  \\u003e 53 | model TransitOption {\\r\\n       |       ^^^^^^^^^^^^^\\r\\n  specification/mission/Mission.Management/resourcetypes/enclaveEndpoint/enclaveEndpoint.tsp:36:7 - error @typespec/openapi/duplicate-type-name: Duplicate type nam\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_26.md\",\"document_title\":\"Is TypeSpec migration complete for folder: recoveryservicesbackup.\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_26.md\\n\\n# Is TypeSpec migration complete for folder: recoveryservicesbackup.\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\nWe had PR in flight: [Adding stable 2025 08 01 for completeness by risraj10 · Pull Request #37381 · Azure/azure-rest-api-…](https://github.com/Azure/azure-rest-api-specs/pull/37381)\\r\\nHowever, I see that TypeSpec migration was done couple of days ago for this folder. \\r\\nI have cancelled the above PR and trying to raise a new PR. However, just running npx tsp compile without any change is giving errors.\\r\\nAnd also it is making unintended change to OpenAPI json file even to existing version. I guess the tsp and OpenAPI json are not in sync.\\r\\nHence, wanted to check if the migration is really complete for this folder.\\n\\n## answer\\n\\nMain typespec validation should always be passing are you sure you are up you are with dependencies locally?\\r\\nMake sure to follow instructions here https://aka.ms/ci-fix\\r\\nJust to reiterate, this is almost always because you need to pull the latest from the target branch into your local clone of the repo, and re-install dependencies at the root.\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"SecurityDefinitionsStructure error on PR\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# SecurityDefinitionsStructure error on PR\\n\\n## question\\n\\nHi,\\r\\nI am seeing this error after adding auth section in my typespec. [Add Azure Health Model Query APIs by vikashy-microsoft · Pull Request #22787 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/22787/checks?check_run_id=42815390637)\\r\\nThe structure looks correct to me except casing for \\\"azure_auth\\\" which is in pascal case \\\"AzureAuth\\\". Am I missing something?\\r\\n \\r\\nI also see some typespec validation failures, I don't see any errors locally when I run `npx tsv .\\\\specification\\\\cloudhealth\\\\CloudHealth.HealthModels.Data`, how can I debug that further? [Add Azure Health Model Query APIs · Azure/azure-rest-api-specs-pr@cfc193c](https://github.com/Azure/azure-rest-api-specs-pr/actions/runs/15220602300/job/42815390614)\\n\\n## answer\\n\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\\r\\n![image](https://github.com/jianingwang123/test/blob/main/image/image%20(11).png?raw=true)\\r\\nyou need to run \\\"tsp format\\\" (which is handled by \\\"npx tsv\\\") and commit the results\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-07-17.md\",\"document_title\":\"Error reported from common library with intersect-duplicate-property\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-07-17.md\\n\\n# Error reported from common library with intersect-duplicate-property\\n\\n## question\\n\\nSome duplicate exceptions thrown from the common library during the tsp compile, e.g.intersect-duplicate-property, duplicate-property\\n\\n## answer\\n\\nCheck the error properties, find them in the spec, remove them.\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-08-07.md\",\"document_title\":\"missing pattern on parameter in path\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-08-07.md\\n\\n# missing pattern on parameter in path\\n\\n## question\\n\\n```diff\\r\\n   \\\"name\\\": \\\"configurationName\\\",\\r\\n   \\\"in\\\": \\\"path\\\",\\r\\n   \\\"required\\\": true,\\r\\n   \\\"type\\\": \\\"string\\\",\\r\\n-  \\\"pattern\\\": \\\"^.*$\\\",\\r\\n   \\\"enum\\\": [\\r\\n     \\\"default\\\"\\r\\n   ],\\r\\n```\\n\\n## answer\\n\\nBecause this parameter in path has an enum type, and currently TypeSpec cannot add patterns for this type of parameter, so just ignore it directly\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"extending-typespec#basics.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/extending-typespec/basics\",\"content\":\"# Creating a TypeSpec Library\\n## Prerequisites\\nYou'll need to have both Node and npm installed. If you're planning to develop multiple libraries simultaneously, it's recommended to set up a monorepo to simplify the development process. TypeSpec itself uses [pnpm](https://pnpm.io/).\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#formatter.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/handbook/formatter\",\"content\":\"# Formatter\\nTypeSpec comes with a built-in formatter. The formatter can be used in different ways:\\r\\n\\r\\n- [Via the cli](#via-the-cli)\\r\\n- Via the VS Code/vs extension\\r\\n- As a `prettier` plugin\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Contributing.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Contributing\",\"content\":\"## Update toolchain\\n- Merge latest from your target branch (e.g. `main`, `RPSaaSMaster`) to your source branch\\r\\n- Run `npm ci` again\\r\\n- If errors or incorrect tool versions, ensure no uncommitted changes, then run `git clean -xdf` to remove all old files, and try again\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-BreakingChanges.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-BreakingChanges\",\"content\":\"# Docs\\nhttps://aka.ms/CPEXBreakingChangesProcess\\r\\n\\r\\nhttps://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# TypeSpec\\n## `IntegerTypeMustHaveFormat`\\nData-plane specs can suppress violations of this rule, since it only exists for the benefit of SDKs generated from swagger, and data-plane SDKs are generated directly from TypeSpec.  Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Spec-Model.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Spec-Model\",\"content\":\"# Overview\\n`spec-model` is a shared component that returns a \\\"model\\\" of a spec folder.  The \\\"model\\\" includes data like the readme.md files, the tags within those readmes, the swagger files within those tags, etc.  This code was recently made more strict, so existing specs that were previously passing checks, may now start seeing errors that must be fixed.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-docs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-docs\",\"content\":\"# Publish REST API reference docs\\n## Onboard to the content publishing services team\\n### Automatic refresh\\nAPI references can be automatically refreshed on the latest API version after first time onboarding.\\r\\nTo enable automatic refresh, a README configuration file with a default tag referring to all spec files of the latest\\r\\nAPI version is __required__. See the [sample README].\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"| Short Link: | [aka.ms/convert-to-typespec](https://aka.ms/convert-to-typespec) |\\r\\n| --- | --- |\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# Suppress validation failures on a PR\\n## Troubleshooting AutoRest suppressions not working\\n### Ensure you are suppressing the right tag (API version)\\nIf, for example, the error pertains to API version 2021-09-01, then the suppressions must be in\\r\\nthe `### Tag: package-2021-09-01` section, not `### Tag: package-2021-09-01-preview` or `### Tag: package-2023-04-27`.\"}]", "inputs.latency": 654.4650251865387, "inputs.response_length": 1413, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://github.com/Azure/azure-rest-api-specs/wiki/Contributing"], "inputs.testcase": "Error running \"npx prettier\": Cannot find module 'prettier/plugins/estree'", "outputs.similarity.similarity": 4.0, "outputs.similarity.gpt_similarity": 4.0, "outputs.similarity.similarity_result": "pass", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1366, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1367, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Error running \\\\\\\"npx prettier\\\\\\\": Cannot find module 'prettier/plugins/estree'\\\\n\\\\nquestion: $  npx prettier --write specification/maps/data-plane/Weather/stable/1.1/weather.json\\\\n[error] Cannot find module 'prettier/plugins/estree'\\\\n[error] Require stack:\\\\n[error] - C:\\\\\\\\github\\\\\\\\azure-rest-api-specs\\\\\\\\eng\\\\\\\\scripts\\\\\\\\prettier-swagger-plugin.js\\\\n[error] - C:\\\\\\\\github\\\\\\\\azure-rest-api-specs\\\\\\\\node_modules\\\\\\\\prettier\\\\\\\\index.js\\\\n[error] - C:\\\\\\\\github\\\\\\\\azure-rest-api-specs\\\\\\\\node_modules\\\\\\\\prettier\\\\\\\\cli.js\\\\n[error] - C:\\\\\\\\github\\\\\\\\azure-rest-api-specs\\\\\\\\node_modules\\\\\\\\prettier\\\\\\\\bin-prettier.js\\\", \\\"response\\\": \\\"This issue is not directly related to TypeSpec, but I'll guide you based on the Azure REST API specs tooling knowledge. The error \\\\\\\"Cannot find module 'prettier/plugins/estree'\\\\\\\" when running `npx prettier` is commonly caused by a mismatch or corruption in your local node_modules, or by using an unsupported version of Prettier or its plugins.\\\\n\\\\nTo fix this, follow these steps:\\\\n\\\\n1. **Clean your repository dependencies:**\\\\n   - Ensure you are on the correct branch (typically main or your PR target).\\\\n   - Run:\\\\n     ```sh\\\\n     git clean -xdf\\\\n     npm ci\\\\n     ```\\\\n   This will remove all old node_modules and install the exact dependencies as specified in package-lock.json.\\\\n\\\\n2. **Retry your command:**\\\\n   - After cleaning and reinstalling, run your `npx prettier` command again.\\\\n\\\\n3. **Check Prettier Version:**\\\\n   - The Azure REST API specs repo often uses a specific Prettier version with custom plugins. Make sure you have not globally installed a different Prettier version interfering with local usage.\\\\n\\\\nIf the error persists, make sure your repo is up to date with the latest from main and that you have no leftover files from previous installations.\\\\n\\\\nFor further troubleshooting steps, see the official guidance:\\\\n- https://github.com/Azure/azure-rest-api-specs/wiki/Contributing#update-toolchain\\\\n\\\\nIf you still experience issues, open a new issue on the repo describing your environment and steps you've taken.\\\", \\\"ground_truth\\\": \\\"you should't need to install prettier yourself in any way.  Just run npm ci from the specs repo root.\\\\nIf you've installed prettier globally, using either npx prettier or npm install -g prettier, they might interfere.  I believe npm/npx are supposed to handle this, and prefer the local install from the specs repo, but maybe that wasn't happening on your dev machine.\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"}, {"inputs.query": "title: Error writing to PR in RPSAASDev branch\n\nquestion: I'm seeing an error when trying to push my changes to a branch off of RPSaaSDev. Has anyone seen this before or would it be a sign that my write access request (Azure SDK Partners on CoreIdentity) is still propagating?\npushing to this PR:[Private.DeviceRegistry 2026-04-01 by yijinglu-microsoft · Pull Request #25274 · Azure/azure-rest-ap…](https://github.com/Azure/azure-rest-api-specs-pr/pull/25274/files)", "inputs.ground_truth": "GitHub is experience an outage on all HTTP and SSH git operations, please check status using https://www.githubstatus.com/.", "inputs.response": "Sorry, I can't access the content of the linked PR, but I can guide you based on the provided Azure SDK onboarding knowledge. \n\nIf you are seeing an error when trying to push changes to a branch off of RPSaaSDev, one common reason is insufficient write access to the repository. According to the onboarding documentation, write access is required to push changes, create PRs, and manage issues in Azure SDK repos. \n\nIf your request to join the Azure SDK Partners (for CoreIdentity) was only recently approved, it can take up to one day for access to propagate after manager approval. During this time, you may experience permission errors when pushing or updating branches. Once access is granted, you should be added to the azure-sdk-partners GitHub team, which will allow you to push to branches such as RPSaaSDev.\n\nIf you continue to see errors after 24 hours, confirm you are listed in the GitHub team and that your request was approved. If the issue persists, you may want to reach out to the onboarding support channel for direct assistance.\n\nActionable next steps:\n- Wait up to 24 hours after manager approval for access to propagate.\n- Check your membership in the azure-sdk-partners GitHub team.\n- If access is still missing after propagation, contact onboarding support for troubleshooting.\n\nLet me know if you need guidance on verifying your access or have other onboarding issues.", "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"Create a PR against main\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\\n\\n# Create a PR against main\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nWhen you're ready for a final review, it's time to create a pull request (PR) from your release branch you created\\r\\noriginally to the `main` branch on [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n* :warning: Do not merge `main` or other release branches unless you know there are changes required.\\r\\n* :white_check_mark: Rebase on `main` if changes are required in a separate topic branch.\\n\\n## Clean PR against main\\n\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\\n\\n## Update your branch with changes from main\\n\\nIf you know there are other changes in the `main` branch or that other services have updated shared files in `main`\\r\\nalready and you need to pick up changes before merging, we recommend you take a merge from main. This is particularly interesting\\r\\nfor common infrastructure changes that are committed in the repo (i.e. github actions, tools, etc). Depending on how old your\\r\\nbranch is some of the pull request checks may not correctly function without taking a merge from main. \\r\\n\\r\\nIf you are working in a non-protected branch you can do a `git merge main` like you would normally do a merge and then push\\r\\nyour changes to your remote branch. However, if you are working in a branch with branch protection enabled (i.e. `release-*`) then\\r\\nyou will need to make a pull request to your branch with the merge. Depending on how out-of-date your branch is from `main` your \\r\\nmerge may have a lot of unwanted and unnecessary changes and the checks not pass. In such cases see below on how to [update the infrastructure](#updating-only-the-infrastructure-changes-from-main).\\n\\n### Updating only the infrastructure changes from main\\n\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\\n\\n## Next steps\\n\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-1-branch.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-1-branch\",\"content\":\"# Create a new branch\\nYou'll first want to create a new branch in which to do your work and that everyone working on changes can target.\\r\\nWe support different type of branches. To learn more about them see [here](xref:api-versions-and-branches).\\r\\n\\r\\n- :white_check_mark: Create a separate branch for each release that a team can work on together, whether\\r\\npreview or stable.\\r\\n- :ballot_box_with_check: Consider customizing the branch name to something discoverable, memorable, and consistent.\\r\\n\\r\\n\\u003e [!Note]\\r\\n\\u003e This tutorial uses the *release* branch, which has branch protection rules against it. Learn more about the different\\r\\n\\u003e branches and branch protection rules [here](xref:api-versions-and-branches).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Breaking changes and versioning issues\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"onboard#access.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/onboard/access\",\"content\":\"## Request access to Azure REST API and SDK repositories\\n### Write access\\nIf you're working on branches in the main repo for your spec, or working in the Azure SDK repositories to submit pull\\r\\nrequests or serving as the support contact for issues, you'll need write access so that you can apply or dismiss labels,\\r\\ncreate or modify issues, and assign issues to others. It also allows you to add/update test recordings in the test assets repo.\\r\\n\\r\\nTo get access to Azure SDK repos, request to join the [Azure SDK Partners](https://aka.ms/azsdk/join/azuresdkpartners) \\r\\nand have the request approved by your manager.  *After your manager approves*, it may take up to one day for you to automatically\\r\\nbe added to the [azure-sdk-partners](https://github.com/orgs/Azure/teams/azure-sdk-partners) GitHub team. This will get you\\r\\nwrite access to all Azure SDK related repos. These membership requests will need to be renewed every 180 days.\\r\\n\\r\\nNote that write access will also give you the ability to merge to the 'main' branch in each of the Azure SDK repos. However,\\r\\nthrough branch protection rules, CODEOWNERS approval of PRs is required. This means that for each file/folder your PR has\\r\\nmodified you will need to get approval from the corresponding people listed in the repo's  \\r\\n[CODEOWNERS file](https://github.com/Azure/azure-sdk/blob/main/docs/policies/opensource.md#codeowners). GitHub will automatically\\r\\nadd all matching CODEOWNERS as reviewers to the PR. You need approval from one CODEOWNER in each area in order to merge.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"plan#upcoming_release_planner_change.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/plan/upcoming_release_planner_change\",\"content\":\"# SDK self-serve for TypeSpec generated management plane SDKs\\n## **2. Generate SDK**\\nResponsible: Service owner\\r\\n\\r\\n1. Submit a request using release planner. More information about release planner is available  \\r\\n[here](https://eng.ms/docs/products/azure-developer-experience/plan/release-plan).\\r\\n2. Automation creates an issue in the [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) repository and it is assigned to Copilot.\\r\\n3. This uses our [automation pipelines](xref:sdk-generate) and as a result it creates a PR in each language repo.\\r\\n4. PRs are open in `DRAFT` state and links for these PRs will be visible in the generate SDK step in the release planner.\\r\\n5. Service owner needs to verify the content of the PRs.\\r\\n6. When the PR is ready for review, access the PR URL and click on `Ready for review` button in GitHub. This will assign the Azure SDK team as reviewers.\\r\\n7. Azure SDK team reviews and approves PR.\\r\\n8. Service team addresses feedback and is responsible for merging the PR.\\r\\n\\r\\n**Troubleshooting steps:**\\r\\n\\r\\nSDK is generated by GitHub Copilot Agent when a generate SDK request is submitted. The release planner contains the link to this GitHub tracking issue.\\r\\n\\r\\nIf the SDK PR doesn’t appear in the release planner within **~30 minutes** after submitting a request, or if you need to **regenerate** the SDK, follow these steps to check the status:\\r\\n\\r\\n1. Identify the GitHub issue created for SDK generation. This is visible in the **Generate SDK** step in the release planner. \\r\\n2. Open the GitHub issue and identify the PR associated with the GitHub issue. This PR is assigned to GitHub Copilot.\\r\\n3. Check for any comment on GitHub PR that indicates any failure to generate SDK. If SDK generation pipeline is in failed status, you can access the failure reason by clicking on pipeline run link.\\r\\n4. If failure indicates any changes required in API spec TypeSpec project:\\r\\n\\r\\n  -  Update the **TypeSpec project** as needed\\r\\n- Create a new TypeSpec PR or push changes to existing one (if it's still open).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-repos.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-repos\",\"content\":\"# Azure REST API specs repositories on GitHub\\nThe REST API descriptions for all Azure services should be published in the Azure REST API specs GitHub repositories.\\r\\n\\r\\nThe [Azure/azure-rest-api-specs] is the public repository. All work done in this repository is public, i.e. visible to\\r\\neveryone, including people outside of Microsoft. Any Azure REST API specification updates must be merged to the `main`\\r\\nbranch as part of the process of releasing those updates to Microsoft customers.\\r\\n\\r\\nThe [Azure/azure-rest-api-specs-pr] is the private repository (the \\\"pr\\\" stands for \\\"private\\\"). It is for work that must\\r\\nremain private until it is ready to be published. For example, if your team is working on a new product with a new Azure\\r\\nResource Manager (ARM) or Resource Provider (RP) namespace, you want to keep developing it in the private repository\\r\\nuntil you have drafted, tested and went through the API review process. Only after this is done, you must merge your\\r\\nchanges to the `main` branch in the public repository.\\r\\n\\r\\nThe `main` branch in the private repository is read-only, as it is mirrored from the public repository `main` branch.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Branch protection rules table\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\nThis table shows which GitHub checks are marked as `required` on respective branches. Even when a check is marked as ❌\\r\\nit **may** still be running on given branch; just that if it fails, the PR won't be blocked from merging.\\r\\n\\r\\n| Branch | Merge | SDK | TSVal | BrCh | BrChC | LintRPaaS | LintDiff | Model | Semantic | Spell | Prettier | license | approver |\\r\\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\\r\\n| public `main`                  | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSMaster`         | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| public/private `release-*`     | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSDev`            | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `InternalARMContracts` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `ARMCoreRPDev`         | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n\\r\\nLegend:\\r\\n\\r\\n| Column name | Full GitHub check name               |\\r\\n|-------------|--------------------------------------|\\r\\n| `BrCh`      | `Swagger BreakingChange`             |\\r\\n| `BrChC`     | `Breaking Change(Cross-Version)`     |\\r\\n| `license`   | `license/cla`                        |\\r\\n| `LintDiff`  | `Swagger LintDiff`                   |\\r\\n| `LintRPaaS` | `Swagger Lint(RPaaS)`                |\\r\\n| `Merge`     | `Automated merging requirements met` |\\r\\n| `Model`     | `Swagger ModelValidation`            |\\r\\n| `Prettier`  | `PrettierCheck`                      |\\r\\n| `SDK`       | `SDK azure-sdk-for-go`               |\\r\\n| `Semantic`  | `Swagger SemanticValidation`         |\\r\\n| `Spell`     | `SpellCheck`                         |\\r\\n| `TSVal`     | `TypeScript Validation`              |\\r\\n| `approver`  | Requires team member approval        |\\r\\n\\r\\nFor more information on these checks, see:\\r\\n\\r\\n- https://aka.ms/azsdk/pr-getting-help\\r\\n- https://aka.ms/ci-fix\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#troubleshoot#PR-failing.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/troubleshoot/PR-failing\",\"content\":\"# I've submitted a pull request, but the build isn't succeeding or tests are failing!\\n\\u003e [!NOTE]\\r\\n\\u003e If you are looking for help with a PR submitted to one of [the Azure REST API specs repositories](xref:api-repos),\\r\\n\\u003e please refer to [this support page](xref:support#get-help-with-prs-submitted-against-the-azure-rest-api-specification-repositories).\\r\\n\\r\\nCongratulations! You've submitted a pull request. As part of the pull request approval process we ensure that the code\\r\\nbuild and tests successfully, as well as performing a range of other validation steps. Generally speaking the build\\r\\nerrors associated with the pipeline run are sufficient to diagnose and fix any issues with your PR. You can access\\r\\nthe build logs by clicking on the failing check run, and then using the view details link to navigate to the error in\\r\\nAzure Pipelines.\\r\\n\\r\\nIf you cannot understand the reason for the failure, ask a question in the _language team_ channel appropriate to the\\r\\nrepository that you are working in. Each language team is the first point of contact for build failures within their\\r\\nrepository.\\r\\n\\r\\nReach to the [language specific Team's channel](xref:support#get-help-with-the-azure-sdks-development).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-develop.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop\",\"content\":\"# Develop client libraries (SDK)\\n## Get help\\n- If you need help with an automation tool or the Release planner, reach out to \\r\\n[Azure SDK / Azure SDK Onboarding](https://aka.ms/azsdk/support/onboarding-channel) channel.\\r\\n- If you need help with the development of the SDKs reach out to the [language specific Team's channel](xref:support#get-help-with-the-azure-sdks-development).\\r\\n- If you need to request an exception for a language review the [request release exception](xref:request-exception).\"}]", "inputs.latency": 700.1996040344238, "inputs.response_length": 1392, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://eng.ms/docs/products/azure-developer-experience/onboard/access"], "inputs.testcase": "Error writing to PR in RPSAASDev branch", "outputs.similarity.similarity": 2.0, "outputs.similarity.gpt_similarity": 2.0, "outputs.similarity.similarity_result": "fail", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1249, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1250, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Error writing to PR in RPSAASDev branch\\\\n\\\\nquestion: I'm seeing an error when trying to push my changes to a branch off of RPSaaSDev. Has anyone seen this before or would it be a sign that my write access request (Azure SDK Partners on CoreIdentity) is still propagating?\\\\npushing to this PR:[Private.DeviceRegistry 2026-04-01 by yijinglu-microsoft \\\\u00b7 Pull Request #25274 \\\\u00b7 Azure/azure-rest-ap\\\\u2026](https://github.com/Azure/azure-rest-api-specs-pr/pull/25274/files)\\\", \\\"response\\\": \\\"Sorry, I can't access the content of the linked PR, but I can guide you based on the provided Azure SDK onboarding knowledge. \\\\n\\\\nIf you are seeing an error when trying to push changes to a branch off of RPSaaSDev, one common reason is insufficient write access to the repository. According to the onboarding documentation, write access is required to push changes, create PRs, and manage issues in Azure SDK repos. \\\\n\\\\nIf your request to join the Azure SDK Partners (for CoreIdentity) was only recently approved, it can take up to one day for access to propagate after manager approval. During this time, you may experience permission errors when pushing or updating branches. Once access is granted, you should be added to the azure-sdk-partners GitHub team, which will allow you to push to branches such as RPSaaSDev.\\\\n\\\\nIf you continue to see errors after 24 hours, confirm you are listed in the GitHub team and that your request was approved. If the issue persists, you may want to reach out to the onboarding support channel for direct assistance.\\\\n\\\\nActionable next steps:\\\\n- Wait up to 24 hours after manager approval for access to propagate.\\\\n- Check your membership in the azure-sdk-partners GitHub team.\\\\n- If access is still missing after propagation, contact onboarding support for troubleshooting.\\\\n\\\\nLet me know if you need guidance on verifying your access or have other onboarding issues.\\\", \\\"ground_truth\\\": \\\"GitHub is experience an outage on all HTTP and SSH git operations, please check status using https://www.githubstatus.com/.\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"2\"}]"}, {"inputs.query": "title: Override description property in referenced parameter.\n\nquestion: In this PR I need to override the description for the typeahead parameter for a specific API, so that all other API that reference this property will not be affected:\nBut this is throwing an error:\nerror: Schema violation: must NOT have additional properties (paths > /search/address/{format} > get > parameters > 4)\nadditionalProperty: description\nI don't know why it is throwing an error, it worked in a similar situation for the BoundingBoxCompassNotation object in PR38554", "inputs.ground_truth": "You should be able to workaround this be slightly refactoring your swagger, for example create a new parameter TypeaheadDeprecated with the new description.", "inputs.response": "The error you're encountering—\"Schema violation: must NOT have additional properties (paths > /search/address/{format} > get > parameters > 4) additionalProperty: description\"—is typically triggered when the OpenAPI emitter finds a referenced parameter that is being overridden or extended in a way that is not allowed by the OpenAPI specification. In OpenAPI, when you reference a parameter (using `$ref`), you cannot add or override properties such as `description` directly at the point of reference; the reference must be to a complete parameter object, and any additional properties are forbidden.\n\nIn TypeSpec, if you have a shared parameter (like `typeahead`) that is used across multiple operations, and you want to override its description for just one operation, you cannot do this by simply referencing the parameter and attaching a new description. This is a limitation of OpenAPI itself—not TypeSpec—and is enforced by both the OpenAPI emitter and validators.\n\nHow did it work previously for `BoundingBoxCompassNotation`? It's possible that in that case, the parameter was redefined (copied or specialized) for the specific operation, rather than referenced via `$ref`. When you need a unique description for a parameter in a single operation, the correct approach is:\n\n**Solution:**\n- Define a new parameter model/type specifically for the operation that needs the unique description. Do not use the shared `$ref` for this one case.\n- All other operations can continue to use the shared parameter reference.\n\n**Example:**\n```typespec\n// Shared parameter\nmodel TypeaheadParam {\n  @query\n  typeahead: string;\n}\n\n// For most operations\nop getSomething(@TypeaheadParam): Response;\n\n// For /search/address/{format}, define a specialized parameter\nmodel TypeaheadParamForAddress {\n  @query\n  @doc(\"Custom description just for this API.\")\n  typeahead: string;\n}\n\nop searchAddress(@TypeaheadParamForAddress): Response;\n```\n\nThis way, the OpenAPI emitter will generate an inline parameter definition for `/search/address/{format}` with your custom description, and all other operations will continue to use the shared `$ref`. This avoids the schema violation.\n\n**Summary:** You cannot override the description of a referenced parameter inline due to OpenAPI limitations. You must define a unique parameter for the operation that requires a different description.\n\nIf you need to override other aspects of parameters (e.g., required, type), use the same approach: create a specialized parameter type for the affected operation.\n", "inputs.context": "[{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#checklists#migrate-dp-tips.md\",\"document_title\":\"Migrate data-plane specs\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\",\"content\":\"# migrate-swagger#checklists#migrate-dp-tips.md\\n\\n# Migrate data-plane specs\\n\\nThe OpenAPI converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\\n\\n## Initial pass through checklist\\n\\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\\r\\n\\r\\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/data-plane` linter rule set in your tspconfig.yaml. Example:\\r\\n\\r\\n```yaml title=tspconfig.yaml\\r\\nlinter:\\r\\n  extends:\\r\\n    - \\\"@azure-tools/typespec-azure-rulesets/data-plane\\\"\\r\\n```\\r\\n\\r\\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\\r\\n\\r\\n✅ **DO** use the built-in [url][url-type] for endpoint specification. Example:\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#checklists#migrate-arm-tips.md\",\"document_title\":\"Migrate ARM spec\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-arm-tips\",\"content\":\"# migrate-swagger#checklists#migrate-arm-tips.md\\n\\n# Migrate ARM spec\\n\\nThe OpenAPI converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\\n\\n## Initial pass through checklist\\n\\n✅ **DO** name your ARM spec folder with `.Management` suffix.\\r\\n\\r\\n✅ **DO** configure your tspconfig.yaml. See: [example tspconfig.yaml][tspconfig]\\r\\n\\r\\n✅ **DO** extend the `@azure-tools/typespec-azure-rulesets/resource-manager` linter rule set in your tspconfig.yaml if not already there. Example:\\r\\n\\r\\n```yaml title=tspconfig.yaml\\r\\nlinter:\\r\\n  extends:\\r\\n    - \\\"@azure-tools/typespec-azure-rulesets/resource-manager\\\"\\r\\n```\\r\\n\\r\\n✅ **DO** ensure your `@service` and `@server` definitions are correct in main.tsp\\r\\n\\r\\n✅ **DO** ensure `interface Operations extends Azure.ResourceManager.Operations {}` is in main.tsp\\r\\n\\r\\n✅ **DO** ensure your versions enum is up to date. For an initial migration we recommend migrating your latest stable API version (and the latest preview API version the service may support after the stable API version)\\r\\n\\r\\n✅ **DO** ensure you have correct ARM common type version select with each service version. Example:\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#diagnostics.md\",\"document_title\":\"Diagnostics\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/diagnostics\",\"content\":\"# emitters#openapi3#diagnostics.md\\n\\n# Diagnostics\\n\\nThe OpenAPI emitter may produce any of the following diagnostic messages.\\r\\n\\r\\n\\u003c!-- Topics within this section should be ordered alphabetically for easy lookup --\\u003e\\n\\n## duplicate-header\\n\\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\\r\\n\\r\\nTo fix this issue, ensure that each response header is defined only once for each status code.\\n\\n### Example\\n\\n```yaml\\r\\nresponses:\\r\\n  \\\"200\\\":\\r\\n    description: Successful response\\r\\n    headers:\\r\\n      X-Rate-Limit:\\r\\n        description: The number of allowed requests in the current period\\r\\n        schema:\\r\\n          type: integer\\r\\n      X-Rate-Limit:\\r\\n        description: The number of allowed requests in the current period\\r\\n        schema:\\r\\n          type: integer\\r\\n```\\r\\n\\r\\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\\n\\n## duplicate-type-name\\n\\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\\r\\n\\r\\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\\n\\n### Example\\n\\n```typespec\\r\\n@friendlyName(\\\"User\\\")\\r\\nmodel Customer {\\r\\n  id: string;\\r\\n}\\r\\n\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\r\\n\\r\\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\\n\\n## inline-cycle\\n\\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\\r\\n\\r\\nTo fix this issue, refactor the schemas to remove the cyclic reference.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    Node:\\r\\n      type: object\\r\\n      properties:\\r\\n        value:\\r\\n          type: string\\r\\n        next:\\r\\n          $ref: \\\"#/components/schemas/Node\\\"\\r\\n```\\r\\n\\r\\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\\n\\n## invalid-default\\n\\nThis diagnostic is issued when a default value is invalid for the specified schema type.\\r\\n\\r\\nTo fix this issue, ensure that the default value is valid for the schema type.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    User:\\r\\n      type: object\\r\\n      properties:\\r\\n        age:\\r\\n          type: integer\\r\\n          default: \\\"twenty\\\"\\r\\n```\\r\\n\\r\\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\\n\\n## invalid-extension-key\\n\\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \\\"x-\\\" as\\r\\nrequired by the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, change the extension name to start with \\\"x-\\\".\\n\\n### Example\\n\\n```typespec\\r\\n@extension(\\\"invalid-name\\\", \\\"value\\\")\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\r\\n\\r\\nShould be changed to:\\r\\n\\r\\n```typespec\\r\\n@extension(\\\"x-valid-name\\\", \\\"value\\\")\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\n\\n## invalid-schema\\n\\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    User:\\r\\n      type: object\\r\\n      properties:\\r\\n        id:\\r\\n          type: string\\r\\n        age:\\r\\n          type: integer\\r\\n          format: \\\"int\\\" # Invalid format\\r\\n```\\r\\n\\r\\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\\n\\n## invalid-server-variable\\n\\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\\r\\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\\r\\n\\r\\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\\n\\n### Example\\n\\n```typespec\\r\\n@server(\\\"{protocol}://{host}/api/{version}\\\", \\\"Custom endpoint\\\", {\\r\\n  protocol: \\\"http\\\" | \\\"https\\\",\\r\\n  host: string,\\r\\n  version: 1, // Should be a string: \\\"1\\\"\\r\\n})\\r\\n```\\n\\n## path-query\\n\\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\\r\\n\\r\\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\\n\\n### Example\\n\\nInstead of:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users?filter={filter}\\\")\\r\\nop getUsers(filter: string): User[];\\r\\n```\\r\\n\\r\\nUse:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users\\\")\\r\\nop getUsers(@query filter?: string): User[];\\r\\n```\\r\\n\\r\\nAlternatively, you can leverage TypeSpec's support for URI templates:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users{?filter}\\\")\\r\\nop getUsers(filter?: string): User[];\\r\\n```\\n\\n## union-null\\n\\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\\r\\nrepresented in OpenAPI.\\r\\n\\r\\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\\n\\n## union-unsupported\\n\\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\\r\\n\\r\\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Validation.md\",\"document_title\":\"Table of Contents\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation\",\"content\":\"# TypeSpec-Validation.md\\n\\n# Table of Contents\\n\\n- [Running Locally](#running-locally)\\r\\n- [Examples Source and Destination](#examples-source-and-destination)\\r\\n- [Validation Rule Suppression](#validation-rule-suppression)\\r\\n- [Rules](#rules)\\r\\n  - [SdkTspConfigValidation](#SdkTspConfigValidation)\\r\\n    - [JavaScript](#JavaScript-Sub-Rules)\\r\\n    - [Python](#Python-Sub-Rules)\\r\\n    - [Go](#Go-Sub-Rules)\\r\\n    - [Java](#Java-Sub-Rules)\\r\\n    - [.Net](#Net-Sub-Rules)\\n\\n# Running Locally\\n\\nTo ensure you see the same results from TypeSpecValidation in your PR check and `tsv` on your local machine:\\r\\n1. Merge latest from parent (e.g. `main` or `RPSaaSMaster`) to your PR branch\\r\\n2. Run locally\\r\\n   1. `git clean -xdf` (may revert any local changes)\\r\\n   2. `git pull`\\r\\n   3. `npm ci`\\r\\n   4. `npx tsv specification/widget/resource-manager/Microsoft.Widget/Widget`\\r\\n   5. `git status`\\r\\n   6. If any changes, `git add`, `git commit`, `git push` to update your PR.\\r\\n3. If you are still having problems, try cloning your branch to a new folder, or try on another machine.\\r\\n4. If the problem can be reproduced on a clean machine, request assistance from the [TypeSpec Discussion](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) teams channel.\\n\\n# Examples Source and Destination\\n\\nIf you are having problems with diffs from \\\"tsp compile\\\" related to examples, ensure you understand how examples flow from source to destination.\\r\\nThe **source** of examples is under your TypeSpec source code folder, and the **destination** of examples is under the Swagger folder.  The TypeSpec compiler copies from source to destination.  In our sample: \\r\\n* source\\r\\n  * https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/Contoso.Management/examples/2021-10-01-preview \\r\\n* destination\\r\\n  * https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/resource-manager/Microsoft.Contoso/preview/2021-10-01-preview/examples\\r\\nIf you are changing examples, you must **first** change the copy under your TypeSpec folder, and then run `tsp compile` (or `tsv` which calls `compile`) to update the copies in your Swagger folder.\\n\\n# Validation Rule Suppression\\n\\nYou can suppress specific validation rules within `TypeSpecValidation` by creating or modifying a `suppressions.yaml` file in the root directory of your service specification.\\r\\n\\u003e **Note:** Currently, only the `SdkTspConfigValidation` rule supports suppression.\\n\\n## Suppressing SdkTspConfigValidation Rules\\n\\nThe `SdkTspConfigValidation` rule is responsible for validating emitter options and parameters defined in your `tspconfig.yaml` file. You have the flexibility to suppress this rule entirely or target specific sub-rules within it.\\n\\n### Suppress the Entire SdkTspConfigValidation Rule\\n\\nIf you need to skip **all** validation checks for emitter options and parameters within a particular `tspconfig.yaml` file, you can suppress the entire `SdkTspConfigValidation` rule.\\r\\nTo do this, add or update the `suppressions.yaml` file in your service's root folder with the following content:\\r\\n```yaml\\r\\n- tool: TypeSpecValidation\\r\\n  paths:\\r\\n    # Specify the path to the tspconfig.yaml file where suppression should apply\\r\\n    - /path/to/tspconfig.yaml\\r\\n  rules:\\r\\n    - SdkTspConfigValidation\\r\\n  reason: the-reason-you-want-to-suppress # Explain why this suppression is necessary\\r\\n```\\n\\n### Suppress Specific Sub-rules within SdkTspConfigValidation\\n\\nIf you only need to bypass validation for **specific** emitter options or parameters, you can suppress individual sub-rules.\\r\\nAdd or update your `suppressions.yaml` file with the following structure, specifying the sub-rules to ignore:\\r\\nSub-rule Syntax:\\r\\n- For parameters: `parameters.\\u003cparameter-key\\u003e.default`\\r\\n- For emitter options: `options.\\u003cemitter-name\\u003e.\\u003coption-key\\u003e`\\r\\n- For nested options (e.g., `package-details: name: \\\"xxx\\\"`), use dot notation: `options.\\u003cemitter-name\\u003e.package-details.name`\\r\\n```yaml\\r\\n- tool: TypeSpecValidation\\r\\n  paths:\\r\\n    # Specify the path to the tspconfig.yaml file where suppression should apply\\r\\n    - /path/to/tspconfig.yaml\\r\\n  rules:\\r\\n    - SdkTspConfigValidation\\r\\n  sub-rules:\\r\\n    # Example: Suppress validation for a specific parameter's default value\\r\\n    - parameters.\\u003ckey-to-validate\\u003e.default \\r\\n    # Example: Suppress validation for a specific emitter option\\r\\n    - options.\\u003cemitter-name\\u003e.\\u003ckey-to-validate\\u003e\\r\\n    # Example: Suppress validation for a nested emitter option\\r\\n    - options.\\u003cemitter-name\\u003e.package-details.name \\r\\n  reason: the-reason-you-want-to-suppress # Explain why this suppression is necessary\\r\\n```\\n\\n# Rules\\n\\n## SdkTspConfigValidation\\n\\n### Parameters\\n\\n- **`parameters.default.service-dir`**\\r\\n  - Allowed values: strings that matches the regex `/^sdk\\\\/.*$/`\\r\\n  - example: `sdk/aaa`\\n\\n### JavaScript Sub Rules\\n\\nPlane\\r\\n- [**`@azure-tools/typespec-ts.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L33)\\r\\n  - Allowed values: strings that matches the regex `/^(?:[a-z]+-)+rest$/`\\r\\n  - example: `arm-aaa-rest`\\r\\n- [**`@azure-tools/typespec-ts.options.package-details.name`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L35)\\r\\n  - Allowed values: strings that matches the regex `/^\\\\@azure-rest\\\\/[a-z]+(?:-[a-z]+)*$/`\\r\\n  - example: `@azure-rest/aaa-bbb`\\n\\n\\u003e Please follow the below steps to configure. If you encounter any issues, please seek help in the \\u003ca href=\\\"https://teams.microsoft.com/l/channel/19%3A408c5f1322ee4303b02b5da9c5ff6137%40thread.skype/Language%20-%20JavaScript%20-%20Reviews?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" rel=\\\"noreferrer noopener\\\" title=\\\"https://teams.microsoft.com/l/channel/19%3a408c5f1322ee4303b02b5da9c5ff6137%40thread.skype/language%20-%20javascript%20-%20reviews?groupid=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantid=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" target=\\\"_blank\\\"\\u003eJS channel\\u003c/a\\u003e\\r\\n#### Management Plane\\r\\n- [**`@azure-tools/typespec-ts.options.experimental-extensible-enums`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L32)\\r\\n  - Allowed values: `true`\\r\\n- [**`@azure-tools/typespec-ts.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L30)\\r\\n  - Allowed values: strings that matches the regex `/^arm-[^\\\\/]+$/`\\r\\n  - example: `arm-aaa-bbb`\\r\\n- [**`@azure-tools/typespec-ts.options.package-details.name`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L34)\\r\\n  - Allowed values: strings that matches the regex `/^\\\\@azure\\\\/arm(?:-[a-z]+)+$/`\\r\\n  - example: `@azure/arm-aaa-bbb`\\r\\n#### Data Plane\\r\\n- [**`@azure-tools/typespec-ts.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L33)\\r\\n  - Allowed values: strings that matches the regex `/^(?:[a-z]+-)+rest$/`\\r\\n  - example: `arm-aaa-rest`\\r\\n- [**`@azure-tools/typespec-ts.options.package-details.name`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L35)\\n\\n### Python Sub Rules\\n\\n\\u003e Please follow the below steps to configure. If you encounter any issues, please seek help in the \\u003ca href=\\\"https://teams.microsoft.com/l/channel/19%3A4175567f1e154a80ab5b88cbd22ea92f%40thread.skype/Language%20-%20Python%20-%20Reviews?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" rel=\\\"noreferrer noopener\\\" title=\\\"https://teams.microsoft.com/l/channel/19%3A4175567f1e154a80ab5b88cbd22ea92f%40thread.skype/Language%20-%20Python%20-%20Reviews?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" target=\\\"_blank\\\"\\u003epython channel\\u003c/a\\u003e\\r\\n#### Management Plane\\r\\n- [**`@azure-tools/typespec-python.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L19)\\r\\n  - Allowed values: strings that matches the regex `/^azure-mgmt(-[a-z]+){1,2}$/`\\r\\n  - example: `azure-mgmt-aaa`\\r\\n- [**`@azure-tools/typespec-python.options.namespace`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L20)\\r\\n  - Allowed values: strings that matches the regex `/^azure\\\\.mgmt(\\\\.[a-z]+){1,2}$/`\\r\\n  - example: `azure.mgmt.aaa`\\r\\n- [**`@azure-tools/typespec-python.options.generate-test`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L21)\\r\\n  - Allowed values: `true`\\r\\n- [**`@azure-tools/typespec-python.options.generate-sample`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L22)\\r\\n  - Allowed values: `true`\\r\\n#### Data Plane\\r\\n- [**`@azure-tools/typespec-python.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L18)\\r\\n  - Allowed values: strings that matches the regex `/^azure(-[a-z]+){1,3}$/`\\n\\n- Allowed values: `true`\\r\\n#### Data Plane\\r\\n- [**`@azure-tools/typespec-python.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L18)\\r\\n  - Allowed values: strings that matches the regex `/^azure(-[a-z]+){1,3}$/`\\r\\n  - example: `azure-aaa-bbb-ccc`\\n\\n### Go Sub Rules\\n\\n\\u003e Please follow the below steps to configure. If you encounter any issues, please \"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-tooling.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-tooling\",\"content\":\"# design#api-specs#api-tooling.md\\n\\n| Short Link: | [aka.ms/azsdk/specprtools](https://aka.ms/azsdk/specprtools) |\\r\\n|--|--|\\n\\n# Use tools to create and validate Azure REST APIs specs\\n\\n## [Author With TypeSpec](#tab/author-with-typespec)\\n\\nAuthor specs with TypeSpec (**recommended approach**)\\r\\n\\r\\nREST APIs authored in [TypeSpec](xref:api-typespec) with the [Azure TypeSpec libraries] have validation built in.\\r\\nCompiling the TypeSpec definition will validate the REST API against the Azure API guidelines.\\r\\nThe TypeSpec compiler will also generate an [OpenAPI](xref:api-openapi) definition for the REST API.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e TypeSpec has [plugins for Visual Studio and Visual Studio Code][TypeSpec plugins] that will highlight errors and\\r\\nwarnings in your TypeSpec definition.\\r\\n\\r\\nTypeSpec is the recommended way for generating OpenAPI specs.\\n\\n## [Author with OpenAPI](#tab/author-with-openapi)\\n\\nAuthor specs with OpenAPI (**legacy approach**)\\r\\n\\r\\nFor REST APIs that cannot be written in TypeSpec and still must be written directly in the OpenAPI format, you can:\\r\\n\\r\\n- Use [OpenAPI Initiative Swagger editor] for basic authoring.\\r\\n- Learn about the [spec directory structure].\\r\\n- Use the [Spectral linter] and the [Azure Spectral ruleset] to validate your OpenAPI definition against the Azure API\\r\\n  guidelines.\\r\\n  - Spectral provides a [VSCode plugin][Spectral VSCode plugin] that will highlight errors and warnings in your\\r\\n    OpenAPI definition in VSCode.\\r\\n\\r\\nYour OpenAPI definitions, to be published, will have to end up in the specs repos as explained in  \\r\\n[this article](xref:api-specs). As such, they will be subject to additional mandatory validation requirements.\\r\\nSee [validate your REST API](#validate-your-rest-api-specs) section to learn about them.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Exclude property from list that is in create/update/get\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Exclude property from list that is in create/update/get\\n\\n## question\\n\\nWe have an ARM resource that has a property , e.g.  properties.blob that will contain a very large amount of text not appropriate for list responses.  \\r\\nI see we can override the properties for ArmResourceCreateOrReplaceAsync and ArmResourcePatchAsync, but I don't see a way to do this for ArmResourceRead or ArmResourceListByParent. \\r\\nIs there a way to exclude a property from properties when listing other than defining a new resource type that lacks the specific property? \\r\\nThe property is required. The only way I can see to do this would be to make it appear optional but return an error is the user tried to set it to empty or null.\\n\\n## answer\\n\\n},\\r\\n          {\\r\\n            \\\"name\\\": \\\"notificationHubName\\\",\\r\\n            \\\"in\\\": \\\"path\\\",\\r\\n            \\\"description\\\": \\\"The name of the NotificationHubResource\\\",\\r\\n            \\\"required\\\": true,\\r\\n            \\\"type\\\": \\\"string\\\",\\r\\n            \\\"pattern\\\": \\\"^[a-zA-Z][a-zA-Z0-9-./_]*$\\\"\\r\\n          },\\r\\n          {\\r\\n            \\\"name\\\": \\\"authorizationRuleName\\\",\\r\\n            \\\"in\\\": \\\"path\\\",\\r\\n            \\\"description\\\": \\\"The name of the SharedAccessAuthorizationRuleResource\\\",\\r\\n            \\\"required\\\": true,\\r\\n            \\\"type\\\": \\\"string\\\",\\r\\n            \\\"pattern\\\": \\\"^[a-zA-Z0-9!()*-._]+$\\\"\\r\\n```\\r\\nExpected: [This](https://github.com/Azure/azure-rest-api-specs/blob/5351ac8e1e6fdf48933bae2cd879434b93b36ac0/specification/notificationhubs/resource-manager/Microsoft.NotificationHubs/preview/2023-10-01-preview/notificationhubs.json#L417-L425) \\r\\n```\\r\\n{\\r\\n            \\\"$ref\\\": \\\"#/parameters/NamespaceName\\\"\\r\\n          },\\r\\n          {\\r\\n            \\\"$ref\\\": \\\"#/parameters/HubName\\\"\\r\\n          },\\r\\n          {\\r\\n            \\\"$ref\\\": \\\"#/parameters/AuthorizationRuleName\\\"\\r\\n          },\\r\\n```\\r\\nis the original swagger. There is limitations on minLength and maxLength.\\r\\n\\r\\n## answer\\r\\nYes, because the actual path parameters do not come from the resource, you would need to decorate the parameters in the LegacyOperations instantiation.\\r\\n\\r\\nWhen you construct the LegacyOperations interface, you pass in the parameters - those passed-in parameters would need to be decorated.\\r\\n \\r\\nI wonder if we shouldn't have a legacy resource template that omits the name parameter, just to avoid confusion, it is literally unused in this context.\\r\\n\\r\\nIf you need to decorate the name parameter, you will need to define them directly, or name the resulting model, so they can be decoratred.  You can decorate a model statement, but not a model expression.\\r\\n \\r\\n# First experience of TSP ApiVersion introduction - passed all CI checks, what's next?\\r\\n\\r\\n## question \\r\\nHi TypeSpec friends!\\n\\n\\\"API version located in the host template\\\"\\r\\n    \\\"@azure-tools/typespec-azure-core/use-standard-operations\\\": \\\"Most of our operation doesn't fit standard ops\\\"\\r\\n    \\\"@azure-tools/typespec-azure-core/use-standard-names\\\": \\\"Most of our operation doesn't fit standard ops\\\"\\r\\n```\\r\\nI'm working on adding Tier 1 language namespace names to TypeSpec APIView. I can get this from the compiler options when namespace is specified in the tspconfig.yaml. However, what should the behavior be when, as in the above config, the namespace isn't specified (for typespec-ts)?  What heuristic is applied to determine the namespace? Is it language specific?\\r\\n\\r\\n## answer\\r\\nWhen the `namespace` isn't explicitly specified in `tspconfig.yaml`, the behavior falls back to what's defined in the TypeSpec file itself—i.e., whatever `namespace` is declared there. If no namespace is declared in the TypeSpec, then the emitter determines the default, which may vary by language.\\r\\n\\r\\nIn the management plane, it's fairly standardized: we derive the namespace based on the resource provider name, stripping prefixes like `Azure` or `Microsoft`, flattening separators, and applying language-specific naming conventions. For example:\\r\\n\\r\\n* .NET: `Azure.ResourceManager.[ProviderName]`\\r\\n* Python: `azure-mgmt-[providername]`\\r\\n* Java: `com.azure.resourcemanager.[providername]`\\r\\n* JS: `@azure/arm-[providername]`\\r\\n\\r\\nFor **data plane**, it's similar but instead of \\\"ResourceManager\\\", you use the service group (like `AI`, `Data`, etc.). By default, it uses the namespace from the TypeSpec unless you override it via:\\r\\n\\r\\n```\\n\\n`TypeSpec.Http.OkResponse` which causes problems in downstream. Can we remove this model? (omit-unreachable-types: true does not work)\\r\\n\\r\\n## answer\\r\\nIf the `OkResponse` model is being emitted but not actually referenced, that does sound like a bug — we shouldn't be generating unused models. Especially in cases like this where you're doing a long-running POST action and the 200 response is effectively empty, it’s more accurate to model the operation with just a `202` and an error response.\\r\\n\\r\\nFor your case, you can avoid using `OkResponse` entirely by switching to `ArmResourceActionNoResponseContentAsync` or passing `never` as the third argument. That will prevent the generation of the unnecessary `OkResponse` model.\\r\\n\\r\\nAlso, keep in mind that for LROs, the POST operation typically doesn't return 200 anyway. That response is just a placeholder in the old pattern to signal \\\"void\\\". If you're converting from existing Swagger, and it doesn’t actually return 200, you should be able to safely drop that response from the Swagger and avoid the breaking change.\\r\\n\\r\\nAlternatively, if you do need to customize the final response for the LRO, `getLroResponse` can be used to override the response returned at the end of the operation — no need to rely on `OkResponse` at all.\\r\\n\\r\\n \\r\\n# TSP Install fails with below error\\r\\n\\r\\n## question \\r\\nI am trying to install TSP and its dependencies and it fails with below error. I have latest node.js Can you please help?\\r\\n\\r\\nError: spawn EINVAL\\r\\n    at ChildProcess.spawn (node:internal/child_process:420:11)\\r\\n    at spawn (node:child_process:753:9)\\r\\n    at installTypeSpecDependencies (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/dist/src/core/install.js:4:19)\\r\\n    at file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/dist/src/core/cli/cli.js:152:95\\r\\n    at Object.handler (file:///C:/Users/anponnet/AppData/Roaming/npm/node_modules/@typespec/compiler/dist/src/core/cli/utils.js:16:16)\\n\\noptions:\\r\\n  \\\"@azure-tools/typespec-autorest\\\":\\r\\n    azure-resource-provider-folder: \\\"data-plane\\\"\\r\\n    emit-lro-options: \\\"none\\\"\\r\\n    emitter-output-dir: \\\"{project-root}/..\\\"\\r\\n    omit-unreachable-types: true\\r\\n    output-file: \\\"{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/Face.json\\\"\\r\\n  \\\"@azure-tools/typespec-python\\\":\\r\\n    package-dir: \\\"azure-ai-vision-face\\\"\\r\\n    namespace: \\\"azure.ai.vision.face\\\"\\r\\n    package-version: 1.0.0b2\\r\\n    package-mode: dataplane\\r\\n    flavor: azure\\r\\n    generate-test: true\\r\\n    generate-sample: true\\r\\n  \\\"@azure-tools/typespec-csharp\\\":\\r\\n    package-dir: \\\"Azure.AI.Vision.Face\\\"\\r\\n    namespace: \\\"{package-dir}\\\"\\r\\n    clear-output-folder: true\\r\\n    model-namespace: false\\r\\n    flavor: azure\\r\\n  \\\"@azure-typespec/http-client-csharp\\\":\\r\\n    namespace: Azure.AI.Vision.Face\\r\\n    model-namespace: false\\r\\n  \\\"@azure-tools/typespec-ts\\\":\\r\\n    package-dir: \\\"ai-vision-face-rest\\\"\\r\\n    generate-metadata: true\\r\\n    flavor: azure\\r\\n    package-details:\\r\\n      name: \\\"@azure-rest/ai-vision-face\\\"\\r\\n      description: \\\"Face API REST Client\\\"\\r\\n  \\\"@azure-tools/typespec-java\\\":\\r\\n    package-dir: \\\"azure-ai-vision-face\\\"\\r\\n    namespace: com.azure.ai.vision.face\\r\\n    partial-update: true\\r\\n    use-eclipse-language-server: false\\r\\n    enable-subclient: true\\r\\n    generate-samples: false\\r\\n    generate-tests: false\\r\\n    flavor: azure\\r\\nlinter:\\r\\n  extends:\\r\\n    - \\\"@azure-tools/typespec-azure-rulesets/data-plane\\\"\\r\\n  disable:\\r\\n    \\\"@azure-tools/typespec-azure-core/operation-missing-api-version\\\": \\\"API version located in the host template\\\"\\r\\n    \\\"@azure-tools/typespec-azure-core/use-standard-operations\\\": \\\"Most of our operation doesn't fit standard ops\\\"\\r\\n    \\\"@azure-tools/typespec-azure-core/use-standard-names\\\": \\\"Most of our operation doesn't fit standard ops\\\"\\r\\n```\\r\\nI'm working on adding Tier 1 language namespace names to TypeSpec APIView. I can get this from the compiler options when namespace is specified in the tspconfig.yaml.\\n\\n{\\r\\n  errno: -4071,\\r\\n  code: 'EINVAL',\\r\\n  syscall: 'spawn'\\r\\n}\\r\\n\\r\\n## answer\\r\\n1. which version of the compiler did you install globally, this looks liek quite an old one?\\r\\n2. where are you trying to use typespec, if its the azure spec repo please follow the docs there https://github.com/Azure/azure-rest-api-specs/blob/7fc6689d84858b1c71b786526b04c014c4589968/documentation/typespec-rest-api-dev-process.md\\r\\n\\r\\n# Augmented decorators on resource in the multi-path scenario\\r\\n\\r\\n## question \\r\\nThis is a resource [model](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/SharedAccessAuthorizationRuleResource.tsp#L18) \\r\\n```\\r\\n@parentResource(NotificationHubResource)\\r\\nmodel SharedAccessAuthorizationRuleResource\\r\\n  is Azure.ResourceManager.TrackedResource\\u003cSharedAccessAuthorizationRuleProperties\\u003e {\\r\\n  ...ResourceNameParameter\\u003c\\r\\n    Resource = SharedAccessAuthorizationRuleResource,\\r\\n    KeyName = \\\"authorizationRuleName\\\",\\r\\n    SegmentName = \\\"authorizationRules\\\",\\r\\n    NamePattern = \\\"^[a-zA-Z0-9!()*-._]+$\\\"\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\nin the multi-path scenario. It wants to have [minLength and maxLength](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/SharedAccessAuthorizationRuleResource.tsp#L179-L180).\\r\\n```\\r\\n@@maxLength(SharedAccessAuthorizationRuleResource.name, 256);\\r\\n@@minLength(SharedAccessAuthorizationRuleResource.name, 1);\\r\\n```\\r\\n Its [parent](https://github.com/Azure/azure-rest-api-specs/blob/3a8d2effa54913b5f5365e9a4610810825366409/specification/notificationhubs/Notificationhubs.Management/NotificationHubResource.tsp#L18) \\r\\n```\\r\\n@parentResource(NamespaceResource)\\r\\nmodel Notificat\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Readonly on model\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Readonly on model\\n\\n## question\\n\\nWe have such swagger\\r\\n```\\r\\n\\\"ReadonlyOnModel\\\": {\\r\\n  readonly: true,\\r\\n  properties: {}\\r\\n},\\r\\n\\\"AnotherModel\\\": {\\r\\n  properties: {\\r\\n    \\\"a\\\": {\\r\\n      $ref: \\\"ReadonlyOnModel\\\"\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\nWhen the type of property \\\"a\\\" in another model is that \\\"ReadonlyOnModel\\\", M4 will give a readonly on that property \\\"a\\\". I want to confirm if the equivalent TypeSpec should be\\r\\n```\\r\\nmodel AnotherModel {\\r\\n  @visibility(Lifecycle.Read)\\r\\n  a: ReadonlyOnModel;\\r\\n}\\r\\nmodel ReadonlyOnModel {}\\r\\n```\\r\\ncc Alitzel Mendez : Common type replacement relates to this. I remember we have several models in the original common type have readonly on them and you removed these because TypeSpec cannot represent readonly on model. Then if any service refers to this model, those properties might need to be updated.\\n\\n## answer\\n\\nTypeSpec can only attach readOnly to properties, not to models or scalars.  Functionally (assuming all references to ReadOnlyModel are through readOnly properties),  these Swagger docs are equivalent, see: [autorest/docs/openapi/howto/$ref-siblings.md at main · Azure/autorest](https://github.com/Azure/autorest/blob/main/docs/openapi/howto/%24ref-siblings.md) from the perspective of both TypeSpec and autorest, these descriptions are equivalent.\"},{\"document_source\":\"static_typespec_to_swagger_mapping\",\"document_filename\":\"TypeSpec-ARM.Foundations-Models-Documentation.md\",\"document_title\":\"TypeSpec Azure.ResourceManager.Foundations Models Mapping to Swagger Documentation\",\"document_link\":\"\",\"content\":\"# TypeSpec-ARM.Foundations-Models-Documentation.md\\n\\n# TypeSpec Azure.ResourceManager.Foundations Models Mapping to Swagger Documentation\\n\\n## 16. TenantBaseParameters\\n\\n### Description\\n\\nThe static parameters for a tenant-based resource. This model provides the minimal parameters required for operations on resources that are scoped to the Azure tenant level.\\n\\n### TypeSpec Example\\n\\n```typespec\\r\\n// Direct usage of TenantBaseParameters for tenant-scoped resources\\r\\n@tenantResource\\r\\nmodel TenantTestResource is ProxyResource\\u003cTestProperties\\u003e {\\r\\n  ...ResourceNameParameter\\u003cTenantTestResource\\u003e;\\r\\n}\\r\\n\\r\\n@armResourceOperations\\r\\ninterface TenantTestResourceOperations {\\r\\n  // Explicitly using Foundations.TenantBaseParameters\\r\\n  get is ArmResourceRead\\u003c\\r\\n    TenantTestResource,\\r\\n    Foundations.TenantBaseParameters\\r\\n  \\u003e;\\r\\n}\\r\\n```\\n\\n### Swagger Output\\n\\n```json\\r\\n{\\r\\n  \\\"path\\\": \\\"/providers/Microsoft.FoundationModelsTest/tenantTestResources/{tenantTestResourceName}\\\",\\r\\n  \\\"get\\\": {\\r\\n    \\\"operationId\\\": \\\"TenantTestResourceOperations_Get\\\",\\r\\n    \\\"parameters\\\": [\\r\\n      {\\r\\n        \\\"$ref\\\": \\\"../../../../../../../common-types/resource-management/v5/types.json#/parameters/ApiVersionParameter\\\"\\r\\n      },\\r\\n      {\\r\\n        \\\"name\\\": \\\"tenantTestResourceName\\\",\\r\\n        \\\"in\\\": \\\"path\\\",\\r\\n        \\\"description\\\": \\\"The name of the TenantTestResource\\\",\\r\\n        \\\"required\\\": true,\\r\\n        \\\"type\\\": \\\"string\\\",\\r\\n        \\\"pattern\\\": \\\"^[a-zA-Z0-9-]{3,24}$\\\"\\r\\n      }\\r\\n    ]\\r\\n  }\\r\\n}\\r\\n```\\r\\n**Note:** TenantBaseParameters only includes the `apiVersion` parameter, as tenant-scoped resources do not require subscription or resource group parameters.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Typespec Validation required check\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Typespec Validation required check\\n\\n## question\\n\\n\\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\". Please add \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-fakes\\\". Please add \\\"options.@azure-tools/typespec-go.generate-fakes\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.head-as-boolean\\\". Please add \\\"options.@azure-tools/typespec-go.head-as-boolean\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.inject-spans\\\". Please add \\\"options.@azure-tools/typespec-go.inject-spans\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-python.package-dir\\\". Please add \\\"options.@azure-tools/typespec-python.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-csharp.namespace \\\"Microsoft.Azure.Management.DevTestLabs\\\" does not match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter. Please update the value of \\\"options.@azure-tools/typespec-csharp.namespace\\\" to match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter.\\r\\nPlease see https://aka.ms/azsdk/spec-gen-sdk-config for more info.\\r\\nFor additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.\\r\\n```\\r\\nI have copied the namespace from the autorest readme files that we had before and it was responsible  to generate SDKs. Is it a requirement to update the namespace as suggested given we have already published the SDK before?\\n\\nPR: https://github.com/Azure/azure-rest-api-specs/pull/35346\\r\\nThis PR only has typespec conversion change and no API update. It is currently failing for required check - Typespec validation. When I run the npx tsmv command locally then I see the following error.\\r\\n```\\r\\nExecuting rule: SdkTspConfigValidation\\r\\nValidation on option \\\"options.@azure-tools/typespec-csharp.namespace\\\" in \\\"@azure-tools/typespec-csharp\\\" are failed. However, per @azure-tools/typespec-csharp’s decision, we will treat it as passed.\\r\\n[SdkTspConfigValidation]: validation failed.\\r\\n- Failed to find \\\"parameters.service-dir.default\\\". Please add \\\"parameters.service-dir.default\\\".\\r\\n- The value of options.@azure-tools/typespec-java.package-dir \\\"azure-mgmt-devtestlabs\\\" does not match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.package-dir\\\" to match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\".\\r\\n- The value of options.@azure-tools/typespec-java.namespace \\\"com.microsoft.azure.management.devtestlabs\\\" does not match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.namespace\\\" to match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.service-dir\\\". Please add \\\"options.@azure-tools/typespec-go.service-dir\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.package-dir\\\". Please add \\\"options.@azure-tools/typespec-go.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-go.module \\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\n\\n## answer\\n\\ntypeSpec validation is failing, but not for that reason.  The configuration for c-sharp emitter is a warning only.  The current failure is caused by diffs between the generated swagger included in your PR and the generated swagger when the ci compiles your spec.\\r\\n \\r\\nUsually this indicates that your local dependencies are out of date, and you need to pull the latest into your local branch and re-install at thetop level:\\r\\n \\r\\ngit fetch upstream main\\r\\ngit pull upstream main\\r\\nnpm ci\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_29.md\",\"document_title\":\"TypeSpec PR Diff Validation Queries\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_29.md\\n\\n# TypeSpec PR Diff Validation Queries\\n\\n## question\\n\\n{\\r\\n    \\\"value\\\": {\\r\\n      \\\"type\\\": \\\"array\\\",\\r\\n      \\\"description\\\": \\\"[Placeholder] Discription for value property\\\",\\r\\n      \\\"items\\\": {\\r\\n        \\\"$ref\\\": \\\"#/definitions/AssessmentResult\\\"\\r\\n      }\\r\\n    },\\r\\n    \\\"nextLink\\\": {\\r\\n      \\\"type\\\": \\\"string\\\",\\r\\n      \\\"format\\\": \\\"uri\\\",\\r\\n      \\\"description\\\": \\\"[Placeholder] Discription for nextLink property\\\"\\r\\n-   }\\r\\n  }\\r\\n+ },\\r\\n+ \\\"required\\\":[\\r\\n+   \\\"value\\\"\\r\\n+ ]\\r\\n```\\r\\n3.extendedProperties of type object contains an additional field named additonalProperties\\r\\n```diff\\r\\n\\\"PredictionResponseProperties\\\": {\\r\\n  \\\"type\\\": \\\"object\\\",\\r\\n  \\\"properties\\\": {\\r\\n    \\\"extendedProperties\\\": {\\r\\n-     \\\"type\\\": \\\"object\\\"\\r\\n+     \\\"type\\\": \\\"object\\\",\\r\\n+     \\\"additionalProperties\\\": {}\\r\\n  },\\r\\n```\\r\\nFew other changes below I can observe from Swagger UI Preview in local:\\r\\n1.Previously we had multiple Swagger Spec Files like advisor.json, assessments.json and resiliencyReviews.json each having a subset of endpoints in line with different Advisor Portal Blades, but with TypeSpec generated Swagger we only have a single openapi.json spec file containing all endpoints. Is this a mandatory requirement with TypeSpec going forward that for each RP we need to generate and maintain a single spec?\\r\\n2.Multiple Tag Name updates - \\\"Metadata\\\" -\\u003e \\\"MetadataEntities\\\". Could such changes lead to any breaking impact on Customers side. Also, from documentation perspective can we update these Tag Names to be similar as past?\\r\\n3.summary for endpoints has been moved to description. Also. few parameter descriptions are updated. Is there recommended practise being followed here?\\r\\n4.Response description updated to be more generic as an Azure Operation and \\\"systemData\\\" section added as part of 200 Response. Are these done as per any recommended guidelines?\\n\\nHi TypeSpec Discussion,\\r\\n\\r\\nI was validating the TypeSpec generated PR - [[TSP Migration][advisor] TypeSpec migrated from swagger by HarveyLink · Pull Request #34319 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/34319) following [this process](https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started/#review-and-adjust-the-typespec) in my local and came across some differences between existing Swagger Spec vs the New Swagger Spec generated via TypeSpec.\\r\\n\\r\\nCan you please help with the queries below for these differences and confirm if these could lead to breaking changes for clients.\\r\\nAlso, what is the expectation from teams should any fixes required be added by the owning teams via a PR on top of this \\\"ConvertAdvisor\\\" branch with TypeSpec changes?\\r\\n1.x-ms-skip-url-encoding enabled on multiple endpoints with resourceUri Parameter.\\r\\n```diff\\r\\n\\\"paths\\\": {\\r\\n  \\\"/{resourceUri}/providers/microsoft.Advisor/recommendations\\\":\\r\\n    get:\\r\\n      operationId: Recommendations_ListByTenant\\r\\n      parameters:\\r\\n        {\\r\\n          \\\"name\\\": \\\"resourceUri\\\",\\r\\n          \\\"in\\\": \\\"path\\\",\\r\\n          \\\"required\\\": true,\\r\\n-         \\\"type\\\": \\\"string\\\"\\r\\n+         \\\"type\\\": \\\"string\\\",\\r\\n+         \\\"x-ms-skip-url-encoding\\\": true\\r\\n```\\r\\n2.Many Models containing array Type value in properties has been changed to \\\"required\\\" from optional\\r\\n```diff\\r\\n\\\"AssessmentListsResult\\\": {\\r\\n  \\\"type\\\": \\\"object\\\",\\r\\n  \\\"description\\\": \\\"[Placeholder] Discription for page model\\\",\\r\\n  \\\"properties\\\": {\\r\\n    \\\"value\\\": {\\r\\n      \\\"type\\\": \\\"array\\\",\\r\\n      \\\"description\\\": \\\"[Placeholder] Discription for value property\\\",\\r\\n      \\\"items\\\": {\\r\\n        \\\"$ref\\\": \\\"#/definitions/AssessmentResult\\\"\\r\\n      }\\r\\n    },\\r\\n    \\\"nextLink\\\": {\\r\\n      \\\"type\\\": \\\"string\\\",\\r\\n      \\\"format\\\": \\\"uri\\\",\\r\\n      \\\"description\\\": \\\"[Placeholder] Discription for nextLink property\\\"\\r\\n-   }\\r\\n  }\\r\\n+ },\\r\\n+ \\\"required\\\":[\\r\\n+   \\\"value\\\"\\r\\n+ ]\\r\\n```\\r\\n3.extendedProperties of type object contains an additional field named additonalProperties\\r\\n```diff\\n\\n## answer\\n\\ngoing forward, except in some limited cases (for example, some teams have special configuration for PowerShell cmdlets that only generate cmdlets for some of their OpenApi specs).  Generally though, this should not be a concern.\\r\\nTag name changes:  tags can affect Terraform.  You can use the @tag decorator (typespec core) to ensure that any missing tags are added to the spec\\r\\ndoc/summary:  The way the converter does this maximizes the usefulness of summary/description for client sdks.  You can still add summary documentation for other consumers of the specs using the @summary decorator\\n\\nFor one thing. the most important thing for the spec is that is accurately represents the API.  There is client decoration available in many cases to keep the sdk from breaking as we make sure the API is accurate:\\r\\nx-ms-skip-url-encoding:  Parameters like 'scope'  and 'resourceUri'  generally contain multiple path segments.  If they occur in a path parameter, you almost always want those path segments included in the path, so skipping url; encoding is appropriate.  If they occur in query parameters, then url encoding is irrelevant.  You can specificall set url encoding for path parameters by decorating with @path(#{allowReserved: true})\\r\\nThe value array.  Generally, the Value array occurs in list types, which also have a nextLink.  No more properties should mean no more nextLink.  It is almost always the case in actual practice that value always occurs in list responses, and this was a piece of inaccurate variance in the original spec.  The best practice is to validate that your service can have a response that does not contain a value property (which is unlikely), and only change the response type then.  Whether or not this is the case, it is highly unlikely to have any impact on clients, which have standard mechaniisms for handling paged types.\\r\\nSingle OpenAPI file:  Teams no longer maintain the OpenAPI spec, they maintain the TypeSpec as the source of truth and OpenApi is generated from that, so the layout of the OpenAPI files should not be important going forward, except in some limited cases (for example, some teams have special configuration for PowerShell cmdlets that only generate cmdlets for some of their OpenApi specs).  Generally though, this should not be a concern.\\r\\nTag name changes:  tags can affect Terraform.  You can use the @tag decorator (typespec core) to ensure that any missing tags are added to the spec\\r\\ndoc/summary:  The way the converter does this maximizes the usefulness of summary/description for client sdks.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_12.md\",\"document_title\":\"SDK Validation steps are failing with not much helpful logs\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_12.md\\n\\n# SDK Validation steps are failing with not much helpful logs\\n\\n## question\\n\\nWe’re in the process of creating a new API version within our RP. However, all SDK-related checks are currently failing, and we’re unable to identify any issues flagged in our changes.\\r\\n \\r\\nCould you please assist us in resolving these failures at the earliest? Your support will help us move forward without further delays.\\r\\n\\r\\n```\\r\\nErrors occurred while generating SDK from specification/advisor. Follow the steps at https://aka.ms/azsdk/sdk-automation-faq#how-to-view-the-detailed-sdk-generation-errors to view detailed errors.\\r\\n[ERROR] total 1 error(s):\\r\\n[ERROR] failed to execute `tsp-client init --update-if-exists --tsp-config /mnt/vss/_work/1/s/azure-rest-api-specs-pr/specification/advisor/Advisor.Management/tspconfig.yaml --commit 028d4d7cae9471f24a06aea6a1f60bf01f37f567 --repo Azure/azure-rest-api-specs-pr --local-spec-repo /mnt/vss/_work/1/s/azure-rest-api-specs-pr/specification/advisor/Advisor.Management --emitter-options module-version=0.1.0 --debug`\\r\\n[ERROR] Please update your tspconfig.yaml to include the \\\"emitter-output-dir\\\" option under the \\\"@azure-tools/typespec-go\\\" emitter options. \\\"package-dir\\\" support is deprecated and will be removed in future versions.\\r\\n[ERROR] Error reading tsp-location.yaml: Error: ENOENT: no such file or directory, stat '/mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/tsp-location.yaml'\\r\\n[ERROR] Diagnostics were reported during compilation. Use the `--debug` flag to see if there is warning diagnostic output.\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\n\\noutput.\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:10:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:10:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n```\\r\\n\\r\\n```\\r\\nSome checks were not successful\\r\\n7 failing, 2 pending, 1 queued, 31 successful checks\\r\\n\\r\\n7 failing checks\\r\\nprivate.rest-api-specs-pr Failing after 1m — Build #Azure OpenAPI failed\\r\\nprivate.rest-api-specs-pr (BranchProtectionForPrivateRepo) Failing after 1m — BranchProtectionForPriv...\\r\\nSDK Validation - .NET - PR Failing after 7m — Build #20250911.25 failed\\r\\nSDK Validation - Go - PR Failing after 4m — Build #20250911.25 failed\\r\\nSDK Validation - Java - PR Failing after 4m — Build #20250911.25 failed\\r\\nSDK Validation - JS - PR Failing after 3m — Build #20250911.25 failed\\r\\nSDK Validation - Python - PR Failing after 7m — Build #20250911.25 failed\\r\\n\\r\\nMerging is blocked\\r\\n```\\r\\n\\r\\nPR: [Advisor Risks : 2025-09-01-preview by pranatiy0701 · Pull Request #24395 · Azure/azure-rest-api-spe…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24395)\\n\\n## answer\\n\\nIt looks like your PR is against the main branch of the private repo - we don't check api specs into this branch.  The sdk failures for flattenProperty are due to those SDKs not being up-to-date with the latest version of typespec-client-generator-core, which was released earlier this week.  Since you are not checking this spec in to the main branch of the private repo, these can be safely ignored.\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-07-17.md\",\"document_title\":\"Error reported from common library with intersect-duplicate-property\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-07-17.md\\n\\n# Error reported from common library with intersect-duplicate-property\\n\\n## question\\n\\nSome duplicate exceptions thrown from the common library during the tsp compile, e.g.intersect-duplicate-property, duplicate-property\\n\\n## answer\\n\\nCheck the error properties, find them in the spec, remove them.\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-07-17.md\",\"document_title\":\"error duplicate-property in @azure-tools/typespec-azure-resource-manager/lib tsp\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-07-17.md\\n\\n# error duplicate-property in @azure-tools/typespec-azure-resource-manager/lib tsp\\n\\n## question\\n\\nDuring the compile process after the convert step, an error that should have appeared in the swagger folder is instead showing up in the lib tsp file.\\n\\n## answer\\n\\nLocate the operation in the swagger TSP file based on the duplicate property error, remove the custom Parameters from it, and then recompile.\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-08-14.md\",\"document_title\":\"The number of enums in the old and new Swagger don't match\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-08-14.md\\n\\n# The number of enums in the old and new Swagger don't match\\n\\n## question\\n\\n```diff\\r\\n{\\r\\n  \\\"name\\\": \\\"recommendationType\\\",\\r\\n  \\\"in\\\": \\\"query\\\",\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"CreateIndex\\\",\\r\\n    \\\"DropIndex\\\",\\r\\n+   \\\"ReIndex\\\",\\r\\n    \\\"AnalyzeTable\\\"\\r\\n  ],\\r\\n  \\\"x-ms-enum\\\": {\\r\\n    \\\"name\\\": \\\"RecommendationType\\\",\\r\\n    \\\"modelAsString\\\": true\\r\\n  }\\r\\n}\\r\\n}，\\r\\n```\\n\\n## answer\\n\\nThis may be caused by two enums with the same name but different content being treated as the same enum by TypeSpec, which cannot be resolved at the moment and needs to be documented in the PR description\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"libraries#typespec-client-generator-core#reference#decorators.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/decorators\",\"content\":\"# Decorators\\n## Azure.ClientGenerator.Core\\n### `@override` {#@Azure.ClientGenerator.Core.override}\\nlanguage emitters by default.\\u003cbr /\\u003eYou can use \\\"!\\\" to exclude specific languages, for example: !(java, python) or !java, !python. |\\r\\n#### Examples\\r\\n##### Customize parameters into an option bag\\r\\n```typespec\\r\\n// main.tsp\\r\\n@service\\r\\nnamespace MyService;\\r\\n\\r\\nop myOperation(foo: string, bar: string): void; // by default, we generate the method signature as `op myOperation(foo: string, bar: string)`;\\r\\n\\r\\n// client.tsp\\r\\nnamespace MyCustomizations;\\r\\n\\r\\nmodel Params {\\r\\n foo: string;\\r\\n bar: string;\\r\\n}\\r\\n\\r\\nop myOperationCustomization(params: MyService.Params): void;\\r\\n\\r\\n@@override(MyService.myOperation, myOperationCustomization); // method signature is now `op myOperation(params: Params)`\\r\\n```\\r\\n##### Customize a parameter to be required\\r\\n```typespec\\r\\n// main.tsp\\r\\n@service\\r\\nnamespace MyService;\\r\\n\\r\\nop myOperation(foo: string, bar?: string): void; // by default, we generate the method signature as `op myOperation(foo: string, bar?: string)`;\\r\\n\\r\\n// client.tsp\\r\\nnamespace MyCustomizations;\\r\\n\\r\\nop myOperationCustomization(foo: string, bar: string): void;\\r\\n\\r\\n@@override(MyService.myOperation, myOperationCustomization)\\r\\n\\r\\n// method signature is now `op myOperation(params: Params)` just for csharp // method signature is now `op myOperation(foo: string, bar: string)`\\r\\n```\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# TypeSpec\\n## `ProvisioningStateMustBeReadOnly`\\nThe root cause is a limitation in how `azure-openapi-validator` and `oav` handle `$ref` siblings:\\r\\n- https://github.com/Azure/azure-openapi-validator/issues/637\\r\\n- https://github.com/Azure/oav/issues/848\\r\\nThe recommended workaround is to add `use-read-only-status-schema: true` to your `tspconfig.yaml`.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#mustread.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/mustread\",\"content\":\"# Understanding the OpenAPI Changes\\n## Handling \\\"readOnly\\\" in Model Schemas\\nThe `\\\"readOnly\\\": true` property should only be used on properties, not on models. If a model is mistakenly marked as readOnly and other models refer to it, like this:\\r\\n\\r\\n```json\\r\\n\\\"ReadOnlyModel\\\": {\\r\\n  \\\"readOnly\\\": true\\r\\n},\\r\\n\\\"ReferToReadOnlyModel\\\": {\\r\\n  \\\"properties\\\": {\\r\\n    \\\"property\\\": {\\r\\n      \\\"$ref\\\": \\\"#/definitions/ReadOnlyModel\\\"\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\nDecorating the property referencing the model with '@visibility(Lifecycle.Read)` is equivalent to marking the model schema as read-only as in the OpenAPI above.\\r\\n\\r\\n```tsp\\r\\nmodel ReadOnlyModel {}\\r\\n\\r\\nmodel ReferToReadOnlyModel {\\r\\n  @visibility(Lifecycle.Read)\\r\\n  property: ReadOnlyModel;\\r\\n}\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#reference#decorators.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/reference/decorators\",\"content\":\"# Decorators\\n## TypeSpec.OpenAPI\\n### `@useRef` {#@TypeSpec.OpenAPI.useRef}\\nSpecify an external reference that should be used inside of emitting this type.\\r\\n\\r\\n```typespec\\r\\n@TypeSpec.OpenAPI.useRef(ref: valueof string)\\r\\n```\\r\\n\\r\\n#### Target\\r\\n\\r\\n`Model | ModelProperty`\\r\\n\\r\\n#### Parameters\\r\\n\\r\\n| Name | Type             | Description                                                          |\\r\\n| ---- | ---------------- | -------------------------------------------------------------------- |\\r\\n| ref  | `valueof string` | External reference(e.g. \\\"../../common.json#/components/schemas/Foo\\\") |\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"language-basics#visibility.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/language-basics/visibility\",\"content\":\"# Visibility\\n## Lifecycle visibility\\nschema:\\r\\n                $ref: \\\"#/components/schemas/Example\\\"\\r\\n    patch:\\r\\n      parameters:\\r\\n        - name: id\\r\\n          in: path\\r\\n          required: true\\r\\n          schema:\\r\\n            type: string\\r\\n      responses:\\r\\n        \\\"200\\\":\\r\\n          content:\\r\\n            application/json:\\r\\n              schema:\\r\\n                $ref: \\\"#/components/schemas/Example\\\"\\r\\n      requestBody:\\r\\n        required: true\\r\\n        content:\\r\\n          application/json:\\r\\n            schema:\\r\\n              $ref: \\\"#/components/schemas/ExampleUpdate\\\"\\r\\ncomponents:\\r\\n  schemas:\\r\\n    Example:\\r\\n      type: object\\r\\n      required:\\r\\n        - id\\r\\n        - name\\r\\n        - description\\r\\n      properties:\\r\\n        id:\\r\\n          type: string\\r\\n          readOnly: true\\r\\n        name:\\r\\n          type: string\\r\\n        description:\\r\\n          type: string\\r\\n    ExampleUpdate:\\r\\n      type: object\\r\\n      properties:\\r\\n        description:\\r\\n          type: string\\r\\n```\\r\\n\\r\\nNotice:\\r\\n\\r\\n- The `id` property is marked `readOnly: true` because it is only visible when reading the resource.\\r\\n- The `ExampleUpdate` schema only includes the `description` property because it is the only property that is visible\\r\\n  when updating the resource.\\r\\n- Each of the `paths` reference the correct schema based on the lifecycle phase that the operations use.\\r\\n- The TypeSpec model is only defined _once_, and any changes in the output schemas are derived from the lifecycle\\r\\n  visibility of the properties in the model.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"libraries#xml#guide.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/libraries/xml/guide\",\"content\":\"# Guide\\n## Examples\\n### 3. Nested models\\n\\u003ctable\\u003e\\r\\n\\u003ctr\\u003e\\r\\n  \\r\\n  \\u003ctd\\u003eTypeSpec\\u003c/td\\u003e\\r\\n  \\u003ctd\\u003eXml\\u003c/td\\u003e\\r\\n  \\u003ctd\\u003eOpenAPI3\\u003c/td\\u003e\\r\\n\\u003c/tr\\u003e\\r\\n\\u003c!-- ---------------------------------------------------  SCENARIO 3.1  ----------------------------------------------------------- --\\u003e\\r\\n\\u003ctr\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```tsp\\r\\nmodel Book {\\r\\n  author: Author;\\r\\n}\\r\\n\\r\\nmodel Author {\\r\\n  name: string;\\r\\n}\\r\\n```\\r\\n\\r\\n\\u003c/td\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```xml\\r\\n\\u003cBook\\u003e\\r\\n  \\u003cauthor\\u003e\\r\\n    \\u003cname\\u003estring\\u003c/name\\u003e\\r\\n  \\u003c/author\\u003e\\r\\n\\u003c/Book\\u003e\\r\\n```\\r\\n\\r\\n\\u003c/td\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```yaml\\r\\nBook:\\r\\n  type: object\\r\\n  properties:\\r\\n    author:\\r\\n      $ref: \\\"#/components/schemas/Author\\\"\\r\\nAuthor:\\r\\n  type: object\\r\\n  properties:\\r\\n    name:\\r\\n      type: string\\r\\n```\\r\\n\\r\\n\\u003c/td\\u003e\\r\\n\\u003c/tr\\u003e\\r\\n\\r\\n\\u003c!-- ---------------------------------------------------  SCENARIO 3.2  ----------------------------------------------------------- --\\u003e\\r\\n\\u003ctr\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```tsp\\r\\nmodel Book {\\r\\n  author: Author;\\r\\n}\\r\\n\\r\\n@encodedName(\\\"application/xml\\\", \\\"XmlAuthor\\\")\\r\\nmodel Author {\\r\\n  name: string;\\r\\n}\\r\\n```\\r\\n\\r\\n\\u003c/td\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```xml\\r\\n\\u003cBook\\u003e\\r\\n  \\u003cauthor\\u003e\\r\\n    \\u003cname\\u003estring\\u003c/name\\u003e\\r\\n  \\u003c/author\\u003e\\r\\n\\u003c/Book\\u003e\\r\\n```\\r\\n\\r\\n\\u003c/td\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```yaml\\r\\nBook:\\r\\n  type: object\\r\\n  properties:\\r\\n    author:\\r\\n      allOf:\\r\\n        - $ref: \\\"#/components/schemas/Author\\\"\\r\\n      xml:\\r\\n        name: \\\"author\\\" # Here we have to redefine this name otherwise in OpenAPI semantic the `XmlAuthor` name would be used\\r\\nAuthor:\\r\\n  type: object\\r\\n  properties:\\r\\n    name:\\r\\n      type: string\\r\\n  xml:\\r\\n    name: \\\"XmlAuthor\\\"\\r\\n```\\r\\n\\r\\n\\u003c/td\\u003e\\r\\n\\u003c/tr\\u003e\\r\\n\\r\\n\\u003c!-- ---------------------------------------------------  SCENARIO 3.3  ----------------------------------------------------------- --\\u003e\\r\\n\\u003ctr\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```tsp\\r\\nmodel Book {\\r\\n  @encodedName(\\\"application/xml\\\", \\\"xml-author\\\")\\r\\n  author: Author;\\r\\n}\\r\\n\\r\\nmodel Author {\\r\\n  name: string;\\r\\n}\\r\\n```\\r\\n\\r\\n\\u003c/td\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```xml\\r\\n\\u003cBook\\u003e\\r\\n  \\u003cxml-author\\u003e\\r\\n    \\u003cname\\u003estring\\u003c/name\\u003e\\r\\n  \\u003c/xml-author\\u003e\\r\\n\\u003c/Book\\u003e\\r\\n```\\r\\n\\r\\n\\u003c/td\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```yaml\\r\\nBook:\\r\\n  type: object\\r\\n  properties:\\r\\n    author:\\r\\n      allOf:\\r\\n        - $ref: \\\"#/components/schemas/Author\\\"\\r\\n      xml:\\r\\n        name: \\\"xml-author\\\"\\r\\nAuthor:\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#breakingchange.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# Resolving OpenAPI Breaking Change Violations\\nThe OpenAPI Converter cannot perfectly represent every aspect of every API in TypeSpec. This document outlines common changes you may need to make to a converted TypeSpec to ensure compatibility with your existing service API and to pass check-in validations.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"extending-typespec#diagnostics.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/extending-typespec/diagnostics\",\"content\":\"# Diagnostics\\nThe TypeSpec compiler uses the diagnostic API to report errors and warnings in the specification.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"language-basics#documentation.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/language-basics/documentation\",\"content\":\"# Documentation\\nDocumentation is a vital aspect of any API. TypeSpec offers several ways to document your API, including doc comments and decorators.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"language-basics#type-literals.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/language-basics/type-literals\",\"content\":\"# Type Literals\\nWhen designing APIs, it's common to define the structure of the API in terms of specific literal values. For instance, an operation might return a specific integer status code, or a model member might be one of a few specific string values. It's also useful to pass specific literal values to decorators. TypeSpec supports string, number, and boolean literal values to cater to these needs.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#cli.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/cli\",\"content\":\"# OpenAPI3 to TypeSpec\\n:::caution\\r\\nThe OpenAPI3 to TypeSpec conversion purpose is a one time conversion to help you get started with TypeSpec.\\r\\nThe output can change in future versions of TypeSpec without being considered a breaking change.\\r\\n:::\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors\",\"content\":\"# Resolving Folder Migration Conflicts: A Guide for PR Authors\\n## The impact to ongoing PRs\\n### After Resolution\\nMake sure to compile the TypeSpec project so that the TypeSpec Validation could pass.\\r\\n\\r\\n1. **Comprehensive validation**:\\r\\n   ```bash\\r\\n   # Run full validation suite\\r\\n   npm ci\\r\\n   npm run lint\\r\\n   npm run validate\\r\\n   \\r\\n   # Test TypeSpec compilation for your service\\r\\n   cd specification/app/data-plane/DynamicSessions/\\r\\n   npx tsp compile .\\r\\n   npx tsp compile . --emit @azure-tools/typespec-autorest\\r\\n   \\r\\n   # Verify generated files match expectations by checking if there's any diff with the OpenAPI json files.\\r\\n   ```\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Requirement.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Requirement\",\"content\":\"# Suppressing Failures\\nIf you need to suppress this check (instead of converting to TypeSpec), add entries to the `suppressions.yaml` for your spec.  Example:\\r\\n\\r\\n```\\r\\n# specification/widget/resource-manager/Microsoft.Widget/Widget/suppressions.yaml\\r\\n- tool: TypeSpecRequirement\\r\\n  paths: \\r\\n    - preview/2022-08-01-preview/**/*.json\\r\\n    - preview/2023-02-01-preview/**/*.json\\r\\n```\\r\\n\\r\\nMore examples: https://github.com/search?q=TypeSpecRequirement+repo%3Aazure%2Fazure-rest-api-specs+path%3A**%2Fsuppressions.yaml\\u0026type=code\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"# Convert OpenAPI specs to TypeSpec\\nThis document outlines the process for converting OpenAPI specifications to TypeSpec, detailing the responsibilities of\\r\\nboth the service team and the Azure SDK team.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"# Convert OpenAPI specs to TypeSpec\\n## Conversion scope\\n- Horizontal conversion: Converting existing Azure OpenAPI specs to TypeSpec should not introduce any changes to the API.\\r\\n- No version revving: No version revving will occur during this process. The focus is solely on converting the existing\\r\\nspecifications to TypeSpec.\\r\\n- SDKs generated for validation only: The SDKs generated from the converted TypeSpec files will be used for validation\\r\\npurposes only. They are not intended for production release.\"}]", "inputs.latency": 763.1819140911102, "inputs.response_length": 2532, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://typespec.io/docs/emitters/openapi3/diagnostics", "https://typespec.io/docs/emitters/openapi3/cli"], "inputs.testcase": "Override description property in referenced parameter.", "outputs.similarity.similarity": 5.0, "outputs.similarity.gpt_similarity": 5.0, "outputs.similarity.similarity_result": "pass", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1464, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1465, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Override description property in referenced parameter.\\\\n\\\\nquestion: In this PR I need to override the description for the typeahead parameter for a specific API, so that all other API that reference this property will not be affected:\\\\nBut this is throwing an error:\\\\nerror: Schema violation: must NOT have additional properties (paths > /search/address/{format} > get > parameters > 4)\\\\nadditionalProperty: description\\\\nI don't know why it is throwing an error, it worked in a similar situation for the BoundingBoxCompassNotation object in PR38554\\\", \\\"response\\\": \\\"The error you're encountering\\\\u2014\\\\\\\"Schema violation: must NOT have additional properties (paths > /search/address/{format} > get > parameters > 4) additionalProperty: description\\\\\\\"\\\\u2014is typically triggered when the OpenAPI emitter finds a referenced parameter that is being overridden or extended in a way that is not allowed by the OpenAPI specification. In OpenAPI, when you reference a parameter (using `$ref`), you cannot add or override properties such as `description` directly at the point of reference; the reference must be to a complete parameter object, and any additional properties are forbidden.\\\\n\\\\nIn TypeSpec, if you have a shared parameter (like `typeahead`) that is used across multiple operations, and you want to override its description for just one operation, you cannot do this by simply referencing the parameter and attaching a new description. This is a limitation of OpenAPI itself\\\\u2014not TypeSpec\\\\u2014and is enforced by both the OpenAPI emitter and validators.\\\\n\\\\nHow did it work previously for `BoundingBoxCompassNotation`? It's possible that in that case, the parameter was redefined (copied or specialized) for the specific operation, rather than referenced via `$ref`. When you need a unique description for a parameter in a single operation, the correct approach is:\\\\n\\\\n**Solution:**\\\\n- Define a new parameter model/type specifically for the operation that needs the unique description. Do not use the shared `$ref` for this one case.\\\\n- All other operations can continue to use the shared parameter reference.\\\\n\\\\n**Example:**\\\\n```typespec\\\\n// Shared parameter\\\\nmodel TypeaheadParam {\\\\n  @query\\\\n  typeahead: string;\\\\n}\\\\n\\\\n// For most operations\\\\nop getSomething(@TypeaheadParam): Response;\\\\n\\\\n// For /search/address/{format}, define a specialized parameter\\\\nmodel TypeaheadParamForAddress {\\\\n  @query\\\\n  @doc(\\\\\\\"Custom description just for this API.\\\\\\\")\\\\n  typeahead: string;\\\\n}\\\\n\\\\nop searchAddress(@TypeaheadParamForAddress): Response;\\\\n```\\\\n\\\\nThis way, the OpenAPI emitter will generate an inline parameter definition for `/search/address/{format}` with your custom description, and all other operations will continue to use the shared `$ref`. This avoids the schema violation.\\\\n\\\\n**Summary:** You cannot override the description of a referenced parameter inline due to OpenAPI limitations. You must define a unique parameter for the operation that requires a different description.\\\\n\\\\nIf you need to override other aspects of parameters (e.g., required, type), use the same approach: create a specialized parameter type for the affected operation.\\\\n\\\", \\\"ground_truth\\\": \\\"You should be able to workaround this be slightly refactoring your swagger, for example create a new parameter TypeaheadDeprecated with the new description.\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"5\"}]"}, {"inputs.query": "title: doc only update?\n\nquestion: Hey team,\nI'm a PM on the VMSS team. I'm trying to understand the new Typespec way to do a documentation only update to swagger? In this case, I just want to update these doc strings to remove/modify the preview notes. I believe I updated the correct text in the models.tsp files. The swagger compiled correctly. Now my questions:\nI want this to be updated in current documentation posted online, as well as SDK docs. How do I submit this change against main or the latest feature branch? Do I need to do additional work to make sure this change is propagated through to SDKs?\nWhen I submitted the PR, got this error. Not sure how to fix: \"The default tag contains multiple API versions swaggers.\"\nThe PR for reference:\n[VMSS prioritizeunhealthyvm and force delete doc update by fitzgeraldsteele · Pull Request #25785 ](https://github.com/Azure/azure-rest-api-specs-pr/pull/25785)", "inputs.ground_truth": "Swagger and TSP must always match.  So the same PR, but to public/main instead of private/main.The error from \"Swagger Avocado\" is an existing problem in your spec, that should be fixed eventually.  See this run from a previous PR to your spec.\nhttps://github.com/Azure/azure-rest-api-specs/actions/runs/18538687430\nDocs:\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#multiple_api_version", "inputs.response": "You are following the correct process for a documentation-only update in TypeSpec: update the doc strings in your .tsp files, compile to OpenAPI, and submit a PR. Documentation changes (such as removing or modifying preview notes) should be made directly in TypeSpec, and these changes will propagate to both the published REST API docs and the generated SDK docs after merging.\n\n**How to submit the change:**\n- You should submit your PR against the `main` branch of `azure-rest-api-specs` (or the corresponding service release branch if your team uses a protected/release branch workflow).\n- No additional work is required to propagate documentation-only changes to SDKs: as long as your PR merges, the next weekly docs and SDK refresh will pick up the change automatically. Documentation-only changes do not trigger breaking changes or require versioning decorators.\n\n**About the error: \"The default tag contains multiple API versions swaggers\":**\n- This is the Avocado `MULTIPLE_API_VERSION` error. It means that your default tag includes multiple API version OpenAPI files, which is now a merge blocker since July 2025 (see references).\n- To resolve this, you must ensure that only one API version OpenAPI file is included in the default tag in your service's `readme.md`. This is a coordinated Azure-wide effort to enforce uniform versioning and unblock TypeSpec migration. See [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) for details.\n\n**Recommended steps to fix:**\n1. In your service's `readme.md`, make sure the `input-file` for the default tag only points to a single OpenAPI version file (the latest or the one you want to update). Remove older versions from the default tag.\n2. If your service must support multiple versions in the default tag for a valid reason, you need to request a one-time suppression from the Azure versioning team (azversioning@service.microsoft.com), or temporarily add the `Approved-Avocado` label to your PR if instructed by the team (see references below).\n3. Once the PR merges, your documentation change will be reflected in both the public API docs and the SDK docs at the next scheduled refresh (usually weekly).\n\n**Summary:**\n- Update doc strings in TypeSpec, compile, and submit PR to main.\n- Ensure only one API version is present in the default tag in readme.md.\n- No special versioning or additional work is needed for documentation-only changes.\n- If blocked by Avocado error, follow the Uniform Versioning Violation Guide or contact the versioning team for help.\n\nLet me know if you need help editing your readme.md or resolving the Avocado error.\n", "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"Create a PR against main\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\\n\\n# Create a PR against main\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nWhen you're ready for a final review, it's time to create a pull request (PR) from your release branch you created\\r\\noriginally to the `main` branch on [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n* :warning: Do not merge `main` or other release branches unless you know there are changes required.\\r\\n* :white_check_mark: Rebase on `main` if changes are required in a separate topic branch.\\n\\n## Clean PR against main\\n\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\\n\\n## Update your branch with changes from main\\n\\nIf you know there are other changes in the `main` branch or that other services have updated shared files in `main`\\r\\nalready and you need to pick up changes before merging, we recommend you take a merge from main. This is particularly interesting\\r\\nfor common infrastructure changes that are committed in the repo (i.e. github actions, tools, etc). Depending on how old your\\r\\nbranch is some of the pull request checks may not correctly function without taking a merge from main. \\r\\n\\r\\nIf you are working in a non-protected branch you can do a `git merge main` like you would normally do a merge and then push\\r\\nyour changes to your remote branch. However, if you are working in a branch with branch protection enabled (i.e. `release-*`) then\\r\\nyou will need to make a pull request to your branch with the merge. Depending on how out-of-date your branch is from `main` your \\r\\nmerge may have a lot of unwanted and unnecessary changes and the checks not pass. In such cases see below on how to [update the infrastructure](#updating-only-the-infrastructure-changes-from-main).\\n\\n### Updating only the infrastructure changes from main\\n\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\\n\\n## Next steps\\n\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"Azure REST API, SDK development process with TypeSpec\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure-REST-API,-SDK-development-process-with-TypeSpec.md\\n\\n# Azure REST API, SDK development process with TypeSpec\\n\\n## Table Of Content\\n\\n1. Introduction\\r\\n2. Repo setup \\u0026 prerequisites\\r\\n3. Creating a new TypeSpec project\\r\\n4. Prepare and submit a Pull Request for reviewing\\r\\n5. Generate SDK code from a TypeSpec project\\n\\n### 1. Introduction\\n\\nThis document describes the processes of developing Azure REST APIs and SDKs with TypeSpec language. The steps below\\r\\n assumes that you are developing TypeSpec API specifications in the `azure-rest-api-specs` and `azure-rest-api-specs-pr`repos.\\r\\nIf you are developing within your own ADO repo first and then submitting into `azure-rest-api-specs` repos for review and\\r\\n release, you will need to copy the TypeSpec files over.\\n\\n### 2. Repo setup \\u0026 prerequisites\\n\\n- The main repos for Azure REST APIs are [azure-rest-api-specs](https://github.com/azure/azure-rest-api-specs) and [azure-rest-api-specs-pr](https://github.com/azure/azure-rest-api-specs-pr)\\r\\n repos. The `-pr` repo contains `RPSaaSMaster` and `RPSaaSDev` branches for ProviderHub based ARM service specs.\\r\\n#### 2.1 With local machine development\\r\\n- [Node.js LTS](https://nodejs.org/en) version 18 or above (LTS Recommended).\\r\\n Ensure you can run the npm command in a command prompt:\\r\\n  ```npm\\r\\n    npm --version\\r\\n  ```\\r\\n- Run following command in the **repository root folder**. This will install required packages such as TypeSpec\\r\\n compilers and Azure Library packages.\\r\\n  ```npm\\r\\n     npm ci\\r\\n  ```\\r\\n- Ensure you can run TypeSpec command within the repo folders.\\r\\n  ```npm\\r\\n     npx tsp --version\\r\\n  ```\\r\\n- One-time set up: Install TypeSpec VisualStudio or VS Code extensions to get syntex highlighting, tool tips in IDE:  \\r\\n  ```npm\\r\\n    npx tsp code install\\r\\n  ```\\r\\n  OR\\r\\n    ```npm\\r\\n      npx tsp vs install\\r\\n    ```\\r\\n#### 2.2  VS Code with local docker .devcontainer\\r\\nAll prerequisites have been installed in the dev container. You should to have `Docker Desktop` and `WSL2` running if\\r\\n you are on Windows machine.\\r\\nTo start, you just need to install `Dev Containers` VS code extension, then open the repo path.\\r\\n- VS Code will detect the .devcontainer and prompt you to reopen the workspace.\\r\\n- Alternatively, you can use Command Palette -\\u003e Dev Containers: Reopen in Container.  \\r\\nOnce VS Code reopened in Container, you can run any of the program below in the VS Code integrated terminal.\\r\\n#### 2.2 VS Code in browser via GitHub codespaces\\r\\nGitHub codespaces leverage the same dev container in the repo. The difference is it is hosted in cloud with VS Code in\\r\\n browser.\\r\\nTo start, you just need to browse to the `azure-rest-api-specs` repo, select `\\u003c\\u003e Code` drop down and follow `Codespaces`\\r\\n instructions.\\n\\n### 3. Creating a new TypeSpec project\\n\\nPlease first review recommended folder structure detailed in [this document](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/directory-structure.md).\\r\\n1. Under `[reporoot]\\\\specification`, create service folder directly.\\r\\n   - Select `(rest-api-spec repo) ARM` or `(rest-api-spec repo) Data-plane` and answer appropriate naming questions.\\r\\n   - If it's ARM service, the service folder would be `specification/{organization}/resource-manager/\\u003cRPNS\\u003e/{service}`.\\r\\n   - If it's Data Plane service, the service folder would be `specification/{organization}/data-plane/{service}`\\r\\n2. Create a new TypeSpec project based on Azure template with command:\\r\\n    ```cli\\r\\n       npx tsp init https://aka.ms/typespec/azure-init\\r\\n    ```\\r\\n3. Compile the generated TypeSpec project with command:\\r\\n    ```cli\\r\\n      npx tsp compile .\\r\\n    ```\\r\\n    The generated OpenAPI files should be correctly placed in the `{service}`folders following the naming conventions.\\r\\n4. Now the project has been set up. You can modify the sample and develop your own APIs with TypeSpec.\\n\\n### 4. Prepare and submit a Pull Request for reviewing\\n\\n1. Create a branch in your local repository for your changes.\\r\\n2. Create or update the TypeSpec files for your service.\\r\\n3. Add or update 'examples' files for each operation of your OpenAPI file.\\r\\n   The [oav](https://github.com/Azure/oav) provides two ways to generate OpenAPI examples:\\r\\n   1. Generating basic examples and then manually modify the values. It will generate two examples for each operation:\\r\\n    one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated\\r\\n     examples consist of random values for most types, you need replace them with meaningful values.\\r\\n       ```bash\\r\\n       oav generate-examples openapi.json\\r\\n       ```\\r\\n    Note, latest OAV tool should automatically generate the following. However, if you are generating the examples manually,\\r\\n     please ensure you have:\\r\\n    - include `title` field and make sure it is descriptive and unique for each operation.\\r\\n    - include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in OpenAPI.\\r\\n4. Add/update the `readme.md` file in the `{service}` folder to specify the version and location of the OpenAPI files. The `readme.md` is needed for both management-plane and data-plane services for REST API Docs generation.\\r\\n   Example:[sample-readme](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/readme.md)\\r\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\n\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\r\\n   - send a pull request to the original repo from your forked repo.\\r\\n   See the ARM Wiki for information on the [supported repos and branches for management-plane services](https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches).\\r\\n#### 4.1 Fix the errors of PR reviewing CI checks\\r\\nThe CI checks result will be commented on the PR. you can refer to the [CI fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\\r\\nNote:\\r\\nSince the OpenAPI is generated from TypeSpec, to change the OpenAPI, you must update the TypeSpec file and regenerate the\\r\\n OpenAPI and avoid updating OpenAPI directly to keep the consistency between OpenAPI and TypeSpec.\\r\\nFor support \\u0026 help, you can post a message to [TypeSpec Discussion - teams channel](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\\n\\n### 5. Generate SDK code from a TypeSpec project\\n\\nRefer to [Develop client libraries](https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop?tabs=management) for more details.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#01-get-started.md\",\"document_title\":\"Getting started with TypeSpec migration\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\",\"content\":\"# migrate-swagger#01-get-started.md\\n\\n# Getting started with TypeSpec migration\\n\\nWe have created a OpenAPI to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane OpenAPI files. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\\r\\n\\r\\n**_Important!_** Because TypeSpec is more expressive than OpenAPI and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\\n\\n## Steps of migration and comparison\\n\\n### Prerequisite\\n\\n- Clone [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n- Install dependencies:\\r\\n  ```shell\\r\\n  npm install # Run at root of the repository\\r\\n  ```\\n\\n### Generate TypeSpec with converter\\n\\n- Go to the `specification/{service-name}` folder in `azure-rest-api-specs`.\\r\\n- Create a directory holding TypeSpec files. See details [here](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\\r\\n- Run the tool from the directory.\\r\\n  - Convert a **data-plane** specification:\\r\\n\\r\\n    ```shell\\r\\n    tsp-client convert --swagger-readme [path to readme.md]\\r\\n    ```\\r\\n\\r\\n  - Convert a **control-plane** specification:\\r\\n\\r\\n    ```shell\\r\\n    tsp-client convert --swagger-readme [path to readme.md] --arm\\r\\n    ```\\r\\n\\r\\n  - Convert a **control-plane** specification to fully compatible output:\\r\\n\\r\\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original OpenAPI file. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the OpenAPI file.\\r\\n\\r\\n    ```shell\\r\\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\\r\\n    ```\\n\\n### Review and adjust the TypeSpec\\n\\nYou will need to compare the OpenAPI file generated from TypeSpec with the original OpenAPI specification(s) to ensure functional equivalence.\\r\\n\\r\\n- In the TypeSpec folder, compile TypeSpec files to emit an auto-generated OpenAPI file:\\r\\n\\r\\n  ```shell\\r\\n  tsp compile .\\r\\n  ```\\r\\n\\r\\n- From the root folder, download the latest specification as baseline. Your original specification will be located at `.\\\\sparse-spec\\\\specification\\\\{service-name}`:\\r\\n\\r\\n  ```shell\\r\\n  .\\\\eng\\\\tools\\\\typespec-migration-validation\\\\scripts\\\\download-main.ps1 {path\\\\to\\\\your\\\\generated\\\\openapi\\\\file}\\r\\n  ```\\r\\n\\r\\n- At the end of the console output, you'll see the next command to sort, merge, and normalize the original OpenAPI file(s) and generated OpenAPI file, making it easier to review changes. Provide an `outputFolder` to store the analysis results:\\r\\n\\r\\n  ```shell\\r\\n  npx tsmv {your\\\\original\\\\openapi\\\\folder} {your\\\\generated\\\\openapi\\\\file} --outputFolder {outputFolder}\\r\\n  ```\\r\\n\\r\\n- In the `{outputFolder}`:\\r\\n  - `newNormalizedSwagger.json` is the processed version of the generated OpenAPI file\\r\\n  - `oldNormalizedSwagger.json` is the processed version of the original OpenAPI file(s)\\r\\n\\r\\n  In VS Code, select both files (select `oldNormalizedSwagger.json` first, then `newNormalizedSwagger.json`), right-click and choose \\\"Compare Selected\\\". Review these differences to understand their patterns.\\r\\n\\r\\n- Check out the output from `npx tsmv` execution. It prints suggested fixes and prompts if any. Please review them before any run.\\r\\n\\r\\n  **Suggested fixes:** These provide exact TypeSpec code that you can apply directly by following the instructions.\\r\\n\\r\\n  **Suggested prompts:** To use these, drag all the TypeSpec files into GitHub Copilot context. Select \\\"Agent\\\" or \\\"Edit\\\" mode with the \\\"Claude\\\" model. Use the provided prompt to ask GitHub Copilot to generate fixes. Carefully review all changes before accepting or undoing them.\\r\\n\\r\\n- For remaining differences, follow this iterative process:\\n\\nPlease review them before any run.\\r\\n\\r\\n  **Suggested fixes:** These provide exact TypeSpec code that you can apply directly by following the instructions.\\r\\n\\r\\n  **Suggested prompts:** To use these, drag all the TypeSpec files into GitHub Copilot context. Select \\\"Agent\\\" or \\\"Edit\\\" mode with the \\\"Claude\\\" model. Use the provided prompt to ask GitHub Copilot to generate fixes. Carefully review all changes before accepting or undoing them.\\r\\n\\r\\n- For remaining differences, follow this iterative process:\\r\\n  1. Recompile TypeSpec files with `tsp compile .` in the TypeSpec folder.\\r\\n  2. Run the `npx tsmv` command again with the same parameters.\\r\\n  3. Review the updated differences in VS Code.\\r\\n  4. Make further adjustments as needed. Refer to [Understanding the OpenAPI Changes](./faq/mustread.md) to understand expected changes and mitigation steps. For more effective visualization, fix differences in this recommended order:\\r\\n     - Path (route) differences first\\r\\n     - Definition (model) name differences next\\r\\n     - Detail differences within paths and definitions last\\n\\n### Create Spec PR with new TypeSpec project\\n\\n- In the `readme.md` file, under the latest tag, change the `input-file` to the OpenAPI file generated from TypeSpec.\\r\\n- If the generated OpenAPI file(s) for the latest version changed name, delete the old OpenAPI file(s) no longer referenced in README.md.\\r\\n- Create a PR with the TypeSpec files, changed OpenAPI files (examples included) and readme file.\\r\\n- Check CI failures. Refer to [Resolving Pipeline failures](./faq/pipeline.md)\\n\\n## How to Get Help\\n\\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\\r\\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\\r\\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\\r\\n  - For bugs, please include:\\r\\n    - A high-level description of the bug\\r\\n    - Expected and Actual Results\\r\\n    - Repro steps, including any TypeSpec code that you used\\r\\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\\r\\n- Schedule review meetings with TypeSpec team.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-2-update.md\",\"document_title\":\"Work against the release branch\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-2-update\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-2-update.md\\n\\n# Work against the release branch\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nNow that you've created a release branch, let people know the branch name you created above. They should create topic\\r\\nbranches against that branch - just like they would against the `main` branch - and submit pull requests (PR).\\r\\nRead about [API design](xref:api-design) for guidelines and more information.\\r\\n\\r\\n- :white_check_mark: Create a topic branch from the upstream release branch.\\r\\n- :white_check_mark: Submit a PR when ready against the upstream release branch.\\r\\n- :x: Do not merge the `main` branch into your topic branch. If you need specific changes, you can cherry-pick them,\\r\\n  or simply copy and paste.\\n\\n## Create a fork\\n\\n1. Create a fork, which is a copy of the target repository. You only need to do this once.\\r\\n\\r\\n   - In [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) (public) or  \\r\\n     [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr) (private) - wherever you created\\r\\n     your branch above - click on the **Fork** button if you haven't already forked the repository.\\r\\n     This will create a copy in developers' own profiles. Read more about [our repositories](xref:api-repos) for what is\\r\\n     public and what is private.\\r\\n\\r\\n   - Click the **Clone** button to clone the repository to your local machine. You can also just hit `.` on\\r\\n     GitHub to open the repository in Visual Studio Code online.\\r\\n\\r\\n2. Whatever tool you use, switch branches to the release branch created above, and then create a new branch.\\r\\n   Call it whatever you like, but a brief, descriptive name like `add-models` is recommended.\\r\\n\\r\\n   Using a terminal, for example, you can pull the upstream release branch and create a topic branch:\\r\\n\\r\\n   ```bash\\r\\n   git fetch upstream release-cognitiveservices-2022-03-01-preview\\r\\n   git checkout -b add-models upstream/release-cognitiveservices-2022-03-01-preview\\r\\n   ```\\n\\n## Make changes to a REST API definition for a release\\n\\n### [Using Typespec](#tab/typespec)\\n\\nStart working on your TypeSpec files.\\n\\n### [Create OpenAPI specs](#tab/create-openapi)\\n\\nFollow instructions on [Create your REST API definition](xref:api-specs?tabs=openapi)\\r\\n\\r\\n#### Start working on your new OpenAPI specs\\r\\n\\r\\nMake the desired changes on your new OpenAPI specification files.\\n\\n### [Update OpenAPI specs](#tab/update-openapi)\\n\\nUpdate the OpenAPI specification files directly.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#versioning.md\",\"document_title\":\"Versioning\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/versioning\",\"content\":\"# howtos#arm#versioning.md\\n\\n# Versioning\\n\\nThis document explains how to manage versioning in TypeSpec projects, including how to add, remove, or modify resources, operations, and properties across API versions.\\n\\n## Introduction\\n\\nVersioning allows you to evolve your API without breaking existing clients. By using versioning decorators, you can specify when resources, operations, or properties are added, removed, or changed.\\n\\n## Declaring Versions\\n\\nDefine your API versions in an enum. For each version, specify dependencies and common types as needed.\\r\\n\\r\\n```tsp\\r\\n/** Contoso API versions */\\r\\nenum Versions {\\r\\n  /** 2021-10-01-preview version */\\r\\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\\r\\n  v1,\\r\\n\\r\\n  /** 2022-11-01-preview version */\\r\\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\\r\\n  v2,\\r\\n}\\r\\n```\\r\\n\\r\\nAfter defining your enum, link it to your namespace using the `@versioned` decorator:\\r\\n\\r\\n```tsp\\r\\n@versioned(Versions)\\r\\nnamespace Microsoft.ContosoProviderHub;\\r\\n```\\r\\n\\r\\n\\u003e **Note:** Add dependencies and common types for each version. After defining a new version, the emitter will produce outputs for all versions. You can then adapt your TypeSpec code for the latest version.\\n\\n## Simple Scenarios\\n\\nThese examples show how to add models, operations, properties, and parameters in specific versions using TypeSpec versioning decorators.\\n\\n### Adding Decoration to an Existing Type\\n\\nThis scenario demonstrates how to change a decorator’s usage across versions.\\r\\n\\r\\nSuppose you have a model property with a decorator:\\r\\n\\r\\n```tsp\\r\\nmodel Employee {\\r\\n  @visibility(Lifecycle.Read)\\r\\n  experience: string;\\r\\n}\\r\\n```\\r\\n\\r\\nIn the next version (v2), the visibility changes so that the property can be read or created. To achieve this, you can use a combination of `@removed`, `@added`, and `@renamedFrom` decorators:\\r\\n\\r\\n```tsp\\r\\nmodel Employee {\\r\\n  @removed(Versions.v2)\\r\\n  @visibility(Lifecycle.Read)\\r\\n  @renamedFrom(Versions.v2, \\\"experience\\\")\\r\\n  oldExperience: string;\\r\\n\\r\\n  @added(Versions.v2)\\r\\n  @visibility(Lifecycle.Read, Lifecycle.Create)\\r\\n  experience: string;\\r\\n}\\r\\n```\\n\\n### Adding a Parameter to an Operation and Making Another Parameter Optional\\n\\nThis scenario shows how to add a parameter and make another optional in an operation.\\r\\n\\r\\nSuppose you start with the following operation in v1:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  listBySubscription is ArmListBySubscription\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      @header\\r\\n      location: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\nIn version `v2`, you want to:\\r\\n\\r\\n- Make the `location` header parameter optional.\\r\\n- Add a new optional query parameter `orderBy`.\\r\\n\\r\\nYou can achieve this using the `@madeOptional` and `@added` decorators:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  listBySubscription is ArmListBySubscription\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      @madeOptional(Versions.v2)\\r\\n      @header\\r\\n      location?: string;\\r\\n\\r\\n      @added(Versions.v2)\\r\\n      @query(\\\"order-by\\\")\\r\\n      orderBy?: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\n**Explanation:**\\r\\n\\r\\n- `@madeOptional(Versions.v2)` makes `location` optional starting in v2.\\r\\n- `@added(Versions.v2)` adds the `orderBy` query parameter in v2 and later.\\n\\n### Converting an Operation from Synchronous to Asynchronous\\n\\nThis scenario illustrates converting a synchronous operation to an asynchronous one across versions.\\r\\n\\r\\nSuppose you start with the following synchronous operation in `v1`:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceSync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\nIn version `v2`, you update this operation to be asynchronous as follows:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  @removed(Versions.v2)\\r\\n  @renamedFrom(Versions.v2, \\\"createOrUpdate\\\")\\r\\n  @sharedRoute\\r\\n  createOrUpdateV1 is ArmResourceCreateOrReplaceSync\\u003cEmployee\\u003e;\\r\\n\\r\\n  @added(Versions.v2)\\r\\n  @sharedRoute\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\n**Explanation:**\\r\\n\\r\\n- `@removed(Versions.v2)` removes the original synchronous operation in v2 and later.\\r\\n- `@renamedFrom(Versions.v2, \\\"createOrUpdate\\\")` keeps the original name for v1.\\r\\n- `@added(Versions.v2)` adds the new asynchronous operation in v2 and later.\\r\\n- `@sharedRoute` ensures both operations can use the same route.\\n\\n## Versioning Decorators\\n\\n### @added\\n\\nYou can add new models, properties, or operations in a specific version and all subsequent versions using the `@added` decorator.\\r\\n\\r\\n- The `version` argument is the version where the element is introduced.\\r\\n- The element will be present in that version and all later versions.\\r\\n\\r\\n**Example: Adding a model and property across versions**\\r\\n\\r\\nFor example, suppose you want to add a new model and then add a property to it in a later version:\\r\\n\\r\\n```tsp\\r\\n// v1: No Employee model exists\\r\\n\\r\\n// v2: Add Employee model\\r\\n@added(Versions.v2)\\r\\nmodel Employee {\\r\\n  name?: string;\\r\\n}\\r\\n\\r\\n// v3: Add 'city' property to Employee\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n\\r\\n  @added(Versions.v3)\\r\\n  city?: string;\\r\\n}\\r\\n```\\r\\n\\r\\n**Example: Adding an operation in a later version**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n  // v3: Add createOrUpdate operation\\r\\n  @added(Versions.v3)\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\n\\n### @removed\\n\\nTo remove models, properties, or operations starting from a specific version, use the `@removed` decorator.\\r\\n\\r\\n- The `version` argument is the version where the element is removed.\\r\\n- The element will not be present in that version or any later versions.\\r\\n\\r\\n**Example: Removing a property and a model across versions**\\r\\n\\r\\nFor example:\\r\\n\\r\\n```tsp\\r\\n// v1: Employee model with 'city' property\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n  city?: string;\\r\\n}\\r\\n\\r\\n// v2: Remove 'city' property\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n\\r\\n  @removed(Versions.v2)\\r\\n  city?: string;\\r\\n}\\r\\n\\r\\n// v3: Remove Employee model entirely\\r\\n@removed(Versions.v3)\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n}\\r\\n```\\r\\n\\r\\n**Example: Removing an operation**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n  @removed(Versions.v3)\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\n\\n### @madeRequired and @madeOptional\\n\\nUse these decorators to change whether a property is required or optional in a specific version.\\r\\n\\r\\n- Use `@madeOptional(Versions.version)` to make a property optional starting in that version.\\r\\n- Use `@madeRequired(Versions.version)` to make a property required starting in that version.\\r\\n\\r\\n**Example: Changing a property from required to optional, then back to required**\\r\\n\\r\\nFor example:\\r\\n\\r\\n```tsp\\r\\n// v1: movingStatus is required\\r\\nmodel MoveResponse {\\r\\n  movingStatus: string;\\r\\n}\\r\\n\\r\\n// v2: movingStatus becomes optional\\r\\nmodel MoveResponse {\\r\\n  @madeOptional(Versions.v2)\\r\\n  movingStatus?: string;\\r\\n}\\r\\n```\\n\\n### @renamedFrom\\n\\nUse `@renamedFrom` to rename models, properties, operations, enums, etc., in a specific version.\\r\\n\\r\\n- The `version` argument is the version where the name changed.\\r\\n- The `oldName` argument is the previous name.\\r\\n\\r\\n**Example: Renaming a property and a model across versions**\\r\\n\\r\\nFor example:\\r\\n\\r\\n```tsp\\r\\n// v1: Model and property have original names\\r\\nmodel WorkerProperties {\\r\\n  state?: string;\\r\\n}\\r\\n\\r\\n// v2: Rename property 'state' to 'city'\\r\\nmodel WorkerProperties {\\r\\n  @renamedFrom(Versions.v2, \\\"state\\\")\\r\\n  city?: string;\\r\\n}\\r\\n\\r\\n// v3: Rename model 'WorkerProperties' to 'EmployeeProperties'\\r\\n@renamedFrom(Versions.v3, \\\"WorkerProperties\\\")\\r\\nmodel EmployeeProperties {\\r\\n  @renamedFrom(Versions.v2, \\\"state\\\")\\r\\n  city?: string;\\r\\n}\\r\\n```\\n\\n## FAQ\\n\\n### How do I version a pattern?\\n\\nI have this model and I would like to change the pattern in v2\\r\\n\\r\\n```tsp\\r\\nmodel EmployeeProperties {\\r\\n  @pattern(\\\"^[a-z]+$\\\")\\r\\n  state: string;\\r\\n}\\r\\n```\\r\\n\\r\\n:::caution\\r\\n\\r\\nUpdating a pattern could be a breaking change:\\r\\n\\r\\n- A **more restrictive pattern** for input data would break existing clients that send previously valid data\\r\\n- A **less restrictive pattern** for output data could break client assumptions and validation logic\\r\\n\\r\\n:::\\r\\n\\r\\nThe key question is: **Does the pattern change apply to all API versions, or only to the new version?**\\r\\n\\r\\n#### 1. Pattern changes for all versions\\r\\n\\r\\nIf the pattern change reflects how your service actually behaves across all versions, update the pattern directly. The specification should accurately reflect the current state of your service.\\r\\n\\r\\n```diff lang=tsp\\r\\nmodel EmployeeProperties {\\r\\n-  @pattern(\\\"^[a-z]+$\\\")\\r\\n+  @pattern(\\\"^[a-zA-Z]+$\\\")\\r\\n   state: string;\\r\\n}\\r\\n```\\r\\n\\r\\n:::note\\r\\nThis will update all openapi specs versions with the new pattern which is the desired behavior.\\r\\n:::\\r\\n\\r\\n#### 2. Different patterns per version (**Very unlikely**)\\r\\n\\r\\nIf older API versions truly enforce a different pattern than newer versions, you need to model this explicitly using versioning decorators:\\r\\n\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_03.md\",\"document_title\":\"Avocado error after @renamedFrom on custom action route\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_03.md\\n\\n# Avocado error after @renamedFrom on custom action route\\n\\n## question\\n\\nFor PR [Add Microsoft.Mission version 2025-05-01-preview - Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/22581) I was asked to consider renaming routes for some custom actions to meet naming conventions. For example, I now have this in my routes:\\r\\n```\\r\\n@doc(\\\"Community Endpoint Interface\\\")\\r\\n@armResourceOperations\\r\\ninterface CommunityEndpoints {\\r\\n  @doc(\\\"Callback that triggers on approval state change.\\\")\\r\\n  @armResourceAction(CommunityEndpointResource)\\r\\n  @added(Microsoft.Mission.Versions.v2024_12_01_preview)\\r\\n  @renamedFrom(\\r\\n    Microsoft.Mission.Versions.v2025_05_01_preview,\\r\\n    \\\"approvalCallback\\\"\\r\\n  )\\r\\n  notifyOnApprovalCreation is ArmResourceActionAsync\\u003c\\r\\n    CommunityEndpointResource,\\r\\n    ApprovalCallbackRequest,\\r\\n    ApprovalActionResponse\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\nThis unfortunately now produces Avocado errors for [MISSING_APIS_IN_DEFAULT_TAG](https://github.com/Azure/avocado/blob/master/README.md#MISSING_APIS_IN_DEFAULT_TAG) , \\r\\n\\r\\nThe default tag should contain all APIs. The API path \\r\\n```\\r\\n/subscriptions/{}/resourcegroups/{}/providers/microsoft.mission/virtualenclaves/{}/enclaveendpoints/{}/approvalcallback\\r\\n```\\r\\nis not in the default tag. Please make sure the missing API swaggers are in the default tag.\\r\\nreadme: [specification/mission/resource-manager/readme.md](https://github.com/Azure/azure-rest-api-specs-pr/blob/589a07c8dcfe05714c746dcaf2052da06ae6ad74/specification/mission/resource-manager/readme.md)\\r\\njson: [Microsoft.Mission/preview/2024-12-01-preview/openapi.json](https://github.com/Azure/azure-rest-api-specs-pr/blob/589a07c8dcfe05714c746dcaf2052da06ae6ad74/specification/mission/resource-manager/Microsoft.Mission/preview/2024-12-01-preview/openapi.json)\\r\\n\\r\\nIs there something that I need to do differently to define this route renaming?\\r\\n \\r\\nLink to [Avocado check](https://github.com/Azure/azure-rest-api-specs-pr/pull/22581/checks?check_run_id=45066798540). Thanks!\\n\\n## answer\\n\\nAvocado doesn't handle moves/renames.  You can suppress by adding label `Approved-Avocado`.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_21.md\",\"document_title\":\"TypeSpec: How can I change only descriptions/comments between versions while keeping models identical?\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_21.md\\n\\n# TypeSpec: How can I change only descriptions/comments between versions while keeping models identical?\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\n \\r\\nWhat’s the recommended way to change only the documentation (description/comments) between API versions while keeping all properties and models the same?\\r\\nFrom what I understand, versioning decorators don’t apply to descriptions/comments, so doc changes propagate to all emitted JSON/OpenAPI versions. I tried versioning a property by removing and re-adding it with an updated comment, but the compiler fails with:\\r\\n`Model already has a property named 'sku'`\\r\\nAttempted snippet (simplified):\\r\\n \\r\\nmodel CapacityReservationUpdate extends UpdateResource {\\r\\n  /**\\r\\n   * Properties of the Capacity reservation.\\r\\n   */\\r\\n  #suppress \\\"@azure-tools/typespec-azure-core/no-private-usage\\\" \\\"For backward compatibility\\\"\\r\\n  @Azure.ResourceManager.Private.conditionalClientFlatten\\r\\n  properties?: CapacityReservationProperties;\\r\\n \\r\\n  /**\\r\\n   * OLD description...\\r\\n   */\\r\\n  @removed(Versions.v2025_04_01)\\r\\n  sku?: Sku;\\r\\n \\r\\n  /**\\r\\n   * NEW description for v2025_04_01...\\r\\n   */\\r\\n  @added(Versions.v2025_04_01)\\r\\n  sku?: Sku;\\r\\n}\\r\\n \\r\\nQuestion:\\r\\nIs there a supported approach to have version-specific descriptions (model-level or property-level) without duplicating and renaming the model/property? If not, what’s the best-practice pattern to achieve doc-only differences while keeping the wire shape unchanged?\\r\\nContext:\\r\\nGoal: same schema and property names across versions; only descriptions/comments differ.\\r\\nError seen: `Model already has a property named 'sku'`.\\r\\nThanks in advance for any guidance!\\n\\n## answer\\n\\nDocumentation changes that improve the documentation should be made without regard to versioning.  Any listed breaking changes in ci checks that are only related to documentation will be easily accepted.  Documentation changes also do not trigger releases of new SDKs.\\n\\nDocumentation changes that improve the documentation should be made without regard to versioning.  Any listed breaking changes in ci checks that are only related to documentation will be easily accepted.  Documentation changes also do not trigger releases of new SDKs.\\r\\n \\r\\nIt is almost always possible to make versioned changes (for example, using the add/remove/rename pattern [like this](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D\\u0026c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCv8Axf8Axf8Axf8Axf8AxfgAxTTxAMV95gG4QegBuusB0yDoAvXkAMhtb2RlbCBFbXBsb3llZSBpcyBUcmFja2Vk6ACCPMgcUHJvcGVydGllcz7lAekuLukApuQCm1BhcmFtZXRlcskxPjvoAIbJX3DJRNJ8ymDpAkhBZ2Ugb2YgZcg%2Fd2l0aCB1cGRhdGVkIGRvY8VG5AFKZGTrAtsu9AES5AEqYWdlPzogaW50MzI76AHm0GPGUXJl5AMeZEZyb23eVywgImFnZSLEXkByZW1vdv8AiOgAiE9sZPEAi0NpdHnyAIxjaXR5Pzogc3Ry5QRzxyxQcm9maWz0ALtlbmNvZGUoImJhc2U2NHVybOUAnXDGMD86IGJ5dGVzyUhUaGUgc3RhdHVzxEt0aGUgbGFzdCDkAYphdGlvbuUEhiAgQHZpc2liaWxpdHkoTGlmZWN5Y2zkAqVhZMddxCDlBRVTdGF0xGflAnDMFOkCDcRzzDLlAIDlAMph6QKaxXdAbHJvxDt1cwp1buQDd9FU5QIp5gEa6QO3xF%2FIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXDkAkXlAN5Bxw46ICLICyLWUGnEQOQAtOkAwchE7ACcOiAizA%2FaTOUCy8RPxUNVxw46ICLIC8o76QYv6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBofHC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QTC6QQ85ANd6QHK6QQ%\\n\\nDocumentation changes that improve the documentation should be made without regard to versioning.  Any listed breaking changes in ci checks that are only related to documentation will be easily accepted.  Documentation changes also do not trigger releases of new SDKs.\\r\\n \\r\\nIt is almost always possible to make versioned changes (for example, using the add/remove/rename pattern [like\\n\\nxjaXR5Pzogc3Ry5QRzxyxQcm9maWz0ALtlbmNvZGUoImJhc2U2NHVybOUAnXDGMD86IGJ5dGVzyUhUaGUgc3RhdHVzxEt0aGUgbGFzdCDkAYphdGlvbuUEhiAgQHZpc2liaWxpdHkoTGlmZWN5Y2zkAqVhZMddxCDlBRVTdGF0xGflAnDMFOkCDcRzzDLlAIDlAMph6QKaxXdAbHJvxDt1cwp1buQDd9FU5QIp5gEa6QO3xF%2FIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXDkAkXlAN5Bxw46ICLICyLWUGnEQOQAtOkAwchE7ACcOiAizA%2FaTOUCy8RPxUNVxw46ICLIC8o76QYv6QDE5gDcZOcBolN1Y2NlZWTlAMXJDNM%2FxTbkAU1mYWlsyT5GxQ06ICLGCdw4d2FzIGNhbmNlyj5Dxw%2FkBofHC%2F8BQCBkZWxl6QGARMQN5gD5yAsi6QTC6QQ85ANd6QHK6QQ%2BTW92ZVLHFegEN8RzbW92xGhmcm9tIGxvY%2BYAvMVuxBPxA1DLM3RvzzF0b8ov9wCVc3BvbnPrBVDmAJbHFuwAl%2B4DbMU%2BxWTGfOYC7s1uaW50ZXJm5AemT%2BgDlHMgZXh0ZW5kc%2FYIaC7LKXt9CuUIRMgjyhvLWegAzeYFeGdldOQBp0HKNeQD5%2BwF1SDnAntPcuUCp%2BUB1ssvQ8cdUmVwbGFjZUFzeW5jzj%2FmBcLHN0N1c3RvbVBhdGNoU8QqCiAgIOkAkyzFDvYA50ZvdW7kAybkBWrIHOYAkU3kAYTGSdBLyhDqBm%2FFGT4KICDlAJ3mAprvANTlApdlV2l0aG91dE9r8wDUbGlzdEJ5yDBHcm91cM9ETMUiUGFyZW501DxTdWJzY3JpcOUCecY7xjPMGcw56AbCIHNhbXBs6wNmYWPFRHRoYXTmAmPpBiN0byBkaWZmZeQAhO8C5sUp7gCyQcVI5QGWyHcs7ANxyA3mAujzAJJIRUFE6gZMxH5jaGVja%2BoAqmV4aXN0ZW7mCIsgxh5FyRTvAljNHe4IZg%3D%3D\\u0026e=%40azure-tools%2Ftypespec-autorest\\u0026vs=%7B%7D)), however this is not advised for documentation changes - documentation changes should be made regardless of versioning.\\r\\n```\\r\\n/** Employee properties */\\r\\nmodel EmployeeProperties {\\r\\n  /** Age of employee with updated docs */\\r\\n  @added(Versions.`2024-10-01-preview`)\\r\\n  age?: int32;\\r\\n\\r\\n  /** Age of employee */\\r\\n  @renamedFrom(Versions.`2024-10-01-preview`, \\\"age\\\")\\r\\n  @removed(Versions.`2024-10-01-preview`)\\r\\n  ageOld?: int32;\\r\\n\\r\\n  /** City of employee */\\r\\n  city?: string;\\r\\n\\r\\n  /** Profile of employee */\\r\\n  @encode(\\\"base64url\\\")\\r\\n  profile?: bytes;\\r\\n\\r\\n  /** The status of the last operation. */\\r\\n  @visibility(Lifecycle.Read)\\r\\n  provisioningState?: ProvisioningState;\\r\\n}\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_14.md\",\"document_title\":\"Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_14.md\\n\\n# Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221\\n\\n## question\\n\\nHi I'm looking for someone to help suppress CI Failure on this PR [new addProxyAgentExtension property for proxyagentsettings by huiminyan2017 · Pull Request #36221 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/36221)\\r\\n \\r\\nCompute has multiple API versions so the Avacado check failure is expected.\\n\\n## answer\\n\\nYour PR is to a feature branch, so no checks are required.\\r\\n \\r\\nHowever, your PR may be blocked when you try to merge to main, so I recommend following the instructions here now:\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#multiple_api_version\\r\\n```\\r\\nMULTIPLE_API_VERSION\\r\\nRule MULTIPLE_API_VERSION was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this Uniform Versioning Violation Guide wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Description changes across versions?\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Description changes across versions?\\n\\n## question\\n\\nHi, as part of this PR: [Service Fabric Managed Clusters - API version 2025-03-01-preview · Azure/azure-rest-api-specs@599e269](https://github.com/Azure/azure-rest-api-specs/actions/runs/14090043123/job/39464153437?pr=33332)\\r\\nMy team wanted to add more details to a model description. This change results in a change in all spec versions generated with Typespec, and causes the Typespec validation to fail if I don't include the changes to the older specs.  \\r\\nI wanted to know what the best course of action was for passing this check. Since we don't expect updates to our older specs, is it ok to just change the output path in our tspconfig.yaml to only point at the current version of the output spec? Or is there a better way to handle this?\\n\\n## answer\\n\\nHonestly, the best thing is to update your docs and take the update in previous versions (which are likely now more accurately described as well). Documentation-only updates should not be flagged as breaking changes at all. If they are for some reason, I'll just approve it.\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-08-07.md\",\"document_title\":\"Additional \\\"consumes\\\": [  \\\"text/plain\\\"  ], in operation\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-08-07.md\\n\\n# Additional \\\"consumes\\\": [  \\\"text/plain\\\"  ], in operation\\n\\n## question\\n\\n```\\r\\n\\\"consumes\\\": [\\r\\n    \\\"text/plain\\\"\\r\\n],\\r\\n```\\n\\n## answer\\n\\n```\\r\\n{\\r\\n    \\\"name\\\": \\\"body\\\",\\r\\n    \\\"in\\\": \\\"body\\\",\\r\\n    \\\"schema\\\": {\\r\\n        \\\"$ref\\\": \\\"#/definitions/email\\\"\\r\\n    }\\r\\n}\\r\\n```\\r\\nBecause TypeSpec wants to reproduce this part of the content from the original swagger, but once the parameter in body is a basic type (string, int32, scalar, etc.), it will cause this extra part to appear. The TypeSpec code is as follows\\r\\n```\\r\\n@action(\\\"listConnectedPartnerResources\\\")\\r\\nlist is ArmResourceActionSync\\u003c\\r\\n    NewRelicMonitorResource,\\r\\n    {\\r\\n        /**\\r\\n         * Email Id of the user\\r\\n         */\\r\\n        @bodyRoot\\r\\n        body?: email;\\r\\n    },\\r\\n    ArmResponse\\u003cConnectedPartnerResourcesListResponse\\u003e\\r\\n\\u003e;\\r\\n}\\r\\n```\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-07-17.md\",\"document_title\":\"readonly: true at the root of model.\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-07-17.md\\n\\n# readonly: true at the root of model.\\n\\n## question\\n\\nproperty readonly: true lives at the root of model like the screenshot as below:\\r\\n```\\r\\n  \\\"WebApplicationFirewallComponentVersions\\\": {\\r\\n    \\\"type\\\": \\\"object\\\",\\r\\n    \\\"readOnly\\\": true,\\r\\n    \\\"required\\\": [\\r\\n      \\\"wafEngineVersion\\\",\\r\\n      \\\"wafNginxVersion\\\"\\r\\n    ],\\r\\n    \\\"description\\\": \\\"Versions of the NGINX App Protect Web Application Firewall (WAF) components.\\\",\\r\\n    \\\"properties\\\": {\\r\\n      \\\"wafEngineVersion\\\": {\\r\\n        \\\"type\\\": \\\"string\\\",\\r\\n        \\\"example\\\": \\\"10.624.0\\\",\\r\\n        \\\"description\\\": \\\"The version of the NGINX App Protect Web Application Firewall (WAF) engine.\\\"\\r\\n      },\\r\\n      \\\"wafNginxVersion\\\": {\\r\\n        \\\"type\\\": \\\"string\\\",\\r\\n        \\\"example\\\": \\\"4.815.0\\\",\\r\\n        \\\"description\\\": \\\"The version of the NGINX App Protect Web Application Firewall (WAF) module for NGINX.\\\"\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n```\\n\\n## answer\\n\\nfind all the references from this model, and make sure if it's readonly\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-09-12.md\",\"document_title\":\"missing externalDocs\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-09-12.md\\n\\n# missing externalDocs\\n\\n## question\\n\\nhow to resolve missing externalDocs?\\n\\n## answer\\n\\n*.tsp files:\\r\\nAdded @externalDocs decorators to multiple interfaces and operations such as\\r\\n```diff\\r\\n+   @externalDocs(\\\"https://docs.microsoft.com/en-us/rest/api/consumption/\\\")\\r\\n    get is Extension.Read\\u003cExtension.ScopeParameter, Budget\\u003e;\\r\\n```\\r\\ngenerated openapi.json file:\\r\\n```diff\\r\\n          \\\"description\\\": \\\"Gets the budget for the scope by budget name.\\\",\\r\\n+         \\\"externalDocs\\\": {\\r\\n+           \\\"url\\\": \\\"https://docs.microsoft.com/en-us/rest/api/consumption/\\\"\\r\\n+         },\\r\\n```\"},{\"document_source\":\"static_typespec_to_swagger_mapping\",\"document_filename\":\"TypeSpec-ARM.Foundations-Models-Documentation.md\",\"document_title\":\"TypeSpec Azure.ResourceManager.Foundations Models Mapping to Swagger Documentation\",\"document_link\":\"\",\"content\":\"# TypeSpec-ARM.Foundations-Models-Documentation.md\\n\\n# TypeSpec Azure.ResourceManager.Foundations Models Mapping to Swagger Documentation\\n\\n## 15. TagsUpdateModel\\n\\n### Description\\n\\nThe type used for updating tags in resources. This model provides a standardized way to update only the tags of a resource without affecting other properties.\\n\\n### TypeSpec Example\\n\\n```typespec\\r\\n// Direct usage of Foundations.TagsUpdateModel\\u003cT\\u003e for tag-only updates\\r\\nmodel TrackedTestResource is TrackedResource\\u003cTestProperties\\u003e {\\r\\n  ...ResourceNameParameter\\u003cTrackedTestResource\\u003e;\\r\\n}\\r\\n\\r\\n// Using TagsUpdateModel to create a model for tag-only updates\\r\\nmodel TagsOnlyUpdate is Foundations.TagsUpdateModel\\u003cTrackedTestResource\\u003e {}\\r\\n\\r\\n@armResourceOperations\\r\\ninterface TrackedTestResourceOperations {\\r\\n  get is ArmResourceRead\\u003cTrackedTestResource\\u003e;\\r\\n  // Can be used with ArmTagsPatchSync for tag-only updates\\r\\n  // Note: ArmTagsPatchSync has known body parameter conflict issues\\r\\n  // updateTags is ArmTagsPatchSync\\u003cTrackedTestResource, TagsOnlyUpdate\\u003e;\\r\\n}\\r\\n```\\n\\n### Swagger Output\\n\\n```json\\r\\n{\\r\\n  \\\"TagsOnlyUpdate\\\": {\\r\\n    \\\"type\\\": \\\"object\\\",\\r\\n    \\\"description\\\": \\\"The type used for updating tags in TrackedTestResource resources.\\\",\\r\\n    \\\"properties\\\": {\\r\\n      \\\"tags\\\": {\\r\\n        \\\"type\\\": \\\"object\\\",\\r\\n        \\\"description\\\": \\\"Resource tags.\\\",\\r\\n        \\\"additionalProperties\\\": {\\r\\n          \\\"type\\\": \\\"string\\\"\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n**Note:** TagsUpdateModel contains only the `tags` field, allowing updates to resource tags without modifying other properties. This is commonly used with PATCH operations for tag-only updates. Note: There may be body parameter conflict issues when using ArmTagsPatchSync operation template.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#generate-with-tsp-client#local_spec_quickstart.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/local_spec_quickstart\",\"content\":\"# Quick Start\\n### Generate a client library from local changes\\n1. Go to local `azure-rest-api-specs` clone.\\r\\n2. Create/Modify the TypeSpec project.\\r\\n3. Switch to the language repository clone you want to generate a client library in. Example:\\r\\n\\r\\n```bash\\r\\ncd \\u003c path to \\u003e /azure-sdk-for-python\\r\\n```\\r\\n\\r\\n4. From the root of the repository run the following command:\\r\\n\\r\\n```bash\\r\\nazure-sdk-for-python\\u003e tsp-client init -c \\u003cpath to local typespec project at tspconfig.yaml level\\u003e\\r\\n```\\r\\n\\r\\nExample:\\r\\n\\r\\n```bash\\r\\nazure-sdk-for-python \\u003e tsp-client init -c ../azure-rest-api-specs/specification/contosowidgetmanager/Contoso.WidgetManager/\\r\\n```\\r\\n\\r\\n:::info\\r\\nTo get familiar with `tsp-client` and supported commands, see [tsp-client usage](https://aka.ms/azsdk/tsp-client).\\r\\n:::\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"API-Spec-Review-FAQ.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ\",\"content\":\"ARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this. See documentation: [Update your branch with changes from main](https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish#update-your-branch-with-changes-from-main). |\\r\\n| I need to set up suppressions for LintDiff violations in my PR | See [Adding Scoped Suppressions](https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff) | \\r\\n| I have specific questions about the inner workings of ARM, testing changes to APIs, or rollout/release schedules | Talk to the ARM team: https://aka.ms/armofficehoursinfo |\\r\\n| I see an Avocado error `MULTIPLE_API_VERSION` | There is a coordinated effort to fix this. Reach out to the relevant parties. [This PR](https://github.com/Azure/avocado/pull/157) gives more context on why this was upgraded to an error. If relevant parties agree, the PR can be unblocked by adding the `Approved-Avocado` label to the PR. |\\r\\n| I merged a PR, when does the REST API documentation update on the Learn site? | Docs are published every week on Tuesdays | \\r\\n| If the specs in the standard branches of `RPSaaSMaster` and `RPSaaSDev` are out of sync, who is responsible for syncing them with main? | The spec owner is responsible for syncing their service’s spec files from `main` to `RPSaaSMaster/RPSaaSDev` to ensure consistency across branches. |\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#generate-client-libraries#10versioning.mdx\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/10versioning\",\"content\":\"# Versioning\\n## Multiple api versions\\n### Default\\nBy default our emitters will only generate the surface used by the latest api version if there are multiple defined. This includes generating only the models used in the surface area of the latest api version.\\r\\nDocumentation and enums showing the available api versions will still include all of the known api versions, meaning there will be documentation for both the preview and stable releases.\\r\\nFor the below example, all languages will generate the api surface of default version `v2023_11_01`. There will be no generation of the operation `previewFunctionality`, and we will also not generate the `PreviewModel` because it's only used in `previewFunctionality`, and therefore is not used in the api surface of `v2023_11_01`.\\r\\n\\u003cClientTabs\\u003e\\r\\n```typespec\\r\\nimport \\\"@typespec/versioning\\\";\\r\\nimport \\\"@typespec/http\\\";\\r\\n\\r\\nusing Versioning;\\r\\nusing Http;\\r\\n\\r\\n@versioned(My.Service.Versions)\\r\\n@service\\r\\nnamespace My.Service;\\r\\n\\r\\nenum Versions {\\r\\n  v2023_11_01_preview: \\\"2023-11-01-preview\\\",\\r\\n  v2023_11_02: \\\"2023-11-02\\\",\\r\\n}\\r\\n\\r\\nmodel PreviewModel {\\r\\n  betaFeature: string;\\r\\n}\\r\\n\\r\\nmodel StableModel {\\r\\n  stableFeature: string;\\r\\n}\\r\\n\\r\\n@added(Versions.v2023_11_01_preview)\\r\\n@removed(Versions.v2023_11_02)\\r\\n@route(\\\"/preview\\\")\\r\\nop previewFunctionality(@body previewModel: PreviewModel): void;\\r\\n\\r\\n@route(\\\"/stable\\\")\\r\\nop stableFunctionality(@body stableModel: StableModel): void;\\r\\n```\\r\\n```python\\r\\nimport pytest\\r\\nfrom my.service import MyServiceClient, models\\r\\n\\r\\nclient = MyServiceClient(endpoint=..., credential=...)\\r\\n# client's api_version will be \\\"2023-11-02\\\"\\r\\n\\r\\nstable_model = models.StableModel(stable_feature=\\\"present\\\")\\r\\nprint(stable_model)\\r\\nclient.stable_functionality(stable_model) # call goes through\\r\\n\\r\\nwith pytest.expect(ImportError):\\r\\n  preview_model = models.PreviewModel(preview_functionality=\\\"not present\\\")\\r\\n\\r\\nwith pytest.expect(AttributeError):\\r\\n  client.preview_functionality({\\\"previewFunctionality\\\": \\\"not present\\\"})\\r\\n```\\r\\n```csharp\\r\\n//ServiceVersion enum\\r\\npublic enum ServiceVersion\\r\\n{\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"intro.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/intro\",\"content\":\"# Introduction\\nTypeSpec is a language for describing cloud service APIs and generating other API description languages, client and service code, documentation, and other assets. TypeSpec provides highly extensible core language primitives that can describe API shapes common among REST, GraphQL, gRPC, and other protocols.\\r\\n\\r\\nYou can find more information at https://typespec.io/docs.\\r\\n\\r\\nThis site is focused on using TypeSpec in the context of Azure. We have published a set of libraries with standard patterns and templates to make defining Azure management and data-plane services easy and compliant with Azure API guidelines. Using these building blocks\\r\\nand guard rails, your service API will be easier to build, will have an easier time passing API reviews, will be consistent with other Azure\\r\\nservices, and will produce good API documentation, good SDKs, and good CLIs.\\r\\nTypeSpec can emit the following artifacts for your service:\\r\\n\\r\\n- OpenAPI3 specs\\r\\n- OpenAPI2 specs, suitable for check-in in to the azure-rest-api-specs repo\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"standard-library#built-in-decorators.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/standard-library/built-in-decorators\",\"content\":\"# Built-in Decorators\\n## TypeSpec\\n### `@returnsDoc` {#@returnsDoc}\\nAttach a documentation string to describe the successful return types of an operation.\\r\\nIf an operation returns a union of success and errors it only describes the success. See `@errorsDoc` for error documentation.\\r\\n```typespec\\r\\n@returnsDoc(doc: valueof string)\\r\\n```\\r\\n#### Target\\r\\n`Operation`\\r\\n#### Parameters\\r\\n| Name | Type | Description |\\r\\n|------|------|-------------|\\r\\n| doc | [valueof `string`](#string) | Documentation string |\\r\\n#### Examples\\r\\n```typespec\\r\\n@returnsDoc(\\\"Returns doc\\\")\\r\\nop get(): Pet | NotFound;\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"standard-library#built-in-decorators.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/standard-library/built-in-decorators\",\"content\":\"# Built-in Decorators\\n## TypeSpec\\n### `@errorsDoc` {#@errorsDoc}\\nAttach a documentation string to describe the error return types of an operation.\\r\\nIf an operation returns a union of success and errors it only describes the errors. See `@returnsDoc` for success documentation.\\r\\n```typespec\\r\\n@errorsDoc(doc: valueof string)\\r\\n```\\r\\n#### Target\\r\\n`Operation`\\r\\n#### Parameters\\r\\n| Name | Type | Description |\\r\\n|------|------|-------------|\\r\\n| doc | [valueof `string`](#string) | Documentation string |\\r\\n#### Examples\\r\\n```typespec\\r\\n@errorsDoc(\\\"Errors doc\\\")\\r\\nop get(): Pet | NotFound;\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#reproducibility.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/handbook/reproducibility\",\"content\":\"# Reproducibility\\nA crucial aspect of service definition is ensuring consistent output over time. This is important in scenarios such as:\\r\\n\\r\\n- An update to a dependency or sub-dependency introduces an unexpected breaking change.\\r\\n- Updates to a new version of a service should not impact older versions.\\r\\n- Modifications are made to the TypeSpec specification.\\r\\n\\r\\nThese issues can be mitigated with a few precautionary measures:\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#reproducibility.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/handbook/reproducibility\",\"content\":\"# Reproducibility\\n## 2. Work with multiple versions of a service\\nTypeSpec provides a library `@typespec/versioning` that can be used to describe changes to a service or library over time. Using this will ensure that a service can evolve while keeping track of the changes and allowing emitters to see the service representation at different versions.\\r\\n\\r\\n[See versioning docs](../libraries/versioning/reference/index.mdx)\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#getting-started-rest#08-conclusion.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/getting-started/getting-started-rest/08-conclusion\",\"content\":\"# Conclusion\\n## Feedback and Community Engagement\\nWe value your feedback and would love to hear about your experiences with this tutorial. Please feel free to share your thoughts and suggestions in our [GitHub discussions channel](https://github.com/microsoft/typespec/discussions).\\r\\n\\r\\nJoin the TypeSpec community on [Discord](https://aka.ms/typespec/discord) to engage with other developers, ask questions, and contribute to discussions. Your participation helps us improve and grow the TypeSpec ecosystem.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"language-basics#documentation.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/language-basics/documentation\",\"content\":\"# Documentation\\n## Markdown\\nTypeSpec Documentation support CommonMark markdown formatting. The tooling(IDE extensions, doc generation, etc.) will process the documentation as markdown.\\r\\nEmitters can choose to render the description as it is, convert it to their preferred format or just strip any markdown information.\\r\\n\\r\\n````tsp\\r\\n@doc(\\\"This is a **bold** text\\\")\\r\\nmodel Dog {\\r\\n  @doc(\\\"This is a _italic_ text\\\")\\r\\n  name: string;\\r\\n\\r\\n  /**\\r\\n   * This contains a bullet list\\r\\n   * - one\\r\\n   * - two\\r\\n   * and code blocks\\r\\n   *\\r\\n   * ```typescript\\r\\n   * dog.age = 5;\\r\\n   * ```\\r\\n   */\\r\\n  age: int32;\\r\\n}\\r\\n````\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"introduction#installation.mdx\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/introduction/installation\",\"content\":\"# Installation\\n## Create a new TypeSpec project\\ntypically contains the main definitions for your models, services, and operations.\\r\\n- **tspconfig.yaml**: Configuration file for the TypeSpec compiler, specifying options and settings for the build process.\\r\\n- **package.json**: Contains metadata about the project, including dependencies, scripts, and other project-related information.\\r\\n- **node_modules/**: Directory where npm installs the project's dependencies.\\r\\n- **tsp-output/**: Directory where the TypeSpec compiler outputs generated files.\\r\\n- **openapi.yaml**: The generated OpenAPI specification file for your API, detailing the API's endpoints, models, and operations. The output can vary based on the target format specified in the `tspconfig.yaml` file.\\r\\n\\r\\nYou can also run `tsp compile . --watch` to automatically compile changes on save.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\n## MULTIPLE_API_VERSION\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\"},{\"document_source\":\"typespec_http_specs\",\"document_filename\":\"versioning#added#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/versioning/added/main.tsp\",\"content\":\"# Usages for Test for the `@added` decorator.\\n## Scenario: This operation should be generated with latest version's signature.\\n``` typespec\\r\\n@route(\\\"/v1\\\")\\r\\n@post\\r\\nop v1(@body body: ModelV1, @added(Versions.v2) @header headerV2: string): ModelV1;\\r\\n```\\r\\n\\r\\n## Scenario: This operation should only be generated with latest version.\\r\\n\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"# Convert OpenAPI specs to TypeSpec\\nThis document outlines the process for converting OpenAPI specifications to TypeSpec, detailing the responsibilities of\\r\\nboth the service team and the Azure SDK team.\"}]", "inputs.latency": 849.6926505565643, "inputs.response_length": 2677, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado", "https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec", "https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ"], "inputs.testcase": "doc only update?", "outputs.similarity.similarity": 4.0, "outputs.similarity.gpt_similarity": 4.0, "outputs.similarity.similarity_result": "pass", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1694, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1695, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: doc only update?\\\\n\\\\nquestion: Hey team,\\\\nI'm a PM on the VMSS team. I'm trying to understand the new Typespec way to do a documentation only update to swagger? In this case, I just want to update these doc strings to remove/modify the preview notes. I believe I updated the correct text in the models.tsp files. The swagger compiled correctly. Now my questions:\\\\nI want this to be updated in current documentation posted online, as well as SDK docs. How do I submit this change against main or the latest feature branch? Do I need to do additional work to make sure this change is propagated through to SDKs?\\\\nWhen I submitted the PR, got this error. Not sure how to fix: \\\\\\\"The default tag contains multiple API versions swaggers.\\\\\\\"\\\\nThe PR for reference:\\\\n[VMSS prioritizeunhealthyvm and force delete doc update by fitzgeraldsteele \\\\u00b7 Pull Request #25785 ](https://github.com/Azure/azure-rest-api-specs-pr/pull/25785)\\\", \\\"response\\\": \\\"You are following the correct process for a documentation-only update in TypeSpec: update the doc strings in your .tsp files, compile to OpenAPI, and submit a PR. Documentation changes (such as removing or modifying preview notes) should be made directly in TypeSpec, and these changes will propagate to both the published REST API docs and the generated SDK docs after merging.\\\\n\\\\n**How to submit the change:**\\\\n- You should submit your PR against the `main` branch of `azure-rest-api-specs` (or the corresponding service release branch if your team uses a protected/release branch workflow).\\\\n- No additional work is required to propagate documentation-only changes to SDKs: as long as your PR merges, the next weekly docs and SDK refresh will pick up the change automatically. Documentation-only changes do not trigger breaking changes or require versioning decorators.\\\\n\\\\n**About the error: \\\\\\\"The default tag contains multiple API versions swaggers\\\\\\\":**\\\\n- This is the Avocado `MULTIPLE_API_VERSION` error. It means that your default tag includes multiple API version OpenAPI files, which is now a merge blocker since July 2025 (see references).\\\\n- To resolve this, you must ensure that only one API version OpenAPI file is included in the default tag in your service's `readme.md`. This is a coordinated Azure-wide effort to enforce uniform versioning and unblock TypeSpec migration. See [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) for details.\\\\n\\\\n**Recommended steps to fix:**\\\\n1. In your service's `readme.md`, make sure the `input-file` for the default tag only points to a single OpenAPI version file (the latest or the one you want to update). Remove older versions from the default tag.\\\\n2. If your service must support multiple versions in the default tag for a valid reason, you need to request a one-time suppression from the Azure versioning team (azversioning@service.microsoft.com), or temporarily add the `Approved-Avocado` label to your PR if instructed by the team (see references below).\\\\n3. Once the PR merges, your documentation change will be reflected in both the public API docs and the SDK docs at the next scheduled refresh (usually weekly).\\\\n\\\\n**Summary:**\\\\n- Update doc strings in TypeSpec, compile, and submit PR to main.\\\\n- Ensure only one API version is present in the default tag in readme.md.\\\\n- No special versioning or additional work is needed for documentation-only changes.\\\\n- If blocked by Avocado error, follow the Uniform Versioning Violation Guide or contact the versioning team for help.\\\\n\\\\nLet me know if you need help editing your readme.md or resolving the Avocado error.\\\\n\\\", \\\"ground_truth\\\": \\\"Swagger and TSP must always match.  So the same PR, but to public/main instead of private/main.The error from \\\\\\\"Swagger Avocado\\\\\\\" is an existing problem in your spec, that should be fixed eventually.  See this run from a previous PR to your spec.\\\\nhttps://github.com/Azure/azure-rest-api-specs/actions/runs/18538687430\\\\nDocs:\\\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#multiple_api_version\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"}, {"inputs.query": "title: Do ARM SDKs support OData filtering like the APIs do?\n\nquestion: For list operations in our resource provider, we know we can perform filtering, sorting and searching using query parameters ($filter, $sort, $search) in our  API calls, and we've implemented the backend support for these queries already.\nIs it possible to do the same sort of server side filtering (or generally add logic to include query parameters with certain calls) with our Azure SDKs as well?", "inputs.ground_truth": "ARM SDKs do support OData‑style query parameters (such as filter, orderby, search, top, skip, select, and expand), but only if your API spec explicitly defines them using TypeSpec or OpenAPI models like Azure.Core.FilterQueryParameter and OrderByQueryParameter. The SDKs don’t add these automatically or treat them specially—they simply expose whatever query parameters your spec declares, following Azure API Guidelines (camelCase names, not $filter). Both C# and Python treat these as normal query parameters, and paging behaviors reinject parameters as needed. In short: define the parameters in your spec, and the SDKs will fully support them.\nhere is an example of the paging pattern in C#\n```\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n// <auto-generated/>\nusing System;\nusing System.ClientModel.Primitives;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Azure;\nusing Azure.Core;\nusing Azure.Core.Pipeline;\nnamespace Azure.Analytics.OnlineExperimentation\n{\ninternal partial class OnlineExperimentationClientGetMetricsAsyncCollectionResult : AsyncPageable<BinaryData>\n{\nprivate readonly OnlineExperimentationClient _client;\nprivate readonly int? _top;\nprivate readonly int? _skip;\nprivate readonly int? _maxpagesize;\nprivate readonly RequestContext _context;\n/// <summary> Initializes a new instance of OnlineExperimentationClientGetMetricsAsyncCollectionResult, which is used to iterate over the pages of a collection. </summary>\n/// <param name=\"client\"> The OnlineExperimentationClient client used to send requests. </param>\n/// <param name=\"top\"> The number of result items to return. </param>\n/// <param name=\"skip\"> The number of result items to skip. </param>\n/// <param name=\"maxpagesize\"> The maximum number of result items per page. </param>\n/// <param name=\"context\"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>\npublic OnlineExperimentationClientGetMetricsAsyncCollectionResult(OnlineExperimentationClient client, int? top, int? skip, int? maxpagesize, RequestContext context) : base(context?.CancellationToken ?? default)\n{\n_client = client;\n_top = top;\n_skip = skip;\n_maxpagesize = maxpagesize;\n_context = context;\n}\n/// <summary> Gets the pages of OnlineExperimentationClientGetMetricsAsyncCollectionResult as an enumerable collection. </summary>\n/// <param name=\"continuationToken\"> A continuation token indicating where to resume paging. </param>\n/// <param name=\"pageSizeHint\"> The number of items per page. </param>\n/// <returns> The pages of OnlineExperimentationClientGetMetricsAsyncCollectionResult as an enumerable collection. </returns>\npublic override async IAsyncEnumerable<Page<BinaryData>> AsPages(string continuationToken, int? pageSizeHint)\n{\nUri nextPage = continuationToken != null ? new Uri(continuationToken) : null;\nwhile (true)\n{\nResponse response = await GetNextResponseAsync(pageSizeHint, nextPage).ConfigureAwait(false);\nif (response is null)\n{\nyield break;\n}\nPagedExperimentMetric result = (PagedExperimentMetric)response;\nList<BinaryData> items = new List<BinaryData>();\nforeach (var item in result.Value)\n{\nitems.Add(ModelReaderWriter.Write(item, ModelSerializationExtensions.WireOptions, AzureAnalyticsOnlineExperimentationContext.Default));\n}\nyield return Page<BinaryData>.FromValues(items, nextPage?.AbsoluteUri, response);\nnextPage = result.NextLink;\nif (nextPage == null)\n{\nyield break;\n}\n}\n}\n/// <summary> Get next page. </summary>\n/// <param name=\"pageSizeHint\"> The number of items per page. </param>\n/// <param name=\"nextLink\"> The next link to use for the next page of results. </param>\nprivate async ValueTask<Response> GetNextResponseAsync(int? pageSizeHint, Uri nextLink)\n{\nHttpMessage message = nextLink != null ? _client.CreateNextGetMetricsRequest(nextLink, _top, _skip, _maxpagesize, _context) : _client.CreateGetMetricsRequest(_top, _skip, _maxpagesize, _context);\nusing DiagnosticScope scope = _client.ClientDiagnostics.CreateScope(\"OnlineExperimentationClient.GetMetrics\");\nscope.Start();\ntry\n{\nreturn await _client.Pipeline.ProcessMessageAsync(message, _context).ConfigureAwait(false);\n}\ncatch (Exception e)\n{\nscope.Failed(e);\nthrow;\n}\n}\n}\n}\n```", "inputs.response": "Yes, Azure Resource Manager (ARM) SDKs do support passing OData-style query parameters such as $filter, $orderby, $search, etc., for list operations—provided your REST API supports these parameters. The SDKs are generated based on your API specification, so any query parameters defined (such as $filter or $orderby) are exposed in the SDK methods as optional parameters.\n\n**How to include these query parameters in SDK calls:**\n\n- **Python SDK:** Query parameters (including OData ones) are exposed as keyword-only arguments in the SDK methods. You can pass them like this:\n  ```python\n  # Pass OData query parameters as keywords\n  resources = client.resource_operations.list(\n      resource_group,\n      $filter=\"name eq 'example'\",\n      $orderby=\"name asc\",\n      $search=\"searchTerm\"\n  )\n  ```\n  Note: Passing these parameters positionally is not supported; you must use keyword arguments. (See migration guide excerpt below.)\n\n- **Go SDK:** Query parameters are generally passed as fields in an options struct for the list operation:\n  ```go\n  options := &ResourceClientListOptions{\n      Filter: to.Ptr(\"name eq 'example'\"),\n      OrderBy: to.Ptr(\"name asc\"),\n      Search: to.Ptr(\"searchTerm\")\n  }\n  pager := client.NewListPager(options)\n  ```\n  The struct fields map directly to your query parameters.\n\n- **.NET SDK:** Similar to Go, options classes or method overloads allow passing query parameters.\n\n- **TypeScript/Java SDKs:** Optional parameters or configuration objects expose query parameters.\n\n**General approach:**\nIf you want custom or additional query parameters exposed in SDKs, define them in your TypeSpec specification using the `@query` decorator on operation parameters or models. For ARM resources, you can use the Azure TypeSpec patterns such as `FilterQueryParameter`, `OrderByQueryParameter`, etc., which are standardized for ARM list operations. For example:\n```typespec\n@armResourceOperations\ninterface Employees {\n  list is ArmListBySubscription<Employee, Parameters={\n    @query(\"$filter\")\n    filter?: string;\n    @query(\"$orderby\")\n    orderby?: string;\n    @query(\"$search\")\n    search?: string;\n  }>;\n}\n```\nThis will ensure those parameters are present in the generated SDKs across languages.\n\n**Summary:**\n- OData query parameters work in SDKs as long as they're defined in your API spec.\n- Pass them as keyword arguments (Python), options structs (Go/.NET), or configuration objects (TypeScript/Java).\n- Use TypeSpec `@query` decorators and ARM patterns to ensure cross-language SDK support.\n\nIf you need to add custom query parameters, update your TypeSpec accordingly and regenerate the SDKs.\n", "inputs.context": "[{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"libraries#azure-core#reference#data-types.md\",\"document_title\":\"Data types\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/data-types\",\"content\":\"# libraries#azure-core#reference#data-types.md\\n\\n# Data types\\n\\n## Azure.Core\\n\\n### `AadOauth2Auth` {#Azure.Core.AadOauth2Auth}\\n\\nAzure Active Directory OAuth2 Flow\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.AadOauth2Auth\\u003cScopes, AuthUrl, TokenUrl\\u003e\\r\\n```\\r\\n\\r\\n#### Template Parameters\\r\\n\\r\\n| Name     | Description                            |\\r\\n| -------- | -------------------------------------- |\\r\\n| Scopes   | A list of scopes the token applies to. |\\r\\n| AuthUrl  | The authorization URL.                 |\\r\\n| TokenUrl | The token URL.                         |\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name          | Type                                                 | Description                                                                    |\\r\\n| ------------- | ---------------------------------------------------- | ------------------------------------------------------------------------------ |\\r\\n| type          | `TypeSpec.Http.AuthType.oauth2`                      | OAuth2 authentication                                                          |\\r\\n| flows         | `[Core.AadTokenAuthFlow\\u003cScopes, AuthUrl, TokenUrl\\u003e]` | Supported OAuth2 flows                                                         |\\r\\n| defaultScopes | `[]`                                                 | Oauth2 scopes of every flow. Overridden by scope definitions in specific flows |\\n\\n### `AadTokenAuthFlow` {#Azure.Core.AadTokenAuthFlow}\\n\\nAzure Active Directory (AAD) Token Authentication Flow\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.AadTokenAuthFlow\\u003cScopes, AuthUrl, TokenUrl\\u003e\\r\\n```\\r\\n\\r\\n#### Template Parameters\\r\\n\\r\\n| Name     | Description                            |\\r\\n| -------- | -------------------------------------- |\\r\\n| Scopes   | A list of scopes the token applies to. |\\r\\n| AuthUrl  | The authorization URL.                 |\\r\\n| TokenUrl | The token URL.                         |\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name             | Type                                             | Description |\\r\\n| ---------------- | ------------------------------------------------ | ----------- |\\r\\n| type             | `TypeSpec.Http.OAuth2FlowType.authorizationCode` |             |\\r\\n| authorizationUrl | `AuthUrl`                                        |             |\\r\\n| tokenUrl         | `TokenUrl`                                       |             |\\r\\n| scopes           | `Scopes`                                         |             |\\n\\n### `ArmResourceIdentifierAllowedResource` {#Azure.Core.ArmResourceIdentifierAllowedResource}\\n\\n```typespec\\r\\nmodel Azure.Core.ArmResourceIdentifierAllowedResource\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name    | Type                                             | Description                                                                                                                                                                          |\\r\\n| ------- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\\r\\n| type    | [`armResourceType`](#Azure.Core.armResourceType) | The type of resource that is being referred to. For example Microsoft.Network/virtualNetworks or Microsoft.Network/virtualNetworks/subnets. See Example Types for more examples.     |\\r\\n| scopes? | `Core.ArmResourceDeploymentScope[]`              | An array of scopes. If not specified, the default scope is [\\\"ResourceGroup\\\"].\\u003cbr /\\u003eSee [Allowed Scopes](https://github.com/Azure/autorest/tree/main/docs/extensions#allowed-scopes). |\\n\\n### `AzureApiKeyAuthentication` {#Azure.Core.AzureApiKeyAuthentication}\\n\\nAzure API Key Authentication using the \\\"Ocp-Apim-Subscription-Key\\\" hea\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.AzureApiKeyAuthentication\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name | Type                                  | Description             |\\r\\n| ---- | ------------------------------------- | ----------------------- |\\r\\n| type | `TypeSpec.Http.AuthType.apiKey`       | API key authentication  |\\r\\n| in   | `TypeSpec.Http.ApiKeyLocation.header` | location of the API key |\\r\\n| name | `\\\"Ocp-Apim-Subscription-Key\\\"`         | name of the API key     |\\n\\n### `ClientRequestIdHeader` {#Azure.Core.ClientRequestIdHeader}\\n\\nProvides the 'x-ms-client-request-id' header to enable request correlation in requests and responses.\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.ClientRequestIdHeader\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name             | Type                       | Description                                                                     |\\r\\n| ---------------- | -------------------------- | ------------------------------------------------------------------------------- |\\r\\n| clientRequestId? | [`uuid`](#Azure.Core.uuid) | An opaque, globally-unique, client-generated string identifier for the request. |\\n\\n### `ConditionalRequestHeaders` {#Azure.Core.ConditionalRequestHeaders}\\n\\nProvides the 'If-\\\\*' headers to enable conditional (cached) responses\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.ConditionalRequestHeaders\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name               | Type          | Description                                                                     |\\r\\n| ------------------ | ------------- | ------------------------------------------------------------------------------- |\\r\\n| ifMatch?           | `string`      | The request should only proceed if an entity matches this string.               |\\r\\n| ifNoneMatch?       | `string`      | The request should only proceed if no entity matches this string.               |\\r\\n| ifUnmodifiedSince? | `utcDateTime` | The request should only proceed if the entity was not modified after this time. |\\r\\n| ifModifiedSince?   | `utcDateTime` | The request should only proceed if the entity was modified after this time.     |\\n\\n### `EmbeddingVector` {#Azure.Core.EmbeddingVector}\\n\\nA vector embedding frequently used in similarity search.\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.EmbeddingVector\\u003cElement\\u003e\\r\\n```\\r\\n\\r\\n#### Template Parameters\\r\\n\\r\\n| Name    | Description                               |\\r\\n| ------- | ----------------------------------------- |\\r\\n| Element | The element type of the embedding vector. |\\r\\n\\r\\n#### Properties\\r\\n\\r\\nNone\\n\\n### `EtagProperty` {#Azure.Core.EtagProperty}\\n\\nProvides the 'ETag' field to enable conditional (cached) requests. This model can be spread\\r\\ninto responses and item models to convey the ETag when it cannot simply conveyed in a header.\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.EtagProperty\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name | Type                       | Description                       |\\r\\n| ---- | -------------------------- | --------------------------------- |\\r\\n| etag | [`eTag`](#Azure.Core.eTag) | The entity tag for this resource. |\\n\\n### `EtagResponseEnvelope` {#Azure.Core.EtagResponseEnvelope}\\n\\nProvides the 'ETag' header to enable conditional (cached) requests\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.EtagResponseEnvelope\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name        | Type     | Description                      |\\r\\n| ----------- | -------- | -------------------------------- |\\r\\n| etagHeader? | `string` | The entity tag for the response. |\\n\\n### `ExpandQueryParameter` {#Azure.Core.ExpandQueryParameter}\\n\\nProvides the standard 'expand' query parameter for list operations.\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.ExpandQueryParameter\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name    | Type       | Description                                       |\\r\\n| ------- | ---------- | ------------------------------------------------- |\\r\\n| expand? | `string[]` | Expand the indicated resources into the response. |\\n\\n### `FilterParameter` {#Azure.Core.FilterParameter}\\n\\nProvides the standard 'filter' query parameter for list operations\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.FilterParameter\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name    | Type     | Description                                  |\\r\\n| ------- | -------- | -------------------------------------------- |\\r\\n| filter? | `string` | The maximum number of result items per page. |\\n\\n### `FilterQueryParameter` {#Azure.Core.FilterQueryParameter}\\n\\nProvides the standard 'filter' query parameter for list operations.\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.FilterQueryParameter\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name    | Type     | Description                                        |\\r\\n| ------- | -------- | -------------------------------------------------- |\\r\\n| filter? | `string` | Filter the result list using the given expression. |\\n\\n### `MaxPageSizeQueryParameter` {#Azure.Core.MaxPageSizeQueryParameter}\\n\\nProvides the standard 'maxpagesize' query parameter for list operations.\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.MaxPageSizeQueryParameter\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name         | Type    | Description                                  |\\r\\n| ------------ | ------- | -------------------------------------------- |\\r\\n| maxpagesize? | `int32` | The maximum number of result items per page. |\\n\\n### `OrderByQueryParameter` {#Azure.Core.OrderByQueryParameter}\\n\\nProvides the standard 'orderby' query parameter for list operations.\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.OrderByQueryParameter\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name     | Type       | Description                                             |\\r\\n| -------- | ---------- | ------------------------------------------------------- |\\r\\n| orderby? | `string[]` | Expressions that specify the order of returned results. |\\n\\n### `Page` {#Azure.Core.Page}\\n\\nDescribes a page of resource object.\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core.Page\\u003cResource\\u003e\\r\\n```\\r\\n\\r\\n#### Template Parameters\\r\\n\\r\\n| Name     | Description        |\\r\\n| -------- | ------------------ |\\r\\n| Resource | The resource type. |\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name      | Type                             | Description |\\r\\n| --------- | -------------------------------- | ----------- |\\r\\n| value     | `Array\\u003cElement\\u003e`                 |             |\\r\\n| nextLink? | `TypeSpec.Rest.ResourceLocation` |             |\\n\\n### `PollingOptions` {#Azure.Core.PollingOptions}\\n\\nGeneric polling options for LRO operations.\\r\\n\\r\\n```typespec\\r\\nmodel Azure.Core\"},{\"document_source\":\"azure_resource_manager_rpc\",\"document_filename\":\"v1.0#common-api-details.md\",\"document_title\":\"Common API Details\",\"document_link\":\"https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/common-api-details.md\",\"content\":\"# v1.0#common-api-details.md\\n\\n# Common API Details\\n\\n## Table of Contents ##\\n\\n- [Proxy Request Header Modifications](#proxy-request-header-modifications) \\u003c/br\\u003e\\r\\n- [Client Request Headers](#client-request-headers) \\u003c/br\\u003e\\r\\n- [Request Query Parameters](#request-query-parameters) \\u003c/br\\u003e\\r\\n- [Case Insensitivity for Requests](#case-insensitivity-for-requests) \\u003c/br\\u003e\\r\\n- [Client Request Timeout](#client-request-timeout) \\u003c/br\\u003e\\r\\n- [Request Throttling](#request-throttling) \\u003c/br\\u003e\\r\\n- [Common API Response Details](#common-api-response-details) \\u003c/br\\u003e\\n\\n## Proxy Request Header Modifications ##\\n\\nthe admins of the tenant which issued the JWT. | 1st party only |\\r\\n| x-ms-client-authentication-methods | Always added. Set to the authentication method references of client JWT. | 1st party only|\\r\\n| x-ms-management-group-ancestors | Always added. Set to the management groups that subscription might belong to. If there are multiple ancestors they will be comma separated. Example: `d27e3b8a-3d55-44b7-b2ba-1b3ef9227527, NonProduction` | 1st party only|\\r\\n| x-ms-arm-resource-routing-location | Added when extension resources or child proxy resources are routed regionally. Set to the endpoint location the request is routed to in the region's lower-case normalized form (i.e. `eastus2`). The endpoint location will be decided by the location of the closest tracked ancestor. If there is no tracked ancestor, the header will not be set. If the request is routed to the global endpoint because there is no matching regional endpoint, it will be set to an empty string. | 1st and 3rd party |\\n\\ntenant ID of the client JWT making the request. | 1st party only |\\r\\n| x-ms-home-tenant-id | Added for requests at or below subscription scopes. Set to the tenant ID of the subscription. This will be different from `x-ms-client-tenant-id` in cross-tenant scenarios. | 1st party only |\\r\\n| x-ms-client-audience | Always added. Set to the audience of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-issuer | Always added. Set to the issuer of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-object-id | Always added. Set to the object Id of the client JWT making the request. Not all users have object Id. For CSP (reseller) scenarios for example, object Id is not available. | 1st party only |\\r\\n| x-ms-client-app-id | Always added. Set to the app Id of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-app-id-acr | Always added. Set to the app Id acr claim of the client JWT making the request. This is the application authentication context class reference claim which indicates how the client was authenticated. | 1st party only |\\r\\n| x-ms-client-authorization-source | Always added. Specifies the authorization source of the token. It\\u0026#39;s value can be NotSpecified, Legacy, RoleBased, Bypassed, Direct and Management. | 1st party only |\\r\\n| x-ms-client-identity-provider | Always added. Set to the identity provider of the client JWT. |1st party only |\\r\\n| x-ms-client-wids | Always added. Set to the wids of the client JWT. These identify the admins of the tenant which issued the JWT. | 1st party only |\\r\\n| x-ms-client-authentication-methods | Always added. Set to the authentication method references of client JWT. | 1st party only|\\r\\n| x-ms-management-group-ancestors | Always added. Set to the management groups that subscription might belong to. If there are multiple ancestors they will be comma separated. Example: `d27e3b8a-3d55-44b7-b2ba-1b3ef9227527, NonProduction` | 1st party only|\\r\\n| x-ms-arm-resource-routing-location |\\n\\nThe resource provider proxy will preserve all the client requests headers, with the exception of modifications per the details below. The headers below are reserved and cannot be set by clients.\\r\\n\\r\\n\\r\\n| Header                     | Description |  1st or 3rd Party |\\r\\n| :----------------------------| :------------------------| :-----------------------------------|\\r\\n| referer | Always added. Set to the full URI that the client connected to (which will be different than the RP URI, since it will have the public hostname instead of the RP hostname). This value can be used in generating FQDN for Location headers or other requests since RPs should not reference their endpoint name. |  1st and 3rd party |\\r\\n| authorization | Always removed/changed. The authorization used by the client to the proxy will be different than the authorization used to communicate from the proxy to the resource provider. | 1st and 3rd party |\\r\\n| x-ms-client-ip-address | Always added . Set to the client IP address used in the request; this is required since the resource provider will not have access to the client IP. | 1st and 3rd party |\\r\\n| x-ms-client-principal-name | Always added. Set to the principal name / UPN of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-principal-id | Added when available. Set to the principal Id of the client JWT making the request. Service principal will not have the principal Id. | 1st party only |\\r\\n| x-ms-client-tenant-id | Always added. Set to the tenant ID of the client JWT making the request. | 1st party only |\\r\\n| x-ms-home-tenant-id | Added for requests at or below subscription scopes. Set to the tenant ID of the subscription. This will be different from `x-ms-client-tenant-id` in cross-tenant scenarios. | 1st party only |\\r\\n| x-ms-client-audience | Always added. Set to the audience of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-issuer | Always added. Set to the issuer of the client JWT making the request. |\\n\\n## Client Request Headers ##\\n\\nAny non-reserved headers provided by the client will pass as-is to the resource provider. All requests to resource providers may include the following standard headers and **must** be supported:\\r\\n\\r\\n| Header | Description |\\r\\n| --- | --- |\\r\\n| Content-Type | Set to application/json. This header is not sent in requests that don\\u0026#39;t have any content, such as all GET calls. |\\r\\n| Accept-Language | Specifies the preferred language for the response; all RPs should use this header when generating error messages or client facing text. |\\r\\n| x-ms-client-request-id | Caller-specified value identifying the request, in the form of a GUID with no decoration such as curly braces (e.g. `client-request-id: 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0`). If the caller provides this header – the resource provider **must** log this with their traces to facilitate tracing a single request. If specified, this will be included in response information as a way to map the request if \\\"x-ms-return-client-request-id\\\"; is specified as \\\"true\\\". Because this header can be client-generated, it should not be assumed to be unique by the RP implementation. |\\r\\n| x-ms-correlation-request-id | Optional. Caller-specified value identifying a set of related operations that the request belongs to, in the form of a GUID. If the caller does not specify this header, ARM will randomly generate a unique GUID. Used for tracing the correlation Id of the request; the resource provider **must** log this so that end-to-end requests can be correlated across Azure. Because this header can be client-generated or re-used for multiple requests, it should not be assumed to be unique by the RP implementation. |\\r\\n| x-ms-return-client-request-id | Optional. True or false and indicates if a client-request-id should be included in the response. Default is false. |\\n\\n## Request Query Parameters ##\\n\\nARM will proxy request parameters (e.g. $filter; $expand; $skipToken; etc.) as-is to the Resource Providers. It will not delete, modify or add any query parameters before relaying the request. The only exceptions are the following query parameters which are not supported on requests into ARM and will cause the request to be rejected with a 400 status code:\\r\\n\\r\\n- `sub`\\r\\n- `subId`\\r\\n- `subscription`\\r\\n- `subscriptionId`\\n\\n## Case Insensitivity for Requests ##\\n\\nWhen satisfying incoming requests, it is assumed that the following values are stored / indexed / compared in a case **insensitive** way:\\r\\n\\r\\n- Resource group name\\r\\n- Resource name\\r\\n- Other names of entities in the URL, even if they are not resources.\\n\\n## Client Request Timeout ##\\n\\nRequests proxied to the resource provider are made with a client timeout of 60 seconds. If requests take more than 60 seconds please consider using asynchronous request/response pattern.\\r\\n\\r\\nThe resource provider must respond within that time interval or the client will receive a 504 (timeout) error code and will not see the response from the RP.\\n\\n## Request Throttling ##\\n\\nARM provides subscription level throttling. More details on these limits can be found [here](https://azure.microsoft.com/en-us/documentation/articles/azure-subscription-service-limits/#overview).\\n\\n## Common API Response Details ##\\n\\n### Response Headers ###\\n\\nAll responses from resource providers should include the following headers:\\r\\n\\r\\n| Header | Description |\\r\\n| --- | --- |\\r\\n| `Content-Type` | Set to application/json. This header is not required in responses that don\\u0026#39;t have any content. |\\r\\n| `Date` | The date that the request was processed, in RFC 1123 format. |\\r\\n| `x-ms-request-id` | A unique identifier for the current operation, service generated. All the resource providers \\\\*must\\\\* return this value in the response headers to facilitate debugging. |\\r\\n| `x-ms-failurecause` | An ___optional___ header used to provide additional failure attribution on error responses. See [below](#x-ms-failurecause-header) for additional information. |\\r\\n\\r\\nAll long running operations response details are described below.\\n\\n### Error Response Content ###\\n\\n\\\"policyAssignmentDisplayName\\\": \\\"Allow Central US and WEU only\\\",\\r\\n              \\\"policyAsssignmentId\\\": \\\"/subscriptions/00000-00000-0000-000/providers/Microsoft.Authorization/policyAssignments/TestAssignment1\\\"\\r\\n            }\\r\\n          },\\r\\n          {\\r\\n            \\\"type\\\": \\\"SomeOtherViolation\\\",\\r\\n            \\\"info\\\": {\\r\\n              \\\"innerException\\\": \\\"innerException Details\\\"\\r\\n       \"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#Guidelines.md\",\"document_title\":\"Microsoft Azure REST API Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md\",\"content\":\"# azure#Guidelines.md\\n\\n# Microsoft Azure REST API Guidelines\\n\\n\\u003c!-- cspell:ignore autorest, BYOS, etag, idempotency, maxpagesize, innererror, trippable, nextlink, condreq, etags --\\u003e\\r\\n\\u003c!-- markdownlint-disable MD033 MD049 MD055 --\\u003e\\r\\n\\r\\n\\u003c!--\\r\\nNote to contributors: All guidelines now have an anchor tag to allow cross-referencing from associated tooling.\\r\\nThe anchor tags within a section using a common prefix to ensure uniqueness with anchor tags in other sections.\\r\\nPlease ensure that you add an anchor tag to any new guidelines that you add and maintain the naming convention.\\r\\n--\\u003e\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2025-Mar-28 | Added guidelines about JSON ID and null values                 |\\r\\n| 2024-Mar-17 | Updated LRO guidelines                                         |\\r\\n| 2024-Jan-17 | Added guidelines on returning string offsets \\u0026 lengths         |\\r\\n| 2023-May-12 | Explain service response for missing/unsupported `api-version` |\\r\\n| 2023-Apr-21 | Update/clarify guidelines on POST method repeatability         |\\r\\n| 2023-Apr-07 | Update/clarify guidelines on polymorphism                      |\\r\\n| 2022-Sep-07 | Updated URL guidelines for DNS Done Right                      |\\r\\n| 2022-Jul-15 | Update guidance on long-running operations                     |\\r\\n| 2022-May-11 | Drop guidance on version discovery                             |\\r\\n| 2022-Mar-29 | Add guidelines about using durations                           |\\r\\n| 2022-Mar-25 | Update guideline for date values in headers to follow RFC 7231 |\\r\\n| 2022-Feb-01 | Updated error guidance                                         |\\r\\n| 2021-Sep-11 | Add long-running operations guidance                           |\\r\\n| 2021-Aug-06 | Updated Azure REST Guidelines per Azure API Stewardship Board. |\\r\\n| 2020-Jul-31 | Added service advice for initial versions                      |\\r\\n| 2020-Mar-31 | 1st public release of the Azure REST API Guidelines            |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Introduction\\n\\nThese guidelines apply to Azure service teams implementing _data plane_ APIs. They offer prescriptive guidance that Azure service teams MUST follow ensuring that customers have a great experience by designing APIs meeting these goals:\\r\\n- Developer friendly via consistent patterns \\u0026 web standards (HTTP, REST, JSON)\\r\\n- Efficient \\u0026 cost-effective\\r\\n- Work well with SDKs in many programming languages\\r\\n- Customers can create fault-tolerant apps by supporting retries/idempotency/optimistic concurrency\\r\\n- Sustainable \\u0026 versionable via clear API contracts with 2 requirements:\\r\\n  1. Customer workloads must never break due to a service change\\r\\n  2. Customers can adopt a version without requiring code changes\\r\\n\\r\\nTechnology and software is constantly changing and evolving, and as such, this is intended to be a living document. [Open an issue](https://github.com/microsoft/api-guidelines/issues/new/choose) to suggest a change or propose a new idea. Please read the [Considerations for Service Design](./ConsiderationsForServiceDesign.md) for an introduction to the topic of API design for Azure services. *For an existing GA'd service, don't change/break its existing API; instead, leverage these concepts for future APIs while prioritizing consistency within your existing service.*\\r\\n\\r\\n*Note: If you are creating a management plane (ARM) API, please refer to the [Azure Resource Manager Resource Provider Contract](https://github.com/cloud-and-ai-microsoft/resource-provider-contract).*\\n\\n### Prescriptive Guidance\\n\\nThis document offers prescriptive guidance labeled as follows:\\r\\n\\r\\n:white_check_mark: **DO** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n:ballot_box_with_check: **YOU SHOULD** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:heavy_check_mark: **YOU MAY** consider this pattern if appropriate to your situation. No notification to the Azure HTTP/REST Stewardship Board is required.\\r\\n\\r\\n:warning: **YOU SHOULD NOT** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:no_entry: **DO NOT** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n*If you feel you need an exception, or need clarity based on your situation, please contact the Azure HTTP/REST Stewardship Board **prior** to release of your API.*\\n\\n## Building Blocks: HTTP, REST, \\u0026 JSON\\n\\nThe Microsoft Azure Cloud platform exposes its APIs through the core building blocks of the Internet; namely HTTP, REST, and JSON. This section provides you with a general understanding of how these technologies should be applied when creating your service.\\r\\n\\r\\n\\u003ca href=\\\"#http\\\" name=\\\"http\\\"\\u003e\\u003c/a\\u003e\\n\\n### HTTP\\n\\ncase-sensitive, multiple delimiter\\r\\nUUID      | 123e4567-e89b-12d3-a456-426614174000 (no {}s, hyphens, case-insensitive) [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)\\r\\nDate/Time (Header) | Sun, 06 Nov 1994 08:49:37 GMT [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1)\\r\\nDate/Time (Query parameter) | YYYY-MM-DDTHH:mm:ss.sssZ (with at most 3 digits of fractional seconds) [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)\\r\\nByte array | Base-64 encoded, max length\\r\\nArray      | One of a) a comma-separated list of values (preferred), or b) separate `name=value` parameter instances for each value of the array\\r\\n\\r\\n\\r\\nThe table below lists the headers most used by Azure services:\\r\\n\\r\\nHeader Key          | Applies to | Example\\r\\n------------------- | ---------- | -------------\\r\\n_authorization_     | Request    | Bearer eyJ0...Xd6j (Support Azure Active Directory)\\r\\n_x-ms-useragent_    | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntraceparent         | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntracecontext        | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\naccept              | Request    | application/json\\r\\nIf-Match            | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-None-Match       | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-Modified-Since   | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\nIf-Unmodified-Since | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\ndate                | Both       | Sun, 06 Nov 1994 08:49:37 GMT (see [RFC 7231, Section 7.1.1.2](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2))\\r\\n_content-type_      | Both       | application/merge-patch+json\\n\\nname=\\\"http-header-names-casing\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** specify headers using kebab-casing\\r\\n\\r\\n\\u003ca href=\\\"#http-header-names-case-sensitivity\\\" name=\\\"http-header-names-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header names using case-insensitivity\\r\\n\\r\\n\\u003ca href=\\\"#http-header-values-case-sensitivity\\\" name=\\\"http-header-values-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header values using case-sensitivity if the header name requires it\\r\\n\\r\\n\\u003ca href=\\\"#http-header-date-values\\\" name=\\\"http-header-date-values\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** accept date values in headers in HTTP-Date format and return date values in headers in the IMF-fixdate format as defined in [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1), e.g. \\\"Sun, 06 Nov 1994 08:49:37 GMT\\\".\\r\\n\\r\\nNote: The RFC 7231 IMF-fixdate format is a \\\"fixed-length and single-zone subset\\\" of the RFC 1123 / RFC 5822 format, which means: a) year must be four digits, b) the seconds component of time is required, and c) the timezone must be GMT.\\r\\n\\r\\n\\u003ca href=\\\"#http-header-request-id\\\" name=\\\"http-header-request-id\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** create an opaque value that uniquely identifies the request and return this value in the `x-ms-request-id` response header.\\r\\n\\r\\nYour service should include the `x-ms-request-id` value in error logs so that users can submit support requests for specific failures using this value.\\r\\n\\r\\n\\u003ca href=\\\"#http-allow-unrecognized-headers\\\" name=\\\"http-allow-unrecognized-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** fail a request that contains an unrecognized header. Headers may be added by API gateways or middleware and this must be tolerated\\r\\n\\r\\n\\u003ca href=\\\"#http-no-x-custom-headers\\\" name=\\\"http-no-x-custom-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** use \\\"x-\\\" prefix for custom headers, unless the header already exists in production [[RFC 6648](https://datatracker.ietf.org/doc/html/rfc6648)].\\r\\n\\r\\n**Additional References**\\n\\nAzure services must adhere to the HTTP specification, [RFC 7231](https://tools.ietf.org/html/rfc7231). This section further refines and constrains how service implementors should apply the constructs defined in the HTTP specification. It is therefore, important that you have a firm understanding of the following concepts:\\r\\n\\r\\n- [Uniform Resource Locators (URLs)](#uniform-resource-locators-urls)\\r\\n- [HTTP Request / Response Pattern](#http-request--response-pattern)\\r\\n- [HTTP Query Parameters and Header Values](#http-query-parameters-and-header-values)\\r\\n\\r\\n#### Uniform Resource Locators (URLs)\\r\\n\\r\\nA Uniform Resource Locator (URL) is how developers access the resources of your service. Ultimately, URLs are how developers form a cognitive model of your service's resources.\\r\\n\\r\\n\\u003ca href=\\\"#http-url-pattern\\\" name=\\\"http-url-pattern\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** use this URL pattern:\\r\\n```text\\r\\nhttps://\\u003ctenant\\u003e.\\u003cregion\\u003e.\\u003cservice\\u003e.\\u003ccloud\\u003e/\\u003cservice-root\\u003e/\\u003cresource-collection\\u003e/\\u003cresou\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#azure-resource-manager#step04.md\",\"document_title\":\"5. Defining Custom Actions\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step04\",\"content\":\"# getstarted#azure-resource-manager#step04.md\\n\\n# 5. Defining Custom Actions\\n\\nSome resources will provide more than the standard CRUD operations and will need to define a custom action endpoint. Additional resource operations can be added to the `interface` where you defined standard resource operations, using the `ArmResourceAction` templates.\\r\\nFor example, to add an additional `POST` action called `/notify` to the standard operations of `User`:\\r\\n```typespec\\r\\n/** The details of a user notification */\\r\\nmodel NotificationDetails {\\r\\n  /** The notification message */\\r\\n  message: string;\\r\\n\\r\\n  /** If true, the notification is urgent */\\r\\n  urgent: boolean;\\r\\n}\\r\\n\\r\\n@armResourceOperations\\r\\ninterface Users extends TrackedResourceOperations\\u003cUser, UserProperties\\u003e {\\r\\n  /** Send a notification to the user */\\r\\n  @segment(\\\"notify\\\")\\r\\n  NotifyUser is ArmResourceActionNoContentSync\\u003cUser, NotificationDetails\\u003e;\\r\\n}\\r\\n```\\r\\nThe following operation templates for different kinds of actions are provided in the `Azure.ResourceManager` namespace:\\r\\n| Template                                                 | Description                                                                                        |\\r\\n| -------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |\\r\\n| `ArmResourceActionNoContentSync\\u003cTResource, TRequest\\u003e`    | Synchronous action with no data in the response, providing the resource type and request payload.  |\\r\\n| `ArmResourceActionNoContentAsync\\u003cTResource, TRequest\\u003e`   | Asynchronous action with no data in the response, providing the resource type and request payload. |\\r\\n| `ArmResourceActionSync\\u003cTResource, TRequest, TResponse\\u003e`  | Synchronous action, providing the resource type and request and response payload.                  |\\r\\n| `ArmResourceActionAsync\\u003cTResource, TRequest, TResponse\\u003e` | Asynchronous action, providing the resource type and request and response payload.                 |\\n\\n## Custom Operations\\n\\nAlternately, you may define custom operations for extraordinary scenarios. Be sure to have a discussion with the ARM team before defining a custom operation.\\r\\nThere are strict guidelines around ARM operations, and you may need to get special signoff for operation that are not expressible using the templates.\\r\\nIn a custom operation, you define the operation parameters, responses, http verb, and so on. For example, here is an operation defining a simple custom action.\\r\\n```typespec\\r\\n/** Send a notification to the user */\\r\\n@post\\r\\n@segment(\\\"notify\\\")\\r\\nop NotifyUser(\\r\\n  ...ResourceInstanceParameters\\u003cUser\\u003e,\\r\\n  @body notification: NotificationDetails,\\r\\n): ArmResponse\\u003cstring\\u003e | ErrorResponse;\\r\\n```\\n\\n### ARM Response Types\\n\\nCustom operations in ARM still need to respect the correct response schema. This library provides standard ARM response types to help with reusability and compliance.\\r\\n| Model                            | Code | Description                                                                                                                 |\\r\\n| -------------------------------- | ---- | --------------------------------------------------------------------------------------------------------------------------- |\\r\\n| `ArmResponse\\u003cT\\u003e`                 | 200  | Base Arm 200 response.                                                                                                      |\\r\\n| `ArmCreatedResponse\\u003cT\\u003e`          | 201  | Resource created response.                                                                                                  |\\r\\n| `ArmNoContentResponse\\u003cTMessage\\u003e` | 204  | No Content (success). The parameter is the documentation for the response (by default, `Operation completed successfully`). |\\r\\n| `ArmDeletedResponse`             | 200  | Resource deleted response.                                                                                                  |\\r\\n| `ArmDeleteAcceptedResponse`      | 202  | Resource deletion in progress response.                                                                                     |\\r\\n| `ArmDeletedNoContentResponse`    | 204  | Resource deleted response.                                                                                                  |\\r\\n| `Page\\u003cT\\u003e`                        | 200  | Return a list of resource with ARM pagination.                                                                              |\\r\\n| `ErrorResponse\\u003cT\\u003e`               | x    | Error response.                                                                                                             |\\n\\n### Common Operation Parameters\\n\\nThere are a number of model types which specify common parameters which are used in resource type operations:\\r\\n| Model                        | In           | Description                                                        |\\r\\n| ---------------------------- | ------------ | ------------------------------------------------------------------ |\\r\\n| `ApiVersionParameter`        | query        | `api-version` parameter                                            |\\r\\n| `SubscriptionIdParameter`    | path         | Subscription ID path parameter                                     |\\r\\n| `ResourceGroupNameParameter` | path         | Resource Group Name path parameter                                 |\\r\\n| `CommonResourceParameters`   | path \\u0026 query | Group of Api version, Subscription ID and Resource group parameter |\\r\\n| `ResourceUriParameter`       | path         | Resource uri path parameter                                        |\\r\\n| `OperationIdParameter`       | path         | Operation Id path parameter                                        |\\n\\n## Name Availability Operations\\n\\nSometimes, resource names must be globally unique or unique within a specified location. The following operation templates are provided in the `Azure.ResourceManager` namespace for checking name availability:\\r\\n| Template                                                              | Description                                          |\\r\\n| --------------------------------------------------------------------- | ---------------------------------------------------- |\\r\\n| `checkLocalNameAvailability\\u003cTRequest, TResponse, TAdditionalParams\\u003e`  | Checks name availability based on an Azure location. |\\r\\n| `checkGlobalNameAvailability\\u003cTRequest, TResponse, TAdditionalParams\\u003e` | Checks name availability globally.                   |\\r\\nThese templates have default values so that they are normally used without specifying any template parameters.\\n\\n### Custom Name Check Operation\\n\\nThe above templates are specializations of the following template in the `Azure.ResourceManager.Foundations` namespace:\\r\\n| Template                                                                          | Description                                                      |\\r\\n| --------------------------------------------------------------------------------- | ---------------------------------------------------------------- |\\r\\n| `checkNameAvailability\\u003cTScopeParameters, TRequest, TResponse, TAdditionalParams\\u003e` | Checks name availability based on the provided scope parameters. |\\r\\nFor reference, the standard templates use the following `TScopeParameters`:\\r\\n| Operation                      | Scope Parameters                                                       |\\r\\n| ------------------------------ | ---------------------------------------------------------------------- |\\r\\n| Global Name Availability Check | `SubscriptionIdParameter, DefaultProviderNamespace`                    |\\r\\n| Local Name Availability Check  | `SubscriptionIdParameter, DefaultProviderNamespace, LocationParameter` |\"},{\"document_source\":\"typespec_azure_http_specs\",\"document_filename\":\"azure#resource-manager#resources#toplevel.md\",\"document_title\":\"Usages for Top Level ARM Resource Operations\",\"document_link\":\"https://github.com/Azure/typespec-azure/blob/main/packages/azure-http-specs/specs/azure/resource-manager/resources/toplevel.tsp\",\"content\":\"# azure#resource-manager#resources#toplevel.md\\n\\n# Usages for Top Level ARM Resource Operations\\n\\n## Scenario: Resource GET operation\\n\\n``` typespec\\r\\n@armResourceOperations\\r\\ninterface TopLevel {  \\r\\n    get is ArmResourceRead\\u003cTopLevelTrackedResource\\u003e;\\r\\n```\\r\\n\\r\\n## Scenario: Resource PUT operation\\r\\n\\r\\n```\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-09-05.md\",\"document_title\":\"Extra \\\"Azure.ResourceManager.ArmResponse\\u003cResponseModel\\u003e\\\" schema in new Swagger\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-09-05.md\\n\\n# Extra \\\"Azure.ResourceManager.ArmResponse\\u003cResponseModel\\u003e\\\" schema in new Swagger\\n\\n## question\\n\\nNew Swagger contains \\\"Azure.ResourceManager.ArmResponse\\u003cResponseModel\\u003e\\\" schema\\n\\n## answer\\n\\nReplace \\\"ArmResponse\\u003cResponseModel\\u003e\\\" with \\\"ResponseModel\\\"\"},{\"document_source\":\"static_typespec_to_swagger_mapping\",\"document_filename\":\"TypeSpec-ARM-Models-Documentation.md\",\"document_title\":\"TypeSpec ARM Model Mapping to Swagger Documentation\",\"document_link\":\"\",\"content\":\"# TypeSpec-ARM-Models-Documentation.md\\n\\n# TypeSpec ARM Model Mapping to Swagger Documentation\\n\\n## 42. ResourceListResult\\n\\n### Description\\n\\nPaged response containing resources. This is the standard response format for Azure Resource Manager list operations.\\n\\n### TypeSpec Example\\n\\n```typescript\\r\\nop list is ArmResourceActionSync\\u003c\\r\\n  Resource = Employee,\\r\\n  Request = void,\\r\\n  Response = ResourceListResult\\u003cEmployee\\u003e\\r\\n\\u003e;\\r\\n```\\r\\n**Swagger Output:**\\r\\n```json\\r\\n{\\r\\n  \\\"definitions\\\": {\\r\\n    \\\"MainServiceListResult\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"The response of a MainService list operation.\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"value\\\": {\\r\\n          \\\"type\\\": \\\"array\\\",\\r\\n          \\\"description\\\": \\\"The MainService items on this page\\\",\\r\\n          \\\"items\\\": {\\r\\n            \\\"$ref\\\": \\\"#/definitions/MainService\\\"\\r\\n          }\\r\\n        },\\r\\n        \\\"nextLink\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"format\\\": \\\"uri\\\",\\r\\n          \\\"description\\\": \\\"The link to the next page of items\\\"\\r\\n        }\\r\\n      },\\r\\n      \\\"required\\\": [\\r\\n        \\\"value\\\"\\r\\n      ]\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\"},{\"document_source\":\"static_typespec_to_swagger_mapping\",\"document_filename\":\"TypeSpec-ARM.CommonTypes-Models-Documentation.md\",\"document_title\":\"TypeSpec Azure.ResourceManager.CommonTypes Models Mapping to Swagger Documentation\",\"document_link\":\"\",\"content\":\"# TypeSpec-ARM.CommonTypes-Models-Documentation.md\\n\\n# TypeSpec Azure.ResourceManager.CommonTypes Models Mapping to Swagger Documentation\\n\\n## 38. OperationListResult\\n\\n### Description\\n\\nA list of REST API operations supported by an Azure Resource Provider.\\n\\n### TypeSpec Example\\n\\n```typespec\\r\\nop listOperations(): OperationListResult;\\r\\n```\\n\\n### Swagger Output\\n\\n```json\\r\\n{\\r\\n  \\\"OperationListResult\\\": {\\r\\n    \\\"type\\\": \\\"object\\\",\\r\\n    \\\"properties\\\": {\\r\\n      \\\"value\\\": {\\r\\n        \\\"type\\\": \\\"array\\\",\\r\\n        \\\"readOnly\\\": true,\\r\\n        \\\"items\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/Operation\\\"\\r\\n        },\\r\\n        \\\"description\\\": \\\"List of operations supported by the resource provider\\\"\\r\\n      },\\r\\n      \\\"nextLink\\\": {\\r\\n        \\\"type\\\": \\\"string\\\",\\r\\n        \\\"readOnly\\\": true,\\r\\n        \\\"description\\\": \\\"URL to get the next set of operation list results (if there are any).\\\"\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\"},{\"document_source\":\"static_typespec_to_swagger_mapping\",\"document_filename\":\"TypeSpec-ARM-Operations-Documentation.md\",\"document_title\":\"TypeSpec ARM Operation Mapping to Swagger Documentation\",\"document_link\":\"\",\"content\":\"# TypeSpec-ARM-Operations-Documentation.md\\n\\n# TypeSpec ARM Operation Mapping to Swagger Documentation\\n\\nThis document provides detailed mapping information for core operations in the Azure Resource Manager TypeSpec library. Each operation is numbered and includes a structured format with description, TypeSpec examples, and corresponding Swagger output.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#azure-core#step09.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step09\",\"content\":\"# 9. Customizing operations with traits\\n## Useful trait types\\n### `QueryParametersTrait\\u003cTParams, Contexts\\u003e`\\nThis trait adds query parameters to operation signatures. It accepts a model type containing the query parameters that will be mixed in to the operation signature:\\r\\n```typespec\\r\\nop getWidget is Operations.ResourceRead\\u003c\\r\\n  Widget,\\r\\n  QueryParametersTrait\\u003c{\\r\\n    @query foo: string;\\r\\n  }\\u003e\\r\\n\\u003e;\\r\\n```\\r\\n\\u003e **NOTE**: All properties in `TParams` must be marked with `@query` or an error will be raised.\\r\\nThe `Contexts` parameter is configured to apply the query parameters to all operations by default.\\r\\nTo constrain the types of operations that these query parameters will apply to, pass one ore more of the following values:\\r\\n- **TraitContext.Read**: Applies to read operations\\r\\n- **TraitContext.Create**: Applies to create operations\\r\\n- **TraitContext.Update**: Applies to update operations\\r\\n- **TraitContext.Delete**: Applies to delete operations\\r\\n- **TraitContext.List**: Applies to list operations\\r\\n- **TraitContext.Action**: Applies to custom action operations\\r\\nHere is an example of applying query parameters to `Read` and `List` operations:\\r\\n```typespec\\r\\nalias MyQueryParams = QueryParametersTrait\\u003c\\r\\n  {\\r\\n    @query foo: string;\\r\\n  },\\r\\n  TraitContext.Read | TraitContext.List\\r\\n\\u003e;\\r\\n\\r\\n// This will have a `foo` parameter added\\r\\nop getWidget is Operations.ResourceRead\\u003cWidget, MyQueryParams\\u003e;\\r\\n\\r\\n// This will not get the `foo` parameter because it doesn't match the contexts\\r\\nop deleteWidget is Operations.ResourceDelete\\u003cWidget, MyQueryParams\\u003e;\\r\\n```\"},{\"document_source\":\"azure-sdk-guidelines\",\"document_filename\":\"golang_introduction.html\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/azure-sdk/golang_introduction.html\",\"content\":\"# Go Azure SDK Design Guidelines\\n## Azure SDK API Design {#golang-api}\\n### Service Clients {#golang-client}\\n%} validate client parameters.\\r\\n\\r\\n{% include requirement/MUSTNOT id=\\\"golang-params-service-validation\\\" %} validate service parameters. This includes null checks, empty strings, and other common validating conditions. Let the service validate any request parameters.\\r\\n\\r\\n{% include requirement/MUST id=\\\"golang-params-devex\\\" %} validate the developer experience when the service parameters are invalid to ensure appropriate error messages are generated by the service. If the developer experience is compromised due to service-side error messages, work with the service team to correct prior to release.\\r\\n\\r\\n#### Methods Returning Collections (Paging)\\r\\n\\r\\n{% include requirement/MUST id=\\\"golang-pagination\\\" %} return an instance of `*runtime.Pager[T]` for operations that return pages.  `runtime.Pager[T]` allows consumers to iterate over all pages as defined by the service.\\r\\n\\r\\n{% include requirement/MUST id=\\\"golang-paged-method-naming\\\" %} name methods that return a `*runtime.Pager[T]` with pattern `New\\u003cOperation\\u003ePager`.\\r\\n\\r\\n{% include requirement/MUSTNOT id=\\\"golang-paging-io\\\" %} perform any IO when creating the `runtime.Pager[T]`.  This implies that the method does NOT take a context and does NOT return an error.\\r\\n\\r\\n```go\\r\\nfunc (c *WidgetClient) NewListPager(options *WidgetClientListOptions) *runtime.Pager[WidgetClientListResponse] {\\r\\n\\t// ...\\r\\n}\\r\\n\\r\\ntype WidgetClientListResponse struct {\\r\\n\\tWidgetsListResult\\r\\n}\\r\\n\\r\\ntype WidgetsListResult struct {\\r\\n\\tValues []*Widget\\r\\n\\r\\n\\tNextLink *string\\r\\n}\\r\\n\\r\\npager := client.NewListPager(nil)\\r\\nfor pager.More() {\\r\\n\\tpage, err := pager.NextPage(context.Background())\\r\\n\\tif err != nil {\\r\\n\\t\\t// handle error...\\r\\n\\t}\\r\\n\\tfor _, w := range page.Value {\\r\\n\\t\\tprocess(w)\\r\\n\\t}\\r\\n}\\r\\n```\\r\\n\\r\\n{% include requirement/MUST id=\\\"golang-pagination-serialization\\\" %} provide means to serialize and deserialize a `runtime.Pager[T]` so that paging can pause and continue, potentially on another machine.\\r\\n\\r\\n#### Methods Invoking Long Running Operations\"},{\"document_source\":\"azure-sdk-guidelines\",\"document_filename\":\"dotnet_implementation.html\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/azure-sdk/dotnet_implementation.html\",\"content\":\"# C#.NET Guidelines: Implementation\\n## API Implementation\\n### The Service Client\\n%} be a required parameter.\\r\\n    * If present this {% include requirement/MUST id=\\\"dotnet-parameter-lro-qualifier-first\\\" %} be the first parameter.\\r\\n    * For LRO this {% include requirement/SHOULD id=\\\"dotnet-parameter-lro-qualifier-presence\\\" %} be the present.\\r\\n\\r\\n2. Required Path: These are parameters that will go in the path of the URI.\\r\\n    * These {% include requirement/MUST id=\\\"dotnet-parameter-path-ordering\\\" %} be sorted based on their order in the URI so they match.\\r\\n    * Sometimes these {% include requirement/MAY id=\\\"dotnet-parameter-path-omit\\\" %} be omitted as public method parameters when the context is known by the enclosing class such as [ResourceGroup.Get](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/resourcemanager/Azure.ResourceManager/src/Resources/Generated/ResourceGroupResource.cs#L127)\\r\\n\\r\\n3. Required Query / Header: These are simple options that can be set as headers or query params in the request.  Typically primitive types or collections that can be transformed into delimited strings.\\r\\n    * Any required query or header parameters {% include requirement/MUST id=\\\"dotnet-parameter-query-header-order\\\" %} come before the body parameter since the body parameter can be optional.\\r\\n\\r\\n4. Body: This is typically found in PUT or POST methods and is object passed as the content of the HTTP request.\\r\\n    * For PUT this {% include requirement/MUST id=\\\"dotnet-parameter-body-required-for-put\\\" %} be a required parameter.\\r\\n\\r\\n5. ContentType: Defines the content type.\\r\\n    * If present this {% include requirement/MUST id=\\\"dotnet-parameter-content-type-type\\\" %} be the type defined in `Azure.Core` [here](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/src/ContentType.cs).\\r\\n    * If present this {% include requirement/MUST id=\\\"dotnet-parameter-content-type-optional\\\" %} be an optional parameter.\\r\\n\\r\\n6. Optional Query / Header: These are simple options that can be set as headers or query params in the request.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/versioning\",\"content\":\"# Versioning\\n## Simple Scenarios\\n### Adding a Parameter to an Operation and Making Another Parameter Optional\\nThis scenario shows how to add a parameter and make another optional in an operation.\\r\\n\\r\\nSuppose you start with the following operation in v1:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  listBySubscription is ArmListBySubscription\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      @header\\r\\n      location: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\nIn version `v2`, you want to:\\r\\n\\r\\n- Make the `location` header parameter optional.\\r\\n- Add a new optional query parameter `orderBy`.\\r\\n\\r\\nYou can achieve this using the `@madeOptional` and `@added` decorators:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  listBySubscription is ArmListBySubscription\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      @madeOptional(Versions.v2)\\r\\n      @header\\r\\n      location?: string;\\r\\n\\r\\n      @added(Versions.v2)\\r\\n      @query(\\\"order-by\\\")\\r\\n      orderBy?: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\n**Explanation:**\\r\\n\\r\\n- `@madeOptional(Versions.v2)` makes `location` optional starting in v2.\\r\\n- `@added(Versions.v2)` adds the `orderBy` query parameter in v2 and later.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#generate-client-libraries#08types.mdx\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/08types\",\"content\":\"# Generated Types\\n## Client Default Values (Legacy)\\n### Operation Parameter Default Values\\nUse `@clientDefaultValue` on operation parameters when you need to specify a default value for query parameters, headers, or other operation inputs.\\r\\n\\u003cClientTabs\\u003e\\r\\n\\u003cClientTabItem lang=\\\"typespec\\\" \\u003e\\r\\n```typespec\\r\\nop getItems(\\r\\n  @Azure.ClientGenerator.Core.Legacy.clientDefaultValue(10)\\r\\n  @query\\r\\n  pageSize?: int32,\\r\\n\\r\\n  @Azure.ClientGenerator.Core.Legacy.clientDefaultValue(\\\"desc\\\")\\r\\n  @query\\r\\n  sortOrder?: string,\\r\\n): Item[];\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"python\\\"\\u003e\\r\\n```python\\r\\n    def get_items(\\r\\n        self, *, page_size: int = 10, sort_order: str = \\\"desc\\\", **kwargs: Any\\r\\n    ) -\\u003e list[_models.Item]:\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"csharp\\\" \\u003e\\r\\n```csharp\\r\\nTODO\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"typescript\\\" \\u003e\\r\\n```typescript\\r\\nTODO;\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"java\\\" \\u003e\\r\\n```java\\r\\nTODO\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"go\\\" \\u003e\\r\\n```go\\r\\nTODO\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003c/ClientTabs\\u003e\"},{\"document_source\":\"azure_sdk_for_python_docs\",\"document_filename\":\"dev#mgmt#operation_migration.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/mgmt/operation_migration.md\",\"content\":\"# Azure SDK Migration Guide: New Operation Design Generation Breaking Changes\\n## Detailed Breaking Changes\\n### Query/Header Parameters Requiring Keywords\\n**What changed**: Query and header parameters in operation methods have been changed from positional to keyword-only.\\r\\n\\r\\n**What will break**:\\r\\n\\r\\n- Code that passes positional parameters\\r\\n\\r\\n**Before**:\\r\\n\\r\\n```python\\r\\nfrom azure.mgmt.confluent import ConfluentManagementClient\\r\\n\\r\\nclient = ConfluentManagementClient(...)\\r\\n\\r\\n# Pass query parameters positionally\\r\\nenvironments = client.organization_operations.list_environments(\\r\\n    \\\"resource_group\\\",\\r\\n    \\\"org_name\\\", \\r\\n    10,        # Pass page_size as positional\\r\\n    \\\"token\\\"    # Pass page_token as positional\\r\\n)\\r\\n```\\r\\n\\r\\n**After**:\\r\\n\\r\\n```python\\r\\nfrom azure.mgmt.confluent import ConfluentManagementClient\\r\\n\\r\\nclient = ConfluentManagementClient(...)\\r\\n\\r\\n# ❌ Raises TypeError\\r\\nenvironments = client.organization_operations.list_environments(\\r\\n    \\\"resource_group\\\",\\r\\n    \\\"org_name\\\", \\r\\n    10,\\r\\n    \\\"token\\\"\\r\\n)\\r\\n\\r\\n# ✅ Use these approaches instead\\r\\nenvironments = client.organization_operations.list_environments(\\r\\n    \\\"resource_group\\\",\\r\\n    \\\"org_name\\\",\\r\\n    page_size=10,         # Must be passed with a keyword\\r\\n    page_token=\\\"token\\\"    # Must be passed with a keyword\\r\\n)\\r\\n```\\r\\n\\r\\n**Migration steps:**\\r\\n\\r\\n- Convert all positional parameters to keyword arguments\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"libraries#http#cheat-sheet.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/libraries/http/cheat-sheet\",\"content\":\"# Cheat sheet\\n## Data types\\nThese examples show how to work with different parameter types and response structures.\\r\\n\\r\\n| Feature                 | Example                                     |\\r\\n| ----------------------- | ------------------------------------------- |\\r\\n| Request header          | `op read(@header traceparent: string): Pet` |\\r\\n| Response header         | `op read(): {@header eTag: string, ...Pet}` |\\r\\n| Query parameter         | `op list(@query filter: string): Pet[]`     |\\r\\n| Explicit body parameter | `op add(@body pet: Pet): void`              |\\r\\n| Implicit body parameter | `op add(...Pet): void`                      |\\r\\n| Status code             | `op read(): {@statusCode _: 200, ...Pet}`   |\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"libraries#http#operations.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/libraries/http/operations\",\"content\":\"# Operations\\n## Path and query parameters\\nModel properties and parameters which should be passed as path and query parameters use the `@path` and `@query` parameters respectively. Let's modify our list operation to support pagination, and add a read operation to our Pets resource:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/pets\\\")\\r\\nnamespace Pets {\\r\\n  op list(@query skip: int32, @query top: int32): Pet[];\\r\\n  op read(@path petId: int32): Pet;\\r\\n}\\r\\n```\\r\\n\\r\\nPath parameters are appended to the URL unless a substitution with that parameter name exists on the resource path. For example, we might define a sub-resource using the following TypeSpec. Note how the path parameter for our sub-resource's list operation corresponds to the substitution in the URL.\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/pets/{petId}/toys\\\")\\r\\nnamespace PetToys {\\r\\n  op list(@path petId: int32): Toy[];\\r\\n}\\r\\n```\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/versioning\",\"content\":\"# Versioning\\n## Adding a Property or Parameter\\nYou can also add new properties or parameters to models and operations in a specific version:\\r\\n\\r\\n**Add a property in v2:**\\r\\n\\r\\n```tsp\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n\\r\\n  @added(Versions.v2)\\r\\n  city?: string;\\r\\n}\\r\\n```\\r\\n\\r\\n**Add a parameter in v2:**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      name: string;\\r\\n\\r\\n      @added(Versions.v2)\\r\\n      department?: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\"},{\"document_source\":\"typespec_azure_http_specs\",\"document_filename\":\"azure#resource-manager#resources#singleton.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/typespec-azure/blob/main/packages/azure-http-specs/specs/azure/resource-manager/resources/singleton.tsp\",\"content\":\"# Usages for Singleton Arm Resource Properties.\\n## Scenario: Resource GET operation.\\n``` typespec\\r\\n@armResourceOperations\\r\\ninterface Singleton {  \\r\\n    getByResourceGroup is ArmResourceRead\\u003cSingletonTrackedResource\\u003e;\\r\\n```\\r\\n\\r\\n## Scenario: Resource PUT operation.\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_azure_http_specs\",\"document_filename\":\"azure#resource-manager#resources#nested.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/typespec-azure/blob/main/packages/azure-http-specs/specs/azure/resource-manager/resources/nested.tsp\",\"content\":\"# Usages for Nested child of Top Level Tracked Resource.\\n## Scenario: Resource GET operation\\n``` typespec\\r\\n@armResourceOperations\\r\\ninterface Nested {  \\r\\n    get is ArmResourceRead\\u003cNestedProxyResource\\u003e;\\r\\n```\\r\\n\\r\\n## Scenario: Resource PUT operation\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_azure_http_specs\",\"document_filename\":\"azure#resource-manager#common-properties#managed-identity.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/typespec-azure/blob/main/packages/azure-http-specs/specs/azure/resource-manager/common-properties/managed-identity.tsp\",\"content\":\"# Usages for Managed Identity Arm Resource Properties.\\n## Scenario: Resource GET operation\\n``` typespec\\r\\n@armResourceOperations\\r\\ninterface ManagedIdentity {  \\r\\n    get is ArmResourceRead\\u003cManagedIdentityTrackedResource\\u003e;\\r\\n```\\r\\n\\r\\n## Scenario: Resource PUT operation\\r\\n\\r\\n```\"},{\"document_source\":\"azure_sdk_for_go_docs\",\"document_filename\":\"development#ARM#MIGRATION_GUIDE.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-sdk-for-go/blob/main/documentation/development/ARM/MIGRATION_GUIDE.md\",\"content\":\"# Guide for migrating to `sdk/resourcemanager/**/arm**` from `services/**/mgmt/**`\\n## Prerequisites\\n- [Supported](https://aka.ms/azsdk/go/supported-versions) version of Go\\r\\n- Latest version of resource management modules\"},{\"document_source\":\"azure_sdk_for_go_docs\",\"document_filename\":\"development#ARM#new-version-guideline.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-sdk-for-go/blob/main/documentation/development/ARM/new-version-guideline.md\",\"content\":\"# Azure Go Management SDK Guideline\\n## Table of contents\\n* [Pageable Operations](#pageable-operations)\\r\\n* [Long-Running Operations](#long-running-operations)\\r\\n* [Troubleshooting](#troubleshooting)\\r\\n* [Major Version Upgrade](#major-version-upgrade)\"},{\"document_source\":\"azure_sdk_for_python_docs\",\"document_filename\":\"dev#sample_guide.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/sample_guide.md\",\"content\":\"# Samples, Snippets, and How-To Guides\\nDevelopers like to learn by looking at code, and so the Azure SDK comes with a myriad of code samples in the form of short code snippets, sample applications, and how-to guides. This document describes where to find all these resources.\"},{\"document_source\":\"azure_sdk_for_python_docs\",\"document_filename\":\"dev#issues#resolve_issues_effectively.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/issues/resolve_issues_effectively.md\",\"content\":\"# Resolve Issues Effectively\\n## Usage error (For users)\\nIf you are not familiar with the SDK usage of a service, you can find relevant examples in [this repo][sample repo] in most cases.\\r\\n\\r\\nFor some common errors, you can check [here](#summary-of-common-errors).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#support.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/support\",\"content\":\"# Get help and support\\n\\u003c!-- A short description of this page (fewer than 50 words) that describes the main learning goal or task that readers\\r\\nwill complete. --\\u003e\\r\\n\\r\\nIf you have problems or questions when using Azure SDK tools or releasing your updates, you can get help by following\\r\\nguidance provided in this article.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Resources\\n### `armwiki.azurewebsites.net`\\n- [Azure Feature Exposure Control][AFEC] (AFEC)\\r\\n- [ARM spec onboarding]\\r\\n  - [ARM branches]\\r\\n- [ARM Resource Provider onboarding]\\r\\n  - [ARM lifecycle stages requirements]\\r\\n  - [ARM preview guidelines]\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"faqs#faqs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/faqs/faqs\",\"content\":\"# Azure SDK frequently asked questions\\n## TypeSpec / OpenAPI specs\\nThis FAQ pertains to generic questions about TypeSpec / OpenAPI specifications. If you have a question related\\r\\nto your PR updating such specifications, see [Azure REST API specs PRs FAQ](#azure-rest-api-specs-prs).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#known-issues.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/known-issues\",\"content\":\"# Known issues and limitations\\nAzure SDK tools include the following known issues and limitations that might impact your experience.\"}]", "inputs.latency": 952.748842716217, "inputs.response_length": 2635, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/mgmt/operation_migration.md", "https://typespec.io/docs/libraries/http/cheat-sheet", "https://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/data-types", "https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/08types", "https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md"], "inputs.testcase": "Do ARM SDKs support OData filtering like the APIs do?", "outputs.similarity.similarity": 5.0, "outputs.similarity.gpt_similarity": 5.0, "outputs.similarity.similarity_result": "pass", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 2413, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 2414, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Do ARM SDKs support OData filtering like the APIs do?\\\\n\\\\nquestion: For list operations in our resource provider, we know we can perform filtering, sorting and searching using query parameters ($filter, $sort, $search) in our  API calls, and we've implemented the backend support for these queries already.\\\\nIs it possible to do the same sort of server side filtering (or generally add logic to include query parameters with certain calls) with our Azure SDKs as well?\\\", \\\"response\\\": \\\"Yes, Azure Resource Manager (ARM) SDKs do support passing OData-style query parameters such as $filter, $orderby, $search, etc., for list operations\\\\u2014provided your REST API supports these parameters. The SDKs are generated based on your API specification, so any query parameters defined (such as $filter or $orderby) are exposed in the SDK methods as optional parameters.\\\\n\\\\n**How to include these query parameters in SDK calls:**\\\\n\\\\n- **Python SDK:** Query parameters (including OData ones) are exposed as keyword-only arguments in the SDK methods. You can pass them like this:\\\\n  ```python\\\\n  # Pass OData query parameters as keywords\\\\n  resources = client.resource_operations.list(\\\\n      resource_group,\\\\n      $filter=\\\\\\\"name eq 'example'\\\\\\\",\\\\n      $orderby=\\\\\\\"name asc\\\\\\\",\\\\n      $search=\\\\\\\"searchTerm\\\\\\\"\\\\n  )\\\\n  ```\\\\n  Note: Passing these parameters positionally is not supported; you must use keyword arguments. (See migration guide excerpt below.)\\\\n\\\\n- **Go SDK:** Query parameters are generally passed as fields in an options struct for the list operation:\\\\n  ```go\\\\n  options := &ResourceClientListOptions{\\\\n      Filter: to.Ptr(\\\\\\\"name eq 'example'\\\\\\\"),\\\\n      OrderBy: to.Ptr(\\\\\\\"name asc\\\\\\\"),\\\\n      Search: to.Ptr(\\\\\\\"searchTerm\\\\\\\")\\\\n  }\\\\n  pager := client.NewListPager(options)\\\\n  ```\\\\n  The struct fields map directly to your query parameters.\\\\n\\\\n- **.NET SDK:** Similar to Go, options classes or method overloads allow passing query parameters.\\\\n\\\\n- **TypeScript/Java SDKs:** Optional parameters or configuration objects expose query parameters.\\\\n\\\\n**General approach:**\\\\nIf you want custom or additional query parameters exposed in SDKs, define them in your TypeSpec specification using the `@query` decorator on operation parameters or models. For ARM resources, you can use the Azure TypeSpec patterns such as `FilterQueryParameter`, `OrderByQueryParameter`, etc., which are standardized for ARM list operations. For example:\\\\n```typespec\\\\n@armResourceOperations\\\\ninterface Employees {\\\\n  list is ArmListBySubscription<Employee, Parameters={\\\\n    @query(\\\\\\\"$filter\\\\\\\")\\\\n    filter?: string;\\\\n    @query(\\\\\\\"$orderby\\\\\\\")\\\\n    orderby?: string;\\\\n    @query(\\\\\\\"$search\\\\\\\")\\\\n    search?: string;\\\\n  }>;\\\\n}\\\\n```\\\\nThis will ensure those parameters are present in the generated SDKs across languages.\\\\n\\\\n**Summary:**\\\\n- OData query parameters work in SDKs as long as they're defined in your API spec.\\\\n- Pass them as keyword arguments (Python), options structs (Go/.NET), or configuration objects (TypeScript/Java).\\\\n- Use TypeSpec `@query` decorators and ARM patterns to ensure cross-language SDK support.\\\\n\\\\nIf you need to add custom query parameters, update your TypeSpec accordingly and regenerate the SDKs.\\\\n\\\", \\\"ground_truth\\\": \\\"ARM SDKs do support OData\\\\u2011style query parameters (such as filter, orderby, search, top, skip, select, and expand), but only if your API spec explicitly defines them using TypeSpec or OpenAPI models like Azure.Core.FilterQueryParameter and OrderByQueryParameter. The SDKs don\\\\u2019t add these automatically or treat them specially\\\\u2014they simply expose whatever query parameters your spec declares, following Azure API Guidelines (camelCase names, not $filter). Both C# and Python treat these as normal query parameters, and paging behaviors reinject parameters as needed. In short: define the parameters in your spec, and the SDKs will fully support them.\\\\nhere is an example of the paging pattern in C#\\\\n```\\\\n// Copyright (c) Microsoft Corporation. All rights reserved.\\\\n// Licensed under the MIT License.\\\\n// <auto-generated/>\\\\nusing System;\\\\nusing System.ClientModel.Primitives;\\\\nusing System.Collections.Generic;\\\\nusing System.Threading.Tasks;\\\\nusing Azure;\\\\nusing Azure.Core;\\\\nusing Azure.Core.Pipeline;\\\\nnamespace Azure.Analytics.OnlineExperimentation\\\\n{\\\\ninternal partial class OnlineExperimentationClientGetMetricsAsyncCollectionResult : AsyncPageable<BinaryData>\\\\n{\\\\nprivate readonly OnlineExperimentationClient _client;\\\\nprivate readonly int? _top;\\\\nprivate readonly int? _skip;\\\\nprivate readonly int? _maxpagesize;\\\\nprivate readonly RequestContext _context;\\\\n/// <summary> Initializes a new instance of OnlineExperimentationClientGetMetricsAsyncCollectionResult, which is used to iterate over the pages of a collection. </summary>\\\\n/// <param name=\\\\\\\"client\\\\\\\"> The OnlineExperimentationClient client used to send requests. </param>\\\\n/// <param name=\\\\\\\"top\\\\\\\"> The number of result items to return. </param>\\\\n/// <param name=\\\\\\\"skip\\\\\\\"> The number of result items to skip. </param>\\\\n/// <param name=\\\\\\\"maxpagesize\\\\\\\"> The maximum number of result items per page. </param>\\\\n/// <param name=\\\\\\\"context\\\\\\\"> The request options, which can override default behaviors of the client pipeline on a per-call basis. </param>\\\\npublic OnlineExperimentationClientGetMetricsAsyncCollectionResult(OnlineExperimentationClient client, int? top, int? skip, int? maxpagesize, RequestContext context) : base(context?.CancellationToken ?? default)\\\\n{\\\\n_client = client;\\\\n_top = top;\\\\n_skip = skip;\\\\n_maxpagesize = maxpagesize;\\\\n_context = context;\\\\n}\\\\n/// <summary> Gets the pages of OnlineExperimentationClientGetMetricsAsyncCollectionResult as an enumerable collection. </summary>\\\\n/// <param name=\\\\\\\"continuationToken\\\\\\\"> A continuation token indicating where to resume paging. </param>\\\\n/// <param name=\\\\\\\"pageSizeHint\\\\\\\"> The number of items per page. </param>\\\\n/// <returns> The pages of OnlineExperimentationClientGetMetricsAsyncCollectionResult as an enumerable collection. </returns>\\\\npublic override async IAsyncEnumerable<Page<BinaryData>> AsPages(string continuationToken, int? pageSizeHint)\\\\n{\\\\nUri nextPage = continuationToken != null ? new Uri(continuationToken) : null;\\\\nwhile (true)\\\\n{\\\\nResponse response = await GetNextResponseAsync(pageSizeHint, nextPage).ConfigureAwait(false);\\\\nif (response is null)\\\\n{\\\\nyield break;\\\\n}\\\\nPagedExperimentMetric result = (PagedExperimentMetric)response;\\\\nList<BinaryData> items = new List<BinaryData>();\\\\nforeach (var item in result.Value)\\\\n{\\\\nitems.Add(ModelReaderWriter.Write(item, ModelSerializationExtensions.WireOptions, AzureAnalyticsOnlineExperimentationContext.Default));\\\\n}\\\\nyield return Page<BinaryData>.FromValues(items, nextPage?.AbsoluteUri, response);\\\\nnextPage = result.NextLink;\\\\nif (nextPage == null)\\\\n{\\\\nyield break;\\\\n}\\\\n}\\\\n}\\\\n/// <summary> Get next page. </summary>\\\\n/// <param name=\\\\\\\"pageSizeHint\\\\\\\"> The number of items per page. </param>\\\\n/// <param name=\\\\\\\"nextLink\\\\\\\"> The next link to use for the next page of results. </param>\\\\nprivate async ValueTask<Response> GetNextResponseAsync(int? pageSizeHint, Uri nextLink)\\\\n{\\\\nHttpMessage message = nextLink != null ? _client.CreateNextGetMetricsRequest(nextLink, _top, _skip, _maxpagesize, _context) : _client.CreateGetMetricsRequest(_top, _skip, _maxpagesize, _context);\\\\nusing DiagnosticScope scope = _client.ClientDiagnostics.CreateScope(\\\\\\\"OnlineExperimentationClient.GetMetrics\\\\\\\");\\\\nscope.Start();\\\\ntry\\\\n{\\\\nreturn await _client.Pipeline.ProcessMessageAsync(message, _context).ConfigureAwait(false);\\\\n}\\\\ncatch (Exception e)\\\\n{\\\\nscope.Failed(e);\\\\nthrow;\\\\n}\\\\n}\\\\n}\\\\n}\\\\n```\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"5\"}]"}, {"inputs.query": "title: SDK release help\n\nquestion: Hi,  I got an error with .NET SDK generation. Here is the log https://dev.azure.com/azure-sdk/internal/_build/results?buildId=5634535&view=results", "inputs.ground_truth": "Log from the pipeline:\n[SGS-WARN] SDK configuration is not enabled for specification-containerservice-Fleet.Management-tspconfig.yaml. Refer to the full log for details.\n.NET is missing in your tspconfig.yaml => azure-rest-api-specs/specification/containerservice/Fleet.Management/tspconfig.yaml at d1319a40758b…\nYou can use azure-rest-api-specs/specification/widget/resource-manager/Microsoft.Widget/Widget/tspconfig.yaml a… as a template", "inputs.response": "Sorry, I can't access the content of external build logs or links directly. However, I can guide you through diagnosing and resolving .NET SDK generation build failures based on standard Azure SDK practices.\n\n1. **Check the Pipeline Logs**: The primary way to diagnose build failures is by accessing the detailed logs in your Azure DevOps pipeline. Click on the failing check and then use the 'view details' link to locate the specific error message.\n\n2. **Common Causes**:\n   - **Naming Violations**: .NET SDK generation often fails due to naming convention issues. Review the log output for violations and consult the official [Naming Conventions](https://github.com/Azure/azure-sdk-for-net/blob/main/doc/dev/Mgmt-Naming-Conventions.md).\n   - **Polishing Configurations**: You may need to adjust your SDK specs according to the [Polishing Configurations](https://github.com/Azure/azure-sdk-for-net/blob/main/doc/dev/Mgmt-Polishing-Configurations.md) to resolve naming or other structural issues.\n   - **Compatibility Issues**: If you encounter compatibility errors that AutoRest can't handle, file an issue in [Azure/azure-sdk-for-net](https://github.com/Azure/azure-sdk-for-net) for support.\n   - **Import Resolution Errors**: If the error pattern includes `import-not-found`, make sure your `tspconfig.yaml` is correctly configured, especially the `additionalDirectories` array.\n\n3. **Next Steps**:\n   - Review the build log for the exact error message.\n   - If the error is unclear or not addressed above, ask in the .NET language team's channel for direct help with your PR and build failures.\n   - Reference the official troubleshooting and support guidance for further help.\n\nIf you provide the exact error message, I can offer more targeted advice for your .NET SDK build failure.", "inputs.context": "[{\"document_source\":\"typespec_docs\",\"document_filename\":\"extending-typespec#diagnostics.md\",\"document_title\":\"Diagnostics\",\"document_link\":\"https://typespec.io/docs/extending-typespec/diagnostics\",\"content\":\"# extending-typespec#diagnostics.md\\n\\n# Diagnostics\\n\\nThe TypeSpec compiler uses the diagnostic API to report errors and warnings in the specification.\\n\\n## Best practices\\n\\n- ❌ Avoid using `throw` to report errors. Any exceptions thrown in this manner will be perceived as bugs in your library by the user.\\r\\n- ✅ Utilize the diagnostic API to report anticipated errors and warnings.\\r\\n  - ✅ Employ `reportDiagnostic` in a decorator, `$onValidate` or `$onEmit`\\r\\n  - ❌ Refrain from using `reportDiagnostic` in an accessor (a function intended to be used in another library or emitter). Refer to the [section on collecting diagnostics](#collect-diagnostics) for more information.\\n\\n## Diagnostic requirements\\n\\n- Each diagnostic MUST have a `code`. The complete code is the library name followed by the declared code. (`\\u003clib-name\\u003e/\\u003clocal-code\\u003e`)\\r\\n- Each diagnostic MUST have a `severity`. It can be `error` or `warning`. Errors cannot be suppressed.\\r\\n- Each diagnostic MUST have at least one message. Using `default` as the `messageId` will make it the default selection.\\r\\n- Each diagnostic message MAY have parameters to interpolate information into the message.\\n\\n## How to use\\n\\n### Declare the diagnostics you plan to report\\n\\n```ts\\r\\nimport { createTypeSpecLibrary } from \\\"@typespec/compiler\\\";\\r\\n\\r\\n// in lib.js\\r\\nexport const $lib = createTypeSpecLibrary({\\r\\n  name: \\\"@typespec/my-lib\\\",\\r\\n  diagnostics: {\\r\\n    // Basic diagnostic with a fixed message\\r\\n    \\\"no-array\\\": {\\r\\n      severity: \\\"error\\\",\\r\\n      messages: {\\r\\n        default: `Array is not allowed in my-lib models.`,\\r\\n      },\\r\\n    },\\r\\n\\r\\n    // Parameterized message\\r\\n    \\\"duplicate-route\\\": {\\r\\n      severity: \\\"error\\\",\\r\\n      messages: {\\r\\n        default: paramMessage`Route '${\\\"path\\\"}' is being referenced in 2 different operations.`,\\r\\n      },\\r\\n    },\\r\\n\\r\\n    // Multiple messages\\r\\n    \\\"duplicate-name\\\": {\\r\\n      severity: \\\"warning\\\",\\r\\n      messages: {\\r\\n        default: paramMessage`Duplicate type name: '${\\\"value\\\"}'.`,\\r\\n        parameter: paramMessage`Duplicate parameter key: '${\\\"value\\\"}'.`,\\r\\n      },\\r\\n    },\\r\\n  },\\r\\n} as const);\\r\\n\\r\\n// Re-export the helper functions to be able to just call them directly.\\r\\nexport const { reportDiagnostic, createDiagnostic };\\r\\n```\\r\\n\\r\\nThis will represent three different diagnostics with the full names of:\\r\\n\\r\\n- `@typespec/my-lib/no-array`\\r\\n- `@typespec/my-lib/duplicate-route`\\r\\n- `@typespec/my-lib/duplicate-name`\\n\\n### Report diagnostics\\n\\n```ts\\r\\nimport { reportDiagnostic } from \\\"./lib.js\\\";\\r\\n\\r\\n// Basic diagnostic with a fixed message\\r\\nreportDiagnostic(program, {\\r\\n  code: \\\"no-array\\\",\\r\\n  target: diagnosticTarget,\\r\\n});\\r\\n\\r\\n// Parameterized message\\r\\nreportDiagnostic(program, {\\r\\n  code: \\\"duplicate-route\\\",\\r\\n  format: {path: \\\"/foo\\\"}\\r\\n  target: diagnosticTarget,\\r\\n});\\r\\n\\r\\n// Multiple messages\\r\\nreportDiagnostic(program, {\\r\\n  code: \\\"duplicate-name\\\",\\r\\n  messageId: \\\"parameter\\\",\\r\\n  format: {value: \\\"$select\\\"},\\r\\n  target: diagnosticTarget,\\r\\n});\\r\\n```\\n\\n### Collect diagnostics\\n\\nWhen attempting to report a diagnostic in an accessor, a good practice is not to report the diagnostic to the program directly, but return a tuple to let the user decide what to do.\\r\\nThis prevents duplicate diagnostics emitter if the accessor is called multiple times.\\r\\n\\r\\n```ts\\r\\nimport { createDiagnosticCollector, Diagnostic } from \\\"@typespec/compiler\\\";\\r\\n\\r\\nfunction getRoutes(): [Route, readonly Diagnostic] {\\r\\n  const diagnostics = createDiagnosticCollector();\\r\\n  diagnostics.add(\\r\\n    createDiagnostic(program, {\\r\\n      code: \\\"no-array\\\",\\r\\n      target: diagnosticTarget,\\r\\n    }),\\r\\n  );\\r\\n  const result = diagnostic.pipe(getParameters()); // to pipe diagnostics returned by `getParameters`\\r\\n  return diagnostics.wrap(routes);\\r\\n}\\r\\n```\\r\\n\\r\\nor manually\\r\\n\\r\\n```ts\\r\\nimport { Diagnostic } from \\\"@typespec/compiler\\\";\\r\\n\\r\\nfunction getRoutes(): [Route, readonly Diagnostic] {\\r\\n  const diagnostics = [];\\r\\n  diagnostics.push(\\r\\n    createDiagnostic(program, {\\r\\n      code: \\\"no-array\\\",\\r\\n      target: diagnosticTarget,\\r\\n    }),\\r\\n  );\\r\\n  return [routes, diagnostics];\\r\\n}\\r\\n```\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Validation.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation\",\"content\":\"# SDK-Validation.md\\n\\n| Short Link: | [aka.ms/azsdk/sdk-automation-faq](https://aka.ms/azsdk/sdk-automation-faq) |\\r\\n|--|--|\\n\\n# Table of Contents\\n\\n- [How to Re-run SDK Validation Checks](#how-to-re-run-sdk-validation-checks)\\r\\n- [How to Re-evaluate `SDK Validation Status` Check](#how-to-re-evaluate-sdk-validation-status-check)\\r\\n- [How to Download the Generated Artifacts](#how-to-download-the-generated-artifacts)\\r\\n  - [Prerequisites](#prerequisites)\\r\\n  - [Steps to Download Artifacts](#steps-to-download-artifacts)\\r\\n- [How to View the Html Report of `SDK Validation` Checks Result](#how-to-view-the-html-report-of-sdk-validation-checks-result)\\r\\n- [How to View the Detailed SDK Generation Errors](#how-to-view-the-detailed-sdk-generation-errors)\\r\\n- [Use Pipeline to Create SDK Pull Request from Your API Specs](#use-pipeline-to-create-sdk-pull-request-from-your-api-specs)\\r\\n- [Common Error Fix Guidance](#common-error-fix-guidance)\\r\\n - [Import Resolution Errors](#import-resolution-errors)\\r\\n   - [Error Pattern: `import-not-found`](#error-pattern-import-not-found)\\r\\n- [.NET SDK Generation Error Fix Guidance](#net-sdk-generation-error-fix-guidance)\\r\\n  - [How to Fix Naming Violations for Management Plane SDK](#how-to-fix-naming-violations-for-management-plane-sdk)\\n\\n## How to Re-run SDK Validation Checks\\n\\nTo trigger a re-run of a specific SDK Validation check, add a comment in the format: `/azp run SDK Validation - {Language}`\\r\\nFor example, commenting `/azp run SDK Validation - Go` will initiate a new run of the \\\"SDK Validation - Go\\\" check.\\n\\n## How to Re-evaluate `SDK Validation Status` Check\\n\\nRe-running any `SDK Validation` checks will automatically re-evaluate the `SDK Validation Status` check. If you don't see any `SDK Validation - {Language}` checks in your PR's checklist, it means you don't have the required permission to trigger them. Refer to the instructions at https://aka.ms/azsdk/access to get the necessary write access. Additionally, make sure your membership in the `Azure` GitHub organization is set to _public_, for example, you can verify your membership visibility on [Azure](https://github.com/orgs/Azure/people?query=) page.\\n\\n## How to Download the Generated Artifacts\\n\\n### Prerequisites\\n\\nEnsure the **SDK Validation** CI check succeeds. If the check fails, the artifacts might not have been generated.\\n\\n### Steps to Download Artifacts\\n\\nLet's take Python as an example.\\r\\n\\r\\n1. Navigate to `Checks` page: click on the **Checks** tab in the navigation pane of the pull request.\\r\\n   ![image](https://github.com/user-attachments/assets/109f7d90-52f6-45ed-ac12-ce2ae3e49af8)\\r\\n\\r\\n2. View the **SDK Validation - Python** check result: click on the `SDK Validation - Python` item\\r\\n in the left CI check list.\\r\\n   ![image](https://github.com/user-attachments/assets/3beb796f-0d53-4ad7-8f4c-d01657f283b4)\\r\\n\\r\\n3. View Azure DevOps Build Pipeline Run: click on the `Pipeline result` link.\\r\\n   ![image](https://github.com/user-attachments/assets/ff4512be-e49d-4d48-bb13-0b9898258d0b)\\r\\n\\r\\n4. Access Artifacts Page: click on the `artifacts` link.\\r\\n   ![image](https://github.com/Azure/azure-rest-api-specs/assets/20296335/b2c4c307-a430-4dec-bb09-5ac7e659a418)\\r\\n\\r\\n5. Locate Generated Artifacts:\\r\\n   The generated artifacts for Python are located under the **Packages** folder.\\r\\n   ![image](https://github.com/user-attachments/assets/a6f1d800-4b3a-42ff-863a-45b50c201047)\\n\\n## How to View the Html Report of `SDK Validation` Checks Result\\n\\n1. Refer to the former `Steps to Download Artifacts` to download html report file.\\r\\n    ![image](https://github.com/user-attachments/assets/a8dfc245-333c-497f-a0a2-f7e2451b3863)\\r\\n\\r\\n2. The html report is like this screenshot:\\r\\n    ![image](https://github.com/user-attachments/assets/b0c50b7f-6ce7-4276-a2fb-2fa55d3b69c7)\\n\\n## How to View the Detailed SDK Generation Errors\\n\\n1. Open the Azure DevOps Build Pipeline Run: click the `Pipeline result` link.\\r\\n   ![image](https://github.com/user-attachments/assets/64caa353-a54c-4ebb-b8fa-800d50ae5dfe)\\r\\n\\r\\n2. Examine the Pipeline Run Log: click directly on the `error` entry directly.\\r\\n   ![Image](https://github.com/user-attachments/assets/42627c1e-6610-4bb3-9cf4-c7c4209080d7)\\r\\n\\r\\n3. Review Detailed Log Information: expand the log group immediately above the error summary group.\\r\\n   ![Image](https://github.com/user-attachments/assets/d9ea22f3-bdd1-42a0-9610-c9cd0339b8e5)\\n\\n## Use Pipeline to Create SDK Pull Request from Your API Specs\\n\\nFor detailed instructions, please refer to [Using the SDK Generation Pipelines](https://aka.ms/azsdk/spec-gen-sdk-pipeline-doc).\\n\\n## Common Error Fix Guidance\\n\\n### Import Resolution Errors\\n\\n#### Error Pattern: `import-not-found`\\r\\n\\r\\n**Error Message Pattern**: `error import-not-found: Couldn't resolve import '[.*].tsp'`\\r\\n\\r\\n**Root Cause**: The folder containing the imported TypeSpec files is not specified in the `tspconfig.yaml` file's `additionalDirectories` setting.\\r\\n\\r\\n**Solution Steps**:\\r\\n\\r\\n1. Locate the `tspconfig.yaml` file in your TypeSpec project root\\r\\n2. Find the `additionalDirectories` array in the configuration\\r\\n3. Add the path to the folder containing the imported `.tsp` files\\r\\n4. Ensure the path is relative to the `tspconfig.yaml` file location\\r\\n**Reference**: [Sample tspconfig.yaml](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L52)\\n\\n## .NET SDK Generation Error Fix Guidance\\n\\n### How to Fix Naming Violations for Management Plane SDK\\n\\nIf your pipeline run logs already outline the naming violations, simply locate the reported issues and proceed as follows:\\r\\n\\r\\n1. **Review the Pipeline Logs:**\\r\\n   Identify the naming violations highlighted in the log output.\\r\\n\\r\\n2. **Consult Naming Conventions:**\\r\\n   Familiarize yourself with the [Naming Conventions](https://github.com/Azure/azure-sdk-for-net/blob/main/doc/dev/Mgmt-Naming-Conventions.md)\\r\\n    guidelines to understand the expected naming rules.\\r\\n\\r\\n3. **Apply Polishing Configurations:**\\r\\n   Use the [Polishing Configurations](https://github.com/Azure/azure-sdk-for-net/blob/main/doc/dev/Mgmt-Polishing-Configurations.md)\\r\\n    as a reference to adjust your SDK naming as per the conventions.\\r\\n\\r\\n4. **Update and Validate:**\\r\\n   Modify the specs to correct the naming issues and run the CI checks again to confirm that all violations have been resolved.\"},{\"document_source\":\"azure_sdk_for_go_docs\",\"document_filename\":\"development#TROUBLESHOOTING.md\",\"document_title\":\"Azure Go SDK Automation Troubleshooting Guide\",\"document_link\":\"https://github.com/Azure/azure-sdk-for-go/blob/main/documentation/development/TROUBLESHOOTING.md\",\"content\":\"# development#TROUBLESHOOTING.md\\n\\n# Azure Go SDK Automation Troubleshooting Guide\\n\\n## Overview\\n\\nThe Azure Go SDK automation tool:\\r\\n\\r\\n- Generates Go SDK code from TypeSpec/OpenAPI specifications\\r\\n- Creates changelogs for API updates\\r\\n- Detects breaking changes automatically\\n\\n## Log Structure Analysis\\n\\n### Key Log Keywords\\n\\n1. **Start Marker**: `Reading generate input file from`\\r\\n2. **Code Generation For TypeSpec**: `Start to process typespec project`\\r\\n3. **Code Generation For Swagger**: `Start to process swagger project`\\n\\n### Success Indicators\\n\\n- **For Each TypeSpec Specification's Generation**: `Finish processing typespec project`\\r\\n- **For Each Swagger Specification's Generation**: `Finish processing swagger project`\\r\\n- **Output File**: contains both changelog details and breaking changes summary\\n\\n### Failure Indicators\\n\\n- Any `[ERROR]` messages in the log\\r\\n- Non-zero exit codes\\r\\n- Exception stack traces\\n\\n## Error Classification and Resolution\\n\\n### 1. Internal Errors\\n\\n**Log Keywords**: `The emitter encountered an internal error during preprocessing.`\\r\\n\\r\\n**Context**: This indicates a failure in the TypeSpec emitter, which should be a bug in the `@azure-tools/typespec-go` package.\\r\\n\\r\\n**Analysis Actions**:\\r\\n\\r\\n- Extract package information\\r\\n- Capture complete error message and stack trace\\r\\n- Identify the failing emitter component\\r\\n\\r\\n**Resolution**: File issue at https://github.com/Azure/autorest.go/issues with:\\r\\n\\r\\n- Complete error details\\r\\n- Package/service context\\r\\n- Stack trace information\\n\\n### 2. TypeSpec Configuration Errors\\n\\n#### Invalid Emitter Arguments\\r\\n\\r\\n**Log Keywords**: `Invalid arguments were passed to the emitter.`\\r\\n\\r\\n**Context**: This happens when config is not set correctly.\\r\\n\\r\\n**Analysis Actions**:\\r\\n\\r\\n- Check the error log to see which config is wrong.\\r\\n- Refer the [doc](https://azure.github.io/typespec-azure/docs/emitters/clients/typespec-go/reference/emitter/#emitter-options) for the usage of emitter config\\r\\n- Compare against standard templates:\\r\\n  - [Management Plane Template](https://github.com/Azure/azure-rest-api-specs/blob/a8f97793186c7680c62519da238c6d07a20f2023/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L35)\\r\\n  - [Data Plane Template](https://github.com/Azure/azure-rest-api-specs/blob/a8f97793186c7680c62519da238c6d07a20f2023/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L41)\\r\\n\\r\\n**Resolution**: Fix `@azure-tools/typespec-go` configuration in `tspconfig.yaml`\\r\\n\\r\\n#### Module Path Errors\\r\\n\\r\\n**Log Keywords**: `module not found, package path:`\\r\\n\\r\\n**Context**: This happens when emitter could not resolve the package you want to generate through configs.\\r\\n\\r\\n**Analysis Actions**:\\r\\n\\r\\n- Validate module path configuration\\r\\n- Check service directory structure\\r\\n- Verify package directory alignment\\r\\n- Refer the [doc](https://azure.github.io/typespec-azure/docs/emitters/clients/typespec-go/reference/emitter/#emitter-options) for the usage of emitter config\\r\\n\\r\\n**Resolution**: Correct these `tspconfig.yaml` properties:\\r\\n\\r\\n- `module`: Go module path\\r\\n- `service-dir`: Service directory path\\r\\n- `package-dir`: Package directory path\\r\\n- `module-version`: Module version\\n\\n### 3. Naming Collision Errors\\n\\n**Log Keywords**: `The emitter automatically renamed one or more types which resulted in a type name collision.`\\r\\n\\r\\n**Context**: Go SDK automatically removes service name prefixes to prevent stuttering (e.g., `armcompute.ComputeDisk` → `armcompute.Disk`)\\r\\n\\r\\n**Analysis Actions**:\\r\\n\\r\\n- Identify conflicting type names\\r\\n- Locate the original model definitions\\r\\n- Determine rename conflicts\\r\\n\\r\\n**Resolution**: Rename conflicting models in `client.tsp` using `@clientName` decorator\\n\\n### 4. Unsupported TypeSpec Features\\n\\n**Log Keywords**: `UnsupportedTsp`\\r\\n\\r\\n**Common Unsupported Features**:\\r\\n\\r\\n- Paging with re-injected parameters\\r\\n- Cookie parameters\\r\\n\\r\\n**Analysis Actions**:\\r\\n\\r\\n- Identify specific unsupported feature\\r\\n- Review error message for feature details\\r\\n\\r\\n**Resolution**: Modify TypeSpec authoring to use supported patterns if possible, or wait for emitter support.\"},{\"document_source\":\"azure_sdk_for_python_docs\",\"document_filename\":\"dev#issues#resolve_issues_effectively.md\",\"document_title\":\"Resolve Issues Effectively\",\"document_link\":\"https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/issues/resolve_issues_effectively.md\",\"content\":\"# dev#issues#resolve_issues_effectively.md\\n\\n# Resolve Issues Effectively\\n\\nAzure Python SDK is an open-source project. It allows users to create issues in the forum to ask questions, report bugs and provide feedback.\\r\\n\\r\\nMost issues can be classified into 3 categories. They are\\r\\n\\r\\n1. Usage error.\\r\\n2. Feature request.\\r\\n3. Bug report.\\n\\n## Usage error (For users)\\n\\nIf you are not familiar with the SDK usage of a service, you can find relevant examples in [this repo][sample repo] in most cases.\\r\\n\\r\\nFor some common errors, you can check [here](#summary-of-common-errors).\\n\\n## Feature Request (For users)\\n\\nPython SDKs are automatically generated based on REST API, so we generally do not recommend modifying SDK code manually. If you need a new function, but the SDK does not provide it, you need to open an issue in the [REST API repository](https://github.com/Azure/azure-rest-api-specs/issues) to describe clearly the feature you want.\\n\\n## Bug Report (For users)\\n\\nPlease describe the bug in as much detail as possible, such as listing the SDK package name, version and operating system info you use.\\r\\n\\r\\nIf you can provide detailed reproduction steps, it will help us locate and solve the issue.\\n\\n## Summary Of Common Errors\\n\\n### Error from Track1 to Track2\\n\\nIf the code you use needs to set wait() function for the Long Running Operation to wait for the result, it should be the SDK of Track1. We have stopped maintenance at present.\\r\\n\\r\\nWe strongly recommend that you update the SDK version. Then you will find that in the SDK of Track2, we all use the function name prefixed with `begin_` for LRO operations, and the result() method can be used to get the returned result.\\r\\n(More Details: [guidance][guidance])\\n\\n### Possible Error from Service\\n\\nSince the python SDK is generated based on the [rest API][rest API], it will not deliberately change the returned results. So if you think the returned result is not as expected, please open the issue under the [rest issue][rest issue].\\r\\n\\r\\n\\u003chr/\\u003e\\n\\n## Resolve issue (For contributors)\\n\\nBug report is one of the most common issues reported in open-source community. Basic steps to resolve a bug report are\\r\\n\\r\\n1. Confirm the bug.\\r\\n2. Locate the fault.\\r\\n3. Fix the bug.\\n\\n### Confirm the Bug\\n\\nConfirm whether it is a bug. If you can definitely identify it is a bug according description of the issue, then go to next step. Otherwise, try to reproduce the bug by yourself. You can ask the issue reporter for details such as version, concrete steps and logs so that you can understand the issue better and it is more likely to be able to reproduce the bug. It is not rare that it is not a bug. Instead, it is a usage error. Refer to \\\"Usage Error\\\" section.\\n\\n### Locate the Fault\\n\\nFault localization is critical to bug fix. Some tips:\\r\\n\\r\\n1. Analyzing logs. It helps you understand the bug.\\r\\n\\r\\n2. Step-by-step debugging. Most modern IDEs provide integrated debugging experience.\\n\\n### Fix the bug\\n\\nOnce you have confirmed the bug and found the fault location, it should be easy to fix the bug. Add a sample if it is missing. Remember to tell users when the fix will released.\\n\\n## Common Principles\\n\\nIf the issue is not from the SDK but from the [rest API][rest API], you can reply to the user and reopen the issue in the appropriate place.\\n\\n### Error like (AttributeError: 'PipelineResponse' object has no attribute 'get')\\n\\nWhen this error occurs, you can check the version of `msrest` and upgrade it to latest version then try again.\\r\\n\\r\\n\\r\\n[sample repo]: https://github.com/Azure-Samples/azure-samples-python-management\\r\\n[rest API]: https://github.com/Azure/azure-rest-api-specs\\r\\n[rest issue]: https://github.com/Azure/azure-rest-api-specs/issues\\r\\n[SDK dependency]: https://github.com/Azure/azure-sdk-for-python/blob/main/shared_requirements.txt\\r\\n[guidance]: https://devblogs.microsoft.com/azure-sdk/migrating-python-management-libraries/\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#troubleshoot#PR-failing.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/troubleshoot/PR-failing\",\"content\":\"# support#troubleshoot#PR-failing.md\\n\\n\\u003c!-- markdownlint-disable MD026 --\\u003e\\n\\n# I've submitted a pull request, but the build isn't succeeding or tests are failing!\\n\\n\\u003e [!NOTE]\\r\\n\\u003e If you are looking for help with a PR submitted to one of [the Azure REST API specs repositories](xref:api-repos),\\r\\n\\u003e please refer to [this support page](xref:support#get-help-with-prs-submitted-against-the-azure-rest-api-specification-repositories).\\r\\n\\r\\nCongratulations! You've submitted a pull request. As part of the pull request approval process we ensure that the code\\r\\nbuild and tests successfully, as well as performing a range of other validation steps. Generally speaking the build\\r\\nerrors associated with the pipeline run are sufficient to diagnose and fix any issues with your PR. You can access\\r\\nthe build logs by clicking on the failing check run, and then using the view details link to navigate to the error in\\r\\nAzure Pipelines.\\r\\n\\r\\nIf you cannot understand the reason for the failure, ask a question in the _language team_ channel appropriate to the\\r\\nrepository that you are working in. Each language team is the first point of contact for build failures within their\\r\\nrepository.\\r\\n\\r\\nReach to the [language specific Team's channel](xref:support#get-help-with-the-azure-sdks-development).\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_12.md\",\"document_title\":\"SDK Validation steps are failing with not much helpful logs\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_12.md\\n\\n# SDK Validation steps are failing with not much helpful logs\\n\\n## question\\n\\nWe’re in the process of creating a new API version within our RP. However, all SDK-related checks are currently failing, and we’re unable to identify any issues flagged in our changes.\\r\\n \\r\\nCould you please assist us in resolving these failures at the earliest? Your support will help us move forward without further delays.\\r\\n\\r\\n```\\r\\nErrors occurred while generating SDK from specification/advisor. Follow the steps at https://aka.ms/azsdk/sdk-automation-faq#how-to-view-the-detailed-sdk-generation-errors to view detailed errors.\\r\\n[ERROR] total 1 error(s):\\r\\n[ERROR] failed to execute `tsp-client init --update-if-exists --tsp-config /mnt/vss/_work/1/s/azure-rest-api-specs-pr/specification/advisor/Advisor.Management/tspconfig.yaml --commit 028d4d7cae9471f24a06aea6a1f60bf01f37f567 --repo Azure/azure-rest-api-specs-pr --local-spec-repo /mnt/vss/_work/1/s/azure-rest-api-specs-pr/specification/advisor/Advisor.Management --emitter-options module-version=0.1.0 --debug`\\r\\n[ERROR] Please update your tspconfig.yaml to include the \\\"emitter-output-dir\\\" option under the \\\"@azure-tools/typespec-go\\\" emitter options. \\\"package-dir\\\" support is deprecated and will be removed in future versions.\\r\\n[ERROR] Error reading tsp-location.yaml: Error: ENOENT: no such file or directory, stat '/mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/tsp-location.yaml'\\r\\n[ERROR] Diagnostics were reported during compilation. Use the `--debug` flag to see if there is warning diagnostic output.\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\n\\noutput.\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:10:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:10:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n```\\r\\n\\r\\n```\\r\\nSome checks were not successful\\r\\n7 failing, 2 pending, 1 queued, 31 successful checks\\r\\n\\r\\n7 failing checks\\r\\nprivate.rest-api-specs-pr Failing after 1m — Build #Azure OpenAPI failed\\r\\nprivate.rest-api-specs-pr (BranchProtectionForPrivateRepo) Failing after 1m — BranchProtectionForPriv...\\r\\nSDK Validation - .NET - PR Failing after 7m — Build #20250911.25 failed\\r\\nSDK Validation - Go - PR Failing after 4m — Build #20250911.25 failed\\r\\nSDK Validation - Java - PR Failing after 4m — Build #20250911.25 failed\\r\\nSDK Validation - JS - PR Failing after 3m — Build #20250911.25 failed\\r\\nSDK Validation - Python - PR Failing after 7m — Build #20250911.25 failed\\r\\n\\r\\nMerging is blocked\\r\\n```\\r\\n\\r\\nPR: [Advisor Risks : 2025-09-01-preview by pranatiy0701 · Pull Request #24395 · Azure/azure-rest-api-spe…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24395)\\n\\n## answer\\n\\nIt looks like your PR is against the main branch of the private repo - we don't check api specs into this branch.  The sdk failures for flattenProperty are due to those SDKs not being up-to-date with the latest version of typespec-client-generator-core, which was released earlier this week.  Since you are not checking this spec in to the main branch of the private repo, these can be safely ignored.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_17.md\",\"document_title\":\"Unknown decorator @flattenProperty\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_17.md\\n\\n# Unknown decorator @flattenProperty\\n\\n## question\\n\\nI'm getting the below errors and something like this, which I had never run into before.  The target branch (which I based my dev branch from) of my PR didn't run into that either.  Looking for some advice or clue about what is causing this and how to fix, or perhaps bypass them.\\r\\n```\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:49:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:52:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:45:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:47:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n```\\r\\nhttps://github.com/Azure/azure-rest-api-specs/pull/37909\\n\\n## answer\\n\\nyour release branch has fallen far behind main.  it will need to be updated or recreated. \\r\\nyou can try this, but if your release branch is too old, it will likely need to be recreated \\r\\nhttps://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish#update-your-branch-with-changes-from-main\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_12.md\",\"document_title\":\"SDK Validation steps are failing with not much helpful logs\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_12.md\\n\\n# SDK Validation steps are failing with not much helpful logs\\n\\n## question\\n\\nWe’re in the process of creating a new API version within our RP. However, all SDK-related checks are currently failing, and we’re unable to identify any issues flagged in our changes.\\r\\n \\r\\nCould you please assist us in resolving these failures at the earliest? Your support will help us move forward without further delays.\\r\\n\\r\\n```\\r\\nErrors occurred while generating SDK from specification/advisor. Follow the steps at https://aka.ms/azsdk/sdk-automation-faq#how-to-view-the-detailed-sdk-generation-errors to view detailed errors.\\r\\n[ERROR] total 1 error(s):\\r\\n[ERROR] failed to execute `tsp-client init --update-if-exists --tsp-config /mnt/vss/_work/1/s/azure-rest-api-specs-pr/specification/advisor/Advisor.Management/tspconfig.yaml --commit 028d4d7cae9471f24a06aea6a1f60bf01f37f567 --repo Azure/azure-rest-api-specs-pr --local-spec-repo /mnt/vss/_work/1/s/azure-rest-api-specs-pr/specification/advisor/Advisor.Management --emitter-options module-version=0.1.0 --debug`\\r\\n[ERROR] Please update your tspconfig.yaml to include the \\\"emitter-output-dir\\\" option under the \\\"@azure-tools/typespec-go\\\" emitter options. \\\"package-dir\\\" support is deprecated and will be removed in future versions.\\r\\n[ERROR] Error reading tsp-location.yaml: Error: ENOENT: no such file or directory, stat '/mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/tsp-location.yaml'\\r\\n[ERROR] Diagnostics were reported during compilation. Use the `--debug` flag to see if there is warning diagnostic output.\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\n\\noutput.\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:10:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:10:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n```\\r\\n\\r\\n```\\r\\nSome checks were not successful\\r\\n7 failing, 2 pending, 1 queued, 31 successful checks\\r\\n\\r\\n7 failing checks\\r\\nprivate.rest-api-specs-pr Failing after 1m — Build #Azure OpenAPI failed\\r\\nprivate.rest-api-specs-pr (BranchProtectionForPrivateRepo) Failing after 1m — BranchProtectionForPriv...\\r\\nSDK Validation - .NET - PR Failing after 7m — Build #20250911.25 failed\\r\\nSDK Validation - Go - PR Failing after 4m — Build #20250911.25 failed\\r\\nSDK Validation - Java - PR Failing after 4m — Build #20250911.25 failed\\r\\nSDK Validation - JS - PR Failing after 3m — Build #20250911.25 failed\\r\\nSDK Validation - Python - PR Failing after 7m — Build #20250911.25 failed\\r\\n\\r\\nMerging is blocked\\r\\n```\\r\\n\\r\\nPR: [Advisor Risks : 2025-09-01-preview by pranatiy0701 · Pull Request #24395 · Azure/azure-rest-api-spe…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24395)\\n\\n## answer\\n\\nIt looks like your PR is against the main branch of the private repo - we don't check api specs into this branch.  The sdk failures for flattenProperty are due to those SDKs not being up-to-date with the latest version of typespec-client-generator-core, which was released earlier this week.  Since you are not checking this spec in to the main branch of the private repo, these can be safely ignored.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"API-Doc-Preview.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/API-Doc-Preview\",\"content\":\"## How do I troubleshoot docs build problems?\\nFollow instructions at [Troubleshooting REST API documentation\\r\\n](https://eng.ms/docs/products/azure-developer-experience/design/api-docs-troubleshooting)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#troubleshoot#engsys.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/troubleshoot/engsys\",\"content\":\"# Help! The engineering system itself is broken\\nOh no! This happens from time to time when one of our dependencies (e.g. Maven Central or Azure Pipelines) goes offline\\r\\nor starts having service issues. It is also possible for the Engineering System team to inadvertently introduce\\r\\na problem which breaks our build and release pipelines.\\r\\n\\r\\nIf you believe that the engineering system itself is failing\\r\\n(as opposed to something in your PR causing a build/test failure), reach out to the Azure SDK Engineering System team.\\r\\nOur preferred method is for you to drop a message in our Teams Channel.\\r\\n\\r\\n- [Azure SDK / Engineering System]\\r\\n\\r\\nNote that when one of our dependencies goes offline we often just need to wait the issue out unless there is a simple\\r\\nmitigation. You can see the latest status updates for many of our dependencies on this channel:\\r\\n\\r\\n- [Azure SDK / System Status]\\r\\n\\r\\nFor tools connected with the REST API specs used in the [Azure/azure-rest-api-specs] repo refer to:\\r\\n\\r\\n- [This support page](xref:support#get-help-with-prs-submitted-against-the-azure-rest-api-specification-repositories)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#support.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/support\",\"content\":\"# Get help and support\\n\\u003c!-- A short description of this page (fewer than 50 words) that describes the main learning goal or task that readers\\r\\nwill complete. --\\u003e\\r\\n\\r\\nIf you have problems or questions when using Azure SDK tools or releasing your updates, you can get help by following\\r\\nguidance provided in this article.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-generate-mgmt-dotnet.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-generate-mgmt-dotnet\",\"content\":\"# Generate .NET management plane SDK\\n## Generate SDKs with OpenAPI\\n- Specify a target version using `tag` as belows if you don't want to use the default tag in [the README configuration file](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/README.md). For example,\\r\\n\\r\\n```\\r\\ntag: package-2022-01-01-preview\\r\\n```\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e To ensure the preview of the corresponding .NET SDK in the API Spec PR, refrain from adding the tag here. Instead, use the default tag to generate the SDK and preview it as desired.\\r\\n\\r\\n2. Run `dotnet build` command to generate the SDK code, then AutoRest will create your .NET SDK using the latest version of your API specs.\\r\\n\\r\\n```\\r\\ndotnet build /t:GenerateCode\\r\\n```\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e Currently there could be some compatibility issues that the AutoRest tool can't handle. If you encounter generation errors, file an issue in the GitHub Repo [Azure/azure-sdk-for-net](https://github.com/Azure/azure-sdk-for-net) to get support.\\r\\n\\r\\n3. Generate the API file with the following command, review it and update any SDK API if it does not follow the [.NET Azure SDK Design Guidelines](https://azure.github.io/azure-sdk/dotnet_introduction.html) with [mgmt configurations](https://github.com/Azure/autorest.csharp/blob/feature/v3/docs/mgmt/readme.md#management-plane-configurations) in `autorest.md`. Then regenerate the API file.\\r\\n\\r\\n```\\r\\n\\u003cRepoRoot\\u003e\\\\eng\\\\scripts\\\\Export-API.ps1 servicelinker\\r\\n```\\r\\n\\r\\n:point_right: Replace `servicelinker` with your SDK service directory name under azure-sdk-for-net\\\\sdk.\\r\\n\\r\\n4. Once the SDK is generated, build your project either in VS or from command line (follow steps in the section [Build \\u0026 test SDKs](#build--test-sdks)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#known-issues.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/known-issues\",\"content\":\"# Known issues and limitations\\nAzure SDK tools include the following known issues and limitations that might impact your experience.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-docs-troubleshooting.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-docs-troubleshooting\",\"content\":\"# Troubleshooting REST API documentation\\n## **Swagger ApiDocPreview** build is failing\\n### To fix **Swagger ApiDocPreview** build failures\\nIf you see an error here and cannot understand the error message, file an issue with the docs team that owns the tool:\\r\\n\\r\\n1. Visit the [SiteHelp Portal](https://aka.ms/sitehelp).\\r\\n1. Click the **Submit request or issue** button.\\r\\n1. For **Where the change is needed or where the issue happens?** select **Content authoring and publishing** and in the **Select Service Category** dropdown select **Reference CI Jobs**.\\r\\n1. Enter a title for the request in **What is the request or issue?**\\r\\n1. In the **Tell us more** field, state that the build is failing and that you need help understanding the error message.\\r\\n1. Click **Submit**.\\r\\n\\r\\nA new IcM ticket will be created on your behalf. Watch the ticket for updates from the docs team.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-develop.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop\",\"content\":\"# Develop client libraries (SDK)\\n## Get help\\n- If you need help with an automation tool or the Release planner, reach out to \\r\\n[Azure SDK / Azure SDK Onboarding](https://aka.ms/azsdk/support/onboarding-channel) channel.\\r\\n- If you need help with the development of the SDKs reach out to the [language specific Team's channel](xref:support#get-help-with-the-azure-sdks-development).\\r\\n- If you need to request an exception for a language review the [request release exception](xref:request-exception).\"}]", "inputs.latency": 1013.8822975158691, "inputs.response_length": 1789, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation", "https://eng.ms/docs/products/azure-developer-experience/support/troubleshoot/PR-failing", "https://eng.ms/docs/products/azure-developer-experience/develop/sdk-generate-mgmt-dotnet"], "inputs.testcase": "SDK release help", "outputs.similarity.similarity": 3.0, "outputs.similarity.gpt_similarity": 3.0, "outputs.similarity.similarity_result": "fail", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1346, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1347, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: SDK release help\\\\n\\\\nquestion: Hi,  I got an error with .NET SDK generation. Here is the log https://dev.azure.com/azure-sdk/internal/_build/results?buildId=5634535&view=results\\\", \\\"response\\\": \\\"Sorry, I can't access the content of external build logs or links directly. However, I can guide you through diagnosing and resolving .NET SDK generation build failures based on standard Azure SDK practices.\\\\n\\\\n1. **Check the Pipeline Logs**: The primary way to diagnose build failures is by accessing the detailed logs in your Azure DevOps pipeline. Click on the failing check and then use the 'view details' link to locate the specific error message.\\\\n\\\\n2. **Common Causes**:\\\\n   - **Naming Violations**: .NET SDK generation often fails due to naming convention issues. Review the log output for violations and consult the official [Naming Conventions](https://github.com/Azure/azure-sdk-for-net/blob/main/doc/dev/Mgmt-Naming-Conventions.md).\\\\n   - **Polishing Configurations**: You may need to adjust your SDK specs according to the [Polishing Configurations](https://github.com/Azure/azure-sdk-for-net/blob/main/doc/dev/Mgmt-Polishing-Configurations.md) to resolve naming or other structural issues.\\\\n   - **Compatibility Issues**: If you encounter compatibility errors that AutoRest can't handle, file an issue in [Azure/azure-sdk-for-net](https://github.com/Azure/azure-sdk-for-net) for support.\\\\n   - **Import Resolution Errors**: If the error pattern includes `import-not-found`, make sure your `tspconfig.yaml` is correctly configured, especially the `additionalDirectories` array.\\\\n\\\\n3. **Next Steps**:\\\\n   - Review the build log for the exact error message.\\\\n   - If the error is unclear or not addressed above, ask in the .NET language team's channel for direct help with your PR and build failures.\\\\n   - Reference the official troubleshooting and support guidance for further help.\\\\n\\\\nIf you provide the exact error message, I can offer more targeted advice for your .NET SDK build failure.\\\", \\\"ground_truth\\\": \\\"Log from the pipeline:\\\\n[SGS-WARN] SDK configuration is not enabled for specification-containerservice-Fleet.Management-tspconfig.yaml. Refer to the full log for details.\\\\n.NET is missing in your tspconfig.yaml => azure-rest-api-specs/specification/containerservice/Fleet.Management/tspconfig.yaml at d1319a40758b\\\\u2026\\\\nYou can use azure-rest-api-specs/specification/widget/resource-manager/Microsoft.Widget/Widget/tspconfig.yaml a\\\\u2026 as a template\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"}, {"inputs.query": "title: azure-rest-api-specs-pr/InternalARMContracts\n\nquestion: Is this branch getting all changes automatically merged from main, which would itself get merged changes from azure-rest-api-specs?\nIt looks that way but then\nPull requests · Azure/azure-rest-api-specs-pr\nI'm a bit puzzled about why we should need a PR like this (if that is the right thing to do)\nUpdate redis folder from main to internal branch by JimRoberts-MS · Pull Request #25870 · Azure/azu…", "inputs.ground_truth": "Individual specs are not synced between any of our branches.  There is a process to sync the infrastructure, but not the specs themselves, from public/main to these branches in specs-pr:\nRPSaaSMaster\nRPSaaSDev\nRPSaaSCanary\nARMCoreRPDev\nInternalARMContracts\nSyncing specs between these branches is the responsibility of the spec owner.\nhttps://github.com/Azure/azure-sdk-tools/blob/813e623459f3e8c47df98ce1196581510f65ffe6/eng/pipelines/mirror-repos.yml#L34-L61", "inputs.response": "The 'InternalARMContracts' branch in the azure-rest-api-specs-pr repository does NOT automatically receive all changes merged into the 'main' branch. According to the knowledge context, the 'main' branch in the private specs repo (azure-rest-api-specs-pr) is mirrored from the public specs repo 'main' branch by a CI job and is considered read-only for this purpose. The 'InternalARMContracts' branch is specifically used for ARM-internal APIs and is never published to customers. There is no automated process described that would merge all changes from 'main' into 'InternalARMContracts'.\n\nTherefore, if you need to update content (such as the Redis folder) in 'InternalARMContracts' to match what is in 'main', you must manually create a pull request to merge those changes. This process allows for selective updates and ensures that only the intended internal APIs or changes are brought over, without inadvertently publishing customer-facing changes or exposing APIs prematurely.\n\nIn summary, the existence of a PR like 'Update redis folder from main to internal branch' is necessary because there is no automatic sync from 'main' to 'InternalARMContracts', and changes must be explicitly merged when needed.", "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"Create a PR against main\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\\n\\n# Create a PR against main\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nWhen you're ready for a final review, it's time to create a pull request (PR) from your release branch you created\\r\\noriginally to the `main` branch on [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n* :warning: Do not merge `main` or other release branches unless you know there are changes required.\\r\\n* :white_check_mark: Rebase on `main` if changes are required in a separate topic branch.\\n\\n## Clean PR against main\\n\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\\n\\n## Update your branch with changes from main\\n\\nIf you know there are other changes in the `main` branch or that other services have updated shared files in `main`\\r\\nalready and you need to pick up changes before merging, we recommend you take a merge from main. This is particularly interesting\\r\\nfor common infrastructure changes that are committed in the repo (i.e. github actions, tools, etc). Depending on how old your\\r\\nbranch is some of the pull request checks may not correctly function without taking a merge from main. \\r\\n\\r\\nIf you are working in a non-protected branch you can do a `git merge main` like you would normally do a merge and then push\\r\\nyour changes to your remote branch. However, if you are working in a branch with branch protection enabled (i.e. `release-*`) then\\r\\nyou will need to make a pull request to your branch with the merge. Depending on how out-of-date your branch is from `main` your \\r\\nmerge may have a lot of unwanted and unnecessary changes and the checks not pass. In such cases see below on how to [update the infrastructure](#updating-only-the-infrastructure-changes-from-main).\\n\\n### Updating only the infrastructure changes from main\\n\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\\n\\n## Next steps\\n\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# design#api-specs-pr#api-versions-and-branches.md\\n\\n| Short Link: | [aka.ms/azsdk/api-versions](https://aka.ms/azsdk/api-versions) |\\r\\n|--|--|\\n\\n# API versions and branches\\n\\nThis article explains the various lifecycle stages of spec API versions and how do they relate to git branches of the  \\r\\n[specs repositories](xref:api-repos).\\n\\n## Spec repos branches table\\n\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\n| Branch                 | [Public repository][public specs repo]        | [Private repository][private specs repo]              |\\r\\n|------------------------|-----------------------------------------------|-------------------------------------------------------|\\r\\n| `main`                 | All API versions in `GA` and `public preview` | Mirrored from public `main`                           |\\r\\n| `RPSaaSMaster`         | N/A                                           | For RPaaS-based specs in `private preview`   |\\r\\n| `RPSaaSDev`            | N/A                                           | For dogfooding RPaaS-based specs.                     |\\r\\n| `release-*`            | Feature branches.                             | Feature branches.                                     |\\r\\n| `dev-*`                | Obsolete. Use `release-*` instead.            | Obsolete. Use `release-*` instead.                    |\\r\\n| `ARMCoreRPDev`         | N/A                                           | [Obsolete ShiftLeft branch]. Use `release-*` instead. |\\r\\n| `InternalARMContracts` | N/A                                           | For ARM-internal APIs, never published to customers.  |\\r\\n\\r\\nIf a given branch in the public or private spec repos is not listed in the table above, then most likely\\r\\nit is obsolete, deprecated, or otherwise not recommended for use.\\n\\n## Branch protection rules table\\n\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\nThis table shows which GitHub checks are marked as `required` on respective branches. Even when a check is marked as ❌\\r\\nit **may** still be running on given branch; just that if it fails, the PR won't be blocked from merging.\\r\\n\\r\\n| Branch | Merge | SDK | TSVal | BrCh | BrChC | LintRPaaS | LintDiff | Model | Semantic | Spell | Prettier | license | approver |\\r\\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\\r\\n| public `main`                  | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSMaster`         | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| public/private `release-*`     | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSDev`            | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `InternalARMContracts` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `ARMCoreRPDev`         | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n\\r\\nLegend:\\r\\n\\r\\n| Column name | Full GitHub check name               |\\r\\n|-------------|--------------------------------------|\\r\\n| `BrCh`      | `Swagger BreakingChange`             |\\r\\n| `BrChC`     | `Breaking Change(Cross-Version)`     |\\r\\n| `license`   | `license/cla`                        |\\r\\n| `LintDiff`  | `Swagger LintDiff`                   |\\r\\n| `LintRPaaS` | `Swagger Lint(RPaaS)`                |\\r\\n| `Merge`     | `Automated merging requirements met` |\\r\\n| `Model`     | `Swagger ModelValidation`            |\\r\\n| `Prettier`  | `PrettierCheck`                      |\\r\\n| `SDK`       | `SDK azure-sdk-for-go`               |\\r\\n| `Semantic`  | `Swagger SemanticValidation`         |\\r\\n| `Spell`     | `SpellCheck`                         |\\r\\n| `TSVal`     | `TypeScript Validation`              |\\r\\n| `approver`  | Requires team member approval        |\\r\\n\\r\\nFor more information on these checks, see:\\r\\n\\r\\n- https://aka.ms/azsdk/pr-getting-help\\r\\n- https://aka.ms/ci-fix\\n\\n## API version lifecycle stages\\n\\nAn API version is a TypeSpec/OpenAPI specification contract identified by its `api-version` value.\\r\\n\\r\\nGiven API version is located in its own directory in the specs repositories. It can be in following lifecycle stages:\\r\\n\\r\\n- `generally available` (aka `GA`, `stable`)\\r\\n- `public preview`\\r\\n- `private preview`\\r\\n- `in development`\\r\\n- `closing down`\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e A `closing down` API spec version need to be kept in the spec repository until it is fully `deprecated`. A `deprecated` API spec version need to be removed from the spec repository, with removal initiated by the service to begin deprecating related APIs, SDKs, and CLIs.\\r\\n\\r\\nThese stages corresponds to [service tree lifecycle stages] as elaborated on in [ARM lifecycle stages requirements].\\n\\n### Generally available\\n\\n**GA** API versions have been released to all Azure customers.\\r\\n\\r\\nFor an API version to be in GA it must:\\r\\n\\r\\n- Be present in the `main` branch of the [public specs repo].\\r\\n- Be in a parent `stable` folder and without a `-preview` suffix. See [spec directory structure] for full details.\\r\\n- Not be gated by any feature flags, including Azure Feature Exposure Control ([AFEC]) flags.\\n\\n### Public preview\\n\\n**Public preview** API versions have been released to all Azure customers, but are not yet GA.\\r\\nFor an API version to be in `public preview`, it must:\\r\\n\\r\\n- Not yet be GA.\\r\\n- Be present in the `main` branch of the [public specs repo].\\r\\n- Be in a parent `preview` folder and have `-preview` suffix in its folder name.\\r\\n  See [spec directory structure] and [ARM preview guidelines] for full details.\\r\\n- Not be gated by any feature flags, including [AFEC] flags.\\n\\n### Private preview\\n\\n**Private preview** API versions have been released to a limited set of Azure customers.\\r\\n\\r\\nUsually API versions are in `private preview` for following reasons:\\r\\n\\r\\n- The spec API version preview cannot yet be made public due to business or marketing reasons.\\r\\n- Early customer feedback is being gathered for given API version preview.\\r\\n\\r\\nFor an API version to be in `private preview`, it must:\\r\\n\\r\\n- Not yet be `GA` or in `public preview`.\\r\\n- Not be present in the [public specs repo] `main` branch or any other branch in that repo.\\r\\n- Be in a parent `preview` folder and have `-prefix` in its folder name.\\r\\n  See [spec directory structure] and [ARM preview guidelines] for full details.\\r\\n- Have at least one customer. If an API version has no customers, it is `in development`, not in `private preview`.\\r\\n- In case of ARM specs:\\r\\n  - Be present in the `RPSaaSMaster` branch of the [private specs repo].\\r\\n    See [ARM branches] and [ARM lifecycle stages requirements] for details.\\r\\n  - Be under access control done with [AFEC] flags.\\r\\n- In case of data-plane specs:\\r\\n  - Can be in any branch in the [private specs repo], except `main` or `RPaaS*` branches,\\r\\n    as there is no designated branch like `RPSaaSMaster` for ARM specs.\\r\\n  - There is no need for access control done with [AFEC] flags, as data plane services should have some mechanism\\r\\n    for allowing `private preview` customers to onboard the preview.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e A `private preview` API spec version can be published as `public preview` by following  \\r\\n\\u003e [this how-to](xref:pr-move-private-to-public).\\n\\n### In development\\n\\n**In development** API versions are all API versions that are not `GA`, in `public preview` or in `private preview`.\\r\\nNotably, such API versions are not present in the [public specs repo] `main` branch and do not have any customers.\\r\\nHowever, they may be present in the public repo feature branches.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e REST API definitions for a service or API version that is `in development` MUST NOT be present in the  \\r\\n\\u003e [public specs repo] `main` at all.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e ARM spec API version, while `in development`, should not be trying to merge into `RPSaaSMaster`.\\r\\n\\u003e The ARM guidance for this is in [ARM spec onboarding] article.\\r\\n\\r\\n**Special cases** There are few special situations that do not fit in the API versioning model described above.\\r\\nIn such situations, attend appropriate office hours:\\r\\n\\r\\n- In case of ARM specs, **ARM API Review Office Hours** in [aka.ms/armofficehoursinfo].\\r\\n- In case of data-plane specs, [aka.ms/azapi/officehours].\\n\\n## Spec repos branches\\n\\n### Public specs repo `main` branch\\n\\nAll API versions in the [public specs repo] `main` branch are published to all Azure customers.\\r\\nThis branch includes `GA` and `public preview` API versions.\\r\\n\\r\\n\\u003e [!CAUTION]\\r\\n\\u003e This is not a dev branch. It should contain **only** finished specs that represent services deployed to customers.\\n\\n### Private specs repo `main` branch\\n\\n[Private specs repo] `main` branch is mirrored from [public specs repo] `main` branch by a CI job on a regular basis.\\r\\nAs such, it is **read only**.\\n\\n### Private specs repo `RPSaaSMaster` branch\\n\\n[Private specs repo] `RPSaaSMaster` contains RPaaS-based ARM specifications.\\r\\n\\r\\nWhen an RPaaS-based ARM API goes into `public preview` or `GA` lifecycle stage it must be merged to [public specs repo]\\r\\n`main` as well.\\r\\n\\r\\nSome parts of this branch are being mirrored from public `main` branch\\r\\nby the [mirror-repos] pipeline, triggered manually on at least daily basis.\\r\\n\\r\\nService teams are responsible for keeping their API specifications in this branch synchronized with\\r\\nthe public specs repo `main` branch.\\r\\n\\r\\nSee also [ARM lifecycle stages requirements] and [ARM branches].\\n\\n### `RPSaaSDev` branch\\n\\nUsed for internal ARM dogfooding. See `RPSaaSDev` in [ARM branches].\\r\\n\\r\\nSome parts of this branch are being mirrored from public `main` branch\\r\\nby the [mirror-repos] pipeline, triggered manually on at least daily basis.\\r\\n\\r\\nService teams are responsible for keeping their API specifications in this branch synchronized with\\r\\nthe public specs repo `main` branch.\\r\\n\\r\\nSee also [ARM lifecycle stages requirements] and [ARM branches].\\n\\n### `release-*` branches\\n\\nAll branches with prefix `release-`, both in public and private specs repos. Also known as \\\"feature\\\" branches.\\r\\n\\r\\nThese branches are used for col\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\",\"document_title\":\"Resolving Folder Migration Conflicts: A Guide for PR Authors\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors\",\"content\":\"# Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\\n\\n# Resolving Folder Migration Conflicts: A Guide for PR Authors\\n\\n## Overview\\n\\nWhen folder structure migration PRs (like [#36764](https://github.com/Azure/azure-rest-api-specs/pull/36764)) are merged, they may conflict with ongoing PRs that modify files within the refactored folders. This guide helps PR authors resolve these conflicts more efficiently.\\r\\n\\r\\n\\u003e **Important Note**: If you create a new PR **after** a folder migration is already merged into main, you should not encounter merge conflicts but need to work based on the new folder structure.\\n\\n## Understanding Folder Migration\\n\\nHere's the brief summary of the file changes of folder structure migration PR. we will take the Container Apps as an example.\\n\\n### Folder Structure Change\\n\\n**Before Migration Structure**:\\r\\n```\\r\\nspecification/app/\\r\\n├── Microsoft.App.DynamicSessions/\\r\\n│   ├── *.tsp\\r\\n│   ├── examples/*/*.json\\r\\n│   └── tspconfig.yaml\\r\\n├── resource-manager/\\r\\n|   ├── readme.md\\r\\n|   └── Microsoft.App/\\r\\n|       ├── preview/*/*.json\\r\\n|       └── stable/*/*.json\\r\\n└── data-plane/\\r\\n    ├── readme.md\\r\\n    └── Microsoft.App.DynamicSessions/\\r\\n        └── preview/*/*.json\\r\\n```\\r\\n\\r\\n**After Migration Structure**:\\r\\n```\\r\\nspecification/app/\\r\\n├── resource-manager/Microsoft.App/ContainerApps/\\r\\n│   ├── preview/*/*.json\\r\\n│   ├── stable/*/*.json\\r\\n│   └── readme.md\\r\\n└── data-plane/DynamicSessions/\\r\\n    ├── examples/*/*.json\\r\\n    ├── preview/*/*.json\\r\\n    ├── *.tsp\\r\\n    ├── tspconfig.yaml\\r\\n    └── readme.md\\r\\n```\\r\\n\\r\\n**Key Changes Made**:\\r\\n- TypeSpec files moved with their respective services\\r\\n- Each service now has its own isolated directory structure\\r\\n\\r\\nFor example:\\r\\n- Create a new serviceName folder ContainerApps: Moved from `resource-manager/Microsoft.App/` to `resource-manager/Microsoft.App/ContainerApps/`\\r\\n- The resource-manager readme.md updated paths from `resource-manager/` to `resource-manager/Microsoft.App/ContainerApps`\\r\\n- DynamicSessions TypeSpec: Moved from `Microsoft.App.DynamicSessions/` to `data-plane/DynamicSessions/`\\r\\n- DynamicSessions OpenAPI json files: Moved from `data-plane/Microsoft.App.DynamicSessions/preview/\\u003cversion\\u003e/` to `data-plane/DynamicSessions/preview/\\u003cversion\\u003e/`\\r\\n- The data-plane readme.md updated paths from `Microsoft.App.DynamicSessions/preview/\\u003cversion\\u003e/` to `preview/\\u003cversion\\u003e/`\\n\\n### File Reference Updates Needed\\n\\n1. **Readme.md files** - Update input-file paths:\\r\\n   \\r\\n   **For ContainerApps (Resource Manager)**:\\r\\n   ```yaml\\r\\n   # Before\\r\\n   input-file:\\r\\n     - Microsoft.App/stable/2024-03-01/ContainerApps.json\\r\\n   \\r\\n   # After  \\r\\n   input-file:\\r\\n     - stable/2024-03-01/ContainerApps.json\\r\\n   ```\\r\\n   \\r\\n   **For DynamicSessions (Data Plane)**:\\r\\n   ```yaml\\r\\n   # Before migration - in data-plane/readme.md\\r\\n   input-file:\\r\\n     - Microsoft.App.DynamicSessions/preview/2025-02-02-preview/DynamicSessions.json\\r\\n   \\r\\n   # After migration - in data-plane/DynamicSessions/readme.md  \\r\\n   input-file:\\r\\n     - preview/2025-02-02-preview/DynamicSessions.json\\r\\n   ```\\r\\n\\r\\n2. **tspconfig.yaml files** - Update emitter output directory:\\r\\n   \\r\\n   **DynamicSessions tspconfig.yaml changes**:\\r\\n   ```yaml\\r\\n   # Before migration - in Microsoft.App.DynamicSessions/tspconfig.yaml\\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       emitter-output-dir: \\\"{project-root}/..\\\"\\r\\n       output-file: \\\"{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/DynamicSessions.json\\\"\\r\\n   \\r\\n   # After migration - in data-plane/DynamicSessions/tspconfig.yaml\\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       emitter-output-dir: \\\"{project-root}\\\"\\r\\n       output-file: \\\"{version-status}/{version}/DynamicSessions.json\\\"\\r\\n   ```\\r\\n\\r\\n3. **Common-types references** - Update relative paths in JSON files:\\r\\n   ```json\\r\\n   // Before (in ContainerApps.json)\\r\\n   \\\"$ref\\\": \\\"../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   \\r\\n   // After  \\r\\n   \\\"$ref\\\": \\\"../../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   ```\\r\\n\\r\\n   Fpr mgmt plane TypeSpec, we also need to specify the `arm-common-types` in tspconfig options of `@azure-tools/typespec-autorest`.\\r\\n   ```yaml \\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n   ```\\n\\n// After  \\r\\n   \\\"$ref\\\": \\\"../../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   ```\\r\\n\\r\\n   Fpr mgmt plane TypeSpec, we also need to specify the `arm-common-types` in tspconfig options of `@azure-tools/typespec-autorest`.\\r\\n   ```yaml \\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n   ```\\r\\n\\r\\n4. **Suppressions.yaml** - Update paths in suppressions:\\r\\nAs GitHub recognize this refactor change as to add new API versions in the OpenAPI folder, in order to make sure the TypeSpec requirement check pass. we need to have a suppressions.yaml under serviceName folder \\r\\nand add suppression one by one like this \\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: ./preview/2022-01-01-preview/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n- tool: TypeSpecRequirement\\r\\n  path: ./stable/2025-01-01/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## The impact to ongoing PRs\\n\\n1. If the ongoing PRs are targeting to a release-* or dev-* branch which are not created or syncing from the latest main, we recommend to merge these PRs first.\\r\\n1. If the ongoing PRs are targeting to public main branch, Here's the suggestion to resolve the conflict. \\r\\n\\r\\n      1. Merge latest main \\r\\n          ```\\r\\n          git checkout main\\r\\n          git pull origin main // origin points to Azure rest api specs repo.\\r\\n          git merge main \\u003cyour-pr-branch\\u003e\\r\\n          ```\\r\\n      2. Resolve conflicts  \\r\\n        - For most of the conflicts, accept the incoming changes.  \\r\\n        - If it's unclear, please accept both and then update based on your judgement with the folder structure changes above.  \\r\\n\\r\\n      3. Make sure the new change is aligned with folder structure v2  \\r\\n\\r\\n         There are some cases where the PR is adding a new version in the original location, but the file diffs don't show as conflict. we should move them into the correct place so that it doesn't break the folder structure v2 as instructions in **Understanding Folder Migration sections** \\r\\n\\r\\n      4. clean up the previous folder if exists.\\r\\n\\r\\n  \\r\\n\\r\\n**Important**: It's strongly recommended to understand what's really changed in the folder refactor. Always ensure the new PR doesn't include any things that breaks the folder structure.\\n\\n### After Resolution\\n\\nMake sure to compile the TypeSpec project so that the TypeSpec Validation could pass.\\r\\n\\r\\n1. **Comprehensive validation**:\\r\\n   ```bash\\r\\n   # Run full validation suite\\r\\n   npm ci\\r\\n   npm run lint\\r\\n   npm run validate\\r\\n   \\r\\n   # Test TypeSpec compilation for your service\\r\\n   cd specification/app/data-plane/DynamicSessions/\\r\\n   npx tsp compile .\\r\\n   npx tsp compile . --emit @azure-tools/typespec-autorest\\r\\n   \\r\\n   # Verify generated files match expectations by checking if there's any diff with the OpenAPI json files.\\r\\n   ```\\n\\n## Getting Help\\n\\n### Resources\\n\\n- [Azure Service Version Guidelines](https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline)\\r\\n- [Container Apps Migration PR #36764](https://github.com/Azure/azure-rest-api-specs/pull/36764)\\n\\n### Support Channels\\n\\nIf you encounter complex conflicts that can't be resolved using this guide, please email to azversioning@service.microsoft.com\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"API-Spec-Review-FAQ.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ\",\"content\":\"ARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this. See documentation: [Update your branch with changes from main](https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish#update-your-branch-with-changes-from-main). |\\r\\n| I need to set up suppressions for LintDiff violations in my PR | See [Adding Scoped Suppressions](https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff) | \\r\\n| I have specific questions about the inner workings of ARM, testing changes to APIs, or rollout/release schedules | Talk to the ARM team: https://aka.ms/armofficehoursinfo |\\r\\n| I see an Avocado error `MULTIPLE_API_VERSION` | There is a coordinated effort to fix this. Reach out to the relevant parties. [This PR](https://github.com/Azure/avocado/pull/157) gives more context on why this was upgraded to an error. If relevant parties agree, the PR can be unblocked by adding the `Approved-Avocado` label to the PR. |\\r\\n| I merged a PR, when does the REST API documentation update on the Learn site? | Docs are published every week on Tuesdays | \\r\\n| If the specs in the standard branches of `RPSaaSMaster` and `RPSaaSDev` are out of sync, who is responsible for syncing them with main? | The spec owner is responsible for syncing their service’s spec files from `main` to `RPSaaSMaster/RPSaaSDev` to ensure consistency across branches. |\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure REST API, SDK development process with TypeSpec\\n## Table Of Content\\n### 4. Prepare and submit a Pull Request for reviewing\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\r\\n   - send a pull request to the original repo from your forked repo.\\r\\n   See the ARM Wiki for information on the [supported repos and branches for management-plane services](https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches).\\r\\n#### 4.1 Fix the errors of PR reviewing CI checks\\r\\nThe CI checks result will be commented on the PR. you can refer to the [CI fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\\r\\nNote:\\r\\nSince the OpenAPI is generated from TypeSpec, to change the OpenAPI, you must update the TypeSpec file and regenerate the\\r\\n OpenAPI and avoid updating OpenAPI directly to keep the consistency between OpenAPI and TypeSpec.\\r\\nFor support \\u0026 help, you can post a message to [TypeSpec Discussion - teams channel](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial\",\"content\":\"# Tutorial: Create a new service spec\\n## Why work in a separate branch?\\nThe [Microsoft Azure REST API Guidelines state](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-versioning),\\r\\n\\r\\n\\u003e Azure services need to change over time. However, when changing a service, there are 2 requirements:\\r\\n\\u003e\\r\\n\\u003e 1. Already-running customer workloads must not break due to a service change.\\r\\n\\u003e 2. Customers can adopt a new service version without requiring any code changes.\\r\\n\\u003e    Of course, the customer must modify code to leverage any new service features.\\r\\n\\r\\nTogether with the [Breaking Changes Policy](http://aka.ms/AzBreakingChangesPolicy/), it effectively means that any\\r\\nchanges you merge directly into the `main` branch in  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) must be supported for 90 days for preview\\r\\nversions, and 3 years for stable versions at a minimum.\\r\\n\\r\\nWorking in a separate branch allows your team to iterate on a design, make changes to the REST API definition or\\r\\neven the service as needed, and merge those changes to `main` - effectively publishing that service version -\\r\\nwhen you're ready.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Breaking changes and versioning issues\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-repos.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-repos\",\"content\":\"# Azure REST API specs repositories on GitHub\\nThe REST API descriptions for all Azure services should be published in the Azure REST API specs GitHub repositories.\\r\\n\\r\\nThe [Azure/azure-rest-api-specs] is the public repository. All work done in this repository is public, i.e. visible to\\r\\neveryone, including people outside of Microsoft. Any Azure REST API specification updates must be merged to the `main`\\r\\nbranch as part of the process of releasing those updates to Microsoft customers.\\r\\n\\r\\nThe [Azure/azure-rest-api-specs-pr] is the private repository (the \\\"pr\\\" stands for \\\"private\\\"). It is for work that must\\r\\nremain private until it is ready to be published. For example, if your team is working on a new product with a new Azure\\r\\nResource Manager (ARM) or Resource Provider (RP) namespace, you want to keep developing it in the private repository\\r\\nuntil you have drafted, tested and went through the API review process. Only after this is done, you must merge your\\r\\nchanges to the `main` branch in the public repository.\\r\\n\\r\\nThe `main` branch in the private repository is read-only, as it is mirrored from the public repository `main` branch.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-docs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-docs\",\"content\":\"# Publish REST API reference docs\\n## Update an existing API reference\\nIf your service is __already using README__ for publishing configuration and utilizing automatic refresh, as long as the\\r\\nREADME is properly updated, any API updates merged to the [Azure/azure-rest-api-specs] repository\\r\\nwill be automatically picked up by the [Azure REST API reference site on Microsoft Learn](https://learn.microsoft.com/rest/api/)  \\r\\nweekly (on Tuesdays).\\r\\nRequest an OOB publishing by [creating a Work Item in Azure DevOps]  \\r\\n(https://dev.azure.com/msft-skilling/Content/_workitems/create/User%20Story?templateId=39fb91e3-64a2-4c8a-83db-b2bdf3603dd3\\u0026ownerId=c4a28f90-17ae-4384-b514-7273392b082b),  \\r\\nif needed.\\r\\nIf you had to use the __alternative publishing configuration__ with direct paths to the OpenAPI spec files, you’ll need\\r\\nto have the publishing configuration manually updated to document any API updates in the [Azure/azure-rest-api-specs] repository.\\r\\nThe easiest way is to create a publishing request by [submitting a User Story in Azure DevOps]  \\r\\n(https://dev.azure.com/msft-skilling/Content/_workitems/create/User%20Story?templateId=39fb91e3-64a2-4c8a-83db-b2bdf3603dd3\\u0026ownerId=c4a28f90-17ae-4384-b514-7273392b082b).  \\r\\nOr you can create a pull request into the [REST API documentation repository]  \\r\\n(https://github.com/Azure/azure-docs-rest-apis) and update the publishing configuration.\\r\\nRead [this document on publishing configurations]  \\r\\n(https://learn.microsoft.com/help/onboard/admin/reference/rest/api-publishing-configuration)  \\r\\nfor more details on the recommended and alternative publishing configurations.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-2-update.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-2-update\",\"content\":\"# Work against the release branch\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nNow that you've created a release branch, let people know the branch name you created above. They should create topic\\r\\nbranches against that branch - just like they would against the `main` branch - and submit pull requests (PR).\\r\\nRead about [API design](xref:api-design) for guidelines and more information.\\r\\n\\r\\n- :white_check_mark: Create a topic branch from the upstream release branch.\\r\\n- :white_check_mark: Submit a PR when ready against the upstream release branch.\\r\\n- :x: Do not merge the `main` branch into your topic branch. If you need specific changes, you can cherry-pick them,\\r\\n  or simply copy and paste.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# Create a pull request with your Azure REST API spec update\\nThis article explains how to create a pull request (PR) in the [Azure REST API specification repositories](xref:api-repos).\\r\\nSuch PR is a part of the [release plan](xref:release-plan).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial\",\"content\":\"# Tutorial: Create a new service spec\\nWhen [working on a new REST API definition](xref:api-design) for a new or existing REST API definition, it's best to\\r\\nwork in a topic branch in git and on GitHub so you can later submit a pull request (PR) and iterate on feedback.\\r\\nWhen a team is involved, you'll need a branch everyone can target that can also validate and find errors early.\\r\\n\\r\\nThis tutorial is recommended for anyone working on a new REST API definition, especially as part of a team.\\r\\nIt will guide you through the entire process from creating the branch to merging in into main.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# Create a pull request with your Azure REST API spec update\\n## Get your PR merged\\n| Short Link: | [aka.ms/azsdk/specreview/merge](https://aka.ms/azsdk/specreview/merge) |\\r\\n|-|-|\\r\\n\\r\\nTo get your PR merged:\\r\\n\\r\\n1. Ensure the `Next Steps to Merge` comment and `Automated merging requirements met` check are green. \\r\\n1. Ensure at least one person has approved your PR. Generally another person from your team that has [write access] to the repo.\\r\\n1. Ensure all required checks are passing and at least investigate to understand any other non-required checks that may be failing. \\r\\n1. Once all required checks are green and any other issues understood you can merge the PR yourself as long as you have [write access] to the repo.\\r\\n1. If your PR is targeting public `main` you will need to first apply the `PublishToCustomers` label to acknowledge you understand this \\r\\n   will cause your spec to be published so customers can consume it.\\r\\n1. If your PR is targeting private repo `main` branch, it **cannot** be merged.\\r\\n   Instead, you can publish your changes to customers by following the guide at [aka.ms/azsdk/move-pr].\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# Create a pull request with your Azure REST API spec update\\n## Create a PR against a specs repo\\n\\u003e [!TIP]\\r\\n\\u003e If you have an existing PR in the private repo and you want to move it to the public repo, refer to [this guide](xref:pr-move-private-to-public).\\r\\n\\r\\nWhen you are ready to submit your REST API spec updates for review, you must create a pull request (PR) in either the  \\r\\n[public or private specs repository](xref:api-repos). When creating the PR, you should select either the\\r\\n**Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API spec updates you are\\r\\nsubmitting.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e The PR template and comments added by the PR automation will guide you through the process of getting your PR reviewed,\\r\\napproved, and merged.\"}]", "inputs.latency": 1061.9973711967468, "inputs.response_length": 1213, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches", "https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ", "https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-repos"], "inputs.testcase": "azure-rest-api-specs-pr/InternalARMContracts", "outputs.similarity.similarity": 4.0, "outputs.similarity.gpt_similarity": 4.0, "outputs.similarity.similarity_result": "pass", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1288, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1289, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: azure-rest-api-specs-pr/InternalARMContracts\\\\n\\\\nquestion: Is this branch getting all changes automatically merged from main, which would itself get merged changes from azure-rest-api-specs?\\\\nIt looks that way but then\\\\nPull requests \\\\u00b7 Azure/azure-rest-api-specs-pr\\\\nI'm a bit puzzled about why we should need a PR like this (if that is the right thing to do)\\\\nUpdate redis folder from main to internal branch by JimRoberts-MS \\\\u00b7 Pull Request #25870 \\\\u00b7 Azure/azu\\\\u2026\\\", \\\"response\\\": \\\"The 'InternalARMContracts' branch in the azure-rest-api-specs-pr repository does NOT automatically receive all changes merged into the 'main' branch. According to the knowledge context, the 'main' branch in the private specs repo (azure-rest-api-specs-pr) is mirrored from the public specs repo 'main' branch by a CI job and is considered read-only for this purpose. The 'InternalARMContracts' branch is specifically used for ARM-internal APIs and is never published to customers. There is no automated process described that would merge all changes from 'main' into 'InternalARMContracts'.\\\\n\\\\nTherefore, if you need to update content (such as the Redis folder) in 'InternalARMContracts' to match what is in 'main', you must manually create a pull request to merge those changes. This process allows for selective updates and ensures that only the intended internal APIs or changes are brought over, without inadvertently publishing customer-facing changes or exposing APIs prematurely.\\\\n\\\\nIn summary, the existence of a PR like 'Update redis folder from main to internal branch' is necessary because there is no automatic sync from 'main' to 'InternalARMContracts', and changes must be explicitly merged when needed.\\\", \\\"ground_truth\\\": \\\"Individual specs are not synced between any of our branches.  There is a process to sync the infrastructure, but not the specs themselves, from public/main to these branches in specs-pr:\\\\nRPSaaSMaster\\\\nRPSaaSDev\\\\nRPSaaSCanary\\\\nARMCoreRPDev\\\\nInternalARMContracts\\\\nSyncing specs between these branches is the responsibility of the spec owner.\\\\nhttps://github.com/Azure/azure-sdk-tools/blob/813e623459f3e8c47df98ce1196581510f65ffe6/eng/pipelines/mirror-repos.yml#L34-L61\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"}, {"inputs.query": "title: Adoption of CBOR (and COSE) encoding/decoding throughout SDKs\n\nquestion: Hi, we are adopting CBOR in multiple places in the company, especially in the context of COSE signing envelopes, their verification.\nCBOR and COSE encoding/decoding is supported natively in .NET SDK via System.Security.Cryptography.Cose already, and is being used in at least one SDK which follows specific RFC drafts.\nHowever, other languages would need to also adopt it when the service expands. Which poses a question what libraries to use in each? I know specific dependencies that we can leverage but is there an approval process to \"allow\" them to become part of the SDKs, or should I just include the dependencies and review those in arch/sdk meeting for each language separately?", "inputs.ground_truth": "I would suggest an email to azsdkarch@microsoft.com to discuss this.", "inputs.response": "Based on the provided Azure SDK onboarding knowledge, there is no explicit approval process documented for adding new platform or third-party dependencies to Azure SDKs prior to including them. However, dependencies—including platform and third-party libraries—should be evaluated and reviewed as part of the SDK architecture and language-specific review meetings, particularly for data plane SDKs.\n\nFor data plane SDKs, you are required to schedule an SDK review meeting with the Azure SDK Architecture Board before publication. In these meetings, you should bring your proposed package dependencies for each language, alongside APIView listings and hero scenarios. This review ensures that the SDKs are developer-friendly, consistent, and meet Azure guidelines across all languages.\n\nFor management plane (ARM) SDKs, a review meeting is NOT required, but it is still recommended to follow Azure SDK design guidelines and best practices for dependency selection and consistency across languages.\n\nThe recommended approach for introducing CBOR/COSE dependencies is:\n- For each language, select well-maintained, secure, and actively supported libraries that fulfill the CBOR/COSE requirements.\n- Document your dependency choices and rationale in your SDK release plan and APIView submission.\n- Discuss the dependencies in the SDK review meeting for each language (for data plane SDKs), ensuring architects and language leads are aware and can provide feedback or raise concerns about compatibility, support, or licensing.\n- Ensure that your choices align with the Azure SDK architecture and language guidelines.\n\nIf you encounter governance or compliance issues, or need an exception (e.g., for a non-standard or unapproved dependency), you can formally request an exception via the Cloud Lifecycle process, which will require business justification and leadership approval.\n\nTo summarize: include your chosen dependencies in your initial SDK implementation, document them in your review materials, and have them evaluated as part of the standard SDK architecture and language review process. This ensures consistent, cross-language adoption and compliance with Azure standards.", "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-develop.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop\",\"content\":\"# develop#sdk-develop.md\\n\\n| Short Link: | [aka.ms/azsdk/dpcodegen](https://aka.ms/azsdk/dpcodegen) |\\r\\n| --- | --- |\\n\\n# Develop client libraries (SDK)\\n\\nOnce your [REST API specification](xref:api-design) defined using [TypeSpec](xref:api-typespec) is approved,\\r\\nyou can generate client libraries and reference documentation for each supported SDK language.\\r\\nYour Azure SDKs should be designed to enhance the productivity of developers connecting to Azure services.\\r\\nThey must follow the [Azure SDK Architecture design guidelines](https://azure.github.io/azure-sdk/general_introduction.html)\\r\\nand specific language guidelines.\\r\\n\\u003e [!NOTE]\\r\\n\\u003e - Azure services are required to release client libraries for all Tier 1 SDK languages for Public Preview and GA, which include .NET, Python,\\r\\n\\u003e Java, JavaScript, and Go (optional for data plane SDKs).\\r\\n\\u003e - Avoiding breaking changes under most circumstances. The Azure SDK team recommends on the SDK release cycle can be\\r\\n\\u003e found in [Release Cycle and Package Versioning](https://azure.github.io/azure-sdk/policies_releases.html#release-cycle).\\r\\n\\u003e - Azure services must have a beta release available for at least one month to allow for community feedback before\\r\\n\\u003e graduating to stable. For more details, may refer to [Beta Releases and Stable Graduation](https://azure.github.io/azure-sdk/policies_releases.html#beta-releases-and-stable-graduation)\\n\\n## Before you begin\\n\\n- You have [access](xref:access) to the GitHub repositories and respective GitHub groups.\\r\\n- You read our [repository branches strategy](https://azure.github.io/azure-sdk/policies_repobranching.html).\\r\\n- You are familiarized with the [Azure SDK Architecture design guidelines](https://azure.github.io/azure-sdk/general_introduction.html).\\r\\n- You have a [release plan](xref:release-plan) created to manage and understand the steps required to generate,\\r\\ntest, and release an SDK.\\r\\n- [Request a namespace review](xref:namespace-review). This review process take 1-2 weeks to complete or longer\\r\\ndepending on the complexity of the review.\\n\\n## Generate SDK\\n\\nYour Azure SDKs will be generated from the configurations you set on your TypeSpec project.\\r\\n1. Locate or create the `tspconfig.yaml` file in your TypeSpec project.\\r\\n2. There are emitters per SDK language supported. Add the required emitters with their respective options.\\r\\n  - [Management plane tspconfig.yaml sample](https://aka.ms/azsdk/tspconfig-sample-mpg).\\r\\n  - [Data plane tspconfig.yaml sample](https://aka.ms/azsdk/tspconfig-sample-dpg).\\r\\nFor OpenAPI, the configurations should be in `readme.md`. Refer to the [Sample Readme](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/README.md#swagger-to-sdk).\\r\\n\\u003e[!TIP]\\r\\n\\u003e We are piloting our new AzSDK tools MCP server which includes the ability to generate the SDKs and\\r\\n\\u003e create a draft pull request in the respective language repository. Refer to [AzSDK tools MCP server](xref:azsdk-tools-mcp)\\r\\n\\u003e for instructions on how to install it and use it.\\n\\n### [Management plane (ARM)](#tab/management)\\n\\n\\u003e[!NOTE]\\r\\n\\u003e The process for generating management plane SDK from TypeSpec has changed. Learn more about our [latest changes](xref:upcoming_release_planner_change).\\r\\nA release plan is required to generate and release the SDK. If the API spec is written using *TypeSpec* then you\\r\\ncan generate the SDK for all tier-1 in *Generate SDK* step in the release planner.\\r\\nIf API spec is written using *Open API* SDK generation happens when you [request a release](xref:sdk-release) for all\\r\\ntier-1 languages except .NET. For .NET, follow the steps in the [Generate .NET management plane SDK](xref:sdk-generate-mgmt-dotnet).\\r\\nAlthough the SDK is autogenerated for you, you can also generate it manually and locally by following the steps outlined\\r\\nin the linked documentation:\\r\\n:point_right: [.NET](xref:sdk-generate-mgmt-dotnet)\\r\\n:point_right: [Go](https://aka.ms/azsdk/mpg/go)\\r\\n:point_right: [Java](https://aka.ms/azsdk/mpg/java)\\r\\n:point_right: [JavaScript](https://aka.ms/azsdk/mpg/js)\\r\\n:point_right: [Python](https://aka.ms/azsdk/mpg/python)\\n\\n### [Data plane](#tab/dataplane)\\n\\nThe following information will guide you from your data plane REST API spec, to code in the respective SDK repositories\\r\\nwith the generated SDK:\\r\\n:point_right: [.NET](https://aka.ms/azsdk/dpcodegen/net)\\r\\n:point_right: [Java](https://aka.ms/azsdk/dpcodegen/java)\\r\\n:point_right: [JavaScript DPG](https://aka.ms/azsdk/dpcodegen/js) (aka modular). This is the preferred JS flavor for codegen.\\r\\n:point_right: [JavaScript RLC](https://aka.ms/azsdk/rlc/js) (aka Rest Level Client). You must not attempt to generate RLC unless SDK archboard told you to.\\r\\n:point_right: [Python](https://aka.ms/azsdk/dpcodegen/python)\\r\\n:point_right: [Go (optional)](https://aka.ms/azsdk/dpcodegen/go).\\n\\n## Get help\\n\\n- If you need help with an automation tool or the Release planner, reach out to \\r\\n[Azure SDK / Azure SDK Onboarding](https://aka.ms/azsdk/support/onboarding-channel) channel.\\r\\n- If you need help with the development of the SDKs reach out to the [language specific Team's channel](xref:support#get-help-with-the-azure-sdks-development).\\r\\n- If you need to request an exception for a language review the [request release exception](xref:request-exception).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-review.md\",\"document_title\":\"Schedule an SDK review\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-review\",\"content\":\"# develop#sdk-review.md\\n\\n# Schedule an SDK review\\n\\n| Short Link: | [aka.ms/azsdk/onboarding/archboardschedule](https://aka.ms/azsdk/onboarding/archboardschedule) |\\r\\n| --- | --- |\\r\\n\\r\\nThis review is designed to help service owners create developer friendly and consistent SDKs for your service in\\r\\nsupported languages. All Azure language SDKs need to be reviewed prior to publication.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e Review meetings with the Azure SDK Architecture Board are only required for data plane libraries.\\r\\n\\u003e **Management Plane (ARM) libraries do NOT require a review meeting.**\\n\\n## Review meeting types\\n\\n### Beta SDK review meeting\\n\\n#### [When to have this meeting](#tab/when-to-have-this-meeting)\\r\\n\\r\\nIf you haven't met with the Architecture Board before, this is where you should start. If you are planning the first\\r\\nbeta release for your library it is required to have this meeting so the library name can be finalized.\\r\\nSubsequent beta releases do not require a Beta SDK review.\\r\\n\\r\\n#### [Typical agenda](#tab/typical-agenda)\\r\\n\\r\\n- Introduce your service to the Azure SDK Architecture Board\\r\\n- Review/Approve the proposed package names for each language\\r\\n  - *Package names for each language should be approved at the end of the beta SDK review meeting. Ensure there are people from your team who can make decision about naming at this meeting.*\\r\\n- Review the APIView of one tier 1 language with the architects\\r\\n- Review samples for how you expect users would interaction with your library\\r\\n- Ask any of your questions to the architects.\\r\\n\\r\\n#### [What to bring](#tab/what-to-bring)\\r\\n\\r\\n| Title | Importance | Description | Example and support documentation |\\r\\n| --- | --- | --- | --- |\\r\\n| Person with naming authority | Must have | Someone from your service team who can agree to SDK package names. | N/A |\\r\\n| APIView | Must have all tier 1 languages | APIView for the generated SDK. | [Example](https://apiview.dev/Assemblies/Review/8b7f5312697a458ab9e65c2fd9cdc2dd) |\\r\\n| Hero scenarios | Must have | Top scenarios on how the service is consumed. Your hero scenarios should be in the format of code examples or pseudo code if the client libraries do not exist yet. | [Guidelines on how to identify hero scenarios](xref:api-design#start-with-hero-scenarios)\\u003cbr\\u003e[Examples](https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/appconfiguration/Azure.Data.AppConfiguration#examples) |\\r\\n| Core concepts | Good to have | A glossary of nouns and verbs. | [Example](xref:api-design#define-terms-and-concepts) |\\r\\n| REST API specs | Good to have |\\n\\nYour hero scenarios should be in the format of code examples or pseudo code if the client libraries do not exist yet. | [Guidelines on how to identify hero scenarios](xref:api-design#start-with-hero-scenarios)\\u003cbr\\u003e[Examples](https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/appconfiguration/Azure.Data.AppConfiguration#examples) |\\r\\n| Core concepts | Good to have | A glossary of nouns and verbs. | [Example](xref:api-design#define-terms-and-concepts) |\\r\\n| REST API specs | Good to have | Link to the reviewed API specs definition in the [azure/azure-rest-api-specs-pr](https://github.com/azure/azure-rest-api-specs-pr) or [azure/azure-rest-api-specs](https://github.com/azure/azure-rest-api-specs) repo. | [Example](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/main.tsp) |\\n\\n## Schedule a meeting\\n\\nSchedule a SDK Architecture review meeting with the Azure SDK Architecture board.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e Reviews must be scheduled ideally at least two business days in advance to give the team time to prepare.\\r\\n\\r\\n1. Log in to [Azure SDK Release Planner](https://aka.ms/azsdk/sdk-release-planner).\\r\\n2. Choose the top-level service that your product is associated with.\\r\\n3. Click **Your release plans** and select the release plan you are interested in.\\r\\n4. The **Summary** view will provide information about where you are in the process and who the contacts are.\\r\\n5. Click on **Milestones** and select **Data-plane SDK Release**. This will open the app with the specific task to\\r\\naccomplish before you schedule the meeting.\\r\\n6. The **Schedule SDK review** task contains the information to schedule the meeting with the  \\r\\n[Azure SDK Scheduler](https://aka.ms/azsdk/schedulesdkreview) app.\\r\\n7. Once in the scheduler app click **Create new**.\\r\\n8. Choose a meeting slot and select your meeting attendees.\\r\\nIn the **Meeting attendees** field, be sure to include the Cloud Product Excellence (CPEX) PM or owner who is\\r\\nresponsible for updating your product in Cloud Lifecycle, as well as any engineering team members that will be\\r\\ngenerating or updating SDKs.\\r\\n9. Indicate whether your service is on pre-release and not publicly disclosed.\\r\\n10. Provide a links to your [hero scenarios](xref:api-design#start-with-hero-scenarios), architecture diagrams and  \\r\\n[core concepts](xref:api-design#define-terms-and-concepts). These fields will be auto populated if you have provided these\\r\\ndocuments before.\\r\\n11. Provide links to your APIView listings for each tier 1 language.\\n\\n## Next steps\\n\\n### What to expect during the review\\n\\nWhile each review is unique, they often follow a common structure:\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e The are some of the main things that get covered during the review but every review has it's own circumstances and\\r\\n\\u003e more areas can be discussed.\\r\\n\\r\\n| Stage | Description |\\r\\n| --- | --- |\\r\\n| Service overview | Service team provides a brief introduction to the service. |\\r\\n| SDK review | SDK review discussion with the board members. |\\r\\n| Action and next steps | Any follow up items before the sign-off. |\\n\\n## Contact us\\n\\nAdmins email alias: [azsdkarch-help@microsoft.com](mailto:azsdkarch-help@microsoft.com)\\n\\n## Appendix\\n\\n| Title | Description |\\r\\n| --- | --- |\\r\\n| Azure SDK Guidelines | The Azure SDK review ensures the adoption of Azure SDK guidelines which are provided [here](https://azure.github.io/azure-sdk/general_introduction.html). |\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-samples.md\",\"document_title\":\"Write SDK samples\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-samples\",\"content\":\"# develop#sdk-samples.md\\n\\n# Write SDK samples\\n\\nEach SDK should have a quickstart guide with code samples. Developers like to learn about a client library by looking at sample code and not by reading in-depth technology papers.\\n\\n## Before you begin\\n\\n- You have [access](xref:access) to the GitHub repositories and respective GitHub groups.\\r\\n- You are familiarized with the [Azure SDK Architecture design guidelines](https://azure.github.io/azure-sdk/general_introduction.html) and the language sample guidelines.\\r\\n- You read our [repository branches strategy](https://azure.github.io/azure-sdk/policies_repobranching.html).\\r\\n- You need to have an SDK to write samples for.\\n\\n## Requirements\\n\\n### [Management plane (ARM)](#tab/management)\\n\\nAt least one sample per language for the most common usage scenario.\\n\\n### [Data plane](#tab/dataplane)\\n\\n- Public preview: at least one sample per language for the most common usage scenario.\\r\\n- GA: at least 4 samples for the most common usage scenario.\\n\\n## Get help\\n\\nReach out to the specific language Teams channel under our [Azure SDK channel](https://teams.microsoft.com/l/team/19%3af6d52ac6465c40ea80dc86b8be3825aa%40thread.skype/conversations?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"onboard#access.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/onboard/access\",\"content\":\"## Request access to Azure REST API and SDK repositories\\n### Write access\\nIf you're working on branches in the main repo for your spec, or working in the Azure SDK repositories to submit pull\\r\\nrequests or serving as the support contact for issues, you'll need write access so that you can apply or dismiss labels,\\r\\ncreate or modify issues, and assign issues to others. It also allows you to add/update test recordings in the test assets repo.\\r\\n\\r\\nTo get access to Azure SDK repos, request to join the [Azure SDK Partners](https://aka.ms/azsdk/join/azuresdkpartners) \\r\\nand have the request approved by your manager.  *After your manager approves*, it may take up to one day for you to automatically\\r\\nbe added to the [azure-sdk-partners](https://github.com/orgs/Azure/teams/azure-sdk-partners) GitHub team. This will get you\\r\\nwrite access to all Azure SDK related repos. These membership requests will need to be renewed every 180 days.\\r\\n\\r\\nNote that write access will also give you the ability to merge to the 'main' branch in each of the Azure SDK repos. However,\\r\\nthrough branch protection rules, CODEOWNERS approval of PRs is required. This means that for each file/folder your PR has\\r\\nmodified you will need to get approval from the corresponding people listed in the repo's  \\r\\n[CODEOWNERS file](https://github.com/Azure/azure-sdk/blob/main/docs/policies/opensource.md#codeowners). GitHub will automatically\\r\\nadd all matching CODEOWNERS as reviewers to the PR. You need approval from one CODEOWNER in each area in order to merge.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-prerequisites.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites\",\"content\":\"# Prerequisites to release client libraries (SDK)\\n## Before you begin\\n- You have completed [the SDK generation](xref:sdk-generate) and created an SDK pull requests to the respective Azure SDK repository.\\r\\n- For an initial SDK release of your service, ensure that the [review of your SDK package\\r\\n  name](xref:namespace-review) — specified in the tspconfig.yaml configuration file — has been completed.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-pipeline.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-pipeline\",\"content\":\"# Run release SDK pipeline\\n## SDK release pipeline\\n### Approve the release\\n\\u003e [!IMPORTANT]\\r\\n\\u003e Once a package is published to a package manger, the action is final and cannot be reversed.\\r\\n\\u003e While it is possible to remove or conceal problematic packages, reusing the same version number is not an option.\\r\\n\\u003e All future package releases require a version change at minimum.\\r\\n\\r\\nEach package generated by the pipeline has an individual approval checkpoint before it is finalized for publishing.\\r\\nThis allows you to selectively approve a specific package for release while declining the rest.\\r\\n\\r\\n1. Read our [Azure SDK approval release guidelines](xref:sdk-approval-release-guidelines).\\r\\n1. Click on the **Review** button in the pipeline run to start the approval process.\\r\\n1. Select which of the packages you want to approve for release.\\r\\n1. Select **Reject** for the packages you do not want to release.\\r\\n\\r\\n\\u003e[!IMPORTANT]\\r\\n\\u003e Make sure to approve only your package's release stage as the pipeline is shared among multiple packages.\\r\\n\\r\\n![Approve release example](../../img/approve_release.png)\\r\\n\\r\\nOnce you click approve the pipeline will proceed to tag the sources that were just built with the package name and\\r\\nversion and then publish the package to the appropriate package manager.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#namespace-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/namespace-review\",\"content\":\"# Review SDK package names\\nRequest a namespace review with SDK architects to ensure that your changes adhere to Azure guidelines.\\r\\nA namespace review is required for new libraries that haven't yet been released in an SDK.\\r\\n\\r\\n\\u003c!-- Todo: Move the examples at the bottom to this section. Provide the guidelines, then show how to request a review.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-approval-release-guidelines.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-approval-release-guidelines\",\"content\":\"# Azure SDK approval release guidelines\\nOnce your request to [Azure SDK Partners](https://aka.ms/azsdk/join/azuresdkpartners) has been approved,\\r\\nyou will gain the authority to approve package releases. Once a package is released to the public registry,\\r\\nthe action is final and cannot be reversed. Therefore, it is imperative that you first familiarize yourself\\r\\nwith the SDK package release guidelines.\\r\\n\\r\\nAs a release approver, you are accountable for ensuring the integrity of the packages your team deploys. Given that\\r\\nreleases are typically irreversible, it is crucial to validate that the packages function correctly before release.\\r\\nWhile it is possible to re-release to rectify hotfix issues, it is important to be mindful of the potential negative\\r\\nimpact that deploying defective packages could have on the credibility of both your service and our broader platform.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e Once a package is released to the public registry, the action is final and cannot be reversed.\\r\\n\\u003e Exercise due diligence in validating the package before making it available to ensure that it meets the necessary\\r\\n\\u003e quality standards and avoids any potential issues post-release.\\r\\n\\r\\nEnsure that you:\\r\\n\\r\\n1. Only approve release which you possess a comprehensive understanding and context.\\r\\n\\r\\n    Do not blindly approve other requests that come up for approval.\\r\\n\\r\\n1. Verify the set of packages is accurate and complete.\\r\\n\\r\\n    You can find packages in the artifacts for the release pipeline. Check that:\\r\\n\\r\\n    - The names of the packages are accurate.\\r\\n    - The versions of the packages are correct.\\r\\n    - The set of packages is as expected, with no additional or missing items.\\r\\n\\r\\n1. Verify that the required validation checks have been performed.\\r\\n\\r\\n    Either you or the person who requests the release must run the required validation prior to any release.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-prerequisites.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites\",\"content\":\"# Prerequisites to release client libraries (SDK)\\n## Commit tests\\nSDK usability is essential for customer success, so our SDKs must include tests.\\r\\n\\r\\nFor GA SDK releases of the management plane, .NET recommends live tests to ensure compatibility with the new service version.\\r\\n\\r\\nFor the data plane, according to the target phase of your SDK, these are the requirements you need to accomplish before the SDK release:\\r\\n\\r\\n- Public preview: at least one test per language for the most common usage scenario.\\r\\n- GA: at least one test per shipped method.\\r\\n\\r\\nAdditional resources on adding SDK tests for various languages and SDK types are available at [test SDKs](xref:sdk-test).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"onboard#index.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/onboard/index\",\"content\":\"# Onboard to Azure SDKs\\nAs an Azure service engineer, you can onboard your product to the Azure SDK team so that you can take advantage of REST\\r\\nAPI and SDK architectural guidance, reviews, tooling, and more.\\r\\n\\r\\n\\u003e[!TIP]\\r\\n\\u003e We are piloting our new AzSDK tools MCP server which includes the ability to generate the SDKs and\\r\\n\\u003e create a draft pull request in the respective language repository. Refer to \\r\\n\\u003e [AzSDK tools MCP server](xref:azsdk-tools-mcp) for instructions on how to install it and use it.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-prerequisites.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites\",\"content\":\"# Prerequisites to release client libraries (SDK)\\n## Write samples\\nEvery SDK needs a quickstart guide with code samples, as developers prefer learning from examples over lengthy documentation.\\r\\n\\r\\nEach management plane SDK release needs at least one sample per language for the main usage scenario.\\r\\n\\r\\nFor the data plane, according to the target phase of your SDK, these are the requirements you need to accomplish\\r\\nbefore the SDK release:\\r\\n\\r\\n- Public preview: at least one sample per language for the most common usage scenario.\\r\\n- GA: at least 4 samples for the most common usage scenario.\\r\\n\\r\\nAdditional resources on adding SDK samples for various languages and SDK types are available at [write SDK samples](xref:sdk-samples).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-test.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-test\",\"content\":\"# Test your SDK\\n## Before you begin\\n- You have [access](xref:access) to the GitHub repositories and respective GitHub groups.\\r\\n- You are familiarized with the [Azure SDK Architecture design guidelines](https://azure.github.io/azure-sdk/general_introduction.html).\\r\\n- You read our [repository branches strategy](https://azure.github.io/azure-sdk/policies_repobranching.html).\\r\\n- You need to have an SDK to write tests against.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"onboard#request-exception.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/onboard/request-exception\",\"content\":\"# Request an exception for Azure SDKs\\nIf your team is unable to fulfill an SDK release readiness requirement or you need more\\r\\ntime to release a specific language, you can request an exception by using [Cloud Lifecycle](https://vnext.s360.msftcloudes.com/cloudLifecycle/products).\\r\\n\\r\\nCloud Lifecycle exceptions are tracked as [extensions](https://eng.ms/docs/cloud-ai-platform/azure-edge-platform-aep/aep-engineering-systems/engineering-intelligence-standards/service-360/service-360-team-docs/cloudlifecycle/completelcs#take-action-on-lifecycle-requirements),\\r\\nwith the expectation that there will be a revised timeline agreed upon for completion of the requirements.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e It’s important to create a consistent developer experience across all Azure services and because of that, these CPEX SDK requirements were agreed on by SLT for all services. All exceptions require business justification, approval from the service partner's leadership team (CVP), and a plan to get compliant.\\r\\n\\u003e After the request is submitted, the Azure SDK team will review request within 7 business days.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-generate-mgmt-dotnet.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-generate-mgmt-dotnet\",\"content\":\"# Generate .NET management plane SDK\\n## Prerequisites for contributing\\n:point_right: Read [azure-sdk-for-net/CONTRIBUTING.md](https://github.com/Azure/azure-sdk-for-net/blob/main/CONTRIBUTING.md)\\r\\n\\r\\n:point_right: The guidance is mainly about contributing in the public SDK repositories for .NET. If you require assistance\\r\\nwith working on a feature that needs to be kept confidential until it is publicly available, reach out to us through the \\r\\n[Teams channel](#get-help) for additional support.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"index.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience\",\"content\":\"# Welcome to the Azure SDKs\\n## What we do\\nOur team is focused on providing guidance, best practices, and tooling to help address\\r\\ncommon Azure developer pain points, like these:\\r\\n\\r\\n- How do we make developers productive faster?\\r\\n- How do we make their job easier?\\r\\n- How do we provide a consistent seamless developer experience across Azure?\\r\\n- How do we provide a delightful developer experience for E2E scenarios?\\r\\n\\r\\n\\u003e[!TIP]\\r\\n\\u003e We are piloting our new AzSDK tools MCP server which includes the ability to generate the SDKs and\\r\\n\\u003e create a draft pull request in the respective language repository. Refer to [AzSDK tools MCP server](xref:azsdk-tools-mcp)\\r\\n\\u003e for instructions on how to install it and use it.\"}]", "inputs.latency": 1110.6672785282135, "inputs.response_length": 2177, "inputs.expected_reference_urls": [], "inputs.reference_urls": ["https://eng.ms/docs/products/azure-developer-experience/develop/sdk-review", "https://eng.ms/docs/products/azure-developer-experience/onboard/request-exception", "https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop"], "inputs.testcase": "Adoption of CBOR (and COSE) encoding/decoding throughout SDKs", "outputs.similarity.similarity": 3.0, "outputs.similarity.gpt_similarity": 3.0, "outputs.similarity.similarity_result": "fail", "outputs.similarity.similarity_threshold": 4, "outputs.similarity.similarity_prompt_tokens": 1373, "outputs.similarity.similarity_completion_tokens": 1, "outputs.similarity.similarity_total_tokens": 1374, "outputs.similarity.similarity_finish_reason": "length", "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14", "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Adoption of CBOR (and COSE) encoding/decoding throughout SDKs\\\\n\\\\nquestion: Hi, we are adopting CBOR in multiple places in the company, especially in the context of COSE signing envelopes, their verification.\\\\nCBOR and COSE encoding/decoding is supported natively in .NET SDK via System.Security.Cryptography.Cose already, and is being used in at least one SDK which follows specific RFC drafts.\\\\nHowever, other languages would need to also adopt it when the service expands. Which poses a question what libraries to use in each? I know specific dependencies that we can leverage but is there an approval process to \\\\\\\"allow\\\\\\\" them to become part of the SDKs, or should I just include the dependencies and review those in arch/sdk meeting for each language separately?\\\", \\\"response\\\": \\\"Based on the provided Azure SDK onboarding knowledge, there is no explicit approval process documented for adding new platform or third-party dependencies to Azure SDKs prior to including them. However, dependencies\\\\u2014including platform and third-party libraries\\\\u2014should be evaluated and reviewed as part of the SDK architecture and language-specific review meetings, particularly for data plane SDKs.\\\\n\\\\nFor data plane SDKs, you are required to schedule an SDK review meeting with the Azure SDK Architecture Board before publication. In these meetings, you should bring your proposed package dependencies for each language, alongside APIView listings and hero scenarios. This review ensures that the SDKs are developer-friendly, consistent, and meet Azure guidelines across all languages.\\\\n\\\\nFor management plane (ARM) SDKs, a review meeting is NOT required, but it is still recommended to follow Azure SDK design guidelines and best practices for dependency selection and consistency across languages.\\\\n\\\\nThe recommended approach for introducing CBOR/COSE dependencies is:\\\\n- For each language, select well-maintained, secure, and actively supported libraries that fulfill the CBOR/COSE requirements.\\\\n- Document your dependency choices and rationale in your SDK release plan and APIView submission.\\\\n- Discuss the dependencies in the SDK review meeting for each language (for data plane SDKs), ensuring architects and language leads are aware and can provide feedback or raise concerns about compatibility, support, or licensing.\\\\n- Ensure that your choices align with the Azure SDK architecture and language guidelines.\\\\n\\\\nIf you encounter governance or compliance issues, or need an exception (e.g., for a non-standard or unapproved dependency), you can formally request an exception via the Cloud Lifecycle process, which will require business justification and leadership approval.\\\\n\\\\nTo summarize: include your chosen dependencies in your initial SDK implementation, document them in your review materials, and have them evaluated as part of the standard SDK architecture and language review process. This ensures consistent, cross-language adoption and compliance with Azure standards.\\\", \\\"ground_truth\\\": \\\"I would suggest an email to azsdkarch@microsoft.com to discuss this.\\\"}\"}]", "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"}], "metrics": {"similarity.similarity": 3.4375, "similarity.gpt_similarity": 3.4375, "similarity.similarity_threshold": 4.0, "similarity.binary_aggregate": 0.44}, "studio_url": null}