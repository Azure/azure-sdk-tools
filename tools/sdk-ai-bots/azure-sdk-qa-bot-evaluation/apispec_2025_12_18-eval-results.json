{
    "rows": [
        {
            "inputs.query": "title: Suppression Review in RPSaaSDev\n\nquestion: Hi, I just created a PR to RPSaaSDev for our product which will help us test using the new RestrictTrafficToTestTenants feature.\nThe idea is that the changes we plan to merge to RPSaaSMaster will be mirrored in a dedicated folder in RPSaaSDev so we can test the exact swaggers we plan to ship, while we have another 'dev' folder where we put our iterative swagger changes which we plan to ship later.\nI raised the [PR against RPSaaSDev](https://github.com/Azure/azure-rest-api-specs-pr/pull/25834), but it got flagged for a suppression review. Is this a merge blocker for RPSaaSDev? I think it just got flagged since it's a new folder, but its the same suppressions that are already approved for that namespace in our dev folder as well as in RPSaaSMaster. Can we just merge? Thanks in advance!\n(This dual folder setup will never be reflected for our product in RPSaaSMaster by the way, just a development helper for us!)",
            "inputs.ground_truth": "RPSaaSDev does not require that checks pass before checking in the code,  so this is more like a warning that when this moves to one of the protected branches (RPSaaSMaster or public main) you will need to go through a suppression review.",
            "inputs.response": "The suppression review flag on your PR to the RPSaaSDev branch is NOT a merge blocker for RPSaaSDev. According to the branch protection rules, RPSaaSDev does not enforce required checks (including suppression review) as merge blockers, so you can proceed with merging your PR even if the suppression is flagged. Required checks and merge blockers are only enforced on production branches like public 'main' and private 'RPSaaSMaster'. The suppression review process is primarily relevant for those branches, where publishing to customers occurs. Your use of RPSaaSDev for testing and development is valid, and the presence of similar suppressions already approved in your dev folder or RPSaaSMaster does not affect your ability to merge to RPSaaSDev.\n\nHowever, it is good practice to keep your suppressions consistent and narrowly scoped. If the suppressions you need are already approved elsewhere, you may want to reference those approvals in your PR comment for transparency, but it will not block your merge to RPSaaSDev.\n\nFor production or public preview/GA, you must follow suppression review and approval on the production branches. For development branches like RPSaaSDev, you can merge despite suppression flags.",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# design#specs-pr-guides#pr-suppressions.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-suppressions](https://aka.ms/azsdk/pr-suppressions) |\\r\\n|--|--|\\n\\n# Suppress validation failures on a PR\\n\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nOn your Azure REST API specs PR, some of the GitHub check failures (see the `Checks` tab on your PR) can be suppressed.\\r\\nThe suppression can be either just for the PR, or permanent.\\n\\n## To suppress given validation failure\\n\\n1. Determine which failing check you want to suppress: see its name in the `Checks` tab in your PR.\\r\\n1. Determine if you have one of the [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. Determine if you want to suppress the failure only for the PR, or permanently.\\r\\n1. Consult [the suppression cases table](#suppression-cases-table) for instructions corresponding to your case.\\r\\n1. If you want to apply temporary suppression:\\r\\n   1. Mention in a comment on your PR the PR assignee asking to apply the suppression. Provide justification.\\r\\n      See [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. If you applied permanent suppression:\\r\\n   1. It will manifest by the PR getting a label `SuppressionReviewRequired`.\\r\\n   1. Verify the suppression works by the check changing from **failed** to **neutral**.\\r\\n   1. Wait until your suppression is reviewed. If it is approved, the approved will add the `Approved-Suppression` label.\\r\\n   1. Understand the suppression won't be approved if it is not one of the  \\r\\n      [valid suppression reasons](#valid-suppression-reasons) as explained in relevant section.\\n\\n## Suppression cases table\\n\\n|\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met | Not possible                              |                                                      | Not possible                                                    |\\r\\n\\r\\n[1] Applies only if the SDK generation check failed with a breaking change. For details of SDK breaking change suppression, see https://aka.ms/azsdk/sdk-suppression.\\r\\nGeneral SDK generation check failure suppressions are not supported. See [#6509].\\n\\n|\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger SemanticValidation         | See [aka.ms/ci-fix]                       | `Approved-SemanticValidation`                        | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger ModelValidation            | See [aka.ms/ci-fix]                       | `Approved-ModelValidation`                           | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger Breaking Change            | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Breaking Change(Cross-Version)     | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              |\\n\\nTable legend:\\r\\n\\r\\n- `Check name`: Check to suppress.\\r\\n- `PR suppression`: instructions to obtain suppression for given check for given PR only.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n- `Label`: the label your PR will get if your suppression is approved.\\r\\n- `Permanent suppression`: instructions how to get permanent suppression.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n\\r\\n| Check name                         | PR suppression                            | Label                                                | Permanent suppression                                           |\\r\\n|------------------------------------|-------------------------------------------|------------------------------------------------------|-----------------------------------------------------------------|\\r\\n| TypeSpec Requirement               | Not possible                              |                                                      | [suppressions.yaml](#suppressionsyaml)                      |\\r\\n| TypeSpec Validation                | Not possible                              |                                                      | Not possible                                                    |\\r\\n| license/cla                        | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 |\\n\\n|\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-net-track2       | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-go               | See [step 3 in the diagram] but note [1]. | `BreakingChange-Go-Sdk-Suppression-Approved`         | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-java             | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-js               | See [step 3 in the diagram] but note [1]. | `BreakingChange-JavaScript-Sdk-Suppression-Approved` | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met |\\n\\n## suppressions.yaml\\n\\nFile `suppressions.yaml` is used for all checks created in 2024 or later, like\\r\\n`TypeSpec Requirement` and `TypeSpec Validation`.\\r\\n\\r\\nFor simplicity, we recommend adding all suppressions to a single file at the root of your spec folder:\\r\\n\\r\\n```\\r\\nspecification/myservice/suppressions.yaml\\r\\n```\\r\\n\\r\\nAlternatively, you can use multiple files in separate folders.  Currently, tools will use the first\\r\\ninstance of `suppressions.yaml` found walking up the directory tree.  We are planning\\r\\nfuture support for \\\"merging\\\" files up the hierarchy.\\r\\n\\r\\nA suppression follows this general format:\\r\\n\\r\\n```\\r\\n- tool: ToolName\\r\\n  path: applies/to/**/*.json\\r\\n  reason: Why this can't be fixed\\r\\n```\\r\\n\\r\\n`path` uses \\\"glob\\\" matching.  For syntax, see https://www.npmjs.com/package/minimatch.\\r\\n\\r\\nScope your `path` as narrowly as possible.  For example, if a suppression only applies\\r\\nto a single version of your spec:\\r\\n\\r\\n```\\r\\n# good\\r\\n- path: data-plane/Azure.Contoso.WidgetManager/preview/2022-11-01-preview/**/*.json\\r\\n\\r\\n# bad\\r\\n- path: data-plane/**/*.json\\r\\n```\\r\\n\\r\\nWhen in doubt, search the repo for examples:\\r\\n\\r\\nhttps://github.com/search?q=repo%3AAzure%2Fazure-rest-api-specs+path%3A%2F%28%5E%7C%5C%2F%29suppressions%5C.yaml%24%2F\\u0026type=code\\n\\n### `TypeSpec Requirement` check\\n\\nTo suppress `TypeSpec Requirement` check for given pattern of OpenAPI spec .json file paths, provide an entry with\\r\\n`tool` set to `TypeSpecRequirement`. Provide the pattern as `path` and provide a `reason`.\\r\\n\\r\\nExample:\\r\\n\\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: data-plane/**/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## Suppress AutoRest extension\\n\\nTo suppress tooling that is an AutoRest extension (see [the suppressio\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"retirement#api-retirement.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/retirement/api-retirement\",\"content\":\"# Retiring Azure APIs\\n## Deprecating Preview REST APIs\\nFollow the process described in the [Azure REST API wiki](https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs) to remove your REST API spec from the specs repository.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Breaking changes and versioning issues\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"plan#upcoming_release_planner_change.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/plan/upcoming_release_planner_change\",\"content\":\"# SDK self-serve for TypeSpec generated management plane SDKs\\n## **2. Generate SDK**\\nResponsible: Service owner\\r\\n\\r\\n1. Submit a request using release planner. More information about release planner is available  \\r\\n[here](https://eng.ms/docs/products/azure-developer-experience/plan/release-plan).\\r\\n2. Automation creates an issue in the [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) repository and it is assigned to Copilot.\\r\\n3. This uses our [automation pipelines](xref:sdk-generate) and as a result it creates a PR in each language repo.\\r\\n4. PRs are open in `DRAFT` state and links for these PRs will be visible in the generate SDK step in the release planner.\\r\\n5. Service owner needs to verify the content of the PRs.\\r\\n6. When the PR is ready for review, access the PR URL and click on `Ready for review` button in GitHub. This will assign the Azure SDK team as reviewers.\\r\\n7. Azure SDK team reviews and approves PR.\\r\\n8. Service team addresses feedback and is responsible for merging the PR.\\r\\n\\r\\n**Troubleshooting steps:**\\r\\n\\r\\nSDK is generated by GitHub Copilot Agent when a generate SDK request is submitted. The release planner contains the link to this GitHub tracking issue.\\r\\n\\r\\nIf the SDK PR doesn’t appear in the release planner within **~30 minutes** after submitting a request, or if you need to **regenerate** the SDK, follow these steps to check the status:\\r\\n\\r\\n1. Identify the GitHub issue created for SDK generation. This is visible in the **Generate SDK** step in the release planner. \\r\\n2. Open the GitHub issue and identify the PR associated with the GitHub issue. This PR is assigned to GitHub Copilot.\\r\\n3. Check for any comment on GitHub PR that indicates any failure to generate SDK. If SDK generation pipeline is in failed status, you can access the failure reason by clicking on pipeline run link.\\r\\n4. If failure indicates any changes required in API spec TypeSpec project:\\r\\n\\r\\n  -  Update the **TypeSpec project** as needed\\r\\n- Create a new TypeSpec PR or push changes to existing one (if it's still open).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# Create a pull request with your Azure REST API spec update\\n## Get your PR merged\\n| Short Link: | [aka.ms/azsdk/specreview/merge](https://aka.ms/azsdk/specreview/merge) |\\r\\n|-|-|\\r\\n\\r\\nTo get your PR merged:\\r\\n\\r\\n1. Ensure the `Next Steps to Merge` comment and `Automated merging requirements met` check are green. \\r\\n1. Ensure at least one person has approved your PR. Generally another person from your team that has [write access] to the repo.\\r\\n1. Ensure all required checks are passing and at least investigate to understand any other non-required checks that may be failing. \\r\\n1. Once all required checks are green and any other issues understood you can merge the PR yourself as long as you have [write access] to the repo.\\r\\n1. If your PR is targeting public `main` you will need to first apply the `PublishToCustomers` label to acknowledge you understand this \\r\\n   will cause your spec to be published so customers can consume it.\\r\\n1. If your PR is targeting private repo `main` branch, it **cannot** be merged.\\r\\n   Instead, you can publish your changes to customers by following the guide at [aka.ms/azsdk/move-pr].\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Branch protection rules table\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\nThis table shows which GitHub checks are marked as `required` on respective branches. Even when a check is marked as ❌\\r\\nit **may** still be running on given branch; just that if it fails, the PR won't be blocked from merging.\\r\\n\\r\\n| Branch | Merge | SDK | TSVal | BrCh | BrChC | LintRPaaS | LintDiff | Model | Semantic | Spell | Prettier | license | approver |\\r\\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\\r\\n| public `main`                  | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSMaster`         | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| public/private `release-*`     | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSDev`            | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `InternalARMContracts` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `ARMCoreRPDev`         | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n\\r\\nLegend:\\r\\n\\r\\n| Column name | Full GitHub check name               |\\r\\n|-------------|--------------------------------------|\\r\\n| `BrCh`      | `Swagger BreakingChange`             |\\r\\n| `BrChC`     | `Breaking Change(Cross-Version)`     |\\r\\n| `license`   | `license/cla`                        |\\r\\n| `LintDiff`  | `Swagger LintDiff`                   |\\r\\n| `LintRPaaS` | `Swagger Lint(RPaaS)`                |\\r\\n| `Merge`     | `Automated merging requirements met` |\\r\\n| `Model`     | `Swagger ModelValidation`            |\\r\\n| `Prettier`  | `PrettierCheck`                      |\\r\\n| `SDK`       | `SDK azure-sdk-for-go`               |\\r\\n| `Semantic`  | `Swagger SemanticValidation`         |\\r\\n| `Spell`     | `SpellCheck`                         |\\r\\n| `TSVal`     | `TypeScript Validation`              |\\r\\n| `approver`  | Requires team member approval        |\\r\\n\\r\\nFor more information on these checks, see:\\r\\n\\r\\n- https://aka.ms/azsdk/pr-getting-help\\r\\n- https://aka.ms/ci-fix\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Spec repos branches\\n### Private specs repo `RPSaaSMaster` branch\\n[Private specs repo] `RPSaaSMaster` contains RPaaS-based ARM specifications.\\r\\n\\r\\nWhen an RPaaS-based ARM API goes into `public preview` or `GA` lifecycle stage it must be merged to [public specs repo]\\r\\n`main` as well.\\r\\n\\r\\nSome parts of this branch are being mirrored from public `main` branch\\r\\nby the [mirror-repos] pipeline, triggered manually on at least daily basis.\\r\\n\\r\\nService teams are responsible for keeping their API specifications in this branch synchronized with\\r\\nthe public specs repo `main` branch.\\r\\n\\r\\nSee also [ARM lifecycle stages requirements] and [ARM branches].\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-arm-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-arm-review\",\"content\":\"# Get your PR reviewed by ARM\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nIf your Azure REST API specs PR pertains to ARM (see [glossary](xref:glossary#arm)) specs,\\r\\nthen the second step of the PR approval process per the [PR workflow diagram] (https://aka.ms/azsdk/pr-diagram)\\r\\nis the ARM review. The overall PR approval process is explained at https://aka.ms/azsdk/specreview/merge.\\r\\n\\r\\nIf your PR does not pertain to ARM specs, then this article won't be relevant to you.\\r\\nSee instead [`Getting help` section] on your PR (https://aka.ms/azsdk/pr-getting-help).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Addressing `BreakingChangeReviewRequired`\\n### `BreakingChange-Approved-Previously`\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## API version lifecycle stages\\n### In development\\n**In development** API versions are all API versions that are not `GA`, in `public preview` or in `private preview`.\\r\\nNotably, such API versions are not present in the [public specs repo] `main` branch and do not have any customers.\\r\\nHowever, they may be present in the public repo feature branches.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e REST API definitions for a service or API version that is `in development` MUST NOT be present in the  \\r\\n\\u003e [public specs repo] `main` at all.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e ARM spec API version, while `in development`, should not be trying to merge into `RPSaaSMaster`.\\r\\n\\u003e The ARM guidance for this is in [ARM spec onboarding] article.\\r\\n\\r\\n**Special cases** There are few special situations that do not fit in the API versioning model described above.\\r\\nIn such situations, attend appropriate office hours:\\r\\n\\r\\n- In case of ARM specs, **ARM API Review Office Hours** in [aka.ms/armofficehoursinfo].\\r\\n- In case of data-plane specs, [aka.ms/azapi/officehours].\"}]",
            "inputs.latency": 58.58155393600464,
            "inputs.response_length": 1221,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches",
                "https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr"
            ],
            "inputs.testcase": "Suppression Review in RPSaaSDev",
            "outputs.similarity.similarity": 5.0,
            "outputs.similarity.gpt_similarity": 5.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1361,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1362,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Suppression Review in RPSaaSDev\\\\n\\\\nquestion: Hi, I just created a PR to RPSaaSDev for our product which will help us test using the new RestrictTrafficToTestTenants feature.\\\\nThe idea is that the changes we plan to merge to RPSaaSMaster will be mirrored in a dedicated folder in RPSaaSDev so we can test the exact swaggers we plan to ship, while we have another 'dev' folder where we put our iterative swagger changes which we plan to ship later.\\\\nI raised the [PR against RPSaaSDev](https://github.com/Azure/azure-rest-api-specs-pr/pull/25834), but it got flagged for a suppression review. Is this a merge blocker for RPSaaSDev? I think it just got flagged since it's a new folder, but its the same suppressions that are already approved for that namespace in our dev folder as well as in RPSaaSMaster. Can we just merge? Thanks in advance!\\\\n(This dual folder setup will never be reflected for our product in RPSaaSMaster by the way, just a development helper for us!)\\\", \\\"response\\\": \\\"The suppression review flag on your PR to the RPSaaSDev branch is NOT a merge blocker for RPSaaSDev. According to the branch protection rules, RPSaaSDev does not enforce required checks (including suppression review) as merge blockers, so you can proceed with merging your PR even if the suppression is flagged. Required checks and merge blockers are only enforced on production branches like public 'main' and private 'RPSaaSMaster'. The suppression review process is primarily relevant for those branches, where publishing to customers occurs. Your use of RPSaaSDev for testing and development is valid, and the presence of similar suppressions already approved in your dev folder or RPSaaSMaster does not affect your ability to merge to RPSaaSDev.\\\\n\\\\nHowever, it is good practice to keep your suppressions consistent and narrowly scoped. If the suppressions you need are already approved elsewhere, you may want to reference those approvals in your PR comment for transparency, but it will not block your merge to RPSaaSDev.\\\\n\\\\nFor production or public preview/GA, you must follow suppression review and approval on the production branches. For development branches like RPSaaSDev, you can merge despite suppression flags.\\\", \\\"ground_truth\\\": \\\"RPSaaSDev does not require that checks pass before checking in the code,  so this is more like a warning that when this moves to one of the protected branches (RPSaaSMaster or public main) you will need to go through a suppression review.\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"5\"}]"
        },
        {
            "inputs.query": "title: How to Sdk generation in local\n\nquestion: I have couple of prs failing with sdk validation.\nIs there a way to reproduce these errors in local?",
            "inputs.ground_truth": "You can run our tooling locally with our Azure SDK Tools MCP: [AzSDK agent](https://eng.ms/docs/products/azure-developer-experience/develop/azsdk-tools-mcp)\nIt will help:\nvalidating your local environment\ngenerating the SDKs locally\nlearn more about the SDK generation and release process\nThe documentation shared has example prompts you can try.",
            "inputs.response": "Yes, you can reproduce SDK validation errors locally before submitting or updating your pull request. The recommended approach is to build and test your SDK code in your local development environment, which allows you to catch build and validation issues that might otherwise cause PR failures.\n\nFor most Azure SDK language repositories, the `CONTRIBUTING.md` file provides detailed setup instructions. After cloning the repo and setting up the required tools (such as .NET, Java, Python, Node.js, etc.), you should:\n\n1. Build your SDK locally using the language-specific commands (e.g., `dotnet build`, `mvn compile`, `pip install -e .`, etc.).\n2. Run the tests using the provided commands (e.g., `dotnet test`, `pytest`, `mvn test`, etc.).\n\nThis will surface most validation errors, including those related to code generation, tests, and compliance checks.\n\nFor management plane .NET SDKs generated from OpenAPI, you can use AutoRest locally:\n- Install AutoRest: `npm install -g autorest`\n- Run: `autorest readme.md` (pointing to your spec folder)\n\nFor additional validation and error details, check the build logs in your local runs and compare them with the CI pipeline errors. If you are stuck or the errors are unclear, reach out to the language-specific team channel for support.\n\nNote: Not all CI validation checks are guaranteed to run identically locally (some security/compliance checks may require pipeline context), but build and test failures are reliably reproducible.\n\nReferences to the detailed setup for each language are provided below.",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-test.md\",\"document_title\":\"Test your SDK\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-test\",\"content\":\"# develop#sdk-test.md\\n\\n# Test your SDK\\n\\nUsability is a critical factor in the success of SDKs for our customers, which is why our SDKs must include tests.\\n\\n## Before you begin\\n\\n- You have [access](xref:access) to the GitHub repositories and respective GitHub groups.\\r\\n- You are familiarized with the [Azure SDK Architecture design guidelines](https://azure.github.io/azure-sdk/general_introduction.html).\\r\\n- You read our [repository branches strategy](https://azure.github.io/azure-sdk/policies_repobranching.html).\\r\\n- You need to have an SDK to write tests against.\\n\\n### [Management plane (ARM)](#tab/management)\\n\\nFor a GA (stable) SDK release, .NET recommends to include live tests to verify that the SDK functions correctly with\\r\\nthe targeted new service version.\\r\\n\\r\\n:point_right: [.NET](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/resourcemanager/Azure.ResourceManager/docs/TestGuide.md)\\r\\n\\r\\n:point_right: [Java](https://github.com/Azure/azure-sdk-for-java/wiki/TypeSpec-Java-Quickstart#adding-tests)\\r\\n\\r\\n:point_right: [JavaScript](https://github.com/Azure/azure-sdk-for-js/blob/main/CONTRIBUTING.md#testing)\\r\\n\\r\\n:point_right: [Python](https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/mgmt/tests.md)\\r\\n\\r\\n:point_right: [Go](https://github.com/Azure/autorest.go/blob/main/packages/autorest.gotest/doc/gotest_howto.md#generate-mock-test-and-execute)\\n\\n### [Data plane](#tab/dataplane)\\n\\nAccording to the target phase of your SDK, these are the requirements you will need to accomplish so you can release your SDK:\\r\\n\\r\\n- Public preview: at least one test per language for the most common usage scenario.\\r\\n- GA: at least one test per shipped method.\\r\\n\\r\\nTutorials to add tests:\\r\\n\\r\\n:point_right: [.NET](https://github.com/Azure/azure-sdk-for-net/blob/main/doc/DataPlaneCodeGeneration/Azure_SDK_Package_Ship_Requirements.md#tests)\\r\\n\\r\\n:point_right: [Java](https://aka.ms/azsdk/dpg/java/tests)\\r\\n\\r\\n:point_right: [JavaScript](https://aka.ms/azsdk/dpg/js/tests)\\r\\n\\r\\n:point_right: [Python](https://aka.ms/azsdk/dpg/python/tests)\\r\\n\\r\\n:point_right: [Go (optional)](https://github.com/Azure/azure-sdk-for-go/blob/main/documentation/developer_setup.md#write-tests).\\n\\n## Get help\\n\\nReach out to the specific language Teams channel under our [Azure SDK channel](https://teams.microsoft.com/l/team/19%3af6d52ac6465c40ea80dc86b8be3825aa%40thread.skype/conversations?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-generate-mgmt-dotnet.md\",\"document_title\":\"Generate .NET management plane SDK\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-generate-mgmt-dotnet\",\"content\":\"# develop#sdk-generate-mgmt-dotnet.md\\n\\n# Generate .NET management plane SDK\\n\\nAzure service engineering team is required to work on .NET management plane SDKs.\\r\\n\\r\\n\\u003e[!IMPORTANT]\\r\\n\\u003e The instructions in this document are for generating SDK from an OpenAPI API spec.\\r\\n\\u003e If your API spec is authored on Typespec, follow the instructions in [Generate SDKs](xref:sdk-develop#generate-sdk)\\n\\n## Before you begin\\n\\n- You have completed the same prerequisites listed in the [Develop SDK - Before you begin](xref:sdk-develop) section.\\r\\n- Ensure that you have the latest version of [PowerShell](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows) \\r\\ninstalled to run all commands successfully.\\n\\n## Prerequisites for contributing\\n\\n:point_right: Read [azure-sdk-for-net/CONTRIBUTING.md](https://github.com/Azure/azure-sdk-for-net/blob/main/CONTRIBUTING.md)\\r\\n\\r\\n:point_right: The guidance is mainly about contributing in the public SDK repositories for .NET. If you require assistance\\r\\nwith working on a feature that needs to be kept confidential until it is publicly available, reach out to us through the \\r\\n[Teams channel](#get-help) for additional support.\\n\\n## Generate SDKs with OpenAPI\\n\\n- Specify a target version using `tag` as belows if you don't want to use the default tag in [the README configuration file](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/README.md). For example,\\r\\n\\r\\n```\\r\\ntag: package-2022-01-01-preview\\r\\n```\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e To ensure the preview of the corresponding .NET SDK in the API Spec PR, refrain from adding the tag here. Instead, use the default tag to generate the SDK and preview it as desired.\\r\\n\\r\\n2. Run `dotnet build` command to generate the SDK code, then AutoRest will create your .NET SDK using the latest version of your API specs.\\r\\n\\r\\n```\\r\\ndotnet build /t:GenerateCode\\r\\n```\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e Currently there could be some compatibility issues that the AutoRest tool can't handle. If you encounter generation errors, file an issue in the GitHub Repo [Azure/azure-sdk-for-net](https://github.com/Azure/azure-sdk-for-net) to get support.\\r\\n\\r\\n3. Generate the API file with the following command, review it and update any SDK API if it does not follow the [.NET Azure SDK Design Guidelines](https://azure.github.io/azure-sdk/dotnet_introduction.html) with [mgmt configurations](https://github.com/Azure/autorest.csharp/blob/feature/v3/docs/mgmt/readme.md#management-plane-configurations) in `autorest.md`. Then regenerate the API file.\\r\\n\\r\\n```\\r\\n\\u003cRepoRoot\\u003e\\\\eng\\\\scripts\\\\Export-API.ps1 servicelinker\\r\\n```\\r\\n\\r\\n:point_right: Replace `servicelinker` with your SDK service directory name under azure-sdk-for-net\\\\sdk.\\r\\n\\r\\n4. Once the SDK is generated, build your project either in VS or from command line (follow steps in the section [Build \\u0026 test SDKs](#build--test-sdks)\\n\\n`Azure.ResourceManager.ServiceLinker` is being used as our prime example for OpenAPI.\\r\\n\\r\\n1. Use any editor to open the `autorest.md` under `src` subfolder, and update:\\r\\n\\r\\n    - Go to the [ServiceLinker readme.md in Azure REST API Specs Repo](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/servicelinker/resource-manager/readme.md), press 'Y' key to [get the permanent link](https://docs.github.com/en/repositories/working-with-files/using-files/getting-permanent-links-to-files) and substitute the `require` value with your specific path here:\\r\\n\\r\\n```\\r\\nrequire: https://github.com/Azure/azure-rest-api-specs/blob/{guid}/specification/servicelinker/resource-manager/readme.md\\r\\n```\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e  * You can use a local patch as the value, which allows you to test an unpublished local OpenAPI spec.\\r\\n\\u003e  * When releasing your SDKs, it must refer to [the `main` branch of the public Azure REST API specs repository](https://github.com/Azure/azure-rest-api-specs/tree/main/specification). Other branches, private repos, or personal repos are **NOT** supported to release an official Azure SDK.\\r\\n\\u003e  * If you need to generate SDKs from specs in [the private REST API Specs repo](https://github.com/Azure/azure-rest-api-specs-pr), there is [an extra step to handle the credential for autorest](https://github.com/Azure/autorest/blob/main/docs/generate/readme.md#generate-from-private-github-repos).\\r\\n\\r\\n    - Specify a target version using `tag` as belows if you don't want to use the default tag in [the README configuration file](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/README.md). For example,\\r\\n\\r\\n```\\r\\ntag: package-2022-01-01-preview\\r\\n```\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e To ensure the preview of the corresponding .NET SDK in the API Spec PR, refrain from adding the tag here. Instead, use the default tag to generate the SDK and preview it as desired.\\n\\n## Build \\u0026 test SDKs\\n\\nLaunch command prompt or PowerShell. Navigate to the subfolder of your project cloned to local workstation. Use `dotnet` command to build and test the project. Take `Azure.ResourceManager` for example:\\r\\n\\r\\n```\\r\\ncd .\\\\sdk\\\\resourcemanager\\\\Azure.ResourceManager\\\\\\r\\ndotnet build /* This builds the Azure.ResourceManager SDK. */\\r\\ndotnet test -f net6.0 /* This builds the Azure.ResourceManager SDK and run tests with Net 6.0. */\\r\\ndotnet pack /* This builds Azure.ResourceManager SDK, skips running tests, and finally creates Azure.ResourceManager nuget package. */\\r\\n```\\n\\n## Next steps\\n\\n- [Write tests](xref:sdk-test)\\r\\n- [Write samples](xref:sdk-samples)\\r\\n- [Release Management Plane SDK for .NET](xref:sdk-release-mgmt-dotnet)\\n\\n## Get help\\n\\n[Code Generation - .NET](https://teams.microsoft.com/l/channel/19%3Aacbd512e57bd475198ea6bf4564599e3%40thread.skype/Code%20Generation%20-%20.NET?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#azsdk-tools-mcp.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/azsdk-tools-mcp\",\"content\":\"# develop#azsdk-tools-mcp.md\\n\\n| Short Link: | [aka.ms/azsdk/agent](https://aka.ms/azsdk/agent) |\\r\\n| --- | --- |\\n\\n# AzSDK agent\\n\\nUse the new AzSDK agent to guide the process for creating and releasing your\\r\\nAzure SDKs from your API definition.\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e - The agent is in preview state. Constantly check this page to get latest updates.\\r\\n\\u003e - The agent supports only TypeSpec API spec for both data plane and management plane SDK generation.\\n\\n## Before you begin\\n\\n- Verify you have [access](xref:access) to the GitHub repositories and respective GitHub groups.\\r\\n- Install [GitHub CLI](https://cli.github.com/) version `2.30.0` or higher.\\r\\n- Install [PowerShell core](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell?view=powershell-7.5)\\r\\n- Install [Node.js](https://nodejs.org/en) version `22.16.0`\\n\\n## Configure and enable the AzSDK tools MCP server\\n\\n1. Open VS Code and ensure you are at the root of the cloned repository: [REST API spec](xref:api-repos) or client\\r\\nlibraries (SDKs) repositories.\\r\\n2. Open VS Code GitHub Copilot agent (CTRL + Shift + I, CTRL + Alt + I)\\r\\n3. Select agent mode.\\r\\n![Select agent](../img/select_agent.png)\\n\\n### Validate MCP server\\n\\nValidate that the MCP server is running by **clicking** on the refresh button in the Copilot window to start the server.\\r\\nThis takes few seconds to download the MCP server and start.\\r\\n![Refresh copilot](../img/refresh_copilot.png)\\r\\nYou can verify currently running MCP servers using `CTRL + Shift + P` -\\u003e `MCP: List Servers`.\\r\\nIt should list `azure-sdk-mcp` server in running state.\\r\\n![Agent running](../img/agent_running.png)\\r\\nIf the agent is not running:\\r\\n- Click on `Start server`\\r\\n- Click on `Authorize` on the open dialog\\n\\n## Agentic workflow scenarios\\n\\n### Verify Setup\\n\\nTo test Python setup requirements with a specific virtual environment, set the environment variable `AZSDKTOOLS_PYTHON_VENV_PATH` to the absolute path to the virtual environment.\\r\\n| Scenario | Example prompt |\\r\\n| -------- | ------- |\\r\\n| Verify that the environment has necessary installations to use SDK MCP tools for the working repository. | \\\"Verify my setup.\\\" |\\r\\n| Verify that the environment has necessary installations to use SDK MCP tools for specific language requirements. | \\\"Verify my setup for \\u003clanguages\\u003e.\\\" |\\n\\n### Release Plan\\n\\n| Scenario | Example prompt |\\r\\n| -------- | ------- |\\r\\n| Provide guidance on how to get a pull request merged. | \\\"My spec PR is not merged, what should I do?\\\" |\\r\\n| Provide the status of the current PR. | \\\"I have submitted a spec PR \\u003cpr number\\u003e. What's the status of it?\\\" |\\r\\n| Check if a release plan exists for the TypeSpec changes. | \\\"Is there a release plan created?\\\" |\\r\\n| Check the language SDKs being released. | \\\"What languages are a part of this release?\\\" |\\r\\n| Check blockers for SDK release. | \\\"Is my SDK ready to be released?\\\" |\\r\\n| Guide the user through the release process using the release planner. | \\\"How can I release my SDK?\\\" |\\n\\n### Generate code\\n\\n| Scenario | Example prompt |\\r\\n| -------- | ------- |\\r\\n| Migrate Swagger services to use TypeSpec. | \\\"Migrate my #file:specification/org-name/service-type/readme.md swagger spec to TypeSpec. Make sure the final results follow the latest Azure best practices.\\\" |\\r\\n| Create a new service using TypeSpec. | \\\"Create a new service\\\"\\\\n\\\\n\\\"Create a new data plane service in the zava org\\\" |\\r\\n| Provide guidance on the steps to generate SDKs. | \\\"How do I generate SDK from TypeSpec?\\\" |\\r\\n| Generate SDK code for a specific language. | \\\"Generate .NET SDK code from this TypeSpec\\\" |\\r\\n| Update SDK code for an existing project. | \\\"Re-generate SDK code for the current SDK project\\\" |\\r\\n| Build/Compile SDK code. | \\\"Build the current SDK project\\\" |\\n\\n### Validate changes\\n\\n| Scenario | Example prompt |\\r\\n| -------- | ------- |\\r\\n| Validate that the spelling within the package is correct. | \\\"Do I have any typos?\\\" |\\r\\n| Validate that the ChangeLog is correctly formatted. | \\\"Is my changelog correct?\\\" |\\r\\n| Validate that the ReadMe is correctly formatted. | \\\"Is my readme correct?\\\" |\\r\\n| Validate that the TypeSpec project compiles and passes checks locally. | \\\"Validate my TypeSpec project\\\" |\\r\\n| Run all the validation checks at once. | \\\"Help me run my validation checks\\\" |\\n\\n## Current limitations\\n\\nWe are constantly working on improving the functionalities of the AzSDK Agent. This is the list of limitations\\r\\npresent:\\r\\n- Supported only in VS Code GitHub Copilot.\\r\\n- Breaking changes in SDKs are not validated\\r\\n- Meetings can't be booked using the AzSDK Agent.\\r\\n- Our goal is to be LLM-agnostic, but most of our current testing (as of Aug 2025) has been completed on\\r\\nClaude Sonnet 4 and 4.1, and GPT-4 and 5. Additionally, the MCP server can handle various types of outcomes\\r\\nand depending on the intended outcome, one model may be more optimized for a given task (e.g. generating\\r\\ndocumentation vs generating code vs explaining our processes) than another model.\\n\\n## Demos\\n\\nThe agent is constantly changing and getting updates. Here are the latest demos recorded according to specific use cases:\\r\\n- Use case: Service team works on TypeSpec locally, generates Python and Java SDKs locally, gets APIView review, and addresses comments. [Demo link](https://microsoft.sharepoint.com/:v:/t/AzureDeveloperExperience/EXbGlJGuglJHjUWyJqqTTxoBfd3l0kSWe8Fe3e47Cfio1A?e=tv8RPl). Note that address comments on APIView is still in development.\\r\\n- Use case: Liftr team uses the Azsdk tools MCP for their workflow and uses automation\\r\\nwhen generating the SDKs. [Demo link](https://microsoftapc.sharepoint.com/:v:/t/Liftrplatformservices/EWJ_IZ7QBwJKmy_lU-Gc0xMBp4JKl2-IzuBNO-WGn2qDIw?e=bxgJOg\\u0026nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D)\\r\\n  - Thank you to the **Liftr team** for their partnership and specially to **Yashika Jain** for her constant feedback\\r\\nand for authoring the demo.\\n\\n## Get help\\n\\nFor assistance, visit the [Azure SDK / DevEx Agent](https://teams.microsoft.com/l/channel/19%3A6d2c19322c254a80bcc521675134da03%40thread.skype/DevEx%20Agent?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-prerequisites.md\",\"document_title\":\"Prerequisites to release client libraries (SDK)\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-prerequisites\",\"content\":\"# develop#sdk-release#sdk-release-prerequisites.md\\n\\n# Prerequisites to release client libraries (SDK)\\n\\nAfter [executing the automation to generate SDKs](xref:sdk-generate) directly from your API\\r\\nspecification in TypeSpec, it is necessary to perform all required tasks outlined on this page before \\r\\n[initiating the SDK release pipeline](xref:sdk-release-pipeline) for publication.\\n\\n## Before you begin\\n\\n- You have completed [the SDK generation](xref:sdk-generate) and created an SDK pull requests to the respective Azure SDK repository.\\r\\n- For an initial SDK release of your service, ensure that the [review of your SDK package\\r\\n  name](xref:namespace-review) — specified in the tspconfig.yaml configuration file — has been completed.\\n\\n## Customize SDKs\\n\\nAfter generating client code with automation, it may be necessary to rename models, attributes, operations,\\r\\nor parameters to maintain consistent naming conversions.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e Azure SDK mandates adherence to a consistent set of naming conventions, which significantly enhances the overall usability of the SDK. For instance, in the case of Azure SDK for .NET, developers are required not only to follow the [general naming conventions of .NET](https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions), but also to comply with specific guidelines regarding the naming of classes, properties, and methods. Further information is available at [Azure SDK for .NET – naming conventions](https://github.com/Azure/azure-sdk-for-net/blob/main/doc/dev/Mgmt-Naming-Conventions.md). Guidelines for additional languages are available at the [Azure SDKs site](https://azure.github.io/azure-sdk/general_introduction.html)\\r\\n\\r\\nTo customize the SDK as needed, you need to configure `client.tsp`. More details can be found at the \\r\\n[setup for SDK customization]( https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/01setup/)\\r\\nand [renaming types](https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/09renaming/#customizations). \\r\\n\\r\\nAfter set up SDK customization and apply renaming, ensure to re-run the SDK generation to regenerate the client libraries.\\n\\n## Resolve Breaking Changes\\n\\nThe automation that generates the SDKs detect and report any breaking changes in the APIs to maintain backward compatibility.\\r\\nIt is necessary to review these breaking changes, retaining only those that are unavoidable and have been evaluated and\\r\\napproved through the [CPEX Breaking Changes Review Process](https://eng.ms/docs/cloud-ai-platform/azure-core/azure-core-product/product-lifecycle-management-plm/service-lifecycle-and-actions-team/service-lifecycle-actions-team/cpex/media/overview_breaking_changes#cpex-breaking-changes-review-process).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e CPEX (Cloud Product Excellence) Breaking Change Policy documentation covers Azure's requirements on service versioning and breaking changes. Generally, we must avoid introducing any breaking changes into our services, products, APIs, or SDKs. If a breaking change is unavoidable, we must provide customers a three-year notification for migration and fully support the prior versions during that period. More details about CPEX Breaking Changes Review Process can be found at this [Azure Breaking Changes](https://eng.ms/docs/cloud-ai-platform/azure-core/azure-core-product/product-lifecycle-management-plm/service-lifecycle-and-actions-team/service-lifecycle-actions-team/cpex/media/overview_breaking_changes) page.\\n\\n## Commit tests\\n\\nSDK usability is essential for customer success, so our SDKs must include tests.\\r\\n\\r\\nFor GA SDK releases of the management plane, .NET recommends live tests to ensure compatibility with the new service version.\\r\\n\\r\\nFor the data plane, according to the target phase of your SDK, these are the requirements you need to accomplish before the SDK release:\\r\\n\\r\\n- Public preview: at least one test per language for the most common usage scenario.\\r\\n- GA: at least one test per shipped method.\\r\\n\\r\\nAdditional resources on adding SDK tests for various languages and SDK types are available at [test SDKs](xref:sdk-test).\\n\\n## Write samples\\n\\nEvery SDK needs a quickstart guide with code samples, as developers prefer learning from examples over lengthy documentation.\\r\\n\\r\\nEach management plane SDK release needs at least one sample per language for the main usage scenario.\\r\\n\\r\\nFor the data plane, according to the target phase of your SDK, these are the requirements you need to accomplish\\r\\nbefore the SDK release:\\r\\n\\r\\n- Public preview: at least one sample per language for the most common usage scenario.\\r\\n- GA: at least 4 samples for the most common usage scenario.\\r\\n\\r\\nAdditional resources on adding SDK samples for various languages and SDK types are available at [write SDK samples](xref:sdk-samples).\\n\\n## Update CHANGELOG file\\n\\nWhen SDK generation happens with automation, it automatically updates the `CHANGELOG.md` to track changes.\\r\\nThe updates include:\\r\\n- Replacing `(unreleased)` with the current date in “YYYY-MM-DD” format. \\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e Prior to starting the SDK release pipelines, you should confirm that the date for the latest version to be released\\r\\nis up to date to; or it can lead to pipeline failures.\\r\\n\\r\\n- Summarizing version updates under Features Added, Breaking Changes, Bug Fixes, and Other Changes.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e To revise, you should only include sections that have content, leaving nonblank.\\r\\n\\r\\nTake an example of the [CHANGELOG.md of Azure Core](https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/CHANGELOG.md)\\n\\n## Get SDK pull request merged\\n\\nOnce you confirm\\r\\n\\r\\n:white_check_mark: your SDK libraries are generated\\r\\n\\r\\n:white_check_mark: tests and samples are added\\r\\n\\r\\n:white_check_mark:`CHANGELOG.md` is up to date\\r\\n\\r\\nAll changes should be committed to the pull request generated by the SDK generation automation (if not already present).\\r\\nMonitor and address review comments from the SDK engineer for each language as needed until approval is granted to merge\\r\\nthe pull request.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e For GA releases, .NET requires APIView approval from the .NET SDK owner on the SDK pull request for release.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# design#specs-pr-guides#pr-suppressions.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-suppressions](https://aka.ms/azsdk/pr-suppressions) |\\r\\n|--|--|\\n\\n# Suppress validation failures on a PR\\n\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nOn your Azure REST API specs PR, some of the GitHub check failures (see the `Checks` tab on your PR) can be suppressed.\\r\\nThe suppression can be either just for the PR, or permanent.\\n\\n## To suppress given validation failure\\n\\n1. Determine which failing check you want to suppress: see its name in the `Checks` tab in your PR.\\r\\n1. Determine if you have one of the [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. Determine if you want to suppress the failure only for the PR, or permanently.\\r\\n1. Consult [the suppression cases table](#suppression-cases-table) for instructions corresponding to your case.\\r\\n1. If you want to apply temporary suppression:\\r\\n   1. Mention in a comment on your PR the PR assignee asking to apply the suppression. Provide justification.\\r\\n      See [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. If you applied permanent suppression:\\r\\n   1. It will manifest by the PR getting a label `SuppressionReviewRequired`.\\r\\n   1. Verify the suppression works by the check changing from **failed** to **neutral**.\\r\\n   1. Wait until your suppression is reviewed. If it is approved, the approved will add the `Approved-Suppression` label.\\r\\n   1. Understand the suppression won't be approved if it is not one of the  \\r\\n      [valid suppression reasons](#valid-suppression-reasons) as explained in relevant section.\\n\\n## Suppression cases table\\n\\n|\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met | Not possible                              |                                                      | Not possible                                                    |\\r\\n\\r\\n[1] Applies only if the SDK generation check failed with a breaking change. For details of SDK breaking change suppression, see https://aka.ms/azsdk/sdk-suppression.\\r\\nGeneral SDK generation check failure suppressions are not supported. See [#6509].\\n\\n|\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger SemanticValidation         | See [aka.ms/ci-fix]                       | `Approved-SemanticValidation`                        | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger ModelValidation            | See [aka.ms/ci-fix]                       | `Approved-ModelValidation`                           | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger Breaking Change            | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Breaking Change(Cross-Version)     | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              |\\n\\nTable legend:\\r\\n\\r\\n- `Check name`: Check to suppress.\\r\\n- `PR suppression`: instructions to obtain suppression for given check for given PR only.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n- `Label`: the label your PR will get if your suppression is approved.\\r\\n- `Permanent suppression`: instructions how to get permanent suppression.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n\\r\\n| Check name                         | PR suppression                            | Label                                                | Permanent suppression                                           |\\r\\n|------------------------------------|-------------------------------------------|------------------------------------------------------|-----------------------------------------------------------------|\\r\\n| TypeSpec Requirement               | Not possible                              |                                                      | [suppressions.yaml](#suppressionsyaml)                      |\\r\\n| TypeSpec Validation                | Not possible                              |                                                      | Not possible                                                    |\\r\\n| license/cla                        | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 |\\n\\n|\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-net-track2       | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-go               | See [step 3 in the diagram] but note [1]. | `BreakingChange-Go-Sdk-Suppression-Approved`         | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-java             | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-js               | See [step 3 in the diagram] but note [1]. | `BreakingChange-JavaScript-Sdk-Suppression-Approved` | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met |\\n\\n## suppressions.yaml\\n\\nFile `suppressions.yaml` is used for all checks created in 2024 or later, like\\r\\n`TypeSpec Requirement` and `TypeSpec Validation`.\\r\\n\\r\\nFor simplicity, we recommend adding all suppressions to a single file at the root of your spec folder:\\r\\n\\r\\n```\\r\\nspecification/myservice/suppressions.yaml\\r\\n```\\r\\n\\r\\nAlternatively, you can use multiple files in separate folders.  Currently, tools will use the first\\r\\ninstance of `suppressions.yaml` found walking up the directory tree.  We are planning\\r\\nfuture support for \\\"merging\\\" files up the hierarchy.\\r\\n\\r\\nA suppression follows this general format:\\r\\n\\r\\n```\\r\\n- tool: ToolName\\r\\n  path: applies/to/**/*.json\\r\\n  reason: Why this can't be fixed\\r\\n```\\r\\n\\r\\n`path` uses \\\"glob\\\" matching.  For syntax, see https://www.npmjs.com/package/minimatch.\\r\\n\\r\\nScope your `path` as narrowly as possible.  For example, if a suppression only applies\\r\\nto a single version of your spec:\\r\\n\\r\\n```\\r\\n# good\\r\\n- path: data-plane/Azure.Contoso.WidgetManager/preview/2022-11-01-preview/**/*.json\\r\\n\\r\\n# bad\\r\\n- path: data-plane/**/*.json\\r\\n```\\r\\n\\r\\nWhen in doubt, search the repo for examples:\\r\\n\\r\\nhttps://github.com/search?q=repo%3AAzure%2Fazure-rest-api-specs+path%3A%2F%28%5E%7C%5C%2F%29suppressions%5C.yaml%24%2F\\u0026type=code\\n\\n### `TypeSpec Requirement` check\\n\\nTo suppress `TypeSpec Requirement` check for given pattern of OpenAPI spec .json file paths, provide an entry with\\r\\n`tool` set to `TypeSpecRequirement`. Provide the pattern as `path` and provide a `reason`.\\r\\n\\r\\nExample:\\r\\n\\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: data-plane/**/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## Suppress AutoRest extension\\n\\nTo suppress tooling that is an AutoRest extension (see [the suppressio\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release.md\",\"document_title\":\"Release SDK\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release\",\"content\":\"# develop#sdk-release#sdk-release.md\\n\\n# Release SDK\\n\\n| Short Link: | [azsdk/releases/partnerinfo](https://aka.ms/azsdk/releases/partnerinfo) |\\r\\n| --- | --- |\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e TypeSpec usage for API definition is a mandatory requirement for all new (greenfield) data plane and management plane\\r\\n\\u003e services. This requirement is enforced by the ARM API Review Board for management plane services and by the API\\r\\n\\u003e Stewardship Board for data plane services.\\r\\n\\u003e Brownfield services will eventually be required to transition to TypeSpec as well.  PRs for brownfields services\\r\\n\\u003e that have not transitioned to TypeSpec will receive notices in FY2024, followed by warnings in FY2025 and\\r\\n\\u003e errors in FY2027. The requirement to move to TypeSpec will ensure a consistent, high-quality developer experience across\\r\\n\\u003e Azure that aligns with Azure SDK guidelines. For more information on TypeSpec, visit [here](xref:api-typespec).\\n\\n## Before you begin\\n\\n- You have [access](xref:access) to the GitHub repositories, respective GitHub groups, and release security groups.\\r\\n- You have a [release plan](xref:release-plan) created to manage and understand the steps required to generate,\\r\\ntest, and release an SDK.\\r\\n- The REST API specs need to be merged in the main branch of the public repository [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n- Ensure to complete all tasks outlined on this page [Prerequisites to release SDKs](xref:sdk-release-prerequisites).\\r\\n- Breaking changes to GAed SDKs are not permitted as they conflict with the  \\r\\n[Azure SDK design principle](https://azure.github.io/azure-sdk/general_introduction.html#dependable).\\r\\nIf breaking changes are inevitable, ensure to get approval from [Azure Breaking Changes Board](https://aka.ms/azbreakingchangespolicy)\\r\\nin your service API Spec review.\\r\\n- Ensure your service is available to the public before the SDK release date.\\n\\n## When to release\\n\\n### [Management plane (ARM)](#tab/management)\\n\\nThe Azure SDK release processes for management plane SDKs vary based on the API specification type\\r\\n\\r\\n- TypeSpec: On demand.\\r\\n- Open API: Request a release **before the cutoff date** for the month that you're targeting.\\r\\n\\r\\n:point_right: 2nd Friday of every month: Cutoff date\\r\\n\\r\\n:point_right: 4th Friday of every month: Release date\\r\\n\\r\\nThe functionality to request a release for Java, JavaScript, Python, and Go is available as part of the\\r\\nmanagement plane release plan. You can learn more about release plans [here](xref:release-plan).\\r\\n\\r\\nFor releasing the .NET SDK release follow the [.NET release process](xref:sdk-release-mgmt-dotnet).\\n\\n### [Data plane](#tab/dataplane)\\n\\nAlthough releases happen every month, you can release the SDK on demand. The Azure SDK team follows a monthly\\r\\nrelease calendar where we minimize disruptions to the release tools as much as possible.\\r\\nOutside of those dates, the tools might not be as stable.\\r\\n\\r\\n[Release Calendar](https://teams.microsoft.com/l/entity/com.microsoft.teamspace.tab.planner/_djb2_msteams_prefix_1611974298?context=%7B%22subEntityId%22%3Anull%2C%22channelId%22%3A%2219%3Adc2e34377e494a9292d89fbc34125eae%40thread.skype%22%7D\\u0026groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47):\\r\\nThis calendar shows the Package Code Freeze and Package Ship dates for the year.\\n\\n## Breaking change policy\\n\\n- Requires approval from Azure SDK Architecture Team \\u003cazsdkarch@microsoft.com\\u003e\\r\\n- More information: http://aka.ms/AzBreakingChangesPolicy/\\n\\n## Next steps\\n\\n- For each released package by going to the public feed and verifying:\\r\\n  - Metadata - Verify that the links, documentation, readme, etc. are correct and appear as expected.\\r\\n  - Download - Download the package and verify that it is the same one you built/published.\\r\\n- In your release plan, mark the **Release SDK** task as completed and proceed to complete the release plan.\\r\\n- [Verify SDK reference docs](xref:sdk-docs)\\r\\n- Verify the content of the release notes PR generated during the release pipeline. Review and approve the PR. See [Producing Release Notes](https://azure.github.io/azure-sdk/policies_releasenotes.html) for details.\\r\\n- The release pipeline will submit a PR with a version bump for each SDK in their respective language repository.\\r\\nYou need to review and merge each version bump pull request.\\n\\n## Get help\\n\\n### [Management plane (ARM)](#tab/management)\\n\\n[Azure SDK - SDK Release Support](https://teams.microsoft.com/l/channel/19%3A084875bb626242ed95f3ac8dddfaa12a%40thread.skype/SDK%20release%20support?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\\n\\n### [Data plane](#tab/dataplane)\\n\\nIf you have any questions about the general release process, please reach out to either of the [Azure SDK Release PMs](#azure-sdk-release-pm)\\r\\nlisted. If your question is related to one of the language specific release processes or you're having\\r\\nissues using a language specific release process, please reach out to the relative  \\r\\n[Release Driver](#release-driver--build-facilitating-developer) for that language.\\r\\n\\r\\n#### Azure SDK release PM\\r\\n\\r\\n- Ronnie Geraghty rgeraghty@microsoft.com\\r\\n\\r\\n#### Release driver / Build facilitating developer\\r\\n\\r\\n- .NET: Jonathan Cardenas Jonathan.Cardenas@microsoft.com\\r\\n- Java: Jair Myree jairmyree@microsoft.com\\r\\n- JS: Timo van Veenendaal timov@microsoft.com\\r\\n- Python: Kashif Khan kashifkhan@microsoft.com\\r\\n- C/C++: Anton Kolesnyk Anton.Kolesnyk@microsoft.com\\r\\n- Go: Grace Wilcox gracewilcox@microsoft.com\\r\\n- Android: Victor Colin victor.colin@microsoft.com\\r\\n- iOS: Travis Prescott trpresco@microsoft.com\\r\\n- Rust: Ronnie Geraghty rgeraghty@microsoft.com\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-release#sdk-release-pipeline.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-release/sdk-release-pipeline\",\"content\":\"# Run release SDK pipeline\\n## SDK release pipeline\\n### Select a release pipeline\\n1. Go to our [pipelines hub](https://dev.azure.com/azure-sdk/internal/_build?view=pipelines\\u0026option=recent) contained\\r\\nwithin the _internal_ team project.\\r\\n1. Select **All** to see all the pipelines aggregated by language folders.\\r\\n1. Per language, you will need to locate and select the pipeline that is used to build your package.\\r\\nPipelines are named after the language and service area that they are responsible for building and releasing.\\r\\nFor example the _core_ libraries are named **java - core**, and the app configuration libraries are named **java - appconfiguration**.\\r\\n1. If you don't find a release pipeline, you will need to create one.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e In some cases where there was a pre-existing track 1 library and new track 2 libraries were introduced,\\r\\n\\u003e we have split the pipelines - so you may see some pipelines in the form **java - [service] - data**.\\r\\n\\u003e This means that the pipeline is the track 1 version of the unified pipeline. This distinction is made to optimize the\\r\\n\\u003e build and release process for teams doing active development on the track 2 versions of the library.\\r\\n\\r\\n#### Create a release pipeline\\r\\n\\r\\nTo generate pipelines for a new service that does not yet exist on _main_, ensure that your PR contains the `ci.yml` and\\r\\n`tests.yml` files ([modified from the template](https://dev.azure.com/azure-sdk/internal/_wiki/wikis/internal.wiki/117/Setting-up-a-new-Unified-Pipeline))\\r\\nand then issue the following comment on your github pull request:\\r\\n\\r\\n```\\r\\n/azp run prepare-pipelines\\r\\n```\\r\\n\\r\\nThis will trigger a pipeline which analyzes the state of the repo-based on your commit and generates pipelines\\r\\nnecessary to run PR validation.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-autorest.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-autorest\",\"content\":\"# Learn about AutoRest config files (READMEs)\\n## Try AutoRest yourself\\nIf you want to understand better how AutoRest interprets the README file, you can run it locally.\\r\\n\\r\\nFirst, install AutoRest via `npm`: `npm install -g autorest`.\\r\\n\\r\\nThen, run:\\r\\n\\r\\n\\u003e `autorest readme.md`\\r\\n\\r\\nTo see additional help and options, run:\\r\\n\\r\\n\\u003e `autorest --help`\\r\\n\\r\\nFor other options on installation see [Installing AutoRest](https://aka.ms/autorest/install) on the AutoRest github page.\\r\\n\\r\\n[aka.ms/azsdk/spec-dirs]: https://aka.ms/azsdk/spec-dirs\\r\\n[AutoRest config]: https://azure.github.io/autorest/user/configuration.html\\r\\n[AutoRest literate config]: https://azure.github.io/autorest/user/literate-file-formats/configuration.html\\r\\n[AutoRest tags]: https://azure.github.io/autorest/generate/#adding-tags-when-generating\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#troubleshoot#PR-failing.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/troubleshoot/PR-failing\",\"content\":\"# I've submitted a pull request, but the build isn't succeeding or tests are failing!\\n\\u003e [!NOTE]\\r\\n\\u003e If you are looking for help with a PR submitted to one of [the Azure REST API specs repositories](xref:api-repos),\\r\\n\\u003e please refer to [this support page](xref:support#get-help-with-prs-submitted-against-the-azure-rest-api-specification-repositories).\\r\\n\\r\\nCongratulations! You've submitted a pull request. As part of the pull request approval process we ensure that the code\\r\\nbuild and tests successfully, as well as performing a range of other validation steps. Generally speaking the build\\r\\nerrors associated with the pipeline run are sufficient to diagnose and fix any issues with your PR. You can access\\r\\nthe build logs by clicking on the failing check run, and then using the view details link to navigate to the error in\\r\\nAzure Pipelines.\\r\\n\\r\\nIf you cannot understand the reason for the failure, ask a question in the _language team_ channel appropriate to the\\r\\nrepository that you are working in. Each language team is the first point of contact for build failures within their\\r\\nrepository.\\r\\n\\r\\nReach to the [language specific Team's channel](xref:support#get-help-with-the-azure-sdks-development).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#support.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/support\",\"content\":\"# Get help and support\\n## Get more help\\nIf none of the scenarios in this article describe your situation, reach out to us\\r\\non the [Azure SDK / Azure SDK Onboarding] channel.\\r\\n\\r\\nWhen applicable, provide a URL relevant to your problem, like validation check failure, pull request, documentation\\r\\npage, etc.\\r\\n\\r\\n[Azure SDK / Azure SDK Onboarding]: https://aka.ms/azsdk/support/onboarding-channel\\r\\n[azure-sdk-for-python]: https://github.com/Azure/azure-sdk-for-python\\r\\n[.NET Teams channel]: https://teams.microsoft.com/l/channel/19%3a7b87fb348f224b37b6206fa9d89a105b%40thread.skype/Language%2520-%2520DotNet?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\r\\n[Java Teams channel]: https://teams.microsoft.com/l/channel/19%3a5e673e41085f4a7eaaf20823b85b2b53%40thread.skype/Language%2520-%2520Java?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\r\\n[TypeScript/JS Teams channel]: https://teams.microsoft.com/l/channel/19%3a344f6b5b36ba414daa15473942c7477b%40thread.skype/Language%2520%25E2%2580%2593%2520JS%25E2%2580%2589%25EF%25BC%2586%25E2%2580%2589TS%2520%25F0%259F%25A5%25B7\\r\\n[Python Teams channel]: https://teams.microsoft.com/l/channel/19%3ab97d98e6d22c41e0970a1150b484d935%40thread.skype/Language%2520-%2520Python?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\r\\n[C++ Teams channel]: https://teams.microsoft.com/l/channel/19%3aa5180a2de11a40cb83a822f588d60c15%40thread.skype/Language%2520-%2520C%25E1%2590%25A9%25E1%2590%25A9?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\r\\n[Go Teams channel]: https://teams.microsoft.com/l/channel/19%3a104f00188bb64ef48d1b4d94ccb7a361%40thread.skype/Language%2520-%2520Go?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#troubleshoot#build-local.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/troubleshoot/build-local\",\"content\":\"# I can't build locally, what am I missing?\\nWe've tried to ensure that the `CONTRIBUTING.md` file in each repository has sufficient information so that you can\\r\\nbuild and test your changes locally before submitting a pull request. If you are stuck, review the `CONTRIBUTING.md`\\r\\nfile in the language repo you are contributing to in order to ensure you have correctly configured your\\r\\nlocal development environment and that you are using the build tools correctly.\\r\\n\\r\\n- [Java](https://github.com/azure/azure-sdk-for-java/tree/master/CONTRIBUTING.md)\\r\\n- [Python](https://github.com/azure/azure-sdk-for-python/tree/master/CONTRIBUTING.md)\\r\\n- [.NET](https://github.com/azure/azure-sdk-for-net/tree/master/CONTRIBUTING.md)\\r\\n- [JavaScript](https://github.com/azure/azure-sdk-for-js/tree/master/CONTRIBUTING.md)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"faqs#faqs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/faqs/faqs\",\"content\":\"# Azure SDK frequently asked questions\\n## General\\n### I need help with Live Validation\\nReach out to the [Service API Toolset Teams channel] for help.\\r\\nIn your post, describe the issue and include links to the artifacts that are applicable to your problem. For example:\\r\\n- Pull request\\r\\n- Build log\\r\\n- Failing check\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-draft-pullrequest.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-draft-pullrequest\",\"content\":\"# Using the SDK generated by the SDK generation pipeline\\n## Fetch the SDK code\\nIf you want to work upon the generated SDK code, retrieve it from the pull request to your local development environment:\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"faqs#faqs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/faqs/faqs\",\"content\":\"# Azure SDK frequently asked questions\\n## Azure REST API specs PRs\\n### I believe the validation tooling is wrong; it reports a problem where there is none\\nCarefully follow the guidance provided in the PR description and in the `Next Steps to Merge` comment added to it\\r\\nby the automation. It covers cases where the tooling is faulty and/or reporting false positives.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"develop#sdk-docs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/develop/sdk-docs\",\"content\":\"# Publish SDK reference docs\\n## FAQ\\n### I found an error in live docs and want to correct it\\nDocs on the live are built by the docs build system from the current state of released SDK packages. Errors fall into two categeories: \\r\\n\\r\\n1. **Wording/misspelling/etc.** -- Correct the issue in source code and release a new version of the package to correct docs.\\r\\nDirect edits to YAML produced in the docs repo will be overwrtitten by later builds.\\r\\n1. **Rendering issues** -- Docs which are worded correctly but render incorrectly on the docs site should be brought to the\\r\\nthe attention of the docs team by filing an issue. To file an issue:\\r\\n    1. Visit https://aka.ms/sitehelp\\r\\n    1. Click the **Submit request or issue** button\\r\\n    1. In the **Where the change is needed or where the issue happens?** dropdowns, select **Learn sites** and **API and SDK reference documentation (all languages and platforms)** \\r\\n    1. Fill in **What is the request or issue?**, and **Tell us more** fields and optionally attach a screenshot\\r\\n    1. Click **Submit** to file the issue\"}]",
            "inputs.latency": 108.72925543785095,
            "inputs.response_length": 1555,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://eng.ms/docs/products/azure-developer-experience/support/troubleshoot/build-local",
                "https://eng.ms/docs/products/azure-developer-experience/support/troubleshoot/PR-failing",
                "https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-autorest"
            ],
            "inputs.testcase": "How to Sdk generation in local",
            "outputs.similarity.similarity": 3.0,
            "outputs.similarity.gpt_similarity": 3.0,
            "outputs.similarity.similarity_result": "fail",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1250,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1251,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: How to Sdk generation in local\\\\n\\\\nquestion: I have couple of prs failing with sdk validation.\\\\nIs there a way to reproduce these errors in local?\\\", \\\"response\\\": \\\"Yes, you can reproduce SDK validation errors locally before submitting or updating your pull request. The recommended approach is to build and test your SDK code in your local development environment, which allows you to catch build and validation issues that might otherwise cause PR failures.\\\\n\\\\nFor most Azure SDK language repositories, the `CONTRIBUTING.md` file provides detailed setup instructions. After cloning the repo and setting up the required tools (such as .NET, Java, Python, Node.js, etc.), you should:\\\\n\\\\n1. Build your SDK locally using the language-specific commands (e.g., `dotnet build`, `mvn compile`, `pip install -e .`, etc.).\\\\n2. Run the tests using the provided commands (e.g., `dotnet test`, `pytest`, `mvn test`, etc.).\\\\n\\\\nThis will surface most validation errors, including those related to code generation, tests, and compliance checks.\\\\n\\\\nFor management plane .NET SDKs generated from OpenAPI, you can use AutoRest locally:\\\\n- Install AutoRest: `npm install -g autorest`\\\\n- Run: `autorest readme.md` (pointing to your spec folder)\\\\n\\\\nFor additional validation and error details, check the build logs in your local runs and compare them with the CI pipeline errors. If you are stuck or the errors are unclear, reach out to the language-specific team channel for support.\\\\n\\\\nNote: Not all CI validation checks are guaranteed to run identically locally (some security/compliance checks may require pipeline context), but build and test failures are reliably reproducible.\\\\n\\\\nReferences to the detailed setup for each language are provided below.\\\", \\\"ground_truth\\\": \\\"You can run our tooling locally with our Azure SDK Tools MCP: [AzSDK agent](https://eng.ms/docs/products/azure-developer-experience/develop/azsdk-tools-mcp)\\\\nIt will help:\\\\nvalidating your local environment\\\\ngenerating the SDKs locally\\\\nlearn more about the SDK generation and release process\\\\nThe documentation shared has example prompts you can try.\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"
        },
        {
            "inputs.query": "title: Update the enum for the exisitng API version\n\nquestion: API Spec Review\nWe have the api-spec for verion 2025-08-01 for the storage mover [azure-rest-api-specs-pr/specification/storagemover/resource-manager/Microsoft.StorageMover/stable/2…](https://github.com/Azure/azure-rest-api-specs-pr/tree/RPSaaSMaster/specification/storagemover/resource-manager/Microsoft.StorageMover/stable/2025-08-01)\nThis version is not live yet.And no customer are using this. If I have to change a Enum and also add new optional for this version, can it be changed and we get the approval from the breaking change team?",
            "inputs.ground_truth": "If this version merged to RPSaaSMaster, it has \"released\".  When you added label PublishToCustomers to the PR, you were agreeing to this statement:\n```\nThis PR targets either the main branch of the public specs repo or the RPSaaSMaster branch of the private specs repo. These branches are not intended for iterative development. Therefore, you must acknowledge you understand that after this PR is merged, the APIs are considered shipped to Azure customers. Any further attempts at in-place modifications to the APIs will be subject to Azure's versioning and breaking change policies.\n```\nThat said, you can open a PR with the changes you'd like to make, then follow the process in the \"next steps to merge comment\" once your breaking changes are detected.\nThe process is documented at these two links:\n1.https://aka.ms/brch\n2.https://aka.ms/azsdk/pr-brch-deep\nYou can self-apply a label if your PR meets the qualifications (2).\nOr contact the breaking changes board for review and approval, by attending the office hours, or sending email to azbreakchangereview@microsoft.com (1).",
            "inputs.response": "Yes, you can change an existing enum and add a new optional property in the API version 2025-08-01 for Storage Mover **if the version is not yet live and not used by any customers**. According to the Azure Versioning and Breaking Changes Policy and supporting deep-dive documentation:\n\n- Breaking changes (including enum changes and adding/removing properties) to an API version **are allowed** if that API version has not been published to a production branch (main or RPSaaSMaster) and no customers are using it yet. Once an API version is published and available to customers (even in public preview), it is considered a contract and cannot be changed except for approved bug fixes.\n- If your PR targets a production branch and the API version is already published (even if not yet GA), then *any* change—even non-breaking—will require approval from the breaking change review board. This is enforced by automated checks that apply `BreakingChangeReviewRequired` or `VersioningReviewRequired` labels. However, if your version is not live (not merged to production), you are free to make changes before it goes live.\n\n**Action Steps:**\n- If your API version 2025-08-01 is not yet merged into a production branch, you may update enums and add new optional properties as needed—no review needed.\n- If your API version is already merged and visible to customers, you must follow the breaking change review process (see [aka.ms/brch]) and obtain explicit approval before merging breaking changes.\n\n**Summary:**\nYou are permitted to change the enum and add new optional properties in an unpublished API version. Once published, changes are tightly controlled.\n",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# design#specs-pr-guides#pr-brch-deep.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-brch-deep](https://aka.ms/azsdk/pr-brch-deep) |\\r\\n| --- | --- |\\n\\n# Deep-dive into breaking changes on spec PRs\\n\\n## Important information about this article\\n\\nThis article provides a deep-dive into breaking changes on spec PRs. It applies if your spec PR has\\r\\n`BreakingChangeReviewRequired` or `VersioningReviewRequired` label.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e This is an advanced deep-dive. If your PR is blocked on breaking changes or versioning issues, you should always\\r\\n\\u003e start by following the guidance at [aka.ms/brch].\\n\\n### Prerequisites\\n\\nThis article assumes you are familiar with [API versions and branches](xref:api-versions-and-branches).\\n\\n### Video overview and slides\\n\\nFor video overview of the breaking changes process, see this [Azure Core Day of Learning talk from March 6, 2024].\\r\\nSlides for the talk are available [here][talk slides].\\n\\n### Summary\\n\\nPer the [PR diagram], the first step of getting your specs PR approved is ensuring your PR obeys the  \\r\\n[Azure Versioning and Breaking Changes Policy]. Relevant details of this policy follow.\\r\\n\\r\\n- Once published, no changes to given API version are allowed, except when fixing the spec to match\\r\\nactual implementation (see the `-Approved-BugFix` labels in this doc).\\r\\nThis applies regardless of whether the API version is for `private preview`, `public preview`, or `GA`.\\r\\n- When introducing a new API version (any `preview` or `GA`), the new API version must be backwards compatible with\\r\\nthe previous, latest `GA` API version.\\r\\n- During a (`private` or `public`) `preview` cycle, a new `preview` API version does not have to be backwards\\r\\ncompatible with the previous `preview` API version.\\r\\n- The rules listed above are checked by automated GitHub checks. The exact ruleset is given in [`oadMessagesRuleMap.ts`].\\r\\nDetails follow.\\n\\n## Breaking changes and versioning issues\\n\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\\n\\n### `BreakingChangeReviewRequired` label\\n\\nThe label `BreakingChangeReviewRequired` is added to your PR if the tooling detects a change that could\\r\\nbe breaking for customers. This can happen in two cases:\\r\\n\\r\\n- In your PR you have possibly introduced a breaking change in a new API version, placed in a new folder,\\r\\nas compared to most recent previous `GA`.\\r\\nThe new API version can be either `preview` or `GA`.\\r\\n  - For example, an existing `GA` API version in leaf folder of `2023-11-15`\\r\\nmay contain API route of `GET .../resoruces/{resourceName}`, but a new `preview` API version of `2024-03-15-preview`\\r\\nmay no longer have this route (REST API path), because you are removing the `resoruces` typo and instead introducing\\r\\n`GET .../resources/{resourceName}` route.\\r\\n- In your PR you are modifying existing `GA` API version in-place. For example, you have recently released\\r\\n`2024-03-18` API version and realized you made a typo and are editing the contents of the leaf folder `2024-03-18`\\r\\ncontaining that API version.\\n\\n### `VersioningReviewRequired` label\\n\\nThe label `VersioningReviewRequired` denotes that your PR has a **versioning issue** possibly violating the  \\r\\n[Azure Versioning and Breaking Changes Policy]. This happens when you made a **non-breaking change**,\\r\\naka **compatible change** to an API version that was already published (merged to a production branch).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e According to [the policy][Azure Versioning and Breaking Changes Policy], compatible (non-breaking changes) are not\\r\\n\\u003e allowed within an existing API version. You must create a new API version. Otherwise, we would confuse our customers\\r\\n\\u003e by having to explain \\\"which version of given API version\\\" has a particular change/feature.\\r\\n\\r\\n`VersioningReviewRequired` label is added by automation if:\\r\\n\\r\\n- You made any compatible changes **within** any API version, `GA` or `preview`.\\r\\n- You made any breaking changes in a `preview` API version.\\r\\n\\r\\nIf your PR has both breaking changes and versioning issues, only `BreakingChangeReviewRequired` label\\r\\nis added to it.\\n\\n### In case there is no latest GA API version\\n\\nIf there is no latest GA OpenAPI spec, then the the cross-version check is instead comparing to\\r\\nlatest available preview if it more than 1 year old.\\r\\n\\r\\nIf neither a GA API version or at least 1 year old preview version exists, then the cross-version check automatically\\r\\npasses.\\n\\n### Diagram explaining breaking changes and versioning issues\\n\\nThe logic for automation adding `BreakingChangeReviewRequired` and `VersioningReviewRequired` labels explained above\\r\\ncan be summarized in the following diagram:\\r\\n\\r\\n![Breaking Changes Confusion Matrix](../../img/breaking_changes_confusion_matrix.png)\\n\\n## Addressing `BreakingChangeReviewRequired`\\n\\nIf your PR is labelled with `BreakingChangeReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the breaking changes in your PR are acceptable, they will be\\r\\napproved by one of these labels:\\n\\n### `BreakingChange-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `BreakingChange-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-UserImpact`\\n\\n- The spec PR describes actual breaking changes to the service.\\r\\n- This is the only case that triggers customer notifications, a 3 year migration period (possibly shorter), etc.\\r\\n- Within this set, the changes may be distinguished further for security or legal compliance, which may be granted\\r\\na shorter migration period.\\r\\n- Details at [aka.ms/brch].\\n\\n### `BreakingChange-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Addressing `VersioningReviewRequired`\\n\\nIf your PR is labelled with `VersioningReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the versioning issue in your PR caused by non-breaking (compatible)\\r\\nchanges is acceptable, the board will approve it by one of these labels:\\n\\n### `Versioning-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `Versioning-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-PrivatePreview`\\n\\nThe API version change that triggered the review is in `private preview`, and non-breaking changes are permitted\\r\\nin the same API version during `private preview`.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-PrivatePreview` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Common misconceptions\\n\\n### FALSE: compatible (non-breaking) changes are allowed in published API versions\\n\\n**Why?**\\r\\n\\r\\nAn API version is a contract, and once the contract is published it cannot be changed.\\r\\nOtherwise, it would create customer confusion about \\\"which version of this API version\\\" are they using.\\r\\n\\r\\nAny change of this kind w\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#Guidelines.md\",\"document_title\":\"Microsoft Azure REST API Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md\",\"content\":\"# azure#Guidelines.md\\n\\n# Microsoft Azure REST API Guidelines\\n\\n\\u003c!-- cspell:ignore autorest, BYOS, etag, idempotency, maxpagesize, innererror, trippable, nextlink, condreq, etags --\\u003e\\r\\n\\u003c!-- markdownlint-disable MD033 MD049 MD055 --\\u003e\\r\\n\\r\\n\\u003c!--\\r\\nNote to contributors: All guidelines now have an anchor tag to allow cross-referencing from associated tooling.\\r\\nThe anchor tags within a section using a common prefix to ensure uniqueness with anchor tags in other sections.\\r\\nPlease ensure that you add an anchor tag to any new guidelines that you add and maintain the naming convention.\\r\\n--\\u003e\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2025-Mar-28 | Added guidelines about JSON ID and null values                 |\\r\\n| 2024-Mar-17 | Updated LRO guidelines                                         |\\r\\n| 2024-Jan-17 | Added guidelines on returning string offsets \\u0026 lengths         |\\r\\n| 2023-May-12 | Explain service response for missing/unsupported `api-version` |\\r\\n| 2023-Apr-21 | Update/clarify guidelines on POST method repeatability         |\\r\\n| 2023-Apr-07 | Update/clarify guidelines on polymorphism                      |\\r\\n| 2022-Sep-07 | Updated URL guidelines for DNS Done Right                      |\\r\\n| 2022-Jul-15 | Update guidance on long-running operations                     |\\r\\n| 2022-May-11 | Drop guidance on version discovery                             |\\r\\n| 2022-Mar-29 | Add guidelines about using durations                           |\\r\\n| 2022-Mar-25 | Update guideline for date values in headers to follow RFC 7231 |\\r\\n| 2022-Feb-01 | Updated error guidance                                         |\\r\\n| 2021-Sep-11 | Add long-running operations guidance                           |\\r\\n| 2021-Aug-06 | Updated Azure REST Guidelines per Azure API Stewardship Board. |\\r\\n| 2020-Jul-31 | Added service advice for initial versions                      |\\r\\n| 2020-Mar-31 | 1st public release of the Azure REST API Guidelines            |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Introduction\\n\\nThese guidelines apply to Azure service teams implementing _data plane_ APIs. They offer prescriptive guidance that Azure service teams MUST follow ensuring that customers have a great experience by designing APIs meeting these goals:\\r\\n- Developer friendly via consistent patterns \\u0026 web standards (HTTP, REST, JSON)\\r\\n- Efficient \\u0026 cost-effective\\r\\n- Work well with SDKs in many programming languages\\r\\n- Customers can create fault-tolerant apps by supporting retries/idempotency/optimistic concurrency\\r\\n- Sustainable \\u0026 versionable via clear API contracts with 2 requirements:\\r\\n  1. Customer workloads must never break due to a service change\\r\\n  2. Customers can adopt a version without requiring code changes\\r\\n\\r\\nTechnology and software is constantly changing and evolving, and as such, this is intended to be a living document. [Open an issue](https://github.com/microsoft/api-guidelines/issues/new/choose) to suggest a change or propose a new idea. Please read the [Considerations for Service Design](./ConsiderationsForServiceDesign.md) for an introduction to the topic of API design for Azure services. *For an existing GA'd service, don't change/break its existing API; instead, leverage these concepts for future APIs while prioritizing consistency within your existing service.*\\r\\n\\r\\n*Note: If you are creating a management plane (ARM) API, please refer to the [Azure Resource Manager Resource Provider Contract](https://github.com/cloud-and-ai-microsoft/resource-provider-contract).*\\n\\n### Prescriptive Guidance\\n\\nThis document offers prescriptive guidance labeled as follows:\\r\\n\\r\\n:white_check_mark: **DO** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n:ballot_box_with_check: **YOU SHOULD** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:heavy_check_mark: **YOU MAY** consider this pattern if appropriate to your situation. No notification to the Azure HTTP/REST Stewardship Board is required.\\r\\n\\r\\n:warning: **YOU SHOULD NOT** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:no_entry: **DO NOT** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n*If you feel you need an exception, or need clarity based on your situation, please contact the Azure HTTP/REST Stewardship Board **prior** to release of your API.*\\n\\n## Building Blocks: HTTP, REST, \\u0026 JSON\\n\\nThe Microsoft Azure Cloud platform exposes its APIs through the core building blocks of the Internet; namely HTTP, REST, and JSON. This section provides you with a general understanding of how these technologies should be applied when creating your service.\\r\\n\\r\\n\\u003ca href=\\\"#http\\\" name=\\\"http\\\"\\u003e\\u003c/a\\u003e\\n\\n### HTTP\\n\\ncase-sensitive, multiple delimiter\\r\\nUUID      | 123e4567-e89b-12d3-a456-426614174000 (no {}s, hyphens, case-insensitive) [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)\\r\\nDate/Time (Header) | Sun, 06 Nov 1994 08:49:37 GMT [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1)\\r\\nDate/Time (Query parameter) | YYYY-MM-DDTHH:mm:ss.sssZ (with at most 3 digits of fractional seconds) [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)\\r\\nByte array | Base-64 encoded, max length\\r\\nArray      | One of a) a comma-separated list of values (preferred), or b) separate `name=value` parameter instances for each value of the array\\r\\n\\r\\n\\r\\nThe table below lists the headers most used by Azure services:\\r\\n\\r\\nHeader Key          | Applies to | Example\\r\\n------------------- | ---------- | -------------\\r\\n_authorization_     | Request    | Bearer eyJ0...Xd6j (Support Azure Active Directory)\\r\\n_x-ms-useragent_    | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntraceparent         | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntracecontext        | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\naccept              | Request    | application/json\\r\\nIf-Match            | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-None-Match       | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-Modified-Since   | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\nIf-Unmodified-Since | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\ndate                | Both       | Sun, 06 Nov 1994 08:49:37 GMT (see [RFC 7231, Section 7.1.1.2](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2))\\r\\n_content-type_      | Both       | application/merge-patch+json\\n\\nname=\\\"http-header-names-casing\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** specify headers using kebab-casing\\r\\n\\r\\n\\u003ca href=\\\"#http-header-names-case-sensitivity\\\" name=\\\"http-header-names-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header names using case-insensitivity\\r\\n\\r\\n\\u003ca href=\\\"#http-header-values-case-sensitivity\\\" name=\\\"http-header-values-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header values using case-sensitivity if the header name requires it\\r\\n\\r\\n\\u003ca href=\\\"#http-header-date-values\\\" name=\\\"http-header-date-values\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** accept date values in headers in HTTP-Date format and return date values in headers in the IMF-fixdate format as defined in [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1), e.g. \\\"Sun, 06 Nov 1994 08:49:37 GMT\\\".\\r\\n\\r\\nNote: The RFC 7231 IMF-fixdate format is a \\\"fixed-length and single-zone subset\\\" of the RFC 1123 / RFC 5822 format, which means: a) year must be four digits, b) the seconds component of time is required, and c) the timezone must be GMT.\\r\\n\\r\\n\\u003ca href=\\\"#http-header-request-id\\\" name=\\\"http-header-request-id\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** create an opaque value that uniquely identifies the request and return this value in the `x-ms-request-id` response header.\\r\\n\\r\\nYour service should include the `x-ms-request-id` value in error logs so that users can submit support requests for specific failures using this value.\\r\\n\\r\\n\\u003ca href=\\\"#http-allow-unrecognized-headers\\\" name=\\\"http-allow-unrecognized-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** fail a request that contains an unrecognized header. Headers may be added by API gateways or middleware and this must be tolerated\\r\\n\\r\\n\\u003ca href=\\\"#http-no-x-custom-headers\\\" name=\\\"http-no-x-custom-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** use \\\"x-\\\" prefix for custom headers, unless the header already exists in production [[RFC 6648](https://datatracker.ietf.org/doc/html/rfc6648)].\\r\\n\\r\\n**Additional References**\\n\\nAzure services must adhere to the HTTP specification, [RFC 7231](https://tools.ietf.org/html/rfc7231). This section further refines and constrains how service implementors should apply the constructs defined in the HTTP specification. It is therefore, important that you have a firm understanding of the following concepts:\\r\\n\\r\\n- [Uniform Resource Locators (URLs)](#uniform-resource-locators-urls)\\r\\n- [HTTP Request / Response Pattern](#http-request--response-pattern)\\r\\n- [HTTP Query Parameters and Header Values](#http-query-parameters-and-header-values)\\r\\n\\r\\n#### Uniform Resource Locators (URLs)\\r\\n\\r\\nA Uniform Resource Locator (URL) is how developers access the resources of your service. Ultimately, URLs are how developers form a cognitive model of your service's resources.\\r\\n\\r\\n\\u003ca href=\\\"#http-url-pattern\\\" name=\\\"http-url-pattern\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** use this URL pattern:\\r\\n```text\\r\\nhttps://\\u003ctenant\\u003e.\\u003cregion\\u003e.\\u003cservice\\u003e.\\u003ccloud\\u003e/\\u003cservice-root\\u003e/\\u003cresource-collection\\u003e/\\u003cresou\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#VersioningGuidelines.md\",\"document_title\":\"Azure Versioning Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/VersioningGuidelines.md\",\"content\":\"# azure#VersioningGuidelines.md\\n\\n# Azure Versioning Guidelines\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2024-Nov-14 | Azure Service Versioning \\u0026 Breaking Change Guidelines       |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Guidelines\\n\\n**DO** remove retired API versions from the azure-rest-api-specs repo.\\r\\n\\r\\n:white_check_mark: **DO** review any change to service behavior that could disrupt customers with the Azure Breaking Changes review board, even if the change is not part of the API definition.\\r\\n\\r\\nSome examples of behavior changes that must be reviewed are:\\r\\n- Introducing or changing rate limits to be more restrictive than previously\\r\\n- Changing the permissions required to successfully execute an operation\\r\\n\\r\\n:no_entry: **DO NOT** change the behavior of an API version that is available to customers either in public preview or GA.\\r\\nChanges in behavior should always be introduced in a new API version, with prior versions working as before.\\r\\n\\r\\n:no_entry: **DO NOT** introduce breaking changes from a prior GA version just to satisfy ARM or Azure API guidelines.\\r\\n\\r\\nAvoiding breaking changes in a GA API takes precedence over adherence to API guidelines and resolving linter errors.\\r\\n\\r\\n:no_entry: **DO NOT** keep a preview feature in preview for more than 1 year; it must go GA (or be removed) within 1 year after introduction.\\n\\nThis document provides a \\\"Dos and Don'ts\\\" list for complying with the Azure Versioning and Breaking Change Policy,\\r\\nas documented [internally](aka.ms/AzBreakingChangesPolicy) and [externally](https://learn.microsoft.com/azure/developer/intro/azure-service-sdk-tool-versioning).\\r\\n\\r\\n:white_check_mark: **DO** thoroughly ensure/test the API contract is entirely correct before merging it into a production branch of the specs repo.\\r\\n\\r\\nTesting helps avoid \\\"BugFix\\\" changes to the API definition. Testing should be done at the HTTP level as well as through generated SDKs.\\r\\n\\r\\n:white_check_mark: **DO** retire all prior preview API versions 90 days after a new GA or preview API version is released.\\r\\n\\r\\n:white_check_mark: **DO** contact the Azure Breaking Change Review board to coordinate communications to customers\\r\\nwhen releasing an API version requiring the retirement of a prior version.\\r\\n\\r\\n:white_check_mark: **DO** create a new preview API version for any features that should remain in preview following a new GA release.\\r\\n\\r\\n:white_check_mark: **DO** use a date strictly later than the most recent GA API version when releasing\\r\\na new preview API version.\\r\\n\\r\\n:white_check_mark: **DO** deprovision any API version that has been retired. Retired APIs versions should behave like\\r\\nan unknown API version (see [ref](https://aka.ms/azapi/guidelines#versioning-api-version-unsupported)).\\r\\n\\r\\n:white_check_mark: **DO** remove retired API versions from the azure-rest-api-specs repo.\\r\\n\\r\\n:white_check_mark: **DO** review any change to service behavior that could disrupt customers with the Azure Breaking Changes review board, even if the change is not part of the API definition.\\r\\n\\r\\nSome examples of behavior changes that must be reviewed are:\\r\\n- Introducing or changing rate limits to be more restrictive than previously\\r\\n- Changing the permissions required to successfully execute an operation\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#versioning.md\",\"document_title\":\"Versioning\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/versioning\",\"content\":\"# getstarted#versioning.md\\n\\n# Versioning\\n\\nVersioning lets you evolve your API without breaking existing clients. This guide covers the basics of declaring versions and adding new resources, operations, and properties in a clear, easy-to-follow way. For more advanced scenarios, see the [full versioning documentation](../howtos/ARM/versioning.md).\\n\\n## Declaring Versions\\n\\nTo support multiple API versions, define them in an enum. After defining your enum, link it to your namespace using the `@versioned` decorator. For each version, specify your dependencies:\\r\\n\\r\\n```tsp\\r\\n/** Contoso API versions */\\r\\nenum Versions {\\r\\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\\r\\n  v1,\\r\\n\\r\\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\\r\\n  v2,\\r\\n}\\r\\n\\r\\n@versioned(Versions)\\r\\nnamespace Microsoft.ContosoProviderHub;\\r\\n```\\n\\n## Adding a Resource or Operation\\n\\nTo introduce a new model or operation in a specific version (and all later versions), use the `@added` decorator:\\r\\n\\r\\n**Add a model in v2:**\\r\\n\\r\\n```tsp\\r\\n@added(Versions.v2)\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n}\\r\\n```\\r\\n\\r\\n**Add an operation in v2:**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n  @added(Versions.v2)\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\n\\n## Adding a Property or Parameter\\n\\nYou can also add new properties or parameters to models and operations in a specific version:\\r\\n\\r\\n**Add a property in v2:**\\r\\n\\r\\n```tsp\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n\\r\\n  @added(Versions.v2)\\r\\n  city?: string;\\r\\n}\\r\\n```\\r\\n\\r\\n**Add a parameter in v2:**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      name: string;\\r\\n\\r\\n      @added(Versions.v2)\\r\\n      department?: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\\n\\n## Adding New Operations\\n\\nYou can add new operations to an interface for a specific version:\\r\\n\\r\\n**Add a new operation in v2:**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n\\r\\n  @added(Versions.v2)\\r\\n  move is ArmResourceActionSync\\u003cEmployee, MoveRequest, MoveResponse\\u003e;\\r\\n}\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#breaking-change-policy.mdx\",\"document_title\":\"Breaking Change Policy\",\"document_link\":\"https://typespec.io/docs/handbook/breaking-change-policy\",\"content\":\"# handbook#breaking-change-policy.mdx\\n\\n# Breaking Change Policy\\n\\nimport { Badge } from \\\"@astrojs/starlight/components\\\";\\r\\n\\r\\n:::note\\r\\nThe information in this document is applicable to TypeSpec packages with version 1.0.0 or greater.\\r\\n:::\\n\\n## Versioning Scheme\\n\\nThe TypeSpec Compiler and libraries follow a major, minor, patch versioning scheme according to the following policy:\\n\\n## Breaking Change Philosophy\\n\\nExisting language syntax and semantics will not change without a major version.\\r\\nThe runtime behavior for a given TypeSpec will not change without a major version.\\r\\nTypeSpecs leveraging new or updated features may cause runtime API consumers to fail\\r\\n(e.g. because a new type is unhandled in an emitter or library that it uses)\\r\\nor builds to fail (e.g. because exhaustive unions are no longer exhaustive).\\r\\n\\r\\n- The language syntax and semantics for existing language elements will not change within a major version.\\r\\n- A spec that builds successfully with a version of the TypeSpec compiler and its libraries will build successfully with a newer version of the compiler and libraries within the same major version.\\r\\n- New types and functionality may be added in a minor version release to the compiler or any TypeSpec library.\\r\\n  - If a spec uses the new type or functionality, existing libraries or emitters may not work with it, and this is not considered a breaking change in the compiler or library that introduced the type. Spec authors should expect that _existing_ specs will continue to work with their workflows, but not that newly-added features will work with their existing workflows every time.\\r\\n- TypeScript API types in TypeScript might change in ways that introduce TypeScript type checking errors (e.g. adding a new variant to a union). TypeScript type checking errors in library builds are not considered breaking changes, and library authors working in TypeScript should take care to program defensively as appropriate. More information about TypeScript API guarantees is provided in the section _Categories of Breaking Changes_ below.\\n\\n### Bugs\\n\\nA bug fix that introduces a technically breaking change will not be considered a breaking change for the purposes of TypeSpec versioning if it is clear that the existing behavior was broken or unintended in the first place.\\n\\n## Categories of Breaking Changes\\n\\n|\\r\\n| --------------------------------------------- | ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\r\\n| TypeKits                                      | \\u003cBadge text=\\\"0\\\" variant=\\\"success\\\" /\\u003e | TypeKits are the recommend way to expose APIs from a library. TypeKits that are only available through experimental subpaths may be broken without a major version update, but TypeKits that are available by default may be considered highly stable.\\n\\nexports                           | \\u003cBadge text=\\\"2\\\" variant=\\\"danger\\\" /\\u003e  | Any function, class or JS component that is exported but doesn't have a TypeScript type due to being marked `@internal` is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\\r\\n| `/internals` exports                          | \\u003cBadge text=\\\"2\\\" variant=\\\"danger\\\" /\\u003e  | Any types exported from a sub export with the name `/internals` is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\\r\\n|\\n\\n|\\r\\n| Bug fixes                                     | [See bug](#bugs)                     | Bug fixes will not be considered breaking changes for the purposes of TypeSpec versioning if the existing behavior is _clearly_ broken or unintentional (e.g. if it violates the documented and expected behavior, or if there is no reasonable interpretation of the buggy behavior), even if the change is technically a breaking change. Bug fixes that are technically breaking will be documented as breaking changes in the release notes, but will not introduce a major version revision. However, if a bug's behavior has become so widely used as to be considered a \\\"feature,\\\" we will consider the impact of the bugfix and make a reasonable determination to the best of our abilities and depending on the non-breaking mitigation strategies we have at our disposal. We will not break behaviors in stable releases that are known to be widely depended upon, even if we believe they are the result of a bug. |\\n\\n|\\r\\n| TypeKits                                      | \\u003cBadge text=\\\"0\\\" variant=\\\"success\\\" /\\u003e | TypeKits are the recommend way to expose APIs from a library. TypeKits that are only available through experimental subpaths may be broken without a major version update, but TypeKits that are available by default may be considered highly stable.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\\r\\n| Additional library helper functions           | \\u003cBadge text=\\\"0\\\" variant=\\\"success\\\" /\\u003e | Helper and metadata accessor functions exported from the public surface of the compiler or a TypeSpec library are generally considered stable unless otherwise specified or only exported through an experimental subpath.\\n\\n|\\r\\n| `/experimental` exports                       | \\u003cBadge text=\\\"2\\\" variant=\\\"danger\\\" /\\u003e  | Any types exported from a sub export with the name `/experimental` is considered for experimental and its API may change at any time. [See experiemental api](#experimental-apis)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\\r\\n| `TemplateParameter` and template declarations | \\u003cBadge text=\\\"2\\\" variant=\\\"danger\\\" /\\u003e  | Working with template declaration is not currently a stable feature of TypeSpec [See working with template declarations](#working-with-template-declarations)\\n\\n- \\u003cBadge text=\\\"Tier 0\\\" variant=\\\"success\\\" /\\u003e: These are stable core APIs and language features that\\r\\n  define fundamental semantics and will not be broken without a major version update. We recommend\\r\\n  that library authors depend on these APIs.\\r\\n- \\u003cBadge text=\\\"Tier 1\\\" variant=\\\"caution\\\" /\\u003e: These are APIs that have very limited use cases and may\\r\\n  be broken without a major version update. We recommend that library authors avoid depending on\\r\\n  these APIs.\\r\\n- \\u003cBadge text=\\\"Tier 2\\\" variant=\\\"danger\\\" /\\u003e: These are internal APIs intended only for use by the\\r\\n  TypeSpec compiler and core libraries. Tier 2 APIs may be changed without a a major version update\\r\\n  or even documentation of the change. Consuming these APIs is _at your own risk_!\\r\\n- \\u003cBadge text=\\\"Tier 3\\\" variant=\\\"note\\\" /\\u003e: These are APIs and language features that don't de\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Is adding new value to enum is considered a breaking change?\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Is adding new value to enum is considered a breaking change?\\n\\n## question\\n\\nHi Team,\\r\\n \\r\\nWe are working on Workload Orchestration Service which is going to GA soon. In swagger, we have data models where we have enum defined as\\r\\n\\r\\n```\\r\\nunion State {\\r\\n  InReview: \\\"InReview\\\",\\r\\n  UpgradeInReview: \\\"UpgradeInReview\\\",\\r\\n  ReadyToDeploy: \\\"ReadyToDeploy\\\",\\r\\n  ReadyToUpgrade: \\\"ReadyToUpgrade\\\",\\r\\n  Deploying: \\\"Deploying\\\",\\r\\n  Deployed: \\\"Deployed\\\",\\r\\n  Failed: \\\"Failed\\\",\\r\\n  Undeployed: \\\"Undeployed\\\",\\r\\n  PendingExternalValidation: \\\"PendingExternalValidation\\\",\\r\\n  ExternalValidationFailed: \\\"ExternalValidationFailed\\\",\\r\\n  Staging: \\\"Staging\\\",\\r\\n  string,\\r\\n}\\r\\n\\r\\nmodel SolutionProperties {\\r\\n  resourceState: State\\r\\n}\\r\\n```\\r\\nIn future, if we add new value to this existing enums in same api-version after GA, then will it be considered as breaking change or not? Will it cause any failure anywhere in swagger, SDK, etc?\\n\\n## answer\\n\\nextensible union as defined in your example wouldn't count as a breaking change to add a new entry as it defines this as already allowing any string\\r\\nFor clarity,  an 'extensible enum'  is represented in TypeSpec as an open union.  That is a union of string values that include string as a variant (`union Foo { Bar: \\\"bar\\\", Baz: \\\"baz\\\", string}`).  In this case, adding new values is not a breaking change, but removing values is\\r\\n \\r\\nAn enum or closed union (union with just literal string variants, `union Foo {Bar: \\\"bar\\\", Baz: \\\"baz\\\"}`) is considered a closed enum, which means that adding or removing values is a breaking change.\\r\\n \\r\\nThe reason for the difference is that some SDKs have enumeration types that are used when an enum is comprehensive (closed),  but not used if the enum is partial.  When the enumeration types are used, customer code can break if it processes each of the variants explicitly.\\r\\n \\r\\nThis is why we highly recommend use open enumerations in most cases, and to use a closed enum you have to suppress a linting rule.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Breaking Change(Cross-Version) failure\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Breaking Change(Cross-Version) failure\\n\\n## question\\n\\nWe have the [PR](https://github.com/Azure/azure-rest-api-specs-pr/pull/22834) to introduce new API version with new features for existing RP. The [Breaking Changes(Cross-Version) detected problems](https://github.com/Azure/azure-rest-api-specs-pr/pull/22834/checks?check_run_id=43004413278). How to fix it?\\n\\n## answer\\n\\nIt depends.  Even across versions, some changes are discouraged/disallowed.  If the breaking changes reported in your PR are all intentional, then you just need to follow the instructions in the \\\"next steps to merge\\\" comment to work with the breaking changes board for approval: https://aka.ms/brch\\r\\nGenerally, breaking changes between preview api-versions are allowed if there are good reasons,  breaking changes relative to a stable api-version are more of a concern.  Also, if preview api-versions are old enough, they count as stable api-versions (I doubt that is the case here).\\r\\nThe case here is a preview with breaking changes relative to the last stable. And in this case, making a property optional would be considered breaking if the property occurs in responses.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_07.md\",\"document_title\":\"How to version a spread property (ManagedServiceIdentityProperty)?\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_07.md\\n\\n# How to version a spread property (ManagedServiceIdentityProperty)?\\n\\n## question\\n\\nI'm trying to add Managed Identity support and want to avoid a breaking change. \\r\\nHowever, adding `...Azure.ResourceManager.ManagedServiceIdentityProperty;` would update all my existing API versions and introduce a breaking change. \\r\\nThat's the right way to introduce the MSI property so I can only add it in a new version of my model? \\r\\nIf instead I'd directly add to my tracked resource `identity?: Foundations.ManagedServiceIdentity;` I get a warning about this not being valid in the resource envelope.\\r\\nAnd how without having to create an entirely separate model. What I want is to introduce the property in a new API version `2025-05-04-preview` only.\\n\\n## answer\\n\\nYou can do it using an extension decorator like this:\\r\\n```\\r\\n/** A ContosoProviderHub resource */\\r\\nmodel Employee is TrackedResource\\u003cEmployeeProperties\\u003e {\\r\\n  ...ResourceNameParameter\\u003cEmployee\\u003e;\\r\\n  ...ManagedServiceIdentityProperty;\\r\\n}\\r\\n\\r\\n@@added(Employee.identity, Versions.`2024-10-01-preview`);\\r\\n```\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# Create a PR against main\\n## Clean PR against main\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial\",\"content\":\"# Tutorial: Create a new service spec\\n## Why work in a separate branch?\\nThe [Microsoft Azure REST API Guidelines state](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-versioning),\\r\\n\\r\\n\\u003e Azure services need to change over time. However, when changing a service, there are 2 requirements:\\r\\n\\u003e\\r\\n\\u003e 1. Already-running customer workloads must not break due to a service change.\\r\\n\\u003e 2. Customers can adopt a new service version without requiring any code changes.\\r\\n\\u003e    Of course, the customer must modify code to leverage any new service features.\\r\\n\\r\\nTogether with the [Breaking Changes Policy](http://aka.ms/AzBreakingChangesPolicy/), it effectively means that any\\r\\nchanges you merge directly into the `main` branch in  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) must be supported for 90 days for preview\\r\\nversions, and 3 years for stable versions at a minimum.\\r\\n\\r\\nWorking in a separate branch allows your team to iterate on a design, make changes to the REST API definition or\\r\\neven the service as needed, and merge those changes to `main` - effectively publishing that service version -\\r\\nwhen you're ready.\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#ConsiderationsForServiceDesign.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/ConsiderationsForServiceDesign.md\",\"content\":\"# Considerations for Service Design\\n\\u003c!-- cspell:ignore autorest, etag, idempotency, maxpagesize, openapi --\\u003e\\r\\n\\u003c!-- markdownlint-disable MD033 --\\u003e\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/versioning\",\"content\":\"# Versioning\\n## Introduction\\nVersioning allows you to evolve your API without breaking existing clients. By using versioning decorators, you can specify when resources, operations, or properties are added, removed, or changed.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/versioning\",\"content\":\"# Versioning\\nThis document explains how to manage versioning in TypeSpec projects, including how to add, remove, or modify resources, operations, and properties across API versions.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#getting-started-rest#06-versioning.mdx\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\",\"content\":\"# Versioning\\n## Adding the Versioning Library\\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\"}]",
            "inputs.latency": 162.92231965065002,
            "inputs.response_length": 1657,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep",
                "https://github.com/microsoft/api-guidelines/blob/vNext/azure/VersioningGuidelines.md"
            ],
            "inputs.testcase": "Update the enum for the exisitng API version",
            "outputs.similarity.similarity": 3.0,
            "outputs.similarity.gpt_similarity": 3.0,
            "outputs.similarity.similarity_result": "fail",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1545,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1546,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Update the enum for the exisitng API version\\\\n\\\\nquestion: API Spec Review\\\\nWe have the api-spec for verion 2025-08-01 for the storage mover [azure-rest-api-specs-pr/specification/storagemover/resource-manager/Microsoft.StorageMover/stable/2\\\\u2026](https://github.com/Azure/azure-rest-api-specs-pr/tree/RPSaaSMaster/specification/storagemover/resource-manager/Microsoft.StorageMover/stable/2025-08-01)\\\\nThis version is not live yet.And no customer are using this. If I have to change a Enum and also add new optional for this version, can it be changed and we get the approval from the breaking change team?\\\", \\\"response\\\": \\\"Yes, you can change an existing enum and add a new optional property in the API version 2025-08-01 for Storage Mover **if the version is not yet live and not used by any customers**. According to the Azure Versioning and Breaking Changes Policy and supporting deep-dive documentation:\\\\n\\\\n- Breaking changes (including enum changes and adding/removing properties) to an API version **are allowed** if that API version has not been published to a production branch (main or RPSaaSMaster) and no customers are using it yet. Once an API version is published and available to customers (even in public preview), it is considered a contract and cannot be changed except for approved bug fixes.\\\\n- If your PR targets a production branch and the API version is already published (even if not yet GA), then *any* change\\\\u2014even non-breaking\\\\u2014will require approval from the breaking change review board. This is enforced by automated checks that apply `BreakingChangeReviewRequired` or `VersioningReviewRequired` labels. However, if your version is not live (not merged to production), you are free to make changes before it goes live.\\\\n\\\\n**Action Steps:**\\\\n- If your API version 2025-08-01 is not yet merged into a production branch, you may update enums and add new optional properties as needed\\\\u2014no review needed.\\\\n- If your API version is already merged and visible to customers, you must follow the breaking change review process (see [aka.ms/brch]) and obtain explicit approval before merging breaking changes.\\\\n\\\\n**Summary:**\\\\nYou are permitted to change the enum and add new optional properties in an unpublished API version. Once published, changes are tightly controlled.\\\\n\\\", \\\"ground_truth\\\": \\\"If this version merged to RPSaaSMaster, it has \\\\\\\"released\\\\\\\".  When you added label PublishToCustomers to the PR, you were agreeing to this statement:\\\\n```\\\\nThis PR targets either the main branch of the public specs repo or the RPSaaSMaster branch of the private specs repo. These branches are not intended for iterative development. Therefore, you must acknowledge you understand that after this PR is merged, the APIs are considered shipped to Azure customers. Any further attempts at in-place modifications to the APIs will be subject to Azure's versioning and breaking change policies.\\\\n```\\\\nThat said, you can open a PR with the changes you'd like to make, then follow the process in the \\\\\\\"next steps to merge comment\\\\\\\" once your breaking changes are detected.\\\\nThe process is documented at these two links:\\\\n1.https://aka.ms/brch\\\\n2.https://aka.ms/azsdk/pr-brch-deep\\\\nYou can self-apply a label if your PR meets the qualifications (2).\\\\nOr contact the breaking changes board for review and approval, by attending the office hours, or sending email to azbreakchangereview@microsoft.com (1).\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"
        },
        {
            "inputs.query": "title: Assistance required with breaking change PR\n\nquestion: Hi team,\nWe have the following open PR: [[Microsoft.Marketplace] - Adding new product fields by eladschartz · Pull Request #38748 · Azure/az…](https://github.com/Azure/azure-rest-api-specs/pull/38748)\nWhich adds a few missing fields to our returned payload and seems to be marked as a breaking change (violation of rule 1041 - AddedPropertyInResponse). Since we are a REST API only, I'm not sure how counts as a breaking change as it changes nothing about the way existing customers interact with our APIs.\nIs there some way to suppress this rule/ request an exception?",
            "inputs.ground_truth": "Follow the process documented in the \"next steps to merge\" comment in your PR, to engage with the breaking change reviewers.\nFor your breaking changes, unless your spec has a special exception, I think you might need to move these changes to a new API version.  Existing API versions should generally not be updated like your PR is doing.",
            "inputs.response": "For Azure REST APIs, adding new properties to response payloads is considered a breaking change per Azure's API versioning and breaking change policies—even if it doesn't impact existing client interactions. The automated check flags this as a violation of rule 1041 (AddedPropertyInResponse) because once an API version is published, any change to the response schema can break strict client contracts or downstream code relying on the original structure.\n\n**Process to request an exception or suppression:**\n- You cannot directly suppress this rule using a configuration or a YAML directive; instead, you must follow the official breaking change review process.\n- If your PR is blocked due to a breaking change, request a review from the Breaking Change Review Board. This is done by following the instructions at [aka.ms/brch](https://aka.ms/brch) and potentially emailing azbreakchangereview@microsoft.com. \n- If the board approves your change (for example, if it is determined to be benign, a bug fix, or required for user impact), they will apply the appropriate approval label (e.g., `BreakingChange-Approved-Benign`, `BreakingChange-Approved-BugFix`, or `BreakingChange-Approved-UserImpact`) to your PR, which will unblock it.\n- Only after this explicit approval can the breaking change be merged.\n\n**Key points:**\n- Do NOT suppress this rule on your own or bypass the review process, as this would violate Azure's published guidelines and could cause downstream compatibility issues.\n- The policy applies regardless of whether you are a REST-only service or provide SDKs; it is enforced for all Azure APIs to maintain customer contract stability.\n\nReference documentation is provided below. For your specific PR, please proceed with the breaking change review process as described.",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# design#specs-pr-guides#pr-suppressions.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-suppressions](https://aka.ms/azsdk/pr-suppressions) |\\r\\n|--|--|\\n\\n# Suppress validation failures on a PR\\n\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nOn your Azure REST API specs PR, some of the GitHub check failures (see the `Checks` tab on your PR) can be suppressed.\\r\\nThe suppression can be either just for the PR, or permanent.\\n\\n## To suppress given validation failure\\n\\n1. Determine which failing check you want to suppress: see its name in the `Checks` tab in your PR.\\r\\n1. Determine if you have one of the [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. Determine if you want to suppress the failure only for the PR, or permanently.\\r\\n1. Consult [the suppression cases table](#suppression-cases-table) for instructions corresponding to your case.\\r\\n1. If you want to apply temporary suppression:\\r\\n   1. Mention in a comment on your PR the PR assignee asking to apply the suppression. Provide justification.\\r\\n      See [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. If you applied permanent suppression:\\r\\n   1. It will manifest by the PR getting a label `SuppressionReviewRequired`.\\r\\n   1. Verify the suppression works by the check changing from **failed** to **neutral**.\\r\\n   1. Wait until your suppression is reviewed. If it is approved, the approved will add the `Approved-Suppression` label.\\r\\n   1. Understand the suppression won't be approved if it is not one of the  \\r\\n      [valid suppression reasons](#valid-suppression-reasons) as explained in relevant section.\\n\\n## Suppression cases table\\n\\n|\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met | Not possible                              |                                                      | Not possible                                                    |\\r\\n\\r\\n[1] Applies only if the SDK generation check failed with a breaking change. For details of SDK breaking change suppression, see https://aka.ms/azsdk/sdk-suppression.\\r\\nGeneral SDK generation check failure suppressions are not supported. See [#6509].\\n\\n|\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger SemanticValidation         | See [aka.ms/ci-fix]                       | `Approved-SemanticValidation`                        | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger ModelValidation            | See [aka.ms/ci-fix]                       | `Approved-ModelValidation`                           | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger Breaking Change            | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Breaking Change(Cross-Version)     | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              |\\n\\nTable legend:\\r\\n\\r\\n- `Check name`: Check to suppress.\\r\\n- `PR suppression`: instructions to obtain suppression for given check for given PR only.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n- `Label`: the label your PR will get if your suppression is approved.\\r\\n- `Permanent suppression`: instructions how to get permanent suppression.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n\\r\\n| Check name                         | PR suppression                            | Label                                                | Permanent suppression                                           |\\r\\n|------------------------------------|-------------------------------------------|------------------------------------------------------|-----------------------------------------------------------------|\\r\\n| TypeSpec Requirement               | Not possible                              |                                                      | [suppressions.yaml](#suppressionsyaml)                      |\\r\\n| TypeSpec Validation                | Not possible                              |                                                      | Not possible                                                    |\\r\\n| license/cla                        | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 |\\n\\n|\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-net-track2       | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-go               | See [step 3 in the diagram] but note [1]. | `BreakingChange-Go-Sdk-Suppression-Approved`         | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-java             | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-js               | See [step 3 in the diagram] but note [1]. | `BreakingChange-JavaScript-Sdk-Suppression-Approved` | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met |\\n\\n## suppressions.yaml\\n\\nFile `suppressions.yaml` is used for all checks created in 2024 or later, like\\r\\n`TypeSpec Requirement` and `TypeSpec Validation`.\\r\\n\\r\\nFor simplicity, we recommend adding all suppressions to a single file at the root of your spec folder:\\r\\n\\r\\n```\\r\\nspecification/myservice/suppressions.yaml\\r\\n```\\r\\n\\r\\nAlternatively, you can use multiple files in separate folders.  Currently, tools will use the first\\r\\ninstance of `suppressions.yaml` found walking up the directory tree.  We are planning\\r\\nfuture support for \\\"merging\\\" files up the hierarchy.\\r\\n\\r\\nA suppression follows this general format:\\r\\n\\r\\n```\\r\\n- tool: ToolName\\r\\n  path: applies/to/**/*.json\\r\\n  reason: Why this can't be fixed\\r\\n```\\r\\n\\r\\n`path` uses \\\"glob\\\" matching.  For syntax, see https://www.npmjs.com/package/minimatch.\\r\\n\\r\\nScope your `path` as narrowly as possible.  For example, if a suppression only applies\\r\\nto a single version of your spec:\\r\\n\\r\\n```\\r\\n# good\\r\\n- path: data-plane/Azure.Contoso.WidgetManager/preview/2022-11-01-preview/**/*.json\\r\\n\\r\\n# bad\\r\\n- path: data-plane/**/*.json\\r\\n```\\r\\n\\r\\nWhen in doubt, search the repo for examples:\\r\\n\\r\\nhttps://github.com/search?q=repo%3AAzure%2Fazure-rest-api-specs+path%3A%2F%28%5E%7C%5C%2F%29suppressions%5C.yaml%24%2F\\u0026type=code\\n\\n### `TypeSpec Requirement` check\\n\\nTo suppress `TypeSpec Requirement` check for given pattern of OpenAPI spec .json file paths, provide an entry with\\r\\n`tool` set to `TypeSpecRequirement`. Provide the pattern as `path` and provide a `reason`.\\r\\n\\r\\nExample:\\r\\n\\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: data-plane/**/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## Suppress AutoRest extension\\n\\nTo suppress tooling that is an AutoRest extension (see [the suppressio\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# design#specs-pr-guides#pr-brch-deep.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-brch-deep](https://aka.ms/azsdk/pr-brch-deep) |\\r\\n| --- | --- |\\n\\n# Deep-dive into breaking changes on spec PRs\\n\\n## Important information about this article\\n\\nThis article provides a deep-dive into breaking changes on spec PRs. It applies if your spec PR has\\r\\n`BreakingChangeReviewRequired` or `VersioningReviewRequired` label.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e This is an advanced deep-dive. If your PR is blocked on breaking changes or versioning issues, you should always\\r\\n\\u003e start by following the guidance at [aka.ms/brch].\\n\\n### Prerequisites\\n\\nThis article assumes you are familiar with [API versions and branches](xref:api-versions-and-branches).\\n\\n### Video overview and slides\\n\\nFor video overview of the breaking changes process, see this [Azure Core Day of Learning talk from March 6, 2024].\\r\\nSlides for the talk are available [here][talk slides].\\n\\n### Summary\\n\\nPer the [PR diagram], the first step of getting your specs PR approved is ensuring your PR obeys the  \\r\\n[Azure Versioning and Breaking Changes Policy]. Relevant details of this policy follow.\\r\\n\\r\\n- Once published, no changes to given API version are allowed, except when fixing the spec to match\\r\\nactual implementation (see the `-Approved-BugFix` labels in this doc).\\r\\nThis applies regardless of whether the API version is for `private preview`, `public preview`, or `GA`.\\r\\n- When introducing a new API version (any `preview` or `GA`), the new API version must be backwards compatible with\\r\\nthe previous, latest `GA` API version.\\r\\n- During a (`private` or `public`) `preview` cycle, a new `preview` API version does not have to be backwards\\r\\ncompatible with the previous `preview` API version.\\r\\n- The rules listed above are checked by automated GitHub checks. The exact ruleset is given in [`oadMessagesRuleMap.ts`].\\r\\nDetails follow.\\n\\n## Breaking changes and versioning issues\\n\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\\n\\n### `BreakingChangeReviewRequired` label\\n\\nThe label `BreakingChangeReviewRequired` is added to your PR if the tooling detects a change that could\\r\\nbe breaking for customers. This can happen in two cases:\\r\\n\\r\\n- In your PR you have possibly introduced a breaking change in a new API version, placed in a new folder,\\r\\nas compared to most recent previous `GA`.\\r\\nThe new API version can be either `preview` or `GA`.\\r\\n  - For example, an existing `GA` API version in leaf folder of `2023-11-15`\\r\\nmay contain API route of `GET .../resoruces/{resourceName}`, but a new `preview` API version of `2024-03-15-preview`\\r\\nmay no longer have this route (REST API path), because you are removing the `resoruces` typo and instead introducing\\r\\n`GET .../resources/{resourceName}` route.\\r\\n- In your PR you are modifying existing `GA` API version in-place. For example, you have recently released\\r\\n`2024-03-18` API version and realized you made a typo and are editing the contents of the leaf folder `2024-03-18`\\r\\ncontaining that API version.\\n\\n### `VersioningReviewRequired` label\\n\\nThe label `VersioningReviewRequired` denotes that your PR has a **versioning issue** possibly violating the  \\r\\n[Azure Versioning and Breaking Changes Policy]. This happens when you made a **non-breaking change**,\\r\\naka **compatible change** to an API version that was already published (merged to a production branch).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e According to [the policy][Azure Versioning and Breaking Changes Policy], compatible (non-breaking changes) are not\\r\\n\\u003e allowed within an existing API version. You must create a new API version. Otherwise, we would confuse our customers\\r\\n\\u003e by having to explain \\\"which version of given API version\\\" has a particular change/feature.\\r\\n\\r\\n`VersioningReviewRequired` label is added by automation if:\\r\\n\\r\\n- You made any compatible changes **within** any API version, `GA` or `preview`.\\r\\n- You made any breaking changes in a `preview` API version.\\r\\n\\r\\nIf your PR has both breaking changes and versioning issues, only `BreakingChangeReviewRequired` label\\r\\nis added to it.\\n\\n### In case there is no latest GA API version\\n\\nIf there is no latest GA OpenAPI spec, then the the cross-version check is instead comparing to\\r\\nlatest available preview if it more than 1 year old.\\r\\n\\r\\nIf neither a GA API version or at least 1 year old preview version exists, then the cross-version check automatically\\r\\npasses.\\n\\n### Diagram explaining breaking changes and versioning issues\\n\\nThe logic for automation adding `BreakingChangeReviewRequired` and `VersioningReviewRequired` labels explained above\\r\\ncan be summarized in the following diagram:\\r\\n\\r\\n![Breaking Changes Confusion Matrix](../../img/breaking_changes_confusion_matrix.png)\\n\\n## Addressing `BreakingChangeReviewRequired`\\n\\nIf your PR is labelled with `BreakingChangeReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the breaking changes in your PR are acceptable, they will be\\r\\napproved by one of these labels:\\n\\n### `BreakingChange-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `BreakingChange-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-UserImpact`\\n\\n- The spec PR describes actual breaking changes to the service.\\r\\n- This is the only case that triggers customer notifications, a 3 year migration period (possibly shorter), etc.\\r\\n- Within this set, the changes may be distinguished further for security or legal compliance, which may be granted\\r\\na shorter migration period.\\r\\n- Details at [aka.ms/brch].\\n\\n### `BreakingChange-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Addressing `VersioningReviewRequired`\\n\\nIf your PR is labelled with `VersioningReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the versioning issue in your PR caused by non-breaking (compatible)\\r\\nchanges is acceptable, the board will approve it by one of these labels:\\n\\n### `Versioning-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `Versioning-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-PrivatePreview`\\n\\nThe API version change that triggered the review is in `private preview`, and non-breaking changes are permitted\\r\\nin the same API version during `private preview`.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-PrivatePreview` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Common misconceptions\\n\\n### FALSE: compatible (non-breaking) changes are allowed in published API versions\\n\\n**Why?**\\r\\n\\r\\nAn API version is a contract, and once the contract is published it cannot be changed.\\r\\nOtherwise, it would create customer confusion about \\\"which version of this API version\\\" are they using.\\r\\n\\r\\nAny change of this kind w\"},{\"document_source\":\"azure_resource_manager_rpc\",\"document_filename\":\"v1.0#resource-api-reference.md\",\"document_title\":\"Resource API Reference\",\"document_link\":\"https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/resource-api-reference.md\",\"content\":\"# v1.0#resource-api-reference.md\\n\\n# Resource API Reference\\n\\nand blocks the OpenAPI spec PRs from getting approved. All `Recommended` rules are strong suggestions, some of which are also automated using linter rules. Violating these rules results in **warnings** to be flagged by the automated checks. All `Allowed` rules simply specify what a service team is allowed to do.\\r\\n\\u003e+ The `Additional impact` column describes any additional impact the specific rule has on APIs that violate the rule over and above the general impact described for the section.\\r\\n\\u003e+ The `Applicabale scope` column describes the scope to which the specific rule applies to. It has one of the following values [ Design | Runtime ]. The value `Design` means that the rule applies to the API design. This means that the rule will be in scope starting from the API design reviews and will most likely also be covered by linter rules. All rules that are in scope for the design phase automatically imply that the runtime will also adhere to it. The value `Runtime` means that the rule applies exclusivley to the runtime implementation of the API. Such a rule cannot be enforced at design time as it refers to something that the actual service runtime is expected to adhere to.\\r\\n\\u003e+ The `Linter rule` column points to the documentation for the error received when this rule is violated in your OpenAPI specification.\\n\\nThese are the APIs that are implemented by resource providers (a.k.a. RPs) when exposing resource types through Azure Resource Manager (a.k.a ARM). This section is divided into further sub sections for easy reading as follows.\\r\\n\\r\\n- [Uri format and arguments for CRUD APIs on Resources](./uri-format-and-arguments-for-crud-apis-on-resources.md)\\r\\n- [Put Resource](./put-resource.md)\\r\\n- [Patch Resource](./patch-resource.md)\\r\\n- [Delete Resource](./delete-resource.md)\\r\\n- [Get Resource](./get-resource.md)\\r\\n- [Pagination](./pagination.md)\\r\\n- [Move Resource](./move-resource.md)\\r\\n\\r\\n\\u003cbr\\u003e\\r\\n\\u003cbr\\u003e\\r\\n\\r\\n\\u003eNOTE: Each of these pages has an `Overview` and a `Rules` section. The `Overview` section provides general information about the topic. The `Rules` section enumerates a list of granular rules that service owners should implement. Each rule has an RPC guideline code, Title, Conformance level, Additional impact and a link to the linter rule if the ruleis automated. \\r\\n\\u003e\\r\\n\\u003e+ The `RPC guideline code` column has values in the format `RPC-{Category}-V1-{serialNumber}`. This code will used for various reporting and tracking purposes.  \\r\\n\\u003e+ The `Title` column describes the rule.\\r\\n\\u003e+ The `Conformance level` column has one of the following values - [Required | Recommended | Allowed]. All `Required` rules are enforced using automated linter rules and **must** be adhered to. Violating these rules results in **errors** to be flagged by the automated checks and blocks the OpenAPI spec PRs from getting approved. All `Recommended` rules are strong suggestions, some of which are also automated using linter rules. Violating these rules results in **warnings** to be flagged by the automated checks. All `Allowed` rules simply specify what a service team is allowed to do.\\r\\n\\u003e+ The `Additional impact` column describes any additional impact the specific rule has on APIs that violate the rule over and above the general impact described for the section.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#arm-rules.md\",\"document_title\":\"ARM Rules, TypeSpec Linting, and Suppression\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\",\"content\":\"# howtos#arm#arm-rules.md\\n\\n# ARM Rules, TypeSpec Linting, and Suppression\\n\\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\\r\\n\\r\\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\\n\\n## ARM RPC Rules\\n\\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\\r\\n\\r\\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\\n\\n## Detecting and Suppressing Rule Violations at Design Time\\n\\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\\r\\n\\r\\nHere is an example of a linter warning:\\r\\n\\r\\n```bash\\r\\nDiagnostics were reported during compilation:\\r\\n\\r\\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\\r\\n\\u003e 38 |   /** Gets the Zero Trust URL for this resource */\\r\\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n\\u003e 39 |   @post\\r\\n     | ^^^^^^^\\r\\n\\u003e 40 |   getZeroTrustUrl(...ResourceInstanceParameters\\u003cZeroTrustResource\\u003e): ZeroTrustUrl | ErrorResponse;\\r\\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n\\r\\nFound 1 warning.\\r\\n\\r\\n```\\r\\n\\r\\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\\r\\n\\r\\n```typespec\\r\\n  #suppress \\\"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\\\" \\\"This is a sample suppression.\\\"\\r\\n  /** Gets the MAA URL for this resource */\\r\\n  @post\\r\\n  getZeroTrustUrl(...ResourceInstanceParameters\\u003cZeroTrustResource\\u003e): ZeroTrustUrl | ErrorResponse;\\r\\n```\\r\\n\\r\\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\\r\\n\\r\\n```typespec\\r\\n  @armResourceAction(ZeroTrustResource)\\r\\n  /** Gets the MAA URL for this resource */\\r\\n  @post\\r\\n  getZeroTrustUrl(...ResourceInstanceParameters\\u003cZeroTrustResource\\u003e): ZeroTrustUrl | ErrorResponse;\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#breaking-change-policy.mdx\",\"document_title\":\"Breaking Change Policy\",\"document_link\":\"https://typespec.io/docs/handbook/breaking-change-policy\",\"content\":\"# handbook#breaking-change-policy.mdx\\n\\n# Breaking Change Policy\\n\\nimport { Badge } from \\\"@astrojs/starlight/components\\\";\\r\\n\\r\\n:::note\\r\\nThe information in this document is applicable to TypeSpec packages with version 1.0.0 or greater.\\r\\n:::\\n\\n## Versioning Scheme\\n\\nThe TypeSpec Compiler and libraries follow a major, minor, patch versioning scheme according to the following policy:\\n\\n## Breaking Change Philosophy\\n\\nExisting language syntax and semantics will not change without a major version.\\r\\nThe runtime behavior for a given TypeSpec will not change without a major version.\\r\\nTypeSpecs leveraging new or updated features may cause runtime API consumers to fail\\r\\n(e.g. because a new type is unhandled in an emitter or library that it uses)\\r\\nor builds to fail (e.g. because exhaustive unions are no longer exhaustive).\\r\\n\\r\\n- The language syntax and semantics for existing language elements will not change within a major version.\\r\\n- A spec that builds successfully with a version of the TypeSpec compiler and its libraries will build successfully with a newer version of the compiler and libraries within the same major version.\\r\\n- New types and functionality may be added in a minor version release to the compiler or any TypeSpec library.\\r\\n  - If a spec uses the new type or functionality, existing libraries or emitters may not work with it, and this is not considered a breaking change in the compiler or library that introduced the type. Spec authors should expect that _existing_ specs will continue to work with their workflows, but not that newly-added features will work with their existing workflows every time.\\r\\n- TypeScript API types in TypeScript might change in ways that introduce TypeScript type checking errors (e.g. adding a new variant to a union). TypeScript type checking errors in library builds are not considered breaking changes, and library authors working in TypeScript should take care to program defensively as appropriate. More information about TypeScript API guarantees is provided in the section _Categories of Breaking Changes_ below.\\n\\n### Bugs\\n\\nA bug fix that introduces a technically breaking change will not be considered a breaking change for the purposes of TypeSpec versioning if it is clear that the existing behavior was broken or unintended in the first place.\\n\\n## Categories of Breaking Changes\\n\\n|\\r\\n| --------------------------------------------- | ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\\r\\n| TypeKits                                      | \\u003cBadge text=\\\"0\\\" variant=\\\"success\\\" /\\u003e | TypeKits are the recommend way to expose APIs from a library. TypeKits that are only available through experimental subpaths may be broken without a major version update, but TypeKits that are available by default may be considered highly stable.\\n\\nexports                           | \\u003cBadge text=\\\"2\\\" variant=\\\"danger\\\" /\\u003e  | Any function, class or JS component that is exported but doesn't have a TypeScript type due to being marked `@internal` is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\\r\\n| `/internals` exports                          | \\u003cBadge text=\\\"2\\\" variant=\\\"danger\\\" /\\u003e  | Any types exported from a sub export with the name `/internals` is considered for internal use only and its API may change at any time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |\\r\\n|\\n\\n|\\r\\n| Bug fixes                                     | [See bug](#bugs)                     | Bug fixes will not be considered breaking changes for the purposes of TypeSpec versioning if the existing behavior is _clearly_ broken or unintentional (e.g. if it violates the documented and expected behavior, or if there is no reasonable interpretation of the buggy behavior), even if the change is technically a breaking change. Bug fixes that are technically breaking will be documented as breaking changes in the release notes, but will not introduce a major version revision. However, if a bug's behavior has become so widely used as to be considered a \\\"feature,\\\" we will consider the impact of the bugfix and make a reasonable determination to the best of our abilities and depending on the non-breaking mitigation strategies we have at our disposal. We will not break behaviors in stable releases that are known to be widely depended upon, even if we believe they are the result of a bug. |\\n\\n|\\r\\n| TypeKits                                      | \\u003cBadge text=\\\"0\\\" variant=\\\"success\\\" /\\u003e | TypeKits are the recommend way to expose APIs from a library. TypeKits that are only available through experimental subpaths may be broken without a major version update, but TypeKits that are available by default may be considered highly stable.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\\r\\n| Additional library helper functions           | \\u003cBadge text=\\\"0\\\" variant=\\\"success\\\" /\\u003e | Helper and metadata accessor functions exported from the public surface of the compiler or a TypeSpec library are generally considered stable unless otherwise specified or only exported through an experimental subpath.\\n\\n|\\r\\n| `/experimental` exports                       | \\u003cBadge text=\\\"2\\\" variant=\\\"danger\\\" /\\u003e  | Any types exported from a sub export with the name `/experimental` is considered for experimental and its API may change at any time. [See experiemental api](#experimental-apis)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\\r\\n| `TemplateParameter` and template declarations | \\u003cBadge text=\\\"2\\\" variant=\\\"danger\\\" /\\u003e  | Working with template declaration is not currently a stable feature of TypeSpec [See working with template declarations](#working-with-template-declarations)\\n\\n- \\u003cBadge text=\\\"Tier 0\\\" variant=\\\"success\\\" /\\u003e: These are stable core APIs and language features that\\r\\n  define fundamental semantics and will not be broken without a major version update. We recommend\\r\\n  that library authors depend on these APIs.\\r\\n- \\u003cBadge text=\\\"Tier 1\\\" variant=\\\"caution\\\" /\\u003e: These are APIs that have very limited use cases and may\\r\\n  be broken without a major version update. We recommend that library authors avoid depending on\\r\\n  these APIs.\\r\\n- \\u003cBadge text=\\\"Tier 2\\\" variant=\\\"danger\\\" /\\u003e: These are internal APIs intended only for use by the\\r\\n  TypeSpec compiler and core libraries. Tier 2 APIs may be changed without a a major version update\\r\\n  or even documentation of the change. Consuming these APIs is _at your own risk_!\\r\\n- \\u003cBadge text=\\\"Tier 3\\\" variant=\\\"note\\\" /\\u003e: These are APIs and language features that don't de\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_10.md\",\"document_title\":\"Is it so bad to introduce named types to replace unnamed ones?\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_10.md\\n\\n# Is it so bad to introduce named types to replace unnamed ones?\\n\\n## question\\n\\nRE [Yuxia/20250401preview by blankor1 · Pull Request #33507 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/33507#issuecomment-3029062363)\\r\\n \\r\\nI notice a suppression in the typespec PR \\r\\n \\r\\n#suppress \\\"@azure-tools/typespec-client-generator-core/no-unnamed-types\\\" \\\"Backwards compatibility with existing clients.\\\"\\r\\n \\r\\nSounds like the PR author is under the impression its a bad idea to get rid of unnamed types and replace them with named ones, because of concerns about backwards compatibility. Is this actually correct?\\r\\n \\r\\nOr would we consider this a benign change? And a best practice to 'fix' unnamed types by creating named types to replace them?\\n\\n## answer\\n\\nIntroducing named types to replace unnamed ones is not a bad idea—in fact, it's preferred. The linter rule @azure-tools/typespec-client-generator-core/no-unnamed-types exists to encourage naming types. However, in the PR you referenced, there was a suppression added with the justification of \\\"Backwards compatibility with existing clients.\\\"\\r\\n\\r\\nAfter reviewing the context, it seems this suppression may not be necessary. The rule itself is currently disabled due to performance issues, so removing the suppression won’t trigger CI. Conceptually, this is a false positive: the anonymous model created via @bodyRoot is a temporary structure that the SDK won’t use, so it shouldn't be flagged.\\r\\n\\r\\nStill, the current template resolves to a borderline case where the SDK might auto-generate a name. A cleaner approach would be to use @@clientName to rename the body parameter directly, avoiding the anonymous model altogether. This is considered a better practice.\\r\\n\\r\\nSo yes—replacing unnamed types with named ones is generally a good idea, and in this case, the suppression may not be needed.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Swagger breaking change\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Swagger breaking change\\n\\n## question\\n\\nPR check run: https://github.com/Azure/azure-rest-api-specs/pull/35346/checks?check_run_id=44501918225\\r\\nMy typespec conversion PR is failing in swagger breaking change check with the following error: \\r\\n\\\"new\\\":\\\"https://github.com/Azure/azure-rest-api-specs/blob/a1ac3f6f98bb1ea3583b765d00dfceab6d85654f/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json\\\",\\r\\n\\\"old\\\":\\\"https://github.com/Azure/azure-rest-api-specs/blob/main/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json\\\",\\r\\n\\\"details\\\":\\\"incompatible properties : tags\\\\n definitions/TrackedResource/properties/tags\\\\n at file:///mnt/vss/_work/1/azure-rest-api-specs/specification/common-types/resource-management/v3/types.json#L489:8\\\\n definitions/Resource/properties/tags\\\\n at file:///mnt/vss/_work/1/azure-rest-api-specs/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json#L12397:8\\\" \\r\\nThis PR is just having typespec conversion change and I am avoiding any change to the swagger file that is generated as part of typespec conversion. In the old swagger there is a Resource definitionwhich is similar Azure resource definition. Should I suppress this check and how to do it?\\n\\n## answer\\n\\nThis occurs because in your original swagger, you did not use swagger common-types. \\r\\nThe 'tags' definitions are compatible, so there is no change in the actual api from this.  This could result in changes in some management sdks, although this change to using the common resource types has generally been accepted. \\r\\ndocs on suppressions for false positives are here: [Suppress validation failures on a PR](https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions) \\r\\nNote that it is important to go through these violations, as the conversion is not guaranteed to be 100% accurate.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Swagger breaking change\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Swagger breaking change\\n\\n## question\\n\\nPR check run: https://github.com/Azure/azure-rest-api-specs/pull/35346/checks?check_run_id=44501918225\\r\\nMy typespec conversion PR is failing in swagger breaking change check with the following error: \\r\\n\\\"new\\\":\\\"https://github.com/Azure/azure-rest-api-specs/blob/a1ac3f6f98bb1ea3583b765d00dfceab6d85654f/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json\\\",\\r\\n\\\"old\\\":\\\"https://github.com/Azure/azure-rest-api-specs/blob/main/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json\\\",\\r\\n\\\"details\\\":\\\"incompatible properties : tags\\\\n definitions/TrackedResource/properties/tags\\\\n at file:///mnt/vss/_work/1/azure-rest-api-specs/specification/common-types/resource-management/v3/types.json#L489:8\\\\n definitions/Resource/properties/tags\\\\n at file:///mnt/vss/_work/1/azure-rest-api-specs/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json#L12397:8\\\" \\r\\nThis PR is just having typespec conversion change and I am avoiding any change to the swagger file that is generated as part of typespec conversion. In the old swagger there is a Resource definitionwhich is similar Azure resource definition. Should I suppress this check and how to do it?\\n\\n## answer\\n\\nThis occurs because in your original swagger, you did not use swagger common-types. \\r\\nThe 'tags' definitions are compatible, so there is no change in the actual api from this.  This could result in changes in some management sdks, although this change to using the common resource types has generally been accepted. \\r\\ndocs on suppressions for false positives are here: [Suppress validation failures on a PR](https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions) \\r\\nNote that it is important to go through these violations, as the conversion is not guaranteed to be 100% accurate.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Seeking Guidance on Defining ResourceStatusCode in TypeSpec\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Seeking Guidance on Defining ResourceStatusCode in TypeSpec\\n\\n## question\\n\\nHello \\r\\nTypeSpec Discussion\\r\\nI am working on defining a `ResourceStatusCode` in TypeSpec, which is similar to HTTP status codes but specific to resource states. I would appreciate your guidance on the following:\\r\\n1. Should I use an `enum` or a `int` to define the `ResourceStatusCode`?\\r\\n2. What are the best practices for defining status codes in TypeSpec?\\r\\n3. How can I ensure that the `ResourceStatusCode` remains extensible for future updates?\\r\\nI want to add statuses like:\\r\\n- `NotSpecified: 204 No Content` - This indicates that the request was successful, but there is no content to return.\\r\\n- `Pending: 102 Processing` - This indicates that the server has received and is processing the request, but no response is available yet.\\r\\n- `Running: 202 Accepted` - This indicates that the request has been accepted for processing, but the processing has not been completed.\\r\\n- `Succeeded: 200 OK` - This indicates that the request has succeeded.\\r\\n- `Failed: 500 Internal Server Error` - This indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.\\r\\nThank you for your assistance.\\n\\n## answer\\n\\nAs per one of our previous understanding, we defined similarly as an open union: [azure-rest-api-specs-pr/specification/impact/Impact.Management/connectors.tsp at RPSaaSMaster · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/blob/RPSaaSMaster/specification/impact/Impact.Management/connectors.tsp#L88-L94).  \\r\\n```\\r\\n@doc(\\\"Enum for connector types\\\")\\r\\nunion Platform {\\r\\n  string,\\r\\n\\r\\n  @doc(\\\"Type of Azure Monitor\\\")\\r\\n  AzureMonitor: \\\"AzureMonitor\\\",\\r\\n}\\r\\n```\\r\\nThis explicitly allows any string value. \\r\\nGenerally, the reason for doing this is that you think additional values will be enabled in future versions (or even in this version).  Note that, if you do not make this an open union, then adding any values in any future api-version would be a breaking change (which is why this is recommended). \\r\\nThere are RPaaS extensions for validation that would allow you to reject requests for values that are not valid.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Missing APIs in default tag error for typespec conversion PR\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Missing APIs in default tag error for typespec conversion PR\\n\\n## question\\n\\nPR: https://github.com/Azure/azure-rest-api-specs/pull/35346\\r\\nAvocado check: https://github.com/Azure/azure-rest-api-specs/pull/35346/checks?check_run_id=44368323389\\r\\n \\r\\nIs there a way to suppress the missing APIs check only for this PR since it only has typspec conversion but no update to the open API spec?\\r\\nThe check is trying to compare the APIs with previous stable release with currently published stable release.\\n\\n## answer\\n\\nPart of the typespec conversion is replacing the existing swagger with a generated swagger.  The generated swagger is still used for some purposes, and Avocado protects the ability to process it. The generated swagger needs to be equivalent, but not necessarily identical.  Generally these issues reflected in the swagger will also show up in breaking change checks, which will have to be resolved (or suppressed if they are false positives)\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Summarize-Impact.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Summarize-Impact\",\"content\":\"## Troubleshooting details\\n### Suppression change without triggering `Suppression Review Required`\\nIn certain circumstances, devs can can modify the suppressions for a readme, _without_ requiring a suppression review. [This PR](https://github.com/Azure/azure-rest-api-specs/pull/36645/files) is one such example. It is adding two new suppressions to a new API version, but the suppressions themselves _already exist_ for a previous API version. In this case, `summarize impact` _intentionally_ evaluates this PR to not need suppression review. If the RP was approved previously, it should be approved for this new api version as well.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Breaking-Changes.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Breaking-Changes\",\"content\":\"# Table of Contents\\n## How to Suppress the SDK Breaking Changes\\n### Next Steps\\n1. The pull request authors create a file called `sdk-suppressions.yaml` if it doesn't already exist in your service folder in the `azure-rest-api-specs` repository.\\r\\n    - For TypeSpec scenarios, `sdk-suppressions.yaml` should be placed in the root folder of the TypeSpec project, which also contains the `tspconfig.yaml` file. For example, refers to the location for [Contoso.Management](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/Contoso.Management).\\r\\n    - For OpenAPI scenarios, `sdk-suppressions.yaml` should be placed in the `{service}\\\\resource-manager` folder. For example, see the location for the [contosowidgetmanager resource provider](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/resource-manager).\\r\\n\\r\\n2. The pull request authors copy every line under the `Absent SDK breaking changes suppressions` section to the suppression file in the following format:\\r\\n\\r\\n``` yaml\\r\\nsuppressions:\\r\\n  azure-sdk-for-go:\\r\\n    - package: 'sdk/resourcemanager/servicelinker/armservicelinker'\\r\\n      breaking-changes:\\r\\n        - Function `*LinkerClient.BeginCreateOrUpdate` has been removed\\r\\n        - Function `*LinkerClient.NewListPager` has been removed\\r\\n```\\r\\n\\r\\n3. The pull request authors add this suppression file change to your spec pull request. Then the suppressions will be recognized by the bot, and the corresponding suppression label will be added to the spec pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression` will be added to the pull request.\\r\\n\\r\\n4. The SDK reviewers will evaluate the suppressions and either approve them or provide feedback. If the suppressions are approved, the corresponding approval label will be added to the pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression-Approved` will be added to the pull request.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Validation.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation\",\"content\":\"# Validation Rule Suppression\\nYou can suppress specific validation rules within `TypeSpecValidation` by creating or modifying a `suppressions.yaml` file in the root directory of your service specification.\\r\\n\\u003e **Note:** Currently, only the `SdkTspConfigValidation` rule supports suppression.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Requirement.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Requirement\",\"content\":\"# Suppressing Failures\\nIf you need to suppress this check (instead of converting to TypeSpec), add entries to the `suppressions.yaml` for your spec.  Example:\\r\\n\\r\\n```\\r\\n# specification/widget/resource-manager/Microsoft.Widget/Widget/suppressions.yaml\\r\\n- tool: TypeSpecRequirement\\r\\n  paths: \\r\\n    - preview/2022-08-01-preview/**/*.json\\r\\n    - preview/2023-02-01-preview/**/*.json\\r\\n```\\r\\n\\r\\nMore examples: https://github.com/search?q=TypeSpecRequirement+repo%3Aazure%2Fazure-rest-api-specs+path%3A**%2Fsuppressions.yaml\\u0026type=code\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Validation.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation\",\"content\":\"# Validation Rule Suppression\\n## Suppressing SdkTspConfigValidation Rules\\n### Suppress Specific Sub-rules within SdkTspConfigValidation\\nIf you only need to bypass validation for **specific** emitter options or parameters, you can suppress individual sub-rules.\\r\\nAdd or update your `suppressions.yaml` file with the following structure, specifying the sub-rules to ignore:\\r\\nSub-rule Syntax:\\r\\n- For parameters: `parameters.\\u003cparameter-key\\u003e.default`\\r\\n- For emitter options: `options.\\u003cemitter-name\\u003e.\\u003coption-key\\u003e`\\r\\n- For nested options (e.g., `package-details: name: \\\"xxx\\\"`), use dot notation: `options.\\u003cemitter-name\\u003e.package-details.name`\\r\\n```yaml\\r\\n- tool: TypeSpecValidation\\r\\n  paths:\\r\\n    # Specify the path to the tspconfig.yaml file where suppression should apply\\r\\n    - /path/to/tspconfig.yaml\\r\\n  rules:\\r\\n    - SdkTspConfigValidation\\r\\n  sub-rules:\\r\\n    # Example: Suppress validation for a specific parameter's default value\\r\\n    - parameters.\\u003ckey-to-validate\\u003e.default \\r\\n    # Example: Suppress validation for a specific emitter option\\r\\n    - options.\\u003cemitter-name\\u003e.\\u003ckey-to-validate\\u003e\\r\\n    # Example: Suppress validation for a nested emitter option\\r\\n    - options.\\u003cemitter-name\\u003e.package-details.name \\r\\n  reason: the-reason-you-want-to-suppress # Explain why this suppression is necessary\\r\\n```\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Deprecating-Preview-APIs.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs\",\"content\":\"## Process\\n1. Open a PR deleting one (or more) previews.  All of:\\r\\n   1. TypeSpec sources (`*.tsp`)\\r\\n   2. Example sources (examples closest to `*.tsp` files)\\r\\n   3. Generated swaggers and examples (`preview/YYYY-MM-DD-preview/**`)\\r\\n   4. readme.md (remove tags)\\r\\n2. PR should fail check `Swagger BreakingChange`, but pass all other checks.\\r\\n3. Request approval following the normal process for breaking changes\\r\\n   - https://aka.ms/brch\\r\\n   - azbreakchangereview@microsoft.com\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"_Sidebar.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/_Sidebar\",\"content\":\"## Checks\\n* [[SDK Breaking Changes]]\\r\\n* [[SDK Validation]]\\r\\n* [[Summarize Checks]]\\r\\n* [[Summarize Impact]]\\r\\n* [[Swagger Avocado]]\\r\\n* [[Swagger BreakingChanges]]\\r\\n* [[Swagger LintDiff]]\\r\\n* [[TypeSpec Requirement]]\\r\\n* [[TypeSpec Validation]]\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# TypeSpec\\n## `IntegerTypeMustHaveFormat`\\nData-plane specs can suppress violations of this rule, since it only exists for the benefit of SDKs generated from swagger, and data-plane SDKs are generated directly from TypeSpec.  Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\n## MULTIPLE_API_VERSION\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Validation.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation\",\"content\":\"# Validation Rule Suppression\\n## Suppressing SdkTspConfigValidation Rules\\n### Suppress the Entire SdkTspConfigValidation Rule\\nIf you need to skip **all** validation checks for emitter options and parameters within a particular `tspconfig.yaml` file, you can suppress the entire `SdkTspConfigValidation` rule.\\r\\nTo do this, add or update the `suppressions.yaml` file in your service's root folder with the following content:\\r\\n```yaml\\r\\n- tool: TypeSpecValidation\\r\\n  paths:\\r\\n    # Specify the path to the tspconfig.yaml file where suppression should apply\\r\\n    - /path/to/tspconfig.yaml\\r\\n  rules:\\r\\n    - SdkTspConfigValidation\\r\\n  reason: the-reason-you-want-to-suppress # Explain why this suppression is necessary\\r\\n```\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Breaking-Changes.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Breaking-Changes\",\"content\":\"# Table of Contents\\n## How Does the Suppression Work\\nThe suppression file will remain with the specification move with it to other branches or repositories(such as from the private specification repository to the public specification repository). The suppressions can be deleted after the SDK has been released to the public.\"}]",
            "inputs.latency": 212.38344645500183,
            "inputs.response_length": 1790,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep",
                "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions"
            ],
            "inputs.testcase": "Assistance required with breaking change PR",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1384,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1385,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Assistance required with breaking change PR\\\\n\\\\nquestion: Hi team,\\\\nWe have the following open PR: [[Microsoft.Marketplace] - Adding new product fields by eladschartz \\\\u00b7 Pull Request #38748 \\\\u00b7 Azure/az\\\\u2026](https://github.com/Azure/azure-rest-api-specs/pull/38748)\\\\nWhich adds a few missing fields to our returned payload and seems to be marked as a breaking change (violation of rule 1041 - AddedPropertyInResponse). Since we are a REST API only, I'm not sure how counts as a breaking change as it changes nothing about the way existing customers interact with our APIs.\\\\nIs there some way to suppress this rule/ request an exception?\\\", \\\"response\\\": \\\"For Azure REST APIs, adding new properties to response payloads is considered a breaking change per Azure's API versioning and breaking change policies\\\\u2014even if it doesn't impact existing client interactions. The automated check flags this as a violation of rule 1041 (AddedPropertyInResponse) because once an API version is published, any change to the response schema can break strict client contracts or downstream code relying on the original structure.\\\\n\\\\n**Process to request an exception or suppression:**\\\\n- You cannot directly suppress this rule using a configuration or a YAML directive; instead, you must follow the official breaking change review process.\\\\n- If your PR is blocked due to a breaking change, request a review from the Breaking Change Review Board. This is done by following the instructions at [aka.ms/brch](https://aka.ms/brch) and potentially emailing azbreakchangereview@microsoft.com. \\\\n- If the board approves your change (for example, if it is determined to be benign, a bug fix, or required for user impact), they will apply the appropriate approval label (e.g., `BreakingChange-Approved-Benign`, `BreakingChange-Approved-BugFix`, or `BreakingChange-Approved-UserImpact`) to your PR, which will unblock it.\\\\n- Only after this explicit approval can the breaking change be merged.\\\\n\\\\n**Key points:**\\\\n- Do NOT suppress this rule on your own or bypass the review process, as this would violate Azure's published guidelines and could cause downstream compatibility issues.\\\\n- The policy applies regardless of whether you are a REST-only service or provide SDKs; it is enforced for all Azure APIs to maintain customer contract stability.\\\\n\\\\nReference documentation is provided below. For your specific PR, please proceed with the breaking change review process as described.\\\", \\\"ground_truth\\\": \\\"Follow the process documented in the \\\\\\\"next steps to merge\\\\\\\" comment in your PR, to engage with the breaking change reviewers.\\\\nFor your breaking changes, unless your spec has a special exception, I think you might need to move these changes to a new API version.  Existing API versions should generally not be updated like your PR is doing.\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: Quick Check on PR Review Status\n\nquestion: Hi API Spec Review,\nI noticed [this PR](https://github.com/Azure/azure-rest-api-specs/pull/38001) has been waiting for review for a couple of days—which is totally fine—but I just wanted to check in to confirm whether it's showing up as ready for review on your end. The GitHub bot added the `ARMSignedOff` label, but it hasn’t been approved yet, so I’m wondering if it’s currently in the review queue or if there’s anything else needed from our side.\nThanks in advance!",
            "inputs.ground_truth": "Once `ARMSignedOff` label is added (either manually by a reviewer, or automatically by the bot), it's been approved by ARM. You can ask for your team member to approve it. Anyone with write access can do that. To request access, you can follow this: https://eng.ms/docs/products/azure-developer-experience/onboard/access?tabs=write-access\nYou can folllow the `Next Steps to Merge` section on what's next.",
            "inputs.response": "Based on the current Azure REST API Spec PR process, if your PR has the `ARMSignedOff` label, it generally means that the automated ARM review checks have completed and the PR is considered ready for further approval or merging steps. However, the label itself does not equate to final approval; it indicates that the PR passed ARM automated checks and is eligible for sign-off, but may still require manual review or approval by a team member with write access before merging.\n\nYour PR should be visible in the review queue. If it is not yet approved, it is likely awaiting manual review or other required checks (such as team approval or required CI checks). There is no additional action required from your side unless the PR automation or reviewers request changes or further information.\n\nIf you want to confirm the review queue status, you can use the following issue queries to see if your PR is included:\n- https://github.com/Azure/azure-rest-api-specs/issues?q=base%3Amain%20AND%20is%3Apr%20AND%20is%3Aopen%20AND%20(label%3AARMAutoSignedOff%20OR%20(label%3ATypeSpec%20AND%20label%3AARMReview%20AND%20-label%3ANotReadyForARMReview%20AND%20(-label%3ASuppressionReviewRequired%20OR%20label%3AApproved-Suppression)))\n\nIf all required checks are passing and the label is present, your PR should proceed through the remaining approval steps according to the process. No further action is needed from your side unless reviewers request it.\n",
            "inputs.context": "[{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"API-Spec-Review-FAQ.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ\",\"content\":\"# API-Spec-Review-FAQ.md\\n\\nAnswers to frequently asked questions in the [Api Spec Review](https://teams.microsoft.com/l/channel/19%3A0351f5f9404446e4b4fd4eaf2c27448d%40thread.skype/API%20Spec%20Review?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47). Within that channel, EngSys should be answering questions about validation pipelines and tools that run in those pipelines. Specific questions about typespec, the API Review process, etc. should be answered by others who specialize in those topics. \\r\\n\\r\\n| If the question is about | The answer should be | \\r\\n| --- | --- | \\r\\n| Authoring typespec | Send to [TypeSpec Discussions](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) | \\r\\n| My PR is ready to review, will someone review it? | See the \\\"Next steps to merge\\\" comment in your PR and follow directions to ensure you're in the review queue. No need to post here. | \\r\\n| API Doc Preview is broken | If the error message linked doesn't make sense, follow instructions at [Troubleshooting REST API documentation](https://eng.ms/docs/products/azure-developer-experience/design/api-docs-troubleshooting). API Doc Preview is not a required check so you can ignore the failure if it's not relevant to your documentation needs. |\\r\\n| My PR needs to be reviewed by the ARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this.\\n\\nARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this. See documentation: [Update your branch with changes from main](https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish#update-your-branch-with-changes-from-main). |\\r\\n| I need to set up suppressions for LintDiff violations in my PR | See [Adding Scoped Suppressions](https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff) | \\r\\n| I have specific questions about the inner workings of ARM, testing changes to APIs, or rollout/release schedules | Talk to the ARM team: https://aka.ms/armofficehoursinfo |\\r\\n| I see an Avocado error `MULTIPLE_API_VERSION` | There is a coordinated effort to fix this. Reach out to the relevant parties. [This PR](https://github.com/Azure/avocado/pull/157) gives more context on why this was upgraded to an error. If relevant parties agree, the PR can be unblocked by adding the `Approved-Avocado` label to the PR. |\\r\\n| I merged a PR, when does the REST API documentation update on the Learn site? | Docs are published every week on Tuesdays | \\r\\n| If the specs in the standard branches of `RPSaaSMaster` and `RPSaaSDev` are out of sync, who is responsible for syncing them with main? | The spec owner is responsible for syncing their service’s spec files from `main` to `RPSaaSMaster/RPSaaSDev` to ensure consistency across branches. |\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# design#specs-pr-guides#pr-brch-deep.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-brch-deep](https://aka.ms/azsdk/pr-brch-deep) |\\r\\n| --- | --- |\\n\\n# Deep-dive into breaking changes on spec PRs\\n\\n## Important information about this article\\n\\nThis article provides a deep-dive into breaking changes on spec PRs. It applies if your spec PR has\\r\\n`BreakingChangeReviewRequired` or `VersioningReviewRequired` label.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e This is an advanced deep-dive. If your PR is blocked on breaking changes or versioning issues, you should always\\r\\n\\u003e start by following the guidance at [aka.ms/brch].\\n\\n### Prerequisites\\n\\nThis article assumes you are familiar with [API versions and branches](xref:api-versions-and-branches).\\n\\n### Video overview and slides\\n\\nFor video overview of the breaking changes process, see this [Azure Core Day of Learning talk from March 6, 2024].\\r\\nSlides for the talk are available [here][talk slides].\\n\\n### Summary\\n\\nPer the [PR diagram], the first step of getting your specs PR approved is ensuring your PR obeys the  \\r\\n[Azure Versioning and Breaking Changes Policy]. Relevant details of this policy follow.\\r\\n\\r\\n- Once published, no changes to given API version are allowed, except when fixing the spec to match\\r\\nactual implementation (see the `-Approved-BugFix` labels in this doc).\\r\\nThis applies regardless of whether the API version is for `private preview`, `public preview`, or `GA`.\\r\\n- When introducing a new API version (any `preview` or `GA`), the new API version must be backwards compatible with\\r\\nthe previous, latest `GA` API version.\\r\\n- During a (`private` or `public`) `preview` cycle, a new `preview` API version does not have to be backwards\\r\\ncompatible with the previous `preview` API version.\\r\\n- The rules listed above are checked by automated GitHub checks. The exact ruleset is given in [`oadMessagesRuleMap.ts`].\\r\\nDetails follow.\\n\\n## Breaking changes and versioning issues\\n\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\\n\\n### `BreakingChangeReviewRequired` label\\n\\nThe label `BreakingChangeReviewRequired` is added to your PR if the tooling detects a change that could\\r\\nbe breaking for customers. This can happen in two cases:\\r\\n\\r\\n- In your PR you have possibly introduced a breaking change in a new API version, placed in a new folder,\\r\\nas compared to most recent previous `GA`.\\r\\nThe new API version can be either `preview` or `GA`.\\r\\n  - For example, an existing `GA` API version in leaf folder of `2023-11-15`\\r\\nmay contain API route of `GET .../resoruces/{resourceName}`, but a new `preview` API version of `2024-03-15-preview`\\r\\nmay no longer have this route (REST API path), because you are removing the `resoruces` typo and instead introducing\\r\\n`GET .../resources/{resourceName}` route.\\r\\n- In your PR you are modifying existing `GA` API version in-place. For example, you have recently released\\r\\n`2024-03-18` API version and realized you made a typo and are editing the contents of the leaf folder `2024-03-18`\\r\\ncontaining that API version.\\n\\n### `VersioningReviewRequired` label\\n\\nThe label `VersioningReviewRequired` denotes that your PR has a **versioning issue** possibly violating the  \\r\\n[Azure Versioning and Breaking Changes Policy]. This happens when you made a **non-breaking change**,\\r\\naka **compatible change** to an API version that was already published (merged to a production branch).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e According to [the policy][Azure Versioning and Breaking Changes Policy], compatible (non-breaking changes) are not\\r\\n\\u003e allowed within an existing API version. You must create a new API version. Otherwise, we would confuse our customers\\r\\n\\u003e by having to explain \\\"which version of given API version\\\" has a particular change/feature.\\r\\n\\r\\n`VersioningReviewRequired` label is added by automation if:\\r\\n\\r\\n- You made any compatible changes **within** any API version, `GA` or `preview`.\\r\\n- You made any breaking changes in a `preview` API version.\\r\\n\\r\\nIf your PR has both breaking changes and versioning issues, only `BreakingChangeReviewRequired` label\\r\\nis added to it.\\n\\n### In case there is no latest GA API version\\n\\nIf there is no latest GA OpenAPI spec, then the the cross-version check is instead comparing to\\r\\nlatest available preview if it more than 1 year old.\\r\\n\\r\\nIf neither a GA API version or at least 1 year old preview version exists, then the cross-version check automatically\\r\\npasses.\\n\\n### Diagram explaining breaking changes and versioning issues\\n\\nThe logic for automation adding `BreakingChangeReviewRequired` and `VersioningReviewRequired` labels explained above\\r\\ncan be summarized in the following diagram:\\r\\n\\r\\n![Breaking Changes Confusion Matrix](../../img/breaking_changes_confusion_matrix.png)\\n\\n## Addressing `BreakingChangeReviewRequired`\\n\\nIf your PR is labelled with `BreakingChangeReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the breaking changes in your PR are acceptable, they will be\\r\\napproved by one of these labels:\\n\\n### `BreakingChange-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `BreakingChange-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-UserImpact`\\n\\n- The spec PR describes actual breaking changes to the service.\\r\\n- This is the only case that triggers customer notifications, a 3 year migration period (possibly shorter), etc.\\r\\n- Within this set, the changes may be distinguished further for security or legal compliance, which may be granted\\r\\na shorter migration period.\\r\\n- Details at [aka.ms/brch].\\n\\n### `BreakingChange-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Addressing `VersioningReviewRequired`\\n\\nIf your PR is labelled with `VersioningReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the versioning issue in your PR caused by non-breaking (compatible)\\r\\nchanges is acceptable, the board will approve it by one of these labels:\\n\\n### `Versioning-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `Versioning-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-PrivatePreview`\\n\\nThe API version change that triggered the review is in `private preview`, and non-breaking changes are permitted\\r\\nin the same API version during `private preview`.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-PrivatePreview` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Common misconceptions\\n\\n### FALSE: compatible (non-breaking) changes are allowed in published API versions\\n\\n**Why?**\\r\\n\\r\\nAn API version is a contract, and once the contract is published it cannot be changed.\\r\\nOtherwise, it would create customer confusion about \\\"which version of this API version\\\" are they using.\\r\\n\\r\\nAny change of this kind w\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-arm-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-arm-review\",\"content\":\"# design#specs-pr-guides#pr-arm-review.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-arm-review](https://aka.ms/azsdk/pr-arm-review) |\\r\\n|--|--|\\n\\n# Get your PR reviewed by ARM\\n\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nIf your Azure REST API specs PR pertains to ARM (see [glossary](xref:glossary#arm)) specs,\\r\\nthen the second step of the PR approval process per the [PR workflow diagram] (https://aka.ms/azsdk/pr-diagram)\\r\\nis the ARM review. The overall PR approval process is explained at https://aka.ms/azsdk/specreview/merge.\\r\\n\\r\\nIf your PR does not pertain to ARM specs, then this article won't be relevant to you.\\r\\nSee instead [`Getting help` section] on your PR (https://aka.ms/azsdk/pr-getting-help).\\n\\n## Review process\\n\\n- If your PR is in purview of ARM review then the automation will add the `ARMReview` label.\\r\\n- Your PR will start the ARM Review process. Your PR could be automatically reviewed or added to a review queue. \\r\\nRefer to the wiki [API Review wiki](https://eng.ms/docs/products/arm/rp_onboarding/process/api_review) for more\\r\\ninformation on the selection criteria.\\n\\n### About the ARM review queue\\n\\nThe PRs on the [ARM review queue] are processed by time opened, ascending.\\r\\n\\r\\nYour PR may show up on 2nd or later page on the GitHub web UI, so ensure to check these pages too.\\r\\n\\r\\nIf you addressed step 1 from [the diagram][PR workflow diagram] (breaking changes review) and your PR is not showing up\\r\\nin the queue, ensure the label `ARMChangesRequested` is removed from your PR.\\r\\nThis should cause the label `WaitForARMFeedback` to be added.\\r\\n\\r\\nThe ARM review queue is processed by the ARM reviewer on-call, per [IcM].\\r\\n\\r\\nThe ARM reviewer reviews approximately 10 PRs in a business day. This could vary based on the complexity of the PRs\\r\\nat any given time in the review queue. The ETA for a review therefore is approximately equal to\\r\\n`((The position of your PR in the review queue) / 10)(int) + 1` business days.\\r\\n\\r\\nFor example: if the position of your PR in the review queue is `12`, then the approximate ETA is:\\r\\n`12/10 + 1 = 1 + 1 = 2` business days.\\n\\n## Getting help for your ARM review\\n\\n\\u003e [!IMPORTANT]\\r\\n\\u003e If your PR has breaking changes you must solve them before asking the on-call ARM reviewer for help.\\r\\n\\r\\nIf you need help from the ARM reviewer, book the **ARM API Review Office Hours** per https://aka.ms/armofficehoursinfo.\\r\\n\\r\\nFor help with other topics, please use the prescribed methods mentioned in the [PR workflow diagram] and your\\r\\nPR description [`Getting help` section].\\r\\n\\r\\n[PR workflow diagram]: https://aka.ms/azsdk/pr-diagram\\r\\n[ARM review queue]: https://github.com/search?q=org%3AAzure+is%3Apr+is%3Aopen+label%3AWaitForARMFeedback+-label%3AIDCDevDiv++draft%3Afalse+sort%3Acreated-asc+\\u0026type=pullrequests\\r\\n[IcM]: https://portal.microsofticm.com/imp/v3/oncall/current?serviceId=20371\\u0026teamIds=51358\\u0026scheduleType=timeline\\u0026shiftType=current\\u0026viewType=1\\r\\n[`Getting help` section]: https://aka.ms/azsdk/pr-getting-help\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"ARM-Auto-SignOff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/ARM-Auto-SignOff\",\"content\":\"# ARM-Auto-SignOff.md\\n\\n## Remaining Work\\n\\n- [ARM Auto SignOff] Update for GA: https://github.com/Azure/azure-rest-api-specs/pull/33440\\n\\n## Test PRs\\n\\n- RM TSP: https://github.com/Azure/azure-rest-api-specs/pull/32545\\r\\n- DP TSP: https://github.com/Azure/azure-rest-api-specs/pull/32694\\n\\n## Issue Queries\\n\\n```\\r\\nbase:main AND\\r\\nis:pr AND\\r\\nis:open AND\\r\\n(label:ARMAutoSignedOff OR\\r\\n (label:TypeSpec AND\\r\\n  label:ARMReview AND\\r\\n  -label:NotReadyForARMReview AND\\r\\n  (-label:SuppressionReviewRequired OR\\r\\n   label:Approved-Suppression)))\\r\\n```\\r\\nhttps://github.com/Azure/azure-rest-api-specs/issues?q=base%3Amain%20AND%20is%3Apr%20AND%20is%3Aopen%20AND%20(label%3AARMAutoSignedOff%20OR%20(label%3ATypeSpec%20AND%20label%3AARMReview%20AND%20-label%3ANotReadyForARMReview%20AND%20(-label%3ASuppressionReviewRequired%20OR%20label%3AApproved-Suppression)))\\r\\n\\r\\nhttps://github.com/Azure/azure-rest-api-specs-pr/issues?q=base%3Amain%20AND%20is%3Apr%20AND%20is%3Aopen%20AND%20(label%3AARMAutoSignedOff%20OR%20(label%3ATypeSpec%20AND%20label%3AARMReview%20AND%20-label%3ANotReadyForARMReview%20AND%20(-label%3ASuppressionReviewRequired%20OR%20label%3AApproved-Suppression)))\\n\\n## Source Code\\n\\n* ARM Incremental TypeSpec\\r\\n  * Determines if PR contains only incremental changes to an existing TypeSpec RP\\r\\n  * https://github.com/Azure/azure-rest-api-specs/blob/main/.github/workflows/arm-incremental-typespec.yaml\\r\\n* ARM Auto SignOff\\r\\n  * Combines results of \\\"ARM Incremental TypeSpec\\\", labels, and checks to determine if PR is eligible for auto sign-off\\r\\n  * https://github.com/Azure/azure-rest-api-specs/blob/main/.github/workflows/arm-auto-signoff.yaml\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-review\",\"content\":\"# design#api-review.md\\n\\n| Short Link: | [azsdk/onboarding/restapischedule](https://aka.ms/azsdk/onboarding/restapischedule) |\\r\\n| --- | --- |\\n\\n# Schedule a data plane REST API spec review\\n\\n## Purpose\\n\\nA data plane REST API review is designed to help you create developer-friendly and consistent REST (data plane) APIs\\r\\nfor your service. All Azure REST APIs need to be reviewed and approved prior to publication.\\n\\n## Before you begin\\n\\n\\u003e [!NOTE]\\r\\n\\u003e For management plane (ARM-based) APIs, you need to create a pull request (PR) in the [Azure REST API specification repositories](xref:api-repos).\\r\\n\\u003e Such PR is a part of the [release plan](xref:release-plan). The ARM review will happen during the [PR process](xref:api-specs-pr).\\r\\n\\r\\nEnsure that:\\r\\n\\r\\n- You have [access](xref:access) to the GitHub repositories and respective Azure open source organization.\\n\\n## Prepare for API review\\n\\nWhen you have your REST API definition ready for review, [create a pull request with your Azure REST API spec update](xref:api-specs-pr).\\r\\n\\r\\nYou should prepare and be ready to present the following information during your review:\\r\\n\\r\\n| Title | Importance | Brief description | Example and support documentation |\\r\\n| --- | --- | --- | --- |\\r\\n\\r\\nAPI spec PR link | Must Have | PR with your API spec definition against [azure/azure-rest-api-specs-pr](https://github.com/azure/azure-rest-api-specs-pr) or [azure/azure-rest-api-specs](https://github.com/azure/azure-rest-api-specs) | In order to access the PR, it may be necessary to join the [Azure GitHub organization](https://repos.opensource.microsoft.com/orgs/Azure). \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to https://repos.opensource.microsoft.com/orgs/Azure\\u003c/li\\u003e\\u003cli\\u003eClick **Join Organization**.\\u003c/li\\u003e\\u003c/ol\\u003e\\u003cp\\u003e\\u003cp\\u003eThe PR should be linked to the issue no less than 2 days before your meeting. To properly link your PR, in the issue click on the settings icon next to `Development` on the right side:\\u003cp\\u003e\\u003cp\\u003e![Screenshot](../img/link-pr.png)  |\\r\\nAPI spec PR CI checks | Important |Make sure all CI is passing before requesting a review. | [ci-fix](https://aka.ms/ci-fix) |\\r\\nCore concepts | Must have | A glossary of nouns and verbs  | [Example](https://github.com/Azure/azure-sdk-pr/blob/main/onboarding/Core_Concepts.pdf)\\r\\nAPI reference docs | Good to have | Your API documentation consists of two parts, the API spec document (TypeSpec/OpenAPI spec), and the generated developer docs. These docs are often the first experience a developer will have with your service. Make a good first impression!!| **Recommended for OpenAPI spec**: [VS Code extension](https://marketplace.visualstudio.com/items?itemName=42Crunch.vscode-openapi) load this extension and then open your OpenAPI spec file in VS Code and select **Preview**. \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to your PR and look for the comment added by the `openapi-pipeline-app bot` and title `Swagger Generation Artifacts`.\\n\\ngenerated developer docs. These docs are often the first experience a developer will have with your service. Make a good first impression!!| **Recommended for OpenAPI spec**: [VS Code extension](https://marketplace.visualstudio.com/items?itemName=42Crunch.vscode-openapi) load this extension and then open your OpenAPI spec file in VS Code and select **Preview**. \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to your PR and look for the comment added by the `openapi-pipeline-app bot` and title `Swagger Generation Artifacts`. In the comment posted by the bot, you will find a link to your generated documentation under `ApiDocPreview`.\\u003c/li\\u003e\\u003cli\\u003eExpand `Detail` and look for `Click here to preview`.\\u003c/li\\u003e\\u003cli\\u003eReview your docs! Ensure that `Summary` and `Description` fields are accurate and complete.\\u003c/li\\u003e\\u003c/ol\\u003e|\\r\\nHero scenarios | Good to have | Top scenarios on how service is consumed. | [Guidelines on how to identify hero scenarios](https://github.com/Azure/azure-sdk-pr/blob/main/training/azure-sdk-apis/principles/approachable/README.md#hero-scenarios)\\u003cp\\u003e\\u003cp\\u003e [Examples](https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/appconfiguration/Azure.Data.AppConfiguration#examples)\\r\\nReview [API style guidelines](https://aka.ms/azapi/style) | Good to do | Review to learn about the Spectral linting tool that can be used inside of VS Code. Running this tool will help you identify and address many of the common issues and greatly improve your OpenAPI spec. | [API style guidelines](https://aka.ms/azapi/style)|\\n\\n### Join the REST API Stewardship Teams channel\\n\\nThe meeting chat is mirrored in the [General channel](https://teams.microsoft.com/l/channel/19%3a3ebb18fded0e47938f998e196a52952f%40thread.tacv2/General?groupId=1a10b50c-e870-4fe0-8483-bf5542a8d2d8\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\\r\\nof the [API Stewardship Team room](https://teams.microsoft.com/l/team/19%3a3ebb18fded0e47938f998e196a52952f%40thread.tacv2/conversations?groupId=1a10b50c-e870-4fe0-8483-bf5542a8d2d8\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\\r\\n\\r\\nTo participate in the chat:\\r\\n\\r\\n1. Go to [Discover Teams](https://teams.microsoft.com/_#/discover)\\r\\n2. Enter the code `uprrab9` to join the team.\\n\\n### Review our style guide\\n\\nReview the [API style guidelines](https://aka.ms/azapi/style) to learn about the Spectral linting tool that can be used\\r\\ninside of VS Code. Running this tool will help you identify and address many of the common issues and greatly improve\\r\\nyour OpenAPI spec.\\n\\n## Schedule a meeting\\n\\nOne of the tasks of your release plan is to **Schedule REST API review meeting** with the Azure REST API Stewardship board.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e Reviews must be scheduled ideally at least two days in advance to give the team time to prepare.\\r\\n\\u003e \\u003e\\r\\n\\u003e For small changes, consider asking for an offline review. See the\\r\\n\\u003e [Requesting an offline REST API review](#requesting-an-offline-rest-api-review) section below.\\r\\n\\r\\n1. Log in to [Azure SDK Release Planner](https://aka.ms/azsdk/sdk-release-planner).\\r\\n2. Choose the top-level service that your product is associated with.\\r\\n3. Click **Your release plans** and select the release plan you are interested in.\\r\\n4. The **Summary** view will provide information about where you are in the process and who the contacts are.\\r\\n5. Click on **Milestones** and select **Data-plane API Readiness**. This will open the app with the specific task to\\r\\naccomplish before you schedule the meeting.\\r\\n6. The **Schedule a REST API review** task contains the information to schedule the meeting with the  \\r\\n[Azure SDK Scheduler](https://aka.ms/azsdk/scheduleapi) app.\\r\\n7. Once in the scheduler app click **Create new**.\\r\\n8. Choose a meeting slot and select meeting attendees.\\r\\nIn the **Meeting attendees** field, be sure to include the Cloud Product Excellence (CPEX) PM or owner who is\\r\\nresponsible for updating your product in Cloud Lifecycle, as well as any engineering team members that will be\\r\\ngenerating or updating SDKs.\\r\\n9. Indicate whether your REST API changes will be public or private.\\r\\n10. Provide a link to the REST API specs pull request that contains your latest changes.\\r\\n11. Provide links to your [hero scenarios](xref:api-design#start-with-hero-scenarios) and [core concepts](xref:api-design#define-terms-and-concepts).\\r\\nThese fields will be auto populated if you have provided these documents when you [onboarded to the Azure SDK team](xref:onboard).\\n\\n## Requesting an offline REST API review\\n\\nFor small changes, consider asking for an offline review. This may be a better use of your time and leave the meeting\\r\\ntime for teams with larger changes - especially important prior to large customer engagements like Build or Ignite.\\n\\n### When offline reviews are appropriate\\n\\nAn offline review is appropriate when the following conditions hold:\\r\\n\\r\\n- The prior API version was reviewed and approved by the API Stewardship board.\\r\\n- The new API version makes only minor changes to the prior API version, such as\\r\\n  - Fields added to an API response\\r\\n  - Optional parameters or fields added to a request\\r\\n- The PR for the new API version is passing all PR pipeline checks.\\r\\n- The TypeSpec and OpenAPI APIViews for the PR were successfully generated and clearly show\\r\\nthe changes without extra \\\"noise\\\".\\n\\n### How to request an offline review\\n\\nThe service team should schedule a review meeting using the scheduling tool for the next available open review slot.\\r\\nThis will create an API review issue that will record the progress / status of the API review.\\r\\n\\r\\nMake sure that the API review issue contains:\\r\\n\\r\\n- A link to the PR for the new API version\\r\\n- Links to design docs / hero scenarios (even if these are unchanged)\\r\\n\\r\\nThen the service team should post a comment in the API review issue with the following information:\\r\\n\\r\\n- A link to the API review issue for the prior API version\\r\\n- A description of the changes being made in the new API version\\r\\n\\r\\nThen send a e-mail to the Azure review board core e-mail alias\\r\\n[azureapirbcore@microsoft.com](mailto:azureapirbcore@microsoft.com) including the link to the review issue and\\r\\nrequesting an offline review.\\r\\n\\r\\nAdd the `offline-review-requested` label to the PR to make it easier for API reviewers to search for PRs to\\r\\nbe reviewed offline.\\n\\n### Conducting the offline review\\n\\nUpon receiving the email requesting offline review, API Stewardship board members may review the PR and leave comments.\\r\\nThe service team may use the Teams chat for the meeting to communicate with the review board\\r\\nto recruit reviewers or answer questions.\\r\\n\\r\\nWhen an API Steward has reviewed the PR and has no concerns they submit an \\\"Approved\\\" review.\\r\\nWhen at least two API stewards have approved and none have requested changes, any member of the Stewardship board\\r\\ncan add the \\\"signedOff\\\" label and the review is complete.\\n\\n### Following a completed offline review\\n\\nOnce the PR has received sign off, the service team should cancel the review meeting\\r\\nto free up the slot for another team.\\r\\n\\r\\nThe signedOff label will unblock merge for the PR, but merging should be done only when the API version is ready\\r\\nto be released to customers.\\n\\n## What happens during the review\\n\\n\\u003e [!NOTE]\\r\\n\\u003e The m\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# design#api-specs-pr#api-specs-pr.md\\n\\n| Short Link: | [aka.ms/azsdk/specreview](https://aka.ms/azsdk/specreview) |\\r\\n|--|--|\\n\\n# Create a pull request with your Azure REST API spec update\\n\\nThis article explains how to create a pull request (PR) in the [Azure REST API specification repositories](xref:api-repos).\\r\\nSuch PR is a part of the [release plan](xref:release-plan).\\n\\n## Before you begin\\n\\nEnsure that:\\r\\n\\r\\n- You have onboarded to Azure SDK team processes by following our [onboarding process](xref:onboard).\\r\\n- You have [access](xref:access) to the GitHub repositories and respective Azure open source organization.\\r\\n- You understand the conventions for the [Azure REST API specs GitHub repositories](xref:api-repos).\\r\\n- You have reviewed and validated your REST API spec updates within your team, using a development branch in one of\\r\\n  the specs repos.\\r\\n- You are ready to release the features described in your REST API spec updates in a private preview, public preview,\\r\\n  or GA release.\\r\\n\\r\\n\\u003e[!TIP]\\r\\n\\u003e We are piloting our new AzSDK tools MCP server which includes the ability to generate the SDKs and\\r\\n\\u003e create a draft pull request in the respective language repository. Refer to [AzSDK tools MCP server](xref:azsdk-tools-mcp)\\r\\n\\u003e for instructions on how to install it and use it.\\n\\n## Create a PR against a specs repo\\n\\n\\u003e [!TIP]\\r\\n\\u003e If you have an existing PR in the private repo and you want to move it to the public repo, refer to [this guide](xref:pr-move-private-to-public).\\r\\n\\r\\nWhen you are ready to submit your REST API spec updates for review, you must create a pull request (PR) in either the  \\r\\n[public or private specs repository](xref:api-repos). When creating the PR, you should select either the\\r\\n**Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API spec updates you are\\r\\nsubmitting.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e The PR template and comments added by the PR automation will guide you through the process of getting your PR reviewed,\\r\\napproved, and merged.\\n\\n## Get your PR merged\\n\\n| Short Link: | [aka.ms/azsdk/specreview/merge](https://aka.ms/azsdk/specreview/merge) |\\r\\n|-|-|\\r\\n\\r\\nTo get your PR merged:\\r\\n\\r\\n1. Ensure the `Next Steps to Merge` comment and `Automated merging requirements met` check are green. \\r\\n1. Ensure at least one person has approved your PR. Generally another person from your team that has [write access] to the repo.\\r\\n1. Ensure all required checks are passing and at least investigate to understand any other non-required checks that may be failing. \\r\\n1. Once all required checks are green and any other issues understood you can merge the PR yourself as long as you have [write access] to the repo.\\r\\n1. If your PR is targeting public `main` you will need to first apply the `PublishToCustomers` label to acknowledge you understand this \\r\\n   will cause your spec to be published so customers can consume it.\\r\\n1. If your PR is targeting private repo `main` branch, it **cannot** be merged.\\r\\n   Instead, you can publish your changes to customers by following the guide at [aka.ms/azsdk/move-pr].\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_10.md\",\"document_title\":\"Service under conversation label\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_10.md\\n\\n# Service under conversation label\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\nMy team currently has a PR open to release a new stable API. However, due to backend delays, it’s been open since July. During that time, the [typespec migration PR](https://github.com/Azure/azure-rest-api-specs/pull/36556) was drafted against our preview API. Now, the service-under-conversion label has been added to our stable PR. I’d like to understand does this label indicate a delay in merging in our [stable api PR](https://github.com/Azure/azure-rest-api-specs/pull/36219), or will we need to make additional changes?\\n\\n## answer\\n\\nThe label should not impact your previous PR, and , if this is a later api-version thatn the conversion PR, the conversion would normally be based on that version once checked in.  Adding Janine Zhang for awareness about the conversion.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure REST API, SDK development process with TypeSpec\\n## Table Of Content\\n### 4. Prepare and submit a Pull Request for reviewing\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\r\\n   - send a pull request to the original repo from your forked repo.\\r\\n   See the ARM Wiki for information on the [supported repos and branches for management-plane services](https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches).\\r\\n#### 4.1 Fix the errors of PR reviewing CI checks\\r\\nThe CI checks result will be commented on the PR. you can refer to the [CI fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\\r\\nNote:\\r\\nSince the OpenAPI is generated from TypeSpec, to change the OpenAPI, you must update the TypeSpec file and regenerate the\\r\\n OpenAPI and avoid updating OpenAPI directly to keep the consistency between OpenAPI and TypeSpec.\\r\\nFor support \\u0026 help, you can post a message to [TypeSpec Discussion - teams channel](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"PR-Check-Modernization.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/PR-Check-Modernization\",\"content\":\"Moved to https://github.com/Azure/azure-rest-api-specs/issues/32396\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Future Plans\\n* Move code for check and package to specs repo (https://github.com/Azure/azure-rest-api-specs/issues/32398)\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Deprecating-Preview-APIs.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs\",\"content\":\"Spec owners are encouraged to remove old preview API versions from the specs repo, once they are retired from the service.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-repos.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-repos\",\"content\":\"# Azure REST API specs repositories on GitHub\\nThe REST API descriptions for all Azure services should be published in the Azure REST API specs GitHub repositories.\\r\\n\\r\\nThe [Azure/azure-rest-api-specs] is the public repository. All work done in this repository is public, i.e. visible to\\r\\neveryone, including people outside of Microsoft. Any Azure REST API specification updates must be merged to the `main`\\r\\nbranch as part of the process of releasing those updates to Microsoft customers.\\r\\n\\r\\nThe [Azure/azure-rest-api-specs-pr] is the private repository (the \\\"pr\\\" stands for \\\"private\\\"). It is for work that must\\r\\nremain private until it is ready to be published. For example, if your team is working on a new product with a new Azure\\r\\nResource Manager (ARM) or Resource Provider (RP) namespace, you want to keep developing it in the private repository\\r\\nuntil you have drafted, tested and went through the API review process. Only after this is done, you must merge your\\r\\nchanges to the `main` branch in the public repository.\\r\\n\\r\\nThe `main` branch in the private repository is read-only, as it is mirrored from the public repository `main` branch.\"}]",
            "inputs.latency": 260.6557023525238,
            "inputs.response_length": 1442,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/ARM-Auto-SignOff",
                "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-arm-review",
                "https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr"
            ],
            "inputs.testcase": "Quick Check on PR Review Status",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1372,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1373,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Quick Check on PR Review Status\\\\n\\\\nquestion: Hi API Spec Review,\\\\nI noticed [this PR](https://github.com/Azure/azure-rest-api-specs/pull/38001) has been waiting for review for a couple of days\\\\u2014which is totally fine\\\\u2014but I just wanted to check in to confirm whether it's showing up as ready for review on your end. The GitHub bot added the `ARMSignedOff` label, but it hasn\\\\u2019t been approved yet, so I\\\\u2019m wondering if it\\\\u2019s currently in the review queue or if there\\\\u2019s anything else needed from our side.\\\\nThanks in advance!\\\", \\\"response\\\": \\\"Based on the current Azure REST API Spec PR process, if your PR has the `ARMSignedOff` label, it generally means that the automated ARM review checks have completed and the PR is considered ready for further approval or merging steps. However, the label itself does not equate to final approval; it indicates that the PR passed ARM automated checks and is eligible for sign-off, but may still require manual review or approval by a team member with write access before merging.\\\\n\\\\nYour PR should be visible in the review queue. If it is not yet approved, it is likely awaiting manual review or other required checks (such as team approval or required CI checks). There is no additional action required from your side unless the PR automation or reviewers request changes or further information.\\\\n\\\\nIf you want to confirm the review queue status, you can use the following issue queries to see if your PR is included:\\\\n- https://github.com/Azure/azure-rest-api-specs/issues?q=base%3Amain%20AND%20is%3Apr%20AND%20is%3Aopen%20AND%20(label%3AARMAutoSignedOff%20OR%20(label%3ATypeSpec%20AND%20label%3AARMReview%20AND%20-label%3ANotReadyForARMReview%20AND%20(-label%3ASuppressionReviewRequired%20OR%20label%3AApproved-Suppression)))\\\\n\\\\nIf all required checks are passing and the label is present, your PR should proceed through the remaining approval steps according to the process. No further action is needed from your side unless reviewers request it.\\\\n\\\", \\\"ground_truth\\\": \\\"Once `ARMSignedOff` label is added (either manually by a reviewer, or automatically by the bot), it's been approved by ARM. You can ask for your team member to approve it. Anyone with write access can do that. To request access, you can follow this: https://eng.ms/docs/products/azure-developer-experience/onboard/access?tabs=write-access\\\\nYou can folllow the `Next Steps to Merge` section on what's next.\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: Licence agreement\n\nquestion: Hi,\n[Added Mongo Types by sougho · Pull Request #23842 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23842)\nWe have a PR which has all pipelines passing except the license agreement.\nIt looks like only author's license agreement comment will be considered by the automated pipeline.\nCan someone help to resolve this? author of this PR won't be available for a while and i have taken over this PR now",
            "inputs.ground_truth": "If the PR author is no longer available to agree to the `license/cla`, you will need to open a new PR from a user who can agree.",
            "inputs.response": "Based strictly on the provided knowledge context, there is no TypeSpec-specific or general Azure REST API specs process that allows another contributor or maintainer to sign the Contributor License Agreement (CLA) or override the license/cla check on behalf of the original author. The license/cla check is marked as 'Not possible' to suppress or bypass, and only the original author can resolve it by signing the agreement themselves. If the author is unavailable, the only compliant path is to either wait for the original author to sign the CLA or create a new PR under your own account, reapplying the same changes. This ensures that all contributions are covered by a valid CLA for each contributor, per Microsoft open source contribution policies.\n\nIf you create a new PR, you will need to ensure that you have signed the CLA and that all commits are attributed to you or contributors who have signed the CLA. There is no documented maintainer override, re-run, or reassignment process for the license/cla check in the official guidance.\n\nFor further information, please refer to the Azure REST API specs PR guides or the official documentation links below.",
            "inputs.context": "[{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#Guidelines.md\",\"document_title\":\"Microsoft Azure REST API Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md\",\"content\":\"# azure#Guidelines.md\\n\\n# Microsoft Azure REST API Guidelines\\n\\n\\u003c!-- cspell:ignore autorest, BYOS, etag, idempotency, maxpagesize, innererror, trippable, nextlink, condreq, etags --\\u003e\\r\\n\\u003c!-- markdownlint-disable MD033 MD049 MD055 --\\u003e\\r\\n\\r\\n\\u003c!--\\r\\nNote to contributors: All guidelines now have an anchor tag to allow cross-referencing from associated tooling.\\r\\nThe anchor tags within a section using a common prefix to ensure uniqueness with anchor tags in other sections.\\r\\nPlease ensure that you add an anchor tag to any new guidelines that you add and maintain the naming convention.\\r\\n--\\u003e\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2025-Mar-28 | Added guidelines about JSON ID and null values                 |\\r\\n| 2024-Mar-17 | Updated LRO guidelines                                         |\\r\\n| 2024-Jan-17 | Added guidelines on returning string offsets \\u0026 lengths         |\\r\\n| 2023-May-12 | Explain service response for missing/unsupported `api-version` |\\r\\n| 2023-Apr-21 | Update/clarify guidelines on POST method repeatability         |\\r\\n| 2023-Apr-07 | Update/clarify guidelines on polymorphism                      |\\r\\n| 2022-Sep-07 | Updated URL guidelines for DNS Done Right                      |\\r\\n| 2022-Jul-15 | Update guidance on long-running operations                     |\\r\\n| 2022-May-11 | Drop guidance on version discovery                             |\\r\\n| 2022-Mar-29 | Add guidelines about using durations                           |\\r\\n| 2022-Mar-25 | Update guideline for date values in headers to follow RFC 7231 |\\r\\n| 2022-Feb-01 | Updated error guidance                                         |\\r\\n| 2021-Sep-11 | Add long-running operations guidance                           |\\r\\n| 2021-Aug-06 | Updated Azure REST Guidelines per Azure API Stewardship Board. |\\r\\n| 2020-Jul-31 | Added service advice for initial versions                      |\\r\\n| 2020-Mar-31 | 1st public release of the Azure REST API Guidelines            |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Introduction\\n\\nThese guidelines apply to Azure service teams implementing _data plane_ APIs. They offer prescriptive guidance that Azure service teams MUST follow ensuring that customers have a great experience by designing APIs meeting these goals:\\r\\n- Developer friendly via consistent patterns \\u0026 web standards (HTTP, REST, JSON)\\r\\n- Efficient \\u0026 cost-effective\\r\\n- Work well with SDKs in many programming languages\\r\\n- Customers can create fault-tolerant apps by supporting retries/idempotency/optimistic concurrency\\r\\n- Sustainable \\u0026 versionable via clear API contracts with 2 requirements:\\r\\n  1. Customer workloads must never break due to a service change\\r\\n  2. Customers can adopt a version without requiring code changes\\r\\n\\r\\nTechnology and software is constantly changing and evolving, and as such, this is intended to be a living document. [Open an issue](https://github.com/microsoft/api-guidelines/issues/new/choose) to suggest a change or propose a new idea. Please read the [Considerations for Service Design](./ConsiderationsForServiceDesign.md) for an introduction to the topic of API design for Azure services. *For an existing GA'd service, don't change/break its existing API; instead, leverage these concepts for future APIs while prioritizing consistency within your existing service.*\\r\\n\\r\\n*Note: If you are creating a management plane (ARM) API, please refer to the [Azure Resource Manager Resource Provider Contract](https://github.com/cloud-and-ai-microsoft/resource-provider-contract).*\\n\\n### Prescriptive Guidance\\n\\nThis document offers prescriptive guidance labeled as follows:\\r\\n\\r\\n:white_check_mark: **DO** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n:ballot_box_with_check: **YOU SHOULD** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:heavy_check_mark: **YOU MAY** consider this pattern if appropriate to your situation. No notification to the Azure HTTP/REST Stewardship Board is required.\\r\\n\\r\\n:warning: **YOU SHOULD NOT** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:no_entry: **DO NOT** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n*If you feel you need an exception, or need clarity based on your situation, please contact the Azure HTTP/REST Stewardship Board **prior** to release of your API.*\\n\\n## Building Blocks: HTTP, REST, \\u0026 JSON\\n\\nThe Microsoft Azure Cloud platform exposes its APIs through the core building blocks of the Internet; namely HTTP, REST, and JSON. This section provides you with a general understanding of how these technologies should be applied when creating your service.\\r\\n\\r\\n\\u003ca href=\\\"#http\\\" name=\\\"http\\\"\\u003e\\u003c/a\\u003e\\n\\n### HTTP\\n\\ncase-sensitive, multiple delimiter\\r\\nUUID      | 123e4567-e89b-12d3-a456-426614174000 (no {}s, hyphens, case-insensitive) [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)\\r\\nDate/Time (Header) | Sun, 06 Nov 1994 08:49:37 GMT [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1)\\r\\nDate/Time (Query parameter) | YYYY-MM-DDTHH:mm:ss.sssZ (with at most 3 digits of fractional seconds) [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)\\r\\nByte array | Base-64 encoded, max length\\r\\nArray      | One of a) a comma-separated list of values (preferred), or b) separate `name=value` parameter instances for each value of the array\\r\\n\\r\\n\\r\\nThe table below lists the headers most used by Azure services:\\r\\n\\r\\nHeader Key          | Applies to | Example\\r\\n------------------- | ---------- | -------------\\r\\n_authorization_     | Request    | Bearer eyJ0...Xd6j (Support Azure Active Directory)\\r\\n_x-ms-useragent_    | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntraceparent         | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntracecontext        | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\naccept              | Request    | application/json\\r\\nIf-Match            | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-None-Match       | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-Modified-Since   | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\nIf-Unmodified-Since | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\ndate                | Both       | Sun, 06 Nov 1994 08:49:37 GMT (see [RFC 7231, Section 7.1.1.2](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2))\\r\\n_content-type_      | Both       | application/merge-patch+json\\n\\nname=\\\"http-header-names-casing\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** specify headers using kebab-casing\\r\\n\\r\\n\\u003ca href=\\\"#http-header-names-case-sensitivity\\\" name=\\\"http-header-names-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header names using case-insensitivity\\r\\n\\r\\n\\u003ca href=\\\"#http-header-values-case-sensitivity\\\" name=\\\"http-header-values-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header values using case-sensitivity if the header name requires it\\r\\n\\r\\n\\u003ca href=\\\"#http-header-date-values\\\" name=\\\"http-header-date-values\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** accept date values in headers in HTTP-Date format and return date values in headers in the IMF-fixdate format as defined in [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1), e.g. \\\"Sun, 06 Nov 1994 08:49:37 GMT\\\".\\r\\n\\r\\nNote: The RFC 7231 IMF-fixdate format is a \\\"fixed-length and single-zone subset\\\" of the RFC 1123 / RFC 5822 format, which means: a) year must be four digits, b) the seconds component of time is required, and c) the timezone must be GMT.\\r\\n\\r\\n\\u003ca href=\\\"#http-header-request-id\\\" name=\\\"http-header-request-id\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** create an opaque value that uniquely identifies the request and return this value in the `x-ms-request-id` response header.\\r\\n\\r\\nYour service should include the `x-ms-request-id` value in error logs so that users can submit support requests for specific failures using this value.\\r\\n\\r\\n\\u003ca href=\\\"#http-allow-unrecognized-headers\\\" name=\\\"http-allow-unrecognized-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** fail a request that contains an unrecognized header. Headers may be added by API gateways or middleware and this must be tolerated\\r\\n\\r\\n\\u003ca href=\\\"#http-no-x-custom-headers\\\" name=\\\"http-no-x-custom-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** use \\\"x-\\\" prefix for custom headers, unless the header already exists in production [[RFC 6648](https://datatracker.ietf.org/doc/html/rfc6648)].\\r\\n\\r\\n**Additional References**\\n\\nAzure services must adhere to the HTTP specification, [RFC 7231](https://tools.ietf.org/html/rfc7231). This section further refines and constrains how service implementors should apply the constructs defined in the HTTP specification. It is therefore, important that you have a firm understanding of the following concepts:\\r\\n\\r\\n- [Uniform Resource Locators (URLs)](#uniform-resource-locators-urls)\\r\\n- [HTTP Request / Response Pattern](#http-request--response-pattern)\\r\\n- [HTTP Query Parameters and Header Values](#http-query-parameters-and-header-values)\\r\\n\\r\\n#### Uniform Resource Locators (URLs)\\r\\n\\r\\nA Uniform Resource Locator (URL) is how developers access the resources of your service. Ultimately, URLs are how developers form a cognitive model of your service's resources.\\r\\n\\r\\n\\u003ca href=\\\"#http-url-pattern\\\" name=\\\"http-url-pattern\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** use this URL pattern:\\r\\n```text\\r\\nhttps://\\u003ctenant\\u003e.\\u003cregion\\u003e.\\u003cservice\\u003e.\\u003ccloud\\u003e/\\u003cservice-root\\u003e/\\u003cresource-collection\\u003e/\\u003cresou\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"troubleshoot#status-read-only-error.md\",\"document_title\":\"`ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error\",\"content\":\"# troubleshoot#status-read-only-error.md\\n\\n# `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\\n\\nWhen trying to check in an ARM specification to the `azure-rest-api-specs` repository, your specification\\r\\nshows violations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\\n\\n## Symptoms\\n\\nIn the `Swagger LintDiff` or `Swagger(RPaaS) LintDiff` checks, your specification shows one or more\\r\\nviolations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\\n\\n## Cause\\n\\nThe LintDiff swagger scripts use an old validation mechanism that does not detect `readOnly` properties, but requires the\\r\\ntype schema referenced by the properties to be `readOnly` instead.\\n\\n## Workaround\\n\\nUntil this validation is fixed, you can configure the `@azure-tools/typespec-autorest` emitter in `tspConfig.yaml`\\r\\nto always output any `ProvisioningState` schema as readOnly, using the `read-only-status-schema` option. This\\r\\nresolves the LintDiff violation. Note that if you use the scaffolding template for `ARM`, this configuration is\\r\\nenabled automatically.\\r\\n\\r\\n```diff lang=yaml title=tspconfig.yaml\\r\\nemit:\\r\\n  - \\\"@azure-tools/typespec-autorest\\\"\\r\\noptions:\\r\\n  \\\"@azure-tools/typespec-autorest\\\":\\r\\n+    use-read-only-status-schema: true\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#diagnostics.md\",\"document_title\":\"Diagnostics\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/diagnostics\",\"content\":\"# emitters#openapi3#diagnostics.md\\n\\n# Diagnostics\\n\\nThe OpenAPI emitter may produce any of the following diagnostic messages.\\r\\n\\r\\n\\u003c!-- Topics within this section should be ordered alphabetically for easy lookup --\\u003e\\n\\n## duplicate-header\\n\\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\\r\\n\\r\\nTo fix this issue, ensure that each response header is defined only once for each status code.\\n\\n### Example\\n\\n```yaml\\r\\nresponses:\\r\\n  \\\"200\\\":\\r\\n    description: Successful response\\r\\n    headers:\\r\\n      X-Rate-Limit:\\r\\n        description: The number of allowed requests in the current period\\r\\n        schema:\\r\\n          type: integer\\r\\n      X-Rate-Limit:\\r\\n        description: The number of allowed requests in the current period\\r\\n        schema:\\r\\n          type: integer\\r\\n```\\r\\n\\r\\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\\n\\n## duplicate-type-name\\n\\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\\r\\n\\r\\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\\n\\n### Example\\n\\n```typespec\\r\\n@friendlyName(\\\"User\\\")\\r\\nmodel Customer {\\r\\n  id: string;\\r\\n}\\r\\n\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\r\\n\\r\\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\\n\\n## inline-cycle\\n\\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\\r\\n\\r\\nTo fix this issue, refactor the schemas to remove the cyclic reference.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    Node:\\r\\n      type: object\\r\\n      properties:\\r\\n        value:\\r\\n          type: string\\r\\n        next:\\r\\n          $ref: \\\"#/components/schemas/Node\\\"\\r\\n```\\r\\n\\r\\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\\n\\n## invalid-default\\n\\nThis diagnostic is issued when a default value is invalid for the specified schema type.\\r\\n\\r\\nTo fix this issue, ensure that the default value is valid for the schema type.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    User:\\r\\n      type: object\\r\\n      properties:\\r\\n        age:\\r\\n          type: integer\\r\\n          default: \\\"twenty\\\"\\r\\n```\\r\\n\\r\\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\\n\\n## invalid-extension-key\\n\\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \\\"x-\\\" as\\r\\nrequired by the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, change the extension name to start with \\\"x-\\\".\\n\\n### Example\\n\\n```typespec\\r\\n@extension(\\\"invalid-name\\\", \\\"value\\\")\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\r\\n\\r\\nShould be changed to:\\r\\n\\r\\n```typespec\\r\\n@extension(\\\"x-valid-name\\\", \\\"value\\\")\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\n\\n## invalid-schema\\n\\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    User:\\r\\n      type: object\\r\\n      properties:\\r\\n        id:\\r\\n          type: string\\r\\n        age:\\r\\n          type: integer\\r\\n          format: \\\"int\\\" # Invalid format\\r\\n```\\r\\n\\r\\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\\n\\n## invalid-server-variable\\n\\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\\r\\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\\r\\n\\r\\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\\n\\n### Example\\n\\n```typespec\\r\\n@server(\\\"{protocol}://{host}/api/{version}\\\", \\\"Custom endpoint\\\", {\\r\\n  protocol: \\\"http\\\" | \\\"https\\\",\\r\\n  host: string,\\r\\n  version: 1, // Should be a string: \\\"1\\\"\\r\\n})\\r\\n```\\n\\n## path-query\\n\\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\\r\\n\\r\\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\\n\\n### Example\\n\\nInstead of:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users?filter={filter}\\\")\\r\\nop getUsers(filter: string): User[];\\r\\n```\\r\\n\\r\\nUse:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users\\\")\\r\\nop getUsers(@query filter?: string): User[];\\r\\n```\\r\\n\\r\\nAlternatively, you can leverage TypeSpec's support for URI templates:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users{?filter}\\\")\\r\\nop getUsers(filter?: string): User[];\\r\\n```\\n\\n## union-null\\n\\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\\r\\nrepresented in OpenAPI.\\r\\n\\r\\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\\n\\n## union-unsupported\\n\\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\\r\\n\\r\\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"Table of Contents\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Swagger-Avocado.md\\n\\n# Table of Contents\\n\\n- [Overview](#overview)\\r\\n- [Fixing Errors](#fixing-errors)\\r\\n- [Running Locally](#running-locally)\\r\\n- [Known Issues](#known-issues)\\r\\n  - [MULTIPLE_API_VERSION](#multiple_api_version)\\r\\n- [Future Plans](#future-plans)\\n\\n# Overview\\n\\nCheck \\\"Swagger Avocado\\\" is a thin wrapper around package `@azure/avocado`, which is hosted in its own repo and published to npmjs.\\r\\n\\r\\nRepo: https://github.com/Azure/avocado\\r\\n\\r\\nPackage: https://www.npmjs.com/package/@azure/avocado\\n\\n# Fixing Errors\\n\\nhttps://github.com/Azure/avocado?tab=readme-ov-file#how-to-solve-errors\\n\\n# Running Locally\\n\\n```\\r\\n$ cd azure-rest-api-specs\\r\\n$ npm ci\\r\\n$ npx avocado --excludePaths common-types -d specification/contosowidgetmanager\\r\\n```\\n\\n# Known Issues\\n\\nWorkaround is for PR reviewer to apply label `Approved-Avocado` until tool issues are fixed.\\r\\n\\r\\n1. [Allow specs with readme.md in sub-folders under resource-manager](https://github.com/Azure/azure-rest-api-specs/issues/32445)\\r\\n2. [[MISSING_APIS_IN_DEFAULT_TAG] False positive on deprecated APIs](https://github.com/Azure/avocado/issues/150)\\n\\n## MULTIPLE_API_VERSION\\n\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\\n\\n# Future Plans\\n\\n* Move code for check and package to specs repo (https://github.com/Azure/azure-rest-api-specs/issues/32398)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# design#specs-pr-guides#pr-suppressions.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-suppressions](https://aka.ms/azsdk/pr-suppressions) |\\r\\n|--|--|\\n\\n# Suppress validation failures on a PR\\n\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nOn your Azure REST API specs PR, some of the GitHub check failures (see the `Checks` tab on your PR) can be suppressed.\\r\\nThe suppression can be either just for the PR, or permanent.\\n\\n## To suppress given validation failure\\n\\n1. Determine which failing check you want to suppress: see its name in the `Checks` tab in your PR.\\r\\n1. Determine if you have one of the [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. Determine if you want to suppress the failure only for the PR, or permanently.\\r\\n1. Consult [the suppression cases table](#suppression-cases-table) for instructions corresponding to your case.\\r\\n1. If you want to apply temporary suppression:\\r\\n   1. Mention in a comment on your PR the PR assignee asking to apply the suppression. Provide justification.\\r\\n      See [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. If you applied permanent suppression:\\r\\n   1. It will manifest by the PR getting a label `SuppressionReviewRequired`.\\r\\n   1. Verify the suppression works by the check changing from **failed** to **neutral**.\\r\\n   1. Wait until your suppression is reviewed. If it is approved, the approved will add the `Approved-Suppression` label.\\r\\n   1. Understand the suppression won't be approved if it is not one of the  \\r\\n      [valid suppression reasons](#valid-suppression-reasons) as explained in relevant section.\\n\\n## Suppression cases table\\n\\n|\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met | Not possible                              |                                                      | Not possible                                                    |\\r\\n\\r\\n[1] Applies only if the SDK generation check failed with a breaking change. For details of SDK breaking change suppression, see https://aka.ms/azsdk/sdk-suppression.\\r\\nGeneral SDK generation check failure suppressions are not supported. See [#6509].\\n\\n|\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger SemanticValidation         | See [aka.ms/ci-fix]                       | `Approved-SemanticValidation`                        | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger ModelValidation            | See [aka.ms/ci-fix]                       | `Approved-ModelValidation`                           | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger Breaking Change            | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Breaking Change(Cross-Version)     | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              |\\n\\nTable legend:\\r\\n\\r\\n- `Check name`: Check to suppress.\\r\\n- `PR suppression`: instructions to obtain suppression for given check for given PR only.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n- `Label`: the label your PR will get if your suppression is approved.\\r\\n- `Permanent suppression`: instructions how to get permanent suppression.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n\\r\\n| Check name                         | PR suppression                            | Label                                                | Permanent suppression                                           |\\r\\n|------------------------------------|-------------------------------------------|------------------------------------------------------|-----------------------------------------------------------------|\\r\\n| TypeSpec Requirement               | Not possible                              |                                                      | [suppressions.yaml](#suppressionsyaml)                      |\\r\\n| TypeSpec Validation                | Not possible                              |                                                      | Not possible                                                    |\\r\\n| license/cla                        | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 |\\n\\n|\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-net-track2       | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-go               | See [step 3 in the diagram] but note [1]. | `BreakingChange-Go-Sdk-Suppression-Approved`         | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-java             | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-js               | See [step 3 in the diagram] but note [1]. | `BreakingChange-JavaScript-Sdk-Suppression-Approved` | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met |\\n\\n## suppressions.yaml\\n\\nFile `suppressions.yaml` is used for all checks created in 2024 or later, like\\r\\n`TypeSpec Requirement` and `TypeSpec Validation`.\\r\\n\\r\\nFor simplicity, we recommend adding all suppressions to a single file at the root of your spec folder:\\r\\n\\r\\n```\\r\\nspecification/myservice/suppressions.yaml\\r\\n```\\r\\n\\r\\nAlternatively, you can use multiple files in separate folders.  Currently, tools will use the first\\r\\ninstance of `suppressions.yaml` found walking up the directory tree.  We are planning\\r\\nfuture support for \\\"merging\\\" files up the hierarchy.\\r\\n\\r\\nA suppression follows this general format:\\r\\n\\r\\n```\\r\\n- tool: ToolName\\r\\n  path: applies/to/**/*.json\\r\\n  reason: Why this can't be fixed\\r\\n```\\r\\n\\r\\n`path` uses \\\"glob\\\" matching.  For syntax, see https://www.npmjs.com/package/minimatch.\\r\\n\\r\\nScope your `path` as narrowly as possible.  For example, if a suppression only applies\\r\\nto a single version of your spec:\\r\\n\\r\\n```\\r\\n# good\\r\\n- path: data-plane/Azure.Contoso.WidgetManager/preview/2022-11-01-preview/**/*.json\\r\\n\\r\\n# bad\\r\\n- path: data-plane/**/*.json\\r\\n```\\r\\n\\r\\nWhen in doubt, search the repo for examples:\\r\\n\\r\\nhttps://github.com/search?q=repo%3AAzure%2Fazure-rest-api-specs+path%3A%2F%28%5E%7C%5C%2F%29suppressions%5C.yaml%24%2F\\u0026type=code\\n\\n### `TypeSpec Requirement` check\\n\\nTo suppress `TypeSpec Requirement` check for given pattern of OpenAPI spec .json file paths, provide an entry with\\r\\n`tool` set to `TypeSpecRequirement`. Provide the pattern as `path` and provide a `reason`.\\r\\n\\r\\nExample:\\r\\n\\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: data-plane/**/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## Suppress AutoRest extension\\n\\nTo suppress tooling that is an AutoRest extension (see [the suppressio\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"TypeSpec Validation failed\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# TypeSpec Validation failed\\n\\n## question\\n\\nIn this [PR](https://github.com/Azure/azure-rest-api-specs/pull/34282), [TypeSpec Validation](https://github.com/Azure/azure-rest-api-specs/actions/runs/15438271648/job/43449735963?pr=34282) failed. I cannot repro in my local machine.\\n\\n## answer\\n\\nRepros locally for me on linux.  Follow instructions here: https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\\r\\n \\r\\nProblem is PR isn't using consistent casing in filenames.\\r\\n```\\r\\n$ git status\\r\\nUntracked files:\\r\\n  (use \\\"git add \\u003cfile\\u003e...\\\" to include in what will be committed)\\r\\n        specification/powerbidedicated/resource-manager/Microsoft.PowerBIDedicated/\\r\\n \\r\\n$ ls specification/powerbidedicated/resource-manager\\r\\nMicrosoft.PowerBIdedicated  readme.go.md  readme.nodejs.md  readme.typescript.md\\r\\nMicrosoft.PowerBIDedicated  readme.md     readme.python.md\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Typespec Validation required check\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Typespec Validation required check\\n\\n## question\\n\\n\\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\". Please add \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-fakes\\\". Please add \\\"options.@azure-tools/typespec-go.generate-fakes\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.head-as-boolean\\\". Please add \\\"options.@azure-tools/typespec-go.head-as-boolean\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.inject-spans\\\". Please add \\\"options.@azure-tools/typespec-go.inject-spans\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-python.package-dir\\\". Please add \\\"options.@azure-tools/typespec-python.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-csharp.namespace \\\"Microsoft.Azure.Management.DevTestLabs\\\" does not match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter. Please update the value of \\\"options.@azure-tools/typespec-csharp.namespace\\\" to match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter.\\r\\nPlease see https://aka.ms/azsdk/spec-gen-sdk-config for more info.\\r\\nFor additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.\\r\\n```\\r\\nI have copied the namespace from the autorest readme files that we had before and it was responsible  to generate SDKs. Is it a requirement to update the namespace as suggested given we have already published the SDK before?\\n\\nPR: https://github.com/Azure/azure-rest-api-specs/pull/35346\\r\\nThis PR only has typespec conversion change and no API update. It is currently failing for required check - Typespec validation. When I run the npx tsmv command locally then I see the following error.\\r\\n```\\r\\nExecuting rule: SdkTspConfigValidation\\r\\nValidation on option \\\"options.@azure-tools/typespec-csharp.namespace\\\" in \\\"@azure-tools/typespec-csharp\\\" are failed. However, per @azure-tools/typespec-csharp’s decision, we will treat it as passed.\\r\\n[SdkTspConfigValidation]: validation failed.\\r\\n- Failed to find \\\"parameters.service-dir.default\\\". Please add \\\"parameters.service-dir.default\\\".\\r\\n- The value of options.@azure-tools/typespec-java.package-dir \\\"azure-mgmt-devtestlabs\\\" does not match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.package-dir\\\" to match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\".\\r\\n- The value of options.@azure-tools/typespec-java.namespace \\\"com.microsoft.azure.management.devtestlabs\\\" does not match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.namespace\\\" to match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.service-dir\\\". Please add \\\"options.@azure-tools/typespec-go.service-dir\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.package-dir\\\". Please add \\\"options.@azure-tools/typespec-go.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-go.module \\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\n\\n## answer\\n\\ntypeSpec validation is failing, but not for that reason.  The configuration for c-sharp emitter is a warning only.  The current failure is caused by diffs between the generated swagger included in your PR and the generated swagger when the ci compiles your spec.\\r\\n \\r\\nUsually this indicates that your local dependencies are out of date, and you need to pull the latest into your local branch and re-install at thetop level:\\r\\n \\r\\ngit fetch upstream main\\r\\ngit pull upstream main\\r\\nnpm ci\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"TypeSpec Validation failed\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# TypeSpec Validation failed\\n\\n## question\\n\\nIn this [PR](https://github.com/Azure/azure-rest-api-specs/pull/34282), [TypeSpec Validation](https://github.com/Azure/azure-rest-api-specs/actions/runs/15438271648/job/43449735963?pr=34282) failed. I cannot repro in my local machine.\\n\\n## answer\\n\\nRepros locally for me on linux.  Follow instructions here: https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\\r\\n \\r\\nProblem is PR isn't using consistent casing in filenames.\\r\\n```\\r\\n$ git status\\r\\nUntracked files:\\r\\n  (use \\\"git add \\u003cfile\\u003e...\\\" to include in what will be committed)\\r\\n        specification/powerbidedicated/resource-manager/Microsoft.PowerBIDedicated/\\r\\n \\r\\n$ ls specification/powerbidedicated/resource-manager\\r\\nMicrosoft.PowerBIdedicated  readme.go.md  readme.nodejs.md  readme.typescript.md\\r\\nMicrosoft.PowerBIDedicated  readme.md     readme.python.md\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#pr-move-private-to-public.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/pr-move-private-to-public\",\"content\":\"# Move private specs to public\\n\\u003e [!CAUTION]\\r\\n\\u003e Copying over specs from private specs repo to public specs repo is effectively converting a `private preview`\\r\\n\\u003e API version to `public preview`. The copying of specs is only one element of a larger process.\\r\\n\\u003e Consult with the service \\u0026 spec owner to ensure you complete all the required steps, like disabling [AFEC] flags,\\r\\n\\u003e publishing relevant docs to external customers, etc.\\r\\n\\u003e ([example requirements doc for ARM][ARM lifecycle stages requirements])\\r\\n\\u003e Do this consultation **before you open the PR** to the public specs repo.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e These instructions replace the former OpenAPI Hub feature **Publish a pull request**\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Branch protection rules table\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\nThis table shows which GitHub checks are marked as `required` on respective branches. Even when a check is marked as ❌\\r\\nit **may** still be running on given branch; just that if it fails, the PR won't be blocked from merging.\\r\\n\\r\\n| Branch | Merge | SDK | TSVal | BrCh | BrChC | LintRPaaS | LintDiff | Model | Semantic | Spell | Prettier | license | approver |\\r\\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\\r\\n| public `main`                  | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSMaster`         | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| public/private `release-*`     | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSDev`            | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `InternalARMContracts` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `ARMCoreRPDev`         | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n\\r\\nLegend:\\r\\n\\r\\n| Column name | Full GitHub check name               |\\r\\n|-------------|--------------------------------------|\\r\\n| `BrCh`      | `Swagger BreakingChange`             |\\r\\n| `BrChC`     | `Breaking Change(Cross-Version)`     |\\r\\n| `license`   | `license/cla`                        |\\r\\n| `LintDiff`  | `Swagger LintDiff`                   |\\r\\n| `LintRPaaS` | `Swagger Lint(RPaaS)`                |\\r\\n| `Merge`     | `Automated merging requirements met` |\\r\\n| `Model`     | `Swagger ModelValidation`            |\\r\\n| `Prettier`  | `PrettierCheck`                      |\\r\\n| `SDK`       | `SDK azure-sdk-for-go`               |\\r\\n| `Semantic`  | `Swagger SemanticValidation`         |\\r\\n| `Spell`     | `SpellCheck`                         |\\r\\n| `TSVal`     | `TypeScript Validation`              |\\r\\n| `approver`  | Requires team member approval        |\\r\\n\\r\\nFor more information on these checks, see:\\r\\n\\r\\n- https://aka.ms/azsdk/pr-getting-help\\r\\n- https://aka.ms/ci-fix\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#pipeline.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline\",\"content\":\"# Resolving Pipeline Failures\\n## Swagger ModelValidation\\nSome validation rules may fail because TypeSpec fixes certain legacy patterns. Review the known issues below and take appropriate action.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#rest-api-publish#checking-in-api-specs-guide.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/rest-api-publish/checking-in-api-specs-guide\",\"content\":\"# Checking in typespec and generated OpenAPI to azure-rest-api-specs repo\\nSee documentation on the azure-rest-api-specs repo https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/Getting-started-with-TypeSpec-specifications.md\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#rest-api-publish#buildpipelines.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/rest-api-publish/buildpipelines\",\"content\":\"# Using Build Pipelines with TypeSpec\\nThis doc will help you get started with using TypeSpec in your build pipelines in your own repository. [See here for more how to use in the azure-rest-api-specs repo](./checking-in-api-specs-guide.md)\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Deprecating-Preview-APIs.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs\",\"content\":\"## Process\\n1. Open a PR deleting one (or more) previews.  All of:\\r\\n   1. TypeSpec sources (`*.tsp`)\\r\\n   2. Example sources (examples closest to `*.tsp` files)\\r\\n   3. Generated swaggers and examples (`preview/YYYY-MM-DD-preview/**`)\\r\\n   4. readme.md (remove tags)\\r\\n2. PR should fail check `Swagger BreakingChange`, but pass all other checks.\\r\\n3. Request approval following the normal process for breaking changes\\r\\n   - https://aka.ms/brch\\r\\n   - azbreakchangereview@microsoft.com\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Validation.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation\",\"content\":\"# Table of Contents\\n## How to Re-evaluate `SDK Validation Status` Check\\nRe-running any `SDK Validation` checks will automatically re-evaluate the `SDK Validation Status` check. If you don't see any `SDK Validation - {Language}` checks in your PR's checklist, it means you don't have the required permission to trigger them. Refer to the instructions at https://aka.ms/azsdk/access to get the necessary write access. Additionally, make sure your membership in the `Azure` GitHub organization is set to _public_, for example, you can verify your membership visibility on [Azure](https://github.com/orgs/Azure/people?query=) page.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"PR-Check-Modernization.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/PR-Check-Modernization\",\"content\":\"Moved to https://github.com/Azure/azure-rest-api-specs/issues/32396\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#specs-pr-guides.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/specs-pr-guides\",\"content\":\"# Azure REST API specs PRs Guides\\nThis section contains articles with detailed guidance for various aspects of getting your  \\r\\n[Azure REST API specs PR](xref:api-specs-pr) merged.\\r\\n\\r\\nBy design, you are expected to be linked to these articles from your specs PR. As such, these articles assume\\r\\nvery specific context which may not be evident if you read them without having a corresponding PR.\"}]",
            "inputs.latency": 306.6212275028229,
            "inputs.response_length": 1163,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions"
            ],
            "inputs.testcase": "Licence agreement",
            "outputs.similarity.similarity": 5.0,
            "outputs.similarity.gpt_similarity": 5.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1182,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1183,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Licence agreement\\\\n\\\\nquestion: Hi,\\\\n[Added Mongo Types by sougho \\\\u00b7 Pull Request #23842 \\\\u00b7 Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/23842)\\\\nWe have a PR which has all pipelines passing except the license agreement.\\\\nIt looks like only author's license agreement comment will be considered by the automated pipeline.\\\\nCan someone help to resolve this? author of this PR won't be available for a while and i have taken over this PR now\\\", \\\"response\\\": \\\"Based strictly on the provided knowledge context, there is no TypeSpec-specific or general Azure REST API specs process that allows another contributor or maintainer to sign the Contributor License Agreement (CLA) or override the license/cla check on behalf of the original author. The license/cla check is marked as 'Not possible' to suppress or bypass, and only the original author can resolve it by signing the agreement themselves. If the author is unavailable, the only compliant path is to either wait for the original author to sign the CLA or create a new PR under your own account, reapplying the same changes. This ensures that all contributions are covered by a valid CLA for each contributor, per Microsoft open source contribution policies.\\\\n\\\\nIf you create a new PR, you will need to ensure that you have signed the CLA and that all commits are attributed to you or contributors who have signed the CLA. There is no documented maintainer override, re-run, or reassignment process for the license/cla check in the official guidance.\\\\n\\\\nFor further information, please refer to the Azure REST API specs PR guides or the official documentation links below.\\\", \\\"ground_truth\\\": \\\"If the PR author is no longer available to agree to the `license/cla`, you will need to open a new PR from a user who can agree.\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"5\"}]"
        },
        {
            "inputs.query": "title: Avocado warning\n\nquestion: Hi,\nNeed some help on this PR - [Renaming the RP to Lionrock from PlannedQuota by sathchan · Pull Request #24569 · Azure/azure-rest-…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24569)\n[Swagger Avocado](https://github.com/Azure/azure-rest-api-specs-pr/actions/runs/18212677882) and [Swagger BreakingChange](https://github.com/Azure/azure-rest-api-specs-pr/actions/runs/18212677881/job/51856124052?pr=24569) validations fail, because in this PR we are removing Microsoft.PlannedQuota namespace and the corresponding specification file:\n```\nRPSaaSMaster/specification/plannedquota/resource-manager/Microsoft.PlannedQuota/preview/2025-10-01-preview/plannedQuota.json\n```\nThis is completely expected and safe to remove, as this namespace was created in the [previous PR](https://github.com/Azure/azure-rest-api-specs-pr/pull/24280) and was never in use.\nPlease note, Microsoft.PlannedQuota was neither registered nor in use.\nCould you help on how to bypass this?",
            "inputs.ground_truth": "Avocado failing when you completely delete a spec folder is a known issue:\n[[MISSING_README] False positive when migrate spec to FSv2 · Issue #163 · Azure/avocado](https://github.com/Azure/avocado/issues/163)\nIf you need to merge a PR with this failing, add a note to your PR for your ARM reviewer to add label `Approved-Avocado` to unblock your one PR, until the bug in the tool is fixed.",
            "inputs.response": "Based on Azure REST API specs PR guidelines, the removal of a never-used, unregistered namespace and its specification file (such as Microsoft.PlannedQuota) is an expected and safe breaking change. However, Swagger Avocado and Swagger BreakingChange validations are designed to block breaking changes by default. \n\nTo proceed, you must request a breaking change approval through the standard Azure process:\n\n1. Open your PR deleting the TypeSpec sources, examples, generated OpenAPI files, and tags in readme.md associated with the unused namespace.\n2. The PR will fail the `Swagger BreakingChange` check, but this is expected.\n3. To unblock, request approval from the Breaking Change Review Board. You should:\n   - Follow the process at https://aka.ms/brch\n   - Email azbreakchangereview@microsoft.com with justification that the namespace was never registered or used, so the removal is benign and does not impact any customers.\n4. Once approved, a reviewer will apply the appropriate approval label (such as `BreakingChange-Approved-Benign`) to your PR, which will bypass the validation failures and allow the PR to proceed.\n\nFor Avocado-specific issues (such as false positives when removing unused APIs), the official workaround is for the PR reviewer to apply the `Approved-Avocado` label until the tooling is updated.\n\nIn summary: Do not attempt to bypass these checks by suppressing or ignoring them. You must follow the breaking change approval process and get the required label(s) applied to your PR.\n",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# design#specs-pr-guides#pr-suppressions.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-suppressions](https://aka.ms/azsdk/pr-suppressions) |\\r\\n|--|--|\\n\\n# Suppress validation failures on a PR\\n\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nOn your Azure REST API specs PR, some of the GitHub check failures (see the `Checks` tab on your PR) can be suppressed.\\r\\nThe suppression can be either just for the PR, or permanent.\\n\\n## To suppress given validation failure\\n\\n1. Determine which failing check you want to suppress: see its name in the `Checks` tab in your PR.\\r\\n1. Determine if you have one of the [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. Determine if you want to suppress the failure only for the PR, or permanently.\\r\\n1. Consult [the suppression cases table](#suppression-cases-table) for instructions corresponding to your case.\\r\\n1. If you want to apply temporary suppression:\\r\\n   1. Mention in a comment on your PR the PR assignee asking to apply the suppression. Provide justification.\\r\\n      See [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. If you applied permanent suppression:\\r\\n   1. It will manifest by the PR getting a label `SuppressionReviewRequired`.\\r\\n   1. Verify the suppression works by the check changing from **failed** to **neutral**.\\r\\n   1. Wait until your suppression is reviewed. If it is approved, the approved will add the `Approved-Suppression` label.\\r\\n   1. Understand the suppression won't be approved if it is not one of the  \\r\\n      [valid suppression reasons](#valid-suppression-reasons) as explained in relevant section.\\n\\n## Suppression cases table\\n\\n|\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met | Not possible                              |                                                      | Not possible                                                    |\\r\\n\\r\\n[1] Applies only if the SDK generation check failed with a breaking change. For details of SDK breaking change suppression, see https://aka.ms/azsdk/sdk-suppression.\\r\\nGeneral SDK generation check failure suppressions are not supported. See [#6509].\\n\\n|\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger SemanticValidation         | See [aka.ms/ci-fix]                       | `Approved-SemanticValidation`                        | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger ModelValidation            | See [aka.ms/ci-fix]                       | `Approved-ModelValidation`                           | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger Breaking Change            | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Breaking Change(Cross-Version)     | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              |\\n\\nTable legend:\\r\\n\\r\\n- `Check name`: Check to suppress.\\r\\n- `PR suppression`: instructions to obtain suppression for given check for given PR only.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n- `Label`: the label your PR will get if your suppression is approved.\\r\\n- `Permanent suppression`: instructions how to get permanent suppression.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n\\r\\n| Check name                         | PR suppression                            | Label                                                | Permanent suppression                                           |\\r\\n|------------------------------------|-------------------------------------------|------------------------------------------------------|-----------------------------------------------------------------|\\r\\n| TypeSpec Requirement               | Not possible                              |                                                      | [suppressions.yaml](#suppressionsyaml)                      |\\r\\n| TypeSpec Validation                | Not possible                              |                                                      | Not possible                                                    |\\r\\n| license/cla                        | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 |\\n\\n|\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-net-track2       | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-go               | See [step 3 in the diagram] but note [1]. | `BreakingChange-Go-Sdk-Suppression-Approved`         | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-java             | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-js               | See [step 3 in the diagram] but note [1]. | `BreakingChange-JavaScript-Sdk-Suppression-Approved` | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met |\\n\\n## suppressions.yaml\\n\\nFile `suppressions.yaml` is used for all checks created in 2024 or later, like\\r\\n`TypeSpec Requirement` and `TypeSpec Validation`.\\r\\n\\r\\nFor simplicity, we recommend adding all suppressions to a single file at the root of your spec folder:\\r\\n\\r\\n```\\r\\nspecification/myservice/suppressions.yaml\\r\\n```\\r\\n\\r\\nAlternatively, you can use multiple files in separate folders.  Currently, tools will use the first\\r\\ninstance of `suppressions.yaml` found walking up the directory tree.  We are planning\\r\\nfuture support for \\\"merging\\\" files up the hierarchy.\\r\\n\\r\\nA suppression follows this general format:\\r\\n\\r\\n```\\r\\n- tool: ToolName\\r\\n  path: applies/to/**/*.json\\r\\n  reason: Why this can't be fixed\\r\\n```\\r\\n\\r\\n`path` uses \\\"glob\\\" matching.  For syntax, see https://www.npmjs.com/package/minimatch.\\r\\n\\r\\nScope your `path` as narrowly as possible.  For example, if a suppression only applies\\r\\nto a single version of your spec:\\r\\n\\r\\n```\\r\\n# good\\r\\n- path: data-plane/Azure.Contoso.WidgetManager/preview/2022-11-01-preview/**/*.json\\r\\n\\r\\n# bad\\r\\n- path: data-plane/**/*.json\\r\\n```\\r\\n\\r\\nWhen in doubt, search the repo for examples:\\r\\n\\r\\nhttps://github.com/search?q=repo%3AAzure%2Fazure-rest-api-specs+path%3A%2F%28%5E%7C%5C%2F%29suppressions%5C.yaml%24%2F\\u0026type=code\\n\\n### `TypeSpec Requirement` check\\n\\nTo suppress `TypeSpec Requirement` check for given pattern of OpenAPI spec .json file paths, provide an entry with\\r\\n`tool` set to `TypeSpecRequirement`. Provide the pattern as `path` and provide a `reason`.\\r\\n\\r\\nExample:\\r\\n\\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: data-plane/**/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## Suppress AutoRest extension\\n\\nTo suppress tooling that is an AutoRest extension (see [the suppressio\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Breaking-Changes.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Breaking-Changes\",\"content\":\"# SDK-Breaking-Changes.md\\n\\n| Short Link: | [aka.ms/azsdk/sdk-suppression](https://aka.ms/azsdk/sdk-suppression) |\\r\\n|--|--|\\n\\n# Table of Contents\\n\\n- [Overview](#overview)\\r\\n- [How to Suppress the SDK Breaking Changes](#how-to-suppress-the-sdk-breaking-changes)\\r\\n- [How Does the Suppression Work](#how-does-the-suppression-work)\\r\\n- [How to Get the Suppression Reviewed](#how-to-get-the-suppression-reviewed)\\n\\n## Overview\\n\\nWhen a specification pull request has breaking change for a specific SDK language, such as `Go`, the pull request will be labelled with \\\"BreakingChange-Go-Sdk\\\". According to [the design principles of Azure SDK](https://azure.github.io/azure-sdk/general_introduction.html#dependable), breaking changes are more harmful to a user’s experience than most new features and improvements are beneficial. Therefore, the pull request author will be strongly encouraged to update the API specification to remove the breaking changes for the SDK. If the breaking change cannot be mitigated by a specification change, the author will need to suppress the breaking changes and have the suppression reviewed. See the following section for details on how to suppress breaking changes.\\r\\n\\r\\nOnce the suppression is added to the pull request, SDK reviewers will evaluate the suppressions and either provide feedback or approve the suppressions. When the suppressions have been approved, the SDK breaking change review is complete and the pull request can proceed to the next stage.\\r\\n\\r\\n\\u003e Note: both the suppressions review and the SDK breaking change review will be conducted proactively by SDK reviewers, and the expected completion time is around 48 business hours.\\n\\n## How to Suppress the SDK Breaking Changes\\n\\nTo suppress SDK breaking changes, go to the `SDK Validation *` CI check result for a specific SDK language, such as \\\"SDK Validation - Go\\\". Click on the link of **View more details on Azure Pipelines** to browse to the azure pipeline result page. Then download the artifact of **spec-gen-sdk logs**. There is a html report with the name ended by \\\"-gen-result.html\\\". Open the html report then look for the `Absent SDK breaking changes suppressions` section, as shown in the following code block:\\r\\n\\r\\n```yaml\\r\\nAbsent SDK breaking changes suppressions\\r\\n- Function `*LinkerClient.BeginCreateOrUpdate` has been removed\\r\\n- Function `*LinkerClient.NewListPager` has been removed\\r\\n```\\r\\n\\r\\n\\u003e Note: refer to https://aka.ms/azsdk/sdk-automation-faq to download the html report.\\n\\n### Next Steps\\n\\n1. The pull request authors create a file called `sdk-suppressions.yaml` if it doesn't already exist in your service folder in the `azure-rest-api-specs` repository.\\r\\n    - For TypeSpec scenarios, `sdk-suppressions.yaml` should be placed in the root folder of the TypeSpec project, which also contains the `tspconfig.yaml` file. For example, refers to the location for [Contoso.Management](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/Contoso.Management).\\r\\n    - For OpenAPI scenarios, `sdk-suppressions.yaml` should be placed in the `{service}\\\\resource-manager` folder. For example, see the location for the [contosowidgetmanager resource provider](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/resource-manager).\\r\\n\\r\\n2. The pull request authors copy every line under the `Absent SDK breaking changes suppressions` section to the suppression file in the following format:\\r\\n\\r\\n``` yaml\\r\\nsuppressions:\\r\\n  azure-sdk-for-go:\\r\\n    - package: 'sdk/resourcemanager/servicelinker/armservicelinker'\\r\\n      breaking-changes:\\r\\n        - Function `*LinkerClient.BeginCreateOrUpdate` has been removed\\r\\n        - Function `*LinkerClient.NewListPager` has been removed\\r\\n```\\r\\n\\r\\n3. The pull request authors add this suppression file change to your spec pull request. Then the suppressions will be recognized by the bot, and the corresponding suppression label will be added to the spec pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression` will be added to the pull request.\\r\\n\\r\\n4. The SDK reviewers will evaluate the suppressions and either approve them or provide feedback. If the suppressions are approved, the corresponding approval label will be added to the pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression-Approved` will be added to the pull request.\\n\\n## How Does the Suppression Work\\n\\nThe suppression file will remain with the specification move with it to other branches or repositories(such as from the private specification repository to the public specification repository). The suppressions can be deleted after the SDK has been released to the public.\\n\\n## How to Get the Suppression Reviewed\\n\\nSDK reviewers will monitor the specification pull requests with breaking change suppression lables. For example, for the  `azure-sdk-for-go`, the label is `BreakingChange-Go-Sdk-Suppression`. They will evaluate the suppressions and either approve them or provide feedback. If the suppressions are approved, the corresponding approval label will be added to the pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression-Approved` will be added to the pull request. Once the suppression review is complete, the pull request can proceed to the next stage.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# design#specs-pr-guides#pr-brch-deep.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-brch-deep](https://aka.ms/azsdk/pr-brch-deep) |\\r\\n| --- | --- |\\n\\n# Deep-dive into breaking changes on spec PRs\\n\\n## Important information about this article\\n\\nThis article provides a deep-dive into breaking changes on spec PRs. It applies if your spec PR has\\r\\n`BreakingChangeReviewRequired` or `VersioningReviewRequired` label.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e This is an advanced deep-dive. If your PR is blocked on breaking changes or versioning issues, you should always\\r\\n\\u003e start by following the guidance at [aka.ms/brch].\\n\\n### Prerequisites\\n\\nThis article assumes you are familiar with [API versions and branches](xref:api-versions-and-branches).\\n\\n### Video overview and slides\\n\\nFor video overview of the breaking changes process, see this [Azure Core Day of Learning talk from March 6, 2024].\\r\\nSlides for the talk are available [here][talk slides].\\n\\n### Summary\\n\\nPer the [PR diagram], the first step of getting your specs PR approved is ensuring your PR obeys the  \\r\\n[Azure Versioning and Breaking Changes Policy]. Relevant details of this policy follow.\\r\\n\\r\\n- Once published, no changes to given API version are allowed, except when fixing the spec to match\\r\\nactual implementation (see the `-Approved-BugFix` labels in this doc).\\r\\nThis applies regardless of whether the API version is for `private preview`, `public preview`, or `GA`.\\r\\n- When introducing a new API version (any `preview` or `GA`), the new API version must be backwards compatible with\\r\\nthe previous, latest `GA` API version.\\r\\n- During a (`private` or `public`) `preview` cycle, a new `preview` API version does not have to be backwards\\r\\ncompatible with the previous `preview` API version.\\r\\n- The rules listed above are checked by automated GitHub checks. The exact ruleset is given in [`oadMessagesRuleMap.ts`].\\r\\nDetails follow.\\n\\n## Breaking changes and versioning issues\\n\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\\n\\n### `BreakingChangeReviewRequired` label\\n\\nThe label `BreakingChangeReviewRequired` is added to your PR if the tooling detects a change that could\\r\\nbe breaking for customers. This can happen in two cases:\\r\\n\\r\\n- In your PR you have possibly introduced a breaking change in a new API version, placed in a new folder,\\r\\nas compared to most recent previous `GA`.\\r\\nThe new API version can be either `preview` or `GA`.\\r\\n  - For example, an existing `GA` API version in leaf folder of `2023-11-15`\\r\\nmay contain API route of `GET .../resoruces/{resourceName}`, but a new `preview` API version of `2024-03-15-preview`\\r\\nmay no longer have this route (REST API path), because you are removing the `resoruces` typo and instead introducing\\r\\n`GET .../resources/{resourceName}` route.\\r\\n- In your PR you are modifying existing `GA` API version in-place. For example, you have recently released\\r\\n`2024-03-18` API version and realized you made a typo and are editing the contents of the leaf folder `2024-03-18`\\r\\ncontaining that API version.\\n\\n### `VersioningReviewRequired` label\\n\\nThe label `VersioningReviewRequired` denotes that your PR has a **versioning issue** possibly violating the  \\r\\n[Azure Versioning and Breaking Changes Policy]. This happens when you made a **non-breaking change**,\\r\\naka **compatible change** to an API version that was already published (merged to a production branch).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e According to [the policy][Azure Versioning and Breaking Changes Policy], compatible (non-breaking changes) are not\\r\\n\\u003e allowed within an existing API version. You must create a new API version. Otherwise, we would confuse our customers\\r\\n\\u003e by having to explain \\\"which version of given API version\\\" has a particular change/feature.\\r\\n\\r\\n`VersioningReviewRequired` label is added by automation if:\\r\\n\\r\\n- You made any compatible changes **within** any API version, `GA` or `preview`.\\r\\n- You made any breaking changes in a `preview` API version.\\r\\n\\r\\nIf your PR has both breaking changes and versioning issues, only `BreakingChangeReviewRequired` label\\r\\nis added to it.\\n\\n### In case there is no latest GA API version\\n\\nIf there is no latest GA OpenAPI spec, then the the cross-version check is instead comparing to\\r\\nlatest available preview if it more than 1 year old.\\r\\n\\r\\nIf neither a GA API version or at least 1 year old preview version exists, then the cross-version check automatically\\r\\npasses.\\n\\n### Diagram explaining breaking changes and versioning issues\\n\\nThe logic for automation adding `BreakingChangeReviewRequired` and `VersioningReviewRequired` labels explained above\\r\\ncan be summarized in the following diagram:\\r\\n\\r\\n![Breaking Changes Confusion Matrix](../../img/breaking_changes_confusion_matrix.png)\\n\\n## Addressing `BreakingChangeReviewRequired`\\n\\nIf your PR is labelled with `BreakingChangeReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the breaking changes in your PR are acceptable, they will be\\r\\napproved by one of these labels:\\n\\n### `BreakingChange-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `BreakingChange-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-UserImpact`\\n\\n- The spec PR describes actual breaking changes to the service.\\r\\n- This is the only case that triggers customer notifications, a 3 year migration period (possibly shorter), etc.\\r\\n- Within this set, the changes may be distinguished further for security or legal compliance, which may be granted\\r\\na shorter migration period.\\r\\n- Details at [aka.ms/brch].\\n\\n### `BreakingChange-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Addressing `VersioningReviewRequired`\\n\\nIf your PR is labelled with `VersioningReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the versioning issue in your PR caused by non-breaking (compatible)\\r\\nchanges is acceptable, the board will approve it by one of these labels:\\n\\n### `Versioning-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `Versioning-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-PrivatePreview`\\n\\nThe API version change that triggered the review is in `private preview`, and non-breaking changes are permitted\\r\\nin the same API version during `private preview`.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-PrivatePreview` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Common misconceptions\\n\\n### FALSE: compatible (non-breaking) changes are allowed in published API versions\\n\\n**Why?**\\r\\n\\r\\nAn API version is a contract, and once the contract is published it cannot be changed.\\r\\nOtherwise, it would create customer confusion about \\\"which version of this API version\\\" are they using.\\r\\n\\r\\nAny change of this kind w\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#breakingchange.md\",\"document_title\":\"Resolving OpenAPI Breaking Change Violations\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# migrate-swagger#faq#breakingchange.md\\n\\n# Resolving OpenAPI Breaking Change Violations\\n\\nThe OpenAPI Converter cannot perfectly represent every aspect of every API in TypeSpec. This document outlines common changes you may need to make to a converted TypeSpec to ensure compatibility with your existing service API and to pass check-in validations.\\n\\n## Migrating ARM Specifications\\n\\n### Customizing Route for Action (POST) Operations\\n\\nBy default, the last segment of a POST action operation route is the operation name. For example:\\r\\n\\r\\n```tsp\\r\\nmove is ArmResourceActionSync\\u003cEmployee, MoveRequest, MoveResponse\\u003e;\\r\\n```\\r\\n\\r\\nThis produces the route:  \\r\\n`/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContosoProviderHub/employees/{employeeName}/move`\\r\\n\\r\\nTo customize the action segment, use the `@action` decorator:\\r\\n\\r\\n```tsp\\r\\n@action(\\\"customizedAction\\\")\\r\\nmove is ArmResourceActionSync\\u003cEmployee, MoveRequest, MoveResponse\\u003e;\\r\\n```\\r\\n\\r\\nThis produces the route:  \\r\\n`/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContosoProviderHub/employees/{employeeName}/customizedAction`\\n\\n### Customizing Request Payload Parameter Names\\n\\nFor operations with request bodies (PUT, POST, PATCH), TypeSpec operation templates provide default names for request parameters. You can use augment decorators to customize these parameter names and other parts of the operation signature.\\r\\n\\r\\nThe following sections show how to do this for each operation template.\\r\\n\\r\\n#### CreateOrUpdate (PUT) APIs\\r\\n\\r\\nGiven a PUT operation, for example:\\r\\n\\r\\n```tsp\\r\\ninterface Widgets {\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cWidget\\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\nThe name of the request body parameter is `resource`. You can change the name in clients using an augment decorator:\\r\\n\\r\\n```tsp\\r\\n@@clientName(Widgets.createOrUpdate::parameters.resource, \\\"\\u003cdesired-request-body-parameter-name\\u003e\\\");\\r\\n```\\r\\n\\r\\nThis works for any PUT operation template.\\r\\n\\r\\n#### Update (PATCH) APIs\\r\\n\\r\\nGiven a PATCH operation, for example:\\r\\n\\r\\n```tsp\\r\\ninterface Widgets {\\r\\n  update is ArmResourcePatchAsync\\u003cWidget, WidgetProperties\\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\nThe name of the request body parameter is `properties`. You can change the name in clients using an augment decorator:\\r\\n\\r\\n```tsp\\r\\n@@clientName(Widgets.update::parameters.properties, \\\"\\u003cdesired-request-body-parameter-name\\u003e\\\");\\r\\n```\\r\\n\\r\\nThis works for any PATCH operation template.\\r\\n\\r\\n#### Action (POST) APIs\\r\\n\\r\\nGiven a POST operation, for example:\\r\\n\\r\\n```tsp\\r\\ninterface Widgets {\\r\\n  mungeWidget is ArmResourceActionAsync\\u003cWidget, MungeRequest, MungeResponse\\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\nThe name of the request body parameter is `body`. You can change the name in clients using an augment decorator:\\r\\n\\r\\n```tsp\\r\\n@@clientName(Widgets.mungeWidget::parameters.body, \\\"\\u003cdesired-request-body-parameter-name\\u003e\\\");\\r\\n```\\r\\n\\r\\nThis works for any POST operation template.\\n\\n### Adding Request Query or Header Parameters\\n\\nThe `Parameters` template parameter allows you to specify additional parameters after the operation path (for example, query and header parameters) in the form of a model, with each model property corresponding to a parameter. You may use intersection to combine multiple separate parameters.\\r\\n\\r\\n```tsp\\r\\n// All list query params\\r\\nop listBySubscription is ArmListBySubscription\\u003c\\r\\n  Widget,\\r\\n  Parameters = Azure.Core.StandardListQueryParameters\\r\\n\\u003e;\\r\\n\\r\\n// Intersecting individual parameters\\r\\nop listBySubscription is ArmListBySubscription\\u003c\\r\\n  Widget,\\r\\n  Parameters = Azure.Core.TopQueryParameter \\u0026 Azure.Core.SkipQueryParameter\\r\\n\\u003e;\\r\\n```\\n\\n### Changing Response Types\\n\\nThe `Response` parameter allows you to specify non-error responses to the operation.\\r\\n\\r\\n```tsp\\r\\nop listBySubscription is ArmListBySubscription\\u003cWidget, Response = MyCustomCollectionType\\u003e;\\r\\n```\\n\\n### Changing Error Types\\n\\nThe `Error` parameter allows you to change the default error type used in an operation.\\r\\n\\r\\n```tsp\\r\\nop listBySubscription is ArmListBySubscription\\u003cWidget, Error = MyCustomError\\u003e;\\r\\n```\\n\\n### Converting Synchronous Operations to LROs\\n\\nYou can generally choose an asynchronous operation template that matches your operation.\\r\\n\\r\\n#### Templates for Async PUT Operations\\r\\n\\r\\n- `ArmCreateOrReplaceAsync` is a PUT operation that uses the 'resource' definition in the request body, and returns a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains a `Location` LRO header.\\r\\n\\r\\n  ```tsp\\r\\n  op createOrUpdate is ArmCreateOrReplaceAsync\\u003cResource\\u003e;\\r\\n  ```\\r\\n\\r\\n- `ArmCreateOrUpdateAsync` is a PUT operation that uses the 'resource' definition in the request body, and returns a `200` response and a `201` response, both of which contain the created/updated resource in the response payload. The 201 response contains an `Azure-AsyncOperation` LRO header.\\r\\n\\r\\n  ```tsp\\r\\n  op createOrUpdate is ArmCreateOrUpdateAsync\\u003cResource\\u003e;\\r\\n  ```\\r\\n\\r\\n#### Templates for Async PATCH Operations\\r\\n\\r\\n- `ArmTagsPatchAsync` is a PATCH operation that only allows changing the resource tags (the minimum for Azure Resource Manager).\\r\\n\\r\\n  ```tsp\\r\\n  op update is ArmTagsPatchAsync\\u003cResource\\u003e;\\r\\n  ```\\r\\n\\r\\n- `ArmResourcePatchAsync` is a PATCH operation that uses the visibility settings to select properties for the PATCH request body (any property with no visibility setting, or including visibility \\\"update\\\"). It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\\r\\n\\r\\n  ```tsp\\r\\n  op update is ArmResourcePatchAsync\\u003cResource, ResourceProperties\\u003e;\\r\\n  ```\\r\\n\\r\\n- `ArmCustomPatchAsync` is a PATCH operation that allows you to customize the PATCH request body.\\r\\n\\r\\n  ```tsp\\r\\n  op update is ArmCustomPatchAsync\\u003cResource, PatchRequestBody\\u003e;\\r\\n  ```\\r\\n\\r\\n#### Templates for Async POST (Action) Operations\\r\\n\\r\\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation.\\n\\nusing the `LroHeaders` parameter.\\r\\n\\r\\n  ```tsp\\r\\n  op update is ArmResourcePatchAsync\\u003cResource, ResourceProperties\\u003e;\\r\\n  ```\\r\\n\\r\\n- `ArmCustomPatchAsync` is a PATCH operation that allows you to customize the PATCH request body.\\r\\n\\r\\n  ```tsp\\r\\n  op update is ArmCustomPatchAsync\\u003cResource, PatchRequestBody\\u003e;\\r\\n  ```\\r\\n\\r\\n#### Templates for Async POST (Action) Operations\\r\\n\\r\\n- `ArmResourceActionAsync` is a POST operation that allows you to specify the request and response body for a resource action operation. It follows the required 202 pattern to resolve the LRO via location, although this can be customized using the `LroHeaders` parameter.\\r\\n\\r\\n  ```tsp\\r\\n  op doStuff is ArmResourceActionAsync\\u003cResource, ActionRequest, ActionResponse\\u003e;\\r\\n\\r\\n  // With no request body\\r\\n  op doStuffNoRequest is ArmResourceActionAsync\\u003cResource, void, ActionResponse\\u003e;\\r\\n\\r\\n  // With no response body\\r\\n  op doStuffCommand is ArmResourceActionAsync\\u003cResource, ActionRequest, void\\u003e;\\r\\n  ```\\r\\n\\r\\n#### Templates for Async DELETE Operations\\r\\n\\r\\n- `ArmResourceDeleteWithoutOKAsync` is a DELETE operation that uses no request body, will return a `202` response in the case of an asynchronous delete operation, and a `204` response in case the resource does not exist.\\r\\n\\r\\n  ```tsp\\r\\n  op delete is ArmResourceDeleteWithoutOKAsync\\u003cResource\\u003e;\\r\\n  ```\\r\\n\\r\\n- `ArmResourceDeleteAsync` is a DELETE operation that uses no request body, and returns a `200` response in the case of a successful synchronous delete, a `202` response in the case of an asynchronous delete operation, and a `204` response in case the resource does not exist.\\r\\n\\r\\n  ```tsp\\r\\n  op delete is ArmResourceDeleteAsync\\u003cResource\\u003e;\\r\\n  ```\\n\\n### Visibility Changes for `nextLink` and `value` Properties\\n\\nFor the `nextLink` and `value` properties of pageable operation response model, some older specifications marked these values as `readOnly`. This has no impact on the API or on SDKs, you can safely ignore this difference in the spec, and any resulting breaking change violation.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Requirement.md\",\"document_title\":\"Table of Contents\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Requirement\",\"content\":\"# TypeSpec-Requirement.md\\n\\n# Table of Contents\\n\\n- [Overview](#overview)\\r\\n- [Suppressing Failures](#suppressing-failures)\\r\\n- [Renaming Specs](#renaming-specs)\\n\\n# Overview\\n\\nCheck `TypeSpec Requirement` enforces the rule that all \\\"new\\\" specs must use TypeSpec (instead of hand-written Swagger).  A \\\"new\\\" spec is defined as any spec that does **not** have a `stable` version in `main`.\\n\\n# Suppressing Failures\\n\\nIf you need to suppress this check (instead of converting to TypeSpec), add entries to the `suppressions.yaml` for your spec.  Example:\\r\\n\\r\\n```\\r\\n# specification/widget/resource-manager/Microsoft.Widget/Widget/suppressions.yaml\\r\\n- tool: TypeSpecRequirement\\r\\n  paths: \\r\\n    - preview/2022-08-01-preview/**/*.json\\r\\n    - preview/2023-02-01-preview/**/*.json\\r\\n```\\r\\n\\r\\nMore examples: https://github.com/search?q=TypeSpecRequirement+repo%3Aazure%2Fazure-rest-api-specs+path%3A**%2Fsuppressions.yaml\\u0026type=code\\n\\n# Renaming Specs\\n\\nThe check may return a \\\"false positive\\\" if you rename an existing spec folder in a PR, since the new name doesn't exist in `main`.  You can use a suppression in these cases.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Missing APIs in default tag error for typespec conversion PR\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Missing APIs in default tag error for typespec conversion PR\\n\\n## question\\n\\nPR: https://github.com/Azure/azure-rest-api-specs/pull/35346\\r\\nAvocado check: https://github.com/Azure/azure-rest-api-specs/pull/35346/checks?check_run_id=44368323389\\r\\n \\r\\nIs there a way to suppress the missing APIs check only for this PR since it only has typspec conversion but no update to the open API spec?\\r\\nThe check is trying to compare the APIs with previous stable release with currently published stable release.\\n\\n## answer\\n\\nPart of the typespec conversion is replacing the existing swagger with a generated swagger.  The generated swagger is still used for some purposes, and Avocado protects the ability to process it. The generated swagger needs to be equivalent, but not necessarily identical.  Generally these issues reflected in the swagger will also show up in breaking change checks, which will have to be resolved (or suppressed if they are false positives)\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_14.md\",\"document_title\":\"Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_14.md\\n\\n# Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221\\n\\n## question\\n\\nHi I'm looking for someone to help suppress CI Failure on this PR [new addProxyAgentExtension property for proxyagentsettings by huiminyan2017 · Pull Request #36221 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/36221)\\r\\n \\r\\nCompute has multiple API versions so the Avacado check failure is expected.\\n\\n## answer\\n\\nYour PR is to a feature branch, so no checks are required.\\r\\n \\r\\nHowever, your PR may be blocked when you try to merge to main, so I recommend following the instructions here now:\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#multiple_api_version\\r\\n```\\r\\nMULTIPLE_API_VERSION\\r\\nRule MULTIPLE_API_VERSION was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this Uniform Versioning Violation Guide wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Seeking Guidance on Defining ResourceStatusCode in TypeSpec\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Seeking Guidance on Defining ResourceStatusCode in TypeSpec\\n\\n## question\\n\\nHello \\r\\nTypeSpec Discussion\\r\\nI am working on defining a `ResourceStatusCode` in TypeSpec, which is similar to HTTP status codes but specific to resource states. I would appreciate your guidance on the following:\\r\\n1. Should I use an `enum` or a `int` to define the `ResourceStatusCode`?\\r\\n2. What are the best practices for defining status codes in TypeSpec?\\r\\n3. How can I ensure that the `ResourceStatusCode` remains extensible for future updates?\\r\\nI want to add statuses like:\\r\\n- `NotSpecified: 204 No Content` - This indicates that the request was successful, but there is no content to return.\\r\\n- `Pending: 102 Processing` - This indicates that the server has received and is processing the request, but no response is available yet.\\r\\n- `Running: 202 Accepted` - This indicates that the request has been accepted for processing, but the processing has not been completed.\\r\\n- `Succeeded: 200 OK` - This indicates that the request has succeeded.\\r\\n- `Failed: 500 Internal Server Error` - This indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.\\r\\nThank you for your assistance.\\n\\n## answer\\n\\nAs per one of our previous understanding, we defined similarly as an open union: [azure-rest-api-specs-pr/specification/impact/Impact.Management/connectors.tsp at RPSaaSMaster · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/blob/RPSaaSMaster/specification/impact/Impact.Management/connectors.tsp#L88-L94).  \\r\\n```\\r\\n@doc(\\\"Enum for connector types\\\")\\r\\nunion Platform {\\r\\n  string,\\r\\n\\r\\n  @doc(\\\"Type of Azure Monitor\\\")\\r\\n  AzureMonitor: \\\"AzureMonitor\\\",\\r\\n}\\r\\n```\\r\\nThis explicitly allows any string value. \\r\\nGenerally, the reason for doing this is that you think additional values will be enabled in future versions (or even in this version).  Note that, if you do not make this an open union, then adding any values in any future api-version would be a breaking change (which is why this is recommended). \\r\\nThere are RPaaS extensions for validation that would allow you to reject requests for values that are not valid.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"API-Spec-Review-FAQ.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ\",\"content\":\"ARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this. See documentation: [Update your branch with changes from main](https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish#update-your-branch-with-changes-from-main). |\\r\\n| I need to set up suppressions for LintDiff violations in my PR | See [Adding Scoped Suppressions](https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff) | \\r\\n| I have specific questions about the inner workings of ARM, testing changes to APIs, or rollout/release schedules | Talk to the ARM team: https://aka.ms/armofficehoursinfo |\\r\\n| I see an Avocado error `MULTIPLE_API_VERSION` | There is a coordinated effort to fix this. Reach out to the relevant parties. [This PR](https://github.com/Azure/avocado/pull/157) gives more context on why this was upgraded to an error. If relevant parties agree, the PR can be unblocked by adding the `Approved-Avocado` label to the PR. |\\r\\n| I merged a PR, when does the REST API documentation update on the Learn site? | Docs are published every week on Tuesdays | \\r\\n| If the specs in the standard branches of `RPSaaSMaster` and `RPSaaSDev` are out of sync, who is responsible for syncing them with main? | The spec owner is responsible for syncing their service’s spec files from `main` to `RPSaaSMaster/RPSaaSDev` to ensure consistency across branches. |\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#pipeline.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline\",\"content\":\"# Resolving Pipeline Failures\\n## Swagger BreakingChange\\n### Multiple OpenAPI Files Before Migration\\nThis pipeline will fail if there is more than one OpenAPI file in the latest version. See the detailed explanation in this [issue](https://github.com/Azure/typespec-azure/issues/2194#issue-2844564216).\\r\\n\\r\\nTo properly identify real breaking changes, use the \\\"TypeSpec Migration Validation\\\" pipeline instead:\\r\\n\\r\\n1. Navigate to the TypeSpec Migration Validation pipeline\\r\\n2. Check the report on the \\\"Summary\\\" page\\r\\n3. The output should match exactly what you see in [this step](../01-get-started.md#review-and-adjust-the-typespec) on the local machine\\r\\n4. Review the changes to verify they are expected\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-BreakingChange.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-BreakingChange\",\"content\":\"# AutoRest Exceptions\\nIf `Swagger BreakingChange` fails with `AutoRest threw a runtime error`, the root cause is likely a problem in your spec causing AutoRest to crash.  To debug (all commands run from repo root):\\r\\n\\r\\n1. Determine if the problem is \\\"before\\\" or \\\"after\\\" your PR (or both)\\r\\n   1. Checkout the target branch of your PR (likely `main` or `RPSaaSMaster`)\\r\\n   2. `npm i`\\r\\n   3. Run `@azure/oad` against the copy of your spec in the target branch.  Specify the same path twice, which should always pass unless AutoRest crashes.\\r\\n    ```\\r\\n    $ npx @azure/oad compare \\\\\\r\\n        specification/contosowidgetmanager/resource-manager/Microsoft.Contoso/stable/2021-11-01/contoso.json \\\\\\r\\n        specification/contosowidgetmanager/resource-manager/Microsoft.Contoso/stable/2021-11-01/contoso.json\\r\\n    ```\\r\\n   4. If your spec is valid, this should return `\\\"code\\\":\\\"NoVersionChange\\\"`, since you are comparing the spec to itself.  If your spec is invalid, this will fail with `AutoRest threw a runtime error`, and the stack trace should include `path` properties pointing to the error.  For instance, here's a failure caused by example with a disallowed property:\\r\\n\\r\\n    ```\\r\\n    code: 'OBJECT-ADDITIONAL-PROPERTIES'\\r\\n    params: [ [Array] ]\\r\\n    message: 'Additional properties not allowed: headers'\\r\\n    path: '#/paths/~1executions/post/x-ms-examples/CodeExecution-Execute-Async-Running'\\r\\n    ```\\r\\n\\r\\n   5. If `@azure/oad compare` passed on the copy of your spec in the target branch, repeat these steps on the copy of your spec in the source branch.\\r\\n2. If the problem is \\\"before\\\" your PR, open another PR dedicated to fixing just this problem.  BreakingChanges may fail in this fixup PR, but should pass going forward.\\r\\n3. If the problem is \\\"after\\\" your PR, just fix the problem in your PR.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\n## MULTIPLE_API_VERSION\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#arm-rules.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\",\"content\":\"# ARM Rules, TypeSpec Linting, and Suppression\\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\\r\\n\\r\\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#conversionfix.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/conversionfix\",\"content\":\"# Fixing Converted TypeSpec\\n## Fixing Linter Rules\\nIdeally, the original OpenAPI file will be converted into equivalent TypeSpec following ARM conventions. However, many OpenAPI specifications predate current ARM conventions and are 'grandfathered in' to prevent breaking changes. The equivalent TypeSpec that represents the original OpenAPI file will violate linter rules, and linter suppressions must be added. Check out how to fix linter violations below.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#checklists#migrate-dp-tips.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/checklists/migrate-dp-tips\",\"content\":\"# Migrate data-plane specs\\nThe OpenAPI converter will not be able to accurately represent every part of every API in TypeSpec. This document outlines some common changes you may need to make to a converted TypeSpec to make it conform to your existing service API and pass validation checks.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#01-get-started.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\",\"content\":\"# Getting started with TypeSpec migration\\nWe have created a OpenAPI to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane OpenAPI files. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\\r\\n\\r\\n**_Important!_** Because TypeSpec is more expressive than OpenAPI and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Deprecating-Preview-APIs.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs\",\"content\":\"## Process\\n1. Open a PR deleting one (or more) previews.  All of:\\r\\n   1. TypeSpec sources (`*.tsp`)\\r\\n   2. Example sources (examples closest to `*.tsp` files)\\r\\n   3. Generated swaggers and examples (`preview/YYYY-MM-DD-preview/**`)\\r\\n   4. readme.md (remove tags)\\r\\n2. PR should fail check `Swagger BreakingChange`, but pass all other checks.\\r\\n3. Request approval following the normal process for breaking changes\\r\\n   - https://aka.ms/brch\\r\\n   - azbreakchangereview@microsoft.com\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\nWorkaround is for PR reviewer to apply label `Approved-Avocado` until tool issues are fixed.\\r\\n\\r\\n1. [Allow specs with readme.md in sub-folders under resource-manager](https://github.com/Azure/azure-rest-api-specs/issues/32445)\\r\\n2. [[MISSING_APIS_IN_DEFAULT_TAG] False positive on deprecated APIs](https://github.com/Azure/avocado/issues/150)\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# TypeSpec\\n## `ProvisioningStateMustBeReadOnly`\\nThe root cause is a limitation in how `azure-openapi-validator` and `oav` handle `$ref` siblings:\\r\\n- https://github.com/Azure/azure-openapi-validator/issues/637\\r\\n- https://github.com/Azure/oav/issues/848\\r\\nThe recommended workaround is to add `use-read-only-status-schema: true` to your `tspconfig.yaml`.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"# Convert OpenAPI specs to TypeSpec\\n## Conversion scope\\n- Horizontal conversion: Converting existing Azure OpenAPI specs to TypeSpec should not introduce any changes to the API.\\r\\n- No version revving: No version revving will occur during this process. The focus is solely on converting the existing\\r\\nspecifications to TypeSpec.\\r\\n- SDKs generated for validation only: The SDKs generated from the converted TypeSpec files will be used for validation\\r\\npurposes only. They are not intended for production release.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-tooling.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-tooling\",\"content\":\"# Use tools to create and validate Azure REST APIs specs\\n## [Author With TypeSpec](#tab/author-with-typespec)\\nAuthor specs with TypeSpec (**recommended approach**)\\r\\n\\r\\nREST APIs authored in [TypeSpec](xref:api-typespec) with the [Azure TypeSpec libraries] have validation built in.\\r\\nCompiling the TypeSpec definition will validate the REST API against the Azure API guidelines.\\r\\nThe TypeSpec compiler will also generate an [OpenAPI](xref:api-openapi) definition for the REST API.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e TypeSpec has [plugins for Visual Studio and Visual Studio Code][TypeSpec plugins] that will highlight errors and\\r\\nwarnings in your TypeSpec definition.\\r\\n\\r\\nTypeSpec is the recommended way for generating OpenAPI specs.\"}]",
            "inputs.latency": 362.2064161300659,
            "inputs.response_length": 1512,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/Deprecating-Preview-APIs",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado",
                "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep"
            ],
            "inputs.testcase": "Avocado warning",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1478,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1479,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Avocado warning\\\\n\\\\nquestion: Hi,\\\\nNeed some help on this PR - [Renaming the RP to Lionrock from PlannedQuota by sathchan \\\\u00b7 Pull Request #24569 \\\\u00b7 Azure/azure-rest-\\\\u2026](https://github.com/Azure/azure-rest-api-specs-pr/pull/24569)\\\\n[Swagger Avocado](https://github.com/Azure/azure-rest-api-specs-pr/actions/runs/18212677882) and [Swagger BreakingChange](https://github.com/Azure/azure-rest-api-specs-pr/actions/runs/18212677881/job/51856124052?pr=24569) validations fail, because in this PR we are removing Microsoft.PlannedQuota namespace and the corresponding specification file:\\\\n```\\\\nRPSaaSMaster/specification/plannedquota/resource-manager/Microsoft.PlannedQuota/preview/2025-10-01-preview/plannedQuota.json\\\\n```\\\\nThis is completely expected and safe to remove, as this namespace was created in the [previous PR](https://github.com/Azure/azure-rest-api-specs-pr/pull/24280) and was never in use.\\\\nPlease note, Microsoft.PlannedQuota was neither registered nor in use.\\\\nCould you help on how to bypass this?\\\", \\\"response\\\": \\\"Based on Azure REST API specs PR guidelines, the removal of a never-used, unregistered namespace and its specification file (such as Microsoft.PlannedQuota) is an expected and safe breaking change. However, Swagger Avocado and Swagger BreakingChange validations are designed to block breaking changes by default. \\\\n\\\\nTo proceed, you must request a breaking change approval through the standard Azure process:\\\\n\\\\n1. Open your PR deleting the TypeSpec sources, examples, generated OpenAPI files, and tags in readme.md associated with the unused namespace.\\\\n2. The PR will fail the `Swagger BreakingChange` check, but this is expected.\\\\n3. To unblock, request approval from the Breaking Change Review Board. You should:\\\\n   - Follow the process at https://aka.ms/brch\\\\n   - Email azbreakchangereview@microsoft.com with justification that the namespace was never registered or used, so the removal is benign and does not impact any customers.\\\\n4. Once approved, a reviewer will apply the appropriate approval label (such as `BreakingChange-Approved-Benign`) to your PR, which will bypass the validation failures and allow the PR to proceed.\\\\n\\\\nFor Avocado-specific issues (such as false positives when removing unused APIs), the official workaround is for the PR reviewer to apply the `Approved-Avocado` label until the tooling is updated.\\\\n\\\\nIn summary: Do not attempt to bypass these checks by suppressing or ignoring them. You must follow the breaking change approval process and get the required label(s) applied to your PR.\\\\n\\\", \\\"ground_truth\\\": \\\"Avocado failing when you completely delete a spec folder is a known issue:\\\\n[[MISSING_README] False positive when migrate spec to FSv2 \\\\u00b7 Issue #163 \\\\u00b7 Azure/avocado](https://github.com/Azure/avocado/issues/163)\\\\nIf you need to merge a PR with this failing, add a note to your PR for your ARM reviewer to add label `Approved-Avocado` to unblock your one PR, until the bug in the tool is fixed.\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: TypeSpec Errors as a result of moving existing swaggers to different directory\n\nquestion: In [PR37469](https://github.com/Azure/azure-rest-api-specs/pull/37469) we are moving swagger files related to existing customer facing API that are GA/stable, but are located in a 'preview' directory and are moving them to a 'stable' directory. As a result are getting multiple TypeSpec Errors because these were not created using TypeSpec. There are no plans to change existing released API. Is there any reason these errors cannot be suppressed?\nWould the following suppression be adequate?\n```\n- suppress: TypeSpec\nfrom: <filename>.json\nreason: The reason for this suppression is the API is already released and introducing changes create undo customer risk.\n```",
            "inputs.ground_truth": "Yes, you can suppress the error if this swagger should never be converted to TypeSpec.\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Requirement#suppressing-failures",
            "inputs.response": "Yes, you can suppress TypeSpec Requirement validation errors when moving existing GA/stable swagger files to a new directory, as long as these APIs were not authored in TypeSpec and there are no plans to change the released API. This is a standard and supported scenario for brownfield services not ready to migrate to TypeSpec.\n\nHowever, the suppression format you provided is not fully aligned with the current Azure guidance. Suppressions for TypeSpec Requirement checks must be added to a `suppressions.yaml` file in the root of your service specification folder, and the format should be as follows:\n\n```yaml\n- tool: TypeSpecRequirement\n  path: stable/<version>/**/*.json  # Adjust path as needed to match your moved files\n  reason: Existing GA API, not authored in TypeSpec. Moving files to stable for compliance; migration to TypeSpec is not planned.\n```\n\nYou should use the `tool: TypeSpecRequirement` field and specify the path to the affected .json files (using glob matching as needed). The reason should clearly indicate the business justification for suppression.\n\nThis is an approved and documented suppression scenario, and there are no restrictions against suppressing TypeSpec errors for existing GA/stable APIs being moved for compliance or organization reasons. See the references for examples and additional details.",
            "inputs.context": "[{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#arm-rules.md\",\"document_title\":\"ARM Rules, TypeSpec Linting, and Suppression\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/arm-rules\",\"content\":\"# howtos#arm#arm-rules.md\\n\\n# ARM Rules, TypeSpec Linting, and Suppression\\n\\nARM includes many rules on the structure of resources and the details of resource operations that ensure a consistent user experience when managing services inside Azure. TypeSpec encodes many fo these rules into linting checks that occur on each compilation. If you use an IDE and install the [TypeSpec IDE Tools](../../getstarted/azure-resource-manager/step00.md#installing-ide-tools), violations of rules will show up as yellow highlights in your tsp code. If you hover over these, you will get a message indicating the issue and how to fix it in your specification. If you use the typespec command-line, violations of rules will be printed as warnings, with a description and steps to correct the issue, and a pointer to the location in the specification where the violation occurred.\\r\\n\\r\\nIn the sections below, we will discuss these rules, how they work, and, in cases where a violation is a false positive, or has a reason approved by an ARM reviewer, can be suppressed.\\n\\n## ARM RPC Rules\\n\\nTypeSpec has a set of linting rules that execute whenever the specification is compiled, and in the IDE as you type. Violations are highlighted inline in the spec, or emitted during compilation.\\r\\n\\r\\nFor more information, see [ARM RPC rules](https://eng.ms/docs/products/arm/api_contracts/guidelines/rpc)\\n\\n## Detecting and Suppressing Rule Violations at Design Time\\n\\nViolations of ARM RPC rules will show up at design time as a yellow highlight over the violating type in TypeSpec, and at compile time as an emitted warning with a specific reference in the specification code (line number, position, pointer).\\r\\n\\r\\nHere is an example of a linter warning:\\r\\n\\r\\n```bash\\r\\nDiagnostics were reported during compilation:\\r\\n\\r\\nC:/typespec-samples/resource-manager/zerotrust/main.tsp:38:3 - warning @azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator: Resource POST operation must be decorated with @armResourceAction.\\r\\n\\u003e 38 |   /** Gets the Zero Trust URL for this resource */\\r\\n     |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n\\u003e 39 |   @post\\r\\n     | ^^^^^^^\\r\\n\\u003e 40 |   getZeroTrustUrl(...ResourceInstanceParameters\\u003cZeroTrustResource\\u003e): ZeroTrustUrl | ErrorResponse;\\r\\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n\\r\\nFound 1 warning.\\r\\n\\r\\n```\\r\\n\\r\\nTo suppress the warning, you would use the `#suppress` directive on the type that violates the rule. The directive takes the fully-qualified name of the rule you are suppressing, and a reason for the suppression.\\r\\n\\r\\n```typespec\\r\\n  #suppress \\\"@azure-tools/typespec-azure-resource-manager/arm-resource-operation-missing-decorator\\\" \\\"This is a sample suppression.\\\"\\r\\n  /** Gets the MAA URL for this resource */\\r\\n  @post\\r\\n  getZeroTrustUrl(...ResourceInstanceParameters\\u003cZeroTrustResource\\u003e): ZeroTrustUrl | ErrorResponse;\\r\\n```\\r\\n\\r\\nOf course, in this case, the best resolution would be to follow the advice in the linting rule, and add the `@armResourceAction` decorator.\\r\\n\\r\\n```typespec\\r\\n  @armResourceAction(ZeroTrustResource)\\r\\n  /** Gets the MAA URL for this resource */\\r\\n  @post\\r\\n  getZeroTrustUrl(...ResourceInstanceParameters\\u003cZeroTrustResource\\u003e): ZeroTrustUrl | ErrorResponse;\\r\\n```\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Validation.md\",\"document_title\":\"Table of Contents\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation\",\"content\":\"# TypeSpec-Validation.md\\n\\n# Table of Contents\\n\\n- [Running Locally](#running-locally)\\r\\n- [Examples Source and Destination](#examples-source-and-destination)\\r\\n- [Validation Rule Suppression](#validation-rule-suppression)\\r\\n- [Rules](#rules)\\r\\n  - [SdkTspConfigValidation](#SdkTspConfigValidation)\\r\\n    - [JavaScript](#JavaScript-Sub-Rules)\\r\\n    - [Python](#Python-Sub-Rules)\\r\\n    - [Go](#Go-Sub-Rules)\\r\\n    - [Java](#Java-Sub-Rules)\\r\\n    - [.Net](#Net-Sub-Rules)\\n\\n# Running Locally\\n\\nTo ensure you see the same results from TypeSpecValidation in your PR check and `tsv` on your local machine:\\r\\n1. Merge latest from parent (e.g. `main` or `RPSaaSMaster`) to your PR branch\\r\\n2. Run locally\\r\\n   1. `git clean -xdf` (may revert any local changes)\\r\\n   2. `git pull`\\r\\n   3. `npm ci`\\r\\n   4. `npx tsv specification/widget/resource-manager/Microsoft.Widget/Widget`\\r\\n   5. `git status`\\r\\n   6. If any changes, `git add`, `git commit`, `git push` to update your PR.\\r\\n3. If you are still having problems, try cloning your branch to a new folder, or try on another machine.\\r\\n4. If the problem can be reproduced on a clean machine, request assistance from the [TypeSpec Discussion](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) teams channel.\\n\\n# Examples Source and Destination\\n\\nIf you are having problems with diffs from \\\"tsp compile\\\" related to examples, ensure you understand how examples flow from source to destination.\\r\\nThe **source** of examples is under your TypeSpec source code folder, and the **destination** of examples is under the Swagger folder.  The TypeSpec compiler copies from source to destination.  In our sample: \\r\\n* source\\r\\n  * https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/Contoso.Management/examples/2021-10-01-preview \\r\\n* destination\\r\\n  * https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/resource-manager/Microsoft.Contoso/preview/2021-10-01-preview/examples\\r\\nIf you are changing examples, you must **first** change the copy under your TypeSpec folder, and then run `tsp compile` (or `tsv` which calls `compile`) to update the copies in your Swagger folder.\\n\\n# Validation Rule Suppression\\n\\nYou can suppress specific validation rules within `TypeSpecValidation` by creating or modifying a `suppressions.yaml` file in the root directory of your service specification.\\r\\n\\u003e **Note:** Currently, only the `SdkTspConfigValidation` rule supports suppression.\\n\\n## Suppressing SdkTspConfigValidation Rules\\n\\nThe `SdkTspConfigValidation` rule is responsible for validating emitter options and parameters defined in your `tspconfig.yaml` file. You have the flexibility to suppress this rule entirely or target specific sub-rules within it.\\n\\n### Suppress the Entire SdkTspConfigValidation Rule\\n\\nIf you need to skip **all** validation checks for emitter options and parameters within a particular `tspconfig.yaml` file, you can suppress the entire `SdkTspConfigValidation` rule.\\r\\nTo do this, add or update the `suppressions.yaml` file in your service's root folder with the following content:\\r\\n```yaml\\r\\n- tool: TypeSpecValidation\\r\\n  paths:\\r\\n    # Specify the path to the tspconfig.yaml file where suppression should apply\\r\\n    - /path/to/tspconfig.yaml\\r\\n  rules:\\r\\n    - SdkTspConfigValidation\\r\\n  reason: the-reason-you-want-to-suppress # Explain why this suppression is necessary\\r\\n```\\n\\n### Suppress Specific Sub-rules within SdkTspConfigValidation\\n\\nIf you only need to bypass validation for **specific** emitter options or parameters, you can suppress individual sub-rules.\\r\\nAdd or update your `suppressions.yaml` file with the following structure, specifying the sub-rules to ignore:\\r\\nSub-rule Syntax:\\r\\n- For parameters: `parameters.\\u003cparameter-key\\u003e.default`\\r\\n- For emitter options: `options.\\u003cemitter-name\\u003e.\\u003coption-key\\u003e`\\r\\n- For nested options (e.g., `package-details: name: \\\"xxx\\\"`), use dot notation: `options.\\u003cemitter-name\\u003e.package-details.name`\\r\\n```yaml\\r\\n- tool: TypeSpecValidation\\r\\n  paths:\\r\\n    # Specify the path to the tspconfig.yaml file where suppression should apply\\r\\n    - /path/to/tspconfig.yaml\\r\\n  rules:\\r\\n    - SdkTspConfigValidation\\r\\n  sub-rules:\\r\\n    # Example: Suppress validation for a specific parameter's default value\\r\\n    - parameters.\\u003ckey-to-validate\\u003e.default \\r\\n    # Example: Suppress validation for a specific emitter option\\r\\n    - options.\\u003cemitter-name\\u003e.\\u003ckey-to-validate\\u003e\\r\\n    # Example: Suppress validation for a nested emitter option\\r\\n    - options.\\u003cemitter-name\\u003e.package-details.name \\r\\n  reason: the-reason-you-want-to-suppress # Explain why this suppression is necessary\\r\\n```\\n\\n# Rules\\n\\n## SdkTspConfigValidation\\n\\n### Parameters\\n\\n- **`parameters.default.service-dir`**\\r\\n  - Allowed values: strings that matches the regex `/^sdk\\\\/.*$/`\\r\\n  - example: `sdk/aaa`\\n\\n### JavaScript Sub Rules\\n\\nPlane\\r\\n- [**`@azure-tools/typespec-ts.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L33)\\r\\n  - Allowed values: strings that matches the regex `/^(?:[a-z]+-)+rest$/`\\r\\n  - example: `arm-aaa-rest`\\r\\n- [**`@azure-tools/typespec-ts.options.package-details.name`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L35)\\r\\n  - Allowed values: strings that matches the regex `/^\\\\@azure-rest\\\\/[a-z]+(?:-[a-z]+)*$/`\\r\\n  - example: `@azure-rest/aaa-bbb`\\n\\n\\u003e Please follow the below steps to configure. If you encounter any issues, please seek help in the \\u003ca href=\\\"https://teams.microsoft.com/l/channel/19%3A408c5f1322ee4303b02b5da9c5ff6137%40thread.skype/Language%20-%20JavaScript%20-%20Reviews?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" rel=\\\"noreferrer noopener\\\" title=\\\"https://teams.microsoft.com/l/channel/19%3a408c5f1322ee4303b02b5da9c5ff6137%40thread.skype/language%20-%20javascript%20-%20reviews?groupid=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantid=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" target=\\\"_blank\\\"\\u003eJS channel\\u003c/a\\u003e\\r\\n#### Management Plane\\r\\n- [**`@azure-tools/typespec-ts.options.experimental-extensible-enums`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L32)\\r\\n  - Allowed values: `true`\\r\\n- [**`@azure-tools/typespec-ts.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L30)\\r\\n  - Allowed values: strings that matches the regex `/^arm-[^\\\\/]+$/`\\r\\n  - example: `arm-aaa-bbb`\\r\\n- [**`@azure-tools/typespec-ts.options.package-details.name`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L34)\\r\\n  - Allowed values: strings that matches the regex `/^\\\\@azure\\\\/arm(?:-[a-z]+)+$/`\\r\\n  - example: `@azure/arm-aaa-bbb`\\r\\n#### Data Plane\\r\\n- [**`@azure-tools/typespec-ts.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L33)\\r\\n  - Allowed values: strings that matches the regex `/^(?:[a-z]+-)+rest$/`\\r\\n  - example: `arm-aaa-rest`\\r\\n- [**`@azure-tools/typespec-ts.options.package-details.name`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L35)\\n\\n### Python Sub Rules\\n\\n\\u003e Please follow the below steps to configure. If you encounter any issues, please seek help in the \\u003ca href=\\\"https://teams.microsoft.com/l/channel/19%3A4175567f1e154a80ab5b88cbd22ea92f%40thread.skype/Language%20-%20Python%20-%20Reviews?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" rel=\\\"noreferrer noopener\\\" title=\\\"https://teams.microsoft.com/l/channel/19%3A4175567f1e154a80ab5b88cbd22ea92f%40thread.skype/Language%20-%20Python%20-%20Reviews?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47\\\" target=\\\"_blank\\\"\\u003epython channel\\u003c/a\\u003e\\r\\n#### Management Plane\\r\\n- [**`@azure-tools/typespec-python.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L19)\\r\\n  - Allowed values: strings that matches the regex `/^azure-mgmt(-[a-z]+){1,2}$/`\\r\\n  - example: `azure-mgmt-aaa`\\r\\n- [**`@azure-tools/typespec-python.options.namespace`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L20)\\r\\n  - Allowed values: strings that matches the regex `/^azure\\\\.mgmt(\\\\.[a-z]+){1,2}$/`\\r\\n  - example: `azure.mgmt.aaa`\\r\\n- [**`@azure-tools/typespec-python.options.generate-test`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L21)\\r\\n  - Allowed values: `true`\\r\\n- [**`@azure-tools/typespec-python.options.generate-sample`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.Management/tspconfig.yaml#L22)\\r\\n  - Allowed values: `true`\\r\\n#### Data Plane\\r\\n- [**`@azure-tools/typespec-python.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L18)\\r\\n  - Allowed values: strings that matches the regex `/^azure(-[a-z]+){1,3}$/`\\n\\n- Allowed values: `true`\\r\\n#### Data Plane\\r\\n- [**`@azure-tools/typespec-python.options.package-dir`**](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml#L18)\\r\\n  - Allowed values: strings that matches the regex `/^azure(-[a-z]+){1,3}$/`\\r\\n  - example: `azure-aaa-bbb-ccc`\\n\\n### Go Sub Rules\\n\\n\\u003e Please follow the below steps to configure. If you encounter any issues, please \"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"Table of Contents\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# Swagger-LintDiff.md\\n\\n# Table of Contents\\n\\n- [Running Locally](#running-locally)\\r\\n- [Adding Scoped Suppressions](#adding-scoped-suppressions)\\r\\n- [TypeSpec](#typespec)\\n\\n# Running Locally\\n\\nhttps://github.com/Azure/azure-openapi-validator/wiki#usage\\n\\n# Adding Scoped Suppressions\\n\\nWhen adding suppressions for LintDiff (https://github.com/Azure/autorest/blob/main/docs/generate/suppress-warnings.md), it's recommened to use a `where` clause to scope the suppression to one instance of the error  How to find the JSON path to use for the suppression.\\r\\n1. In the raw log for the \\\"LintDiff\\\" step of the \\\"LintDiff\\\" check, find the line containing the JSON object representing your error.  For example:\\r\\n```\\r\\n{\\\"pluginName\\\":\\\"spectral\\\",\\\"extensionName\\\":\\\"@microsoft.azure/openapi-validator\\\",\\\"level\\\":\\\"error\\\",\\\"message\\\":\\\"Properties of a PATCH request body must not be required, property:endpointType.\\\",\\\"code\\\":\\\"PatchBodyParametersSchema\\\",\\\"details\\\":{\\\"jsonpath\\\":[\\\"paths\\\",\\\"/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}\\\",\\\"patch\\\",\\\"parameters\\\",\\\"2\\\",\\\"schema\\\",\\\"properties\\\",\\\"deadLetterDestination\\\"],\\\"validationCategory\\\":\\\"\\\",\\\"providerNamespace\\\":false,\\\"resourceType\\\":false,\\\"rpcGuidelineCode\\\":\\\"RPC-Patch-V1-10\\\",\\\"range\\\":{\\\"start\\\":{\\\"line\\\":1,\\\"column\\\":0},\\\"end\\\":{\\\"line\\\":1,\\\"column\\\":0}}},\\\"source\\\":[{\\\"document\\\":\\\"file:///mnt/vss/_work/1/azure-rest-api-specs/specification/eventgrid/resource-manager/Microsoft.EventGrid/stable/2025-02-15/EventGrid.json\\\",\\\"position\\\":{\\\"line\\\":2908,\\\"column\\\":13}}]}\\r\\n```\\r\\n2. Paste into VSCode (or another editor) to format for readability.  We are focused on the `jsonpath` property.\\r\\n```\\r\\n{\\r\\n    \\\"pluginName\\\": \\\"spectral\\\",\\r\\n    \\\"extensionName\\\": \\\"@microsoft.azure/openapi-validator\\\",\\r\\n    \\\"level\\\": \\\"error\\\",\\r\\n    \\\"message\\\": \\\"Properties of a PATCH request body must not be required, property:endpointType.\\\",\\r\\n    \\\"code\\\": \\\"PatchBodyParametersSchema\\\",\\r\\n    \\\"details\\\": {\\r\\n        \\\"jsonpath\\\": [\\r\\n            \\\"paths\\\",\\r\\n            \\\"/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}\\\",\\r\\n            \\\"patch\\\",\\r\\n            \\\"parameters\\\",\\r\\n            \\\"2\\\",\\r\\n            \\\"schema\\\",\\r\\n            \\\"properties\\\",\\r\\n            \\\"deadLetterDestination\\\"\\r\\n        ],\\r\\n        ...\\r\\n    },\\r\\n    \\\"source\\\": [\\r\\n        {\\r\\n            \\\"documen\\n\\nrequest body must not be required, property:endpointType.\\\",\\r\\n    \\\"code\\\": \\\"PatchBodyParametersSchema\\\",\\r\\n    \\\"details\\\": {\\r\\n        \\\"jsonpath\\\": [\\r\\n            \\\"paths\\\",\\r\\n            \\\"/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}\\\",\\r\\n            \\\"patch\\\",\\r\\n            \\\"parameters\\\",\\r\\n            \\\"2\\\",\\r\\n            \\\"schema\\\",\\r\\n            \\\"properties\\\",\\r\\n            \\\"deadLetterDestination\\\"\\r\\n        ],\\r\\n        ...\\r\\n    },\\r\\n    \\\"source\\\": [\\r\\n        {\\r\\n            \\\"document\\\": \\\"file:///mnt/vss/_work/1/azure-rest-api-specs/specification/eventgrid/resource-manager/Microsoft.EventGrid/stable/2025-02-15/EventGrid.json\\\",\\r\\n            \\\"position\\\": {\\r\\n                \\\"line\\\": 2908,\\r\\n                \\\"column\\\": 13\\r\\n            }\\r\\n        }\\r\\n    ]\\r\\n}\\r\\n```\\r\\n3. Convert the `jsonpath` array to a string, and add to your suppression:\\r\\n```\\r\\n  - code: PatchBodyParametersSchema\\r\\n    from: EventGrid.json\\r\\n    where: $.paths[\\\"/{scope}/providers/Microsoft.EventGrid/eventSubscriptions/{eventSubscriptionName}\\\"].patch.parameters[2].schema.properties.deadLetterDestination\\r\\n```\\n\\n# TypeSpec\\n\\nCheck `Swagger LintDiff` may fail for the OpenAPI generated from TypeSpec, even if there are no warnings or errors reported from the TypeSpec compiler.  Causes include bugs in the TypeSpec OpenAPI emitter, bugs in LintDiff rules, incompatibilities between TypeSpec and LintDiff, or checks duplicated in TypeSpec and LintDiff.\\r\\nWe are working to address the root causes (where possible).  Until then, we recommend you [suppress](https://aka.ms/pr-suppressions) these LintDiff errors, using a \\\"permanent suppression\\\" with a descriptive \\\"reason\\\".\\n\\n## `AvoidAdditionalProperties`\\n\\nThe use of `Record\\u003cunknown\\u003e` in TypeSpec is discouraged, and there is a TypeSpec lint rule to enforce this.  If you still need to use `Record\\u003cunknown\\u003e`, the OpenAPI spec generated will cause many LintDiff errors of types `AvoidAdditionalProperties` and `PropertiesTypeObjectNoDefinition`.  You will need to suppress both the TypeSpec violation (in TypeSpec source code) and the LintDiff violations.\\n\\n## `AvoidAnonymousParameter`\\n\\n### data-plane\\n\\nData-plane specs can suppress violations of this rule, since it only exists for the benefit of SDKs generated from swagger, and data-plane SDKs are generated directly from TypeSpec.  Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\\n\\n### resource-manager\\n\\nAs an exception to the previous note, resource-manager specs **may** be able to suppress `AvoidAnonymousTypes`, but only if the error is inside a 202 response from a long-running operation (LRO).  It is known that SDKs do not need to generate type names for such responses.\\n\\n## `AvoidAnonymousTypes`\\n\\nData-plane specs can suppress violations of this rule, since it only exists for the benefit of SDKs generated from swagger, and data-plane SDKs are generated directly from TypeSpec.  Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\\n\\n### `LongRunningResourceAction`\\n\\nThere is a known issue where `LongRunningResourceAction` in TypeSpec, generates swagger that causes `AvoidAnonymousTypes`.  These errors should be suppressed until the root cause is fixed.  https://github.com/Azure/typespec-azure-pr/issues/3349\\n\\n## `EvenSegmentedPathForPutOperation`\\n\\nIf `EvenSegmentedPathForPutOperation` is failing for OpenAPI generated from TypeSpec using `@singleton` (OpenAPI path ends with `/default`), we believe this is a false positive: https://github.com/Azure/azure-openapi-validator/issues/646\\n\\n## `IntegerTypeMustHaveFormat`\\n\\nData-plane specs can suppress violations of this rule, since it only exists for the benefit of SDKs generated from swagger, and data-plane SDKs are generated directly from TypeSpec.  Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\\n\\n## `PatchBodyParameterSchema`\\n\\nThe root cause is a bug in typespec-azure:\\r\\nhttps://github.com/Azure/typespec-azure/issues/383.\\r\\nPlease see the issue above for the suggested workaround and apply it directly to the spec TypeSpec sources.  The LintDiff error should **not** be ignored or suppressed.\\n\\n## `PatchPropertiesCorrespondToPutProperties`\\n\\nWe believe this is a false positive: https://github.com/Azure/azure-openapi-validator/issues/642\\n\\n## `PropertiesTypeObjectNoDefinition`\\n\\nThe use of `Record\\u003cunknown\\u003e` in TypeSpec is discouraged, and there is a TypeSpec lint rule to enforce this.  If you still need to use `Record\\u003cunknown\\u003e`, the OpenAPI spec generated will cause many LintDiff errors of types `AvoidAdditionalProperties` and `PropertiesTypeObjectNoDefinition`.  You will need to suppress both the TypeSpec violation (in TypeSpec source code) and the LintDiff violations.\\n\\n## `ProvisioningStateMustBeReadOnly`\\n\\nThe root cause is a limitation in how `azure-openapi-validator` and `oav` handle `$ref` siblings:\\r\\n- https://github.com/Azure/azure-openapi-validator/issues/637\\r\\n- https://github.com/Azure/oav/issues/848\\r\\nThe recommended workaround is to add `use-read-only-status-schema: true` to your `tspconfig.yaml`.\\n\\n## `RequestBodyMustExistForPutPatch`\\n\\nWe believe this is a false positive: https://github.com/Azure/azure-openapi-validator/issues/641\\n\\n## `ResourceNameRestriction`\\n\\nWhether `ResourceNameRestriction` should be applied to enums is an open question:\\r\\nhttps://github.com/Azure/azure-openapi-validator/issues/501\\r\\nhttps://github.com/Azure/azure-openapi-validator/pull/714\\r\\nUntil this is resolved, suppress the errors and discuss with your ARM reviewer.\\n\\n## `XmsEnumValidation`\\n\\nTypeSpec using `OAuth2Auth` may generate the following OpenAPI:\\r\\n``` yaml\\r\\n\\\"type\\\": {\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"description\\\": \\\"OAuth2 authentication\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"oauth2\\\"\\r\\n  ]\\r\\n},\\r\\n```\\r\\n\\r\\nWhich causes error `XmsEnumValidation`.  The recommended workaround is to add `omit-unreachable-types: true` to your `tspconfig.yaml`.\\r\\n\\r\\n## `XmsPageableForListCalls`\\r\\nIf `XmsPageableForListCalls` are failing for OpenAPI generated from TypeSpec using `@singleton` (OpenAPI path ends with `/default`), we believe this is a false positive: https://github.com/Azure/azure-openapi-validator/issues/646\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# design#specs-pr-guides#pr-suppressions.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-suppressions](https://aka.ms/azsdk/pr-suppressions) |\\r\\n|--|--|\\n\\n# Suppress validation failures on a PR\\n\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nOn your Azure REST API specs PR, some of the GitHub check failures (see the `Checks` tab on your PR) can be suppressed.\\r\\nThe suppression can be either just for the PR, or permanent.\\n\\n## To suppress given validation failure\\n\\n1. Determine which failing check you want to suppress: see its name in the `Checks` tab in your PR.\\r\\n1. Determine if you have one of the [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. Determine if you want to suppress the failure only for the PR, or permanently.\\r\\n1. Consult [the suppression cases table](#suppression-cases-table) for instructions corresponding to your case.\\r\\n1. If you want to apply temporary suppression:\\r\\n   1. Mention in a comment on your PR the PR assignee asking to apply the suppression. Provide justification.\\r\\n      See [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. If you applied permanent suppression:\\r\\n   1. It will manifest by the PR getting a label `SuppressionReviewRequired`.\\r\\n   1. Verify the suppression works by the check changing from **failed** to **neutral**.\\r\\n   1. Wait until your suppression is reviewed. If it is approved, the approved will add the `Approved-Suppression` label.\\r\\n   1. Understand the suppression won't be approved if it is not one of the  \\r\\n      [valid suppression reasons](#valid-suppression-reasons) as explained in relevant section.\\n\\n## Suppression cases table\\n\\n|\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met | Not possible                              |                                                      | Not possible                                                    |\\r\\n\\r\\n[1] Applies only if the SDK generation check failed with a breaking change. For details of SDK breaking change suppression, see https://aka.ms/azsdk/sdk-suppression.\\r\\nGeneral SDK generation check failure suppressions are not supported. See [#6509].\\n\\n|\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger SemanticValidation         | See [aka.ms/ci-fix]                       | `Approved-SemanticValidation`                        | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger ModelValidation            | See [aka.ms/ci-fix]                       | `Approved-ModelValidation`                           | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger Breaking Change            | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Breaking Change(Cross-Version)     | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              |\\n\\nTable legend:\\r\\n\\r\\n- `Check name`: Check to suppress.\\r\\n- `PR suppression`: instructions to obtain suppression for given check for given PR only.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n- `Label`: the label your PR will get if your suppression is approved.\\r\\n- `Permanent suppression`: instructions how to get permanent suppression.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n\\r\\n| Check name                         | PR suppression                            | Label                                                | Permanent suppression                                           |\\r\\n|------------------------------------|-------------------------------------------|------------------------------------------------------|-----------------------------------------------------------------|\\r\\n| TypeSpec Requirement               | Not possible                              |                                                      | [suppressions.yaml](#suppressionsyaml)                      |\\r\\n| TypeSpec Validation                | Not possible                              |                                                      | Not possible                                                    |\\r\\n| license/cla                        | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 |\\n\\n|\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-net-track2       | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-go               | See [step 3 in the diagram] but note [1]. | `BreakingChange-Go-Sdk-Suppression-Approved`         | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-java             | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-js               | See [step 3 in the diagram] but note [1]. | `BreakingChange-JavaScript-Sdk-Suppression-Approved` | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met |\\n\\n## suppressions.yaml\\n\\nFile `suppressions.yaml` is used for all checks created in 2024 or later, like\\r\\n`TypeSpec Requirement` and `TypeSpec Validation`.\\r\\n\\r\\nFor simplicity, we recommend adding all suppressions to a single file at the root of your spec folder:\\r\\n\\r\\n```\\r\\nspecification/myservice/suppressions.yaml\\r\\n```\\r\\n\\r\\nAlternatively, you can use multiple files in separate folders.  Currently, tools will use the first\\r\\ninstance of `suppressions.yaml` found walking up the directory tree.  We are planning\\r\\nfuture support for \\\"merging\\\" files up the hierarchy.\\r\\n\\r\\nA suppression follows this general format:\\r\\n\\r\\n```\\r\\n- tool: ToolName\\r\\n  path: applies/to/**/*.json\\r\\n  reason: Why this can't be fixed\\r\\n```\\r\\n\\r\\n`path` uses \\\"glob\\\" matching.  For syntax, see https://www.npmjs.com/package/minimatch.\\r\\n\\r\\nScope your `path` as narrowly as possible.  For example, if a suppression only applies\\r\\nto a single version of your spec:\\r\\n\\r\\n```\\r\\n# good\\r\\n- path: data-plane/Azure.Contoso.WidgetManager/preview/2022-11-01-preview/**/*.json\\r\\n\\r\\n# bad\\r\\n- path: data-plane/**/*.json\\r\\n```\\r\\n\\r\\nWhen in doubt, search the repo for examples:\\r\\n\\r\\nhttps://github.com/search?q=repo%3AAzure%2Fazure-rest-api-specs+path%3A%2F%28%5E%7C%5C%2F%29suppressions%5C.yaml%24%2F\\u0026type=code\\n\\n### `TypeSpec Requirement` check\\n\\nTo suppress `TypeSpec Requirement` check for given pattern of OpenAPI spec .json file paths, provide an entry with\\r\\n`tool` set to `TypeSpecRequirement`. Provide the pattern as `path` and provide a `reason`.\\r\\n\\r\\nExample:\\r\\n\\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: data-plane/**/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## Suppress AutoRest extension\\n\\nTo suppress tooling that is an AutoRest extension (see [the suppressio\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\",\"document_title\":\"Resolving Folder Migration Conflicts: A Guide for PR Authors\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors\",\"content\":\"# Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\\n\\n# Resolving Folder Migration Conflicts: A Guide for PR Authors\\n\\n## Overview\\n\\nWhen folder structure migration PRs (like [#36764](https://github.com/Azure/azure-rest-api-specs/pull/36764)) are merged, they may conflict with ongoing PRs that modify files within the refactored folders. This guide helps PR authors resolve these conflicts more efficiently.\\r\\n\\r\\n\\u003e **Important Note**: If you create a new PR **after** a folder migration is already merged into main, you should not encounter merge conflicts but need to work based on the new folder structure.\\n\\n## Understanding Folder Migration\\n\\nHere's the brief summary of the file changes of folder structure migration PR. we will take the Container Apps as an example.\\n\\n### Folder Structure Change\\n\\n**Before Migration Structure**:\\r\\n```\\r\\nspecification/app/\\r\\n├── Microsoft.App.DynamicSessions/\\r\\n│   ├── *.tsp\\r\\n│   ├── examples/*/*.json\\r\\n│   └── tspconfig.yaml\\r\\n├── resource-manager/\\r\\n|   ├── readme.md\\r\\n|   └── Microsoft.App/\\r\\n|       ├── preview/*/*.json\\r\\n|       └── stable/*/*.json\\r\\n└── data-plane/\\r\\n    ├── readme.md\\r\\n    └── Microsoft.App.DynamicSessions/\\r\\n        └── preview/*/*.json\\r\\n```\\r\\n\\r\\n**After Migration Structure**:\\r\\n```\\r\\nspecification/app/\\r\\n├── resource-manager/Microsoft.App/ContainerApps/\\r\\n│   ├── preview/*/*.json\\r\\n│   ├── stable/*/*.json\\r\\n│   └── readme.md\\r\\n└── data-plane/DynamicSessions/\\r\\n    ├── examples/*/*.json\\r\\n    ├── preview/*/*.json\\r\\n    ├── *.tsp\\r\\n    ├── tspconfig.yaml\\r\\n    └── readme.md\\r\\n```\\r\\n\\r\\n**Key Changes Made**:\\r\\n- TypeSpec files moved with their respective services\\r\\n- Each service now has its own isolated directory structure\\r\\n\\r\\nFor example:\\r\\n- Create a new serviceName folder ContainerApps: Moved from `resource-manager/Microsoft.App/` to `resource-manager/Microsoft.App/ContainerApps/`\\r\\n- The resource-manager readme.md updated paths from `resource-manager/` to `resource-manager/Microsoft.App/ContainerApps`\\r\\n- DynamicSessions TypeSpec: Moved from `Microsoft.App.DynamicSessions/` to `data-plane/DynamicSessions/`\\r\\n- DynamicSessions OpenAPI json files: Moved from `data-plane/Microsoft.App.DynamicSessions/preview/\\u003cversion\\u003e/` to `data-plane/DynamicSessions/preview/\\u003cversion\\u003e/`\\r\\n- The data-plane readme.md updated paths from `Microsoft.App.DynamicSessions/preview/\\u003cversion\\u003e/` to `preview/\\u003cversion\\u003e/`\\n\\n### File Reference Updates Needed\\n\\n1. **Readme.md files** - Update input-file paths:\\r\\n   \\r\\n   **For ContainerApps (Resource Manager)**:\\r\\n   ```yaml\\r\\n   # Before\\r\\n   input-file:\\r\\n     - Microsoft.App/stable/2024-03-01/ContainerApps.json\\r\\n   \\r\\n   # After  \\r\\n   input-file:\\r\\n     - stable/2024-03-01/ContainerApps.json\\r\\n   ```\\r\\n   \\r\\n   **For DynamicSessions (Data Plane)**:\\r\\n   ```yaml\\r\\n   # Before migration - in data-plane/readme.md\\r\\n   input-file:\\r\\n     - Microsoft.App.DynamicSessions/preview/2025-02-02-preview/DynamicSessions.json\\r\\n   \\r\\n   # After migration - in data-plane/DynamicSessions/readme.md  \\r\\n   input-file:\\r\\n     - preview/2025-02-02-preview/DynamicSessions.json\\r\\n   ```\\r\\n\\r\\n2. **tspconfig.yaml files** - Update emitter output directory:\\r\\n   \\r\\n   **DynamicSessions tspconfig.yaml changes**:\\r\\n   ```yaml\\r\\n   # Before migration - in Microsoft.App.DynamicSessions/tspconfig.yaml\\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       emitter-output-dir: \\\"{project-root}/..\\\"\\r\\n       output-file: \\\"{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/DynamicSessions.json\\\"\\r\\n   \\r\\n   # After migration - in data-plane/DynamicSessions/tspconfig.yaml\\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       emitter-output-dir: \\\"{project-root}\\\"\\r\\n       output-file: \\\"{version-status}/{version}/DynamicSessions.json\\\"\\r\\n   ```\\r\\n\\r\\n3. **Common-types references** - Update relative paths in JSON files:\\r\\n   ```json\\r\\n   // Before (in ContainerApps.json)\\r\\n   \\\"$ref\\\": \\\"../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   \\r\\n   // After  \\r\\n   \\\"$ref\\\": \\\"../../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   ```\\r\\n\\r\\n   Fpr mgmt plane TypeSpec, we also need to specify the `arm-common-types` in tspconfig options of `@azure-tools/typespec-autorest`.\\r\\n   ```yaml \\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n   ```\\n\\n// After  \\r\\n   \\\"$ref\\\": \\\"../../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   ```\\r\\n\\r\\n   Fpr mgmt plane TypeSpec, we also need to specify the `arm-common-types` in tspconfig options of `@azure-tools/typespec-autorest`.\\r\\n   ```yaml \\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n   ```\\r\\n\\r\\n4. **Suppressions.yaml** - Update paths in suppressions:\\r\\nAs GitHub recognize this refactor change as to add new API versions in the OpenAPI folder, in order to make sure the TypeSpec requirement check pass. we need to have a suppressions.yaml under serviceName folder \\r\\nand add suppression one by one like this \\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: ./preview/2022-01-01-preview/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n- tool: TypeSpecRequirement\\r\\n  path: ./stable/2025-01-01/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## The impact to ongoing PRs\\n\\n1. If the ongoing PRs are targeting to a release-* or dev-* branch which are not created or syncing from the latest main, we recommend to merge these PRs first.\\r\\n1. If the ongoing PRs are targeting to public main branch, Here's the suggestion to resolve the conflict. \\r\\n\\r\\n      1. Merge latest main \\r\\n          ```\\r\\n          git checkout main\\r\\n          git pull origin main // origin points to Azure rest api specs repo.\\r\\n          git merge main \\u003cyour-pr-branch\\u003e\\r\\n          ```\\r\\n      2. Resolve conflicts  \\r\\n        - For most of the conflicts, accept the incoming changes.  \\r\\n        - If it's unclear, please accept both and then update based on your judgement with the folder structure changes above.  \\r\\n\\r\\n      3. Make sure the new change is aligned with folder structure v2  \\r\\n\\r\\n         There are some cases where the PR is adding a new version in the original location, but the file diffs don't show as conflict. we should move them into the correct place so that it doesn't break the folder structure v2 as instructions in **Understanding Folder Migration sections** \\r\\n\\r\\n      4. clean up the previous folder if exists.\\r\\n\\r\\n  \\r\\n\\r\\n**Important**: It's strongly recommended to understand what's really changed in the folder refactor. Always ensure the new PR doesn't include any things that breaks the folder structure.\\n\\n### After Resolution\\n\\nMake sure to compile the TypeSpec project so that the TypeSpec Validation could pass.\\r\\n\\r\\n1. **Comprehensive validation**:\\r\\n   ```bash\\r\\n   # Run full validation suite\\r\\n   npm ci\\r\\n   npm run lint\\r\\n   npm run validate\\r\\n   \\r\\n   # Test TypeSpec compilation for your service\\r\\n   cd specification/app/data-plane/DynamicSessions/\\r\\n   npx tsp compile .\\r\\n   npx tsp compile . --emit @azure-tools/typespec-autorest\\r\\n   \\r\\n   # Verify generated files match expectations by checking if there's any diff with the OpenAPI json files.\\r\\n   ```\\n\\n## Getting Help\\n\\n### Resources\\n\\n- [Azure Service Version Guidelines](https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline)\\r\\n- [Container Apps Migration PR #36764](https://github.com/Azure/azure-rest-api-specs/pull/36764)\\n\\n### Support Channels\\n\\nIf you encounter complex conflicts that can't be resolved using this guide, please email to azversioning@service.microsoft.com\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_12.md\",\"document_title\":\"Swagger LintDiff Suppression via TypeSpec\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_12.md\\n\\n# Swagger LintDiff Suppression via TypeSpec\\n\\n## question\\n\\nHello all, we are trying to get our spec migration wrapped up, but we are unable to figure out a suppression for `PatchBodyParametersSchema Properties of a PATCH request body must not be required, property:name.`\\r\\n \\r\\nLink to linter errors: [Migrate devcenter to TypeSpec · Azure/azure-rest-api-specs@82edee2](https://github.com/Azure/azure-rest-api-specs/actions/runs/17628981647)\\r\\n```\\r\\nRule\\tMessage\\tRelated RPC [For API reviewers]\\r\\n❌ PatchBodyParametersSchema\\tProperties of a PATCH request body must not be required, property:name. Location: Microsoft.DevCenter/preview/2025-07-01-preview/devcenter.json#L2943\\tRPC-Patch-V1-10\\r\\n❌ PatchBodyParametersSchema\\tProperties of a PATCH request body must not be required, property:name. Location: Microsoft.DevCenter/preview/2025-07-01-preview/devcenter.json#L8164\\tRPC-Patch-V1-10\\r\\n```\\r\\n \\r\\nThis is because a couple of our resource definitions reference the `Sku` definition from ARM common types\\r\\n \\r\\nThe TypeSpec: [Link](https://github.com/Azure/azure-rest-api-specs/blob/82edee201bde3d1de2633221016530141567dd28/specification/devcenter/DevCenter.Management/models.tsp#L1435)\\r\\n```\\r\\n@doc(\\\"Properties of a Dev Box definition. These properties can be updated after the resource has been created.\\\")\\r\\nmodel DevBoxDefinitionUpdateProperties {\\r\\n  @doc(\\\"Image reference information.\\\")\\r\\n  imageReference?: ImageReference;\\r\\n\\r\\n  @doc(\\\"The SKU for Dev Boxes created using this definition.\\\")\\r\\n  sku?: Azure.ResourceManager.CommonTypes.Sku;\\r\\n\\r\\n  @doc(\\\"The storage type used for the Operating System disk of Dev Boxes created using this definition.\\\")\\r\\n  osStorageType?: string;\\r\\n\\r\\n  @doc(\\\"Indicates whether Dev Boxes created with this definition are capable of hibernation. Not all images are capable of supporting hibernation. To find out more see https://aka.ms/devbox/hibernate\\\")\\r\\n  hibernateSupport?: HibernateSupport;\\r\\n}\\r\\n```\\n\\n\\\"string\\\",\\r\\n          \\\"description\\\": \\\"If the service has different generations of hardware, for the same SKU, then that can be captured here.\\\"\\r\\n        },\\r\\n        \\\"capacity\\\": {\\r\\n          \\\"type\\\": \\\"integer\\\",\\r\\n          \\\"format\\\": \\\"int32\\\",\\r\\n          \\\"description\\\": \\\"If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.\\\"\\r\\n        }\\r\\n      },\\r\\n      \\\"required\\\": [\\r\\n        \\\"name\\\"\\r\\n      ]\\r\\n    },\\r\\n```\\r\\n \\r\\nI am unable to figure out a suppression for this in the readme with a directives ([examples](https://github.com/Azure/azure-rest-api-specs/blob/82edee201bde3d1de2633221016530141567dd28/specification/devcenter/resource-manager/readme.md?plain=1#L43)\\r\\n```\\r\\n  - where:\\r\\n    - $.definitions.PoolUpdate.properties.devBoxDefinition.sku\\r\\n    suppress:\\r\\n      - PatchBodyParametersSchema\\r\\n```\\r\\n), and the ARM reviewer has told me that this should be accomplished via a suppression in the TypeSpec. I can't seem to find any examples of this and would really appreciate any help!\\n\\n\\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The storage type used for the Operating System disk of Dev Boxes created using this definition.\\\"\\r\\n        },\\r\\n        \\\"hibernateSupport\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/HibernateSupport\\\",\\r\\n          \\\"description\\\": \\\"Indicates whether Dev Boxes created with this definition are capable of hibernation. Not all images are capable of supporting hibernation. To find out more see https://aka.ms/devbox/hibernate\\\"\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n```\\r\\nThe actual definition of Sku and the required type that's causing the linter error: [Link](https://github.com/Azure/azure-rest-api-specs/blob/82edee201bde3d1de2633221016530141567dd28/specification/common-types/resource-management/v4/types.json#L470)\\r\\n```\\r\\n    \\\"Sku\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"The resource model definition representing SKU\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"name\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The name of the SKU. E.g. P3. It is typically a letter+number code\\\"\\r\\n        },\\r\\n        \\\"tier\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/SkuTier\\\"\\r\\n        },\\r\\n        \\\"size\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. \\\"\\r\\n        },\\r\\n        \\\"family\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"If the service has different generations of hardware, for the same SKU, then that can be captured here.\\\"\\r\\n        },\\r\\n        \\\"capacity\\\": {\\r\\n          \\\"type\\\": \\\"integer\\\",\\r\\n          \\\"format\\\": \\\"int32\\\",\\r\\n          \\\"description\\\": \\\"If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.\\\"\\r\\n        }\\r\\n      },\\r\\n      \\\"required\\\": [\\r\\n        \\\"name\\\"\\r\\n      ]\\r\\n    },\\r\\n```\\n\\n@doc(\\\"The SKU for Dev Boxes created using this definition.\\\")\\r\\n  sku?: Azure.ResourceManager.CommonTypes.Sku;\\r\\n\\r\\n  @doc(\\\"The storage type used for the Operating System disk of Dev Boxes created using this definition.\\\")\\r\\n  osStorageType?: string;\\r\\n\\r\\n  @doc(\\\"Indicates whether Dev Boxes created with this definition are capable of hibernation. Not all images are capable of supporting hibernation. To find out more see https://aka.ms/devbox/hibernate\\\")\\r\\n  hibernateSupport?: HibernateSupport;\\r\\n}\\r\\n```\\r\\nThe generated swagger: [Link](https://github.com/Azure/azure-rest-api-specs/blob/82edee201bde3d1de2633221016530141567dd28/specification/devcenter/resource-manager/Microsoft.DevCenter/preview/2025-07-01-preview/devcenter.json#L9780)\\r\\n```\\r\\n    \\\"DevBoxDefinitionUpdateProperties\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"Properties of a Dev Box definition. These properties can be updated after the resource has been created.\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"imageReference\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/ImageReference\\\",\\r\\n          \\\"description\\\": \\\"Image reference information.\\\"\\r\\n        },\\r\\n        \\\"sku\\\": {\\r\\n          \\\"$ref\\\": \\\"../../../../../common-types/resource-management/v4/types.json#/definitions/Sku\\\",\\r\\n          \\\"description\\\": \\\"The SKU for Dev Boxes created using this definition.\\\"\\r\\n        },\\r\\n        \\\"osStorageType\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The storage type used for the Operating System disk of Dev Boxes created using this definition.\\\"\\r\\n        },\\r\\n        \\\"hibernateSupport\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/HibernateSupport\\\",\\r\\n          \\\"description\\\": \\\"Indicates whether Dev Boxes created with this definition are capable of hibernation. Not all images are capable of supporting hibernation. To find out more see https://aka.ms/devbox/hibernate\\\"\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n```\\n\\n## answer\\n\\nIf you just need to add a suppression for the swagger error in LintDiff, see here:\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff#adding-scoped-suppressions\\r\\n \\r\\nAlso left a comment here, with a correction to the instructions provided by your ARM reviewer.\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/pull/36201#discussion_r2342265620:\\r\\n```\\r\\nCurrently, LintDiff errors can only be suppressed in readme.md, not *.tsp files or suppressions.yaml or anywhere else.\\r\\n\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff#adding-scoped-suppressions\\r\\n\\r\\nTypeSpec Linter errors should be suppressed in the *.tsp themselves.\\r\\n\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Output folder 'ContentUnderstanding' appears to contain TypeSpec-generated swagger files, not generated from the current TypeSpec sources. Perhaps you deleted a version from your TypeSpec, but didn't delete the associated swaggers?\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Output folder 'ContentUnderstanding' appears to contain TypeSpec-generated swagger files, not generated from the current TypeSpec sources. Perhaps you deleted a version from your TypeSpec, but didn't delete the associated swaggers?\\n\\n## question\\n\\n[Pull Request #21772](https://github.com/Azure/azure-rest-api-specs-pr/pull/21772) is currently failing TypeSpec validation because data-plane contains the Swagger for an older preview not specified in main.tsp.  The guidance I got from API board a month ago is that main.tsp should only list the latest preview. API version  But doing so triggered this error. \\r\\nShould this be an error?  Or can we make this into a warning instead?\\n\\n## answer\\n\\nYou should only track the latest preview version in your TypeSpec files.\\r\\nIf there are older preview Swagger files still in the repo, they can remain there for the required 90-day deprecation window, even if they're no longer listed in your .tsp files.\\r\\nWhile TypeSpec validation currently throws an error if Swagger files exist without a matching version in TypeSpec, you can suppress this error by adding an entry to suppressions.yaml in your service's spec folder (not the global one).\\r\\nLonger-term, the goal is to eliminate swagger files entirely, but for now, swagger and TypeSpec coexist. So:\\r\\nKeep only the latest preview in .tsp\\r\\nKeep older generated swagger for 90 days\\r\\nAdd suppressions if needed to prevent TypeSpec validation from failing\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"How to properly update the TypeSpec environment?\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# How to properly update the TypeSpec environment?\\n\\n## question\\n\\nI tried inferring steps from the various installation documents but just managed to break my environment and have no idea how to fix it. \\r\\nI saw a recent post where it was said to run `npm install -g @typespec/compiler` to get the latest (0.66) but it looks like it did not work for me. My compiler is still 0.64.\\r\\n```\\r\\nNORTHAMERICA+darkoa@darkoa-ws MINGW64 /d/Dev/Projects/git/github/azure-rest-api-specs-pr (RPSaaSMaster)\\r\\n$ npm install -g @typespec/compiler\\r\\n\\r\\nchanged 268 packages in 11s\\r\\n\\r\\n34 packages are looking for funding\\r\\n  run `npm fund` for details\\r\\n\\r\\nNORTHAMERICA+darkoa@darkoa-ws MINGW64 /d/Dev/Projects/git/github/azure-rest-api-specs-pr (RPSaaSMaster)\\r\\n$ tsp compile specification/deviceupdate/DeviceUpdate.Edge.Management/\\r\\nTypeSpec compiler v0.64.0\\r\\n\\r\\nDiagnostics were reported during compilation:\\r\\n```\\r\\nI get a bunch of errors, although we made no changes recently. I am guessing those changes were made by the TypeSpec team and I am also guessing that if I manage to properly update tools, the errors should go away. \\r\\nSo, is there a single document that describes how to update the environment to the latest?\\n\\n## answer\\n\\nThe issue you're facing is related to updating your local TypeSpec environment. Here's a summary of the solution:\\r\\nUpdate Local Dependencies:\\r\\nRunning npm install -g @typespec/compiler only updates the global TypeSpec compiler, which is not typically used for local development unless you need access to TypeSpec commands globally.\\r\\nTo properly update your local environment, navigate to your repository and run npm ci. This command installs the exact versions of dependencies specified in the package-lock.json, ensuring consistency.\\r\\nTypeSpec Versions in Repositories:\\r\\nWhen working with repositories like azure-rest-api-specs, you should always install dependencies based on the local package.json and package-lock.json at the root of your branch. This ensures you're using the correct version of TypeSpec and associated tools for your current project.\\r\\nDealing with Configuration Warnings:\\r\\nThe warnings you're seeing (such as missing options for SDK emitters) are configuration-related, not errors. These warnings appear when SDK emitters for specific languages (like Go, Python, C#) are not installed, but they do not affect your immediate work with TypeSpec validation. These can be safely ignored unless you need to work with SDK generation.\\r\\nSuppression and Documentation:\\r\\nIf you want to suppress specific warnings, you can modify the suppressions.yaml file, but it's important to follow the TypeSpec guidelines to ensure proper environment configuration.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_10.md\",\"document_title\":\"Is it so bad to introduce named types to replace unnamed ones?\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_10.md\\n\\n# Is it so bad to introduce named types to replace unnamed ones?\\n\\n## question\\n\\nRE [Yuxia/20250401preview by blankor1 · Pull Request #33507 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/33507#issuecomment-3029062363)\\r\\n \\r\\nI notice a suppression in the typespec PR \\r\\n \\r\\n#suppress \\\"@azure-tools/typespec-client-generator-core/no-unnamed-types\\\" \\\"Backwards compatibility with existing clients.\\\"\\r\\n \\r\\nSounds like the PR author is under the impression its a bad idea to get rid of unnamed types and replace them with named ones, because of concerns about backwards compatibility. Is this actually correct?\\r\\n \\r\\nOr would we consider this a benign change? And a best practice to 'fix' unnamed types by creating named types to replace them?\\n\\n## answer\\n\\nIntroducing named types to replace unnamed ones is not a bad idea—in fact, it's preferred. The linter rule @azure-tools/typespec-client-generator-core/no-unnamed-types exists to encourage naming types. However, in the PR you referenced, there was a suppression added with the justification of \\\"Backwards compatibility with existing clients.\\\"\\r\\n\\r\\nAfter reviewing the context, it seems this suppression may not be necessary. The rule itself is currently disabled due to performance issues, so removing the suppression won’t trigger CI. Conceptually, this is a false positive: the anonymous model created via @bodyRoot is a temporary structure that the SDK won’t use, so it shouldn't be flagged.\\r\\n\\r\\nStill, the current template resolves to a borderline case where the SDK might auto-generate a name. A cleaner approach would be to use @@clientName to rename the body parameter directly, avoiding the anonymous model altogether. This is considered a better practice.\\r\\n\\r\\nSo yes—replacing unnamed types with named ones is generally a good idea, and in this case, the suppression may not be needed.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Typespec Validation Failing on PR due to `typespec-go` configuration missing\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Typespec Validation Failing on PR due to `typespec-go` configuration missing\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\nCI has been failing constantly for our PR ([Azure Load Testing\\\\] Add 2025-03-01-preview Data-Plane APIs by Harshan01 · Pull Request #32585 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/32585)) for Typespec Validation step. The logs show that we are missing the Go SDK configuration and I am able to produce this error locally as well. However, our service doesnt have a Go SDK and we are not planning to put it in scope right now. This check has suddenly started failing for our PRs, what should we do?\\r\\n```\\r\\nExecuting rule：SdkTspConfigVa1idation\\r\\n[SdkTspconfigVa1idation]：validation failed．\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-fakes\\\"．Please add \\\"options.@azure-tools/typespec-go.generate-fakes\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.inject一spans“．Please add \\\"options.@azure-tools/typespec-go.inject一spans.\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.service-dir\\\"．Please add \\\"options.@azure-tools/typespec-go.service-dir\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.package-dir\\\"．Please add\\\"options.@azure-tools/typespec-go.package-dir\\\".\\r\\nPlease See https://aka.ms/azsdk/spec-gen-sdk-config for more info．\\r\\nFor additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.\\r\\n```\\n\\n## answer\\n\\nSuppressing go specific rules worked for me (locally, checking CI now). Thanks Mike. Also FYI Darren Cohen. Here's our suppression file:\\r\\n```yml\\r\\n- tool: TypeSpecValidation\\r\\n  paths:\\r\\n    - tspconfig.yaml\\r\\n  rules:\\r\\n    - SdkTspConfigValidation\\r\\n  sub-rules:\\r\\n    # Suppress validation for a Go emitter options\\r\\n    - options.@azure-tools/typespec-go.generate-fakes\\r\\n    - options.@azure-tools/typespec-go.inject-spans\\r\\n    - options.@azure-tools/typespec-go.service-dir\\r\\n    - options.@azure-tools/typespec-go.package-dir\\r\\n  reason: 'Azure Load Testing does not support a Go SDK currently'\\r\\n```\\r\\nLet me know if I can help with anything!\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_26.md\",\"document_title\":\"Is TypeSpec migration complete for folder: recoveryservicesbackup.\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_26.md\\n\\n# Is TypeSpec migration complete for folder: recoveryservicesbackup.\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\nWe had PR in flight: [Adding stable 2025 08 01 for completeness by risraj10 · Pull Request #37381 · Azure/azure-rest-api-…](https://github.com/Azure/azure-rest-api-specs/pull/37381)\\r\\nHowever, I see that TypeSpec migration was done couple of days ago for this folder. \\r\\nI have cancelled the above PR and trying to raise a new PR. However, just running npx tsp compile without any change is giving errors.\\r\\nAnd also it is making unintended change to OpenAPI json file even to existing version. I guess the tsp and OpenAPI json are not in sync.\\r\\nHence, wanted to check if the migration is really complete for this folder.\\n\\n## answer\\n\\nMain typespec validation should always be passing are you sure you are up you are with dependencies locally?\\r\\nMake sure to follow instructions here https://aka.ms/ci-fix\\r\\nJust to reiterate, this is almost always because you need to pull the latest from the target branch into your local clone of the repo, and re-install dependencies at the root.\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_03.md\",\"document_title\":\"ARM PR Typespec validation - GitHub CI fails but succeeds locally\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_03.md\\n\\n# ARM PR Typespec validation - GitHub CI fails but succeeds locally\\n\\n## question\\n\\nI'm new to Typespec and the only one from my team to try it, so I have no one else to turn to for what I believe is a rookie mistake in my Typespec PR. In my PR (https://github.com/Azure/azure-rest-api-specs/pull/34972) the Typespec validation fails where running `npm exec --no -- tsv specification/nginx/Nginx.Management` returns errors. But when I run this same command locally on my IDE, it succeeds:\\r\\n```\\r\\nexecFile(\\\"C:\\\\\\\\nvm4w\\\\\\\\nodejs\\\\\\\\node.exe\\\", [\\\"--\\\" \\\"C:\\\\\\\\nvm4w\\\\\\\\nodejs\\\\\\\\node_modules\\\\\\\\npm\\\\\\\\bin\\\\\\\\npm-cli.js\\\", \\\"exec\\\", \\\"--no-ttier\\\", \\\"--write\\\",\\\"tspconfig.yaml\\\"])\\r\\n    simple-git [GitExecutor] [SPAWN] git ['status', '--porcelain', '-b', '-u', '--null', '--porcelain', 'C:/Users/briankimutai/source/repos/azure-rest-api-specs/specification/nginx'] +0ms\\r\\n    simple-git [GitExecutor] [HANDLE] retrieving task output complete +522ms\\r\\ntspconfig.yaml 306ms (unchanged)\\r\\nRunning git diff on folder C:/Users/briankimutai/source/repos/azure-rest-api-specs/specification/nginx\\r\\n\\r\\nExecuting rule: SdkTspConfigValidation\\r\\n[SdkTspConfigValidation]: validation passed.\\r\\n\\r\\nPS C:\\\\Users\\\\briankimutai\\\\source\\\\repos\\\\azure-rest-api-specs\\u003e\\r\\n```\\r\\nI believe I'm making a rookie mistake and would appreciate if someone could point it out and unblock us\\n\\n## answer\\n\\nThe reason your TypeSpec validation fails in GitHub CI but succeeds locally is due to a case sensitivity mismatch in your folder naming. Your PR uses NGINX.NGINXPLUS as the RP namespace directory, but the validation check expects Nginx.NginxPlus. Git repositories are case-sensitive, and this discrepancy causes the CI to fail.\\r\\n\\r\\nTo fix this, you have two options:\\r\\n\\r\\nRename your folder and TypeSpec namespace to match Pascal casing (Nginx.NginxPlus), which is the recommended convention. However, this may trigger validation errors if older API versions are not present in main, as the spec will be treated as new and require rewriting in TypeSpec.\\r\\n\\r\\nKeep using NGINX.NGINXPLUS if that’s what your spec has historically used. You can suppress the TypeSpec linter warning and configure the output path in your TypeSpec config like this:\\r\\n```\\r\\noutput-file: \\\"{azure-resource-provider-folder}/NGINX.NGINXPLUS/{version-status}/{version}/openapi.json\\\"\\r\\n```\\r\\nThis way, you avoid rewriting older versions and maintain consistency with your existing structure.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Breaking-Changes.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Breaking-Changes\",\"content\":\"# Table of Contents\\n## How to Suppress the SDK Breaking Changes\\n### Next Steps\\n1. The pull request authors create a file called `sdk-suppressions.yaml` if it doesn't already exist in your service folder in the `azure-rest-api-specs` repository.\\r\\n    - For TypeSpec scenarios, `sdk-suppressions.yaml` should be placed in the root folder of the TypeSpec project, which also contains the `tspconfig.yaml` file. For example, refers to the location for [Contoso.Management](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/Contoso.Management).\\r\\n    - For OpenAPI scenarios, `sdk-suppressions.yaml` should be placed in the `{service}\\\\resource-manager` folder. For example, see the location for the [contosowidgetmanager resource provider](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/resource-manager).\\r\\n\\r\\n2. The pull request authors copy every line under the `Absent SDK breaking changes suppressions` section to the suppression file in the following format:\\r\\n\\r\\n``` yaml\\r\\nsuppressions:\\r\\n  azure-sdk-for-go:\\r\\n    - package: 'sdk/resourcemanager/servicelinker/armservicelinker'\\r\\n      breaking-changes:\\r\\n        - Function `*LinkerClient.BeginCreateOrUpdate` has been removed\\r\\n        - Function `*LinkerClient.NewListPager` has been removed\\r\\n```\\r\\n\\r\\n3. The pull request authors add this suppression file change to your spec pull request. Then the suppressions will be recognized by the bot, and the corresponding suppression label will be added to the spec pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression` will be added to the pull request.\\r\\n\\r\\n4. The SDK reviewers will evaluate the suppressions and either approve them or provide feedback. If the suppressions are approved, the corresponding approval label will be added to the pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression-Approved` will be added to the pull request.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\n## MULTIPLE_API_VERSION\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Requirement.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Requirement\",\"content\":\"# Suppressing Failures\\nIf you need to suppress this check (instead of converting to TypeSpec), add entries to the `suppressions.yaml` for your spec.  Example:\\r\\n\\r\\n```\\r\\n# specification/widget/resource-manager/Microsoft.Widget/Widget/suppressions.yaml\\r\\n- tool: TypeSpecRequirement\\r\\n  paths: \\r\\n    - preview/2022-08-01-preview/**/*.json\\r\\n    - preview/2023-02-01-preview/**/*.json\\r\\n```\\r\\n\\r\\nMore examples: https://github.com/search?q=TypeSpecRequirement+repo%3Aazure%2Fazure-rest-api-specs+path%3A**%2Fsuppressions.yaml\\u0026type=code\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-tooling.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-tooling\",\"content\":\"# Use tools to create and validate Azure REST APIs specs\\n## [Author With TypeSpec](#tab/author-with-typespec)\\nAuthor specs with TypeSpec (**recommended approach**)\\r\\n\\r\\nREST APIs authored in [TypeSpec](xref:api-typespec) with the [Azure TypeSpec libraries] have validation built in.\\r\\nCompiling the TypeSpec definition will validate the REST API against the Azure API guidelines.\\r\\nThe TypeSpec compiler will also generate an [OpenAPI](xref:api-openapi) definition for the REST API.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e TypeSpec has [plugins for Visual Studio and Visual Studio Code][TypeSpec plugins] that will highlight errors and\\r\\nwarnings in your TypeSpec definition.\\r\\n\\r\\nTypeSpec is the recommended way for generating OpenAPI specs.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"# Convert OpenAPI specs to TypeSpec\\n## Conversion scope\\n- Horizontal conversion: Converting existing Azure OpenAPI specs to TypeSpec should not introduce any changes to the API.\\r\\n- No version revving: No version revving will occur during this process. The focus is solely on converting the existing\\r\\nspecifications to TypeSpec.\\r\\n- SDKs generated for validation only: The SDKs generated from the converted TypeSpec files will be used for validation\\r\\npurposes only. They are not intended for production release.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-specs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-specs\",\"content\":\"# Create or update an Azure REST API spec\\n## Create your REST API definition\\n### [TypeSpec](#tab/typespec)\\nServices that use TypeSpec Azure to describe their REST API must include both the TypeSpec source spec and generated OpenAPI\\r\\nspecs in the specs repo.\\r\\n\\r\\nIt is good practice to create a new branch in the specs repo for each new REST API definition that you create.\\r\\nUse this branch to iterate on your REST API definition until it is ready for review.\\r\\n\\r\\n- [Spec directory structure]\\r\\n- See our [tutorial](xref:api-tutorial) for more help.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-repos.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-repos\",\"content\":\"# Azure REST API specs repositories on GitHub\\n## Publishing your spec to the spec repos\\nTo publish your spec to the API specs repositories, you must first understand what kind of API version you are\\r\\ntrying to publish and make a PR to appropriate branch based on that. Read about this in [this article](xref:pr-move-private-to-public).\\r\\n\\r\\n\\u003c!-- links --\\u003e\\r\\n[Azure/azure-rest-api-specs]: https://github.com/Azure/azure-rest-api-specs\\r\\n[Azure/azure-rest-api-specs-pr]: https://github.com/Azure/azure-rest-api-specs-pr\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"# Convert OpenAPI specs to TypeSpec\\n## Conversion process\\n### TypeSpec conversion tool\\nThe OpenAPI to TypeSpec conversion tool helps take on the bulk of the manual conversion labor. It handles both data-plane\\r\\n and management-plane OpenAPI specs. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\\r\\n\\r\\nFor detailed instructions on how to use the conversion tool, refer to the full [documentation](https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started/).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e The conversion tool will not handle all scenarios - some manual conversion work may be required.\"}]",
            "inputs.latency": 423.6409375667572,
            "inputs.response_length": 1336,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Requirement",
                "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors"
            ],
            "inputs.testcase": "TypeSpec Errors as a result of moving existing swaggers to different directory",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1287,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1288,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: TypeSpec Errors as a result of moving existing swaggers to different directory\\\\n\\\\nquestion: In [PR37469](https://github.com/Azure/azure-rest-api-specs/pull/37469) we are moving swagger files related to existing customer facing API that are GA/stable, but are located in a 'preview' directory and are moving them to a 'stable' directory. As a result are getting multiple TypeSpec Errors because these were not created using TypeSpec. There are no plans to change existing released API. Is there any reason these errors cannot be suppressed?\\\\nWould the following suppression be adequate?\\\\n```\\\\n- suppress: TypeSpec\\\\nfrom: <filename>.json\\\\nreason: The reason for this suppression is the API is already released and introducing changes create undo customer risk.\\\\n```\\\", \\\"response\\\": \\\"Yes, you can suppress TypeSpec Requirement validation errors when moving existing GA/stable swagger files to a new directory, as long as these APIs were not authored in TypeSpec and there are no plans to change the released API. This is a standard and supported scenario for brownfield services not ready to migrate to TypeSpec.\\\\n\\\\nHowever, the suppression format you provided is not fully aligned with the current Azure guidance. Suppressions for TypeSpec Requirement checks must be added to a `suppressions.yaml` file in the root of your service specification folder, and the format should be as follows:\\\\n\\\\n```yaml\\\\n- tool: TypeSpecRequirement\\\\n  path: stable/<version>/**/*.json  # Adjust path as needed to match your moved files\\\\n  reason: Existing GA API, not authored in TypeSpec. Moving files to stable for compliance; migration to TypeSpec is not planned.\\\\n```\\\\n\\\\nYou should use the `tool: TypeSpecRequirement` field and specify the path to the affected .json files (using glob matching as needed). The reason should clearly indicate the business justification for suppression.\\\\n\\\\nThis is an approved and documented suppression scenario, and there are no restrictions against suppressing TypeSpec errors for existing GA/stable APIs being moved for compliance or organization reasons. See the references for examples and additional details.\\\", \\\"ground_truth\\\": \\\"Yes, you can suppress the error if this swagger should never be converted to TypeSpec.\\\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Requirement#suppressing-failures\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: Guidelines for revising an already published API spec?\n\nquestion: Hello, we recently published a new API version, however, we realized that a property should have been marked optional. Are there guidelines on how to revise an already published API version? We have not announced this version to our customer yet.",
            "inputs.ground_truth": "Your best next step, is to create a PR fixing the problem.  The \"next steps to merge\" comment should guide you from there, including the breaking change process you may need to follow.",
            "inputs.response": "Azure's official versioning and breaking change policy is very clear: once an API version is published (merged into a production branch), you are generally NOT allowed to make any changes—even non-breaking or compatible changes—within that API version. This applies whether or not the version has been publicly announced or used by customers. The reasoning is to prevent confusion and guarantee contract stability.\n\nHowever, there is a specific exception for cases where the spec does not match the actual implementation (i.e., a bug fix to align the spec with service behavior). If you have not announced the version or onboarded customers, and the property was always optional in the service implementation, you may apply for a breaking change review to get an approval label (such as `BreakingChange-Approved-BugFix` or `Versioning-Approved-BugFix`). This process is documented in the Azure Breaking Changes Policy and spec PR guidelines.\n\nThe recommended approach is:\n1. Start by following the process described at aka.ms/brch (Breaking Change Review process).\n2. Clearly document that this is a bug fix to match the spec to service behavior and that no customers are impacted.\n3. Once approved, you can revise the spec in-place for the published API version.\n\nIf the property change would affect customers (i.e., if it was actually required in the implementation), you MUST NOT revise the published API version. Instead, create a new API version with the correct contract.\n\nIn summary: You may revise a published API version only to fix a bug so the spec matches actual service behavior, and only with explicit approval via the breaking change review process. Otherwise, publish a new API version for any changes—even compatible ones.\n",
            "inputs.context": "[{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#Guidelines.md\",\"document_title\":\"Microsoft Azure REST API Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md\",\"content\":\"# azure#Guidelines.md\\n\\n# Microsoft Azure REST API Guidelines\\n\\n\\u003c!-- cspell:ignore autorest, BYOS, etag, idempotency, maxpagesize, innererror, trippable, nextlink, condreq, etags --\\u003e\\r\\n\\u003c!-- markdownlint-disable MD033 MD049 MD055 --\\u003e\\r\\n\\r\\n\\u003c!--\\r\\nNote to contributors: All guidelines now have an anchor tag to allow cross-referencing from associated tooling.\\r\\nThe anchor tags within a section using a common prefix to ensure uniqueness with anchor tags in other sections.\\r\\nPlease ensure that you add an anchor tag to any new guidelines that you add and maintain the naming convention.\\r\\n--\\u003e\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2025-Mar-28 | Added guidelines about JSON ID and null values                 |\\r\\n| 2024-Mar-17 | Updated LRO guidelines                                         |\\r\\n| 2024-Jan-17 | Added guidelines on returning string offsets \\u0026 lengths         |\\r\\n| 2023-May-12 | Explain service response for missing/unsupported `api-version` |\\r\\n| 2023-Apr-21 | Update/clarify guidelines on POST method repeatability         |\\r\\n| 2023-Apr-07 | Update/clarify guidelines on polymorphism                      |\\r\\n| 2022-Sep-07 | Updated URL guidelines for DNS Done Right                      |\\r\\n| 2022-Jul-15 | Update guidance on long-running operations                     |\\r\\n| 2022-May-11 | Drop guidance on version discovery                             |\\r\\n| 2022-Mar-29 | Add guidelines about using durations                           |\\r\\n| 2022-Mar-25 | Update guideline for date values in headers to follow RFC 7231 |\\r\\n| 2022-Feb-01 | Updated error guidance                                         |\\r\\n| 2021-Sep-11 | Add long-running operations guidance                           |\\r\\n| 2021-Aug-06 | Updated Azure REST Guidelines per Azure API Stewardship Board. |\\r\\n| 2020-Jul-31 | Added service advice for initial versions                      |\\r\\n| 2020-Mar-31 | 1st public release of the Azure REST API Guidelines            |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Introduction\\n\\nThese guidelines apply to Azure service teams implementing _data plane_ APIs. They offer prescriptive guidance that Azure service teams MUST follow ensuring that customers have a great experience by designing APIs meeting these goals:\\r\\n- Developer friendly via consistent patterns \\u0026 web standards (HTTP, REST, JSON)\\r\\n- Efficient \\u0026 cost-effective\\r\\n- Work well with SDKs in many programming languages\\r\\n- Customers can create fault-tolerant apps by supporting retries/idempotency/optimistic concurrency\\r\\n- Sustainable \\u0026 versionable via clear API contracts with 2 requirements:\\r\\n  1. Customer workloads must never break due to a service change\\r\\n  2. Customers can adopt a version without requiring code changes\\r\\n\\r\\nTechnology and software is constantly changing and evolving, and as such, this is intended to be a living document. [Open an issue](https://github.com/microsoft/api-guidelines/issues/new/choose) to suggest a change or propose a new idea. Please read the [Considerations for Service Design](./ConsiderationsForServiceDesign.md) for an introduction to the topic of API design for Azure services. *For an existing GA'd service, don't change/break its existing API; instead, leverage these concepts for future APIs while prioritizing consistency within your existing service.*\\r\\n\\r\\n*Note: If you are creating a management plane (ARM) API, please refer to the [Azure Resource Manager Resource Provider Contract](https://github.com/cloud-and-ai-microsoft/resource-provider-contract).*\\n\\n### Prescriptive Guidance\\n\\nThis document offers prescriptive guidance labeled as follows:\\r\\n\\r\\n:white_check_mark: **DO** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n:ballot_box_with_check: **YOU SHOULD** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:heavy_check_mark: **YOU MAY** consider this pattern if appropriate to your situation. No notification to the Azure HTTP/REST Stewardship Board is required.\\r\\n\\r\\n:warning: **YOU SHOULD NOT** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:no_entry: **DO NOT** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n*If you feel you need an exception, or need clarity based on your situation, please contact the Azure HTTP/REST Stewardship Board **prior** to release of your API.*\\n\\n## Building Blocks: HTTP, REST, \\u0026 JSON\\n\\nThe Microsoft Azure Cloud platform exposes its APIs through the core building blocks of the Internet; namely HTTP, REST, and JSON. This section provides you with a general understanding of how these technologies should be applied when creating your service.\\r\\n\\r\\n\\u003ca href=\\\"#http\\\" name=\\\"http\\\"\\u003e\\u003c/a\\u003e\\n\\n### HTTP\\n\\ncase-sensitive, multiple delimiter\\r\\nUUID      | 123e4567-e89b-12d3-a456-426614174000 (no {}s, hyphens, case-insensitive) [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)\\r\\nDate/Time (Header) | Sun, 06 Nov 1994 08:49:37 GMT [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1)\\r\\nDate/Time (Query parameter) | YYYY-MM-DDTHH:mm:ss.sssZ (with at most 3 digits of fractional seconds) [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)\\r\\nByte array | Base-64 encoded, max length\\r\\nArray      | One of a) a comma-separated list of values (preferred), or b) separate `name=value` parameter instances for each value of the array\\r\\n\\r\\n\\r\\nThe table below lists the headers most used by Azure services:\\r\\n\\r\\nHeader Key          | Applies to | Example\\r\\n------------------- | ---------- | -------------\\r\\n_authorization_     | Request    | Bearer eyJ0...Xd6j (Support Azure Active Directory)\\r\\n_x-ms-useragent_    | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntraceparent         | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntracecontext        | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\naccept              | Request    | application/json\\r\\nIf-Match            | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-None-Match       | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-Modified-Since   | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\nIf-Unmodified-Since | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\ndate                | Both       | Sun, 06 Nov 1994 08:49:37 GMT (see [RFC 7231, Section 7.1.1.2](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2))\\r\\n_content-type_      | Both       | application/merge-patch+json\\n\\nname=\\\"http-header-names-casing\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** specify headers using kebab-casing\\r\\n\\r\\n\\u003ca href=\\\"#http-header-names-case-sensitivity\\\" name=\\\"http-header-names-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header names using case-insensitivity\\r\\n\\r\\n\\u003ca href=\\\"#http-header-values-case-sensitivity\\\" name=\\\"http-header-values-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header values using case-sensitivity if the header name requires it\\r\\n\\r\\n\\u003ca href=\\\"#http-header-date-values\\\" name=\\\"http-header-date-values\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** accept date values in headers in HTTP-Date format and return date values in headers in the IMF-fixdate format as defined in [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1), e.g. \\\"Sun, 06 Nov 1994 08:49:37 GMT\\\".\\r\\n\\r\\nNote: The RFC 7231 IMF-fixdate format is a \\\"fixed-length and single-zone subset\\\" of the RFC 1123 / RFC 5822 format, which means: a) year must be four digits, b) the seconds component of time is required, and c) the timezone must be GMT.\\r\\n\\r\\n\\u003ca href=\\\"#http-header-request-id\\\" name=\\\"http-header-request-id\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** create an opaque value that uniquely identifies the request and return this value in the `x-ms-request-id` response header.\\r\\n\\r\\nYour service should include the `x-ms-request-id` value in error logs so that users can submit support requests for specific failures using this value.\\r\\n\\r\\n\\u003ca href=\\\"#http-allow-unrecognized-headers\\\" name=\\\"http-allow-unrecognized-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** fail a request that contains an unrecognized header. Headers may be added by API gateways or middleware and this must be tolerated\\r\\n\\r\\n\\u003ca href=\\\"#http-no-x-custom-headers\\\" name=\\\"http-no-x-custom-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** use \\\"x-\\\" prefix for custom headers, unless the header already exists in production [[RFC 6648](https://datatracker.ietf.org/doc/html/rfc6648)].\\r\\n\\r\\n**Additional References**\\n\\nAzure services must adhere to the HTTP specification, [RFC 7231](https://tools.ietf.org/html/rfc7231). This section further refines and constrains how service implementors should apply the constructs defined in the HTTP specification. It is therefore, important that you have a firm understanding of the following concepts:\\r\\n\\r\\n- [Uniform Resource Locators (URLs)](#uniform-resource-locators-urls)\\r\\n- [HTTP Request / Response Pattern](#http-request--response-pattern)\\r\\n- [HTTP Query Parameters and Header Values](#http-query-parameters-and-header-values)\\r\\n\\r\\n#### Uniform Resource Locators (URLs)\\r\\n\\r\\nA Uniform Resource Locator (URL) is how developers access the resources of your service. Ultimately, URLs are how developers form a cognitive model of your service's resources.\\r\\n\\r\\n\\u003ca href=\\\"#http-url-pattern\\\" name=\\\"http-url-pattern\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** use this URL pattern:\\r\\n```text\\r\\nhttps://\\u003ctenant\\u003e.\\u003cregion\\u003e.\\u003cservice\\u003e.\\u003ccloud\\u003e/\\u003cservice-root\\u003e/\\u003cresource-collection\\u003e/\\u003cresou\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# design#specs-pr-guides#pr-brch-deep.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-brch-deep](https://aka.ms/azsdk/pr-brch-deep) |\\r\\n| --- | --- |\\n\\n# Deep-dive into breaking changes on spec PRs\\n\\n## Important information about this article\\n\\nThis article provides a deep-dive into breaking changes on spec PRs. It applies if your spec PR has\\r\\n`BreakingChangeReviewRequired` or `VersioningReviewRequired` label.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e This is an advanced deep-dive. If your PR is blocked on breaking changes or versioning issues, you should always\\r\\n\\u003e start by following the guidance at [aka.ms/brch].\\n\\n### Prerequisites\\n\\nThis article assumes you are familiar with [API versions and branches](xref:api-versions-and-branches).\\n\\n### Video overview and slides\\n\\nFor video overview of the breaking changes process, see this [Azure Core Day of Learning talk from March 6, 2024].\\r\\nSlides for the talk are available [here][talk slides].\\n\\n### Summary\\n\\nPer the [PR diagram], the first step of getting your specs PR approved is ensuring your PR obeys the  \\r\\n[Azure Versioning and Breaking Changes Policy]. Relevant details of this policy follow.\\r\\n\\r\\n- Once published, no changes to given API version are allowed, except when fixing the spec to match\\r\\nactual implementation (see the `-Approved-BugFix` labels in this doc).\\r\\nThis applies regardless of whether the API version is for `private preview`, `public preview`, or `GA`.\\r\\n- When introducing a new API version (any `preview` or `GA`), the new API version must be backwards compatible with\\r\\nthe previous, latest `GA` API version.\\r\\n- During a (`private` or `public`) `preview` cycle, a new `preview` API version does not have to be backwards\\r\\ncompatible with the previous `preview` API version.\\r\\n- The rules listed above are checked by automated GitHub checks. The exact ruleset is given in [`oadMessagesRuleMap.ts`].\\r\\nDetails follow.\\n\\n## Breaking changes and versioning issues\\n\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\\n\\n### `BreakingChangeReviewRequired` label\\n\\nThe label `BreakingChangeReviewRequired` is added to your PR if the tooling detects a change that could\\r\\nbe breaking for customers. This can happen in two cases:\\r\\n\\r\\n- In your PR you have possibly introduced a breaking change in a new API version, placed in a new folder,\\r\\nas compared to most recent previous `GA`.\\r\\nThe new API version can be either `preview` or `GA`.\\r\\n  - For example, an existing `GA` API version in leaf folder of `2023-11-15`\\r\\nmay contain API route of `GET .../resoruces/{resourceName}`, but a new `preview` API version of `2024-03-15-preview`\\r\\nmay no longer have this route (REST API path), because you are removing the `resoruces` typo and instead introducing\\r\\n`GET .../resources/{resourceName}` route.\\r\\n- In your PR you are modifying existing `GA` API version in-place. For example, you have recently released\\r\\n`2024-03-18` API version and realized you made a typo and are editing the contents of the leaf folder `2024-03-18`\\r\\ncontaining that API version.\\n\\n### `VersioningReviewRequired` label\\n\\nThe label `VersioningReviewRequired` denotes that your PR has a **versioning issue** possibly violating the  \\r\\n[Azure Versioning and Breaking Changes Policy]. This happens when you made a **non-breaking change**,\\r\\naka **compatible change** to an API version that was already published (merged to a production branch).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e According to [the policy][Azure Versioning and Breaking Changes Policy], compatible (non-breaking changes) are not\\r\\n\\u003e allowed within an existing API version. You must create a new API version. Otherwise, we would confuse our customers\\r\\n\\u003e by having to explain \\\"which version of given API version\\\" has a particular change/feature.\\r\\n\\r\\n`VersioningReviewRequired` label is added by automation if:\\r\\n\\r\\n- You made any compatible changes **within** any API version, `GA` or `preview`.\\r\\n- You made any breaking changes in a `preview` API version.\\r\\n\\r\\nIf your PR has both breaking changes and versioning issues, only `BreakingChangeReviewRequired` label\\r\\nis added to it.\\n\\n### In case there is no latest GA API version\\n\\nIf there is no latest GA OpenAPI spec, then the the cross-version check is instead comparing to\\r\\nlatest available preview if it more than 1 year old.\\r\\n\\r\\nIf neither a GA API version or at least 1 year old preview version exists, then the cross-version check automatically\\r\\npasses.\\n\\n### Diagram explaining breaking changes and versioning issues\\n\\nThe logic for automation adding `BreakingChangeReviewRequired` and `VersioningReviewRequired` labels explained above\\r\\ncan be summarized in the following diagram:\\r\\n\\r\\n![Breaking Changes Confusion Matrix](../../img/breaking_changes_confusion_matrix.png)\\n\\n## Addressing `BreakingChangeReviewRequired`\\n\\nIf your PR is labelled with `BreakingChangeReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the breaking changes in your PR are acceptable, they will be\\r\\napproved by one of these labels:\\n\\n### `BreakingChange-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `BreakingChange-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-UserImpact`\\n\\n- The spec PR describes actual breaking changes to the service.\\r\\n- This is the only case that triggers customer notifications, a 3 year migration period (possibly shorter), etc.\\r\\n- Within this set, the changes may be distinguished further for security or legal compliance, which may be granted\\r\\na shorter migration period.\\r\\n- Details at [aka.ms/brch].\\n\\n### `BreakingChange-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Addressing `VersioningReviewRequired`\\n\\nIf your PR is labelled with `VersioningReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the versioning issue in your PR caused by non-breaking (compatible)\\r\\nchanges is acceptable, the board will approve it by one of these labels:\\n\\n### `Versioning-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `Versioning-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-PrivatePreview`\\n\\nThe API version change that triggered the review is in `private preview`, and non-breaking changes are permitted\\r\\nin the same API version during `private preview`.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-PrivatePreview` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Common misconceptions\\n\\n### FALSE: compatible (non-breaking) changes are allowed in published API versions\\n\\n**Why?**\\r\\n\\r\\nAn API version is a contract, and once the contract is published it cannot be changed.\\r\\nOtherwise, it would create customer confusion about \\\"which version of this API version\\\" are they using.\\r\\n\\r\\nAny change of this kind w\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#VersioningGuidelines.md\",\"document_title\":\"Azure Versioning Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/VersioningGuidelines.md\",\"content\":\"# azure#VersioningGuidelines.md\\n\\n# Azure Versioning Guidelines\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2024-Nov-14 | Azure Service Versioning \\u0026 Breaking Change Guidelines       |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Guidelines\\n\\n**DO** remove retired API versions from the azure-rest-api-specs repo.\\r\\n\\r\\n:white_check_mark: **DO** review any change to service behavior that could disrupt customers with the Azure Breaking Changes review board, even if the change is not part of the API definition.\\r\\n\\r\\nSome examples of behavior changes that must be reviewed are:\\r\\n- Introducing or changing rate limits to be more restrictive than previously\\r\\n- Changing the permissions required to successfully execute an operation\\r\\n\\r\\n:no_entry: **DO NOT** change the behavior of an API version that is available to customers either in public preview or GA.\\r\\nChanges in behavior should always be introduced in a new API version, with prior versions working as before.\\r\\n\\r\\n:no_entry: **DO NOT** introduce breaking changes from a prior GA version just to satisfy ARM or Azure API guidelines.\\r\\n\\r\\nAvoiding breaking changes in a GA API takes precedence over adherence to API guidelines and resolving linter errors.\\r\\n\\r\\n:no_entry: **DO NOT** keep a preview feature in preview for more than 1 year; it must go GA (or be removed) within 1 year after introduction.\\n\\nThis document provides a \\\"Dos and Don'ts\\\" list for complying with the Azure Versioning and Breaking Change Policy,\\r\\nas documented [internally](aka.ms/AzBreakingChangesPolicy) and [externally](https://learn.microsoft.com/azure/developer/intro/azure-service-sdk-tool-versioning).\\r\\n\\r\\n:white_check_mark: **DO** thoroughly ensure/test the API contract is entirely correct before merging it into a production branch of the specs repo.\\r\\n\\r\\nTesting helps avoid \\\"BugFix\\\" changes to the API definition. Testing should be done at the HTTP level as well as through generated SDKs.\\r\\n\\r\\n:white_check_mark: **DO** retire all prior preview API versions 90 days after a new GA or preview API version is released.\\r\\n\\r\\n:white_check_mark: **DO** contact the Azure Breaking Change Review board to coordinate communications to customers\\r\\nwhen releasing an API version requiring the retirement of a prior version.\\r\\n\\r\\n:white_check_mark: **DO** create a new preview API version for any features that should remain in preview following a new GA release.\\r\\n\\r\\n:white_check_mark: **DO** use a date strictly later than the most recent GA API version when releasing\\r\\na new preview API version.\\r\\n\\r\\n:white_check_mark: **DO** deprovision any API version that has been retired. Retired APIs versions should behave like\\r\\nan unknown API version (see [ref](https://aka.ms/azapi/guidelines#versioning-api-version-unsupported)).\\r\\n\\r\\n:white_check_mark: **DO** remove retired API versions from the azure-rest-api-specs repo.\\r\\n\\r\\n:white_check_mark: **DO** review any change to service behavior that could disrupt customers with the Azure Breaking Changes review board, even if the change is not part of the API definition.\\r\\n\\r\\nSome examples of behavior changes that must be reviewed are:\\r\\n- Introducing or changing rate limits to be more restrictive than previously\\r\\n- Changing the permissions required to successfully execute an operation\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#versioning.md\",\"document_title\":\"Versioning\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/versioning\",\"content\":\"# howtos#arm#versioning.md\\n\\n# Versioning\\n\\nThis document explains how to manage versioning in TypeSpec projects, including how to add, remove, or modify resources, operations, and properties across API versions.\\n\\n## Introduction\\n\\nVersioning allows you to evolve your API without breaking existing clients. By using versioning decorators, you can specify when resources, operations, or properties are added, removed, or changed.\\n\\n## Declaring Versions\\n\\nDefine your API versions in an enum. For each version, specify dependencies and common types as needed.\\r\\n\\r\\n```tsp\\r\\n/** Contoso API versions */\\r\\nenum Versions {\\r\\n  /** 2021-10-01-preview version */\\r\\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\\r\\n  v1,\\r\\n\\r\\n  /** 2022-11-01-preview version */\\r\\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\\r\\n  v2,\\r\\n}\\r\\n```\\r\\n\\r\\nAfter defining your enum, link it to your namespace using the `@versioned` decorator:\\r\\n\\r\\n```tsp\\r\\n@versioned(Versions)\\r\\nnamespace Microsoft.ContosoProviderHub;\\r\\n```\\r\\n\\r\\n\\u003e **Note:** Add dependencies and common types for each version. After defining a new version, the emitter will produce outputs for all versions. You can then adapt your TypeSpec code for the latest version.\\n\\n## Simple Scenarios\\n\\nThese examples show how to add models, operations, properties, and parameters in specific versions using TypeSpec versioning decorators.\\n\\n### Adding Decoration to an Existing Type\\n\\nThis scenario demonstrates how to change a decorator’s usage across versions.\\r\\n\\r\\nSuppose you have a model property with a decorator:\\r\\n\\r\\n```tsp\\r\\nmodel Employee {\\r\\n  @visibility(Lifecycle.Read)\\r\\n  experience: string;\\r\\n}\\r\\n```\\r\\n\\r\\nIn the next version (v2), the visibility changes so that the property can be read or created. To achieve this, you can use a combination of `@removed`, `@added`, and `@renamedFrom` decorators:\\r\\n\\r\\n```tsp\\r\\nmodel Employee {\\r\\n  @removed(Versions.v2)\\r\\n  @visibility(Lifecycle.Read)\\r\\n  @renamedFrom(Versions.v2, \\\"experience\\\")\\r\\n  oldExperience: string;\\r\\n\\r\\n  @added(Versions.v2)\\r\\n  @visibility(Lifecycle.Read, Lifecycle.Create)\\r\\n  experience: string;\\r\\n}\\r\\n```\\n\\n### Adding a Parameter to an Operation and Making Another Parameter Optional\\n\\nThis scenario shows how to add a parameter and make another optional in an operation.\\r\\n\\r\\nSuppose you start with the following operation in v1:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  listBySubscription is ArmListBySubscription\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      @header\\r\\n      location: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\nIn version `v2`, you want to:\\r\\n\\r\\n- Make the `location` header parameter optional.\\r\\n- Add a new optional query parameter `orderBy`.\\r\\n\\r\\nYou can achieve this using the `@madeOptional` and `@added` decorators:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  listBySubscription is ArmListBySubscription\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      @madeOptional(Versions.v2)\\r\\n      @header\\r\\n      location?: string;\\r\\n\\r\\n      @added(Versions.v2)\\r\\n      @query(\\\"order-by\\\")\\r\\n      orderBy?: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\n**Explanation:**\\r\\n\\r\\n- `@madeOptional(Versions.v2)` makes `location` optional starting in v2.\\r\\n- `@added(Versions.v2)` adds the `orderBy` query parameter in v2 and later.\\n\\n### Converting an Operation from Synchronous to Asynchronous\\n\\nThis scenario illustrates converting a synchronous operation to an asynchronous one across versions.\\r\\n\\r\\nSuppose you start with the following synchronous operation in `v1`:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceSync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\nIn version `v2`, you update this operation to be asynchronous as follows:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  @removed(Versions.v2)\\r\\n  @renamedFrom(Versions.v2, \\\"createOrUpdate\\\")\\r\\n  @sharedRoute\\r\\n  createOrUpdateV1 is ArmResourceCreateOrReplaceSync\\u003cEmployee\\u003e;\\r\\n\\r\\n  @added(Versions.v2)\\r\\n  @sharedRoute\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\n**Explanation:**\\r\\n\\r\\n- `@removed(Versions.v2)` removes the original synchronous operation in v2 and later.\\r\\n- `@renamedFrom(Versions.v2, \\\"createOrUpdate\\\")` keeps the original name for v1.\\r\\n- `@added(Versions.v2)` adds the new asynchronous operation in v2 and later.\\r\\n- `@sharedRoute` ensures both operations can use the same route.\\n\\n## Versioning Decorators\\n\\n### @added\\n\\nYou can add new models, properties, or operations in a specific version and all subsequent versions using the `@added` decorator.\\r\\n\\r\\n- The `version` argument is the version where the element is introduced.\\r\\n- The element will be present in that version and all later versions.\\r\\n\\r\\n**Example: Adding a model and property across versions**\\r\\n\\r\\nFor example, suppose you want to add a new model and then add a property to it in a later version:\\r\\n\\r\\n```tsp\\r\\n// v1: No Employee model exists\\r\\n\\r\\n// v2: Add Employee model\\r\\n@added(Versions.v2)\\r\\nmodel Employee {\\r\\n  name?: string;\\r\\n}\\r\\n\\r\\n// v3: Add 'city' property to Employee\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n\\r\\n  @added(Versions.v3)\\r\\n  city?: string;\\r\\n}\\r\\n```\\r\\n\\r\\n**Example: Adding an operation in a later version**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n  // v3: Add createOrUpdate operation\\r\\n  @added(Versions.v3)\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\n\\n### @removed\\n\\nTo remove models, properties, or operations starting from a specific version, use the `@removed` decorator.\\r\\n\\r\\n- The `version` argument is the version where the element is removed.\\r\\n- The element will not be present in that version or any later versions.\\r\\n\\r\\n**Example: Removing a property and a model across versions**\\r\\n\\r\\nFor example:\\r\\n\\r\\n```tsp\\r\\n// v1: Employee model with 'city' property\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n  city?: string;\\r\\n}\\r\\n\\r\\n// v2: Remove 'city' property\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n\\r\\n  @removed(Versions.v2)\\r\\n  city?: string;\\r\\n}\\r\\n\\r\\n// v3: Remove Employee model entirely\\r\\n@removed(Versions.v3)\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n}\\r\\n```\\r\\n\\r\\n**Example: Removing an operation**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n  @removed(Versions.v3)\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\n\\n### @madeRequired and @madeOptional\\n\\nUse these decorators to change whether a property is required or optional in a specific version.\\r\\n\\r\\n- Use `@madeOptional(Versions.version)` to make a property optional starting in that version.\\r\\n- Use `@madeRequired(Versions.version)` to make a property required starting in that version.\\r\\n\\r\\n**Example: Changing a property from required to optional, then back to required**\\r\\n\\r\\nFor example:\\r\\n\\r\\n```tsp\\r\\n// v1: movingStatus is required\\r\\nmodel MoveResponse {\\r\\n  movingStatus: string;\\r\\n}\\r\\n\\r\\n// v2: movingStatus becomes optional\\r\\nmodel MoveResponse {\\r\\n  @madeOptional(Versions.v2)\\r\\n  movingStatus?: string;\\r\\n}\\r\\n```\\n\\n### @renamedFrom\\n\\nUse `@renamedFrom` to rename models, properties, operations, enums, etc., in a specific version.\\r\\n\\r\\n- The `version` argument is the version where the name changed.\\r\\n- The `oldName` argument is the previous name.\\r\\n\\r\\n**Example: Renaming a property and a model across versions**\\r\\n\\r\\nFor example:\\r\\n\\r\\n```tsp\\r\\n// v1: Model and property have original names\\r\\nmodel WorkerProperties {\\r\\n  state?: string;\\r\\n}\\r\\n\\r\\n// v2: Rename property 'state' to 'city'\\r\\nmodel WorkerProperties {\\r\\n  @renamedFrom(Versions.v2, \\\"state\\\")\\r\\n  city?: string;\\r\\n}\\r\\n\\r\\n// v3: Rename model 'WorkerProperties' to 'EmployeeProperties'\\r\\n@renamedFrom(Versions.v3, \\\"WorkerProperties\\\")\\r\\nmodel EmployeeProperties {\\r\\n  @renamedFrom(Versions.v2, \\\"state\\\")\\r\\n  city?: string;\\r\\n}\\r\\n```\\n\\n## FAQ\\n\\n### How do I version a pattern?\\n\\nI have this model and I would like to change the pattern in v2\\r\\n\\r\\n```tsp\\r\\nmodel EmployeeProperties {\\r\\n  @pattern(\\\"^[a-z]+$\\\")\\r\\n  state: string;\\r\\n}\\r\\n```\\r\\n\\r\\n:::caution\\r\\n\\r\\nUpdating a pattern could be a breaking change:\\r\\n\\r\\n- A **more restrictive pattern** for input data would break existing clients that send previously valid data\\r\\n- A **less restrictive pattern** for output data could break client assumptions and validation logic\\r\\n\\r\\n:::\\r\\n\\r\\nThe key question is: **Does the pattern change apply to all API versions, or only to the new version?**\\r\\n\\r\\n#### 1. Pattern changes for all versions\\r\\n\\r\\nIf the pattern change reflects how your service actually behaves across all versions, update the pattern directly. The specification should accurately reflect the current state of your service.\\r\\n\\r\\n```diff lang=tsp\\r\\nmodel EmployeeProperties {\\r\\n-  @pattern(\\\"^[a-z]+$\\\")\\r\\n+  @pattern(\\\"^[a-zA-Z]+$\\\")\\r\\n   state: string;\\r\\n}\\r\\n```\\r\\n\\r\\n:::note\\r\\nThis will update all openapi specs versions with the new pattern which is the desired behavior.\\r\\n:::\\r\\n\\r\\n#### 2. Different patterns per version (**Very unlikely**)\\r\\n\\r\\nIf older API versions truly enforce a different pattern than newer versions, you need to model this explicitly using versioning decorators:\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"libraries#versioning#guide.md\",\"document_title\":\"Tutorial\",\"document_link\":\"https://typespec.io/docs/libraries/versioning/guide\",\"content\":\"# libraries#versioning#guide.md\\n\\n# Tutorial\\n\\n## Implementing versioned APIs\\n\\nThe primary role of the TypeSpec.Versioning library is to enable API versioning. Let's start with an API that lacks versioning.\\r\\n\\r\\n```typespec\\r\\n@service(#{ title: \\\"Contoso Widget Manager\\\" })\\r\\nnamespace Contoso.WidgetManager;\\r\\n```\\r\\n\\r\\nTo introduce versioning to this API, we need to use the `@versioned` decorator on the namespace and define an enum that outlines the supported versions.\\r\\n\\r\\n```typespec\\r\\n@service(#{ title: \\\"Contoso Widget Manager\\\" })\\r\\n@versioned(Contoso.WidgetManager.Versions)\\r\\nnamespace Contoso.WidgetManager;\\r\\n\\r\\nenum Versions {\\r\\n  v1,\\r\\n}\\r\\n```\\n\\n## Declaring versioned dependencies\\n\\nBoth versioned and unversioned services can declare their dependencies on versioned TypeSpec libraries. This is achieved using the `@useDependency` decorator. For unversioned services, this is declared on the namespace. For versioned services, it's declared on the versioned enum.\\r\\n\\r\\nFor example, if our unversioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\\r\\n\\r\\n```typespec\\r\\n@service(#{ title: \\\"Contoso Widget Manager Unversioned\\\" })\\r\\n@useDependency(Azure.Core.v1_0_Preview_1)\\r\\nnamespace Contoso.WidgetManager.Unversioned;\\r\\n```\\r\\n\\r\\nIf our versioned WidgetManager service depends on the Azure.Core library, we would declare it like this:\\r\\n\\r\\n```typespec\\r\\n@service(#{ title: \\\"Contoso Widget Manager\\\" })\\r\\n@versioned(Contoso.WidgetManager.Versions)\\r\\nnamespace Contoso.WidgetManager;\\r\\n\\r\\nenum Versions {\\r\\n  @useDependency(Azure.Core.v1_0_Preview_1)\\r\\n  v1,\\r\\n}\\r\\n```\\r\\n\\r\\nLet's say we introduce a new version to our service, and it uses features from a newer version of the Azure.Core library. We can declare that dependency like this:\\r\\n\\r\\n```typespec\\r\\n@service(#{ title: \\\"Contoso Widget Manager\\\" })\\r\\n@versioned(Contoso.WidgetManager.Versions)\\r\\nnamespace Contoso.WidgetManager;\\r\\n\\r\\nenum Versions {\\r\\n  @useDependency(Azure.Core.v1_0_Preview_1)\\r\\n  v1,\\r\\n\\r\\n  @useDependency(Azure.Core.v1_0_Preview_2)\\r\\n  v2,\\r\\n}\\r\\n```\\n\\n## Versioning APIs\\n\\nreflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\\r\\n\\r\\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\\r\\n\\r\\n```yaml\\r\\nWidget:\\r\\n  type: object\\r\\n  properties:\\r\\n    id:\\r\\n      type: string\\r\\n    description:\\r\\n      type: string\\r\\n  required:\\r\\n    - id\\r\\n```\\r\\n\\r\\nHowever, the OpenAPI definition for versions 1 and 2 still reflect the original name and the mandatory nature of the property:\\r\\n\\r\\n```yaml\\r\\nWidget:\\r\\n  type: object\\r\\n  properties:\\r\\n    id:\\r\\n      type: string\\r\\n    name:\\r\\n      type: string\\r\\n  required:\\r\\n    - id\\r\\n    - name\\r\\n```\\r\\n\\r\\nThis is a common pattern with the versioning decorators. The TypeSpec should represent the _current state_ of the API. The decorators indicate the version at which this definition became accurate and, depending on the decorator, the other parameters reflect the previous values to retain that information.\\n\\nThe versioning library simplifies the process of versioning APIs. Let's start with a basic example. Assume we have a service with a single API that returns a list of widgets. We can define that API like this:\\r\\n\\r\\n```typespec\\r\\nusing Versioning;\\r\\nusing Rest;\\r\\nusing Http;\\r\\n\\r\\n@service(#{ title: \\\"Contoso Widget Manager\\\" })\\r\\n@versioned(Contoso.WidgetManager.Versions)\\r\\nnamespace Contoso.WidgetManager;\\r\\n\\r\\nenum Versions {\\r\\n  v1,\\r\\n}\\r\\n\\r\\n@error\\r\\nmodel Error {\\r\\n  code: string;\\r\\n  message?: string;\\r\\n}\\r\\n\\r\\nmodel Widget {\\r\\n  @key\\r\\n  id: string;\\r\\n\\r\\n  name: string;\\r\\n}\\r\\n\\r\\nop list(): Widget[] | Error;\\r\\n```\\r\\n\\r\\nNow, let's suppose that in version 2 of the service, we add a get operation to retrieve a single widget. We can add that like this:\\r\\n\\r\\n```typespec\\r\\nenum Versions {\\r\\n  v1,\\r\\n  v2,\\r\\n}\\r\\n\\r\\nmodel Widget {\\r\\n  @key\\r\\n  id: string;\\r\\n\\r\\n  name: string;\\r\\n}\\r\\n\\r\\n@route(\\\"/widget\\\")\\r\\nop list(): Widget[] | Error;\\r\\n\\r\\n@added(Versions.v2)\\r\\n@route(\\\"/widget/{id}\\\")\\r\\nop get(...Resource.KeysOf\\u003cWidget\\u003e): Widget | Error;\\r\\n```\\r\\n\\r\\nNow, let's suppose that in version 3 of the service, we realize that `name` is not accurate and that this field should be called `description`. Also, we decide that the description should be optional, not mandatory. We can implement these changes like this:\\r\\n\\r\\n```typespec\\r\\nmodel Widget {\\r\\n  @key\\r\\n  widgetId: string;\\r\\n\\r\\n  @renamedFrom(Versions.v3, \\\"name\\\")\\r\\n  @madeOptional(Versions.v3)\\r\\n  description?: string;\\r\\n}\\r\\n```\\r\\n\\r\\nWe made the change to the actual model property so that it now reflects the correct name and optional nature of the property. Both the `@renamedFrom` and `@madeOptional` decorators indicate the version in which the change was made, and the `@renamedFrom` decorator also identifies the previous name of the property. This allows us to generate code that is aware of the change and can handle it appropriately.\\r\\n\\r\\nThe OpenAPI definition of `Widget` for version 3 reflects the change:\\r\\n\\r\\n```yaml\\r\\nWidget:\\r\\n  type: object\\r\\n  properties:\\r\\n    id:\\r\\n      type: string\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Is it possible to make a field to be optional only on new api version?\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Is it possible to make a field to be optional only on new api version?\\n\\n## question\\n\\nHi TypeSpec Discussion,\\r\\n \\r\\nIn swagger, we have below data model. We want to make StageSpec.specification to be optional from 2025-06-01-preview version, but for older versions, it is still mandatory.\\r\\n \\r\\nI tried below implementation, but it failed during tsp compile. Compiler complains the field name is duplicated.\\r\\n \\r\\nIs there any way to achieve this? Really appreciate if there's any examples.\\r\\n```\\r\\nDiagnostics were reported during compilation:\\r\\n \\r\\n\\u001b[36mWorkflowVersion.tsp\\u001b[39m:\\u001b[33m95\\u001b[39m:\\u001b[33m3\\u001b[39m - \\u001b[31merror\\u001b[39m \\u001b[90mduplicate-property\\u001b[39m: Model already has \\r\\na property named specification\\r\\n\\u003e 95 |   specification?: Record\\u003cunknown\\u003e;\\r\\n     |   ^^^^^^^^^^^^^\\r\\n \\r\\nFound 1 error.\\r\\n```\\r\\n```\\r\\n@doc(\\\"Stage Properties\\\")\\r\\nmodel StageSpec {\\r\\n  @doc(\\\"Name of Stage\\\")\\r\\n  name: string;\\r\\n\\r\\n  @removed(Versions.v2025_06_01_preview)\\r\\n  @doc(\\\"Target ARM id\\\")\\r\\n  targetId?: string;\\r\\n\\r\\n  #suppress \\\"@azure-tools/typespec-azure-core/no-unknown\\\" \\\"Suppress no-unknown to handle the datatype object used in dependent service\\\"\\r\\n  #suppress \\\"@azure-tools/typespec-azure-resource-manager/arm-no-record\\\" \\\"Suppress arm-no-record to handle the datatype object used in dependent service\\\"\\r\\n  @doc(\\\"Stage specification\\\")\\r\\n  @removed(Versions.v2025_06_01_preview)\\r\\n  specification: Record\\u003cunknown\\u003e;\\r\\n\\r\\n  #suppress \\\"@azure-tools/typespec-azure-core/no-unknown\\\" \\\"Suppress no-unknown to handle the datatype object used in dependent service\\\"\\r\\n  #suppress \\\"@azure-tools/typespec-azure-resource-manager/arm-no-record\\\" \\\"Suppress arm-no-record to handle the datatype object used in dependent service\\\"\\r\\n  @doc(\\\"Stage specification\\\")\\r\\n  @added(Versions.v2025_06_01_preview)\\r\\n  specification?: Record\\u003cunknown\\u003e;\\r\\n\\r\\n  @added(Versions.v2025_06_01_preview)\\r\\n  @doc(\\\"List of tasks in the stage\\\")\\r\\n  tasks: TaskSpec[];\\r\\n\\r\\n  @added(Versions.v2025_06_01_preview)\\r\\n  @doc(\\\"Task option for the stage\\\")\\r\\n  taskOption?: TaskOption;\\r\\n}\\r\\n```\\n\\n## answer\\n\\nYou should use the @madeOptional decorator, here: [Decorators | TypeSpec](https://typespec.io/docs/libraries/versioning/reference/decorators/#@TypeSpec.Versioning.madeOptional).  Note that, making a property that occurs in responses optional is considered a breaking change.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_17.md\",\"document_title\":\"Guidelines to Implement Custom Patch\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_17.md\\n\\n# Guidelines to Implement Custom Patch\\n\\n## question\\n\\nHi Team! We are planning to implement a custom model for patch. Are there any guidelines available for this? I found some information about \\\"TrackedResourceUpdate,\\\" but it doesn't seem to be included in the package anymore.\\r\\nIf you have any examples, especially on implementing the model for Properties and referencing it for patch calls, that would be very helpful.\\n\\n## answer\\n\\n59QCuCj4%2BPj47Cu8BTMogxn3kAVzrAQfSJ8RD5AG0VGhlIFBBVENIIMZRZm9yIOQA9MQu5QKwzmjGXgog12As8wFePSAi5AEiIiB8ICJwyRci5gHY5ACDcnAt5ARgaWZpYyBwxFTkATogyivmAwLKED86%2BQD35QIFxFTIIc9H%2BAE16QCMQWdlIG9m6QECxnthZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5PzrnAh3JLFByb2ZpbNNZQGVuY29kZSgiYmFzZTY0dXJsIuQDZXDGMD86IGJ5dGVzyUjkAaxzdGF0dXPES3RoZSBsYXN0IOQAxWHkAl3lBQEgIEB2aXNpYmlsaXR5KExpZmVjeWNs5APlYWTHXcQg5QWQU3RhdMRn5QOwzBTpAUjEc8wy5QCA5QDKYekD2sV3QGxyb8Q7dXMKdW7kBLfRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB0ZWTEZyAgQccOOiAiyAsi1lBpxEDkALTpAMHIROwAnDogIswP2kx15AJixE%2FFQ%2BUCcMY%2FyAvKO%2BkGqukAxOYA3GTnAaJTdWNjZWVk5QDFyQzTP8U25AFNZmFpbMk%2BRsUNOiAixgncOHdhcyBjYW5jZco%2BQ8cP5AcCxwv%2FAUAgZGVsZekBgETEDeYA%2BcgLIukGAukDd21vduoByukDeU1vdmVSxxXoA3LEc21vdsRoZnJvbSBsb2PmALzFbsQT8QNQyzN0b88xdG%2FKL%2FcAlXNwb25z6waQ5gCWxxbsAJfuA2zFPsVkxnzmAu7NbmludGVyZuQIIU%2FoA5TqBl72B2zLKXt9CuUIv8gjyhvLWegAzeYEs2dldOQBp0HKNeQD5%2BwHFSDnAntPcuoGGcsvQ8cdUmVwbGFjZUFzeW5jzj%2FlAvfIN0N1c3RvbeUF%2BVPMKizvBiHFOuYCN89x5QI0ZVdpdGhvdXRPa9NxbGlzdEJ5yDBHcm91cM9ETMUiUGFyZW501DxTdWJzY3Jp5QdxxzvGM8wZzDnoBf0gc2FtcGzrAwNhY8VEdGhhdOYCAOkFwHRvIGRpZmZl5ACE7wKDxSnuALJBxUjvATPrAw7IDeYChfMAkkhFQUTqBenEfmNoZWNr6gCqZXhpc3RlbuYJaCDGHkXJFO8B9c0d7glD\\u0026e=%40azure-tools%2Ftypespec-autorest\\u0026vs=%7B%7D)\\r\\n```\\r\\n/** A ContosoProviderHub resource */\\r\\nmodel Employee is TrackedResource\\u003cEmployeeProperties\\u003e {\\r\\n  ...ResourceNameParameter\\u003cEmployee\\u003e;\\r\\n}\\r\\n\\r\\nalias PatchModel\\u003c\\r\\n  T extends {},\\r\\n  OmittedProperties extends string = \\\"\\\",\\r\\n  NameTemplate extends valueof string = \\\"{name}Update\\\"\\r\\n\\u003e = UpdateableProperties\\u003cOptionalProperties\\u003cOmitDefaults\\u003cOmitProperties\\u003c\\r\\n  T,\\r\\n  OmittedProperties\\r\\n\\u003e\\u003e\\u003e\\u003e;\\r\\n\\r\\nmodel EmployeePropertiesUpdate is PatchModel\\u003cEmployeeProperties\\u003e;\\r\\n\\r\\n/** The PATCH model for employees */\\r\\nmodel EmployeeUpdate\\r\\n  is PatchModel\\u003cEmployee, OmittedProperties = \\\"name\\\" | \\\"properties\\\"\\u003e {\\r\\n  /** rp-specific patchable properties */\\r\\n  properties?: EmployeePropertiesUpdate;\\r\\n}\\r\\n\\r\\n/** Employee properties */\\r\\nmodel EmployeeProperties {\\n\\nYou want to make sure to represent the properties that can be PATCHed in the patch operation, generally this includes any properties that are not generated on the service (e.g. type, id, name, systemData) or settable only on creation (e.g. location), and make sure these properties are optional and have no defaults.\\r\\n \\r\\nYou can do this either be creating a separate model type for patch, or by using standard transformations to filter out the readOnly and createOnly properties and make these optional\\n\\nAzure.ResourceManager.Operations {}\\r\\n\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n  update is ArmCustomPatchSync\\u003cEmployee, EmployeeUpdate\\u003e;\\r\\n  delete is ArmResourceDeleteWithoutOkAsync\\u003cEmployee\\u003e;\\r\\n  listByResourceGroup is ArmResourceListByParent\\u003cEmployee\\u003e;\\r\\n  listBySubscription is ArmListBySubscription\\u003cEmployee\\u003e;\\r\\n\\r\\n  /** A sample resource action that move employee to different location */\\r\\n  move is ArmResourceActionSync\\u003cEmployee, MoveRequest, MoveResponse\\u003e;\\r\\n\\r\\n  /** A sample HEAD operation to check resource existence */\\r\\n  checkExistence is ArmResourceCheckExistence\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\n\\nto make sure to represent the properties that can be PATCHed in the patch operation, generally this includes any properties that are not generated on the service (e.g. type, id, name, systemData) or settable only on creation (e.g. location), and make sure these properties are optional and have no defaults.\\r\\n \\r\\nYou can do this either be creating a separate model type for patch, or by using standard transformations to filter out the readOnly and createOnly properties and make these optional\\r\\n\\r\\n- [Here is a sample of using a fully bespoke patch\\n\\nzLpANFDaXR50ipjaXR5Pzogc3Ry5QPPxyxQcm9maWzTWUBlbmNvZGUoImJhc2U2NHVybCLkAkZwxjA%2FOiBieXRlc%2BkA%2B%2BkBp%2F8A28gc%2FwDV%2FwDV%2FwDV%2FwDV%2FwDVc8lI5AHQc3RhdHVzxEt0aGUgbGFzdCDkAMXlAlTlBLcgIEB2aXNpYmlsaXR5KExpZmVjeWNs5AKLYWTHXcQg5QVGU3RhdMRn5QNmzBTtAkPMMuUAgOUAymHpA5DFd0Bscm%2FEO3VzCnVu5ARt0VTlAWTmARos7ADSyEcgY3JlxCdyZXF1ZXN0IGhhcyBiZWVuIGFjY2VwdGVkxGcgIEHHDjogIsgLItZQacRA5AC06QDByETsAJw6ICLMD9pMdeQC%2F8RPxUPlAw3GP8gLyjvpBmDpAMTmANxk5wGiU3VjY2VlZOUAxckM0z%2FFNuQBTWZhaWzJPkbFDTogIsYJ3Dh3YXMgY2FuY2XKPkPHD%2BQGuMcL%2FwFAIGRlbGXpAYBExA3mAPnICyLpBbjpA3dtb3bqAcrpA3lNb3ZlUscV6ANyxHNtb3bEaGZyb20gbG9j5gC8xW7EE%2FEDUMszdG%2FPMXRvyi%2F3AJVzcG9uc%2BsFweYAlscW7ACX7gNsxT7FZMZ85gLuzW5pbnRlcmbkB9dP6AOUcyBleHRlbmRz9giZLsspe30K5Qh1yCPKG8tZ6ADN5gSzZ2V05AGnQco15APn7AbLIOcCe09y5wW%2Fzi9Dxx1SZXBsYWNlQXN5bmPOP%2BUC98g3Q3VzdG9tUGF0Y2hTzCos7wcGxTrmAjfPceUCNGVXaXRob3V0T2vTcWxpc3RCecgwR3JvdXDPREzFIlBhcmVudNQ8U3Vic2NyaXDlAhbGO8YzzBnMOegF%2FSBzYW1wbOsDA2FjxUR0aGF05gIA6QXAdG8gZGlmZmXkAITvAoPFKe4AskHFSO8BM%2BsDDsgN5gKF8wCSSEVBROoF6cR%2BY2hlY2vqAKpleGlzdGVu5gkeIMYeRckU7wH1zR3uCPk%3D\\u0026e=%40azure-tools%2Ftypespec-autorest\\u0026vs=%7B%7D)\\r\\n```\\r\\n/** A ContosoProviderHub resource */\\r\\nmodel Employee is TrackedResource\\u003cEmployeeProperties\\u003e {\\r\\n  ...ResourceNameParameter\\u003cEmployee\\u003e;\\r\\n}\\r\\n\\r\\n/** The PATCH model for Employee */\\r\\nmodel EmployeeUpdate {\\r\\n  ...Azure.ResourceManager.Foundations.ArmTagsProperty;\\r\\n\\r\\n  /** rp-specific properties */\\r\\n  properties?: EmployeePropertiesUpdate;\\r\\n}\\r\\n\\r\\n/** The PATCH mdoel for rp-specific employee properties */\\r\\nmodel EmployeePropertiesUpdate {\\r\\n  /** Age of employee */\\r\\n  age?: int32;\\r\\n\\r\\n  /** City of employee */\\r\\n  city?: string;\\r\\n\\r\\n  /** Profile of employee */\\r\\n  @encode(\\\"base64url\\\")\\r\\n  profile?: bytes;\\r\\n}\\r\\n\\r\\n/** Employee properties */\\r\\nmodel EmployeeProperties {\\r\\n  /** Age of employee */\\r\\n  age?: int32;\\r\\n\\r\\n  /** City of employee */\\r\\n  city?: string;\\r\\n\\r\\n  /** Profile of employee */\\r\\n  @encode(\\\"base64url\\\")\\r\\n  profile?: bytes;\\r\\n\\r\\n  /** The status of the last operation. */\\n\\n/** The moving to location */\\r\\n  to: string;\\r\\n}\\r\\n\\r\\n/** Employee move response */\\r\\nmodel MoveResponse {\\r\\n  /** The status of the move */\\r\\n  movingStatus: string;\\r\\n}\\r\\n\\r\\ninterface Operations extends Azure.ResourceManager.Operations {}\\r\\n\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n  update is ArmCustomPatchSync\\u003cEmployee, EmployeeUpdate\\u003e;\\r\\n  delete is ArmResourceDeleteWithoutOkAsync\\u003cEmployee\\u003e;\\r\\n  listByResourceGroup is ArmResourceListByParent\\u003cEmployee\\u003e;\\r\\n  listBySubscription is ArmListBySubscription\\u003cEmployee\\u003e;\\r\\n\\r\\n  /** A sample resource action that move employee to different location */\\r\\n  move is ArmResourceActionSync\\u003cEmployee, MoveRequest, MoveResponse\\u003e;\\r\\n\\r\\n  /** A sample HEAD operation to check resource existence */\\r\\n  checkExistence is ArmResourceCheckExistence\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\r\\nThe advantage to using transformations is that, as the model versions, the PATCH model will also version automatically, whereas if you use a completely bespoke patch model, you will need to remember to make appropriate versioning changes there as well as in the resource model.\\n\\nEmployeeUpdate\\u003e;\\r\\n  delete is ArmResourceDeleteWithoutOkAsync\\u003cEmployee\\u003e;\\r\\n  listByResourceGroup is ArmResourceListByParent\\u003cEmployee\\u003e;\\r\\n  listBySubscription is ArmListBySubscription\\u003cEmployee\\u003e;\\r\\n\\r\\n  /** A sample resource action that move employee to different location */\\r\\n  move is ArmResourceActionSync\\u003cEmployee, MoveRequest, MoveResponse\\u003e;\\r\\n\\r\\n  /** A sample HEAD operation to check resource existence */\\r\\n  checkExistence is ArmResourceCheckExistence\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\r\\n- [Here is a sample of using transformations](https://azure.github.io/typespec-azure/playground/?options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fresource-manager%22%5D%7D%7D\\u0026c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3Jl3yvIK3Jlc291cmNlLW1hbmFnZXIiOwoKdXNpbmcgSHR0cDvHDFJlc3TIDFbpAI7IEkHESi5Db3JlzhJSx1xNxls7CgovKiogQ29udG9zb8RUxR4gUHJvdmlkZXIg5gCDbWVudCBBUEkuICovCkBhcm3IIE5hbWVzcGFjZQpAc2VydmljZSgjeyB0aXRsZTogIsdXyC1IdWJDbGllbnQiIH0pCkDnAUNlZCjnAL9zKQpuyFAgTWljcm9zb2Z0LtJG7wC2QVBJIMdNc%2BQAoWVudW3oARNzIHsKICDELjIwMjEtMTAtMDEtcHJldmlld8g1xDQgIEB1c2VEZXBlbmRlbmN5KPUBLy7IVi52MV8wX1DGSF8xKcRAYXJtQ29tbW9uVOQBz8cq10jLKctUNcRIYPIAqWAsCn3mAPNB6AD16wEOIOgCMOQAyG1vZGVsIEVtcGxveWVlIGlzIFRyYWNrZWToAII8yBxQcm9wZXJ0aWVzPuUBJC4u6QCm5AHWUGFyYW1ldGVyyTE%2BO%2BQAhmFsaWFzIFBhdGNoTcRsPAogIFQgZXh0ZW5kcyB7fSwKICBPbWl0dGVkymLJIHN0cuQCjD0gIiLEKcRpVGVtcGxhdGXJJHZhbHVlb2bLLHvkAhd9VXBkYXRlIgo%2BID0gxgxhYmzrAMc8T3B0aW9uYWzME21pdERlZmF1bHTGDcsc5AC59QCuCj4%2BPj47Cu8BTMogxn3kAVzrAQfSJ8RD5AG0VGhlIFBBVENIIMZRZm9yIOQA9MQu5QKwzmjGXgog12As8wFePSAi5AEiIiB8ICJwyRci5gHY5ACDcnAt5ARgaWZpYyBwxFTkATogyivmAwLKED86%2BQD35QIFxFTIIc9H%2BAE16QCMQWdlIG9m6QECxnthZ2U%2FOiBpbnQzMjsKxylDaXR50ipjaXR5PzrnAh3JLFByb2ZpbNNZQGVuY29kZSgiYmFzZTY0dXJsIuQDZXDGMD86IGJ5dGVzyUjkAaxzdGF0dXPES3RoZSBsYXN0IOQAxWHkAl3lBQEgIEB2aXNpYmlsaXR5KExpZmVjeWNs5APlYWTHXcQg5QWQU3RhdMRn5QOwzBTpAUjEc8wy5QCA5QDKYekD2sV3QGxyb8Q7dXMKdW7kBLfRVOUBZOYBGizsANLIRyBjcmXEJ3JlcXVlc3QgaGFzIGJlZW4gYWNjZXB\\n\\nemployee properties */\\r\\nmodel EmployeePropertiesUpdate {\\r\\n  /** Age of employee */\\r\\n  age?: int32;\\r\\n\\r\\n  /** City of employee */\\r\\n  city?: string;\\r\\n\\r\\n  /** Profile of employee */\\r\\n  @encode(\\\"base64url\\\")\\r\\n  profile?: bytes;\\r\\n}\\r\\n\\r\\n/** Employee properties */\\r\\nmodel EmployeeProperties {\\r\\n  /** Age of employee */\\r\\n  age?: int32;\\r\\n\\r\\n  /** City of employee */\\r\\n  city?: string;\\r\\n\\r\\n  /** Profile of employee */\\r\\n  @encode(\\\"base64url\\\")\\r\\n  profile?: bytes;\\r\\n\\r\\n  /** The status of the last operation. */\\r\\n  @visibility(Lifecycle.Read)\\r\\n  provisioningState?: ProvisioningState;\\r\\n}\\r\\n\\r\\n/** The provisioning state of a resource. */\\r\\n@lroStatus\\r\\nu\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_26.md\",\"document_title\":\"Changing Property to Optional with Default\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_26.md\\n\\n# Changing Property to Optional with Default\\n\\n## question\\n\\nHi everyone, \\r\\nI am making a property optional in typespec and to be a non-breaking change, I see that is required to have a default. However my change seems to also change the existing version instead of only the new version. \\r\\nBefore:\\r\\n  @OpenAPI.extension(\\\"x-ms-identifiers\\\", #[])\\r\\n  dnsResolverDomainLists: SubResource[]; \\r\\nAfter:\\r\\n  @madeOptional(Versions.v2025_10_01_preview)\\r\\n  @OpenAPI.extension(\\\"x-ms-identifiers\\\", #[])\\r\\n  dnsResolverDomainLists?: SubResource[] = #[]; \\r\\n1) How can I make the change in typespec so that the generation of the openapi jsons will not affect the existing version? Currently generation also adds the empty array default to the existing API version (2025-05-01) which causes the breaking change CI to flag.\\r\\n2) Is there a way I can default the SubResource[] array to null instead? \\r\\nThis is in accordance to the documentation here (Made optional with/without default case): [non-breaking-versioning | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/non-breaking-versioning/#-incorrect)\\r\\nMy PR: [Release 2025-10-01-preview for DNS Resolver by jamesvoongms · Pull Request #24470 · Azure/azure-res…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24470)\\n\\n## answer\\n\\nYou should not add OpenApi extensions directly - x-ms-identifiers are automatically added based on the `@key` properties of a model,  or you should use the `@identifiers` decorator if you need to override the default setting. \\r\\nThe problem is that this is two changes (making a property optional and providing a default), but there is only versioning decoration for one change.  Compounding this, there is no versioning decoration for adding a default value, this is being tracked here: [Add additional versioning decorators · Issue #2761 · microsoft/typespec](https://github.com/microsoft/typespec/issues/2761).  Ideally we should combine these two changes into a single decorator to promote non-breaking changes. \\r\\nMeanwhile, you can do this using the added/removed/rename pattern to replace one property with another property in a new version, as this example.\\r\\n```\\r\\n/** Employee properties */\\r\\nmodel EmployeeProperties {\\r\\n  @removed(Versions.`2025-10-01-preview`)\\r\\n  @renamedFrom(Versions.`2025-10-01-preview`, \\\"stuff\\\")\\r\\n  @doc(\\\"The stuff\\\")\\r\\n  oldStuff: string[];\\r\\n\\r\\n  @added(Versions.`2025-10-01-preview`)\\r\\n  @doc(\\\"The stuff\\\")\\r\\n  stuff?: string[] = #[];\\r\\n}\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Handling multiple API versions using typespec\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Handling multiple API versions using typespec\\n\\n## question\\n\\nHi Team,\\r\\n \\r\\nI am releasing a new API version and looks there is a new validation to check existing swagger with new tsp file \\r\\n \\r\\n\\\"appears to contain TypeSpec-generated swagger files, not generated from the current TypeSpec sources. Perhaps you deleted a version from your TypeSpec, but didn't delete the associated swaggers?\\\"\\r\\n \\r\\nWe want to keep both old and new api versoins. What is the suggestion here? Do you suggest to create different TSP file for each version/use versioning in existing TSP? \\r\\n \\r\\nIf second case, can you share some example where APIs/Properties are added/removed in a newer version\\n\\n## answer\\n\\nThe idea behind TypeSpec versioning is to model the diffs in your API, encouraging best practices for API evolution. If you have questions about modeling particular changes, feel free to ask.\\r\\n\\r\\nAbout your concern: fixing a new validation causing changes to older APIs—this usually happens when new changes are added without using the appropriate version decorators. For example:\\r\\n\\r\\nIf you added properties or made a property optional, but didn’t annotate them with @added or @madeOptional, then they would apply to all versions by default, including older ones.\\r\\n\\r\\nThat’s likely why your stable version (e.g., 2024-12-01) got unintentionally updated when you only meant to target 2025-07-01-preview.\\r\\n\\r\\nTo avoid this, always use decorators like @added and @madeOptional to indicate version-specific changes.\\r\\n\\r\\nAs for the location field and the read/create mutability warning:\\r\\nThat rule is a warning meant to be advisory. In your case, it doesn’t seem to apply—so this is a good example where you should not change the service behavior just to satisfy a linting rule. It's fine to ignore the warning here.\\r\\n\\r\\nRegarding your question on renaming an API response (e.g., from MoveResponse to MoveResult):\\r\\nIf the new name is meant for a specific version, ensure it’s versioned properly in your TypeSpec. In your repro, the naming appears correct—MoveResult in 2021-10-01-preview, and MoveResponse in 2024-10-01-preview—so it’s working as expected.\\r\\n\\r\\nFinally, for adding or removing a parameter in only the new version:\\r\\nUnfortunately, you can’t directly decorate a spread parameter. The best way is to use operation-specific parameters, which you can decorate with versioning decorators. You could alternatively decorate the core parameter definition (e.g., with an augment decorator), but that would affect every usage—so for localized changes, use operation-specific ones. Since this is a method parameter, the APIs are equivalent and the change has no SDK impact.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_26.md\",\"document_title\":\"Changing Property to Optional with Default\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_26.md\\n\\n# Changing Property to Optional with Default\\n\\n## question\\n\\nHi everyone, \\r\\nI am making a property optional in typespec and to be a non-breaking change, I see that is required to have a default. However my change seems to also change the existing version instead of only the new version. \\r\\nBefore:\\r\\n  @OpenAPI.extension(\\\"x-ms-identifiers\\\", #[])\\r\\n  dnsResolverDomainLists: SubResource[]; \\r\\nAfter:\\r\\n  @madeOptional(Versions.v2025_10_01_preview)\\r\\n  @OpenAPI.extension(\\\"x-ms-identifiers\\\", #[])\\r\\n  dnsResolverDomainLists?: SubResource[] = #[]; \\r\\n1) How can I make the change in typespec so that the generation of the openapi jsons will not affect the existing version? Currently generation also adds the empty array default to the existing API version (2025-05-01) which causes the breaking change CI to flag.\\r\\n2) Is there a way I can default the SubResource[] array to null instead? \\r\\nThis is in accordance to the documentation here (Made optional with/without default case): [non-breaking-versioning | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/non-breaking-versioning/#-incorrect)\\r\\nMy PR: [Release 2025-10-01-preview for DNS Resolver by jamesvoongms · Pull Request #24470 · Azure/azure-res…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24470)\\n\\n## answer\\n\\nYou should not add OpenApi extensions directly - x-ms-identifiers are automatically added based on the `@key` properties of a model,  or you should use the `@identifiers` decorator if you need to override the default setting. \\r\\nThe problem is that this is two changes (making a property optional and providing a default), but there is only versioning decoration for one change.  Compounding this, there is no versioning decoration for adding a default value, this is being tracked here: [Add additional versioning decorators · Issue #2761 · microsoft/typespec](https://github.com/microsoft/typespec/issues/2761).  Ideally we should combine these two changes into a single decorator to promote non-breaking changes. \\r\\nMeanwhile, you can do this using the added/removed/rename pattern to replace one property with another property in a new version, as this example.\\r\\n```\\r\\n/** Employee properties */\\r\\nmodel EmployeeProperties {\\r\\n  @removed(Versions.`2025-10-01-preview`)\\r\\n  @renamedFrom(Versions.`2025-10-01-preview`, \\\"stuff\\\")\\r\\n  @doc(\\\"The stuff\\\")\\r\\n  oldStuff: string[];\\r\\n\\r\\n  @added(Versions.`2025-10-01-preview`)\\r\\n  @doc(\\\"The stuff\\\")\\r\\n  stuff?: string[] = #[];\\r\\n}\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-review\",\"content\":\"# Schedule a data plane REST API spec review\\n## Requesting an offline REST API review\\n### When offline reviews are appropriate\\nAn offline review is appropriate when the following conditions hold:\\r\\n\\r\\n- The prior API version was reviewed and approved by the API Stewardship board.\\r\\n- The new API version makes only minor changes to the prior API version, such as\\r\\n  - Fields added to an API response\\r\\n  - Optional parameters or fields added to a request\\r\\n- The PR for the new API version is passing all PR pipeline checks.\\r\\n- The TypeSpec and OpenAPI APIViews for the PR were successfully generated and clearly show\\r\\nthe changes without extra \\\"noise\\\".\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#ConsiderationsForServiceDesign.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/ConsiderationsForServiceDesign.md\",\"content\":\"# Considerations for Service Design\\n## Communicate Deprecations\\nAs your service evolves over time, it will be natural that you want to remove operations that are no longer needed. For example, additional requirements or new capability in your service, may have resulted in a new operation that, effectively, replaces an old one.\\r\\nAzure has a well established breaking changes policy that describes how to approach these kinds of changes. As part of this policy, the service team is required to clearly communicate to customers when their API is changing, e.g. deprecating operations. Often, this is done via an email to the address that is attached to the Azure subscription.\\r\\n\\r\\nHowever, given how many organizations are structured, it's common that this email address is different from the actual people writing code against your API. To address this, the service API should declare that it may return the `azure-deprecating` header, to indicate that this operation will be removed in the future. There is a simple string convention, specified in the [Azure REST API Guidelines](https://aka.ms/azapi/guidelines#deprecating-behavior-notification) that provides more information about the forthcoming deprecation.\\r\\nThis header is targeted at developers or operation professionals, and it is intended to give them enough information and lead time to properly adapt to this change. Your documentation should reference this header and encourage logging and alerting practices based on its presence.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/versioning\",\"content\":\"# Versioning\\nVersioning lets you evolve your API without breaking existing clients. This guide covers the basics of declaring versions and adding new resources, operations, and properties in a clear, easy-to-follow way. For more advanced scenarios, see the [full versioning documentation](../howtos/ARM/versioning.md).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-versioning.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-versioning\",\"content\":\"# Azure REST API versioning\\nAzure services need to change over time; however, when releasing a new version of a service, there are 2 requirements:\\r\\n\\r\\n- Already-running customer workloads must not break due to a service change.\\r\\n- Customers can adopt a new service version without requiring any code changes.\\r\\n\\r\\nThe recommended approach for versioning Azure REST APIs is to accept an `api-version` query parameter on all operations.\\r\\nThe value of this parameter is a date in the format `YYYY-MM-DD`, with a `-preview` suffix for preview versions.\\r\\n\\r\\nThere is no significance in date-part of an api-version. The only requirement is that each new version have a newer\\r\\ndate than the previous preview or GA api-version.\\r\\n\\r\\nThe service must check the value of the api-version parameter and reject any request that\\r\\n\\r\\n- does not pass an api-version, or\\r\\n- specifies an api-version that is not documented as supported by the service.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial\",\"content\":\"# Tutorial: Create a new service spec\\n## Why work in a separate branch?\\nThe [Microsoft Azure REST API Guidelines state](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-versioning),\\r\\n\\r\\n\\u003e Azure services need to change over time. However, when changing a service, there are 2 requirements:\\r\\n\\u003e\\r\\n\\u003e 1. Already-running customer workloads must not break due to a service change.\\r\\n\\u003e 2. Customers can adopt a new service version without requiring any code changes.\\r\\n\\u003e    Of course, the customer must modify code to leverage any new service features.\\r\\n\\r\\nTogether with the [Breaking Changes Policy](http://aka.ms/AzBreakingChangesPolicy/), it effectively means that any\\r\\nchanges you merge directly into the `main` branch in  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) must be supported for 90 days for preview\\r\\nversions, and 3 years for stable versions at a minimum.\\r\\n\\r\\nWorking in a separate branch allows your team to iterate on a design, make changes to the REST API definition or\\r\\neven the service as needed, and merge those changes to `main` - effectively publishing that service version -\\r\\nwhen you're ready.\"}]",
            "inputs.latency": 481.3189494609833,
            "inputs.response_length": 1740,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://github.com/microsoft/api-guidelines/blob/vNext/azure/VersioningGuidelines.md"
            ],
            "inputs.testcase": "Guidelines for revising an already published API spec?",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1255,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1256,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Guidelines for revising an already published API spec?\\\\n\\\\nquestion: Hello, we recently published a new API version, however, we realized that a property should have been marked optional. Are there guidelines on how to revise an already published API version? We have not announced this version to our customer yet.\\\", \\\"response\\\": \\\"Azure's official versioning and breaking change policy is very clear: once an API version is published (merged into a production branch), you are generally NOT allowed to make any changes\\\\u2014even non-breaking or compatible changes\\\\u2014within that API version. This applies whether or not the version has been publicly announced or used by customers. The reasoning is to prevent confusion and guarantee contract stability.\\\\n\\\\nHowever, there is a specific exception for cases where the spec does not match the actual implementation (i.e., a bug fix to align the spec with service behavior). If you have not announced the version or onboarded customers, and the property was always optional in the service implementation, you may apply for a breaking change review to get an approval label (such as `BreakingChange-Approved-BugFix` or `Versioning-Approved-BugFix`). This process is documented in the Azure Breaking Changes Policy and spec PR guidelines.\\\\n\\\\nThe recommended approach is:\\\\n1. Start by following the process described at aka.ms/brch (Breaking Change Review process).\\\\n2. Clearly document that this is a bug fix to match the spec to service behavior and that no customers are impacted.\\\\n3. Once approved, you can revise the spec in-place for the published API version.\\\\n\\\\nIf the property change would affect customers (i.e., if it was actually required in the implementation), you MUST NOT revise the published API version. Instead, create a new API version with the correct contract.\\\\n\\\\nIn summary: You may revise a published API version only to fix a bug so the spec matches actual service behavior, and only with explicit approval via the breaking change review process. Otherwise, publish a new API version for any changes\\\\u2014even compatible ones.\\\\n\\\", \\\"ground_truth\\\": \\\"Your best next step, is to create a PR fixing the problem.  The \\\\\\\"next steps to merge\\\\\\\" comment should guide you from there, including the breaking change process you may need to follow.\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: Creating new service typespec definition\n\nquestion: Hello,\nI'm currently writing a new definition for a service and wanted to ask if there's any guidance on how to go about it. I saw this guide [Work against the release branch](https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-2-update) however it doesn't go over creating the service folder and creating the readme.md file, please help with this, thanks",
            "inputs.ground_truth": "The first thing is to start in the specs repositories.\nYou can use:\nCopilot to help you create folder structure, files needed, etc\nUse the [Azure SDK Tools MCP](https://aka.ms/azsdk/agent#generate-code) which will have more context and will utilize what it is in the specs repositories.\nThis is a new service API? If it's new, you should be able to ask copilot (in vscode) to create a new service, and it will prompt you for some information to create the proper folder structure\nThe documentation it is using is based on https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline, then it will initialize a project for you after the folders are created.",
            "inputs.response": "To add a new TypeSpec service definition to the Azure REST API specs repo, you should follow these recommended steps and conventions, which ensure compliance with Azure API guidelines and enable smooth SDK generation and validation:\n\n**1. Folder Structure:**\n- For management-plane (ARM) services, your files should be under:\n  `specification/<organization>/resource-manager/<RPnamespace>/<ServiceName>/`\n- For data-plane services, use:\n  `specification/<organization>/data-plane/<ServiceName>/`\n\nEach service folder should contain:\n- `main.tsp` (TypeSpec entry point)\n- `tspconfig.yaml` (TypeSpec config and emitter options)\n- Additional `*.tsp` files as needed\n- `readme.md` (central config for code generation)\n- Example files: `examples/<apiVersion>/...`\n- Generated OpenAPI specs: `stable/<apiVersion>/...` and/or `preview/<apiVersion>/...`\n\n**2. Creating the Service Folder:**\n- Follow the directory structure guidelines: https://github.com/Azure/azure-rest-api-specs/wiki/Specification-Folder-Structure-Guide\n- Use the TypeSpec Azure template to scaffold your service folder and starter files:\n  ```bash\n  npx tsp init https://aka.ms/typespec/azure-init\n  ```\n  This will prompt for the correct template and set up initial files.\n\n**3. Creating README.md:**\n- The `readme.md` file is required in each service folder. It specifies input files, tags (versions), and configuration for the Autorest tool.\n- For management-plane services, it should indicate ARM and RPaaS subtype, and list the generated OpenAPI files:\n\n  Example:\n  ```yaml\n  openapi-type: arm\n  openapi-subtype: rpaas\n  tags:\n    - tag: package-2025-08-15\n      input-file:\n        - stable/2025-08-15/Limit.json\n  ```\n- For data-plane, omit ARM-specific fields but include the relevant OpenAPI files under the latest tag.\n- See a sample here: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/readme.md\n\n**4. tspconfig.yaml:**\n- Ensure emitter options point to the correct output folder and ARM types directory (if applicable):\n  ```yaml\n  options:\n    \"@azure-tools/typespec-autorest\":\n      emitter-output-dir: \"{project-root}\"\n      output-file: \"{version-status}/{version}/widget.json\"\n      arm-types-dir: \"{project-root}/../../../../common-types/resource-management\"\n  ```\n\n**5. Example Files:**\n- Place API examples in `examples/<apiVersion>/`. You can generate basic examples with the [oav](https://github.com/Azure/oav) tool and then adjust for meaningful data.\n\n**6. Compile and Validate:**\n- Compile TypeSpec to generate OpenAPI files:\n  ```bash\n  npx tsp compile .\n  ```\n- Make sure generated files are in the correct folders and referenced by README.md.\n- Fix any CI errors by updating TypeSpec, not the generated OpenAPI directly.\n\n**Summary of Steps:**\n1. Create the correct folder structure using the template.\n2. Fill in `main.tsp`, `tspconfig.yaml`, and `readme.md` as shown above.\n3. Add or generate example files.\n4. Compile and verify OpenAPI output and references.\n5. Push your branch and open a PR for review.\n\nThis process ensures your service spec is compliant and ready for Azure tooling and review.\n\nIf you need a sample, the Widget service in the repo is a good reference: https://github.com/Azure/azure-rest-api-specs/tree/main/specification/widget/resource-manager/Microsoft.Widget/Widget",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"Create a PR against main\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\\n\\n# Create a PR against main\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nWhen you're ready for a final review, it's time to create a pull request (PR) from your release branch you created\\r\\noriginally to the `main` branch on [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n* :warning: Do not merge `main` or other release branches unless you know there are changes required.\\r\\n* :white_check_mark: Rebase on `main` if changes are required in a separate topic branch.\\n\\n## Clean PR against main\\n\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\\n\\n## Update your branch with changes from main\\n\\nIf you know there are other changes in the `main` branch or that other services have updated shared files in `main`\\r\\nalready and you need to pick up changes before merging, we recommend you take a merge from main. This is particularly interesting\\r\\nfor common infrastructure changes that are committed in the repo (i.e. github actions, tools, etc). Depending on how old your\\r\\nbranch is some of the pull request checks may not correctly function without taking a merge from main. \\r\\n\\r\\nIf you are working in a non-protected branch you can do a `git merge main` like you would normally do a merge and then push\\r\\nyour changes to your remote branch. However, if you are working in a branch with branch protection enabled (i.e. `release-*`) then\\r\\nyou will need to make a pull request to your branch with the merge. Depending on how out-of-date your branch is from `main` your \\r\\nmerge may have a lot of unwanted and unnecessary changes and the checks not pass. In such cases see below on how to [update the infrastructure](#updating-only-the-infrastructure-changes-from-main).\\n\\n### Updating only the infrastructure changes from main\\n\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\\n\\n## Next steps\\n\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"Azure REST API, SDK development process with TypeSpec\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure-REST-API,-SDK-development-process-with-TypeSpec.md\\n\\n# Azure REST API, SDK development process with TypeSpec\\n\\n## Table Of Content\\n\\n1. Introduction\\r\\n2. Repo setup \\u0026 prerequisites\\r\\n3. Creating a new TypeSpec project\\r\\n4. Prepare and submit a Pull Request for reviewing\\r\\n5. Generate SDK code from a TypeSpec project\\n\\n### 1. Introduction\\n\\nThis document describes the processes of developing Azure REST APIs and SDKs with TypeSpec language. The steps below\\r\\n assumes that you are developing TypeSpec API specifications in the `azure-rest-api-specs` and `azure-rest-api-specs-pr`repos.\\r\\nIf you are developing within your own ADO repo first and then submitting into `azure-rest-api-specs` repos for review and\\r\\n release, you will need to copy the TypeSpec files over.\\n\\n### 2. Repo setup \\u0026 prerequisites\\n\\n- The main repos for Azure REST APIs are [azure-rest-api-specs](https://github.com/azure/azure-rest-api-specs) and [azure-rest-api-specs-pr](https://github.com/azure/azure-rest-api-specs-pr)\\r\\n repos. The `-pr` repo contains `RPSaaSMaster` and `RPSaaSDev` branches for ProviderHub based ARM service specs.\\r\\n#### 2.1 With local machine development\\r\\n- [Node.js LTS](https://nodejs.org/en) version 18 or above (LTS Recommended).\\r\\n Ensure you can run the npm command in a command prompt:\\r\\n  ```npm\\r\\n    npm --version\\r\\n  ```\\r\\n- Run following command in the **repository root folder**. This will install required packages such as TypeSpec\\r\\n compilers and Azure Library packages.\\r\\n  ```npm\\r\\n     npm ci\\r\\n  ```\\r\\n- Ensure you can run TypeSpec command within the repo folders.\\r\\n  ```npm\\r\\n     npx tsp --version\\r\\n  ```\\r\\n- One-time set up: Install TypeSpec VisualStudio or VS Code extensions to get syntex highlighting, tool tips in IDE:  \\r\\n  ```npm\\r\\n    npx tsp code install\\r\\n  ```\\r\\n  OR\\r\\n    ```npm\\r\\n      npx tsp vs install\\r\\n    ```\\r\\n#### 2.2  VS Code with local docker .devcontainer\\r\\nAll prerequisites have been installed in the dev container. You should to have `Docker Desktop` and `WSL2` running if\\r\\n you are on Windows machine.\\r\\nTo start, you just need to install `Dev Containers` VS code extension, then open the repo path.\\r\\n- VS Code will detect the .devcontainer and prompt you to reopen the workspace.\\r\\n- Alternatively, you can use Command Palette -\\u003e Dev Containers: Reopen in Container.  \\r\\nOnce VS Code reopened in Container, you can run any of the program below in the VS Code integrated terminal.\\r\\n#### 2.2 VS Code in browser via GitHub codespaces\\r\\nGitHub codespaces leverage the same dev container in the repo. The difference is it is hosted in cloud with VS Code in\\r\\n browser.\\r\\nTo start, you just need to browse to the `azure-rest-api-specs` repo, select `\\u003c\\u003e Code` drop down and follow `Codespaces`\\r\\n instructions.\\n\\n### 3. Creating a new TypeSpec project\\n\\nPlease first review recommended folder structure detailed in [this document](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/directory-structure.md).\\r\\n1. Under `[reporoot]\\\\specification`, create service folder directly.\\r\\n   - Select `(rest-api-spec repo) ARM` or `(rest-api-spec repo) Data-plane` and answer appropriate naming questions.\\r\\n   - If it's ARM service, the service folder would be `specification/{organization}/resource-manager/\\u003cRPNS\\u003e/{service}`.\\r\\n   - If it's Data Plane service, the service folder would be `specification/{organization}/data-plane/{service}`\\r\\n2. Create a new TypeSpec project based on Azure template with command:\\r\\n    ```cli\\r\\n       npx tsp init https://aka.ms/typespec/azure-init\\r\\n    ```\\r\\n3. Compile the generated TypeSpec project with command:\\r\\n    ```cli\\r\\n      npx tsp compile .\\r\\n    ```\\r\\n    The generated OpenAPI files should be correctly placed in the `{service}`folders following the naming conventions.\\r\\n4. Now the project has been set up. You can modify the sample and develop your own APIs with TypeSpec.\\n\\n### 4. Prepare and submit a Pull Request for reviewing\\n\\n1. Create a branch in your local repository for your changes.\\r\\n2. Create or update the TypeSpec files for your service.\\r\\n3. Add or update 'examples' files for each operation of your OpenAPI file.\\r\\n   The [oav](https://github.com/Azure/oav) provides two ways to generate OpenAPI examples:\\r\\n   1. Generating basic examples and then manually modify the values. It will generate two examples for each operation:\\r\\n    one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated\\r\\n     examples consist of random values for most types, you need replace them with meaningful values.\\r\\n       ```bash\\r\\n       oav generate-examples openapi.json\\r\\n       ```\\r\\n    Note, latest OAV tool should automatically generate the following. However, if you are generating the examples manually,\\r\\n     please ensure you have:\\r\\n    - include `title` field and make sure it is descriptive and unique for each operation.\\r\\n    - include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in OpenAPI.\\r\\n4. Add/update the `readme.md` file in the `{service}` folder to specify the version and location of the OpenAPI files. The `readme.md` is needed for both management-plane and data-plane services for REST API Docs generation.\\r\\n   Example:[sample-readme](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/readme.md)\\r\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\n\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\r\\n   - send a pull request to the original repo from your forked repo.\\r\\n   See the ARM Wiki for information on the [supported repos and branches for management-plane services](https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches).\\r\\n#### 4.1 Fix the errors of PR reviewing CI checks\\r\\nThe CI checks result will be commented on the PR. you can refer to the [CI fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\\r\\nNote:\\r\\nSince the OpenAPI is generated from TypeSpec, to change the OpenAPI, you must update the TypeSpec file and regenerate the\\r\\n OpenAPI and avoid updating OpenAPI directly to keep the consistency between OpenAPI and TypeSpec.\\r\\nFor support \\u0026 help, you can post a message to [TypeSpec Discussion - teams channel](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\\n\\n### 5. Generate SDK code from a TypeSpec project\\n\\nRefer to [Develop client libraries](https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop?tabs=management) for more details.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\",\"document_title\":\"Resolving Folder Migration Conflicts: A Guide for PR Authors\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors\",\"content\":\"# Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\\n\\n# Resolving Folder Migration Conflicts: A Guide for PR Authors\\n\\n## Overview\\n\\nWhen folder structure migration PRs (like [#36764](https://github.com/Azure/azure-rest-api-specs/pull/36764)) are merged, they may conflict with ongoing PRs that modify files within the refactored folders. This guide helps PR authors resolve these conflicts more efficiently.\\r\\n\\r\\n\\u003e **Important Note**: If you create a new PR **after** a folder migration is already merged into main, you should not encounter merge conflicts but need to work based on the new folder structure.\\n\\n## Understanding Folder Migration\\n\\nHere's the brief summary of the file changes of folder structure migration PR. we will take the Container Apps as an example.\\n\\n### Folder Structure Change\\n\\n**Before Migration Structure**:\\r\\n```\\r\\nspecification/app/\\r\\n├── Microsoft.App.DynamicSessions/\\r\\n│   ├── *.tsp\\r\\n│   ├── examples/*/*.json\\r\\n│   └── tspconfig.yaml\\r\\n├── resource-manager/\\r\\n|   ├── readme.md\\r\\n|   └── Microsoft.App/\\r\\n|       ├── preview/*/*.json\\r\\n|       └── stable/*/*.json\\r\\n└── data-plane/\\r\\n    ├── readme.md\\r\\n    └── Microsoft.App.DynamicSessions/\\r\\n        └── preview/*/*.json\\r\\n```\\r\\n\\r\\n**After Migration Structure**:\\r\\n```\\r\\nspecification/app/\\r\\n├── resource-manager/Microsoft.App/ContainerApps/\\r\\n│   ├── preview/*/*.json\\r\\n│   ├── stable/*/*.json\\r\\n│   └── readme.md\\r\\n└── data-plane/DynamicSessions/\\r\\n    ├── examples/*/*.json\\r\\n    ├── preview/*/*.json\\r\\n    ├── *.tsp\\r\\n    ├── tspconfig.yaml\\r\\n    └── readme.md\\r\\n```\\r\\n\\r\\n**Key Changes Made**:\\r\\n- TypeSpec files moved with their respective services\\r\\n- Each service now has its own isolated directory structure\\r\\n\\r\\nFor example:\\r\\n- Create a new serviceName folder ContainerApps: Moved from `resource-manager/Microsoft.App/` to `resource-manager/Microsoft.App/ContainerApps/`\\r\\n- The resource-manager readme.md updated paths from `resource-manager/` to `resource-manager/Microsoft.App/ContainerApps`\\r\\n- DynamicSessions TypeSpec: Moved from `Microsoft.App.DynamicSessions/` to `data-plane/DynamicSessions/`\\r\\n- DynamicSessions OpenAPI json files: Moved from `data-plane/Microsoft.App.DynamicSessions/preview/\\u003cversion\\u003e/` to `data-plane/DynamicSessions/preview/\\u003cversion\\u003e/`\\r\\n- The data-plane readme.md updated paths from `Microsoft.App.DynamicSessions/preview/\\u003cversion\\u003e/` to `preview/\\u003cversion\\u003e/`\\n\\n### File Reference Updates Needed\\n\\n1. **Readme.md files** - Update input-file paths:\\r\\n   \\r\\n   **For ContainerApps (Resource Manager)**:\\r\\n   ```yaml\\r\\n   # Before\\r\\n   input-file:\\r\\n     - Microsoft.App/stable/2024-03-01/ContainerApps.json\\r\\n   \\r\\n   # After  \\r\\n   input-file:\\r\\n     - stable/2024-03-01/ContainerApps.json\\r\\n   ```\\r\\n   \\r\\n   **For DynamicSessions (Data Plane)**:\\r\\n   ```yaml\\r\\n   # Before migration - in data-plane/readme.md\\r\\n   input-file:\\r\\n     - Microsoft.App.DynamicSessions/preview/2025-02-02-preview/DynamicSessions.json\\r\\n   \\r\\n   # After migration - in data-plane/DynamicSessions/readme.md  \\r\\n   input-file:\\r\\n     - preview/2025-02-02-preview/DynamicSessions.json\\r\\n   ```\\r\\n\\r\\n2. **tspconfig.yaml files** - Update emitter output directory:\\r\\n   \\r\\n   **DynamicSessions tspconfig.yaml changes**:\\r\\n   ```yaml\\r\\n   # Before migration - in Microsoft.App.DynamicSessions/tspconfig.yaml\\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       emitter-output-dir: \\\"{project-root}/..\\\"\\r\\n       output-file: \\\"{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/DynamicSessions.json\\\"\\r\\n   \\r\\n   # After migration - in data-plane/DynamicSessions/tspconfig.yaml\\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       emitter-output-dir: \\\"{project-root}\\\"\\r\\n       output-file: \\\"{version-status}/{version}/DynamicSessions.json\\\"\\r\\n   ```\\r\\n\\r\\n3. **Common-types references** - Update relative paths in JSON files:\\r\\n   ```json\\r\\n   // Before (in ContainerApps.json)\\r\\n   \\\"$ref\\\": \\\"../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   \\r\\n   // After  \\r\\n   \\\"$ref\\\": \\\"../../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   ```\\r\\n\\r\\n   Fpr mgmt plane TypeSpec, we also need to specify the `arm-common-types` in tspconfig options of `@azure-tools/typespec-autorest`.\\r\\n   ```yaml \\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n   ```\\n\\n// After  \\r\\n   \\\"$ref\\\": \\\"../../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   ```\\r\\n\\r\\n   Fpr mgmt plane TypeSpec, we also need to specify the `arm-common-types` in tspconfig options of `@azure-tools/typespec-autorest`.\\r\\n   ```yaml \\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n   ```\\r\\n\\r\\n4. **Suppressions.yaml** - Update paths in suppressions:\\r\\nAs GitHub recognize this refactor change as to add new API versions in the OpenAPI folder, in order to make sure the TypeSpec requirement check pass. we need to have a suppressions.yaml under serviceName folder \\r\\nand add suppression one by one like this \\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: ./preview/2022-01-01-preview/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n- tool: TypeSpecRequirement\\r\\n  path: ./stable/2025-01-01/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## The impact to ongoing PRs\\n\\n1. If the ongoing PRs are targeting to a release-* or dev-* branch which are not created or syncing from the latest main, we recommend to merge these PRs first.\\r\\n1. If the ongoing PRs are targeting to public main branch, Here's the suggestion to resolve the conflict. \\r\\n\\r\\n      1. Merge latest main \\r\\n          ```\\r\\n          git checkout main\\r\\n          git pull origin main // origin points to Azure rest api specs repo.\\r\\n          git merge main \\u003cyour-pr-branch\\u003e\\r\\n          ```\\r\\n      2. Resolve conflicts  \\r\\n        - For most of the conflicts, accept the incoming changes.  \\r\\n        - If it's unclear, please accept both and then update based on your judgement with the folder structure changes above.  \\r\\n\\r\\n      3. Make sure the new change is aligned with folder structure v2  \\r\\n\\r\\n         There are some cases where the PR is adding a new version in the original location, but the file diffs don't show as conflict. we should move them into the correct place so that it doesn't break the folder structure v2 as instructions in **Understanding Folder Migration sections** \\r\\n\\r\\n      4. clean up the previous folder if exists.\\r\\n\\r\\n  \\r\\n\\r\\n**Important**: It's strongly recommended to understand what's really changed in the folder refactor. Always ensure the new PR doesn't include any things that breaks the folder structure.\\n\\n### After Resolution\\n\\nMake sure to compile the TypeSpec project so that the TypeSpec Validation could pass.\\r\\n\\r\\n1. **Comprehensive validation**:\\r\\n   ```bash\\r\\n   # Run full validation suite\\r\\n   npm ci\\r\\n   npm run lint\\r\\n   npm run validate\\r\\n   \\r\\n   # Test TypeSpec compilation for your service\\r\\n   cd specification/app/data-plane/DynamicSessions/\\r\\n   npx tsp compile .\\r\\n   npx tsp compile . --emit @azure-tools/typespec-autorest\\r\\n   \\r\\n   # Verify generated files match expectations by checking if there's any diff with the OpenAPI json files.\\r\\n   ```\\n\\n## Getting Help\\n\\n### Resources\\n\\n- [Azure Service Version Guidelines](https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline)\\r\\n- [Container Apps Migration PR #36764](https://github.com/Azure/azure-rest-api-specs/pull/36764)\\n\\n### Support Channels\\n\\nIf you encounter complex conflicts that can't be resolved using this guide, please email to azversioning@service.microsoft.com\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#01-get-started.md\",\"document_title\":\"Getting started with TypeSpec migration\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\",\"content\":\"# migrate-swagger#01-get-started.md\\n\\n# Getting started with TypeSpec migration\\n\\nWe have created a OpenAPI to TypeSpec conversion tool to help take on the bulk of the manual conversion labor. It can handle both data-plane and management-plane OpenAPI files. The produced TypeSpec relies on the Azure.Core and Azure.Resource.Manager libraries.\\r\\n\\r\\n**_Important!_** Because TypeSpec is more expressive than OpenAPI and with the help of evolving Azure libraries, this tool should only be used as an aid in the conversion/migration process, not as the sole tool to produce final version of TypeSpec specs without human inspection, correction and optimization.\\n\\n## Steps of migration and comparison\\n\\n### Prerequisite\\n\\n- Clone [azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n- Install dependencies:\\r\\n  ```shell\\r\\n  npm install # Run at root of the repository\\r\\n  ```\\n\\n### Generate TypeSpec with converter\\n\\n- Go to the `specification/{service-name}` folder in `azure-rest-api-specs`.\\r\\n- Create a directory holding TypeSpec files. See details [here](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/typespec-structure-guidelines.md).\\r\\n- Run the tool from the directory.\\r\\n  - Convert a **data-plane** specification:\\r\\n\\r\\n    ```shell\\r\\n    tsp-client convert --swagger-readme [path to readme.md]\\r\\n    ```\\r\\n\\r\\n  - Convert a **control-plane** specification:\\r\\n\\r\\n    ```shell\\r\\n    tsp-client convert --swagger-readme [path to readme.md] --arm\\r\\n    ```\\r\\n\\r\\n  - Convert a **control-plane** specification to fully compatible output:\\r\\n\\r\\n    By default, the converted TypeSpec project will leverage TypeSpec built-in libraries with standard patterns and templates (highly recommended), which will cause discrepancies between the generated TypeSpec and original OpenAPI file. If you really don't want this intended discrepancy, add `--fully-compatible` flag to generate a TypeSpec project that is fully compatible with the OpenAPI file.\\r\\n\\r\\n    ```shell\\r\\n    tsp-client convert --swagger-readme [path to readme.md] --arm --fully-compatible\\r\\n    ```\\n\\n### Review and adjust the TypeSpec\\n\\nYou will need to compare the OpenAPI file generated from TypeSpec with the original OpenAPI specification(s) to ensure functional equivalence.\\r\\n\\r\\n- In the TypeSpec folder, compile TypeSpec files to emit an auto-generated OpenAPI file:\\r\\n\\r\\n  ```shell\\r\\n  tsp compile .\\r\\n  ```\\r\\n\\r\\n- From the root folder, download the latest specification as baseline. Your original specification will be located at `.\\\\sparse-spec\\\\specification\\\\{service-name}`:\\r\\n\\r\\n  ```shell\\r\\n  .\\\\eng\\\\tools\\\\typespec-migration-validation\\\\scripts\\\\download-main.ps1 {path\\\\to\\\\your\\\\generated\\\\openapi\\\\file}\\r\\n  ```\\r\\n\\r\\n- At the end of the console output, you'll see the next command to sort, merge, and normalize the original OpenAPI file(s) and generated OpenAPI file, making it easier to review changes. Provide an `outputFolder` to store the analysis results:\\r\\n\\r\\n  ```shell\\r\\n  npx tsmv {your\\\\original\\\\openapi\\\\folder} {your\\\\generated\\\\openapi\\\\file} --outputFolder {outputFolder}\\r\\n  ```\\r\\n\\r\\n- In the `{outputFolder}`:\\r\\n  - `newNormalizedSwagger.json` is the processed version of the generated OpenAPI file\\r\\n  - `oldNormalizedSwagger.json` is the processed version of the original OpenAPI file(s)\\r\\n\\r\\n  In VS Code, select both files (select `oldNormalizedSwagger.json` first, then `newNormalizedSwagger.json`), right-click and choose \\\"Compare Selected\\\". Review these differences to understand their patterns.\\r\\n\\r\\n- Check out the output from `npx tsmv` execution. It prints suggested fixes and prompts if any. Please review them before any run.\\r\\n\\r\\n  **Suggested fixes:** These provide exact TypeSpec code that you can apply directly by following the instructions.\\r\\n\\r\\n  **Suggested prompts:** To use these, drag all the TypeSpec files into GitHub Copilot context. Select \\\"Agent\\\" or \\\"Edit\\\" mode with the \\\"Claude\\\" model. Use the provided prompt to ask GitHub Copilot to generate fixes. Carefully review all changes before accepting or undoing them.\\r\\n\\r\\n- For remaining differences, follow this iterative process:\\n\\nPlease review them before any run.\\r\\n\\r\\n  **Suggested fixes:** These provide exact TypeSpec code that you can apply directly by following the instructions.\\r\\n\\r\\n  **Suggested prompts:** To use these, drag all the TypeSpec files into GitHub Copilot context. Select \\\"Agent\\\" or \\\"Edit\\\" mode with the \\\"Claude\\\" model. Use the provided prompt to ask GitHub Copilot to generate fixes. Carefully review all changes before accepting or undoing them.\\r\\n\\r\\n- For remaining differences, follow this iterative process:\\r\\n  1. Recompile TypeSpec files with `tsp compile .` in the TypeSpec folder.\\r\\n  2. Run the `npx tsmv` command again with the same parameters.\\r\\n  3. Review the updated differences in VS Code.\\r\\n  4. Make further adjustments as needed. Refer to [Understanding the OpenAPI Changes](./faq/mustread.md) to understand expected changes and mitigation steps. For more effective visualization, fix differences in this recommended order:\\r\\n     - Path (route) differences first\\r\\n     - Definition (model) name differences next\\r\\n     - Detail differences within paths and definitions last\\n\\n### Create Spec PR with new TypeSpec project\\n\\n- In the `readme.md` file, under the latest tag, change the `input-file` to the OpenAPI file generated from TypeSpec.\\r\\n- If the generated OpenAPI file(s) for the latest version changed name, delete the old OpenAPI file(s) no longer referenced in README.md.\\r\\n- Create a PR with the TypeSpec files, changed OpenAPI files (examples included) and readme file.\\r\\n- Check CI failures. Refer to [Resolving Pipeline failures](./faq/pipeline.md)\\n\\n## How to Get Help\\n\\n- Ask questions in the [TypeSpec Discussions Channel](https://teams.microsoft.com/l/channel/19%3a906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%2520Discussion%2520%25F0%259F%2590%25AE?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\\r\\n- Attend TypeSpec office hours. The office hours is listed on top tabs on the discussion channel.\\r\\n- File issues in the [typespec-azure github repo](https://github.com/azure/typespec-azure/issues)\\r\\n  - For bugs, please include:\\r\\n    - A high-level description of the bug\\r\\n    - Expected and Actual Results\\r\\n    - Repro steps, including any TypeSpec code that you used\\r\\n    - Any error messages you saw, including stack traces. For issues with VS or VS Code tooling see [Troubleshooting VSCode Tooling and Filing Issues](../typespec-getting-started.md#troubleshooting-vscode-tooling-and-filing-issues)\\r\\n- Schedule review meetings with TypeSpec team.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#createproject.md\",\"document_title\":\"Creating a project\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/createproject\",\"content\":\"# getstarted#createproject.md\\n\\n# Creating a project\\n\\nIf you've installed TypeSpec on your local machine, you can create a new TypeSpec project by following these steps:\\r\\n1. **Open your command prompt** (PowerShell, cmd.exe, bash, etc.), create an empty folder for your new project, and `cd` into it.\\r\\n2. If creating a new service in the [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) repository, create the new service folder following our [directory structure guidelines](https://aka.ms/azsdk/spec-dirs).\\r\\n3. To create a new Azure service specification, use the `tsp init` command:\\r\\n```bash\\r\\ntsp init https://aka.ms/typespec/azure-init\\r\\n```\\r\\nYou will be prompted with a few questions regarding the service template, project name, and library updates.\\n\\n### Understanding Project Templates\\n\\nWhen initializing a new project, you'll encounter four templates:\\r\\n| Template Name                                                   | Description                                                                                                                                                                          |\\r\\n| --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\\r\\n| **(rest-api-spec repo) Azure Data Plane Service Project**       | This template is configured for projects within the `azure-rest-api-specs` repository, with settings that comply with the repo's requirements, such as file paths and linting rules. |\\r\\n| **(rest-api-spec repo) Azure Resource Manager Service Project** | Similar to the above, but tailored for Azure Resource Manager services within the `azure-rest-api-specs` repository.                                                                 |\\r\\n| **(standalone) Azure Data Plane Service Project**               | This template is configured for local use or in a personal repo, allowing for API development without the specific directory structure of the `azure-rest-api-specs` repo.           |\\r\\n| **(standalone) Azure Resource Manager Service Project**         | Similar to the above but designed for Azure Resource Manager services, configured for local use or in a personal repo.                                                               |\\n\\n### Target Users\\n\\n- **Rest-API-Spec Repo Projects**: Ideal for those contributing directly to the Azure REST API specifications, ensuring production-quality SDK generation.\\r\\n- **Standalone Projects**: Suited for API-first development, allowing users to generate OpenAPI specs, service code, and clients without conforming to the specs repo's structure.\\n\\n### Install the dependencies\\n\\nNow that the new project has been created, you can install the dependencies by running the following command:\\r\\n- `npm ci` - If in the `azure-rest-api-specs` repo.\\r\\n- `tsp install` - If a standalone project\\r\\nAfter setting up your project, run `tsp install` to install dependencies. You can then open the file `main.tsp` to continue with the tutorial. Choose the tutorial that matches your chosen project template:\\r\\n| Azure Service Type       | Tutorial                                      | Produces                   |\\r\\n| ------------------------ | --------------------------------------------- | -------------------------- |\\r\\n| Azure Data-Plane Service | [Azure-Core tutorial](azure-core/step01)      | OpenApi 2.0 (Swagger) spec |\\r\\n| Azure Management Service | [ARM tutorial](azure-resource-manager/step00) | OpenApi 2.0 (Swagger) spec |\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_21.md\",\"document_title\":\"Generating readme and examples files\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_21.md\\n\\n# Generating readme and examples files\\n\\n## question\\n\\nHi TypeSpec Discussion\\r\\n\\r\\nI have this PR [adding shared limit typespec by parthshah2305 · Pull Request #24115 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/24115) to add a new resource provider's typespec.\\r\\n\\r\\nTwo of the validations that are failing are due to missing readme and example files.\\r\\nCould anyone point me to some documentation around generating readme files?\\r\\n\\r\\nI also tried generating the example files locally, but it throws the below exception . I am not sure where this path to common-types is specified to change it to point it correctly.\\r\\n\\r\\n```\\r\\noav generate-examples .\\\\resource-manager\\\\Microsoft.Limit\\\\Limit\\\\stable\\\\2025-08-15\\\\Limit.json\\r\\n{\\r\\n  message: `fatal error: ENOENT: no such file or directory, open 'D:\\\\\\\\repos\\\\\\\\azure-rest-api-specs-pr\\\\\\\\common-types\\\\\\\\resource-management\\\\\\\\v5\\\\\\\\types.json', {\\\"errno\\\":-4058,\\\"code\\\":\\\"ENOENT\\\",\\\"syscall\\\":\\\"open\\\",\\\"path\\\":\\\"D:\\\\\\\\\\\\\\\\repos\\\\\\\\\\\\\\\\azure-rest-api-specs-pr\\\\\\\\\\\\\\\\common-types\\\\\\\\\\\\\\\\resource-management\\\\\\\\\\\\\\\\v5\\\\\\\\\\\\\\\\types.json\\\"}`,\\r\\n  level: '\\\\x1B[31merror\\\\x1B[39m'\\r\\n}\\r\\n```\\n\\n## answer\\n\\nThere're several problems with your PR. \\r\\n1.the folder structure is incorrect with your *.tsp files, you should put them under specification/limit/resource-manager/Microsoft.Limit/Limit/ as well as the tspconfig.yaml, you can take the widget specs as an example https://github.com/Azure/azure-rest-api-specs/tree/main/specification/widget/resource-manager \\r\\n2.Assuming you are an RPaaS services (because you are a new service and in azure-rest-api-specs-pr repo), you have to have a readme.md under resource-manager folder and which should contains the minimal information which is required from RPaaS to know that your service is a RPaaS services, you can also take a look at widget's example\\r\\n```\\r\\nopenapi-type: arm\\r\\nopenapi-subtype: rpaas\\r\\n```\\r\\nYou need to pay attention to the output file path in your tspconfig.yaml under the `@azure-tools/typespec-autorest` section https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/tspconfig.yaml#L9-L13 \\r\\n```\\r\\n    emitter-output-dir: \\\"{project-root}\\\"\\r\\n    # TODO: Does anything need this set, if it's not used in output-file?  Currently required by TSV.\\r\\n    azure-resource-provider-folder: \\\"resource-manager\\\"\\r\\n    output-file: \\\"{version-status}/{version}/widget.json\\\"\\r\\n    arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n```\\r\\n1.because this is the file oav is trying to find https://github.com/Azure/azure-rest-api-specs-pr/blob/d1fd46b8d93ae2cdd50e282768fe5e82e718e893/specification/common-types/resource-management/v5/types.json\\r\\n2.You also need to have a readme.md under specification/limit/resource-manager/Microsoft.Limit/Limit/ ,  similar like this one https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/readme.md where you have to have references to all your swagger files with tags and its input-files\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Avocado Failing on PR\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Avocado Failing on PR\\n\\n## question\\n\\nHi TypeSpec Discussion \\r\\nI have a PR here to add a new set of Azure AI APIs: https://github.com/Azure/azure-rest-api-specs/pull/33130 \\r\\nI'm a bit confused on why the avocado step is failing? As this is a brand new API, we started from scratch with tsp itself, and these swaggers are the output of `npx tsv` .... Do I really need to include a README.md in the swagger directories, or is this just failing incorrectly? I don't see README.md files in other service directories (i.e. keyvault) for example.\\n\\n## answer\\n\\nyou need a readme.md somewhere to generate SDKs.  location and factoring of the readme.md(s) can vary by spec.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Proper Service Versioning\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Proper Service Versioning\\n\\n## question\\n\\nHi TypeSpec Discussion. I'm looking to understand how to properly add a new service version to my team's typespec. I've been looking at this doc here as a baseline, and I think I generally understand everything there. But I've got a couple of questions for my specific case.\\r\\n1. What does the `added` decorator actually do? Just tell the swagger which version should/shouldn't contain a property? I'm assuming the question of whether it has an impact on any of the SDKs is a question for the individual generator teams?\\r\\n2. My team's spec has a [client.tsp file](https://github.com/Azure/azure-rest-api-specs/blob/dargilco/ai-model-inference/specification/ai/ModelClient/client.tsp#L8) with a `customization` namespace, which has this decorator: `@useDependency(AI.Model.Versions.v2024_05_01_Preview)`. I get the general gist that this ties things to a specific version, but what does that mean from a practical standpoint? I maybe can understand client customizations being specific to individual versions, but what about modifications that work across versions? I don't seem to be able to provide a list or anything to that decorator. I've tried removing it, and I get an error saying that the `customization` namespace is referencing a versioned namespace and should add the decorator. I've also tried just changing the namespace to match, but then I get an error from my client interfaces saying that I have duplicate operations. So I'm trying to understand how to correctly handle this.\\r\\nAny pointers would be appreciated. Thanks in advance!\\n\\n## answer\\n\\nbmNlzEBDxxE6ICLIC9NEd2FzIHNlbnQgdG%2FlAYz1AYNTZW50VG9NyxvkANPRFfACvXN1Ym1pdHRlZOgBh3JlcXVlc3QgZm9y8AGK7ALF5gF9Usct7gLS6QHK6gI5z17HUSDIEOUBxegCiesB2O8Cj2TEWGFuZCB0aW1lIHdoZW7FY8dcaXMgc2NoZWR1bGVk5AErb2NjdeoBIMkbRGF0ZVRp5AMpdXRjyA3faclp5gDv5AGRY3JlYXTrAcvHEN9e317JXnVwxCXKXscQ317fXsleY29tcGxlzGDJEtdi7wOzcGFyYW1ldGXkAxLrAijlAfp1c8ls9wI25gPOUMRE7Ad79ARxIGJl5AhG5gHi6wCwQHBhdGjFCsYo7AR18wWdJ3PkALPzBaTEFuYFokBwYXJlbnRSyBvmALHwBbxQYXLwAu7kBXXoALXLZe4FxcQ4%2FwXJ%2FwXJyG9JROQC3HVzZeUBenJlb3JkZcQn8gCAxA3xBY3yAWnEJ%2F8F2P8F2PcF2GRldGFpbHPEaGHoAKnvBF%2FqAVXzBGPEF1LGN%2FIEaElkZW50aWZpZXMgd2hvIHNpZ25lZCBvZuYA1M9ux10gxydPZmZCefICMC8gQW4gZXhh5AMK5gC15ArCbGV0b24g6AIy5wDfUHJvdmlkZXMgYW5hbHl0aWNzIGFib3V0xX3kAZzkA4BtYWludGVu5AXYxk%2FmANfyAoXJRf8CiewBHUHJee4CjmnoARhy5QFj5ACQyV8gb2JqZWN0LiDEKnJl5AUxb25seSBvbuYCxmQgJ2N1csR9J%2B8CxclDSWT%2FAsLoAsJp5AbUx07kDErtAzJ1bWJl5QptdXNl5QIg6gPxyXl1c2VDb3VudDogaW50NjTZQ%2BQE5nPLQeUE4fEEMMYRzlHtBCjsAurEV8ZNc%2FIBrcwp7Anc7Adl7wGUzDMnc%2BQIxHF15AOC7wFlzCf%2FAWjuAWj1A%2BHPde0KX%2FsEX883ZnVsbCBhZGRyZXPoAQwgyBD%2FBA%2FrA1hPcGVyYXTlDWr%2FDIjpDa505A4tZXPsBBZTxhvmDkfnAWMuLi5TdXDkDtFzUmVwZWF0YWJsZecELnPkAIPNI0NvbmRp5ACIYWzaJGxp5QN%2BxR9JZDzpDXXsDWE%2B6QDeYWxpYXPsAOE97A7z6APFyiA87QDGPjsKfQoK5A3yQXV0aCgKICBBcGlLZXnEDjzGC0xvY8U6LmhlYWRlciwgImFwaS1rZXkiPiB8IE%2FEKjLFL1vlAMrmARcgIOQP0TrHH0Zsb3dUeXBlLmltcGxpY2l05AoExAFhdXRob3JpesVhVXJsOiAi5BBdczovL2xvZ2luLmPnD3Vjb20vY29tbW9uL2%2FENTIvdjIuMC%2FIQOYNE8QBc2NvcGVzOiBbyUnnA9fMSi5kZWZhdWx0Il3GN30KICBdPgopCkDnAf4oI3sgdGl0bOQNcvYP1iIgfccvZXLkATcie2VuZHBvaW50fcdy5QCT0D5BUElzxRnqA6EK5wH56g5Z5wGicyDIU3MgKHByb3RvY29s5QXZaG9zdOQDQyzlBWPnBjI6CukA8mVzdHVzLmFwaS7yAP0pLgroA0fIX%2BgDSOYLminsER%2F7EQnrAnPkAM3mEW71ESXlA6DkBotyZsRAxhzGNu4DniDpDWfnD0DEJ%2BcJ0%2BsGwSDkA%2BHFMeoEwXNoYXJlZFJvdXTkByMgIGdldMYtyV3GXOQGdMkTcy5H5AoT7wMjxik8xj%2FlA2n%2BAI5kZeQKuf8Ale4AlUTFM%2F8Am%2FoAm8VNIOcAgOgC%2Bm5ldmVyxQw%2B6AVTL8cjy1fGGSoqIEPlDC9zIG9y5wvcc%2BoA0mFzeW5jaHJvbm91c2x56grzb2xsaW5nyU3nCBpzLvgBbeYGIuYMmU9yVcVnx2PuAOxMb25nUnVu5BPK6AD05gCgyDbqAY7sAY%2Fq\\n\\ncvZXLkATcie2VuZHBvaW50fcdy5QCT0D5BUElzxRnqA6EK5wH56g5Z5wGicyDIU3MgKHByb3RvY29s5QXZaG9zdOQDQyzlBWPnBjI6CukA8mVzdHVzLmFwaS7yAP0pLgroA0fIX%2BgDSOYLminsER%2F7EQnrAnPkAM3mEW71ESXlA6DkBotyZsRAxhzGNu4DniDpDWfnD0DEJ%2BcJ0%2BsGwSDkA%2BHFMeoEwXNoYXJlZFJvdXTkByMgIGdldMYtyV3GXOQGdMkTcy5H5AoT7wMjxik8xj%2FlA2n%2BAI5kZeQKuf8Ale4AlUTFM%2F8Am%2FoAm8VNIOcAgOgC%2Bm5ldmVyxQw%2B6AVTL8cjy1fGGSoqIEPlDC9zIG9y5wvcc%2BoA0mFzeW5jaHJvbm91c2x56grzb2xsaW5nyU3nCBpzLvgBbeYGIuYMmU9yVcVnx2PuAOxMb25nUnVu5BPK6AD05gCgyDbqAY7sAY%2FqALLnAKPpAInPYMhV5Aa300vmAY%2F4AQDrC%2FT%2FAQH3AdnmAQfmAif%2FAP%2FpAP%2FGSfMArExpc3TqD9zGLecGpiAgbGlz5wCJ8AJOyFjEP%2FYCQMQaUXVlcnnlDRjlDVzlBiQ8U3RhbmRhcmTTISAmxz3kD%2F9sZWPPID73Ao%2FpCjz1Ac3JHusB1soU%2FwHZyyvJeP4C7tFvxiHfcvYCoNJ86QD05g569AOK5AD85Ao%2F8gRb7RDk6QKHI3N1cHDkCQD%2FF0NvcmUvdXNlLXPnAcAt6QSicyIgIlRoaeUA22EgY3VzdG9t6gTA6ACJ6AYfLiLFd0By5ATIKCLnBt9zL3vGCUlkfS%2FnEmUve8lFSWR95wpB7w92xHRGb3VuZOoE5%2F0E38w85g%2By6AKx8wEk7gJwKiogU%2BcRdeoQIuYOtcQ06gpQ%2FwPZ%2BQTa6BHT5gCE8AIq8wPWQWPEG%2FYDgPMAz9sbICYgxwpJZFJlc3BvbnNlSOUJoegBBOcKIPAHeOQO1ewNtPcG1sQn8wbT6QEQxCD%2FBsD%2FB1vFQ%2FQDpO0Ag%2B0S3csY%2FAOVV2l0aOcJROcPKGTkEPvXd%2BwEe8xz7QDr13DrBHfQV%2B8GVMxa7AYK213tBgPQX%2BsGB8VD%2BwYLxCD9Bg%2FWYucQ%2BiBhbGzlEaPmE2rzDyn4Az7FeOoDQvMCMuYDRucRLPQAp%2FQIGG9s5AZpaW9u9ANNxEXuAzbyEcX1CTHxAy7sD0%2F9AzDMKfYDMswi%2FwM0%2BgM0zEX3BtpyZXBsYeQCA%2B8Ale0DRE9yUsYnzSP%2BBuTHMvkAhOYDQ9R07wD%2B12jlA0fYXekDSc1J%2FwmjyWUozDblAo77AY7sCan7ALf6Ca%2F4AMTlA67NUvUDsMwi%2FQOyz2jvFPj%2FHoj%2FHoj%2FHoj%2FHiD6HiDPN%2F4feeUQ7cd4YP8eyP8eyP8AqP8AqP8AqO0RlfgfCOYV2yAiZ2xvYmFsIiBSUEPqBCnnAbjmB8RkcyB3aXRo6ARgaW5mb3JtxSfrFd9vdmVy5AWV5wHQ6RQi5gmfxxbkCfZ0deYUIG9w5AOI5wcS6gR4UnBj6QJg5gVGe33mBRzoEcTGRFPlEB3sFq8gIMcp7RJMCuUFSX0K\\u0026e=%40azure-tools%2Ftypespec-autorest\\u0026options=%7B%22linterRuleSet%22%3A%7B%22extends%22%3A%5B%22%40azure-tools%2Ftypespec-azure-rulesets%2Fdata-plane%22%5D%7D%7D)\\r\\nFeel free to reach out with any specific questions.\\n\\nFeel free to reach out with any specific questions.\\r\\nThe linked playground is a little more complex than it needs to be, but, depending on what is in your client.tsp, is likely similar.  Note that this also gives you the option of making version-specific client.tsp changes, but simply having the linkage as shown using the `@useDependency` decorators will ensure that the client.tsp is used in both versions.\\n\\nversioning decorators is impossible, so the decorated types themselves generally need to be versioned. \\r\\nAs far as the client.tsp goes, versioning is tightly tied to a namespace (but includes all the child namespaces).  If your client.tsp is a child namespace of the versioned namespace, then no explicit version coupling is required.  If not, then you will need to replicate the versions enum from the service namespace in client.tsp,  and explicitly tie each version to the corresponding version.  I have shown an example of what I mean [in this\\n\\nOn the first question, TypeSpec is allowing you to version based on differences,  starting with the base api-version, whenever you make changes to the api, you just need to tag those changes with the 'versioning' decorator to ensure that typespec can reconstruct the api at each version that is still active.\\r\\nIn the case of `@added` this is used whenever adding a new type to the spec - a new model, a new model property, a new interface, a new parameter, a new operation - you simply decorate the element with this decorator and pass in the version that this change occurred in.  `@removed` works similarly for removing types (which is always a breaking change).  decorators like `@renamedFrom` allow you to rename types, and take the version the change occurred at and the old name of the type (the type name is changed inline). `@typeChangedFrom` works similarly - describing the state of the type before the change occurred.\\r\\nThere are some limitations around versioning (for example, versioning decorators is impossible, so the decorated types themselves generally need to be versioned. \\r\\nAs far as the client.tsp goes, versioning is tightly tied to a namespace (but includes all the child namespaces).  If your client.tsp is a child namespace of the versioned namespace, then no explicit version coupling is required.  If not, then you will need to replicate the versions enum from the service namespace in client.tsp,  and explicitly tie each version to the corresponding version.\\n\\ntypes themselves generally need to be versioned. \\r\\nAs far as the client.tsp goes, versioning is tightly tied to a namespace (but includes all the child namespaces).  If your client.tsp is a child namespace of the versioned namespace, then no explicit version coupling is required.  If not, then you will need to replicate the versions enum from the service namespace in client.tsp,  and explicitly tie each version to the corresponding version.  I have shown an example of what I mean [in this playground](https://azure.github.io/typespec-azure/playground/?c=aW1wb3J0ICJAdHlwZXNwZWMvaHR0cCI7CtIZcmVzdNUZdmVyc2lvbmluZ8wfYXp1cmUtdG9vbHMvyCstxhVjb3JlIjsKCnVzaW5nIEh0dHA7xwxSZXN0yAxWyVfIEkHEPi5Db3Jl0hIuVHJhaXRzOwoKQOcAkGVkKENvbnRvc28uV2lkZ2V0TWFuYWdlci7HWXMpCm5hbWVzcGFjZSDVKiB7CiAgLyoqIFRoySIgxiIgyCNzZXJ2aWNlIMd1LiAqLwogIGVudW3oAMFzxUfGSccTIDIwMjItMDgtMzDGMCAgQHVzZURlcGVuZGVuY3ko6wDZyEcudjFfMF9QcmV2aWV3XzIpxTdgykpgLArUaDUtMDHfaN9oyGjHSmAsCiAgfcRsLy8gTW9kZWxzIC%2FTAcUi5wE9Y29sb3Igb2YgYSB35QFA5wEodW7kAKbmAVNDxSTmASxzdHJpbmfrANFCbGFja8cpIMYqxUEgxho6ICLFCCLLM1doaXRl1TPFGjogIsUIzDNSZWTVMVJlZDogIlJlZMwtR3JlZegAvM4vxRo6ICLFCMwzQmx19gCSxBnlAMR15ACQ6AFfKiogQe4BMEByZXNvdXJjZSgixhhzIuQBoG3kAYbIWeoCbuQBesYnIOQC6sdEICBAa2V5yEFOYW1lxUQgIEB2aXNpYmlsaXR5KExpZmVjeWNsZS5SZWFkxiDERDrnAZs76gDVy2blAefJZ8UOOuwB3s82SUTkAhN0yUAncyBtYW51ZmFjdHVyZcpJzBVJZO8Agy4uLkV0YWdQcm9wZXJ0eTvsAT7EZXJlcGFpciBzdGF0ZfMCgkBscm9TdGF0dXPvAo9SxTjEG2X4ApXGKcdicyBzdWNjZWVkZWTHWyAgU8gSOiAiyQztAqTOQmZhaWzLP0bFDzogIsYJ2zl3ZXJlIGNhbmNlzEBDxxE6ICLIC9NEd2FzIHNlbnQgdG%2FlAYz1AYNTZW50VG9NyxvkANPRFfACvXN1Ym1pdHRlZOgBh3JlcXVlc3QgZm9y8AGK7ALF5gF9Usct7gLS6QHK6gI5z17HUSDIEOUBxegCiesB2O8Cj2TEWGFuZCB0aW1lIHdoZW7FY8dcaXMgc2NoZWR1bGVk5AErb2NjdeoBIMkbRGF0ZVRp5AMpdXRjyA3faclp5gDv5AGRY3JlYXTrAcvHEN9e317JXnVwxCXKXscQ317fXsleY29tcGxlzGDJEtdi7wOzcGFyYW1ldGXkAxLrAijlAfp1c8ls9wI25gPOUMRE7Ad79ARxIGJl5AhG5gHi6wCwQHBhdGjFCsYo7AR18wWdJ3PkALPzBaTEFuYFokBwYXJlbnRSyBvmALHwBbxQYXLwAu7kBXXoALXLZe4FxcQ4%2FwXJ%2FwXJyG9JROQC3HVzZeUBenJlb3JkZcQn8gCAxA3xBY\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-review\",\"content\":\"# Schedule a data plane REST API spec review\\n## Prepare for API review\\nWhen you have your REST API definition ready for review, [create a pull request with your Azure REST API spec update](xref:api-specs-pr).\\r\\n\\r\\nYou should prepare and be ready to present the following information during your review:\\r\\n\\r\\n| Title | Importance | Brief description | Example and support documentation |\\r\\n| --- | --- | --- | --- |\\r\\n\\r\\nAPI spec PR link | Must Have | PR with your API spec definition against [azure/azure-rest-api-specs-pr](https://github.com/azure/azure-rest-api-specs-pr) or [azure/azure-rest-api-specs](https://github.com/azure/azure-rest-api-specs) | In order to access the PR, it may be necessary to join the [Azure GitHub organization](https://repos.opensource.microsoft.com/orgs/Azure). \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to https://repos.opensource.microsoft.com/orgs/Azure\\u003c/li\\u003e\\u003cli\\u003eClick **Join Organization**.\\u003c/li\\u003e\\u003c/ol\\u003e\\u003cp\\u003e\\u003cp\\u003eThe PR should be linked to the issue no less than 2 days before your meeting. To properly link your PR, in the issue click on the settings icon next to `Development` on the right side:\\u003cp\\u003e\\u003cp\\u003e![Screenshot](../img/link-pr.png)  |\\r\\nAPI spec PR CI checks | Important |Make sure all CI is passing before requesting a review. | [ci-fix](https://aka.ms/ci-fix) |\\r\\nCore concepts | Must have | A glossary of nouns and verbs  | [Example](https://github.com/Azure/azure-sdk-pr/blob/main/onboarding/Core_Concepts.pdf)\\r\\nAPI reference docs | Good to have | Your API documentation consists of two parts, the API spec document (TypeSpec/OpenAPI spec), and the generated developer docs. These docs are often the first experience a developer will have with your service. Make a good first impression!!| **Recommended for OpenAPI spec**: [VS Code extension](https://marketplace.visualstudio.com/items?itemName=42Crunch.vscode-openapi) load this extension and then open your OpenAPI spec file in VS Code and select **Preview**. \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to your PR and look for the comment added by the `openapi-pipeline-app bot` and title `Swagger Generation Artifacts`.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-docs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-docs\",\"content\":\"# Publish REST API reference docs\\n## More info\\n* Learn more about [onboarding reference content to Microsoft Learn](https://learn.microsoft.com/help/onboard/reference?branch=main).\\r\\n* For help and support, you can ask questions in the [\\\"API reference and Samples\\\" Teams Channel](https://teams.microsoft.com/dl/launcher/launcher.html?url=%2F_%23%2Fl%2Fchannel%2F19%3A7506cc3e220f430ab89d992c7db5284f%40thread.skype%2FAPI%2520Reference%2520and%2520Samples%3FgroupId%3Dde9ddba4-2574-4830-87ed-41668c07a1ca%26tenantId%3D72f988bf-86f1-41af-91ab-2d7cd011db47\\u0026type=channel\\u0026deeplinkId=4d931d59-a8ff-489e-a010-100f7f950bd6\\u0026directDl=true\\u0026msLaunch=true\\u0026enableMobilePage=true\\u0026suppressPrompt=true).\\r\\n[Sample OpenAPI spec]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/Microsoft.YourServiceName/stable/YYYY-MM-DD/YourServiceName.json\\r\\n[sample README]: https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/samplefiles/README.md\\r\\n[Azure/azure-rest-api-specs]: https://github.com/Azure/azure-rest-api-specs\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-Service-Versioning-Guideline.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline\",\"content\":\"# Azure Service Versioning Guide\\n## An Azure Resource Provider and its 1+ Azure Services\\nA single Azure Resource Provider (RP) has an RP namespace. This RP namespace can contain 1+ control-plane services and 0+ data-plane service; each service versions as described above. Today, we want the GitHub specs repo to be structured as follows for control-plane \\u0026 data-plane contracts:\\r\\n```\\r\\nspecification/\\r\\n└── \\u003corgName1\\u003e/\\r\\n    ├── cspell.yaml\\r\\n    └── resource-manager/\\r\\n        ├── readme.md\\t\\t\\tß NOTE: For ARM schema validation; see bullet #2 below\\r\\n        └── \\u003cRPNamespace\\u003e/\\t\\tß NOTE: Control-plane only (not data-plane) \\r\\n            └── \\u003cServiceName1\\u003e/\\tß Customer-facing service name; each version gets Documentation \\u0026 SDK package\\r\\n                ├── tspconfig.yaml\\tß TypeSpec files\\r\\n                ├── main.tsp\\r\\n                ├── models.tsp\\r\\n                ├── readme.md\\t\\tß autorest readme with YAML blocks\\r\\n                └── examples/\\t\\tß TypeSpec example folder\\r\\n                    └── \\u003capi-version\\u003e/\\tß One folder per service version described in TypeSpec\\r\\n                        └── \\u003cexample .json files\\u003e \\r\\n                └── preview/ and stable/\\r\\n                    └── \\u003capi-version\\u003e/\\tß One folder per service version described in OpenAPI. These folders are created and populated by compiling the TypeSpec folder for the service.\\r\\n                        ├── \\u003cOpenAPI .json files\\u003e\\r\\n                        └── examples/\\tß OpenAPI example folder\\r\\n                            └── \\u003cexample .json files\\u003e\\r\\n            └── \\u003cServiceName2\\u003e/\\t// Customer-facing service name; contents identical to above structure\\r\\n    └── data-plane/\\r\\n        └── \\u003cServiceName3\\u003e/\\t// Customer-facing service name; contents identical to above structure\\r\\n```\\r\\nIn this structure, Azure services are presented as an RPNamespace that is used to manage services (both with customer-facing names). Each service has versions (some preview and some GA) and each version has its own API contract, documentation, and (beta/stable) SDK package(s).\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#azure-resource-manager#step05.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step05\",\"content\":\"# 6. Complete Example and Generate OpenApi 2.0 spec\\nTo generate an OpenAPI v2 (Swagger) specification from the service definition, run the following command inside of the project folder:\\r\\n\\r\\n```\\r\\ntsp compile . --emit @azure-tools/typespec-autorest\\r\\n```\\r\\n\\r\\nThis will create a file in the `tsp-output` subfolder called `openapi.json`.\\r\\n\\r\\nYou can learn more about the `typespec-autorest` emitter and its options by reading its [README.md](https://github.com/Azure/typespec-azure/blob/main/packages/typespec-autorest/README.md).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# Create a pull request with your Azure REST API spec update\\n## Create a PR against a specs repo\\n\\u003e [!TIP]\\r\\n\\u003e If you have an existing PR in the private repo and you want to move it to the public repo, refer to [this guide](xref:pr-move-private-to-public).\\r\\n\\r\\nWhen you are ready to submit your REST API spec updates for review, you must create a pull request (PR) in either the  \\r\\n[public or private specs repository](xref:api-repos). When creating the PR, you should select either the\\r\\n**Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API spec updates you are\\r\\nsubmitting.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e The PR template and comments added by the PR automation will guide you through the process of getting your PR reviewed,\\r\\napproved, and merged.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#azure-resource-manager#step00.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/azure-resource-manager/step00\",\"content\":\"# 1. Installing Tools\\n## Creating a Service\\nThe Azure Resource Manager Service Project will create a very basic TypeSpec file in `main.tsp`:\\r\\n```typespec\\r\\nimport \\\"@typespec/rest\\\";\\r\\nimport \\\"@typespec/versioning\\\";\\r\\nimport \\\"@azure-tools/typespec-autorest\\\";\\r\\nimport \\\"@azure-tools/typespec-azure-core\\\";\\r\\nimport \\\"@azure-tools/typespec-azure-resource-manager\\\";\\r\\n```\\r\\nThese lines import the libraries you will need to build your first service.\\r\\n**Add the following lines** to bring the models, operations, and decorators you will need into the specification:\\r\\n```typespec\\r\\nusing Http;\\r\\nusing Rest;\\r\\nusing Versioning;\\r\\nusing Azure.ResourceManager;\\r\\n```\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#azure-core#step10.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10\",\"content\":\"# 10. Versioning\\n## Versioning your service\\nto the `Versions` enum:\\r\\n\\r\\n```typespec\\r\\nenum Versions {\\r\\n  v2022_08_31: \\\"2022-08-31\\\",\\r\\n  v2022_11_30: \\\"2022-11-30\\\",\\r\\n}\\r\\n```\\r\\n\\r\\nYou will also need to add the `@useDependency` decorator:\\r\\n\\r\\n```typespec\\r\\nenum Versions {\\r\\n  v2022_08_31: \\\"2022-08-31\\\",\\r\\n  v2022_11_30: \\\"2022-11-30\\\",\\r\\n}\\r\\n```\\r\\n\\r\\nFinally, you can express changes to your service using the `@added` and `@removed` decorators. Here's an example of adding a new property to `Widget` and removing an old one:\\r\\n\\r\\n```typespec\\r\\n/** A widget. */\\r\\n@resource(\\\"widgets\\\")\\r\\nmodel Widget {\\r\\n  /** The widget name. */\\r\\n  @key(\\\"widgetName\\\")\\r\\n  @visibility(Lifecycle.Read)\\r\\n  name: string;\\r\\n\\r\\n  /** The widget color. */\\r\\n  @added(Contoso.WidgetManager.Versions.v2022_11_30)\\r\\n  color: string;\\r\\n\\r\\n  /** The ID of the widget's manufacturer. */\\r\\n  @removed(Contoso.WidgetManager.Versions.v2022_11_30)\\r\\n  manufacturerId: string;\\r\\n}\\r\\n```\\r\\n\\r\\n\\u003e You can do a lot more with versioning decorators, so consult the `typespec-versioning` [README.md](https://github.com/microsoft/typespec/tree/main/packages/versioning#enable-versioning-for-service-or-library) for more information on how you can use them to annotate your service and describe changes between different versions.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#azure-core#step10.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/azure-core/step10\",\"content\":\"# 10. Versioning\\n## Versioning your service\\nIt is inevitable that service specifications will change over time. It is a best practice to add versioning support to your specification from the first version. To do that, you will need to define an `enum` containing your service versions and then apply the `@versioned` decorator to your service namespace.\\r\\n\\r\\nHere is an example for the `WidgetManager` service:\\r\\n\\r\\n```typespec\\r\\n@service(#{ title: \\\"Contoso Widget Manager\\\" })\\r\\n@versioned(Contoso.WidgetManager.Versions)\\r\\nnamespace Contoso.WidgetManager;\\r\\n\\r\\nenum Versions {\\r\\n  v2022_08_31: \\\"2022-08-31\\\",\\r\\n}\\r\\n```\\r\\n\\r\\nThere are a few things to point out here:\\r\\n\\r\\n- We define an `enum` called `Versions` inside of the service namespace. For each service version, we map a version symbol like `v2022_08_31` to a version string like `2022-08-31`. This service currently only has a single version, but we can add more to this enum as things change over time.\\r\\n- We add the `@versioned` decorator and reference the `Versions` enum we defined using the fully-qualified name `Contoso.WidgetManager.Versions`. This marks the service as being versioned and specifies the set of versions.\\r\\n- We change the `@useDependency` decorator we used previously to now link each service version to a specific version of `Azure.Core`. See the [Using Azure.Core Versions](#using-azurecore-versions) section for more information.\\r\\n\\r\\nImagine that it's 3 months later and you want to release a new version of your service with some slight changes. Add a new version to the `Versions` enum:\\r\\n\\r\\n```typespec\\r\\nenum Versions {\\r\\n  v2022_08_31: \\\"2022-08-31\\\",\\r\\n  v2022_11_30: \\\"2022-11-30\\\",\\r\\n}\\r\\n```\\r\\n\\r\\nYou will also need to add the `@useDependency` decorator:\\r\\n\\r\\n```typespec\\r\\nenum Versions {\\r\\n  v2022_08_31: \\\"2022-08-31\\\",\\r\\n  v2022_11_30: \\\"2022-11-30\\\",\\r\\n}\\r\\n```\\r\\n\\r\\nFinally, you can express changes to your service using the `@added` and `@removed` decorators. Here's an example of adding a new property to `Widget` and removing an old one:\\r\\n\\r\\n```typespec\\r\\n/** A widget. */\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#code-generation-csharp.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/getting-started/code-generation-csharp\",\"content\":\"# Getting started with TypeSpec server code generation for C#\\n## 9. Evolving your API\\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\\r\\n\\r\\n1. Modify your TypeSpec definition (e.g., add new models or operations)\\r\\n\\r\\n2. Recompile to update the generated code:\\r\\n\\r\\n```bash\\r\\ntsp compile .\\r\\n```\\r\\n\\r\\nThis updates the generated files (controllers, interfaces, models) but preserves your implementation files.\\r\\n\\r\\n3. If you've added entirely new resources that require new implementation files:\\r\\n\\r\\n```bash\\r\\nnpx hscs-scaffold main.tsp\\r\\n```\\r\\n\\r\\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/categories\\\")\\r\\n@tag(\\\"Categories\\\")\\r\\ninterface Categories {\\r\\n  /** List categories */\\r\\n  @get list(): CategoryList | Error;\\r\\n  // More operations...\\r\\n}\\r\\n```\\r\\n\\r\\nWhen you run the scaffolding step again:\\r\\n\\r\\n- It will create new files for the new `Categories` interface (`CategoriesController.cs`, `ICategories.cs`, and `CategoriesImpl.cs`)\\r\\n- It won't overwrite your existing `Widgets.cs` with your custom business logic\\r\\n- This allows you to incrementally add new resources without losing your existing implementations\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"introduction#installation.mdx\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/introduction/installation\",\"content\":\"# Installation\\n## Create a new TypeSpec project\\n\\u003cTabs\\u003e\\r\\n  \\u003cTabItem label=\\\"CLI\\\"\\u003e\\r\\n\\r\\n\\u003cSteps\\u003e\\r\\n\\r\\n1. Create a new TypeSpec project.\\r\\n\\r\\n   ```bash\\r\\n   tsp init\\r\\n   ```\\r\\n\\r\\n   This will prompt you with a few questions. Pick the `Generic REST API` template, your project name, and make sure the `@typespec/http` and `@typespec/openapi3` libraries are selected.\\r\\n\\r\\n2. Run a build to generate the OpenAPI specification output file.\\r\\n\\r\\n   ```bash\\r\\n   tsp compile .\\r\\n   ```\\r\\n\\r\\n\\u003c/Steps\\u003e\\r\\n  \\u003c/TabItem\\u003e\\r\\n  \\u003cTabItem label=\\\"VS Code\\\"\\u003e\\r\\n\\r\\n\\u003cSteps\\u003e\\r\\n\\r\\n1. Invoke the command `\\u003eTypeSpec: Create TypeSpec Project` to create TypeSpec project, or click `Create TypeSpec Project` button from the Primary Sidebar of Explorer.\\r\\n2. Follow Quick Picks to select root folder of your project, pick the `Generic REST API` template, input your project name, make sure the `@typespec/http` and `@typespec/openapi3` libraries are selected, then return to launch project scaffolding.\\r\\n\\r\\n\\u003c/Steps\\u003e\\r\\n\\r\\n![vscode_project_scaffolding.gif](https://raw.githubusercontent.com/microsoft/typespec/main/website/src/content/docs/docs/images/vscode_project_scaffolding.gif)\\r\\n\\r\\n  \\u003c/TabItem\\u003e\\r\\n\\u003c/Tabs\\u003e\\r\\n\\r\\nYou should now have a basic TypeSpec project setup with a structure looking like this:\\r\\n\\r\\n{/* prettier-ignore */}\\r\\n\\u003cFileTree\\u003e\\r\\n- main.tsp\\r\\n- tspconfig.yaml\\r\\n- package.json\\r\\n- node_modules/\\r\\n- tsp-output/\\r\\n  - @typespec/\\r\\n    - openapi3/\\r\\n      - openapi.yaml\\r\\n\\u003c/FileTree\\u003e\\r\\n\\r\\n- **main.tsp**: The entry point for your TypeSpec build. This file typically contains the main definitions for your models, services, and operations.\\r\\n- **tspconfig.yaml**: Configuration file for the TypeSpec compiler, specifying options and settings for the build process.\\r\\n- **package.json**: Contains metadata about the project, including dependencies, scripts, and other project-related information.\\r\\n- **node_modules/**: Directory where npm installs the project's dependencies.\\r\\n- **tsp-output/**: Directory where the TypeSpec compiler outputs generated files.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Specification-Folder-Structure-Guide.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Specification-Folder-Structure-Guide\",\"content\":\"# Azure REST API Specification Directory Structure\\n## Service folder structure\\n### Contents of a service folder\\nEach service folder contains a standardized set of files and directories organized by their purpose and the development approach used (TypeSpec vs. OpenAPI).\\r\\nA service folder contains the following elements:\\r\\n**TypeSpec files** (for TypeSpec-based services):\\r\\n- `main.tsp` - Main TypeSpec entry point for the service\\r\\n- `tspconfig.yaml` - TypeSpec compilation configuration with OpenAPI/SDK emitter options\\r\\n- Additional `*.tsp` files - Supporting TypeSpec files for the service\\r\\n- `examples/\\u003capiVersion\\u003e/` - TypeSpec examples organized by API version\\r\\n**README and configuration files**:\\r\\n- `readme.md` - Central file that groups APIs into different tags for tooling purposes\\r\\n- `readme.lang.md` - Language-specific README files for SDK generation (deprecated when TypeSpec is used)\\r\\n**Generated OpenAPI specifications**:\\r\\n- `stable/\\u003capiVersion\\u003e/` - Contains stable API version specifications\\r\\n- `preview/\\u003capiVersion\\u003e/` - Contains preview API version specifications\\r\\nThe `stable` and `preview` folders contain OpenAPI specifications in their respective [lifecycle stages][aka.ms/azsdk/api-versions], organized in `\\u003capiVersion\\u003e` subfolders for each service API version.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-Service-Versioning-Guideline.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline\",\"content\":\"# Azure Service Versioning Guide\\n## An Azure Resource Provider and its 1+ Azure Services\\n\\u003cServiceName2\\u003e/\\t// Customer-facing service name; contents identical to above structure\\r\\n    └── data-plane/\\r\\n        └── \\u003cServiceName3\\u003e/\\t// Customer-facing service name; contents identical to above structure\\r\\n```\\r\\nIn this structure, Azure services are presented as an RPNamespace that is used to manage services (both with customer-facing names). Each service has versions (some preview and some GA) and each version has its own API contract, documentation, and (beta/stable) SDK package(s).   \\r\\n\\r\\nTo enforce these rules, here are some notes about the repo structure:\\r\\n\\r\\n1.\\tIn the resource-manager folder, if it's a RPaaS service, there must be just 1 readme.md file, and 1+ service name folders under resource-manager/RPnamespace folder, but the resource types within each service folder must not duplicate except for operations, locations, checkNameAvailability etc. Which is required by RPaaS for HTTP request schema validation.\\r\\n2.\\tIn the data-plane folder there must be no files and at least 1 service name folder.\\r\\n3.\\tThe ServiceName folder must have only readme.*, tspconfig.yaml and *.tsp files in it. \\r\\n    - In the readme.md file, the latest package tag value (which represents a service version) must refer to OpenAPI files that are all in the exact same folder. Also, if the tag value is suffixed with “-preview” then all the OpenAPI paths must refer to files in the preview subfolder; else all OpenAPI paths must refer to files in the stable subfolder.\\r\\n    - If 2+ services want to “share” some TypeSpec/OpenAPI files, these files must be explicitly copied into a consuming service’s folder on its desired timeline. We do not allow multiple services to reference a single copy of a service contract because it is too dangerous to allow one service to change a shared contract, forcing other services to pick up this shared contract instantly, especially if the shared contract introduces breaking changes. Each service must be in control of its own destiny.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Specification-Folder-Structure-Guide.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Specification-Folder-Structure-Guide\",\"content\":\"# Azure REST API Specification Directory Structure\\n## `specification/common-types`\\nThe [`specification/common-types`] directory serves a special purpose in the repository structure, containing shared definitions that can be reused across all Azure service specifications.\\r\\n**Purpose and usage:**\\r\\n- Contains common models, types, and operations used across multiple Azure services\\r\\n- Enables consistency and reduces duplication across service specifications\\r\\n- Provides standardized definitions for common Azure patterns\\r\\n**Important limitations:**\\r\\nWhen you need to share definitions beyond those available in [`specification/common-types`], you must duplicate them in each service's own folder. This requirement ensures that each service maintains independent control over the versioning lifecycle of shared definitions.\\r\\n**Best practice for managing shared definitions:**\\r\\nTo minimize the maintenance burden of duplicate copies, service teams can implement a shared ownership pattern:\\r\\n1. **Designate an owner service** - The service that creates or updates the shared models becomes the owner.\\r\\n2. **Create a `sharable/` folder** - The owner service creates this folder to make definitions available for copying.\\r\\n3. **Use `copyFrom*Sharable` folders** - Other services create these folders to indicate copied content that should not be edited directly.\\r\\n**Example structure:**\\r\\n```diff\\r\\nspecification/compute/resource-manager/Microsoft.Compute/\\r\\n├── ComputeRP\\r\\n+│   ├── sharable/\\r\\n│   ├── *.tsp\\r\\n│   ├── main.tsp\\r\\n│   ├── tspconfig.yaml\\r\\n│   ├── readme.md\\r\\n│   ├── preview/\\r\\n│   └── stable/\\r\\n├── RecommenderRP\\r\\n+    ├── copyFromComputeSharable\\r\\n    ├── *.tsp\\r\\n    ├── main.tsp\\r\\n    ├── tspconfig.yaml\\r\\n    ├── readme.md\\r\\n    ├── preview/\\r\\n    └── stable/\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-specs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-specs\",\"content\":\"# Create or update an Azure REST API spec\\n## Create your REST API definition\\n### [TypeSpec](#tab/typespec)\\nServices that use TypeSpec Azure to describe their REST API must include both the TypeSpec source spec and generated OpenAPI\\r\\nspecs in the specs repo.\\r\\n\\r\\nIt is good practice to create a new branch in the specs repo for each new REST API definition that you create.\\r\\nUse this branch to iterate on your REST API definition until it is ready for review.\\r\\n\\r\\n- [Spec directory structure]\\r\\n- See our [tutorial](xref:api-tutorial) for more help.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-spec-gen-sdk-config.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-spec-gen-sdk-config\",\"content\":\"# SDK generation configuration\\nTo generate SDK code based on REST API specifications, you need to configure the corresponding files.\\r\\n\\r\\n- For TypeSpec, the configuration file is `tspconfig.yaml`.\\r\\n- For OpenAPI, the configuration file is `readme.md`.\"}]",
            "inputs.latency": 553.706068277359,
            "inputs.response_length": 3357,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://azure.github.io/typespec-azure/docs/getstarted/createproject",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Specification-Folder-Structure-Guide",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline"
            ],
            "inputs.testcase": "Creating new service typespec definition",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1856,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1857,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Creating new service typespec definition\\\\n\\\\nquestion: Hello,\\\\nI'm currently writing a new definition for a service and wanted to ask if there's any guidance on how to go about it. I saw this guide [Work against the release branch](https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-2-update) however it doesn't go over creating the service folder and creating the readme.md file, please help with this, thanks\\\", \\\"response\\\": \\\"To add a new TypeSpec service definition to the Azure REST API specs repo, you should follow these recommended steps and conventions, which ensure compliance with Azure API guidelines and enable smooth SDK generation and validation:\\\\n\\\\n**1. Folder Structure:**\\\\n- For management-plane (ARM) services, your files should be under:\\\\n  `specification/<organization>/resource-manager/<RPnamespace>/<ServiceName>/`\\\\n- For data-plane services, use:\\\\n  `specification/<organization>/data-plane/<ServiceName>/`\\\\n\\\\nEach service folder should contain:\\\\n- `main.tsp` (TypeSpec entry point)\\\\n- `tspconfig.yaml` (TypeSpec config and emitter options)\\\\n- Additional `*.tsp` files as needed\\\\n- `readme.md` (central config for code generation)\\\\n- Example files: `examples/<apiVersion>/...`\\\\n- Generated OpenAPI specs: `stable/<apiVersion>/...` and/or `preview/<apiVersion>/...`\\\\n\\\\n**2. Creating the Service Folder:**\\\\n- Follow the directory structure guidelines: https://github.com/Azure/azure-rest-api-specs/wiki/Specification-Folder-Structure-Guide\\\\n- Use the TypeSpec Azure template to scaffold your service folder and starter files:\\\\n  ```bash\\\\n  npx tsp init https://aka.ms/typespec/azure-init\\\\n  ```\\\\n  This will prompt for the correct template and set up initial files.\\\\n\\\\n**3. Creating README.md:**\\\\n- The `readme.md` file is required in each service folder. It specifies input files, tags (versions), and configuration for the Autorest tool.\\\\n- For management-plane services, it should indicate ARM and RPaaS subtype, and list the generated OpenAPI files:\\\\n\\\\n  Example:\\\\n  ```yaml\\\\n  openapi-type: arm\\\\n  openapi-subtype: rpaas\\\\n  tags:\\\\n    - tag: package-2025-08-15\\\\n      input-file:\\\\n        - stable/2025-08-15/Limit.json\\\\n  ```\\\\n- For data-plane, omit ARM-specific fields but include the relevant OpenAPI files under the latest tag.\\\\n- See a sample here: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/readme.md\\\\n\\\\n**4. tspconfig.yaml:**\\\\n- Ensure emitter options point to the correct output folder and ARM types directory (if applicable):\\\\n  ```yaml\\\\n  options:\\\\n    \\\\\\\"@azure-tools/typespec-autorest\\\\\\\":\\\\n      emitter-output-dir: \\\\\\\"{project-root}\\\\\\\"\\\\n      output-file: \\\\\\\"{version-status}/{version}/widget.json\\\\\\\"\\\\n      arm-types-dir: \\\\\\\"{project-root}/../../../../common-types/resource-management\\\\\\\"\\\\n  ```\\\\n\\\\n**5. Example Files:**\\\\n- Place API examples in `examples/<apiVersion>/`. You can generate basic examples with the [oav](https://github.com/Azure/oav) tool and then adjust for meaningful data.\\\\n\\\\n**6. Compile and Validate:**\\\\n- Compile TypeSpec to generate OpenAPI files:\\\\n  ```bash\\\\n  npx tsp compile .\\\\n  ```\\\\n- Make sure generated files are in the correct folders and referenced by README.md.\\\\n- Fix any CI errors by updating TypeSpec, not the generated OpenAPI directly.\\\\n\\\\n**Summary of Steps:**\\\\n1. Create the correct folder structure using the template.\\\\n2. Fill in `main.tsp`, `tspconfig.yaml`, and `readme.md` as shown above.\\\\n3. Add or generate example files.\\\\n4. Compile and verify OpenAPI output and references.\\\\n5. Push your branch and open a PR for review.\\\\n\\\\nThis process ensures your service spec is compliant and ready for Azure tooling and review.\\\\n\\\\nIf you need a sample, the Widget service in the repo is a good reference: https://github.com/Azure/azure-rest-api-specs/tree/main/specification/widget/resource-manager/Microsoft.Widget/Widget\\\", \\\"ground_truth\\\": \\\"The first thing is to start in the specs repositories.\\\\nYou can use:\\\\nCopilot to help you create folder structure, files needed, etc\\\\nUse the [Azure SDK Tools MCP](https://aka.ms/azsdk/agent#generate-code) which will have more context and will utilize what it is in the specs repositories.\\\\nThis is a new service API? If it's new, you should be able to ask copilot (in vscode) to create a new service, and it will prompt you for some information to create the proper folder structure\\\\nThe documentation it is using is based on https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline, then it will initialize a project for you after the folders are created.\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: Creating a Management Plane RP and referencing Data Plane model\n\nquestion: Hello API Spec Review, I'm currently working on creating a new management plane RPAAS RP in the private spec repo based off of the `RPSaaSMaster` branch, the service spec requires a reference to Compute RP model `VMProfileProperties` however the `specification\\compute` folder for Compute is only available in the main branch of the private repo, so I wanted to ask:\nIs it possible to create a RPAAS RP based on the main branch in the private repo?\nCan a RPAAS RP reference a model in a data plane RP?\nIs there a way to reference the compute model from the RPSaaSMaster branch?\nThanks!",
            "inputs.ground_truth": "resource-manager specs should not share anything with data-plane specs.  Our latest guidelines go even further, preventing any sharing across different specs:\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline",
            "inputs.response": "Let's address your questions based strictly on Azure API specification, repo, and TypeSpec guidelines:\n\n1) **Is it possible to create a RPAAS RP based on the main branch in the private repo?**\n\nNo, you should not create a new RPaaS RP spec directly based on the `main` branch in the private spec repo. The private spec repo `main` branch is a **read-only mirror of the public main branch** and is not intended for direct development or onboarding of new RPaaS RPs. RPaaS specs in private preview must use the `RPSaaSMaster` branch (see knowledge references below). You should create your new spec branch off `RPSaaSMaster`, not private/main.\n\n2) **Can a RPAAS RP reference a model in a data plane RP?**\n\nNo, this is not allowed by Azure spec repo rules. Each service (control plane or data plane) must own and version its own models independently. If you need to use a model like `VMProfileProperties` from another RP (even if it is Compute), you must **duplicate** the model in your own service folder. This is to avoid shared contracts that can break downstream consumers if the original is changed. You cannot reference a model from another RP folder (see Azure Service Versioning Guide and Spec Folder Structure Guide). If common types are needed, they must be copied into your RP's folder.\n\n3) **Is there a way to reference the Compute model from the RPSaaSMaster branch?**\n\nNo, you cannot directly reference or import the model from the Compute RP's folder, whether it's in main or RPSaaSMaster. The correct process is to copy the model definition (`VMProfileProperties`) into your own RP folder and maintain it independently. If Compute updates the model in the future, you must manually copy any desired changes. This rule ensures service independence and prevents breaking changes due to shared contracts.\n\n**Summary of actions:**\n- Create your RPaaS RP spec branch from `RPSaaSMaster`.\n- Copy the required Compute model (`VMProfileProperties`) into your RP's folder (do not reference or import from Compute RP directly).\n- Maintain and version the model as part of your RP spec.\n\nIf you need further clarification on the repo branching or TypeSpec referencing rules, please refer to the references below or ask follow-up questions.",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"Create a PR against main\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\\n\\n# Create a PR against main\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nWhen you're ready for a final review, it's time to create a pull request (PR) from your release branch you created\\r\\noriginally to the `main` branch on [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n* :warning: Do not merge `main` or other release branches unless you know there are changes required.\\r\\n* :white_check_mark: Rebase on `main` if changes are required in a separate topic branch.\\n\\n## Clean PR against main\\n\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\\n\\n## Update your branch with changes from main\\n\\nIf you know there are other changes in the `main` branch or that other services have updated shared files in `main`\\r\\nalready and you need to pick up changes before merging, we recommend you take a merge from main. This is particularly interesting\\r\\nfor common infrastructure changes that are committed in the repo (i.e. github actions, tools, etc). Depending on how old your\\r\\nbranch is some of the pull request checks may not correctly function without taking a merge from main. \\r\\n\\r\\nIf you are working in a non-protected branch you can do a `git merge main` like you would normally do a merge and then push\\r\\nyour changes to your remote branch. However, if you are working in a branch with branch protection enabled (i.e. `release-*`) then\\r\\nyou will need to make a pull request to your branch with the merge. Depending on how out-of-date your branch is from `main` your \\r\\nmerge may have a lot of unwanted and unnecessary changes and the checks not pass. In such cases see below on how to [update the infrastructure](#updating-only-the-infrastructure-changes-from-main).\\n\\n### Updating only the infrastructure changes from main\\n\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\\n\\n## Next steps\\n\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# design#api-specs-pr#api-versions-and-branches.md\\n\\n| Short Link: | [aka.ms/azsdk/api-versions](https://aka.ms/azsdk/api-versions) |\\r\\n|--|--|\\n\\n# API versions and branches\\n\\nThis article explains the various lifecycle stages of spec API versions and how do they relate to git branches of the  \\r\\n[specs repositories](xref:api-repos).\\n\\n## Spec repos branches table\\n\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\n| Branch                 | [Public repository][public specs repo]        | [Private repository][private specs repo]              |\\r\\n|------------------------|-----------------------------------------------|-------------------------------------------------------|\\r\\n| `main`                 | All API versions in `GA` and `public preview` | Mirrored from public `main`                           |\\r\\n| `RPSaaSMaster`         | N/A                                           | For RPaaS-based specs in `private preview`   |\\r\\n| `RPSaaSDev`            | N/A                                           | For dogfooding RPaaS-based specs.                     |\\r\\n| `release-*`            | Feature branches.                             | Feature branches.                                     |\\r\\n| `dev-*`                | Obsolete. Use `release-*` instead.            | Obsolete. Use `release-*` instead.                    |\\r\\n| `ARMCoreRPDev`         | N/A                                           | [Obsolete ShiftLeft branch]. Use `release-*` instead. |\\r\\n| `InternalARMContracts` | N/A                                           | For ARM-internal APIs, never published to customers.  |\\r\\n\\r\\nIf a given branch in the public or private spec repos is not listed in the table above, then most likely\\r\\nit is obsolete, deprecated, or otherwise not recommended for use.\\n\\n## Branch protection rules table\\n\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\nThis table shows which GitHub checks are marked as `required` on respective branches. Even when a check is marked as ❌\\r\\nit **may** still be running on given branch; just that if it fails, the PR won't be blocked from merging.\\r\\n\\r\\n| Branch | Merge | SDK | TSVal | BrCh | BrChC | LintRPaaS | LintDiff | Model | Semantic | Spell | Prettier | license | approver |\\r\\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\\r\\n| public `main`                  | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSMaster`         | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| public/private `release-*`     | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSDev`            | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `InternalARMContracts` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `ARMCoreRPDev`         | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n\\r\\nLegend:\\r\\n\\r\\n| Column name | Full GitHub check name               |\\r\\n|-------------|--------------------------------------|\\r\\n| `BrCh`      | `Swagger BreakingChange`             |\\r\\n| `BrChC`     | `Breaking Change(Cross-Version)`     |\\r\\n| `license`   | `license/cla`                        |\\r\\n| `LintDiff`  | `Swagger LintDiff`                   |\\r\\n| `LintRPaaS` | `Swagger Lint(RPaaS)`                |\\r\\n| `Merge`     | `Automated merging requirements met` |\\r\\n| `Model`     | `Swagger ModelValidation`            |\\r\\n| `Prettier`  | `PrettierCheck`                      |\\r\\n| `SDK`       | `SDK azure-sdk-for-go`               |\\r\\n| `Semantic`  | `Swagger SemanticValidation`         |\\r\\n| `Spell`     | `SpellCheck`                         |\\r\\n| `TSVal`     | `TypeScript Validation`              |\\r\\n| `approver`  | Requires team member approval        |\\r\\n\\r\\nFor more information on these checks, see:\\r\\n\\r\\n- https://aka.ms/azsdk/pr-getting-help\\r\\n- https://aka.ms/ci-fix\\n\\n## API version lifecycle stages\\n\\nAn API version is a TypeSpec/OpenAPI specification contract identified by its `api-version` value.\\r\\n\\r\\nGiven API version is located in its own directory in the specs repositories. It can be in following lifecycle stages:\\r\\n\\r\\n- `generally available` (aka `GA`, `stable`)\\r\\n- `public preview`\\r\\n- `private preview`\\r\\n- `in development`\\r\\n- `closing down`\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e A `closing down` API spec version need to be kept in the spec repository until it is fully `deprecated`. A `deprecated` API spec version need to be removed from the spec repository, with removal initiated by the service to begin deprecating related APIs, SDKs, and CLIs.\\r\\n\\r\\nThese stages corresponds to [service tree lifecycle stages] as elaborated on in [ARM lifecycle stages requirements].\\n\\n### Generally available\\n\\n**GA** API versions have been released to all Azure customers.\\r\\n\\r\\nFor an API version to be in GA it must:\\r\\n\\r\\n- Be present in the `main` branch of the [public specs repo].\\r\\n- Be in a parent `stable` folder and without a `-preview` suffix. See [spec directory structure] for full details.\\r\\n- Not be gated by any feature flags, including Azure Feature Exposure Control ([AFEC]) flags.\\n\\n### Public preview\\n\\n**Public preview** API versions have been released to all Azure customers, but are not yet GA.\\r\\nFor an API version to be in `public preview`, it must:\\r\\n\\r\\n- Not yet be GA.\\r\\n- Be present in the `main` branch of the [public specs repo].\\r\\n- Be in a parent `preview` folder and have `-preview` suffix in its folder name.\\r\\n  See [spec directory structure] and [ARM preview guidelines] for full details.\\r\\n- Not be gated by any feature flags, including [AFEC] flags.\\n\\n### Private preview\\n\\n**Private preview** API versions have been released to a limited set of Azure customers.\\r\\n\\r\\nUsually API versions are in `private preview` for following reasons:\\r\\n\\r\\n- The spec API version preview cannot yet be made public due to business or marketing reasons.\\r\\n- Early customer feedback is being gathered for given API version preview.\\r\\n\\r\\nFor an API version to be in `private preview`, it must:\\r\\n\\r\\n- Not yet be `GA` or in `public preview`.\\r\\n- Not be present in the [public specs repo] `main` branch or any other branch in that repo.\\r\\n- Be in a parent `preview` folder and have `-prefix` in its folder name.\\r\\n  See [spec directory structure] and [ARM preview guidelines] for full details.\\r\\n- Have at least one customer. If an API version has no customers, it is `in development`, not in `private preview`.\\r\\n- In case of ARM specs:\\r\\n  - Be present in the `RPSaaSMaster` branch of the [private specs repo].\\r\\n    See [ARM branches] and [ARM lifecycle stages requirements] for details.\\r\\n  - Be under access control done with [AFEC] flags.\\r\\n- In case of data-plane specs:\\r\\n  - Can be in any branch in the [private specs repo], except `main` or `RPaaS*` branches,\\r\\n    as there is no designated branch like `RPSaaSMaster` for ARM specs.\\r\\n  - There is no need for access control done with [AFEC] flags, as data plane services should have some mechanism\\r\\n    for allowing `private preview` customers to onboard the preview.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e A `private preview` API spec version can be published as `public preview` by following  \\r\\n\\u003e [this how-to](xref:pr-move-private-to-public).\\n\\n### In development\\n\\n**In development** API versions are all API versions that are not `GA`, in `public preview` or in `private preview`.\\r\\nNotably, such API versions are not present in the [public specs repo] `main` branch and do not have any customers.\\r\\nHowever, they may be present in the public repo feature branches.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e REST API definitions for a service or API version that is `in development` MUST NOT be present in the  \\r\\n\\u003e [public specs repo] `main` at all.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e ARM spec API version, while `in development`, should not be trying to merge into `RPSaaSMaster`.\\r\\n\\u003e The ARM guidance for this is in [ARM spec onboarding] article.\\r\\n\\r\\n**Special cases** There are few special situations that do not fit in the API versioning model described above.\\r\\nIn such situations, attend appropriate office hours:\\r\\n\\r\\n- In case of ARM specs, **ARM API Review Office Hours** in [aka.ms/armofficehoursinfo].\\r\\n- In case of data-plane specs, [aka.ms/azapi/officehours].\\n\\n## Spec repos branches\\n\\n### Public specs repo `main` branch\\n\\nAll API versions in the [public specs repo] `main` branch are published to all Azure customers.\\r\\nThis branch includes `GA` and `public preview` API versions.\\r\\n\\r\\n\\u003e [!CAUTION]\\r\\n\\u003e This is not a dev branch. It should contain **only** finished specs that represent services deployed to customers.\\n\\n### Private specs repo `main` branch\\n\\n[Private specs repo] `main` branch is mirrored from [public specs repo] `main` branch by a CI job on a regular basis.\\r\\nAs such, it is **read only**.\\n\\n### Private specs repo `RPSaaSMaster` branch\\n\\n[Private specs repo] `RPSaaSMaster` contains RPaaS-based ARM specifications.\\r\\n\\r\\nWhen an RPaaS-based ARM API goes into `public preview` or `GA` lifecycle stage it must be merged to [public specs repo]\\r\\n`main` as well.\\r\\n\\r\\nSome parts of this branch are being mirrored from public `main` branch\\r\\nby the [mirror-repos] pipeline, triggered manually on at least daily basis.\\r\\n\\r\\nService teams are responsible for keeping their API specifications in this branch synchronized with\\r\\nthe public specs repo `main` branch.\\r\\n\\r\\nSee also [ARM lifecycle stages requirements] and [ARM branches].\\n\\n### `RPSaaSDev` branch\\n\\nUsed for internal ARM dogfooding. See `RPSaaSDev` in [ARM branches].\\r\\n\\r\\nSome parts of this branch are being mirrored from public `main` branch\\r\\nby the [mirror-repos] pipeline, triggered manually on at least daily basis.\\r\\n\\r\\nService teams are responsible for keeping their API specifications in this branch synchronized with\\r\\nthe public specs repo `main` branch.\\r\\n\\r\\nSee also [ARM lifecycle stages requirements] and [ARM branches].\\n\\n### `release-*` branches\\n\\nAll branches with prefix `release-`, both in public and private specs repos. Also known as \\\"feature\\\" branches.\\r\\n\\r\\nThese branches are used for col\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-Service-Versioning-Guideline.md\",\"document_title\":\"Azure Service Versioning Guide\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline\",\"content\":\"# Azure-Service-Versioning-Guideline.md\\n\\n# Azure Service Versioning Guide\\n\\nThis document defines what an Azure service is, the rules that govern the service’s versioning, and all the benefits that flow from this.  \\r\\nThe end of this document describes the problems that arise from Azure services that do not follow the service versioning rules and why they must now adopt these rules to greatly improve the Azure customer experience as well as the Azure engineering experience.  \\r\\nFor questions related to Azure Service Versioning, contact azversioning@service.microsoft.com\\n\\n## What Is an Azure Service?\\n\\nAn Azure service is a set of operations that version uniformly (in perpetuity).  \\r\\n- A customer client app is expected to use only one version of a service at any given point in time.  \\r\\n- This means that any public or private preview service version must be a superset of that last GA service version (unless a preview version introduces a breaking change).  \\r\\n- Services can version \\u0026 be retired independently from each other. This allows services to be agile and removes coordination between sub-teams.  \\r\\n- Customers consciously select and target specific service versions.\\r\\n    - This is important for the public cloud customers as all datacenters may not have the same service versions deployed. \\r\\n    - It is also important for Azure Stack, government cloud, and other air-gapped/non-public cloud customers which also may not have the same service versions deployed.\\n\\n## An Azure Resource Provider and its 1+ Azure Services\\n\\nA single Azure Resource Provider (RP) has an RP namespace. This RP namespace can contain 1+ control-plane services and 0+ data-plane service; each service versions as described above. Today, we want the GitHub specs repo to be structured as follows for control-plane \\u0026 data-plane contracts:\\r\\n```\\r\\nspecification/\\r\\n└── \\u003corgName1\\u003e/\\r\\n    ├── cspell.yaml\\r\\n    └── resource-manager/\\r\\n        ├── readme.md\\t\\t\\tß NOTE: For ARM schema validation; see bullet #2 below\\r\\n        └── \\u003cRPNamespace\\u003e/\\t\\tß NOTE: Control-plane only (not data-plane) \\r\\n            └── \\u003cServiceName1\\u003e/\\tß Customer-facing service name; each version gets Documentation \\u0026 SDK package\\r\\n                ├── tspconfig.yaml\\tß TypeSpec files\\r\\n                ├── main.tsp\\r\\n                ├── models.tsp\\r\\n                ├── readme.md\\t\\tß autorest readme with YAML blocks\\r\\n                └── examples/\\t\\tß TypeSpec example folder\\r\\n                    └── \\u003capi-version\\u003e/\\tß One folder per service version described in TypeSpec\\r\\n                        └── \\u003cexample .json files\\u003e \\r\\n                └── preview/ and stable/\\r\\n                    └── \\u003capi-version\\u003e/\\tß One folder per service version described in OpenAPI. These folders are created and populated by compiling the TypeSpec folder for the service.\\r\\n                        ├── \\u003cOpenAPI .json files\\u003e\\r\\n                        └── examples/\\tß OpenAPI example folder\\r\\n                            └── \\u003cexample .json files\\u003e\\r\\n            └── \\u003cServiceName2\\u003e/\\t// Customer-facing service name; contents identical to above structure\\r\\n    └── data-plane/\\r\\n        └── \\u003cServiceName3\\u003e/\\t// Customer-facing service name; contents identical to above structure\\r\\n```\\r\\nIn this structure, Azure services are presented as an RPNamespace that is used to manage services (both with customer-facing names). Each service has versions (some preview and some GA) and each version has its own API contract, documentation, and (beta/stable) SDK package(s).\\n\\nIf 2+ services want to “share” some TypeSpec/OpenAPI files, these files must be explicitly copied into a consuming service’s folder on its desired timeline. We do not allow multiple services to reference a single copy of a service contract because it is too dangerous to allow one service to change a shared contract, forcing other services to pick up this shared contract instantly, especially if the shared contract introduces breaking changes. Each service must be in control of its own destiny.\\r\\n4.\\tThe ServiceName folder must have examples, preview and stable subfolders. Additional subfolders are allowed to help organize *.tsp files. The rules should ensure that only the tspconfig.yaml  and *.tsp files are in the ServiceName folder.  \\r\\n5.\\tThe examples folder should only have a subfolder for each api-version and each api-version folder can contain only example *.json files for this api-version.\\r\\n6.\\tThe preview and stable folders must only have subfolders whose name match this format: YYYY-MM-DD-preview in the preview folder and YYYY-MM-DD in the stable folder. All the files in the YYYY-MM-DD(-preview) folders must be json (OpenAPI) files.\\r\\n7.\\tEach YYYY-MM-DD(-preview) folder must have an examples folder containing only example *.json files for this api-version.\\r\\n8.\\tIt is illegal for a preview and GA version to share the same date. For example, if there is a 2024-04-01-preview, then there can never be a 2024-04-01 GA.\\r\\n9. Each new control plane api-version should be unique across all the control plane service folders for an RP Namespace. \\r\\n10.\\tEach service name folder must duplicate the special \\\"list operations\\\" API. \\r\\n    - While this RP (not service) operation requires an api-version query parameter, the response data is not specific to this api-version; the response is api-version neutral. In addition, the response is always the same regardless of tenant/subscription.\\n\\n\\u003cServiceName2\\u003e/\\t// Customer-facing service name; contents identical to above structure\\r\\n    └── data-plane/\\r\\n        └── \\u003cServiceName3\\u003e/\\t// Customer-facing service name; contents identical to above structure\\r\\n```\\r\\nIn this structure, Azure services are presented as an RPNamespace that is used to manage services (both with customer-facing names). Each service has versions (some preview and some GA) and each version has its own API contract, documentation, and (beta/stable) SDK package(s).   \\r\\n\\r\\nTo enforce these rules, here are some notes about the repo structure:\\r\\n\\r\\n1.\\tIn the resource-manager folder, if it's a RPaaS service, there must be just 1 readme.md file, and 1+ service name folders under resource-manager/RPnamespace folder, but the resource types within each service folder must not duplicate except for operations, locations, checkNameAvailability etc. Which is required by RPaaS for HTTP request schema validation.\\r\\n2.\\tIn the data-plane folder there must be no files and at least 1 service name folder.\\r\\n3.\\tThe ServiceName folder must have only readme.*, tspconfig.yaml and *.tsp files in it. \\r\\n    - In the readme.md file, the latest package tag value (which represents a service version) must refer to OpenAPI files that are all in the exact same folder. Also, if the tag value is suffixed with “-preview” then all the OpenAPI paths must refer to files in the preview subfolder; else all OpenAPI paths must refer to files in the stable subfolder.\\r\\n    - If 2+ services want to “share” some TypeSpec/OpenAPI files, these files must be explicitly copied into a consuming service’s folder on its desired timeline. We do not allow multiple services to reference a single copy of a service contract because it is too dangerous to allow one service to change a shared contract, forcing other services to pick up this shared contract instantly, especially if the shared contract introduces breaking changes. Each service must be in control of its own destiny.\\n\\nthere can never be a 2024-04-01 GA.\\r\\n9. Each new control plane api-version should be unique across all the control plane service folders for an RP Namespace. \\r\\n10.\\tEach service name folder must duplicate the special \\\"list operations\\\" API. \\r\\n    - While this RP (not service) operation requires an api-version query parameter, the response data is not specific to this api-version; the response is api-version neutral. In addition, the response is always the same regardless of tenant/subscription. Whenever any other service in the RP gets a new api-version, the TypeSpec/OpenAPI for the operations service must also be updated to match this new api-version.\\n\\n## Positive Consequences of the Azure Service Definition\\n\\nto increment its major number as per semantic versioning. This also causes old preview and GA service versions and their corresponding SDK package versions to be retired/deprecated.\\r\\n- The above service and SDK package versioning rules simplify the usage and ongoing maintenance of downstream consumers such as the Azure Portal, Azure CLI/PowerShell, Azure Developer CLI, ARM templates, Bicep, 3rd party libraries that wrap our Azure REST APIs and SDK packages (such as Terraform/Pulumi), etc.  \\r\\n\\r\\nThe following diagram summarizes how Azure internal teams and customers should think about Azure service abstractions and their relationship to each other. \\r\\n- The RP namespace identifies the Resource Provider that customers must use to manage some Azure resource(s). The namespace itself has no code and therefore never versions. \\r\\n- Within an RP namespace is 1+ control plane services and 0+ data-plane services which version uniformly over time. \\r\\n    - Private preview versions don’t have corresponding SDK package versions\\r\\n    - Public preview versions do have corresponding beta SDK package versions\\r\\n    - GA versions do have corresponding stable SDK package versions. Beta SDK package versions may also exist if the SDK package has rich functionality requiring customer testing/feedback before releasing the stable SDK package version.\\r\\n \\r\\n\\u003cimg width=\\\"600\\\" height=\\\"400\\\" alt=\\\"image\\\" src=\\\"https://github.com/user-attachments/assets/7b079665-2328-4524-8784-476e52e57343\\\" /\\u003e\\n\\nFrom the above definition, many processes and assets naturally flow, providing both Azure engineering teams and customers with great experiences:\\r\\n- Each service version is documented separately allowing a customer to reference the specific version of the service they are targeting.\\r\\n- \"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# design#specs-pr-guides#pr-brch-deep.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-brch-deep](https://aka.ms/azsdk/pr-brch-deep) |\\r\\n| --- | --- |\\n\\n# Deep-dive into breaking changes on spec PRs\\n\\n## Important information about this article\\n\\nThis article provides a deep-dive into breaking changes on spec PRs. It applies if your spec PR has\\r\\n`BreakingChangeReviewRequired` or `VersioningReviewRequired` label.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e This is an advanced deep-dive. If your PR is blocked on breaking changes or versioning issues, you should always\\r\\n\\u003e start by following the guidance at [aka.ms/brch].\\n\\n### Prerequisites\\n\\nThis article assumes you are familiar with [API versions and branches](xref:api-versions-and-branches).\\n\\n### Video overview and slides\\n\\nFor video overview of the breaking changes process, see this [Azure Core Day of Learning talk from March 6, 2024].\\r\\nSlides for the talk are available [here][talk slides].\\n\\n### Summary\\n\\nPer the [PR diagram], the first step of getting your specs PR approved is ensuring your PR obeys the  \\r\\n[Azure Versioning and Breaking Changes Policy]. Relevant details of this policy follow.\\r\\n\\r\\n- Once published, no changes to given API version are allowed, except when fixing the spec to match\\r\\nactual implementation (see the `-Approved-BugFix` labels in this doc).\\r\\nThis applies regardless of whether the API version is for `private preview`, `public preview`, or `GA`.\\r\\n- When introducing a new API version (any `preview` or `GA`), the new API version must be backwards compatible with\\r\\nthe previous, latest `GA` API version.\\r\\n- During a (`private` or `public`) `preview` cycle, a new `preview` API version does not have to be backwards\\r\\ncompatible with the previous `preview` API version.\\r\\n- The rules listed above are checked by automated GitHub checks. The exact ruleset is given in [`oadMessagesRuleMap.ts`].\\r\\nDetails follow.\\n\\n## Breaking changes and versioning issues\\n\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\\n\\n### `BreakingChangeReviewRequired` label\\n\\nThe label `BreakingChangeReviewRequired` is added to your PR if the tooling detects a change that could\\r\\nbe breaking for customers. This can happen in two cases:\\r\\n\\r\\n- In your PR you have possibly introduced a breaking change in a new API version, placed in a new folder,\\r\\nas compared to most recent previous `GA`.\\r\\nThe new API version can be either `preview` or `GA`.\\r\\n  - For example, an existing `GA` API version in leaf folder of `2023-11-15`\\r\\nmay contain API route of `GET .../resoruces/{resourceName}`, but a new `preview` API version of `2024-03-15-preview`\\r\\nmay no longer have this route (REST API path), because you are removing the `resoruces` typo and instead introducing\\r\\n`GET .../resources/{resourceName}` route.\\r\\n- In your PR you are modifying existing `GA` API version in-place. For example, you have recently released\\r\\n`2024-03-18` API version and realized you made a typo and are editing the contents of the leaf folder `2024-03-18`\\r\\ncontaining that API version.\\n\\n### `VersioningReviewRequired` label\\n\\nThe label `VersioningReviewRequired` denotes that your PR has a **versioning issue** possibly violating the  \\r\\n[Azure Versioning and Breaking Changes Policy]. This happens when you made a **non-breaking change**,\\r\\naka **compatible change** to an API version that was already published (merged to a production branch).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e According to [the policy][Azure Versioning and Breaking Changes Policy], compatible (non-breaking changes) are not\\r\\n\\u003e allowed within an existing API version. You must create a new API version. Otherwise, we would confuse our customers\\r\\n\\u003e by having to explain \\\"which version of given API version\\\" has a particular change/feature.\\r\\n\\r\\n`VersioningReviewRequired` label is added by automation if:\\r\\n\\r\\n- You made any compatible changes **within** any API version, `GA` or `preview`.\\r\\n- You made any breaking changes in a `preview` API version.\\r\\n\\r\\nIf your PR has both breaking changes and versioning issues, only `BreakingChangeReviewRequired` label\\r\\nis added to it.\\n\\n### In case there is no latest GA API version\\n\\nIf there is no latest GA OpenAPI spec, then the the cross-version check is instead comparing to\\r\\nlatest available preview if it more than 1 year old.\\r\\n\\r\\nIf neither a GA API version or at least 1 year old preview version exists, then the cross-version check automatically\\r\\npasses.\\n\\n### Diagram explaining breaking changes and versioning issues\\n\\nThe logic for automation adding `BreakingChangeReviewRequired` and `VersioningReviewRequired` labels explained above\\r\\ncan be summarized in the following diagram:\\r\\n\\r\\n![Breaking Changes Confusion Matrix](../../img/breaking_changes_confusion_matrix.png)\\n\\n## Addressing `BreakingChangeReviewRequired`\\n\\nIf your PR is labelled with `BreakingChangeReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the breaking changes in your PR are acceptable, they will be\\r\\napproved by one of these labels:\\n\\n### `BreakingChange-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `BreakingChange-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-UserImpact`\\n\\n- The spec PR describes actual breaking changes to the service.\\r\\n- This is the only case that triggers customer notifications, a 3 year migration period (possibly shorter), etc.\\r\\n- Within this set, the changes may be distinguished further for security or legal compliance, which may be granted\\r\\na shorter migration period.\\r\\n- Details at [aka.ms/brch].\\n\\n### `BreakingChange-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Addressing `VersioningReviewRequired`\\n\\nIf your PR is labelled with `VersioningReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the versioning issue in your PR caused by non-breaking (compatible)\\r\\nchanges is acceptable, the board will approve it by one of these labels:\\n\\n### `Versioning-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `Versioning-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-PrivatePreview`\\n\\nThe API version change that triggered the review is in `private preview`, and non-breaking changes are permitted\\r\\nin the same API version during `private preview`.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-PrivatePreview` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Common misconceptions\\n\\n### FALSE: compatible (non-breaking) changes are allowed in published API versions\\n\\n**Why?**\\r\\n\\r\\nAn API version is a contract, and once the contract is published it cannot be changed.\\r\\nOtherwise, it would create customer confusion about \\\"which version of this API version\\\" are they using.\\r\\n\\r\\nAny change of this kind w\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Specification-Folder-Structure-Guide.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Specification-Folder-Structure-Guide\",\"content\":\"# Specification-Folder-Structure-Guide.md\\n\\n| Short Link: | [aka.ms/azsdk/spec-dirs](https://aka.ms/azsdk/spec-dirs) |\\r\\n|--|--|\\r\\n\\u003c!-- \\r\\nTable of contents generated with VSCode Markdown All in One:\\r\\nhttps://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one \\r\\n--\\u003e\\r\\n- [`specification` directory structure](#specification-directory-structure)\\r\\n  - [Key concepts and terminology](#key-concepts-and-terminology)\\r\\n  - [Overview of the folder structure](#overview-of-the-folder-structure)\\r\\n    - [ARM services: `resource-manager/\\u003cRPNS\\u003e` folder](#arm-services-resource-managerrpns-folder)\\r\\n    - [Data-plane services: `data-plane` folders](#data-plane-services-data-planeservice-folders)\\r\\n  - [Service folder structure](#service-folder-structure)\\r\\n    - [Contents of a service folder](#contents-of-a-service-folder)\\r\\n    - [`\\u003capiVersion\\u003e` folders](#apiVersion-folders)\\r\\n  - [`specification/common-types`](#specificationcommon-types)\\r\\n  - [Naming guidelines for `specification` folder contents](#naming-guidelines-for-specification-folder-contents)\\r\\n  - [Legacy and deprecated patterns](#legacy-and-deprecated-patterns)\\r\\n  - [Current migration efforts](#current-migration-efforts)\\r\\n  - [Existing violations and historical context](#existing-violations-and-historical-context)\\n\\n# Azure REST API Specification Directory Structure\\n\\nThis article provides a comprehensive guide to the recommended directory structure and folder layout for Azure REST API specifications within the `specification` folder. The structure outlined here is designed to support both ARM (Azure Resource Manager) and data-plane services while maintaining compatibility with both TypeSpec-based and OpenAPI-based API development workflows.\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e The structure described in this article is the **recommended standard** for all new Azure services. While some existing services may follow legacy patterns for historical reasons, all new services must adopt this structure. We are actively working on migrating legacy patterns to align with these guidelines.\\n\\n## Key concepts and terminology\\n\\nTo better understand the directory structure, it's essential to familiarize yourself with these key concepts as defined in the [glossary]:\\r\\n- **Service**: A customer-facing Azure service (e.g., Azure Key Vault, Azure Container Registry)\\r\\n- **Organization**: The Azure team or group responsible for one or more services\\r\\n- **Resource Provider Namespace (RPNS)**: The ARM namespace for resource management operations (e.g., `Microsoft.KeyVault`)\\r\\n- **API Version**: All Azure services use the YYYY-MM-DD(-preview) format for consistent versioning.\\n\\n## Overview of the folder structure\\n\\nThe `specification` folder follows a hierarchical organization designed to accommodate both ARM and data-plane services. The structure ensures clear separation between different service types while maintaining consistency across all Azure service specifications.\\r\\n```\\r\\nspecification/\\r\\n└── \\u003corganization\\u003e/\\r\\n    ├── cspell.yaml                     # Spell-check configuration\\r\\n    ├── resource-manager/               # ARM services\\r\\n    │   └── \\u003cRPNS\\u003e/                    # Resource Provider Namespace\\r\\n    │       ├── \\u003cservice1\\u003e/             # Individual service\\r\\n    │       └── \\u003cservice2\\u003e/             # Individual service\\r\\n    └── data-plane/                    # Data-plane services\\r\\n        ├── \\u003cservice1\\u003e/                 # Individual service\\r\\n        └── \\u003cservice2\\u003e/                 # Individual service\\r\\n```\\r\\n**Organization structure:**\\r\\nEach organization folder contains up to two main directories:\\r\\n- **One `resource-manager/\\u003cRPNS\\u003e/` folder** for ARM services (where `\\u003cRPNS\\u003e` is the Resource Provider Namespace) containing **one or more** `\\u003cservice\\u003e` folders\\r\\n- **One `data-plane/` folder** for non-ARM APIs containing **one or more** `\\u003cservice\\u003e` folders\\r\\n**Important notes:**\\r\\n- Organizations may have only ARM services, only data-plane services, or both\\r\\n- The presence of both directories is not mandatory - it depends on the services offered by the organization\\n\\n### ARM services: `resource-manager/\\u003cRPNS\\u003e` folder\\n\\nThe `\\u003corganization\\u003e/resource-manager/\\u003cRPNS\\u003e` folder corresponds to an ARM **Resource Provider (RP) namespace**. This namespace defines the scope of resource management operations for the organization's ARM services.\\r\\n**Example structure:**\\r\\n- RPNS example: `Microsoft.Automation`\\r\\n- Full path: `specification/containerservice/resource-manager/Microsoft.ContainerService/aks`\\r\\n- Service: `aks` service within the `Microsoft.ContainerService` ARM Resource Provider namespace\\r\\nFor a complete list of Resource Providers, see the [Resource Provider list].\\r\\n\\u003e [!NOTE]\\r\\n\\u003e **Legacy pattern to avoid**: Many Azure teams with a single ARM service historically placed it directly in `specification/\\u003corganization\\u003e/resource-manager/` instead of following the proper `specification/\\u003corganization\\u003e/resource-manager/\\u003cRPNS\\u003e/\\u003cservice\\u003e` structure. This legacy pattern is deprecated and strongly discouraged for new services.\\n\\n### Data-plane services: `data-plane` folders\\n\\nThe `\\u003corganization\\u003e/data-plane` folder contains data-plane service APIs, which differ from ARM services in several key ways:\\r\\n**Key characteristics:**\\r\\n- Contains data-plane service APIs (not ARM service APIs)\\r\\n- No Resource Provider Namespace (`\\u003cRPNS\\u003e`) concept applies\\r\\n- Each service gets its own folder directly under `data-plane/`\\r\\n- Simpler structure: `\\u003corganization\\u003e/data-plane/\\u003cservice\\u003e`\\r\\nEach `\\u003corganization\\u003e/data-plane` folder contains one or more `\\u003cservice\\u003e` folders corresponding to the data-plane services owned by the organization.\\r\\n\\u003e [!NOTE]\\r\\n\\u003e **Legacy patterns to avoid**: Some organizations historically used additional grouping folders like `\\u003corganization\\u003e/data-plane/\\u003cgroupingDir\\u003e/\\u003cservice\\u003e` or prefixed service names with `Azure.\\u003cSomeService\\u003e` or `Microsoft.\\u003cSomeService\\u003e`. These legacy patterns are deprecated and strongly discouraged for new services.\\n\\n## Service folder structure\\n\\nEvery service folder follows a consistent structure regardless of whether it's an ARM or data-plane service. This consistency simplifies navigation and tooling across all Azure services.\\r\\n**Standard service folder paths:**\\r\\n- **ARM services**: `specification/\\u003corganization\\u003e/resource-manager/\\u003cRPNS\\u003e/\\u003cservice\\u003e`\\r\\n- **Data-plane services**: `specification/\\u003corganization\\u003e/data-plane/\\u003cservice\\u003e`\\n\\n### Contents of a service folder\\n\\nEach service folder contains a standardized set of files and directories organized by their purpose and the development approach used (TypeSpec vs. OpenAPI).\\r\\nA service folder contains the following elements:\\r\\n**TypeSpec files** (for TypeSpec-based services):\\r\\n- `main.tsp` - Main TypeSpec entry point for the service\\r\\n- `tspconfig.yaml` - TypeSpec compilation configuration with OpenAPI/SDK emitter options\\r\\n- Additional `*.tsp` files - Supporting TypeSpec files for the service\\r\\n- `examples/\\u003capiVersion\\u003e/` - TypeSpec examples organized by API version\\r\\n**README and configuration files**:\\r\\n- `readme.md` - Central file that groups APIs into different tags for tooling purposes\\r\\n- `readme.lang.md` - Language-specific README files for SDK generation (deprecated when TypeSpec is used)\\r\\n**Generated OpenAPI specifications**:\\r\\n- `stable/\\u003capiVersion\\u003e/` - Contains stable API version specifications\\r\\n- `preview/\\u003capiVersion\\u003e/` - Contains preview API version specifications\\r\\nThe `stable` and `preview` folders contain OpenAPI specifications in their respective [lifecycle stages][aka.ms/azsdk/api-versions], organized in `\\u003capiVersion\\u003e` subfolders for each service API version.\\n\\n### `\\u003capiVersion\\u003e` folders\\n\\nAPI version folders reflect the actual service API version, following Azure's standard `YYYY-MM-DD(-preview)` format for consistent versioning across all services.\\r\\n**Folder structure by service type:**\\r\\n**ARM services**:\\r\\n- `\\u003corganization\\u003e/resource-manager/\\u003cRPNS\\u003e/\\u003cservice\\u003e/stable/\\u003cYYYY-MM-DD\\u003e`\\r\\n- `\\u003corganization\\u003e/resource-manager/\\u003cRPNS\\u003e/\\u003cservice\\u003e/preview/\\u003cYYYY-MM-DD-preview\\u003e`\\r\\n**Data-plane services**:\\r\\n- `\\u003corganization\\u003e/data-plane/\\u003cservice\\u003e/stable/\\u003cYYYY-MM-DD\\u003e`\\r\\n- `\\u003corganization\\u003e/data-plane/\\u003cservice\\u003e/preview/\\u003cYYYY-MM-DD-preview\\u003e`\\r\\n**Contents of each API version folder:**\\r\\n- `.json` files containing OpenAPI specifications (typically emitted from TypeSpec)\\r\\n- `examples/` subfolder containing `.json` files with [`x-ms-examples`] content referenced from the OpenAPI specifications\\r\\n\\u003e [!NOTE]\\r\\n\\u003e **TypeSpec examples organization**: The `examples/` folder under the `\\u003cservice\\u003e` directory contains TypeSpec examples and serves as a superset of all API version examples. The TypeSpec team is actively working on new designs to reduce redundancy in example organization.\\r\\nFor detailed information about API versioning practices, see the [API versioning guidelines].\\n\\n## `specification/common-types`\\n\\nThe [`specification/common-types`] directory serves a special purpose in the repository structure, containing shared definitions that can be reused across all Azure service specifications.\\r\\n**Purpose and usage:**\\r\\n- Contains common models, types, and operations used across multiple Azure services\\r\\n- Enables consistency and reduces duplication across service specifications\\r\\n- Provides standardized definitions for common Azure patterns\\r\\n**Important limitations:**\\r\\nWhen you need to share definitions beyond those available in [`specification/common-types`], you must duplicate them in each service's own folder. This requirement ensures that each service maintains independent control over the versioning lifecycle of shared definitions.\\r\\n**Best practice for managing shared definitions:**\\r\\nTo minimize the maintenance burden of duplicate copies, service teams can implement a shared ownership pattern:\\r\\n1. **Designate an owner service** - The service that creates or updates the shared models becomes the owner.\\r\\n2. **Create a `sharable/` folder** - The owner service creates this folder to make definitions available for copying.\\r\\n3. **Use `copyFrom*Sharable\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"azure#apiVersionEvolution.md\",\"document_title\":\"Scenarios for API Evolution\",\"document_link\":\"\",\"content\":\"# azure#apiVersionEvolution.md\\n\\n# Scenarios for API Evolution\\n\\nThis document describe how to evolute api version for a management plane services.\\n\\n## Scenarios to Consider\\n\\nadd a new stable version\\r\\nadd a new preview version\\r\\nMaking a preview api stable\\r\\nReplacing a preview API with a new preview API\\r\\nReplacing a preview API with a stable API\\r\\nReplacing a preview API with a stable API and a new preview API\\r\\nAdding a preview API (previous stable API)\\r\\nConverting existing specs with mixes of preview and stable APIs\\r\\nNote that, in this new scenario, new services will always have only a single version in their specs until they have their first stable version.  This should drastically reduce the amount of decoration in preview APIs\\n\\n## Add a new stable version\\n\\n### TypeSpec Steps\\n\\n1. Check the Latest Version\\r\\n   1. Determine whether the latest version is a preview version or a stable (GA) version.\\r\\n2. If the Latest Version is Stable (GA):\\r\\n   1. Add a new entry for the new stable version at the bottom of the Versions enumeration\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Make changes to the API using versioning decorators to mark each change\\r\\n3. if the latest version is preview version: \\r\\n   1. Add a new stable (GA) version enum before the existing preview enum value.\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Update all items that are GA’ing:\\r\\n      1. Change their @added version value to match the new GA enum value.\\r\\n   4. Handle remaining preview-only features:\\r\\n      1. If some features are not GAed, create a new preview version and Decorate non-GA items with @added pointing to the new preview version.\\r\\n      2. If all features in the preview version are GAed, delete the existing preview version.\\n\\n## Replacing a Preview API with a new Preview API (Adding a Preview API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new preview api-version\\r\\n- rename the example folder to use the new version\\r\\n- Remove any api changes not in the new version (simply remove types or type change decorators that do not apply)\\r\\n- Change the API inline decorating any type changes or new types in the new versionSome tooling to pick which resources, types, and operations are part of the new API could be useful.\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a Stable API (Adding a stable API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new stable api-version. \\r\\n- Remove any @previewVersion decorator\\r\\n- rename the example folder to use the new stable api version\\r\\n- Remove any api changes not in the new stable API version. Some tooling to pick which resources, types, and operations are part of the new API could be useful.\\r\\n- Add any api changes in the new stable version, using versioning decorators unless it is the only api-version\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a new Stable and a Preview API (previous stable API exists)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the preview version in the \\\"versions\\\" enumeration to match the new preview version and all references\\r\\n- Add a new Stable version entry immediately before the renamed version entry\\r\\n- rename the example folder to use the new preview api version\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Relabel any api changes in the new stable API version, that is, any changes in the preview that are now considered stable. \\r\\n    - Some tooling to pick which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any api changes in the new stable version, using versioning decorators (automatically included in the new preview version)\\r\\n- Add any api changes still in preview in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with the first Stable API and a new Preview API (no previous stable api)\\n\\n### TypeSpec Steps\\n\\n- Replace the current versions enum member with the new stable api-version (first) and the new preview api-version (last)\\r\\n- Decorate the preview api-version with the @previewVersion decorator\\r\\n- Rename the example folder to use the new preview api version and update examples as needed\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Leave any resources, types and operations in the new stable version undecorated (automatically included in both the new stable and the new preview version)\\r\\n- Decorate any resources, types, and operations only in the new preview API version, that is, any types that are not considered stable. Some tooling to pick - which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any new preview api changes in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Adding a Preview API (Previous Stable API)\\n\\n### TypeSpec Steps\\n\\n- Add a new entry for the new preview version at the bottom of the Versions enumeration and decorate with @previewVersion\\r\\n- Add a new example folder for the new version and copy any still-relevant examples\\r\\n- Make changes to the API using versioning decorators to mark each change\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n## Converting Existing Specs With mixes of Preview and Stable APIs\\n\\n### TypeSpec Steps\\n\\n- For each preview api-version, in order\\r\\n  - For each versioning decorator, forward the version to the next version, except\\r\\n    - if this would result in a duplicated decorator application (including all decorator parameters) at that version, discard the forwarded decorator\\r\\n    - if this would result in an @added and @removed pair at a version, then discard the forwarded decorator\\r\\n    - If this would result in @typeChangedFrom or @renamedFrom with conflicting parameters, use the forwarded decorator\\r\\n  - Remove the preview api-version\\r\\n- For the first stable version\\r\\n  - Remove any @madeOptional, @added,  @typeChangedFrom, or @renamedFrom decorators\\r\\n  - Remove any types marked with the @removed decorator, unless they have @added decoration in subsequent versions\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n## Rules for api-version Changes\\n\\n@typeChangedFrom(b, string) myType: int32\\r\\nsafe: @madeOptional(a) @renamedFrom(b, \\\"oldName\\\") newName?: string -\\u003e @madeOptional(b) @renamedFrom(b, \\\"oldName\\\") newName: string\\r\\n  - This is also true for @typeChangedFrom decorators w.r.t @madeOptional and renamedFrom decorators, and @renamedFrom decorators w.r.t @madeOptional and @typeChangedFrom decorators:safe: @typeChangedFrom(a, string) @madeOptional(b) myType?: int32 -\\u003e @typeChangedFrom(b, string) @madeOptional(b) myType: int32\\r\\nsafe: @typeChangedFrom(a, string) @renamedFrom(b, \\\"oldName\\\") newName: int32 -\\u003e @typeChangedFrom(b, string) @renamedFrom(b, \\\"oldName\\\") newName: int32\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @madeOptional(b) newName?: string -\\u003e @renamedFrom(b, \\\"oldName\\\") @madeOptional(b) newName?: string\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @typeChangedFrom(b, string) newName?: int32-\\u003e @renamedFrom(b, \\\"oldName\\\") @typeChangedFrom(b, string)) newName?: int32\\r\\n  - It is safe for @typeChangedFrom, @renamedFrom, @madeOptional decorators in version a to be forwarded to version b if the type is removed in version bsafe: @renamedFrom(a, \\\"oldName\\\") @removed(b) newName: string -\\u003e @renamedFrom(b, \\\"oldName\\\") removed(b) newName: string\\r\\n  - if there is an@removed decorator in version a and an  @added decorator in version b, both decorators can be removedsafe: @removed(a) @added(b) myType: string-\\u003e myType: string\\r\\n  - if there is an@addeddecorator in version a and an  @removeddecorator in version b, safe: @added(a) @removed(b) myType: string-\\u003e \\r\\n  - There should never be a backward-looking decorator from version a forwarded to version b if version b has an @added decoratorThis is because such a versioning would already be inconsistent:  A type cannot be transformed before it exists\\n\\ndecorator on type T from a to b, provided there are no other versioning decorators on type T that use version b.\\r\\n    - safe:  @added(a) -\\u003e @added(b)\\r\\n    - possibly unsafe: @added(a)@removed(b) -\\u003e @added(b) @removed(b)\\r\\n  - It is safe to forward an @added decorator on type T from a to b and remove any backward-looking decorator on type T using version b:\\r\\n    - safe: @added(a) @added(b) -\\u003e @added(b)\\r\\n    - safe: @added(a) @madeOptional(b) myType?: int32 -\\u003e @added(b) myType?: int32\\r\\n    - safe: @added(a) @typeChangedFrom(b, string) myType: int32 -\\u003e @added(b) myType: int32\\r\\n    - safe: @added(a) @renamedFrom(b, \\\"oldName\\\") newName: string -\\u003e @added(b) newName: string\\r\\n  - It is safe to forward a @madeOpt\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"How to restrict importing typespec files in main based off of versions.\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# How to restrict importing typespec files in main based off of versions.\\n\\n## question\\n\\nHi Team,\\r\\nWe have 2 imports in our main.tsp to include other resource type tsp files, however we do not want to include one of the resourcetype to the new api version we want to introduce.  Is there a way to do conditional imports based off of version in main? \\r\\nThank you in advance!\\n\\n## answer\\n\\nno, you have to mark the models/types and everything that you want to remove with the @removed decorator using the versioning library \\r\\nif you are in preview version I think also the policy is to only have a single preview version in the spec repo at the timme now so you could also just delete it\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_05.md\",\"document_title\":\"PR in azure-rest-api-specs-pr/main branch isnt merged to RPSaasMaster\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_05.md\\n\\n# PR in azure-rest-api-specs-pr/main branch isnt merged to RPSaasMaster\\n\\n## question\\n\\nOur RP api-version exists in azure-rest-api-specs-pr/main, but not in RPSaasMaster. So before I raise PR for a new api version for RPSaasMaster, the change should be made on the latest api version. If yes, could you please help who can merge from main to RpSaasMaster?\\r\\n \\r\\nMain - 2024-09-30-preview is latest public preview  version\\r\\n[azure-rest-api-specs-pr/specification/codesigning/resource-manager/Microsoft.CodeSigning/preview at main · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/tree/main/specification/codesigning/resource-manager/Microsoft.CodeSigning/preview)\\r\\n \\r\\nRPSaasMaster is missing the 2024-09-30-preview - \\r\\nhttps://github.com/Azure/azure-rest-api-specs-pr/tree/RPSaaSMaster/specification/codesigning/resource-manager/Microsoft.CodeSigning/preview\\n\\n## answer\\n\\nSyncing changes between public/main and private/RPSaaSMaster (in both directions) is the responsiblity of the spec owner.\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-07-17.md\",\"document_title\":\"additional  \\\"readOnly\\\": true in ProvisioningState\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-07-17.md\\n\\n# additional  \\\"readOnly\\\": true in ProvisioningState\\n\\n## question\\n\\n```\\r\\n{\\r\\n  \\\"OperationProvisioningState\\\": {\\r\\n    \\\"type\\\": \\\"string\\\",\\r\\n    \\\"description\\\": \\\"Defines values for OperationProvisioningState.\\\",\\r\\n    \\\"enum\\\": [\\r\\n      \\\"Unknown\\\",\\r\\n      \\\"InProgress\\\",\\r\\n      \\\"Succeeded\\\",\\r\\n      \\\"Failed\\\",\\r\\n      \\\"Canceled\\\",\\r\\n      \\\"Pending\\\",\\r\\n      \\\"Disabled\\\"\\r\\n    ],\\r\\n    \\\"x-ms-enum\\\": {...\\r\\n    },\\r\\n    \\\"readOnly\\\": true\\r\\n  }\\r\\n```\\r\\n\\r\\nwhen compiled from the tsp, the compiled swagger file has additional property \\\"readOnly\\\": true in ProvisioningState\\n\\n## answer\\n\\n1. Modification at tspconfig.yaml:  Remove use-read-only-status-schema: true.\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"API-Spec-Review-FAQ.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ\",\"content\":\"ARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this. See documentation: [Update your branch with changes from main](https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish#update-your-branch-with-changes-from-main). |\\r\\n| I need to set up suppressions for LintDiff violations in my PR | See [Adding Scoped Suppressions](https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff) | \\r\\n| I have specific questions about the inner workings of ARM, testing changes to APIs, or rollout/release schedules | Talk to the ARM team: https://aka.ms/armofficehoursinfo |\\r\\n| I see an Avocado error `MULTIPLE_API_VERSION` | There is a coordinated effort to fix this. Reach out to the relevant parties. [This PR](https://github.com/Azure/avocado/pull/157) gives more context on why this was upgraded to an error. If relevant parties agree, the PR can be unblocked by adding the `Approved-Avocado` label to the PR. |\\r\\n| I merged a PR, when does the REST API documentation update on the Learn site? | Docs are published every week on Tuesdays | \\r\\n| If the specs in the standard branches of `RPSaaSMaster` and `RPSaaSDev` are out of sync, who is responsible for syncing them with main? | The spec owner is responsible for syncing their service’s spec files from `main` to `RPSaaSMaster/RPSaaSDev` to ensure consistency across branches. |\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/versioning\",\"content\":\"# Versioning\\n## Simple Scenarios\\nThese examples show how to add models, operations, properties, and parameters in specific versions using TypeSpec versioning decorators.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/versioning\",\"content\":\"# Versioning\\nVersioning lets you evolve your API without breaking existing clients. This guide covers the basics of declaring versions and adding new resources, operations, and properties in a clear, easy-to-follow way. For more advanced scenarios, see the [full versioning documentation](../howtos/ARM/versioning.md).\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/versioning\",\"content\":\"# Versioning\\nThis document explains how to manage versioning in TypeSpec projects, including how to add, remove, or modify resources, operations, and properties across API versions.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/versioning\",\"content\":\"# Versioning\\n## Adding a Property or Parameter\\nYou can also add new properties or parameters to models and operations in a specific version:\\r\\n\\r\\n**Add a property in v2:**\\r\\n\\r\\n```tsp\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n\\r\\n  @added(Versions.v2)\\r\\n  city?: string;\\r\\n}\\r\\n```\\r\\n\\r\\n**Add a parameter in v2:**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      name: string;\\r\\n\\r\\n      @added(Versions.v2)\\r\\n      department?: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#versioning#preview-version.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/versioning/preview-version\",\"content\":\"# How to define a preview version\\nSee [`@typespec/versioning` documentation](https://typespec.io/docs/libraries/versioning/guide) for the general versioning concept. This guide expands on how Azure Services should define Preview versions.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#getting-started-rest#06-versioning.mdx\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\",\"content\":\"# Versioning\\n## Introduction\\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#reproducibility.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/handbook/reproducibility\",\"content\":\"# Reproducibility\\n## Summary\\n1. Use `package-lock.json`\\r\\n2. Use [versioning library](../libraries/versioning/reference/index.mdx)\\r\\n3. Keep track of commit IDs\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#breaking-change-policy.mdx\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/handbook/breaking-change-policy\",\"content\":\"# Breaking Change Policy\\n## Versioning Scheme\\nThe TypeSpec Compiler and libraries follow a major, minor, patch versioning scheme according to the following policy:\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#reproducibility.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/handbook/reproducibility\",\"content\":\"# Reproducibility\\n## 3. Change to the TypeSpec spec\\nIf you don't directly control the spec, you might still want to make sure you remember which exact definition was used.\\r\\nUsing version control and pinning to a specific commit SHA will ensure that the spec will remain exactly as it was.\"},{\"document_source\":\"typespec_http_specs\",\"document_filename\":\"versioning#added#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/versioning/added/main.tsp\",\"content\":\"# Usages for Test for the `@added` decorator.\\n## Scenario: This operation should be generated with latest version's signature.\\n``` typespec\\r\\n@route(\\\"/v1\\\")\\r\\n@post\\r\\nop v1(@body body: ModelV1, @added(Versions.v2) @header headerV2: string): ModelV1;\\r\\n```\\r\\n\\r\\n## Scenario: This operation should only be generated with latest version.\\r\\n\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-1-branch.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-1-branch\",\"content\":\"# Create a new branch\\n## How to create a new release branch\\n### [Private repo](#tab/private-repo)\\nIn the private repo you can use `main`, `RPSaaSMaster` or `RPSaaSDev` as the base branch.\\r\\n\\r\\n```\\r\\ngit branch \\u003cbranch-name\\u003e \\u003cbase-branch\\u003e\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-versioning.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-versioning\",\"content\":\"# Azure REST API versioning\\n## API versions in the specs repos\\nYou can learn more about how the specs API versions are laid out in [the specs repos](xref:api-repos) by reading\\r\\nthe [spec directory structure] article as well as reading upon [the lifecycle stages of API versions](xref:api-versions-and-branches).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial\",\"content\":\"# Tutorial: Create a new service spec\\n## Next steps\\n1. [Create a new branch](xref:api-tutorial-branch)\\r\\n2. [Work against the release branch](xref:api-tutorial-update)\\r\\n3. [Create a PR against main](xref:api-tutorial-publish)\"}]",
            "inputs.latency": 618.2805244922638,
            "inputs.response_length": 2241,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Specification-Folder-Structure-Guide",
                "https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches"
            ],
            "inputs.testcase": "Creating a Management Plane RP and referencing Data Plane model",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1501,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1502,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Creating a Management Plane RP and referencing Data Plane model\\\\n\\\\nquestion: Hello API Spec Review, I'm currently working on creating a new management plane RPAAS RP in the private spec repo based off of the `RPSaaSMaster` branch, the service spec requires a reference to Compute RP model `VMProfileProperties` however the `specification\\\\\\\\compute` folder for Compute is only available in the main branch of the private repo, so I wanted to ask:\\\\nIs it possible to create a RPAAS RP based on the main branch in the private repo?\\\\nCan a RPAAS RP reference a model in a data plane RP?\\\\nIs there a way to reference the compute model from the RPSaaSMaster branch?\\\\nThanks!\\\", \\\"response\\\": \\\"Let's address your questions based strictly on Azure API specification, repo, and TypeSpec guidelines:\\\\n\\\\n1) **Is it possible to create a RPAAS RP based on the main branch in the private repo?**\\\\n\\\\nNo, you should not create a new RPaaS RP spec directly based on the `main` branch in the private spec repo. The private spec repo `main` branch is a **read-only mirror of the public main branch** and is not intended for direct development or onboarding of new RPaaS RPs. RPaaS specs in private preview must use the `RPSaaSMaster` branch (see knowledge references below). You should create your new spec branch off `RPSaaSMaster`, not private/main.\\\\n\\\\n2) **Can a RPAAS RP reference a model in a data plane RP?**\\\\n\\\\nNo, this is not allowed by Azure spec repo rules. Each service (control plane or data plane) must own and version its own models independently. If you need to use a model like `VMProfileProperties` from another RP (even if it is Compute), you must **duplicate** the model in your own service folder. This is to avoid shared contracts that can break downstream consumers if the original is changed. You cannot reference a model from another RP folder (see Azure Service Versioning Guide and Spec Folder Structure Guide). If common types are needed, they must be copied into your RP's folder.\\\\n\\\\n3) **Is there a way to reference the Compute model from the RPSaaSMaster branch?**\\\\n\\\\nNo, you cannot directly reference or import the model from the Compute RP's folder, whether it's in main or RPSaaSMaster. The correct process is to copy the model definition (`VMProfileProperties`) into your own RP folder and maintain it independently. If Compute updates the model in the future, you must manually copy any desired changes. This rule ensures service independence and prevents breaking changes due to shared contracts.\\\\n\\\\n**Summary of actions:**\\\\n- Create your RPaaS RP spec branch from `RPSaaSMaster`.\\\\n- Copy the required Compute model (`VMProfileProperties`) into your RP's folder (do not reference or import from Compute RP directly).\\\\n- Maintain and version the model as part of your RP spec.\\\\n\\\\nIf you need further clarification on the repo branching or TypeSpec referencing rules, please refer to the references below or ask follow-up questions.\\\", \\\"ground_truth\\\": \\\"resource-manager specs should not share anything with data-plane specs.  Our latest guidelines go even further, preventing any sharing across different specs:\\\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: IntegerTypeMustHaveFormat errors\n\nquestion: I've got multiple [IntegerTypeMustHaveFormat errors](https://github.com/Azure/azure-rest-api-specs/actions/runs/18047835415) in existing swagger files in my [PR](https://github.com/Azure/azure-rest-api-specs/pull/37469). These swagger files all represent stable versions of Azure Maps REST API that have been available to customers for some time, I'm just moving the files to different directories, so changes could potentially have customer impact. If there is no format defined, what does it default to? I would imagine `int32` given an int in C# is int32 (int64 is a long)... Does this even apply to REST API? If the default value is int32 for example, would it be appropriate to define them all as `\"format\": \"int32\"`,? or would it be better to suppress these errors?",
            "inputs.ground_truth": "if you are just moving swagger files, your best option is to leave them unchanged, and add suppressions to readme.md:\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff#adding-scoped-suppressions\nif you have many instances of the same error, you could use a global suppression for that error",
            "inputs.response": "Based on Azure API guidelines and the rules enforced by the Azure REST API specs repo, for resource-manager specs (like Azure Maps management APIs), every integer property in OpenAPI/Swagger must explicitly specify a \"format\" (e.g., \"int32\" or \"int64\"). This requirement exists because SDK generators (including C#) rely on the \"format\" field to map Swagger integer types to the correct language types (e.g., `int` in C# maps to `int32`, while `long` maps to `int64`).\n\nIf a Swagger integer property omits the \"format\", OpenAPI itself does NOT specify a default, and various tools/languages may treat it inconsistently. In Azure, for management plane APIs, you must not rely on defaults—you must be explicit.\n\nFor existing, stable, customer-facing specs, the recommended and correct action is to add `\"format\": \"int32\"` to every integer schema entry that represents a 32-bit integer. Only use `\"int64\"` for properties intended to hold large values. Suppression of this error (IntegerTypeMustHaveFormat) is NOT allowed for resource-manager specs—see below:\n\n> \"Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\"\n\nIf you suppress the error, you risk breaking SDK code generation and downstream client code, since the SDKs may treat the property as an ambiguous type, leading to bugs or binary incompatibility. Therefore, you must update the spec by explicitly setting the format for all integer types as appropriate. This change is safe, and is considered a non-breaking metadata correction—SDKs will map types correctly and no customer-facing API change occurs.\n\n**Summary:**\n- Always specify `\"format\": \"int32\"` (or `\"int64\"`) for all integer properties in resource-manager Swagger specs\n- Do NOT suppress IntegerTypeMustHaveFormat errors in resource-manager specs\n- This is required for SDK correctness and does not break customer API contracts\n\nIf you need further guidance, refer to the Azure REST API specs wiki and the TypeSpec migration docs.",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# design#specs-pr-guides#pr-suppressions.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-suppressions](https://aka.ms/azsdk/pr-suppressions) |\\r\\n|--|--|\\n\\n# Suppress validation failures on a PR\\n\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nOn your Azure REST API specs PR, some of the GitHub check failures (see the `Checks` tab on your PR) can be suppressed.\\r\\nThe suppression can be either just for the PR, or permanent.\\n\\n## To suppress given validation failure\\n\\n1. Determine which failing check you want to suppress: see its name in the `Checks` tab in your PR.\\r\\n1. Determine if you have one of the [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. Determine if you want to suppress the failure only for the PR, or permanently.\\r\\n1. Consult [the suppression cases table](#suppression-cases-table) for instructions corresponding to your case.\\r\\n1. If you want to apply temporary suppression:\\r\\n   1. Mention in a comment on your PR the PR assignee asking to apply the suppression. Provide justification.\\r\\n      See [valid suppression reasons](#valid-suppression-reasons).\\r\\n1. If you applied permanent suppression:\\r\\n   1. It will manifest by the PR getting a label `SuppressionReviewRequired`.\\r\\n   1. Verify the suppression works by the check changing from **failed** to **neutral**.\\r\\n   1. Wait until your suppression is reviewed. If it is approved, the approved will add the `Approved-Suppression` label.\\r\\n   1. Understand the suppression won't be approved if it is not one of the  \\r\\n      [valid suppression reasons](#valid-suppression-reasons) as explained in relevant section.\\n\\n## Suppression cases table\\n\\n|\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met | Not possible                              |                                                      | Not possible                                                    |\\r\\n\\r\\n[1] Applies only if the SDK generation check failed with a breaking change. For details of SDK breaking change suppression, see https://aka.ms/azsdk/sdk-suppression.\\r\\nGeneral SDK generation check failure suppressions are not supported. See [#6509].\\n\\n|\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger SemanticValidation         | See [aka.ms/ci-fix]                       | `Approved-SemanticValidation`                        | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger ModelValidation            | See [aka.ms/ci-fix]                       | `Approved-ModelValidation`                           | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger Breaking Change            | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Breaking Change(Cross-Version)     | Email [Breaking Change Board]             | `Approved-BreakingChange`                            | Not possible                                                    |\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              |\\n\\nTable legend:\\r\\n\\r\\n- `Check name`: Check to suppress.\\r\\n- `PR suppression`: instructions to obtain suppression for given check for given PR only.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n- `Label`: the label your PR will get if your suppression is approved.\\r\\n- `Permanent suppression`: instructions how to get permanent suppression.\\r\\n  First, [read the about process](#to-suppress-given-validation-failure).\\r\\n\\r\\n| Check name                         | PR suppression                            | Label                                                | Permanent suppression                                           |\\r\\n|------------------------------------|-------------------------------------------|------------------------------------------------------|-----------------------------------------------------------------|\\r\\n| TypeSpec Requirement               | Not possible                              |                                                      | [suppressions.yaml](#suppressionsyaml)                      |\\r\\n| TypeSpec Validation                | Not possible                              |                                                      | Not possible                                                    |\\r\\n| license/cla                        | Not possible                              |                                                      | Not possible                                                    |\\r\\n| Swagger Avocado                    | See [aka.ms/ci-fix]                       | `Approved-Avocado`                                   | Not possible                                                    |\\r\\n| Swagger PrettierCheck              | See [aka.ms/ci-fix]                       |                                                      | Not possible                                                    |\\r\\n| Swagger SpellCheck                 |\\n\\n|\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-net-track2       | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-go               | See [step 3 in the diagram] but note [1]. | `BreakingChange-Go-Sdk-Suppression-Approved`         | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-java             | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-js               | See [step 3 in the diagram] but note [1]. | `BreakingChange-JavaScript-Sdk-Suppression-Approved` | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met |\\n\\n## suppressions.yaml\\n\\nFile `suppressions.yaml` is used for all checks created in 2024 or later, like\\r\\n`TypeSpec Requirement` and `TypeSpec Validation`.\\r\\n\\r\\nFor simplicity, we recommend adding all suppressions to a single file at the root of your spec folder:\\r\\n\\r\\n```\\r\\nspecification/myservice/suppressions.yaml\\r\\n```\\r\\n\\r\\nAlternatively, you can use multiple files in separate folders.  Currently, tools will use the first\\r\\ninstance of `suppressions.yaml` found walking up the directory tree.  We are planning\\r\\nfuture support for \\\"merging\\\" files up the hierarchy.\\r\\n\\r\\nA suppression follows this general format:\\r\\n\\r\\n```\\r\\n- tool: ToolName\\r\\n  path: applies/to/**/*.json\\r\\n  reason: Why this can't be fixed\\r\\n```\\r\\n\\r\\n`path` uses \\\"glob\\\" matching.  For syntax, see https://www.npmjs.com/package/minimatch.\\r\\n\\r\\nScope your `path` as narrowly as possible.  For example, if a suppression only applies\\r\\nto a single version of your spec:\\r\\n\\r\\n```\\r\\n# good\\r\\n- path: data-plane/Azure.Contoso.WidgetManager/preview/2022-11-01-preview/**/*.json\\r\\n\\r\\n# bad\\r\\n- path: data-plane/**/*.json\\r\\n```\\r\\n\\r\\nWhen in doubt, search the repo for examples:\\r\\n\\r\\nhttps://github.com/search?q=repo%3AAzure%2Fazure-rest-api-specs+path%3A%2F%28%5E%7C%5C%2F%29suppressions%5C.yaml%24%2F\\u0026type=code\\n\\n### `TypeSpec Requirement` check\\n\\nTo suppress `TypeSpec Requirement` check for given pattern of OpenAPI spec .json file paths, provide an entry with\\r\\n`tool` set to `TypeSpecRequirement`. Provide the pattern as `path` and provide a `reason`.\\r\\n\\r\\nExample:\\r\\n\\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: data-plane/**/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## Suppress AutoRest extension\\n\\nTo suppress tooling that is an AutoRest extension (see [the suppressio\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#typespec-for-openapi-dev.md\",\"document_title\":\"TypeSpec for OpenAPI Developers\",\"document_link\":\"https://typespec.io/docs/getting-started/typespec-for-openapi-dev\",\"content\":\"# getting-started#typespec-for-openapi-dev.md\\n\\n# TypeSpec for OpenAPI Developers\\n\\nThis guide introduces TypeSpec using concepts familiar to developers who build or use API definitions in OpenAPI v2 or v3.\\r\\n\\r\\nIn many cases, this will also describe how the typespec-autorest and openapi3 emitters translate\\r\\nTypeSpec designs into OpenAPI.\\r\\n\\r\\nThe document is organized around the features of an OpenAPI v2 or v3 definition.\\r\\nThe idea is that if you know how to describe some API feature in OpenAPI, you can just navigate\\r\\nto the section of this document for that feature.\\n\\n## Data Types\\n\\nIn OpenAPI [v2](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#data-types)/[v3](https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#data-types), data types are specified using the `type` and `format` fields in a schema.\\r\\n\\r\\nThe TypeSpec equivalents of OpenAPI data types are the TypeSpec primitive types or [built-in models](https://typespec.io/docs/language-basics/built-in-types).\\n\\n### type and format\\n\\nThe following table shows how common OpenAPI types map to TypeSpec types:\\r\\n\\r\\n| `type:`   | `format:`   | TypeSpec type    | Notes                                                                     |\\r\\n| --------- | ----------- | ---------------- | ------------------------------------------------------------------------- |\\r\\n| `integer` | `int32`     | `int32`          |                                                                           |\\r\\n| `integer` | `int64`     | `int64`          |                                                                           |\\r\\n| `number`  | `float`     | `float32`        |                                                                           |\\r\\n| `number`  | `double`    | `float64`        |                                                                           |\\r\\n| `string`  |             | `string`         |                                                                           |\\r\\n| `string`  | `byte`      | `bytes`          | for content-type == 'application/json' or 'text/plain'                    |\\r\\n| `string`  | `binary`    | `bytes`          | for \\\"binary\\\" content types, e.g. 'application/octet-stream', 'image/jpeg' |\\r\\n| `string`  | `date`      | `plainDate`      |                                                                           |\\r\\n| `string`  | `date-time` | `utcDateTime`    | RFC 3339 date in coordinated universal time (UTC)                         |\\r\\n| `string`  | `date-time` | `offsetDateTime` | RFC 3339 date with offset                                                 |\\r\\n| `string`  | `password`  | `@secret string` |                                                                           |\\r\\n| `boolean` |             | `boolean`        |                                                                           |\\r\\n\\r\\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\\r\\n\\r\\n```typespec\\r\\nmodel Example {\\r\\n  /** This property has no `type` defined. */\\n\\n| RFC 3339 date with offset                                                 |\\r\\n| `string`  | `password`  | `@secret string` |                                                                           |\\r\\n| `boolean` |             | `boolean`        |                                                                           |\\r\\n\\r\\nYou can also define a property with no type specified using the TypeSpec `unknown` type.\\r\\n\\r\\n```typespec\\r\\nmodel Example {\\r\\n  /** This property has no `type` defined. */\\r\\n  noType?: unknown;\\r\\n}\\r\\n```\\r\\n\\r\\nOpenAPI allows any string as a format, and there is a [registry of common formats][Format Registry].\\r\\nTypeSpec supports some of these directly.\\r\\n\\r\\n[Format Registry]: https://spec.openapis.org/registry/format\\r\\n\\r\\n| `type:`   | `format:`    | TypeSpec type | Notes |\\r\\n| --------- | ------------ | ------------- | ----- |\\r\\n| `number`  | `decimal`    | `decimal`     |       |\\r\\n| `number`  | `double-int` | `safeint`     |       |\\r\\n| `integer` | `int8`       | `int8`        |       |\\r\\n| `integer` | `int16`      | `int16`       |       |\\r\\n| `integer` | `uint8`      | `uint8`       |       |\\r\\n| `string`  | `uri`        | `url`         |       |\\r\\n\\r\\nFor formats that are not supported directly, you can use the built-in `@format` decorator to specify\\r\\nthe format explicitly.\\n\\n### JSON Schema assertions\\n\\nOpenAPI supports a variety of \\\"assertions\\\" that can be used to further restrict the values allowed for a data type.\\r\\nThese are actually borrowed into OpenAPI from JSON Schema.\\r\\n\\r\\nFor `type: integer` and `type: number` data types:\\r\\n\\r\\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\\r\\n| --------------------------- | ---------------------------- | ----- |\\r\\n| `minimum: value`            | `@minValue(value)` decorator |       |\\r\\n| `maximum: value`            | `@maxValue(value)` decorator |       |\\r\\n\\r\\nFor `type: string` data types:\\r\\n\\r\\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\\r\\n| --------------------------- | ----------------------------- | ----- |\\r\\n| `minLength: value`          | `@minLength(value)` decorator |       |\\r\\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\\r\\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\\r\\n\\r\\nFor `type: array` data types:\\r\\n\\r\\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\\r\\n| --------------------------- | ---------------------------- | ----- |\\r\\n| `minItems: value`           | `@minItems(value)` decorator |       |\\r\\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\\n\\n### enum\\n\\nThere are two ways to define an `enum` data type in TypeSpec. One is with the [TypeSpec `enum` statement](https://typespec.io/docs/language-basics/enums), e.g.:\\r\\n\\r\\n\\u003c!-- To retain the quotes from the enum values --\\u003e\\r\\n\\u003c!-- prettier-ignore-start --\\u003e\\r\\n```typespec\\r\\nenum Color {\\r\\n  \\\"red\\\",\\r\\n  \\\"blue\\\",\\r\\n  \\\"green\\\",\\r\\n}\\r\\n```\\r\\n\\u003c!-- prettier-ignore-end --\\u003e\\r\\n\\r\\nAnother is to use the union operation to define the enum values inline, e.g.:\\r\\n\\r\\n```typespec\\r\\nmodel Example {\\r\\n  size?: \\\"small\\\" | \\\"medium\\\" | \\\"large\\\" | \\\"x-large\\\";\\r\\n}\\r\\n```\\n\\n### default\\n\\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\\r\\n\\r\\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\\r\\n\\r\\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\\r\\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\\r\\nin the route, this defines a new path that is the value from the `@route` decorator with the path parameter appended.\\r\\n\\r\\n```\\n\\nA model property that specifies a default value using \\\"=\\\" will produce a `default` field in the schema for this property.\\r\\n\\r\\n```typespec\\r\\nmodel Example {\\r\\n  answer?: int32 = 42;\\r\\n  color?: string = \\\"purple\\\";\\r\\n}\\r\\n```\\r\\n\\r\\nproduces\\r\\n\\r\\n```yaml title=openapi.yaml\\r\\nanswer:\\r\\n  type: integer\\r\\n  format: int32\\r\\n  default: 42\\r\\ncolor:\\r\\n  type: string\\r\\n  default: purple\\r\\n```\\r\\n\\r\\n## Host / BasePath / Servers\\r\\n\\r\\nIn OpenAPI v2, the `host` and `basePath` fields at the top-level of the API definition combine to form the base URL for the API. The paths defined in the `paths` object are appended to this base URL to form the absolute URL for an operation.\\r\\n\\r\\nIn OpenAPI v3, the top-level `servers` field specifies an array of `server` objects [[v3][v3-server]] with a base URL, which may be parameterized, to which the operation path is appended.\\r\\n\\r\\n[v3-server]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#server-object\\r\\n\\r\\nIn TypeSpec, the `host` in OpenAPI v2 or `servers` in OpenAPI v3 can be specified with the `@server` decorator\\r\\non the namespace (from `@typespec/http` library). You can use this decorator multiple times to specify multiple servers.\\r\\n\\r\\n## Paths Object\\r\\n\\r\\nIn OpenAPI, the `paths` object [[v2][v2-paths], [v3][v3-paths]] is the top-level structure for defining the operations of the API, organized by the \\\"path\\\" for the operation.\\r\\n\\r\\n[v2-paths]: https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md#paths-object\\r\\n[v3-paths]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#paths-object\\r\\n\\r\\nIn TypeSpec, you can specify the path for a namespace, interface, or operation using the `@route` decorator.\\r\\n\\r\\nWhen the value of the `@route` decorator contains path parameters, operations within the scope of the decorator\\r\\nmust declare parameters with the same name and type. If an operation declares a path parameter that is not present\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#openapi.md\",\"document_title\":\"OpenAPI v3 emitter\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/openapi\",\"content\":\"# emitters#openapi3#openapi.md\\n\\n# OpenAPI v3 emitter\\n\\nThe OpenAPI emitter translates TypeSpec language elements into their equivalent OpenAPI expressions. This guide explains how TypeSpec constructs are mapped to OpenAPI components.\\r\\n\\r\\n**Note**: The below documentation generally refers to the behavior of the OpenAPI v3 emitter when using OpenAPI version 3.0. Emitter output for version 3.1 may be slightly different according to additional features supported in 3.1 but not in 3.0.\\n\\n## Server Details\\n\\nWhen your TypeSpec file includes an [(HTTP) `@server` decorator](../../libraries/http/reference/decorators.md#@TypeSpec.Http.server), the OpenAPI emitter will generate a `servers` object in the resulting OpenAPI document. This object contains the server URL, description, and any variables defined in the decorator.\\r\\n\\r\\nYou can apply multiple `@server` decorators to create multiple entries in the `servers` array:\\r\\n\\r\\n```typespec\\r\\n@server(\\\"https://api.example.com/v1\\\", \\\"Primary production endpoint\\\")\\r\\n@server(\\\"https://api-dev.example.com/v1\\\", \\\"Development endpoint\\\")\\r\\nnamespace MyService;\\r\\n```\\n\\n## Operations\\n\\nEach TypeSpec operation is converted into an OpenAPI operation.\\n\\n### HTTP Method\\n\\nYou can explicitly specify the HTTP method using one of the [(HTTP) decorators][http-verb-decorators]:\\r\\n\\r\\n- `@get`\\r\\n- `@post`\\r\\n- `@put`\\r\\n- `@patch`\\r\\n- `@delete`\\r\\n\\r\\nIf you don't specify a method, the emitter will infer it from the operation name and signature.\\r\\n\\r\\n```typespec\\r\\n// Explicitly declared as GET /{id}\\r\\n@get\\r\\nop getUser(@path id: string): User;\\r\\n\\r\\n// Explicitly declared as POST /\\r\\n@post\\r\\nop createUser(user: User): User;\\r\\n\\r\\n// Automatically detected as GET /{id}\\r\\nop getUser(@path id: string): User;\\r\\n\\r\\n// Automatically detected as POST /\\r\\nop createUser(user: User): User;\\r\\n```\\n\\n### Operation Path\\n\\nThe path for an operation comes from the [(HTTP) `@route` decorator][http-route-decorator]. You can apply `@route` to:\\r\\n\\r\\n- Individual operations\\r\\n- Interfaces (groups of operations)\\r\\n- Namespaces\\r\\n\\r\\nWhen you apply routes to multiple levels, they're combined to form the complete path:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/api\\\")\\r\\nnamespace MyService {\\r\\n  @route(\\\"/users\\\")\\r\\n  interface Users {\\r\\n    // Results in GET /api/users/{id}\\r\\n    @route(\\\"/{id}\\\")\\r\\n    @get\\r\\n    getUser(@path id: string): User;\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n[http-verb-decorators]: ../../libraries/http/reference/decorators.md\\r\\n[http-route-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.route\\r\\n\\r\\nThe [OpenAPI Operation object][openapi-operation-object] fields are populated as described in the following sections.\\r\\n\\r\\n[openapi-operation-object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operationObject\\n\\n### Description\\n\\nThe operation's description comes from the documentation of the TypeSpec operation.\\r\\n\\r\\nDocumentation is provided either by a documentation comment or by the [(built-in) `@doc` decorator][doc-decorator] (the two are equivalent):\\r\\n\\r\\n```typespec\\r\\n/**\\r\\n * Retrieves a user by their unique identifier.\\r\\n */\\r\\nop getUser(@path id: string): User;\\r\\n\\r\\n@doc(\\\"Retrieves a user by their unique identifier.\\\")\\r\\nop getUser(@path id: string): User;\\r\\n```\\r\\n\\r\\nIf no documentation is provided, the description field is omitted.\\r\\n\\r\\n[doc-decorator]: ../../standard-library/built-in-decorators.md#@doc\\n\\n### Summary\\n\\nThe operation's summary comes from the [(built-in) `@summary` decorator][summary-decorator]:\\r\\n\\r\\n```typespec\\r\\n/**\\r\\n * Retrieves a user by their unique identifier.\\r\\n */\\r\\n@summary(\\\"Get a User by ID.\\\")\\r\\nop getUser(@path id: string): User;\\r\\n```\\r\\n\\r\\nIf no `@summary` is provided, the summary field is omitted.\\r\\n\\r\\n[summary-decorator]: ../../standard-library/built-in-decorators.md#@summary\\n\\n### Operation ID\\n\\nThe operation ID can be explicitly set using the [(OpenAPI) `@operationId` decorator][openapi-operation-decorator]:\\r\\n\\r\\n```typespec\\r\\n@operationId(\\\"getUserById\\\")\\r\\nop getUser(id: string): User;\\r\\n```\\r\\n\\r\\nIf not explicitly defined, the operation ID defaults to:\\r\\n\\r\\n- The operation name (when the operation is not in an interface)\\r\\n- The interface name followed by the operation name (when in an interface)\\r\\n\\r\\n[openapi-operation-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.operationId\\n\\n### Parameters and Request Body\\n\\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\\r\\n\\r\\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\\r\\n\\r\\n```typespec\\r\\n/**\\r\\n * Retrieves the User by their unique identifier.\\r\\n *\\r\\n * @param id The user's unique identifier.\\r\\n */\\r\\nop getUser(@path id: string): User;\\r\\n```\\r\\n\\r\\nThe content type for request bodies follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\\r\\n\\r\\nFor more advanced parameter configuration, see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\\n\\nTypeSpec operation parameters map to OpenAPI parameters and request body.\\r\\n\\r\\n#### Parameter Location\\r\\n\\r\\nYou specify where a parameter appears using these [(HTTP) decorators][http-parameter-decorators]:\\r\\n\\r\\n- `@query` - Query parameter in the URL\\r\\n- `@header` - HTTP header parameter\\r\\n- `@path` - Path parameter in the URL\\r\\n\\r\\nParameters without these decorators are assumed to be in the request body.\\r\\n\\r\\n```typespec\\r\\nop createUser(\\r\\n  // The parameter name is transformed to look like an HTTP header, so the parameter `contentType` maps\\r\\n  // to the `content-type` header\\r\\n  @header contentType: string,\\r\\n\\r\\n  @query include: string,\\r\\n  @path id: string,\\r\\n\\r\\n  // The request body will be a JSON object `{ \\\"user\\\": \\u003cUser\\u003e }`\\r\\n  user: User, // This goes in the request body\\r\\n): User;\\r\\n```\\r\\n\\r\\n#### Request Body\\r\\n\\r\\nYou can explicitly mark a parameter as the request body using the [(HTTP) `@body` decorator][http-body-decorator]:\\r\\n\\r\\n```typespec\\r\\n// The request body will be a JSON object that _only_ contains the User at the top level.\\r\\nop createUser(@body user: User): User;\\r\\n```\\r\\n\\r\\nIf `@body` is not used, all parameters not marked with `@header`, `@query`, or `@path` form the request body, which is marked as required. To make the request body optional, declare it with an optional property and the `@body` decorator:\\r\\n\\r\\n```typespec\\r\\nop updateUser(@path id: string, @body user?: User): User;\\r\\n```\\r\\n\\r\\n[http-parameter-decorators]: ../../libraries/http/reference/decorators.md\\r\\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\\r\\n\\r\\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\\r\\n\\r\\n```typespec\\r\\n/**\\r\\n * Retrieves the User by their unique identifier.\\r\\n *\\r\\n * @param id The user's unique identifier.\\r\\n */\\r\\nop getUser(@path id: string): User;\\r\\n```\\r\\n\\r\\nThe content type for request bodies follows the [default content-type resolution logic](../..\\n\\n### Responses\\n\\nstatus code is 200, the body will be just a JSON User at the top level.\\r\\n  @body user: User;\\r\\n}\\r\\n\\r\\nmodel NotFound {\\r\\n  @statusCode code: 404;\\r\\n\\r\\n  // If the status code is 404, the body will be a JSON object `{ \\\"message\\\": \\u003cstring\\u003e }`\\r\\n  message: string;\\r\\n}\\r\\n\\r\\nop getUser(@path id: string): UserResponse | NotFound;\\r\\n```\\r\\n\\r\\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\\r\\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\\r\\n\\r\\nThe content type for responses follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\\r\\n\\r\\nFor more advanced response configuration, see see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\\n\\nThe operation's return type(s) translate into OpenAPI responses.\\r\\n\\r\\n#### Status Codes\\r\\n\\r\\nYou can specify a status code using the [(HTTP) `@statusCode` decorator][http-statuscode-decorator] on a property in the return type:\\r\\n\\r\\n```typespec\\r\\nmodel UserResponse {\\r\\n  @statusCode\\r\\n  code: 200;\\r\\n\\r\\n  body: User;\\r\\n}\\r\\n\\r\\nop getUser(@path id: string): UserResponse;\\r\\n```\\r\\n\\r\\nYou can define multiple response types to handle different status codes:\\r\\n\\r\\n```typespec\\r\\nmodel UserResponse {\\r\\n  @statusCode\\r\\n  code: 200;\\r\\n\\r\\n  user: User;\\r\\n}\\r\\n\\r\\nmodel UserNotFoundResponse {\\r\\n  @statusCode\\r\\n  code: 404;\\r\\n\\r\\n  message: string;\\r\\n}\\r\\n\\r\\nop getUser(@path id: string): UserResponse | UserNotFoundResponse;\\r\\n```\\r\\n\\r\\n#### Error Responses\\r\\n\\r\\nUse the [(built-in) `@error` decorator][error-decorator] to indicate an error response, which becomes the \\\"default\\\" response in OpenAPI. To indicate that an operation returns a successful response or an error, simply use the error response type in a union with a non-error type:\\r\\n\\r\\n```typespec\\r\\n@error\\r\\nmodel ErrorResponse {\\r\\n  @statusCode\\r\\n  code: 404 | 500;\\r\\n\\r\\n  message: string;\\r\\n}\\r\\n\\r\\nop getUser(@path id: string): User | ErrorResponse;\\r\\n```\\r\\n\\r\\n#### Response Body\\r\\n\\r\\nThe response body can be explicitly marked with the `@body` decorator. Otherwise, any properties not marked with `@statusCode` or `@header` form the response body.\\r\\n\\r\\n```typespec\\r\\nmodel UserResponse {\\r\\n  @statusCode code: 200;\\r\\n\\r\\n  // If the status code is 200, the body will be just a JSON User at the top level.\\r\\n  @body user: User;\\r\\n}\\r\\n\\r\\nmodel NotFound {\\r\\n  @statusCode code: 404;\\r\\n\\r\\n  // If the status code is 404, the body will be a JSON object `{ \\\"message\\\": \\u003cstring\\u003e }`\\r\\n  message: string;\\r\\n}\\r\\n\\r\\nop getUser(@path id: string): UserResponse | NotFound;\\r\\n```\\r\\n\\r\\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\\r\\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\\n\\n### Tags\\n\\nUse the [(built-in) `@tag` decorator][tag-decorator] to apply tag groups to operations that will be represented in the generated OpenAPI and OpenAPI-based documentation tools such as Swagger UI:\\r\\n\\r\\n```typespec\\r\\n@tag(\\\"Us\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#diagnostics.md\",\"document_title\":\"Diagnostics\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/diagnostics\",\"content\":\"# emitters#openapi3#diagnostics.md\\n\\n# Diagnostics\\n\\nThe OpenAPI emitter may produce any of the following diagnostic messages.\\r\\n\\r\\n\\u003c!-- Topics within this section should be ordered alphabetically for easy lookup --\\u003e\\n\\n## duplicate-header\\n\\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\\r\\n\\r\\nTo fix this issue, ensure that each response header is defined only once for each status code.\\n\\n### Example\\n\\n```yaml\\r\\nresponses:\\r\\n  \\\"200\\\":\\r\\n    description: Successful response\\r\\n    headers:\\r\\n      X-Rate-Limit:\\r\\n        description: The number of allowed requests in the current period\\r\\n        schema:\\r\\n          type: integer\\r\\n      X-Rate-Limit:\\r\\n        description: The number of allowed requests in the current period\\r\\n        schema:\\r\\n          type: integer\\r\\n```\\r\\n\\r\\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\\n\\n## duplicate-type-name\\n\\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\\r\\n\\r\\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\\n\\n### Example\\n\\n```typespec\\r\\n@friendlyName(\\\"User\\\")\\r\\nmodel Customer {\\r\\n  id: string;\\r\\n}\\r\\n\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\r\\n\\r\\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\\n\\n## inline-cycle\\n\\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\\r\\n\\r\\nTo fix this issue, refactor the schemas to remove the cyclic reference.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    Node:\\r\\n      type: object\\r\\n      properties:\\r\\n        value:\\r\\n          type: string\\r\\n        next:\\r\\n          $ref: \\\"#/components/schemas/Node\\\"\\r\\n```\\r\\n\\r\\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\\n\\n## invalid-default\\n\\nThis diagnostic is issued when a default value is invalid for the specified schema type.\\r\\n\\r\\nTo fix this issue, ensure that the default value is valid for the schema type.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    User:\\r\\n      type: object\\r\\n      properties:\\r\\n        age:\\r\\n          type: integer\\r\\n          default: \\\"twenty\\\"\\r\\n```\\r\\n\\r\\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\\n\\n## invalid-extension-key\\n\\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \\\"x-\\\" as\\r\\nrequired by the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, change the extension name to start with \\\"x-\\\".\\n\\n### Example\\n\\n```typespec\\r\\n@extension(\\\"invalid-name\\\", \\\"value\\\")\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\r\\n\\r\\nShould be changed to:\\r\\n\\r\\n```typespec\\r\\n@extension(\\\"x-valid-name\\\", \\\"value\\\")\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\n\\n## invalid-schema\\n\\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    User:\\r\\n      type: object\\r\\n      properties:\\r\\n        id:\\r\\n          type: string\\r\\n        age:\\r\\n          type: integer\\r\\n          format: \\\"int\\\" # Invalid format\\r\\n```\\r\\n\\r\\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\\n\\n## invalid-server-variable\\n\\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\\r\\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\\r\\n\\r\\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\\n\\n### Example\\n\\n```typespec\\r\\n@server(\\\"{protocol}://{host}/api/{version}\\\", \\\"Custom endpoint\\\", {\\r\\n  protocol: \\\"http\\\" | \\\"https\\\",\\r\\n  host: string,\\r\\n  version: 1, // Should be a string: \\\"1\\\"\\r\\n})\\r\\n```\\n\\n## path-query\\n\\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\\r\\n\\r\\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\\n\\n### Example\\n\\nInstead of:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users?filter={filter}\\\")\\r\\nop getUsers(filter: string): User[];\\r\\n```\\r\\n\\r\\nUse:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users\\\")\\r\\nop getUsers(@query filter?: string): User[];\\r\\n```\\r\\n\\r\\nAlternatively, you can leverage TypeSpec's support for URI templates:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users{?filter}\\\")\\r\\nop getUsers(filter?: string): User[];\\r\\n```\\n\\n## union-null\\n\\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\\r\\nrepresented in OpenAPI.\\r\\n\\r\\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\\n\\n## union-unsupported\\n\\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\\r\\n\\r\\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#Guidelines.md\",\"document_title\":\"Microsoft Azure REST API Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md\",\"content\":\"# azure#Guidelines.md\\n\\n# Microsoft Azure REST API Guidelines\\n\\n\\u003c!-- cspell:ignore autorest, BYOS, etag, idempotency, maxpagesize, innererror, trippable, nextlink, condreq, etags --\\u003e\\r\\n\\u003c!-- markdownlint-disable MD033 MD049 MD055 --\\u003e\\r\\n\\r\\n\\u003c!--\\r\\nNote to contributors: All guidelines now have an anchor tag to allow cross-referencing from associated tooling.\\r\\nThe anchor tags within a section using a common prefix to ensure uniqueness with anchor tags in other sections.\\r\\nPlease ensure that you add an anchor tag to any new guidelines that you add and maintain the naming convention.\\r\\n--\\u003e\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2025-Mar-28 | Added guidelines about JSON ID and null values                 |\\r\\n| 2024-Mar-17 | Updated LRO guidelines                                         |\\r\\n| 2024-Jan-17 | Added guidelines on returning string offsets \\u0026 lengths         |\\r\\n| 2023-May-12 | Explain service response for missing/unsupported `api-version` |\\r\\n| 2023-Apr-21 | Update/clarify guidelines on POST method repeatability         |\\r\\n| 2023-Apr-07 | Update/clarify guidelines on polymorphism                      |\\r\\n| 2022-Sep-07 | Updated URL guidelines for DNS Done Right                      |\\r\\n| 2022-Jul-15 | Update guidance on long-running operations                     |\\r\\n| 2022-May-11 | Drop guidance on version discovery                             |\\r\\n| 2022-Mar-29 | Add guidelines about using durations                           |\\r\\n| 2022-Mar-25 | Update guideline for date values in headers to follow RFC 7231 |\\r\\n| 2022-Feb-01 | Updated error guidance                                         |\\r\\n| 2021-Sep-11 | Add long-running operations guidance                           |\\r\\n| 2021-Aug-06 | Updated Azure REST Guidelines per Azure API Stewardship Board. |\\r\\n| 2020-Jul-31 | Added service advice for initial versions                      |\\r\\n| 2020-Mar-31 | 1st public release of the Azure REST API Guidelines            |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Introduction\\n\\nThese guidelines apply to Azure service teams implementing _data plane_ APIs. They offer prescriptive guidance that Azure service teams MUST follow ensuring that customers have a great experience by designing APIs meeting these goals:\\r\\n- Developer friendly via consistent patterns \\u0026 web standards (HTTP, REST, JSON)\\r\\n- Efficient \\u0026 cost-effective\\r\\n- Work well with SDKs in many programming languages\\r\\n- Customers can create fault-tolerant apps by supporting retries/idempotency/optimistic concurrency\\r\\n- Sustainable \\u0026 versionable via clear API contracts with 2 requirements:\\r\\n  1. Customer workloads must never break due to a service change\\r\\n  2. Customers can adopt a version without requiring code changes\\r\\n\\r\\nTechnology and software is constantly changing and evolving, and as such, this is intended to be a living document. [Open an issue](https://github.com/microsoft/api-guidelines/issues/new/choose) to suggest a change or propose a new idea. Please read the [Considerations for Service Design](./ConsiderationsForServiceDesign.md) for an introduction to the topic of API design for Azure services. *For an existing GA'd service, don't change/break its existing API; instead, leverage these concepts for future APIs while prioritizing consistency within your existing service.*\\r\\n\\r\\n*Note: If you are creating a management plane (ARM) API, please refer to the [Azure Resource Manager Resource Provider Contract](https://github.com/cloud-and-ai-microsoft/resource-provider-contract).*\\n\\n### Prescriptive Guidance\\n\\nThis document offers prescriptive guidance labeled as follows:\\r\\n\\r\\n:white_check_mark: **DO** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n:ballot_box_with_check: **YOU SHOULD** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:heavy_check_mark: **YOU MAY** consider this pattern if appropriate to your situation. No notification to the Azure HTTP/REST Stewardship Board is required.\\r\\n\\r\\n:warning: **YOU SHOULD NOT** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:no_entry: **DO NOT** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n*If you feel you need an exception, or need clarity based on your situation, please contact the Azure HTTP/REST Stewardship Board **prior** to release of your API.*\\n\\n## Building Blocks: HTTP, REST, \\u0026 JSON\\n\\nThe Microsoft Azure Cloud platform exposes its APIs through the core building blocks of the Internet; namely HTTP, REST, and JSON. This section provides you with a general understanding of how these technologies should be applied when creating your service.\\r\\n\\r\\n\\u003ca href=\\\"#http\\\" name=\\\"http\\\"\\u003e\\u003c/a\\u003e\\n\\n### HTTP\\n\\ncase-sensitive, multiple delimiter\\r\\nUUID      | 123e4567-e89b-12d3-a456-426614174000 (no {}s, hyphens, case-insensitive) [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)\\r\\nDate/Time (Header) | Sun, 06 Nov 1994 08:49:37 GMT [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1)\\r\\nDate/Time (Query parameter) | YYYY-MM-DDTHH:mm:ss.sssZ (with at most 3 digits of fractional seconds) [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)\\r\\nByte array | Base-64 encoded, max length\\r\\nArray      | One of a) a comma-separated list of values (preferred), or b) separate `name=value` parameter instances for each value of the array\\r\\n\\r\\n\\r\\nThe table below lists the headers most used by Azure services:\\r\\n\\r\\nHeader Key          | Applies to | Example\\r\\n------------------- | ---------- | -------------\\r\\n_authorization_     | Request    | Bearer eyJ0...Xd6j (Support Azure Active Directory)\\r\\n_x-ms-useragent_    | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntraceparent         | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntracecontext        | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\naccept              | Request    | application/json\\r\\nIf-Match            | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-None-Match       | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-Modified-Since   | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\nIf-Unmodified-Since | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\ndate                | Both       | Sun, 06 Nov 1994 08:49:37 GMT (see [RFC 7231, Section 7.1.1.2](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2))\\r\\n_content-type_      | Both       | application/merge-patch+json\\n\\nname=\\\"http-header-names-casing\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** specify headers using kebab-casing\\r\\n\\r\\n\\u003ca href=\\\"#http-header-names-case-sensitivity\\\" name=\\\"http-header-names-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header names using case-insensitivity\\r\\n\\r\\n\\u003ca href=\\\"#http-header-values-case-sensitivity\\\" name=\\\"http-header-values-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header values using case-sensitivity if the header name requires it\\r\\n\\r\\n\\u003ca href=\\\"#http-header-date-values\\\" name=\\\"http-header-date-values\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** accept date values in headers in HTTP-Date format and return date values in headers in the IMF-fixdate format as defined in [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1), e.g. \\\"Sun, 06 Nov 1994 08:49:37 GMT\\\".\\r\\n\\r\\nNote: The RFC 7231 IMF-fixdate format is a \\\"fixed-length and single-zone subset\\\" of the RFC 1123 / RFC 5822 format, which means: a) year must be four digits, b) the seconds component of time is required, and c) the timezone must be GMT.\\r\\n\\r\\n\\u003ca href=\\\"#http-header-request-id\\\" name=\\\"http-header-request-id\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** create an opaque value that uniquely identifies the request and return this value in the `x-ms-request-id` response header.\\r\\n\\r\\nYour service should include the `x-ms-request-id` value in error logs so that users can submit support requests for specific failures using this value.\\r\\n\\r\\n\\u003ca href=\\\"#http-allow-unrecognized-headers\\\" name=\\\"http-allow-unrecognized-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** fail a request that contains an unrecognized header. Headers may be added by API gateways or middleware and this must be tolerated\\r\\n\\r\\n\\u003ca href=\\\"#http-no-x-custom-headers\\\" name=\\\"http-no-x-custom-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** use \\\"x-\\\" prefix for custom headers, unless the header already exists in production [[RFC 6648](https://datatracker.ietf.org/doc/html/rfc6648)].\\r\\n\\r\\n**Additional References**\\n\\nAzure services must adhere to the HTTP specification, [RFC 7231](https://tools.ietf.org/html/rfc7231). This section further refines and constrains how service implementors should apply the constructs defined in the HTTP specification. It is therefore, important that you have a firm understanding of the following concepts:\\r\\n\\r\\n- [Uniform Resource Locators (URLs)](#uniform-resource-locators-urls)\\r\\n- [HTTP Request / Response Pattern](#http-request--response-pattern)\\r\\n- [HTTP Query Parameters and Header Values](#http-query-parameters-and-header-values)\\r\\n\\r\\n#### Uniform Resource Locators (URLs)\\r\\n\\r\\nA Uniform Resource Locator (URL) is how developers access the resources of your service. Ultimately, URLs are how developers form a cognitive model of your service's resources.\\r\\n\\r\\n\\u003ca href=\\\"#http-url-pattern\\\" name=\\\"http-url-pattern\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** use this URL pattern:\\r\\n```text\\r\\nhttps://\\u003ctenant\\u003e.\\u003cregion\\u003e.\\u003cservice\\u003e.\\u003ccloud\\u003e/\\u003cservice-root\\u003e/\\u003cresource-collection\\u003e/\\u003cresou\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_12.md\",\"document_title\":\"Swagger LintDiff Suppression via TypeSpec\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_12.md\\n\\n# Swagger LintDiff Suppression via TypeSpec\\n\\n## question\\n\\nHello all, we are trying to get our spec migration wrapped up, but we are unable to figure out a suppression for `PatchBodyParametersSchema Properties of a PATCH request body must not be required, property:name.`\\r\\n \\r\\nLink to linter errors: [Migrate devcenter to TypeSpec · Azure/azure-rest-api-specs@82edee2](https://github.com/Azure/azure-rest-api-specs/actions/runs/17628981647)\\r\\n```\\r\\nRule\\tMessage\\tRelated RPC [For API reviewers]\\r\\n❌ PatchBodyParametersSchema\\tProperties of a PATCH request body must not be required, property:name. Location: Microsoft.DevCenter/preview/2025-07-01-preview/devcenter.json#L2943\\tRPC-Patch-V1-10\\r\\n❌ PatchBodyParametersSchema\\tProperties of a PATCH request body must not be required, property:name. Location: Microsoft.DevCenter/preview/2025-07-01-preview/devcenter.json#L8164\\tRPC-Patch-V1-10\\r\\n```\\r\\n \\r\\nThis is because a couple of our resource definitions reference the `Sku` definition from ARM common types\\r\\n \\r\\nThe TypeSpec: [Link](https://github.com/Azure/azure-rest-api-specs/blob/82edee201bde3d1de2633221016530141567dd28/specification/devcenter/DevCenter.Management/models.tsp#L1435)\\r\\n```\\r\\n@doc(\\\"Properties of a Dev Box definition. These properties can be updated after the resource has been created.\\\")\\r\\nmodel DevBoxDefinitionUpdateProperties {\\r\\n  @doc(\\\"Image reference information.\\\")\\r\\n  imageReference?: ImageReference;\\r\\n\\r\\n  @doc(\\\"The SKU for Dev Boxes created using this definition.\\\")\\r\\n  sku?: Azure.ResourceManager.CommonTypes.Sku;\\r\\n\\r\\n  @doc(\\\"The storage type used for the Operating System disk of Dev Boxes created using this definition.\\\")\\r\\n  osStorageType?: string;\\r\\n\\r\\n  @doc(\\\"Indicates whether Dev Boxes created with this definition are capable of hibernation. Not all images are capable of supporting hibernation. To find out more see https://aka.ms/devbox/hibernate\\\")\\r\\n  hibernateSupport?: HibernateSupport;\\r\\n}\\r\\n```\\n\\n\\\"string\\\",\\r\\n          \\\"description\\\": \\\"If the service has different generations of hardware, for the same SKU, then that can be captured here.\\\"\\r\\n        },\\r\\n        \\\"capacity\\\": {\\r\\n          \\\"type\\\": \\\"integer\\\",\\r\\n          \\\"format\\\": \\\"int32\\\",\\r\\n          \\\"description\\\": \\\"If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.\\\"\\r\\n        }\\r\\n      },\\r\\n      \\\"required\\\": [\\r\\n        \\\"name\\\"\\r\\n      ]\\r\\n    },\\r\\n```\\r\\n \\r\\nI am unable to figure out a suppression for this in the readme with a directives ([examples](https://github.com/Azure/azure-rest-api-specs/blob/82edee201bde3d1de2633221016530141567dd28/specification/devcenter/resource-manager/readme.md?plain=1#L43)\\r\\n```\\r\\n  - where:\\r\\n    - $.definitions.PoolUpdate.properties.devBoxDefinition.sku\\r\\n    suppress:\\r\\n      - PatchBodyParametersSchema\\r\\n```\\r\\n), and the ARM reviewer has told me that this should be accomplished via a suppression in the TypeSpec. I can't seem to find any examples of this and would really appreciate any help!\\n\\n\\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The storage type used for the Operating System disk of Dev Boxes created using this definition.\\\"\\r\\n        },\\r\\n        \\\"hibernateSupport\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/HibernateSupport\\\",\\r\\n          \\\"description\\\": \\\"Indicates whether Dev Boxes created with this definition are capable of hibernation. Not all images are capable of supporting hibernation. To find out more see https://aka.ms/devbox/hibernate\\\"\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n```\\r\\nThe actual definition of Sku and the required type that's causing the linter error: [Link](https://github.com/Azure/azure-rest-api-specs/blob/82edee201bde3d1de2633221016530141567dd28/specification/common-types/resource-management/v4/types.json#L470)\\r\\n```\\r\\n    \\\"Sku\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"The resource model definition representing SKU\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"name\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The name of the SKU. E.g. P3. It is typically a letter+number code\\\"\\r\\n        },\\r\\n        \\\"tier\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/SkuTier\\\"\\r\\n        },\\r\\n        \\\"size\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code. \\\"\\r\\n        },\\r\\n        \\\"family\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"If the service has different generations of hardware, for the same SKU, then that can be captured here.\\\"\\r\\n        },\\r\\n        \\\"capacity\\\": {\\r\\n          \\\"type\\\": \\\"integer\\\",\\r\\n          \\\"format\\\": \\\"int32\\\",\\r\\n          \\\"description\\\": \\\"If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.\\\"\\r\\n        }\\r\\n      },\\r\\n      \\\"required\\\": [\\r\\n        \\\"name\\\"\\r\\n      ]\\r\\n    },\\r\\n```\\n\\n@doc(\\\"The SKU for Dev Boxes created using this definition.\\\")\\r\\n  sku?: Azure.ResourceManager.CommonTypes.Sku;\\r\\n\\r\\n  @doc(\\\"The storage type used for the Operating System disk of Dev Boxes created using this definition.\\\")\\r\\n  osStorageType?: string;\\r\\n\\r\\n  @doc(\\\"Indicates whether Dev Boxes created with this definition are capable of hibernation. Not all images are capable of supporting hibernation. To find out more see https://aka.ms/devbox/hibernate\\\")\\r\\n  hibernateSupport?: HibernateSupport;\\r\\n}\\r\\n```\\r\\nThe generated swagger: [Link](https://github.com/Azure/azure-rest-api-specs/blob/82edee201bde3d1de2633221016530141567dd28/specification/devcenter/resource-manager/Microsoft.DevCenter/preview/2025-07-01-preview/devcenter.json#L9780)\\r\\n```\\r\\n    \\\"DevBoxDefinitionUpdateProperties\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"Properties of a Dev Box definition. These properties can be updated after the resource has been created.\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"imageReference\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/ImageReference\\\",\\r\\n          \\\"description\\\": \\\"Image reference information.\\\"\\r\\n        },\\r\\n        \\\"sku\\\": {\\r\\n          \\\"$ref\\\": \\\"../../../../../common-types/resource-management/v4/types.json#/definitions/Sku\\\",\\r\\n          \\\"description\\\": \\\"The SKU for Dev Boxes created using this definition.\\\"\\r\\n        },\\r\\n        \\\"osStorageType\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The storage type used for the Operating System disk of Dev Boxes created using this definition.\\\"\\r\\n        },\\r\\n        \\\"hibernateSupport\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/HibernateSupport\\\",\\r\\n          \\\"description\\\": \\\"Indicates whether Dev Boxes created with this definition are capable of hibernation. Not all images are capable of supporting hibernation. To find out more see https://aka.ms/devbox/hibernate\\\"\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n```\\n\\n## answer\\n\\nIf you just need to add a suppression for the swagger error in LintDiff, see here:\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff#adding-scoped-suppressions\\r\\n \\r\\nAlso left a comment here, with a correction to the instructions provided by your ARM reviewer.\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/pull/36201#discussion_r2342265620:\\r\\n```\\r\\nCurrently, LintDiff errors can only be suppressed in readme.md, not *.tsp files or suppressions.yaml or anywhere else.\\r\\n\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff#adding-scoped-suppressions\\r\\n\\r\\nTypeSpec Linter errors should be suppressed in the *.tsp themselves.\\r\\n\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Typespec Validation required check\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Typespec Validation required check\\n\\n## question\\n\\n\\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\". Please add \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-fakes\\\". Please add \\\"options.@azure-tools/typespec-go.generate-fakes\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.head-as-boolean\\\". Please add \\\"options.@azure-tools/typespec-go.head-as-boolean\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.inject-spans\\\". Please add \\\"options.@azure-tools/typespec-go.inject-spans\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-python.package-dir\\\". Please add \\\"options.@azure-tools/typespec-python.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-csharp.namespace \\\"Microsoft.Azure.Management.DevTestLabs\\\" does not match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter. Please update the value of \\\"options.@azure-tools/typespec-csharp.namespace\\\" to match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter.\\r\\nPlease see https://aka.ms/azsdk/spec-gen-sdk-config for more info.\\r\\nFor additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.\\r\\n```\\r\\nI have copied the namespace from the autorest readme files that we had before and it was responsible  to generate SDKs. Is it a requirement to update the namespace as suggested given we have already published the SDK before?\\n\\nPR: https://github.com/Azure/azure-rest-api-specs/pull/35346\\r\\nThis PR only has typespec conversion change and no API update. It is currently failing for required check - Typespec validation. When I run the npx tsmv command locally then I see the following error.\\r\\n```\\r\\nExecuting rule: SdkTspConfigValidation\\r\\nValidation on option \\\"options.@azure-tools/typespec-csharp.namespace\\\" in \\\"@azure-tools/typespec-csharp\\\" are failed. However, per @azure-tools/typespec-csharp’s decision, we will treat it as passed.\\r\\n[SdkTspConfigValidation]: validation failed.\\r\\n- Failed to find \\\"parameters.service-dir.default\\\". Please add \\\"parameters.service-dir.default\\\".\\r\\n- The value of options.@azure-tools/typespec-java.package-dir \\\"azure-mgmt-devtestlabs\\\" does not match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.package-dir\\\" to match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\".\\r\\n- The value of options.@azure-tools/typespec-java.namespace \\\"com.microsoft.azure.management.devtestlabs\\\" does not match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.namespace\\\" to match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.service-dir\\\". Please add \\\"options.@azure-tools/typespec-go.service-dir\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.package-dir\\\". Please add \\\"options.@azure-tools/typespec-go.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-go.module \\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\n\\n## answer\\n\\ntypeSpec validation is failing, but not for that reason.  The configuration for c-sharp emitter is a warning only.  The current failure is caused by diffs between the generated swagger included in your PR and the generated swagger when the ci compiles your spec.\\r\\n \\r\\nUsually this indicates that your local dependencies are out of date, and you need to pull the latest into your local branch and re-install at thetop level:\\r\\n \\r\\ngit fetch upstream main\\r\\ngit pull upstream main\\r\\nnpm ci\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Swagger breaking change\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Swagger breaking change\\n\\n## question\\n\\nPR check run: https://github.com/Azure/azure-rest-api-specs/pull/35346/checks?check_run_id=44501918225\\r\\nMy typespec conversion PR is failing in swagger breaking change check with the following error: \\r\\n\\\"new\\\":\\\"https://github.com/Azure/azure-rest-api-specs/blob/a1ac3f6f98bb1ea3583b765d00dfceab6d85654f/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json\\\",\\r\\n\\\"old\\\":\\\"https://github.com/Azure/azure-rest-api-specs/blob/main/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json\\\",\\r\\n\\\"details\\\":\\\"incompatible properties : tags\\\\n definitions/TrackedResource/properties/tags\\\\n at file:///mnt/vss/_work/1/azure-rest-api-specs/specification/common-types/resource-management/v3/types.json#L489:8\\\\n definitions/Resource/properties/tags\\\\n at file:///mnt/vss/_work/1/azure-rest-api-specs/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json#L12397:8\\\" \\r\\nThis PR is just having typespec conversion change and I am avoiding any change to the swagger file that is generated as part of typespec conversion. In the old swagger there is a Resource definitionwhich is similar Azure resource definition. Should I suppress this check and how to do it?\\n\\n## answer\\n\\nThis occurs because in your original swagger, you did not use swagger common-types. \\r\\nThe 'tags' definitions are compatible, so there is no change in the actual api from this.  This could result in changes in some management sdks, although this change to using the common resource types has generally been accepted. \\r\\ndocs on suppressions for false positives are here: [Suppress validation failures on a PR](https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions) \\r\\nNote that it is important to go through these violations, as the conversion is not guaranteed to be 100% accurate.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_31.md\",\"document_title\":\"TypeSpec Validation error\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_31.md\\n\\n# TypeSpec Validation error\\n\\n## question\\n\\nI have error: https://github.com/Azure/azure-rest-api-specs/actions/runs/16475997770/job/46577654359?pr=35887:\\r\\n```\\r\\nRule Compile failed\\r\\n  {\\\"not_added\\\":[],\\\"conflicted\\\":[],\\\"created\\\":[],\\\"deleted\\\":[],\\\"modified\\\":[\\\"specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\\"],\\\"renamed\\\":[],\\\"files\\\":[{\\\"path\\\":\\\"specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\\",\\\"index\\\":\\\" \\\",\\\"working_dir\\\":\\\"M\\\"}],\\\"staged\\\":[],\\\"ahead\\\":0,\\\"behind\\\":0,\\\"current\\\":\\\"HEAD\\\",\\\"tracking\\\":null,\\\"detached\\\":true}diff --git a/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json b/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\r\\n  index 58f42ef3f..cc93d3906 100644\\r\\n  --- a/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\r\\n  +++ b/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\r\\n  @@ -7079,8 +7079,7 @@\\r\\n             \\\"description\\\": \\\"Optional. Any input parameters that needs to passed to the script and are accessed within the script for its execution.\\\",\\r\\n             \\\"items\\\": {\\r\\n               \\\"$ref\\\": \\\"#/definitions/GalleryScriptParameter\\\"\\r\\n  -          },\\r\\n  -          \\\"x-ms-identifiers\\\": []\\r\\n  +          }\\r\\n           }\\r\\n         },\\r\\n         \\\"required\\\": [\\r\\n  \\r\\n  Files have been changed after `tsp compile`. Run `tsp compile` and ensure all files are included in your change.\\r\\n  Error: TypeSpec Validation failed for project specification/compute/Gallery.Management run the following command locally to validate.\\r\\n   \\u003e npm ci\\r\\n   \\u003e npx tsv specification/compute/Gallery.Management\\r\\n  For more detailed docs see https://aka.ms/azsdk/specs/typespec-validation\\r\\n```\\r\\n \\r\\nIs it because I have\\r\\n```\\r\\n  @@ -7079,8 +7079,7 @@\\r\\n             \\\"description\\\": \\\"Optional.\\n\\nFiles have been changed after `tsp compile`. Run `tsp compile` and ensure all files are included in your change.\\r\\n  Error: TypeSpec Validation failed for project specification/compute/Gallery.Management run the following command locally to validate.\\r\\n   \\u003e npm ci\\r\\n   \\u003e npx tsv specification/compute/Gallery.Management\\r\\n  For more detailed docs see https://aka.ms/azsdk/specs/typespec-validation\\r\\n```\\r\\n \\r\\nIs it because I have\\r\\n```\\r\\n  @@ -7079,8 +7079,7 @@\\r\\n             \\\"description\\\": \\\"Optional. Any input parameters that needs to passed to the script and are accessed within the script for its execution.\\\",\\r\\n             \\\"items\\\": {\\r\\n               \\\"$ref\\\": \\\"#/definitions/GalleryScriptParameter\\\"\\r\\n  -          },\\r\\n  -          \\\"x-ms-identifiers\\\": []\\r\\n  +          }\\r\\n           }\\r\\n         },\\r\\n         \\\"required\\\": [\\r\\n```\\r\\nwhere x-ms-identifier is empty? That is intended.\\n\\n## answer\\n\\nThe swagger generated by TypeSpec is constantly changing across TypeSpec versions.  Do you believe the new swagger is incorrect?\\r\\n \\r\\nAlso, keep in mind the version of TypeSpec may be different in main, the base and source branches of your PR, and locally.  Unless you think the new generated swagger is incorrect, you want to update forward.\\r\\nx-ms-identifier is no longer needed https://github.com/Azure/typespec-azure/issues/2868:\\r\\n```\\r\\nissue 2868:\\r\\ntitle: [Deprecation] x-ms-identifiers extension is no longer useful\\r\\ncontent: As title, and confirmed by @cweining, this swagger extension is completely useless for them who is from the original team that added this extension in swagger. Please remove it from typespec-autorest emitter\\r\\n```\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-08-07.md\",\"document_title\":\"Additional \\\"consumes\\\": [  \\\"text/plain\\\"  ], in operation\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-08-07.md\\n\\n# Additional \\\"consumes\\\": [  \\\"text/plain\\\"  ], in operation\\n\\n## question\\n\\n```\\r\\n\\\"consumes\\\": [\\r\\n    \\\"text/plain\\\"\\r\\n],\\r\\n```\\n\\n## answer\\n\\n```\\r\\n{\\r\\n    \\\"name\\\": \\\"body\\\",\\r\\n    \\\"in\\\": \\\"body\\\",\\r\\n    \\\"schema\\\": {\\r\\n        \\\"$ref\\\": \\\"#/definitions/email\\\"\\r\\n    }\\r\\n}\\r\\n```\\r\\nBecause TypeSpec wants to reproduce this part of the content from the original swagger, but once the parameter in body is a basic type (string, int32, scalar, etc.), it will cause this extra part to appear. The TypeSpec code is as follows\\r\\n```\\r\\n@action(\\\"listConnectedPartnerResources\\\")\\r\\nlist is ArmResourceActionSync\\u003c\\r\\n    NewRelicMonitorResource,\\r\\n    {\\r\\n        /**\\r\\n         * Email Id of the user\\r\\n         */\\r\\n        @bodyRoot\\r\\n        body?: email;\\r\\n    },\\r\\n    ArmResponse\\u003cConnectedPartnerResourcesListResponse\\u003e\\r\\n\\u003e;\\r\\n}\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#reference#emitter.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/reference/emitter\",\"content\":\"# Emitter usage\\n## Emitter options\\n### `safeint-strategy`\\n**Type:** `\\\"double-int\\\" | \\\"int64\\\"`\\r\\n\\r\\nHow to handle safeint type. Options are:\\r\\n\\r\\n- `double-int`: Will produce `type: integer, format: double-int`\\r\\n- `int64`: Will produce `type: integer, format: int64`\\r\\n\\r\\nDefault: `int64`\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#cli.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/cli\",\"content\":\"# OpenAPI3 to TypeSpec\\n## Examples\\n### 1. Convert component schemas into models\\nAll schemas present at `#/components/schemas` will be converted into a model or scalar as appropriate.\\r\\n\\r\\n\\u003ctable\\u003e\\r\\n\\u003ctr\\u003e\\r\\n\\u003ctd\\u003eOpenAPI3\\u003c/td\\u003e\\r\\n\\u003ctd\\u003eTypeSpec\\u003c/td\\u003e\\r\\n\\u003c/tr\\u003e\\r\\n\\u003c!-- ---------------------------------------------------  SCENARIO 1.1  ----------------------------------------------------------- --\\u003e\\r\\n\\u003ctr\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```yml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    Widget:\\r\\n      type: object\\r\\n      required:\\r\\n        - id\\r\\n        - weight\\r\\n        - color\\r\\n      properties:\\r\\n        id:\\r\\n          type: string\\r\\n        weight:\\r\\n          type: integer\\r\\n          format: int32\\r\\n        color:\\r\\n          type: string\\r\\n          enum:\\r\\n            - red\\r\\n            - blue\\r\\n    uuid:\\r\\n      type: string\\r\\n      format: uuid\\r\\n```\\r\\n\\r\\n\\u003c/td\\u003e\\r\\n\\u003ctd\\u003e\\r\\n\\r\\n```tsp\\r\\nmodel Widget {\\r\\n  id: string;\\r\\n  weight: int32;\\r\\n  color: \\\"red\\\" | \\\"blue\\\";\\r\\n}\\r\\n\\r\\n@format(\\\"uuid\\\")\\r\\nscalar uuid extends string;\\r\\n```\\r\\n\\r\\n\\u003c/td\\u003e\\r\\n\\u003c/tr\\u003e\\r\\n\\u003c/table\\u003e\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"libraries#azure-core#rules#prevent-format.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/prevent-format\",\"content\":\"# prevent-format\\n```text title=\\\"Full name\\\"\\r\\n@azure-tools/typespec-azure-core/prevent-format\\r\\n```\\r\\n\\r\\nUsing the `@format` decorator is disallowed. While in OpenAPI `format:` was used to both represent a known string format and a more precise type, in TypeSpec `@format` is only meant to represent a known pattern for a string. This means that using `@format` would result in a `string` type with some validation.\\r\\n\\r\\n## Mapping of format to types\\r\\n\\r\\n| Format   | Type                               |\\r\\n| -------- | ---------------------------------- |\\r\\n| `int32`  | `int32`                            |\\r\\n| `uri`    | `url`                              |\\r\\n| `url`    | `url`                              |\\r\\n| `uuid`   | `Azure.Core.uuid`                  |\\r\\n| `eTag`   | `Azure.Core.eTag`                  |\\r\\n| `arm-id` | `Azure.Core.armResourceIdentifier` |\\r\\n| `ipv4`   | `Azure.Core.ipV4Address`           |\\r\\n| `ipv6`   | `Azure.Core.ipV6Address`           |\\r\\n| `ipv6`   | `Azure.Core.azureLocation`         |\\r\\n\\r\\n## Examples\\r\\n\\r\\n#### ❌ Incorrect\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#pipeline.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline\",\"content\":\"# Resolving Pipeline Failures\\n## Swagger BreakingChange\\n### Multiple OpenAPI Files Before Migration\\nThis pipeline will fail if there is more than one OpenAPI file in the latest version. See the detailed explanation in this [issue](https://github.com/Azure/typespec-azure/issues/2194#issue-2844564216).\\r\\n\\r\\nTo properly identify real breaking changes, use the \\\"TypeSpec Migration Validation\\\" pipeline instead:\\r\\n\\r\\n1. Navigate to the TypeSpec Migration Validation pipeline\\r\\n2. Check the report on the \\\"Summary\\\" page\\r\\n3. The output should match exactly what you see in [this step](../01-get-started.md#review-and-adjust-the-typespec) on the local machine\\r\\n4. Review the changes to verify they are expected\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"language-basics#built-in-types.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/language-basics/built-in-types\",\"content\":\"# Built-in types\\n## Numeric types\\n### Numeric supertypes\\n`numeric`, `integer`, `float` and `decimal` are types that represent any possible number in their category. For some emit targets, `BigInt` or `BigDecimal` might be an analogous type satisfying the TypeSpec types `integer` and `decimal` respectively. For other targets where the language, serialization format, or protocol does not support an analogous type, emitters may decide on a policy for emitting the numeric supertypes. This might involve picking the closest analogous type and reporting a warning when they are encountered.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# TypeSpec\\n## `IntegerTypeMustHaveFormat`\\nData-plane specs can suppress violations of this rule, since it only exists for the benefit of SDKs generated from swagger, and data-plane SDKs are generated directly from TypeSpec.  Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\n## MULTIPLE_API_VERSION\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# TypeSpec\\nCheck `Swagger LintDiff` may fail for the OpenAPI generated from TypeSpec, even if there are no warnings or errors reported from the TypeSpec compiler.  Causes include bugs in the TypeSpec OpenAPI emitter, bugs in LintDiff rules, incompatibilities between TypeSpec and LintDiff, or checks duplicated in TypeSpec and LintDiff.\\r\\nWe are working to address the root causes (where possible).  Until then, we recommend you [suppress](https://aka.ms/pr-suppressions) these LintDiff errors, using a \\\"permanent suppression\\\" with a descriptive \\\"reason\\\".\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-tooling.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-tooling\",\"content\":\"# Use tools to create and validate Azure REST APIs specs\\n## [Author With TypeSpec](#tab/author-with-typespec)\\nAuthor specs with TypeSpec (**recommended approach**)\\r\\n\\r\\nREST APIs authored in [TypeSpec](xref:api-typespec) with the [Azure TypeSpec libraries] have validation built in.\\r\\nCompiling the TypeSpec definition will validate the REST API against the Azure API guidelines.\\r\\nThe TypeSpec compiler will also generate an [OpenAPI](xref:api-openapi) definition for the REST API.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e TypeSpec has [plugins for Visual Studio and Visual Studio Code][TypeSpec plugins] that will highlight errors and\\r\\nwarnings in your TypeSpec definition.\\r\\n\\r\\nTypeSpec is the recommended way for generating OpenAPI specs.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec\",\"content\":\"# What is TypeSpec?\\n## Case Studies\\n### Azure AI Content Safety\\n[Case Study](https://microsoft.sharepoint.com/:w:/t/AzureDeveloperExperience/EdlE2PYtZ9BKoXQ-R0h-O10B9RidePBT4mwB1JgIqRC01A?e=JRneI2)\\r\\n\\r\\n\\u003e \\\"I find TypeSpec to be much simpler to learn and write compared to Swagger. In my experience, Swagger often encounters many conflicts due to its JSON format. TypeSpec proves to be a much better alternative as it allows everyone to work independently on their own sections, making it more user-friendly. Furthermore, TypeSpec allows for the separate definition of models and routes. So, from my perspective, it's a superior choice at present.\\\"\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec\",\"content\":\"# What is TypeSpec?\\n## Case Studies\\n### Azure Batch\\n[Case Study](https://microsoft.sharepoint.com/:w:/t/AzureDeveloperExperience/EUkgwSc69lpPsBjQBfLfMEgB0WCTBe9x7ozU8VNK2s8mAw?e=1MIXZi)\\r\\n\\r\\n\\u003e \\\"There's definitions in Swagger, but … TypeSpec has much more flexibility when it comes to doing things like mix or not mixing in traits and defining core things that you export.\\\"\\r\\n\\u003e \\\"I want to highlight the tooling improvements, like not having to figure out how to install things locally [like Swagger tooling], having it all in the same tool set that includes the emitters and things like that is really nice. The VS code integration right out of the box is something I've really liked.\\\"\"}]",
            "inputs.latency": 678.3534119129181,
            "inputs.response_length": 2064,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff",
                "https://typespec.io/docs/getting-started/typespec-for-openapi-dev",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff",
                "https://typespec.io/docs/getting-started/typespec-for-openapi-dev"
            ],
            "inputs.testcase": "IntegerTypeMustHaveFormat errors",
            "outputs.similarity.similarity": 3.0,
            "outputs.similarity.gpt_similarity": 3.0,
            "outputs.similarity.similarity_result": "fail",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1517,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1518,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: IntegerTypeMustHaveFormat errors\\\\n\\\\nquestion: I've got multiple [IntegerTypeMustHaveFormat errors](https://github.com/Azure/azure-rest-api-specs/actions/runs/18047835415) in existing swagger files in my [PR](https://github.com/Azure/azure-rest-api-specs/pull/37469). These swagger files all represent stable versions of Azure Maps REST API that have been available to customers for some time, I'm just moving the files to different directories, so changes could potentially have customer impact. If there is no format defined, what does it default to? I would imagine `int32` given an int in C# is int32 (int64 is a long)... Does this even apply to REST API? If the default value is int32 for example, would it be appropriate to define them all as `\\\\\\\"format\\\\\\\": \\\\\\\"int32\\\\\\\"`,? or would it be better to suppress these errors?\\\", \\\"response\\\": \\\"Based on Azure API guidelines and the rules enforced by the Azure REST API specs repo, for resource-manager specs (like Azure Maps management APIs), every integer property in OpenAPI/Swagger must explicitly specify a \\\\\\\"format\\\\\\\" (e.g., \\\\\\\"int32\\\\\\\" or \\\\\\\"int64\\\\\\\"). This requirement exists because SDK generators (including C#) rely on the \\\\\\\"format\\\\\\\" field to map Swagger integer types to the correct language types (e.g., `int` in C# maps to `int32`, while `long` maps to `int64`).\\\\n\\\\nIf a Swagger integer property omits the \\\\\\\"format\\\\\\\", OpenAPI itself does NOT specify a default, and various tools/languages may treat it inconsistently. In Azure, for management plane APIs, you must not rely on defaults\\\\u2014you must be explicit.\\\\n\\\\nFor existing, stable, customer-facing specs, the recommended and correct action is to add `\\\\\\\"format\\\\\\\": \\\\\\\"int32\\\\\\\"` to every integer schema entry that represents a 32-bit integer. Only use `\\\\\\\"int64\\\\\\\"` for properties intended to hold large values. Suppression of this error (IntegerTypeMustHaveFormat) is NOT allowed for resource-manager specs\\\\u2014see below:\\\\n\\\\n> \\\\\\\"Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\\\\\\\"\\\\n\\\\nIf you suppress the error, you risk breaking SDK code generation and downstream client code, since the SDKs may treat the property as an ambiguous type, leading to bugs or binary incompatibility. Therefore, you must update the spec by explicitly setting the format for all integer types as appropriate. This change is safe, and is considered a non-breaking metadata correction\\\\u2014SDKs will map types correctly and no customer-facing API change occurs.\\\\n\\\\n**Summary:**\\\\n- Always specify `\\\\\\\"format\\\\\\\": \\\\\\\"int32\\\\\\\"` (or `\\\\\\\"int64\\\\\\\"`) for all integer properties in resource-manager Swagger specs\\\\n- Do NOT suppress IntegerTypeMustHaveFormat errors in resource-manager specs\\\\n- This is required for SDK correctness and does not break customer API contracts\\\\n\\\\nIf you need further guidance, refer to the Azure REST API specs wiki and the TypeSpec migration docs.\\\", \\\"ground_truth\\\": \\\"if you are just moving swagger files, your best option is to leave them unchanged, and add suppressions to readme.md:\\\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff#adding-scoped-suppressions\\\\nif you have many instances of the same error, you could use a global suppression for that error\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"
        },
        {
            "inputs.query": "title: Trying to understand API spec validation errors\n\nquestion: Hello all,\nI just published a new PR for adding a new API version for our service. I followed the same procedure we have followed over last couple of years, but I am seeing validation errors which are pretty hard to decipher with my limited knowledge regarding them.\nPR: https://github.com/Azure/azure-rest-api-specs/pull/38843\nCan someone please take a look and help me narrow down the issues?\nThe best I can see is that this file is missing?\n```\nCause: ResolverError: Error reading file \"/home/runner/work/azure-rest-api-specs/azure-rest-api-specs/after/specification/storagecache/common-types/resource-management/v3/types.json\"\n```",
            "inputs.ground_truth": "It looks like you have incorrect relative paths to common-types.\nIn your previous spec:\n```\n\"$ref\": \"../../../../../../common-types/resource-management/v3/types.json#/parameters/ApiVersionParameter\"\n```\n(6 segments bfore common-types)\nin this PR:\n```\n\"$ref\": \"../../../../../common-types/resource-management/v3/types.json#/parameters/ApiVersionParameter\"\n```\n(5 segments before common-types)",
            "inputs.response": "The validation error you're seeing (`ResolverError: Error reading file .../specification/storagecache/common-types/resource-management/v3/types.json`) indicates that the CI pipeline cannot find the referenced `types.json` file for ARM common types in your OpenAPI spec. This is a common issue during TypeSpec conversion and OpenAPI generation when the path to the shared common-types Swagger is incorrect or missing.\n\n**Root Cause:**\nYour generated OpenAPI is referencing a file (`common-types/resource-management/v3/types.json`) that does not exist in the expected location. This typically happens when:\n- The `arm-types-dir` option in your `tspconfig.yaml` is incorrectly set, or\n- The relative `$ref` paths in the generated OpenAPI do not match the repo's folder structure after migration.\n\n**How to Fix:**\n1. **Update your tspconfig.yaml**: Make sure the `arm-types-dir` is set correctly to point to the shared common-types location in the repo. For example:\n\n```yaml\noptions:\n  \"@azure-tools/typespec-autorest\":\n    arm-types-dir: \"{project-root}/../../../../common-types/resource-management\"\n```\nThis will ensure that references to ARM common types resolve to the correct file location.\n\n2. **Check your OpenAPI $ref paths**: In the generated OpenAPI files, verify that all `$ref` paths to common-types point to the correct relative location, such as:\n```json\n\"$ref\": \"../../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\"\n```\nIf they are incorrect, re-run `tsp compile` after fixing `tspconfig.yaml`.\n\n3. **Validate locally**: After updating, run the following locally to ensure all references resolve:\n```bash\nnpm ci\nnpx tsp compile .\n```\n\n4. **Re-add generated files to PR**: Commit and push the corrected generated OpenAPI files. The validation error should be resolved.\n\n**Summary:**\nThis error is a folder path misconfiguration for ARM common-types. Fix your `tspconfig.yaml` and regenerate your OpenAPI files to resolve the CI validation issue.\n\nIf you need a reference, you can look at how other RPs configure their `tspconfig.yaml` for ARM common-types, such as in the Widget service example:\n```yaml\n    arm-types-dir: \"{project-root}/../../../../common-types/resource-management\"\n```\n\nFor more guidance, see the official documentation and migration guides linked below.",
            "inputs.context": "[{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"emitters#typespec-autorest#reference#emitter.md\",\"document_title\":\"Emitter usage\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/emitters/typespec-autorest/reference/emitter\",\"content\":\"# emitters#typespec-autorest#reference#emitter.md\\n\\n# Emitter usage\\n\\n## Emitter usage\\n\\n1. Via the command line\\r\\n```bash\\r\\ntsp compile . --emit=@azure-tools/typespec-autorest\\r\\n```\\r\\n2. Via the config\\r\\n```yaml\\r\\nemit:\\r\\n  - \\\"@azure-tools/typespec-autorest\\\"\\r\\n```\\r\\nThe config can be extended with options as follows:\\r\\n```yaml\\r\\nemit:\\r\\n  - \\\"@azure-tools/typespec-autorest\\\"\\r\\noptions:\\r\\n  \\\"@azure-tools/typespec-autorest\\\":\\r\\n    option: value\\r\\n```\\n\\n## Emitter options\\n\\n### `emitter-output-dir`\\n\\n**Type:** `absolutePath`\\r\\nDefines the emitter output directory. Defaults to `{output-dir}/@azure-tools/typespec-autorest`\\r\\nSee [Configuring output directory for more info](https://typespec.io/docs/handbook/configuration/configuration/#configuring-output-directory)\\n\\n### `output-dir`\\n\\n**Type:** `string`\\r\\nDeprecated DO NOT USE. Use built-in emitter-output-dir instead\\n\\n### `output-file`\\n\\n**Type:** `string`\\r\\nName of the output file.\\r\\nOutput file will interpolate the following values:\\r\\n- service-name: Name of the service if multiple\\r\\n- version: Version of the service if multiple\\r\\n- azure-resource-provider-folder: Value of the azure-resource-provider-folder option\\r\\n- version-status: Only enabled if azure-resource-provider-folder is set. `preview` if version contains preview, stable otherwise.\\r\\nDefault: `{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/openapi.json`\\r\\nExample: Single service no versioning\\r\\n- `openapi.yaml`\\r\\nExample: Multiple services no versioning\\r\\n- `openapi.Org1.Service1.yaml`\\r\\n- `openapi.Org1.Service2.yaml`\\r\\nExample: Single service with versioning\\r\\n- `openapi.v1.yaml`\\r\\n- `openapi.v2.yaml`\\r\\nExample: Multiple service with versioning\\r\\n- `openapi.Org1.Service1.v1.yaml`\\r\\n- `openapi.Org1.Service1.v2.yaml`\\r\\n- `openapi.Org1.Service2.v1.0.yaml`\\r\\n- `openapi.Org1.Service2.v1.1.yaml`\\r\\nExample: azureResourceProviderFolder is provided\\r\\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\\r\\n- `arm-folder/AzureService/preview/2020-01-01.yaml`\\n\\n### `examples-dir`\\n\\n**Type:** `string`\\r\\nDirectory where the examples are located. Default: `{project-root}/examples`.\\n\\n### `examples-directory`\\n\\n**Type:** `string`\\r\\nDEPRECATED. Use examples-dir instead\\n\\n### `version`\\n\\n**Type:** `string`\\n\\n### `azure-resource-provider-folder`\\n\\n**Type:** `string`\\n\\n### `arm-types-dir`\\n\\n**Type:** `string`\\r\\nPath to the common-types.json file folder. Default: '${project-root}/../../common-types/resource-management'\\n\\n### `new-line`\\n\\n**Type:** `\\\"crlf\\\" | \\\"lf\\\"`\\r\\nSet the newline character for emitting files.\\n\\n### `omit-unreachable-types`\\n\\n**Type:** `boolean`\\r\\nOmit unreachable types. By default all types declared under the service namespace will be included. With this flag on only types references in an operation will be emitted.\\n\\n### `version-enum-strategy`\\n\\n**Type:** `string`\\r\\nDecide how to deal with the Version enum when when `omit-unreachable-types` is not set. Default to 'omit'\\n\\n### `include-x-typespec-name`\\n\\n**Type:** `\\\"inline-only\\\" | \\\"never\\\"`\\r\\nIf the generated openapi types should have the `x-typespec-name` extension set with the name of the TypeSpec type that created it.\\r\\nThis extension is meant for debugging and should not be depended on.\\n\\n### `use-read-only-status-schema`\\n\\n**Type:** `boolean`\\r\\nCreate read-only property schema for lro status\\n\\n### `emit-lro-options`\\n\\n**Type:** `\\\"none\\\" | \\\"final-state-only\\\" | \\\"all\\\"`\\r\\nDetermine whether and how to emit x-ms-long-running-operation-options for lro resolution\\n\\n### `emit-common-types-schema`\\n\\n**Type:** `\\\"never\\\" | \\\"for-visibility-changes\\\"`\\r\\nDetermine whether and how to emit schemas for common-types rather than referencing them\\n\\n### `xml-strategy`\\n\\n**Type:** `\\\"xml-service\\\" | \\\"none\\\"`\\r\\nStrategy for applying XML serialization metadata to schemas.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-tooling.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-tooling\",\"content\":\"# design#api-specs#api-tooling.md\\n\\n| Short Link: | [aka.ms/azsdk/specprtools](https://aka.ms/azsdk/specprtools) |\\r\\n|--|--|\\n\\n# Use tools to create and validate Azure REST APIs specs\\n\\n## [Author With TypeSpec](#tab/author-with-typespec)\\n\\nAuthor specs with TypeSpec (**recommended approach**)\\r\\n\\r\\nREST APIs authored in [TypeSpec](xref:api-typespec) with the [Azure TypeSpec libraries] have validation built in.\\r\\nCompiling the TypeSpec definition will validate the REST API against the Azure API guidelines.\\r\\nThe TypeSpec compiler will also generate an [OpenAPI](xref:api-openapi) definition for the REST API.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e TypeSpec has [plugins for Visual Studio and Visual Studio Code][TypeSpec plugins] that will highlight errors and\\r\\nwarnings in your TypeSpec definition.\\r\\n\\r\\nTypeSpec is the recommended way for generating OpenAPI specs.\\n\\n## [Author with OpenAPI](#tab/author-with-openapi)\\n\\nAuthor specs with OpenAPI (**legacy approach**)\\r\\n\\r\\nFor REST APIs that cannot be written in TypeSpec and still must be written directly in the OpenAPI format, you can:\\r\\n\\r\\n- Use [OpenAPI Initiative Swagger editor] for basic authoring.\\r\\n- Learn about the [spec directory structure].\\r\\n- Use the [Spectral linter] and the [Azure Spectral ruleset] to validate your OpenAPI definition against the Azure API\\r\\n  guidelines.\\r\\n  - Spectral provides a [VSCode plugin][Spectral VSCode plugin] that will highlight errors and warnings in your\\r\\n    OpenAPI definition in VSCode.\\r\\n\\r\\nYour OpenAPI definitions, to be published, will have to end up in the specs repos as explained in  \\r\\n[this article](xref:api-specs). As such, they will be subject to additional mandatory validation requirements.\\r\\nSee [validate your REST API](#validate-your-rest-api-specs) section to learn about them.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\",\"document_title\":\"Resolving Folder Migration Conflicts: A Guide for PR Authors\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors\",\"content\":\"# Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\\n\\n# Resolving Folder Migration Conflicts: A Guide for PR Authors\\n\\n## Overview\\n\\nWhen folder structure migration PRs (like [#36764](https://github.com/Azure/azure-rest-api-specs/pull/36764)) are merged, they may conflict with ongoing PRs that modify files within the refactored folders. This guide helps PR authors resolve these conflicts more efficiently.\\r\\n\\r\\n\\u003e **Important Note**: If you create a new PR **after** a folder migration is already merged into main, you should not encounter merge conflicts but need to work based on the new folder structure.\\n\\n## Understanding Folder Migration\\n\\nHere's the brief summary of the file changes of folder structure migration PR. we will take the Container Apps as an example.\\n\\n### Folder Structure Change\\n\\n**Before Migration Structure**:\\r\\n```\\r\\nspecification/app/\\r\\n├── Microsoft.App.DynamicSessions/\\r\\n│   ├── *.tsp\\r\\n│   ├── examples/*/*.json\\r\\n│   └── tspconfig.yaml\\r\\n├── resource-manager/\\r\\n|   ├── readme.md\\r\\n|   └── Microsoft.App/\\r\\n|       ├── preview/*/*.json\\r\\n|       └── stable/*/*.json\\r\\n└── data-plane/\\r\\n    ├── readme.md\\r\\n    └── Microsoft.App.DynamicSessions/\\r\\n        └── preview/*/*.json\\r\\n```\\r\\n\\r\\n**After Migration Structure**:\\r\\n```\\r\\nspecification/app/\\r\\n├── resource-manager/Microsoft.App/ContainerApps/\\r\\n│   ├── preview/*/*.json\\r\\n│   ├── stable/*/*.json\\r\\n│   └── readme.md\\r\\n└── data-plane/DynamicSessions/\\r\\n    ├── examples/*/*.json\\r\\n    ├── preview/*/*.json\\r\\n    ├── *.tsp\\r\\n    ├── tspconfig.yaml\\r\\n    └── readme.md\\r\\n```\\r\\n\\r\\n**Key Changes Made**:\\r\\n- TypeSpec files moved with their respective services\\r\\n- Each service now has its own isolated directory structure\\r\\n\\r\\nFor example:\\r\\n- Create a new serviceName folder ContainerApps: Moved from `resource-manager/Microsoft.App/` to `resource-manager/Microsoft.App/ContainerApps/`\\r\\n- The resource-manager readme.md updated paths from `resource-manager/` to `resource-manager/Microsoft.App/ContainerApps`\\r\\n- DynamicSessions TypeSpec: Moved from `Microsoft.App.DynamicSessions/` to `data-plane/DynamicSessions/`\\r\\n- DynamicSessions OpenAPI json files: Moved from `data-plane/Microsoft.App.DynamicSessions/preview/\\u003cversion\\u003e/` to `data-plane/DynamicSessions/preview/\\u003cversion\\u003e/`\\r\\n- The data-plane readme.md updated paths from `Microsoft.App.DynamicSessions/preview/\\u003cversion\\u003e/` to `preview/\\u003cversion\\u003e/`\\n\\n### File Reference Updates Needed\\n\\n1. **Readme.md files** - Update input-file paths:\\r\\n   \\r\\n   **For ContainerApps (Resource Manager)**:\\r\\n   ```yaml\\r\\n   # Before\\r\\n   input-file:\\r\\n     - Microsoft.App/stable/2024-03-01/ContainerApps.json\\r\\n   \\r\\n   # After  \\r\\n   input-file:\\r\\n     - stable/2024-03-01/ContainerApps.json\\r\\n   ```\\r\\n   \\r\\n   **For DynamicSessions (Data Plane)**:\\r\\n   ```yaml\\r\\n   # Before migration - in data-plane/readme.md\\r\\n   input-file:\\r\\n     - Microsoft.App.DynamicSessions/preview/2025-02-02-preview/DynamicSessions.json\\r\\n   \\r\\n   # After migration - in data-plane/DynamicSessions/readme.md  \\r\\n   input-file:\\r\\n     - preview/2025-02-02-preview/DynamicSessions.json\\r\\n   ```\\r\\n\\r\\n2. **tspconfig.yaml files** - Update emitter output directory:\\r\\n   \\r\\n   **DynamicSessions tspconfig.yaml changes**:\\r\\n   ```yaml\\r\\n   # Before migration - in Microsoft.App.DynamicSessions/tspconfig.yaml\\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       emitter-output-dir: \\\"{project-root}/..\\\"\\r\\n       output-file: \\\"{azure-resource-provider-folder}/{service-name}/{version-status}/{version}/DynamicSessions.json\\\"\\r\\n   \\r\\n   # After migration - in data-plane/DynamicSessions/tspconfig.yaml\\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       emitter-output-dir: \\\"{project-root}\\\"\\r\\n       output-file: \\\"{version-status}/{version}/DynamicSessions.json\\\"\\r\\n   ```\\r\\n\\r\\n3. **Common-types references** - Update relative paths in JSON files:\\r\\n   ```json\\r\\n   // Before (in ContainerApps.json)\\r\\n   \\\"$ref\\\": \\\"../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   \\r\\n   // After  \\r\\n   \\\"$ref\\\": \\\"../../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   ```\\r\\n\\r\\n   Fpr mgmt plane TypeSpec, we also need to specify the `arm-common-types` in tspconfig options of `@azure-tools/typespec-autorest`.\\r\\n   ```yaml \\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n   ```\\n\\n// After  \\r\\n   \\\"$ref\\\": \\\"../../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\"\\r\\n   ```\\r\\n\\r\\n   Fpr mgmt plane TypeSpec, we also need to specify the `arm-common-types` in tspconfig options of `@azure-tools/typespec-autorest`.\\r\\n   ```yaml \\r\\n   options:\\r\\n     \\\"@azure-tools/typespec-autorest\\\":\\r\\n       arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n   ```\\r\\n\\r\\n4. **Suppressions.yaml** - Update paths in suppressions:\\r\\nAs GitHub recognize this refactor change as to add new API versions in the OpenAPI folder, in order to make sure the TypeSpec requirement check pass. we need to have a suppressions.yaml under serviceName folder \\r\\nand add suppression one by one like this \\r\\n```\\r\\n- tool: TypeSpecRequirement\\r\\n  path: ./preview/2022-01-01-preview/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n- tool: TypeSpecRequirement\\r\\n  path: ./stable/2025-01-01/*.json\\r\\n  reason: Brownfield service not ready to migrate\\r\\n```\\n\\n## The impact to ongoing PRs\\n\\n1. If the ongoing PRs are targeting to a release-* or dev-* branch which are not created or syncing from the latest main, we recommend to merge these PRs first.\\r\\n1. If the ongoing PRs are targeting to public main branch, Here's the suggestion to resolve the conflict. \\r\\n\\r\\n      1. Merge latest main \\r\\n          ```\\r\\n          git checkout main\\r\\n          git pull origin main // origin points to Azure rest api specs repo.\\r\\n          git merge main \\u003cyour-pr-branch\\u003e\\r\\n          ```\\r\\n      2. Resolve conflicts  \\r\\n        - For most of the conflicts, accept the incoming changes.  \\r\\n        - If it's unclear, please accept both and then update based on your judgement with the folder structure changes above.  \\r\\n\\r\\n      3. Make sure the new change is aligned with folder structure v2  \\r\\n\\r\\n         There are some cases where the PR is adding a new version in the original location, but the file diffs don't show as conflict. we should move them into the correct place so that it doesn't break the folder structure v2 as instructions in **Understanding Folder Migration sections** \\r\\n\\r\\n      4. clean up the previous folder if exists.\\r\\n\\r\\n  \\r\\n\\r\\n**Important**: It's strongly recommended to understand what's really changed in the folder refactor. Always ensure the new PR doesn't include any things that breaks the folder structure.\\n\\n### After Resolution\\n\\nMake sure to compile the TypeSpec project so that the TypeSpec Validation could pass.\\r\\n\\r\\n1. **Comprehensive validation**:\\r\\n   ```bash\\r\\n   # Run full validation suite\\r\\n   npm ci\\r\\n   npm run lint\\r\\n   npm run validate\\r\\n   \\r\\n   # Test TypeSpec compilation for your service\\r\\n   cd specification/app/data-plane/DynamicSessions/\\r\\n   npx tsp compile .\\r\\n   npx tsp compile . --emit @azure-tools/typespec-autorest\\r\\n   \\r\\n   # Verify generated files match expectations by checking if there's any diff with the OpenAPI json files.\\r\\n   ```\\n\\n## Getting Help\\n\\n### Resources\\n\\n- [Azure Service Version Guidelines](https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline)\\r\\n- [Container Apps Migration PR #36764](https://github.com/Azure/azure-rest-api-specs/pull/36764)\\n\\n### Support Channels\\n\\nIf you encounter complex conflicts that can't be resolved using this guide, please email to azversioning@service.microsoft.com\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#add-common-types.md\",\"document_title\":\"Adding Common Types to Azure Resource Manager (ARM)\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/add-common-types\",\"content\":\"# howtos#arm#add-common-types.md\\n\\n# Adding Common Types to Azure Resource Manager (ARM)\\n\\nThis guide provides detailed instructions on how to add and manage common types in Azure Resource Manager (ARM) using Common types are reusable components that can be shared across multiple ARM templates, ensuring consistency and reducing redundancy.\\r\\n\\r\\nThe TypeSpec common-types files are located in the [typespec-azure repository](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/lib/common-types). The generated Swagger files can be found in the [common-types/openapi directory](https://github.com/Azure/typespec-azure/tree/main/packages/samples/common-types/openapi).\\r\\n\\r\\nThere are two main approaches to editing common types:\\r\\n\\r\\n1. **Creating a New Version of an Existing Common Type**: This involves updating an existing common type with new versioning information and making necessary changes.\\r\\n2. **Creating a Completely New Common Type**: This involves defining a new common type from scratch and integrating it into the existing system.\\r\\n\\r\\nFollow the steps outlined in this guide to ensure that your common types are correctly added and documented.\\n\\n## Create a New Version of an Existing Common Type\\n\\n[Pull Request Example](https://github.com/Azure/typespec-azure/pull/1689/files)\\r\\n\\r\\nCreating a new version of an existing common type mostly involves editing what is already there and adding the new version of the common type.\\r\\n\\r\\n1. Make all the necessary versioning changes in the common-type file, mostly using `@added(Versions.vX)`, `@removed(Versions.vX)`, and `@typeChangedFrom(Versions.vX)` decorators.\\r\\n2. Update the common-type-ref file by adding the new version of the common type using the `@@armCommonDefinition` decorator .This needs to be done for all the definitions present in the new version, not only the newly added definitions.\\r\\n   ```typespec\\r\\n   @@armCommonDefinition(ExtensionResource,\\r\\n     \\\"ProxyResource\\\",\\r\\n     Azure.ResourceManager.CommonTypes.Versions.v6\\r\\n   );\\r\\n   ```\\r\\n3. If it is a completely new version, add the version to [versions.tsp](https://github.com/AlitzelMendez/typespec-azure/blob/main/packages/typespec-azure-resource-manager/lib/common-types/versions.tsp))\\r\\n4. Generate the Swagger updates by running:\\r\\n   ```bash\\r\\n   cd typespec-azure\\\\packages\\\\samples\\\\common-types\\r\\n   pnpm regen-common-types\\r\\n   ```\\r\\n5. Generate the documentation\\r\\n   ```bash\\r\\n   pnpm gen-docs\\r\\n   ```\\n\\n## Create a new common type\\n\\n);\\r\\n     ```\\r\\n\\r\\n1. Add the common-type file to [common-types.tsp](https://github.com/Azure/typespec-azure/blob/main/packages/typespec-azure-resource-manager/lib/common-types/common-types.tsp)\\r\\n1. Create an equivalent file of the common type in [samples/common-types/src](https://github.com/Azure/typespec-azure/tree/main/packages/samples/common-types/src) (`managed-identity-with-delegation.tsp`)\\r\\n1. In that file, import the TypeSpec file you created before: `import \\\"../../node_modules/@azure-tools/typespec-azure-resource-manager/lib/common-types/managed-identity-with-delegation.tsp\\\";`\\r\\n1. Indicate that you want to emit the common types Swagger by updating [gen.ts](https://github.com/Azure/typespec-azure/blob/main/packages/samples/common-types/gen.ts)), adding a line like the following:\\r\\n   ```typespec\\r\\n   await emitCommonTypesSwagger(\\\"managed-identity-with-delegation\\\");\\r\\n   ```\\r\\n1. Generate the Swagger updates by running:\\r\\n   ```bash\\r\\n   cd typespec-azure\\\\packages\\\\samples\\\\common-types\\r\\n   pnpm regen-common-types\\r\\n   ```\\r\\n1. Finally, generate the documentation:\\r\\n   ```bash\\r\\n   pnpm gen-docs\\r\\n   ```\\n\\n[Example of a pull request](https://github.com/Azure/typespec-azure/pull/1505/files)\\r\\n\\r\\n1. Create a new file in the [common-types folder](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/lib/common-types) with your common type name, e.g., `managed-identity-with-delegation.tsp`.\\r\\n1. Write the common type in the `managed-identity-with-delegation.tsp` file:\\r\\n   - Use the `@added(Versions.vX)` decorator in all models to specify in which version the model is added.\\r\\n1. Create a new reference file in the [common-types folder](https://github.com/Azure/typespec-azure/tree/main/packages/typespec-azure-resource-manager/lib/common-types) with the common type name and the `-ref` suffix, e.g., `managed-identity-with-delegation-ref.tsp`\\r\\n1. Edit the `-ref` file:\\r\\n   - Start by importing the common type TypeSpec file.\\r\\n     ```typespec\\r\\n     import \\\"./managed-identity-with-delegation.tsp\\\";\\r\\n     ```\\r\\n   - In the `-ref` file write the reference to all the definitions you just created using the `@@armCommonDefinition(` decorator. Expose every single version in which the definition is available.\\r\\n\\r\\n     ```typespec\\r\\n     @@armCommonDefinition(ManagedServiceIdentityWithDelegation,\\r\\n       \\\"ManagedServiceIdentityWithDelegation\\\",\\r\\n       Azure.ResourceManager.CommonTypes.Versions.v4\\r\\n     );\\r\\n     @@armCommonDefinition(ManagedServiceIdentityWithDelegation,\\r\\n       \\\"ManagedServiceIdentityWithDelegation\\\",\\r\\n       Azure.ResourceManager.CommonTypes.Versions.v5\\r\\n     );\\r\\n     ```\\r\\n\\r\\n1. Add the common-type file to [common-types.tsp](https://github.com/Azure/typespec-azure/blob/main/packages/typespec-azure-resource-manager/lib/common-types/common-types.tsp)\\r\\n1. Create an equivalent file of the common type in [samples/common-types/src](https://github.com/Azure/typespec-azure/tree/main/packages/samples/common-types/src) (`managed-identity-with-delegation.tsp`)\\r\\n1. In that file, import the TypeSpec file you created before: `import \\\"../..\"},{\"document_source\":\"azure_resource_manager_rpc\",\"document_filename\":\"v1.0#common-api-details.md\",\"document_title\":\"Common API Details\",\"document_link\":\"https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/common-api-details.md\",\"content\":\"# v1.0#common-api-details.md\\n\\n# Common API Details\\n\\n## Table of Contents ##\\n\\n- [Proxy Request Header Modifications](#proxy-request-header-modifications) \\u003c/br\\u003e\\r\\n- [Client Request Headers](#client-request-headers) \\u003c/br\\u003e\\r\\n- [Request Query Parameters](#request-query-parameters) \\u003c/br\\u003e\\r\\n- [Case Insensitivity for Requests](#case-insensitivity-for-requests) \\u003c/br\\u003e\\r\\n- [Client Request Timeout](#client-request-timeout) \\u003c/br\\u003e\\r\\n- [Request Throttling](#request-throttling) \\u003c/br\\u003e\\r\\n- [Common API Response Details](#common-api-response-details) \\u003c/br\\u003e\\n\\n## Proxy Request Header Modifications ##\\n\\nthe admins of the tenant which issued the JWT. | 1st party only |\\r\\n| x-ms-client-authentication-methods | Always added. Set to the authentication method references of client JWT. | 1st party only|\\r\\n| x-ms-management-group-ancestors | Always added. Set to the management groups that subscription might belong to. If there are multiple ancestors they will be comma separated. Example: `d27e3b8a-3d55-44b7-b2ba-1b3ef9227527, NonProduction` | 1st party only|\\r\\n| x-ms-arm-resource-routing-location | Added when extension resources or child proxy resources are routed regionally. Set to the endpoint location the request is routed to in the region's lower-case normalized form (i.e. `eastus2`). The endpoint location will be decided by the location of the closest tracked ancestor. If there is no tracked ancestor, the header will not be set. If the request is routed to the global endpoint because there is no matching regional endpoint, it will be set to an empty string. | 1st and 3rd party |\\n\\ntenant ID of the client JWT making the request. | 1st party only |\\r\\n| x-ms-home-tenant-id | Added for requests at or below subscription scopes. Set to the tenant ID of the subscription. This will be different from `x-ms-client-tenant-id` in cross-tenant scenarios. | 1st party only |\\r\\n| x-ms-client-audience | Always added. Set to the audience of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-issuer | Always added. Set to the issuer of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-object-id | Always added. Set to the object Id of the client JWT making the request. Not all users have object Id. For CSP (reseller) scenarios for example, object Id is not available. | 1st party only |\\r\\n| x-ms-client-app-id | Always added. Set to the app Id of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-app-id-acr | Always added. Set to the app Id acr claim of the client JWT making the request. This is the application authentication context class reference claim which indicates how the client was authenticated. | 1st party only |\\r\\n| x-ms-client-authorization-source | Always added. Specifies the authorization source of the token. It\\u0026#39;s value can be NotSpecified, Legacy, RoleBased, Bypassed, Direct and Management. | 1st party only |\\r\\n| x-ms-client-identity-provider | Always added. Set to the identity provider of the client JWT. |1st party only |\\r\\n| x-ms-client-wids | Always added. Set to the wids of the client JWT. These identify the admins of the tenant which issued the JWT. | 1st party only |\\r\\n| x-ms-client-authentication-methods | Always added. Set to the authentication method references of client JWT. | 1st party only|\\r\\n| x-ms-management-group-ancestors | Always added. Set to the management groups that subscription might belong to. If there are multiple ancestors they will be comma separated. Example: `d27e3b8a-3d55-44b7-b2ba-1b3ef9227527, NonProduction` | 1st party only|\\r\\n| x-ms-arm-resource-routing-location |\\n\\nThe resource provider proxy will preserve all the client requests headers, with the exception of modifications per the details below. The headers below are reserved and cannot be set by clients.\\r\\n\\r\\n\\r\\n| Header                     | Description |  1st or 3rd Party |\\r\\n| :----------------------------| :------------------------| :-----------------------------------|\\r\\n| referer | Always added. Set to the full URI that the client connected to (which will be different than the RP URI, since it will have the public hostname instead of the RP hostname). This value can be used in generating FQDN for Location headers or other requests since RPs should not reference their endpoint name. |  1st and 3rd party |\\r\\n| authorization | Always removed/changed. The authorization used by the client to the proxy will be different than the authorization used to communicate from the proxy to the resource provider. | 1st and 3rd party |\\r\\n| x-ms-client-ip-address | Always added . Set to the client IP address used in the request; this is required since the resource provider will not have access to the client IP. | 1st and 3rd party |\\r\\n| x-ms-client-principal-name | Always added. Set to the principal name / UPN of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-principal-id | Added when available. Set to the principal Id of the client JWT making the request. Service principal will not have the principal Id. | 1st party only |\\r\\n| x-ms-client-tenant-id | Always added. Set to the tenant ID of the client JWT making the request. | 1st party only |\\r\\n| x-ms-home-tenant-id | Added for requests at or below subscription scopes. Set to the tenant ID of the subscription. This will be different from `x-ms-client-tenant-id` in cross-tenant scenarios. | 1st party only |\\r\\n| x-ms-client-audience | Always added. Set to the audience of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-issuer | Always added. Set to the issuer of the client JWT making the request. |\\n\\n## Client Request Headers ##\\n\\nAny non-reserved headers provided by the client will pass as-is to the resource provider. All requests to resource providers may include the following standard headers and **must** be supported:\\r\\n\\r\\n| Header | Description |\\r\\n| --- | --- |\\r\\n| Content-Type | Set to application/json. This header is not sent in requests that don\\u0026#39;t have any content, such as all GET calls. |\\r\\n| Accept-Language | Specifies the preferred language for the response; all RPs should use this header when generating error messages or client facing text. |\\r\\n| x-ms-client-request-id | Caller-specified value identifying the request, in the form of a GUID with no decoration such as curly braces (e.g. `client-request-id: 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0`). If the caller provides this header – the resource provider **must** log this with their traces to facilitate tracing a single request. If specified, this will be included in response information as a way to map the request if \\\"x-ms-return-client-request-id\\\"; is specified as \\\"true\\\". Because this header can be client-generated, it should not be assumed to be unique by the RP implementation. |\\r\\n| x-ms-correlation-request-id | Optional. Caller-specified value identifying a set of related operations that the request belongs to, in the form of a GUID. If the caller does not specify this header, ARM will randomly generate a unique GUID. Used for tracing the correlation Id of the request; the resource provider **must** log this so that end-to-end requests can be correlated across Azure. Because this header can be client-generated or re-used for multiple requests, it should not be assumed to be unique by the RP implementation. |\\r\\n| x-ms-return-client-request-id | Optional. True or false and indicates if a client-request-id should be included in the response. Default is false. |\\n\\n## Request Query Parameters ##\\n\\nARM will proxy request parameters (e.g. $filter; $expand; $skipToken; etc.) as-is to the Resource Providers. It will not delete, modify or add any query parameters before relaying the request. The only exceptions are the following query parameters which are not supported on requests into ARM and will cause the request to be rejected with a 400 status code:\\r\\n\\r\\n- `sub`\\r\\n- `subId`\\r\\n- `subscription`\\r\\n- `subscriptionId`\\n\\n## Case Insensitivity for Requests ##\\n\\nWhen satisfying incoming requests, it is assumed that the following values are stored / indexed / compared in a case **insensitive** way:\\r\\n\\r\\n- Resource group name\\r\\n- Resource name\\r\\n- Other names of entities in the URL, even if they are not resources.\\n\\n## Client Request Timeout ##\\n\\nRequests proxied to the resource provider are made with a client timeout of 60 seconds. If requests take more than 60 seconds please consider using asynchronous request/response pattern.\\r\\n\\r\\nThe resource provider must respond within that time interval or the client will receive a 504 (timeout) error code and will not see the response from the RP.\\n\\n## Request Throttling ##\\n\\nARM provides subscription level throttling. More details on these limits can be found [here](https://azure.microsoft.com/en-us/documentation/articles/azure-subscription-service-limits/#overview).\\n\\n## Common API Response Details ##\\n\\n### Response Headers ###\\n\\nAll responses from resource providers should include the following headers:\\r\\n\\r\\n| Header | Description |\\r\\n| --- | --- |\\r\\n| `Content-Type` | Set to application/json. This header is not required in responses that don\\u0026#39;t have any content. |\\r\\n| `Date` | The date that the request was processed, in RFC 1123 format. |\\r\\n| `x-ms-request-id` | A unique identifier for the current operation, service generated. All the resource providers \\\\*must\\\\* return this value in the response headers to facilitate debugging. |\\r\\n| `x-ms-failurecause` | An ___optional___ header used to provide additional failure attribution on error responses. See [below](#x-ms-failurecause-header) for additional information. |\\r\\n\\r\\nAll long running operations response details are described below.\\n\\n### Error Response Content ###\\n\\n\\\"policyAssignmentDisplayName\\\": \\\"Allow Central US and WEU only\\\",\\r\\n              \\\"policyAsssignmentId\\\": \\\"/subscriptions/00000-00000-0000-000/providers/Microsoft.Authorization/policyAssignments/TestAssignment1\\\"\\r\\n            }\\r\\n          },\\r\\n          {\\r\\n            \\\"type\\\": \\\"SomeOtherViolation\\\",\\r\\n            \\\"info\\\": {\\r\\n              \\\"innerException\\\": \\\"innerException Details\\\"\\r\\n       \"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-07-17.md\",\"document_title\":\"Missing x-ms-request-id field\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-07-17.md\\n\\n# Missing x-ms-request-id field\\n\\n## question\\n\\nSome newly generated swaggers may be missing the \\\"x-ms-request-id\\\" field\\r\\n```diff\\r\\n\\\"responses\\\": {\\r\\n    \\\"200\\\": {\\r\\n        \\\"description\\\": \\\"ignore\\\",\\r\\n        \\\"schema\\\": {\\r\\n            \\\"$ref\\\": \\\"#/definitions/RestoreResult\\\"\\r\\n-       }\\r\\n-       \\\"headers\\\":{\\r\\n-           \\\"x-ms-request-id\\\":{\\r\\n-               \\\"type\\\": \\\"string\\\",\\r\\n-               \\\"description\\\": \\\"A unique ID for the current operation, service generated. All the resource pro\\r\\n-           }\\r\\n        }\\r\\n    },\\r\\n    \\\"202\\\": {\\r\\n-       \\\"description\\\": \\\"ignore\\\",\\r\\n-       \\\"headers\\\": {\\r\\n-           \\\"x-ms-request-id\\\": {\\r\\n-               \\\"type\\\": \\\"string\\\",\\r\\n-               \\\"description\\\": \\\"A unique ID for the current operation, service generated. All the resource pro\\r\\n-           }\\r\\n-       }\\r\\n+       \\\"description\\\": \\\"ignore\\\"\\r\\n    },\\r\\n```\\n\\n## answer\\n\\nhttps://azure.github.io/typespec-azure/docs/libraries/azure-core/reference/data-types/#Azure.Core.RequestIdResponseHeader\\r\\n\\r\\nexample:\\r\\nmove is ArmResourceActionSync\\u003cEmployee, MoveRequest, MoveResponse \\u0026 Azure.Core.RequestIdResponseHeader\\u003e;\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_31.md\",\"document_title\":\"TypeSpec Validation error\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_31.md\\n\\n# TypeSpec Validation error\\n\\n## question\\n\\nI have error: https://github.com/Azure/azure-rest-api-specs/actions/runs/16475997770/job/46577654359?pr=35887:\\r\\n```\\r\\nRule Compile failed\\r\\n  {\\\"not_added\\\":[],\\\"conflicted\\\":[],\\\"created\\\":[],\\\"deleted\\\":[],\\\"modified\\\":[\\\"specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\\"],\\\"renamed\\\":[],\\\"files\\\":[{\\\"path\\\":\\\"specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\\",\\\"index\\\":\\\" \\\",\\\"working_dir\\\":\\\"M\\\"}],\\\"staged\\\":[],\\\"ahead\\\":0,\\\"behind\\\":0,\\\"current\\\":\\\"HEAD\\\",\\\"tracking\\\":null,\\\"detached\\\":true}diff --git a/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json b/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\r\\n  index 58f42ef3f..cc93d3906 100644\\r\\n  --- a/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\r\\n  +++ b/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\r\\n  @@ -7079,8 +7079,7 @@\\r\\n             \\\"description\\\": \\\"Optional. Any input parameters that needs to passed to the script and are accessed within the script for its execution.\\\",\\r\\n             \\\"items\\\": {\\r\\n               \\\"$ref\\\": \\\"#/definitions/GalleryScriptParameter\\\"\\r\\n  -          },\\r\\n  -          \\\"x-ms-identifiers\\\": []\\r\\n  +          }\\r\\n           }\\r\\n         },\\r\\n         \\\"required\\\": [\\r\\n  \\r\\n  Files have been changed after `tsp compile`. Run `tsp compile` and ensure all files are included in your change.\\r\\n  Error: TypeSpec Validation failed for project specification/compute/Gallery.Management run the following command locally to validate.\\r\\n   \\u003e npm ci\\r\\n   \\u003e npx tsv specification/compute/Gallery.Management\\r\\n  For more detailed docs see https://aka.ms/azsdk/specs/typespec-validation\\r\\n```\\r\\n \\r\\nIs it because I have\\r\\n```\\r\\n  @@ -7079,8 +7079,7 @@\\r\\n             \\\"description\\\": \\\"Optional.\\n\\nFiles have been changed after `tsp compile`. Run `tsp compile` and ensure all files are included in your change.\\r\\n  Error: TypeSpec Validation failed for project specification/compute/Gallery.Management run the following command locally to validate.\\r\\n   \\u003e npm ci\\r\\n   \\u003e npx tsv specification/compute/Gallery.Management\\r\\n  For more detailed docs see https://aka.ms/azsdk/specs/typespec-validation\\r\\n```\\r\\n \\r\\nIs it because I have\\r\\n```\\r\\n  @@ -7079,8 +7079,7 @@\\r\\n             \\\"description\\\": \\\"Optional. Any input parameters that needs to passed to the script and are accessed within the script for its execution.\\\",\\r\\n             \\\"items\\\": {\\r\\n               \\\"$ref\\\": \\\"#/definitions/GalleryScriptParameter\\\"\\r\\n  -          },\\r\\n  -          \\\"x-ms-identifiers\\\": []\\r\\n  +          }\\r\\n           }\\r\\n         },\\r\\n         \\\"required\\\": [\\r\\n```\\r\\nwhere x-ms-identifier is empty? That is intended.\\n\\n## answer\\n\\nThe swagger generated by TypeSpec is constantly changing across TypeSpec versions.  Do you believe the new swagger is incorrect?\\r\\n \\r\\nAlso, keep in mind the version of TypeSpec may be different in main, the base and source branches of your PR, and locally.  Unless you think the new generated swagger is incorrect, you want to update forward.\\r\\nx-ms-identifier is no longer needed https://github.com/Azure/typespec-azure/issues/2868:\\r\\n```\\r\\nissue 2868:\\r\\ntitle: [Deprecation] x-ms-identifiers extension is no longer useful\\r\\ncontent: As title, and confirmed by @cweining, this swagger extension is completely useless for them who is from the original team that added this extension in swagger. Please remove it from typespec-autorest emitter\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Breaking Change(Cross-Version) failure\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Breaking Change(Cross-Version) failure\\n\\n## question\\n\\nWe have the [PR](https://github.com/Azure/azure-rest-api-specs-pr/pull/22834) to introduce new API version with new features for existing RP. The [Breaking Changes(Cross-Version) detected problems](https://github.com/Azure/azure-rest-api-specs-pr/pull/22834/checks?check_run_id=43004413278). How to fix it?\\n\\n## answer\\n\\nIt depends.  Even across versions, some changes are discouraged/disallowed.  If the breaking changes reported in your PR are all intentional, then you just need to follow the instructions in the \\\"next steps to merge\\\" comment to work with the breaking changes board for approval: https://aka.ms/brch\\r\\nGenerally, breaking changes between preview api-versions are allowed if there are good reasons,  breaking changes relative to a stable api-version are more of a concern.  Also, if preview api-versions are old enough, they count as stable api-versions (I doubt that is the case here).\\r\\nThe case here is a preview with breaking changes relative to the last stable. And in this case, making a property optional would be considered breaking if the property occurs in responses.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_14.md\",\"document_title\":\"Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_14.md\\n\\n# Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221\\n\\n## question\\n\\nHi I'm looking for someone to help suppress CI Failure on this PR [new addProxyAgentExtension property for proxyagentsettings by huiminyan2017 · Pull Request #36221 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/36221)\\r\\n \\r\\nCompute has multiple API versions so the Avacado check failure is expected.\\n\\n## answer\\n\\nYour PR is to a feature branch, so no checks are required.\\r\\n \\r\\nHowever, your PR may be blocked when you try to merge to main, so I recommend following the instructions here now:\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#multiple_api_version\\r\\n```\\r\\nMULTIPLE_API_VERSION\\r\\nRule MULTIPLE_API_VERSION was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this Uniform Versioning Violation Guide wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_21.md\",\"document_title\":\"Generating readme and examples files\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_21.md\\n\\n# Generating readme and examples files\\n\\n## question\\n\\nHi TypeSpec Discussion\\r\\n\\r\\nI have this PR [adding shared limit typespec by parthshah2305 · Pull Request #24115 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/24115) to add a new resource provider's typespec.\\r\\n\\r\\nTwo of the validations that are failing are due to missing readme and example files.\\r\\nCould anyone point me to some documentation around generating readme files?\\r\\n\\r\\nI also tried generating the example files locally, but it throws the below exception . I am not sure where this path to common-types is specified to change it to point it correctly.\\r\\n\\r\\n```\\r\\noav generate-examples .\\\\resource-manager\\\\Microsoft.Limit\\\\Limit\\\\stable\\\\2025-08-15\\\\Limit.json\\r\\n{\\r\\n  message: `fatal error: ENOENT: no such file or directory, open 'D:\\\\\\\\repos\\\\\\\\azure-rest-api-specs-pr\\\\\\\\common-types\\\\\\\\resource-management\\\\\\\\v5\\\\\\\\types.json', {\\\"errno\\\":-4058,\\\"code\\\":\\\"ENOENT\\\",\\\"syscall\\\":\\\"open\\\",\\\"path\\\":\\\"D:\\\\\\\\\\\\\\\\repos\\\\\\\\\\\\\\\\azure-rest-api-specs-pr\\\\\\\\\\\\\\\\common-types\\\\\\\\\\\\\\\\resource-management\\\\\\\\\\\\\\\\v5\\\\\\\\\\\\\\\\types.json\\\"}`,\\r\\n  level: '\\\\x1B[31merror\\\\x1B[39m'\\r\\n}\\r\\n```\\n\\n## answer\\n\\nThere're several problems with your PR. \\r\\n1.the folder structure is incorrect with your *.tsp files, you should put them under specification/limit/resource-manager/Microsoft.Limit/Limit/ as well as the tspconfig.yaml, you can take the widget specs as an example https://github.com/Azure/azure-rest-api-specs/tree/main/specification/widget/resource-manager \\r\\n2.Assuming you are an RPaaS services (because you are a new service and in azure-rest-api-specs-pr repo), you have to have a readme.md under resource-manager folder and which should contains the minimal information which is required from RPaaS to know that your service is a RPaaS services, you can also take a look at widget's example\\r\\n```\\r\\nopenapi-type: arm\\r\\nopenapi-subtype: rpaas\\r\\n```\\r\\nYou need to pay attention to the output file path in your tspconfig.yaml under the `@azure-tools/typespec-autorest` section https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/tspconfig.yaml#L9-L13 \\r\\n```\\r\\n    emitter-output-dir: \\\"{project-root}\\\"\\r\\n    # TODO: Does anything need this set, if it's not used in output-file?  Currently required by TSV.\\r\\n    azure-resource-provider-folder: \\\"resource-manager\\\"\\r\\n    output-file: \\\"{version-status}/{version}/widget.json\\\"\\r\\n    arm-types-dir: \\\"{project-root}/../../../../common-types/resource-management\\\"\\r\\n```\\r\\n1.because this is the file oav is trying to find https://github.com/Azure/azure-rest-api-specs-pr/blob/d1fd46b8d93ae2cdd50e282768fe5e82e718e893/specification/common-types/resource-management/v5/types.json\\r\\n2.You also need to have a readme.md under specification/limit/resource-manager/Microsoft.Limit/Limit/ ,  similar like this one https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/readme.md where you have to have references to all your swagger files with tags and its input-files\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# TypeSpec\\n## `ProvisioningStateMustBeReadOnly`\\nThe root cause is a limitation in how `azure-openapi-validator` and `oav` handle `$ref` siblings:\\r\\n- https://github.com/Azure/azure-openapi-validator/issues/637\\r\\n- https://github.com/Azure/oav/issues/848\\r\\nThe recommended workaround is to add `use-read-only-status-schema: true` to your `tspconfig.yaml`.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure REST API, SDK development process with TypeSpec\\n## Table Of Content\\n### 4. Prepare and submit a Pull Request for reviewing\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\r\\n   - send a pull request to the original repo from your forked repo.\\r\\n   See the ARM Wiki for information on the [supported repos and branches for management-plane services](https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches).\\r\\n#### 4.1 Fix the errors of PR reviewing CI checks\\r\\nThe CI checks result will be commented on the PR. you can refer to the [CI fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\\r\\nNote:\\r\\nSince the OpenAPI is generated from TypeSpec, to change the OpenAPI, you must update the TypeSpec file and regenerate the\\r\\n OpenAPI and avoid updating OpenAPI directly to keep the consistency between OpenAPI and TypeSpec.\\r\\nFor support \\u0026 help, you can post a message to [TypeSpec Discussion - teams channel](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#mustread.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/mustread\",\"content\":\"# Understanding the OpenAPI Changes\\n## Using Resources from Common Types\\nIf your resource definition already extends from a resource type in [common-types](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/common-types/resource-management), skip this section. This section explains how resource models are identified and appropriate base models from the TypeSpec resource manager library are selected.\\r\\n\\r\\nAn ARM Resource model should extend one of the typespec common-types Resource models when it meets **all** of the following criteria:\\r\\n\\r\\n1. There is a GET operation for the model.\\r\\n2. At least one operation returns a 200 response containing this model.\\r\\n3. The model has properties named `id`, `name`, and `type`.\\r\\n\\r\\nOnce a model is identified as a resource, it is represented by extending an appropriate [resource model](../../howtos/ARM/resource-type.md#modeling-resources-in-typespec) from the TypeSpec library. This can result in textual differences between the original OpenAPI file and generated OpenAPI file like:\\r\\n\\r\\n```diff\\r\\n\\\"YourResource\\\": {\\r\\n  \\\"type\\\": \\\"object\\\",\\r\\n  \\\"properties\\\": {\\r\\n    \\\"properties\\\": {\\r\\n      \\\"$ref\\\": \\\"#/definitions/YourResourceProperties\\\",\\r\\n    }\\r\\n  },\\r\\n  \\\"allOf\\\": [\\r\\n    {\\r\\n-      \\\"$ref\\\": \\\"#/definitions/YourOwnProxyResourceDefinition\\\"\\r\\n+      \\\"$ref\\\": \\\"../../../../../common-types/resource-management/v3/types.json#/definitions/ProxyResource\\\"\\r\\n    }\\r\\n  ]\\r\\n}\\r\\n```\\r\\n\\r\\nAccept this change to align with ARM conventions. If there is a strong business justification to keep the original definition, use the `@customAzureResource` decorator to mark the model.\\r\\n\\r\\n```tsp\\r\\nmodel YourResource extends YourOwnProxyResourceDefinition {\\r\\n  properties: YourResourceProperties;\\r\\n}\\r\\n\\r\\n@Azure.ResourceManager.Legacy.customAzureResource\\r\\nmodel YourOwnProxyResourceDefinition {\\r\\n  @key\\r\\n  @path\\r\\n  @segment(\\\"yourSegment\\\")\\r\\n  name: string;\\r\\n}\\r\\n```\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/versioning\",\"content\":\"# Versioning\\nThis document explains how to manage versioning in TypeSpec projects, including how to add, remove, or modify resources, operations, and properties across API versions.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#01-get-started.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/01-get-started\",\"content\":\"# Getting started with TypeSpec migration\\n## Steps of migration and comparison\\n### Create Spec PR with new TypeSpec project\\n- In the `readme.md` file, under the latest tag, change the `input-file` to the OpenAPI file generated from TypeSpec.\\r\\n- If the generated OpenAPI file(s) for the latest version changed name, delete the old OpenAPI file(s) no longer referenced in README.md.\\r\\n- Create a PR with the TypeSpec files, changed OpenAPI files (examples included) and readme file.\\r\\n- Check CI failures. Refer to [Resolving Pipeline failures](./faq/pipeline.md)\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"libraries#azure-resource-manager#reference#data-types.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/libraries/azure-resource-manager/reference/data-types\",\"content\":\"# Data types\\n## Azure.ResourceManager.CommonTypes\\n### `ErrorDetail` {#Azure.ResourceManager.CommonTypes.ErrorDetail}\\nThe error detail.\\r\\n```typespec\\r\\nmodel Azure.ResourceManager.CommonTypes.ErrorDetail\\r\\n```\\r\\n#### Properties\\r\\n| Name            | Type                                                | Description                |\\r\\n| --------------- | --------------------------------------------------- | -------------------------- |\\r\\n| code?           | `string`                                            | The error code.            |\\r\\n| message?        | `string`                                            | The error message.         |\\r\\n| target?         | `string`                                            | The error target.          |\\r\\n| details?        | `ResourceManager.CommonTypes.ErrorDetail[]`         | The error details.         |\\r\\n| additionalInfo? | `ResourceManager.CommonTypes.ErrorAdditionalInfo[]` | The error additional info. |\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\n## MULTIPLE_API_VERSION\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"# Convert OpenAPI specs to TypeSpec\\n## Conversion scope\\n- Horizontal conversion: Converting existing Azure OpenAPI specs to TypeSpec should not introduce any changes to the API.\\r\\n- No version revving: No version revving will occur during this process. The focus is solely on converting the existing\\r\\nspecifications to TypeSpec.\\r\\n- SDKs generated for validation only: The SDKs generated from the converted TypeSpec files will be used for validation\\r\\npurposes only. They are not intended for production release.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-repos.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-repos\",\"content\":\"# Azure REST API specs repositories on GitHub\\n## Publishing your spec to the spec repos\\nTo publish your spec to the API specs repositories, you must first understand what kind of API version you are\\r\\ntrying to publish and make a PR to appropriate branch based on that. Read about this in [this article](xref:pr-move-private-to-public).\\r\\n\\r\\n\\u003c!-- links --\\u003e\\r\\n[Azure/azure-rest-api-specs]: https://github.com/Azure/azure-rest-api-specs\\r\\n[Azure/azure-rest-api-specs-pr]: https://github.com/Azure/azure-rest-api-specs-pr\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-specs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-specs\",\"content\":\"# Create or update an Azure REST API spec\\n## Create your REST API definition\\n### [TypeSpec](#tab/typespec)\\nServices that use TypeSpec Azure to describe their REST API must include both the TypeSpec source spec and generated OpenAPI\\r\\nspecs in the specs repo.\\r\\n\\r\\nIt is good practice to create a new branch in the specs repo for each new REST API definition that you create.\\r\\nUse this branch to iterate on your REST API definition until it is ready for review.\\r\\n\\r\\n- [Spec directory structure]\\r\\n- See our [tutorial](xref:api-tutorial) for more help.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-typespec-conversion.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-typespec-conversion\",\"content\":\"# Convert OpenAPI specs to TypeSpec\\n## Before you begin\\n### Overview of TypeSpec\\n[TypeSpec](https://typespec.io) is the new standard API definition language for Azure, developed by Microsoft.\\r\\nTypeSpec offers many [benefits for Azure API definition](api-typespec.md), including consistency, efficiency, enhanced tooling,\\r\\nand accessibility. By using TypeSpec, you can ensure a consistent, high-quality developer experience across Azure services.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-specs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-specs\",\"content\":\"# Create or update an Azure REST API spec\\nEvery Azure service must describe its REST APIs using [TypeSpec Azure](xref:api-typespec)  \\r\\n([OpenAPI](xref:api-openapi) is supported on an exception basis only).\\r\\nAs of October 2023, Azure has adopted [TypeSpec](xref:api-typespec) as the preferred means for defining REST APIs.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Important information about this article\\n### Summary\\nPer the [PR diagram], the first step of getting your specs PR approved is ensuring your PR obeys the  \\r\\n[Azure Versioning and Breaking Changes Policy]. Relevant details of this policy follow.\\r\\n\\r\\n- Once published, no changes to given API version are allowed, except when fixing the spec to match\\r\\nactual implementation (see the `-Approved-BugFix` labels in this doc).\\r\\nThis applies regardless of whether the API version is for `private preview`, `public preview`, or `GA`.\\r\\n- When introducing a new API version (any `preview` or `GA`), the new API version must be backwards compatible with\\r\\nthe previous, latest `GA` API version.\\r\\n- During a (`private` or `public`) `preview` cycle, a new `preview` API version does not have to be backwards\\r\\ncompatible with the previous `preview` API version.\\r\\n- The rules listed above are checked by automated GitHub checks. The exact ruleset is given in [`oadMessagesRuleMap.ts`].\\r\\nDetails follow.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Advanced cases\\n### Internal-only services\\nThere are some services that are \\\"internal only\\\" - none of their API versions are published in the public specs repo.\\r\\nThe Azure SDK team tooling running on the specs PRs may need to be updated to handle such cases.  \\r\\n[source](https://github.com/Azure/azure-sdk-tools/issues/7697#issuecomment-1980956741).\"}]",
            "inputs.latency": 742.8335733413696,
            "inputs.response_length": 2334,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors",
                "https://azure.github.io/typespec-azure/docs/howtos/arm/add-common-types"
            ],
            "inputs.testcase": "Trying to understand API spec validation errors",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1559,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1560,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Trying to understand API spec validation errors\\\\n\\\\nquestion: Hello all,\\\\nI just published a new PR for adding a new API version for our service. I followed the same procedure we have followed over last couple of years, but I am seeing validation errors which are pretty hard to decipher with my limited knowledge regarding them.\\\\nPR: https://github.com/Azure/azure-rest-api-specs/pull/38843\\\\nCan someone please take a look and help me narrow down the issues?\\\\nThe best I can see is that this file is missing?\\\\n```\\\\nCause: ResolverError: Error reading file \\\\\\\"/home/runner/work/azure-rest-api-specs/azure-rest-api-specs/after/specification/storagecache/common-types/resource-management/v3/types.json\\\\\\\"\\\\n```\\\", \\\"response\\\": \\\"The validation error you're seeing (`ResolverError: Error reading file .../specification/storagecache/common-types/resource-management/v3/types.json`) indicates that the CI pipeline cannot find the referenced `types.json` file for ARM common types in your OpenAPI spec. This is a common issue during TypeSpec conversion and OpenAPI generation when the path to the shared common-types Swagger is incorrect or missing.\\\\n\\\\n**Root Cause:**\\\\nYour generated OpenAPI is referencing a file (`common-types/resource-management/v3/types.json`) that does not exist in the expected location. This typically happens when:\\\\n- The `arm-types-dir` option in your `tspconfig.yaml` is incorrectly set, or\\\\n- The relative `$ref` paths in the generated OpenAPI do not match the repo's folder structure after migration.\\\\n\\\\n**How to Fix:**\\\\n1. **Update your tspconfig.yaml**: Make sure the `arm-types-dir` is set correctly to point to the shared common-types location in the repo. For example:\\\\n\\\\n```yaml\\\\noptions:\\\\n  \\\\\\\"@azure-tools/typespec-autorest\\\\\\\":\\\\n    arm-types-dir: \\\\\\\"{project-root}/../../../../common-types/resource-management\\\\\\\"\\\\n```\\\\nThis will ensure that references to ARM common types resolve to the correct file location.\\\\n\\\\n2. **Check your OpenAPI $ref paths**: In the generated OpenAPI files, verify that all `$ref` paths to common-types point to the correct relative location, such as:\\\\n```json\\\\n\\\\\\\"$ref\\\\\\\": \\\\\\\"../../../../../../common-types/resource-management/v3/types.json#/parameters/SubscriptionIdParameter\\\\\\\"\\\\n```\\\\nIf they are incorrect, re-run `tsp compile` after fixing `tspconfig.yaml`.\\\\n\\\\n3. **Validate locally**: After updating, run the following locally to ensure all references resolve:\\\\n```bash\\\\nnpm ci\\\\nnpx tsp compile .\\\\n```\\\\n\\\\n4. **Re-add generated files to PR**: Commit and push the corrected generated OpenAPI files. The validation error should be resolved.\\\\n\\\\n**Summary:**\\\\nThis error is a folder path misconfiguration for ARM common-types. Fix your `tspconfig.yaml` and regenerate your OpenAPI files to resolve the CI validation issue.\\\\n\\\\nIf you need a reference, you can look at how other RPs configure their `tspconfig.yaml` for ARM common-types, such as in the Widget service example:\\\\n```yaml\\\\n    arm-types-dir: \\\\\\\"{project-root}/../../../../common-types/resource-management\\\\\\\"\\\\n```\\\\n\\\\nFor more guidance, see the official documentation and migration guides linked below.\\\", \\\"ground_truth\\\": \\\"It looks like you have incorrect relative paths to common-types.\\\\nIn your previous spec:\\\\n```\\\\n\\\\\\\"$ref\\\\\\\": \\\\\\\"../../../../../../common-types/resource-management/v3/types.json#/parameters/ApiVersionParameter\\\\\\\"\\\\n```\\\\n(6 segments bfore common-types)\\\\nin this PR:\\\\n```\\\\n\\\\\\\"$ref\\\\\\\": \\\\\\\"../../../../../common-types/resource-management/v3/types.json#/parameters/ApiVersionParameter\\\\\\\"\\\\n```\\\\n(5 segments before common-types)\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: Generating Dictionary<string,object> type for swagger\n\nquestion: Hi API Spec Review,\nWe are currently using `IDictionary<string, object>` in our models to allow passing through various key-value pairs, where the values can be a string, an array, or other types. So I defined the property in Swagger and provided examples in one PR, but encountered errors during PR validation.\nCould you please suggest the right way to define such a flexible dictionary type in Swagger, and provide an example?\nPR Link: [Add AddtionalProperties for DataConnector by LaylaLiu-gmail · Pull Request #38644 · Azure/azure-res…](https://github.com/Azure/azure-rest-api-specs/pull/38644/files#diff-2770767541dae7e1213d29b59c6e3bed488a458947839f25fdc31b3c7844ad42)\nDictionary Definition in PR:\n```\n\"extendedProperties\": {\n\"type\": \"object\",\n\"additionalProperties\": {\n\"type\": \"object\"\n}\n```\nExamples in PR:\n```\n\"extendedProperties\": {\n\"environment\": \"production\",\n\"owner\": \"alice\",\n\"additionalEndpoints\": [\n\"https://foo.kusto.windows.net/databasename\",\n\"https://bar.kusto.windows.net/databasename\"\n]\n}\n```\nValidation Error:\n```\n❌  Check failure on line 8 in specification/app/resource-manager/Microsoft.App/ContainerApps/stable/2026-01-01/examples/Ag...\nGitHub Actions / Swagger ModelValidation - Analyze Code\nINVALID_TYPE: Expected type object but found type array\n❌  Check failure on line 8 in specification/app/resource-manager/Microsoft.App/ContainerApps/stable/2026-01-01/examples/Ag...\nGitHub Actions / Swagger ModelValidation - Analyze Code\nINVALID_TYPE: Expected type object but found type string\n```",
            "inputs.ground_truth": "I think what you want (unfortunately) is\n```\n\"extendedProperties\": {\n\"type\": \"object\",\n\"additionalProperties\": {}\n}\n```\nstrictly speaking, these should be the same, but autorest interprets {} to be any json value\nIn typespec this would be `Record<unknown>`  (a dictionary in which the properties can be any json type)",
            "inputs.response": "To correctly define a flexible dictionary property in Swagger/OpenAPI (for Azure REST APIs) where values can be string, array, or other types, you must use `additionalProperties` with an explicit schema that matches the types you want to allow. \n\nYour current definition uses:\n```json\n\"extendedProperties\": {\n  \"type\": \"object\",\n  \"additionalProperties\": {\n    \"type\": \"object\"\n  }\n}\n```\n\nHowever, this means each value in the dictionary must be an object, so simple values like strings or arrays will fail ModelValidation. \n\n**Best Practice (per Azure REST API guidelines):**\nTo allow values to be string, array, or object, you should use `oneOf` inside `additionalProperties` to describe all allowed types. For example:\n```json\n\"extendedProperties\": {\n  \"type\": \"object\",\n  \"additionalProperties\": {\n    \"oneOf\": [\n      { \"type\": \"string\" },\n      { \"type\": \"array\", \"items\": { \"type\": \"string\" } },\n      { \"type\": \"object\" }\n    ]\n  }\n}\n```\n\nThis schema means any key can have a string, an array of strings, or an object as its value. If you need more types, add more entries to the `oneOf` array.\n\n**Example that matches the schema:**\n```json\n\"extendedProperties\": {\n  \"environment\": \"production\",                  // string\n  \"owner\": \"alice\",                            // string\n  \"additionalEndpoints\": [                      // array of strings\n    \"https://foo.kusto.windows.net/databasename\",\n    \"https://bar.kusto.windows.net/databasename\"\n  ],\n  \"extraInfo\": { \"createdBy\": \"bob\" }         // object\n}\n```\n\n**Why the error occurred:**\nThe validation error 'Expected type object but found type array/string' happens because your schema required each value to be an object, but your example used a string or array. The fix is to use `oneOf` to allow the expected types.\n\n**TypeSpec equivalent:**\nIf you are writing TypeSpec, the closest equivalent is:\n```typespec\nmodel DataConnector {\n  extendedProperties?: Record<string | string[] | object>;\n}\n```\nBut for OpenAPI, you must express this with `oneOf` as shown above.\n\n**Summary:**\n- Use `additionalProperties` with `oneOf` for multiple allowed value types.\n- Your example must match one of the types defined in `oneOf`.\n- This pattern is compliant with Azure REST API guidelines and will pass ModelValidation.\n\nIf you have a fixed set of types or want to restrict to specific schemas, add them to the `oneOf` array.",
            "inputs.context": "[{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#openapi.md\",\"document_title\":\"OpenAPI v3 emitter\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/openapi\",\"content\":\"# emitters#openapi3#openapi.md\\n\\n# OpenAPI v3 emitter\\n\\nThe OpenAPI emitter translates TypeSpec language elements into their equivalent OpenAPI expressions. This guide explains how TypeSpec constructs are mapped to OpenAPI components.\\r\\n\\r\\n**Note**: The below documentation generally refers to the behavior of the OpenAPI v3 emitter when using OpenAPI version 3.0. Emitter output for version 3.1 may be slightly different according to additional features supported in 3.1 but not in 3.0.\\n\\n## Server Details\\n\\nWhen your TypeSpec file includes an [(HTTP) `@server` decorator](../../libraries/http/reference/decorators.md#@TypeSpec.Http.server), the OpenAPI emitter will generate a `servers` object in the resulting OpenAPI document. This object contains the server URL, description, and any variables defined in the decorator.\\r\\n\\r\\nYou can apply multiple `@server` decorators to create multiple entries in the `servers` array:\\r\\n\\r\\n```typespec\\r\\n@server(\\\"https://api.example.com/v1\\\", \\\"Primary production endpoint\\\")\\r\\n@server(\\\"https://api-dev.example.com/v1\\\", \\\"Development endpoint\\\")\\r\\nnamespace MyService;\\r\\n```\\n\\n## Operations\\n\\nEach TypeSpec operation is converted into an OpenAPI operation.\\n\\n### HTTP Method\\n\\nYou can explicitly specify the HTTP method using one of the [(HTTP) decorators][http-verb-decorators]:\\r\\n\\r\\n- `@get`\\r\\n- `@post`\\r\\n- `@put`\\r\\n- `@patch`\\r\\n- `@delete`\\r\\n\\r\\nIf you don't specify a method, the emitter will infer it from the operation name and signature.\\r\\n\\r\\n```typespec\\r\\n// Explicitly declared as GET /{id}\\r\\n@get\\r\\nop getUser(@path id: string): User;\\r\\n\\r\\n// Explicitly declared as POST /\\r\\n@post\\r\\nop createUser(user: User): User;\\r\\n\\r\\n// Automatically detected as GET /{id}\\r\\nop getUser(@path id: string): User;\\r\\n\\r\\n// Automatically detected as POST /\\r\\nop createUser(user: User): User;\\r\\n```\\n\\n### Operation Path\\n\\nThe path for an operation comes from the [(HTTP) `@route` decorator][http-route-decorator]. You can apply `@route` to:\\r\\n\\r\\n- Individual operations\\r\\n- Interfaces (groups of operations)\\r\\n- Namespaces\\r\\n\\r\\nWhen you apply routes to multiple levels, they're combined to form the complete path:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/api\\\")\\r\\nnamespace MyService {\\r\\n  @route(\\\"/users\\\")\\r\\n  interface Users {\\r\\n    // Results in GET /api/users/{id}\\r\\n    @route(\\\"/{id}\\\")\\r\\n    @get\\r\\n    getUser(@path id: string): User;\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n[http-verb-decorators]: ../../libraries/http/reference/decorators.md\\r\\n[http-route-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.route\\r\\n\\r\\nThe [OpenAPI Operation object][openapi-operation-object] fields are populated as described in the following sections.\\r\\n\\r\\n[openapi-operation-object]: https://github.com/OAI/OpenAPI-Specification/blob/3.0.3/versions/3.0.3.md#operationObject\\n\\n### Description\\n\\nThe operation's description comes from the documentation of the TypeSpec operation.\\r\\n\\r\\nDocumentation is provided either by a documentation comment or by the [(built-in) `@doc` decorator][doc-decorator] (the two are equivalent):\\r\\n\\r\\n```typespec\\r\\n/**\\r\\n * Retrieves a user by their unique identifier.\\r\\n */\\r\\nop getUser(@path id: string): User;\\r\\n\\r\\n@doc(\\\"Retrieves a user by their unique identifier.\\\")\\r\\nop getUser(@path id: string): User;\\r\\n```\\r\\n\\r\\nIf no documentation is provided, the description field is omitted.\\r\\n\\r\\n[doc-decorator]: ../../standard-library/built-in-decorators.md#@doc\\n\\n### Summary\\n\\nThe operation's summary comes from the [(built-in) `@summary` decorator][summary-decorator]:\\r\\n\\r\\n```typespec\\r\\n/**\\r\\n * Retrieves a user by their unique identifier.\\r\\n */\\r\\n@summary(\\\"Get a User by ID.\\\")\\r\\nop getUser(@path id: string): User;\\r\\n```\\r\\n\\r\\nIf no `@summary` is provided, the summary field is omitted.\\r\\n\\r\\n[summary-decorator]: ../../standard-library/built-in-decorators.md#@summary\\n\\n### Operation ID\\n\\nThe operation ID can be explicitly set using the [(OpenAPI) `@operationId` decorator][openapi-operation-decorator]:\\r\\n\\r\\n```typespec\\r\\n@operationId(\\\"getUserById\\\")\\r\\nop getUser(id: string): User;\\r\\n```\\r\\n\\r\\nIf not explicitly defined, the operation ID defaults to:\\r\\n\\r\\n- The operation name (when the operation is not in an interface)\\r\\n- The interface name followed by the operation name (when in an interface)\\r\\n\\r\\n[openapi-operation-decorator]: ../../libraries/openapi/reference/decorators.md#@TypeSpec.OpenAPI.operationId\\n\\n### Parameters and Request Body\\n\\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\\r\\n\\r\\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\\r\\n\\r\\n```typespec\\r\\n/**\\r\\n * Retrieves the User by their unique identifier.\\r\\n *\\r\\n * @param id The user's unique identifier.\\r\\n */\\r\\nop getUser(@path id: string): User;\\r\\n```\\r\\n\\r\\nThe content type for request bodies follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\\r\\n\\r\\nFor more advanced parameter configuration, see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\\n\\nTypeSpec operation parameters map to OpenAPI parameters and request body.\\r\\n\\r\\n#### Parameter Location\\r\\n\\r\\nYou specify where a parameter appears using these [(HTTP) decorators][http-parameter-decorators]:\\r\\n\\r\\n- `@query` - Query parameter in the URL\\r\\n- `@header` - HTTP header parameter\\r\\n- `@path` - Path parameter in the URL\\r\\n\\r\\nParameters without these decorators are assumed to be in the request body.\\r\\n\\r\\n```typespec\\r\\nop createUser(\\r\\n  // The parameter name is transformed to look like an HTTP header, so the parameter `contentType` maps\\r\\n  // to the `content-type` header\\r\\n  @header contentType: string,\\r\\n\\r\\n  @query include: string,\\r\\n  @path id: string,\\r\\n\\r\\n  // The request body will be a JSON object `{ \\\"user\\\": \\u003cUser\\u003e }`\\r\\n  user: User, // This goes in the request body\\r\\n): User;\\r\\n```\\r\\n\\r\\n#### Request Body\\r\\n\\r\\nYou can explicitly mark a parameter as the request body using the [(HTTP) `@body` decorator][http-body-decorator]:\\r\\n\\r\\n```typespec\\r\\n// The request body will be a JSON object that _only_ contains the User at the top level.\\r\\nop createUser(@body user: User): User;\\r\\n```\\r\\n\\r\\nIf `@body` is not used, all parameters not marked with `@header`, `@query`, or `@path` form the request body, which is marked as required. To make the request body optional, declare it with an optional property and the `@body` decorator:\\r\\n\\r\\n```typespec\\r\\nop updateUser(@path id: string, @body user?: User): User;\\r\\n```\\r\\n\\r\\n[http-parameter-decorators]: ../../libraries/http/reference/decorators.md\\r\\n[http-body-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.body\\r\\n\\r\\nParameter descriptions, like operation descriptions, come from the parameters' documentation and are included in the OpenAPI definition:\\r\\n\\r\\n```typespec\\r\\n/**\\r\\n * Retrieves the User by their unique identifier.\\r\\n *\\r\\n * @param id The user's unique identifier.\\r\\n */\\r\\nop getUser(@path id: string): User;\\r\\n```\\r\\n\\r\\nThe content type for request bodies follows the [default content-type resolution logic](../..\\n\\n### Responses\\n\\nstatus code is 200, the body will be just a JSON User at the top level.\\r\\n  @body user: User;\\r\\n}\\r\\n\\r\\nmodel NotFound {\\r\\n  @statusCode code: 404;\\r\\n\\r\\n  // If the status code is 404, the body will be a JSON object `{ \\\"message\\\": \\u003cstring\\u003e }`\\r\\n  message: string;\\r\\n}\\r\\n\\r\\nop getUser(@path id: string): UserResponse | NotFound;\\r\\n```\\r\\n\\r\\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\\r\\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\\r\\n\\r\\nThe content type for responses follows the [default content-type resolution logic](../../libraries/http/content-types.md#default-behavior) unless the `content-type` header is explicitly specified.\\r\\n\\r\\nFor more advanced response configuration, see see the complete documentation of [HTTP operation metadata](../../libraries/http/operations.md#metadata).\\n\\nThe operation's return type(s) translate into OpenAPI responses.\\r\\n\\r\\n#### Status Codes\\r\\n\\r\\nYou can specify a status code using the [(HTTP) `@statusCode` decorator][http-statuscode-decorator] on a property in the return type:\\r\\n\\r\\n```typespec\\r\\nmodel UserResponse {\\r\\n  @statusCode\\r\\n  code: 200;\\r\\n\\r\\n  body: User;\\r\\n}\\r\\n\\r\\nop getUser(@path id: string): UserResponse;\\r\\n```\\r\\n\\r\\nYou can define multiple response types to handle different status codes:\\r\\n\\r\\n```typespec\\r\\nmodel UserResponse {\\r\\n  @statusCode\\r\\n  code: 200;\\r\\n\\r\\n  user: User;\\r\\n}\\r\\n\\r\\nmodel UserNotFoundResponse {\\r\\n  @statusCode\\r\\n  code: 404;\\r\\n\\r\\n  message: string;\\r\\n}\\r\\n\\r\\nop getUser(@path id: string): UserResponse | UserNotFoundResponse;\\r\\n```\\r\\n\\r\\n#### Error Responses\\r\\n\\r\\nUse the [(built-in) `@error` decorator][error-decorator] to indicate an error response, which becomes the \\\"default\\\" response in OpenAPI. To indicate that an operation returns a successful response or an error, simply use the error response type in a union with a non-error type:\\r\\n\\r\\n```typespec\\r\\n@error\\r\\nmodel ErrorResponse {\\r\\n  @statusCode\\r\\n  code: 404 | 500;\\r\\n\\r\\n  message: string;\\r\\n}\\r\\n\\r\\nop getUser(@path id: string): User | ErrorResponse;\\r\\n```\\r\\n\\r\\n#### Response Body\\r\\n\\r\\nThe response body can be explicitly marked with the `@body` decorator. Otherwise, any properties not marked with `@statusCode` or `@header` form the response body.\\r\\n\\r\\n```typespec\\r\\nmodel UserResponse {\\r\\n  @statusCode code: 200;\\r\\n\\r\\n  // If the status code is 200, the body will be just a JSON User at the top level.\\r\\n  @body user: User;\\r\\n}\\r\\n\\r\\nmodel NotFound {\\r\\n  @statusCode code: 404;\\r\\n\\r\\n  // If the status code is 404, the body will be a JSON object `{ \\\"message\\\": \\u003cstring\\u003e }`\\r\\n  message: string;\\r\\n}\\r\\n\\r\\nop getUser(@path id: string): UserResponse | NotFound;\\r\\n```\\r\\n\\r\\n[http-statuscode-decorator]: ../../libraries/http/reference/decorators.md#@TypeSpec.Http.statusCode\\r\\n[error-decorator]: ../../standard-library/built-in-decorators.md#@error\\n\\n### Tags\\n\\nUse the [(built-in) `@tag` decorator][tag-decorator] to apply tag groups to operations that will be represented in the generated OpenAPI and OpenAPI-based documentation tools such as Swagger UI:\\r\\n\\r\\n```typespec\\r\\n@tag(\\\"Us\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#generate-client-libraries#08types.mdx\",\"document_title\":\"Generated Types\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/generate-client-libraries/08types\",\"content\":\"# howtos#generate-client-libraries#08types.mdx\\n\\n# Generated Types\\n\\nimport { ClientTabs, ClientTabItem } from \\\"@components/client-tabs\\\";\\r\\nThis page documents what type definitions in TypeSpec are generated as in emitted libraries\\n\\n## Namespace\\n\\nThe namespace for models, enums, and unions will follow the namespace they belong to. You can use `@clientNamespace` to override it if needed.\\n\\n### Model in namespace\\n\\n\\u003cClientTabs\\u003e\\r\\n\\u003cClientTabItem lang=\\\"typespec\\\" \\u003e\\r\\n```typespec\\r\\nnamespace Service;\\r\\n\\r\\nmodel Foo {\\r\\n  prop: string;\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"python\\\"\\u003e\\r\\n```python\\r\\nfrom service.models import Foo\\r\\n\\r\\nfoo = Foo(prop=\\\"hello\\\")\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"csharp\\\" \\u003e\\r\\n```csharp\\r\\n// TODO\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"typescript\\\" \\u003e\\r\\n```typescript\\r\\nexport interface Foo {\\r\\n  prop: string;\\r\\n}\\r\\n\\r\\nexport function fooSerializer(item: Foo): any {\\r\\n  return { prop: item[\\\"prop\\\"] };\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"java\\\" \\u003e\\r\\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\\r\\n```java\\r\\nimport service.models.Foo;\\r\\n\\r\\nFoo foo = new Foo(\\\"hello\\\");\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"go\\\" \\u003e\\r\\n```go\\r\\ntype Foo struct {\\r\\n  Prop string `json:\\\"prop\\\"`\\r\\n}\\r\\n\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003c/ClientTabs\\u003e\\n\\n### Model in sub namespace\\n\\n\\u003cClientTabs\\u003e\\r\\n\\u003cClientTabItem lang=\\\"typespec\\\" \\u003e\\r\\n```typespec\\r\\nnamespace Service;\\r\\n\\r\\nnamespace Container {\\r\\n  model Foo {\\r\\n    prop: string;\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"python\\\"\\u003e\\r\\n```python\\r\\nfrom service.container.models import Foo\\r\\n\\r\\nfoo = Foo(prop=\\\"hello\\\")\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"csharp\\\" \\u003e\\r\\n```csharp\\r\\n// TODO\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"typescript\\\" \\u003e\\r\\n```typescript\\r\\nexport interface Foo {\\r\\n  prop: string;\\r\\n}\\r\\n\\r\\nexport function fooSerializer(item: Foo): any {\\r\\n  return { prop: item[\\\"prop\\\"] };\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"java\\\" \\u003e\\r\\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\\r\\n```java\\r\\nimport service.container.models.Foo;\\r\\n\\r\\nFoo foo = new Foo(\\\"hello\\\");\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"go\\\" \\u003e\\r\\n```go\\r\\npackage container\\r\\n\\r\\ntype Foo struct {\\r\\n  Prop string `json:\\\"prop\\\"`\\r\\n}\\r\\n\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003c/ClientTabs\\u003e\\n\\n### Model in namespace with renaming\\n\\n\\u003cClientTabs\\u003e\\r\\n\\u003cClientTabItem lang=\\\"typespec\\\" \\u003e\\r\\n```typespec\\r\\nnamespace Service;\\r\\n\\r\\n@clientNamespace(\\\"Service.Container\\\")\\r\\nmodel Foo {\\r\\n  prop: string;\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"python\\\"\\u003e\\r\\n```python\\r\\nfrom service.container.models import Foo\\r\\n\\r\\nfoo = Foo(prop=\\\"hello\\\")\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"csharp\\\" \\u003e\\r\\n```csharp\\r\\n// TODO\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"typescript\\\" \\u003e\\r\\n```typescript\\r\\nexport interface Foo {\\r\\n  prop: string;\\r\\n}\\r\\n\\r\\nexport function fooSerializer(item: Foo): any {\\r\\n  return { prop: item[\\\"prop\\\"] };\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"java\\\" \\u003e\\r\\nAs `flavor=azure`, Java emitter generates the model classes under `models` package.\\r\\n```java\\r\\nimport service.container.models.Foo;\\r\\n\\r\\nFoo foo = new Foo(\\\"hello\\\");\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"go\\\" \\u003e\\r\\n```go\\r\\npackage container\\r\\n\\r\\ntype Foo struct {\\r\\n  Prop *string\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003c/ClientTabs\\u003e\\n\\n## Client Documentation\\n\\nposition in a 2D coordinate system\\r\\n */\\r\\nexport interface Point {\\r\\n  /**\\r\\n   * The horizontal position (increases moving right)\\r\\n   */\\r\\n  x: number;\\r\\n\\r\\n  /**\\r\\n   * The vertical position (increases moving down)\\r\\n   */\\r\\n  y: number;\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"java\\\" \\u003e\\r\\n```java\\r\\n/**\\r\\n * Base class for all shape objects that can be drawn on a canvas.\\r\\n */\\r\\n@Fluent\\r\\npublic final class Shape {\\r\\n    /**\\r\\n     * The x,y coordinates where the shape will be positioned on the canvas.\\r\\n     */\\r\\n    private Point position;\\r\\n\\r\\n    /**\\r\\n     * Get the position property: The x,y coordinates where the shape will be positioned on the canvas.\\r\\n     *\\r\\n     * @return the position value.\\r\\n     */\\r\\n    public Point getPosition() {\\r\\n        return this.position;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set the position property: The x,y coordinates where the shape will be positioned on the canvas.\\r\\n     *\\r\\n     * @param position the position value to set.\\r\\n     * @return the Shape object itself.\\r\\n     */\\r\\n    public Shape setPosition(Point position) {\\r\\n        this.position = position;\\r\\n        return this;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Represents a position in a 2D coordinate system.\\r\\n */\\r\\n@Fluent\\r\\npublic final class Point {\\r\\n    /**\\r\\n     * The horizontal position (increases moving right).\\r\\n     */\\r\\n    private float x;\\r\\n\\r\\n    /**\\r\\n     * The vertical position (increases moving down).\\r\\n     */\\r\\n    private float y;\\r\\n\\r\\n    /**\\r\\n     * Get the x property: The horizontal position (increases moving right).\\r\\n     *\\r\\n     * @return the x value.\\r\\n     */\\r\\n    public float getX() {\\r\\n        return this.x;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set the x property: The horizontal position (increases moving right).\\r\\n     *\\r\\n     * @param x the x value to set.\\r\\n     * @return the Point object itself.\\r\\n     */\\r\\n    public Point setX(float x) {\\r\\n        this.x = x;\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Get the y property: The vertical position (increases moving down).\\r\\n     *\\n\\n(increases moving right).\\r\\n     *\\r\\n     * @return the x value.\\r\\n     */\\r\\n    public float getX() {\\r\\n        return this.x;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set the x property: The horizontal position (increases moving right).\\r\\n     *\\r\\n     * @param x the x value to set.\\r\\n     * @return the Point object itself.\\r\\n     */\\r\\n    public Point setX(float x) {\\r\\n        this.x = x;\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Get the y property: The vertical position (increases moving down).\\r\\n     *\\r\\n     * @return the y value.\\r\\n     */\\r\\n    public float getY() {\\r\\n        return this.y;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Set the y property: The vertical position (increases moving down).\\r\\n     *\\r\\n     * @param y the y value to set.\\r\\n     * @return the Point object itself.\\r\\n     */\\r\\n    public Point setY(float y) {\\r\\n        this.y = y;\\r\\n        return this;\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"go\\\"\\u003e\\r\\n```go\\r\\n// Shape - Base class for all shape objects that can be drawn on a canvas\\r\\ntype Shape struct {\\r\\n\\t// Position - The x,y coordinates where the shape will be positioned on the canvas\\r\\n\\tPosition *Point\\r\\n}\\r\\n\\r\\n// Point - Represents a position in a 2D coordinate system\\r\\ntype Point struct {\\r\\n\\t// X - The horizontal position (increases moving right)\\r\\n\\tX *float32\\r\\n\\r\\n\\t// Y - The vertical position (increases moving down)\\r\\n\\tY *float32\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003c/ClientTabs\\u003e\\r\\nThe `@clientDoc` decorator can be used on everything that the `@doc` decorator can be applied to.\\r\\nWhen both `@doc` and `@clientDoc` are present, the generated code outputs the final documentation depending on the mode that you called `@clientDoc` with.\\r\\nIf called with `replace`, `@clientDoc` replaces `@doc` completely. If called with `append`, `@clientDoc` is appended onto `@doc`.\\n\\ny: float = rest_field()\\r\\n    \\\"\\\"\\\"The vertical position (increases moving down).\\\"\\\"\\\"\\r\\n\\r\\nclass Shape(_model_base.Model):\\r\\n    \\\"\\\"\\\"Base class for all shape objects that can be drawn on a canvas.\\r\\n\\r\\n    :param position: The x,y coordinates where the shape will be positioned on the canvas\\r\\n    :type position: Point\\r\\n    \\\"\\\"\\\"\\r\\n\\r\\n    position: Point = rest_field()\\r\\n    \\\"\\\"\\\"The x,y coordinates where the shape will be positioned on the canvas.\\\"\\\"\\\"\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"csharp\\\" \\u003e\\r\\n```csharp\\r\\n/// \\u003csummary\\u003e\\r\\n/// Base class for all shape objects that can be drawn on a canvas\\r\\n/// \\u003c/summary\\u003e\\r\\npublic partial class Shape\\r\\n{\\r\\n    /// \\u003csummary\\u003e\\r\\n    /// The x,y coordinates where the shape will be positioned on the canvas\\r\\n    /// \\u003c/summary\\u003e\\r\\n    public Point Position { get; set; }\\r\\n}\\r\\n\\r\\n/// \\u003csummary\\u003e\\r\\n/// Represents a position in a 2D coordinate system\\r\\n/// \\u003c/summary\\u003e\\r\\npublic partial class Point\\r\\n{\\r\\n    /// \\u003csummary\\u003e\\r\\n    /// The horizontal position (increases moving right)\\r\\n    /// \\u003c/summary\\u003e\\r\\n    public float X { get; set; }\\r\\n\\r\\n    /// \\u003csummary\\u003e\\r\\n    /// The vertical position (increases moving down)\\r\\n    /// \\u003c/summary\\u003e\\r\\n    public float Y { get; set; }\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"typescript\\\" \\u003e\\r\\n```typescript\\r\\n/**\\r\\n * Base class for all shape objects that can be drawn on a canvas\\r\\n */\\r\\nexport interface Shape {\\r\\n  /**\\r\\n   * The x,y coordinates where the shape will be positioned on the canvas\\r\\n   */\\r\\n  position: Point;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Represents a position in a 2D coordinate system\\r\\n */\\r\\nexport interface Point {\\r\\n  /**\\r\\n   * The horizontal position (increases moving right)\\r\\n   */\\r\\n  x: number;\\r\\n\\r\\n  /**\\r\\n   * The vertical position (increases moving down)\\r\\n   */\\r\\n  y: number;\\r\\n}\\r\\n```\\r\\n\\u003c/ClientTabItem\\u003e\\r\\n\\u003cClientTabItem lang=\\\"java\\\" \\u003e\\r\\n```java\\r\\n/**\\r\\n * Base class for all shape objects that can be drawn on a canvas.\\r\\n */\\r\\n@Fluent\\r\\npublic final class Shape {\\r\\n    /**\\r\\n     * The x,y coordinates where the shape will be positioned on the canvas.\\n\\nThe `@clientDoc` decorator lets you add documentation that will appear in generated client libraries. This is useful for providing additional context, examples, or implementation notes that are only relevant for SDK consumers.\\r\\n\\u003cClientTabs\\u003e\\r\\n\\u003cClientTabItem lang=\\\"typespec\\\" \\u003e\\r\\n```typespec\\r\\n@doc(\\\"This internal model is the base class for shapes\\\")\\r\\n@clientDoc(\\r\\n  \\\"Base class for all shape objects that can be drawn on a canvas\\\",\\r\\n  DocumentationMode.replace\\r\\n)\\r\\nmodel Shape {\\r\\n  @doc(\\\"The coordinates of the shape\\\")\\r\\n  @clientDoc(\\r\\n    \\\"The x,y coordinates where the shape will be positioned on the canvas\\\",\\r\\n    DocumentationMode.replace\\r\\n  )\\r\\n  position: Point;\\r\\n}\\r\\n\\r\\n@doc(\\\"A two-dimensional point\\\")\\r\\n@clientDoc(\\\"Represents a position in a 2D coordinate system\\\", DocumentationMode.replace)\\r\\nmodel Point {\\r\\n  @doc(\\\"X coordinate\\\")\\r\\n  @clientDoc(\\\"The horizontal position (increases moving right)\\\", DocumentationMode.replace)\\r\\n  x: float32;\\r\\n\\r\\n  @doc(\\\"Y coordinate\\\")\\r\\n  @clientDoc(\\\"The vertical position (incre\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#Guidelines.md\",\"document_title\":\"Microsoft Azure REST API Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md\",\"content\":\"# azure#Guidelines.md\\n\\n# Microsoft Azure REST API Guidelines\\n\\n\\u003c!-- cspell:ignore autorest, BYOS, etag, idempotency, maxpagesize, innererror, trippable, nextlink, condreq, etags --\\u003e\\r\\n\\u003c!-- markdownlint-disable MD033 MD049 MD055 --\\u003e\\r\\n\\r\\n\\u003c!--\\r\\nNote to contributors: All guidelines now have an anchor tag to allow cross-referencing from associated tooling.\\r\\nThe anchor tags within a section using a common prefix to ensure uniqueness with anchor tags in other sections.\\r\\nPlease ensure that you add an anchor tag to any new guidelines that you add and maintain the naming convention.\\r\\n--\\u003e\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2025-Mar-28 | Added guidelines about JSON ID and null values                 |\\r\\n| 2024-Mar-17 | Updated LRO guidelines                                         |\\r\\n| 2024-Jan-17 | Added guidelines on returning string offsets \\u0026 lengths         |\\r\\n| 2023-May-12 | Explain service response for missing/unsupported `api-version` |\\r\\n| 2023-Apr-21 | Update/clarify guidelines on POST method repeatability         |\\r\\n| 2023-Apr-07 | Update/clarify guidelines on polymorphism                      |\\r\\n| 2022-Sep-07 | Updated URL guidelines for DNS Done Right                      |\\r\\n| 2022-Jul-15 | Update guidance on long-running operations                     |\\r\\n| 2022-May-11 | Drop guidance on version discovery                             |\\r\\n| 2022-Mar-29 | Add guidelines about using durations                           |\\r\\n| 2022-Mar-25 | Update guideline for date values in headers to follow RFC 7231 |\\r\\n| 2022-Feb-01 | Updated error guidance                                         |\\r\\n| 2021-Sep-11 | Add long-running operations guidance                           |\\r\\n| 2021-Aug-06 | Updated Azure REST Guidelines per Azure API Stewardship Board. |\\r\\n| 2020-Jul-31 | Added service advice for initial versions                      |\\r\\n| 2020-Mar-31 | 1st public release of the Azure REST API Guidelines            |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Introduction\\n\\nThese guidelines apply to Azure service teams implementing _data plane_ APIs. They offer prescriptive guidance that Azure service teams MUST follow ensuring that customers have a great experience by designing APIs meeting these goals:\\r\\n- Developer friendly via consistent patterns \\u0026 web standards (HTTP, REST, JSON)\\r\\n- Efficient \\u0026 cost-effective\\r\\n- Work well with SDKs in many programming languages\\r\\n- Customers can create fault-tolerant apps by supporting retries/idempotency/optimistic concurrency\\r\\n- Sustainable \\u0026 versionable via clear API contracts with 2 requirements:\\r\\n  1. Customer workloads must never break due to a service change\\r\\n  2. Customers can adopt a version without requiring code changes\\r\\n\\r\\nTechnology and software is constantly changing and evolving, and as such, this is intended to be a living document. [Open an issue](https://github.com/microsoft/api-guidelines/issues/new/choose) to suggest a change or propose a new idea. Please read the [Considerations for Service Design](./ConsiderationsForServiceDesign.md) for an introduction to the topic of API design for Azure services. *For an existing GA'd service, don't change/break its existing API; instead, leverage these concepts for future APIs while prioritizing consistency within your existing service.*\\r\\n\\r\\n*Note: If you are creating a management plane (ARM) API, please refer to the [Azure Resource Manager Resource Provider Contract](https://github.com/cloud-and-ai-microsoft/resource-provider-contract).*\\n\\n### Prescriptive Guidance\\n\\nThis document offers prescriptive guidance labeled as follows:\\r\\n\\r\\n:white_check_mark: **DO** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n:ballot_box_with_check: **YOU SHOULD** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:heavy_check_mark: **YOU MAY** consider this pattern if appropriate to your situation. No notification to the Azure HTTP/REST Stewardship Board is required.\\r\\n\\r\\n:warning: **YOU SHOULD NOT** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:no_entry: **DO NOT** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n*If you feel you need an exception, or need clarity based on your situation, please contact the Azure HTTP/REST Stewardship Board **prior** to release of your API.*\\n\\n## Building Blocks: HTTP, REST, \\u0026 JSON\\n\\nThe Microsoft Azure Cloud platform exposes its APIs through the core building blocks of the Internet; namely HTTP, REST, and JSON. This section provides you with a general understanding of how these technologies should be applied when creating your service.\\r\\n\\r\\n\\u003ca href=\\\"#http\\\" name=\\\"http\\\"\\u003e\\u003c/a\\u003e\\n\\n### HTTP\\n\\ncase-sensitive, multiple delimiter\\r\\nUUID      | 123e4567-e89b-12d3-a456-426614174000 (no {}s, hyphens, case-insensitive) [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)\\r\\nDate/Time (Header) | Sun, 06 Nov 1994 08:49:37 GMT [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1)\\r\\nDate/Time (Query parameter) | YYYY-MM-DDTHH:mm:ss.sssZ (with at most 3 digits of fractional seconds) [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)\\r\\nByte array | Base-64 encoded, max length\\r\\nArray      | One of a) a comma-separated list of values (preferred), or b) separate `name=value` parameter instances for each value of the array\\r\\n\\r\\n\\r\\nThe table below lists the headers most used by Azure services:\\r\\n\\r\\nHeader Key          | Applies to | Example\\r\\n------------------- | ---------- | -------------\\r\\n_authorization_     | Request    | Bearer eyJ0...Xd6j (Support Azure Active Directory)\\r\\n_x-ms-useragent_    | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntraceparent         | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntracecontext        | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\naccept              | Request    | application/json\\r\\nIf-Match            | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-None-Match       | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-Modified-Since   | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\nIf-Unmodified-Since | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\ndate                | Both       | Sun, 06 Nov 1994 08:49:37 GMT (see [RFC 7231, Section 7.1.1.2](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2))\\r\\n_content-type_      | Both       | application/merge-patch+json\\n\\nname=\\\"http-header-names-casing\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** specify headers using kebab-casing\\r\\n\\r\\n\\u003ca href=\\\"#http-header-names-case-sensitivity\\\" name=\\\"http-header-names-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header names using case-insensitivity\\r\\n\\r\\n\\u003ca href=\\\"#http-header-values-case-sensitivity\\\" name=\\\"http-header-values-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header values using case-sensitivity if the header name requires it\\r\\n\\r\\n\\u003ca href=\\\"#http-header-date-values\\\" name=\\\"http-header-date-values\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** accept date values in headers in HTTP-Date format and return date values in headers in the IMF-fixdate format as defined in [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1), e.g. \\\"Sun, 06 Nov 1994 08:49:37 GMT\\\".\\r\\n\\r\\nNote: The RFC 7231 IMF-fixdate format is a \\\"fixed-length and single-zone subset\\\" of the RFC 1123 / RFC 5822 format, which means: a) year must be four digits, b) the seconds component of time is required, and c) the timezone must be GMT.\\r\\n\\r\\n\\u003ca href=\\\"#http-header-request-id\\\" name=\\\"http-header-request-id\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** create an opaque value that uniquely identifies the request and return this value in the `x-ms-request-id` response header.\\r\\n\\r\\nYour service should include the `x-ms-request-id` value in error logs so that users can submit support requests for specific failures using this value.\\r\\n\\r\\n\\u003ca href=\\\"#http-allow-unrecognized-headers\\\" name=\\\"http-allow-unrecognized-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** fail a request that contains an unrecognized header. Headers may be added by API gateways or middleware and this must be tolerated\\r\\n\\r\\n\\u003ca href=\\\"#http-no-x-custom-headers\\\" name=\\\"http-no-x-custom-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** use \\\"x-\\\" prefix for custom headers, unless the header already exists in production [[RFC 6648](https://datatracker.ietf.org/doc/html/rfc6648)].\\r\\n\\r\\n**Additional References**\\n\\nAzure services must adhere to the HTTP specification, [RFC 7231](https://tools.ietf.org/html/rfc7231). This section further refines and constrains how service implementors should apply the constructs defined in the HTTP specification. It is therefore, important that you have a firm understanding of the following concepts:\\r\\n\\r\\n- [Uniform Resource Locators (URLs)](#uniform-resource-locators-urls)\\r\\n- [HTTP Request / Response Pattern](#http-request--response-pattern)\\r\\n- [HTTP Query Parameters and Header Values](#http-query-parameters-and-header-values)\\r\\n\\r\\n#### Uniform Resource Locators (URLs)\\r\\n\\r\\nA Uniform Resource Locator (URL) is how developers access the resources of your service. Ultimately, URLs are how developers form a cognitive model of your service's resources.\\r\\n\\r\\n\\u003ca href=\\\"#http-url-pattern\\\" name=\\\"http-url-pattern\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** use this URL pattern:\\r\\n```text\\r\\nhttps://\\u003ctenant\\u003e.\\u003cregion\\u003e.\\u003cservice\\u003e.\\u003ccloud\\u003e/\\u003cservice-root\\u003e/\\u003cresource-collection\\u003e/\\u003cresou\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"language-basics#type-relations.md\",\"document_title\":\"Type Relations\",\"document_link\":\"https://typespec.io/docs/language-basics/type-relations\",\"content\":\"# language-basics#type-relations.md\\n\\n# Type Relations\\n\\n## Type hierarchy\\n\\n```mermaid\\r\\ngraph RL\\r\\n    record[\\\"Record\\u003cElement\\u003e\\\"] --\\u003e unknown\\r\\n    customModel[\\\"Custom model with properties\\\"] --\\u003e record[\\\"Record\\u003cT\\u003e\\\"]\\r\\n    array[\\\"Array\\u003cElement\\u003e\\\"] --\\u003e unknown\\r\\n    tuple[\\\"Tuple\\\"] --\\u003e array\\r\\n    numeric --\\u003e unknown\\r\\n    subgraph numerics[For numeric types, a narrower type can be assigned to a wider one]\\r\\n      integer --\\u003e numeric\\r\\n        int8 --\\u003e integer\\r\\n        int16 --\\u003e integer\\r\\n        int32 --\\u003e integer\\r\\n        safeint --\\u003e integer\\r\\n        int64 --\\u003e integer\\r\\n        uint8 --\\u003e integer\\r\\n        uint16 --\\u003e integer\\r\\n        uint32 --\\u003e integer\\r\\n        uint64 --\\u003e integer\\r\\n      float --\\u003e numeric\\r\\n        float32 --\\u003e float\\r\\n        float64 --\\u003e  float\\r\\n      decimal --\\u003e numeric\\r\\n        decimal128 --\\u003e decimal\\r\\n    end\\r\\n    string --\\u003e unknown\\r\\n    boolean --\\u003e unknown\\r\\n    null --\\u003e unknown\\r\\n    bytes --\\u003e unknown\\r\\n    plainDate --\\u003e unknown\\r\\n    plainTime --\\u003e unknown\\r\\n    zoneDateTime --\\u003e unknown\\r\\n    duration --\\u003e unknown\\r\\n```\\n\\n## Model with properties\\n\\nWhen determining if type `S` can be assigned to type `T`, if `T` is a model with properties, it checks whether all those properties are present in `S` and if their types can be assigned to the type of the corresponding property in `T`.\\r\\n\\r\\nFor instance,\\r\\n\\r\\n```typespec\\r\\nmodel T {\\r\\n  foo: string;\\r\\n  bar: int32;\\r\\n}\\r\\n\\r\\n// Valid\\r\\n\\r\\nmodel S { // When properties types are the exact same\\r\\n  foo: string;\\r\\n  bar: int32;\\r\\n}\\r\\nmodel S { // When the properties types are literal assignable to the target type\\r\\n  foo: \\\"abc\\\";\\r\\n  bar: 123;\\r\\n}\\r\\nmodel S {\\r\\n  foo: string;\\r\\n  bar: int8; // int8 is assignable to int16\\r\\n}\\r\\nmodel S {\\r\\n  foo: string;\\r\\n  bar: int32;\\r\\n  otherProp: boolean; // Additional properties are valid.\\r\\n}\\r\\n\\r\\n// Invalid\\r\\nmodel S { // Missing property bar\\r\\n  foo: string;\\r\\n}\\r\\nmodel S {\\r\\n  foo: string;\\r\\n  bar: int64; // int64 is NOT assignable to int32\\r\\n}\\r\\n```\\n\\n## `Record\\u003cT\\u003e`\\n\\nA record is a model indexed with a string with a value of T. It represents a model where all properties (string keys) are assignable to the type T. You can assign a model expression where all the properties are of type T or another model that `is` also a `Record\\u003cT\\u003e`.\\r\\n\\r\\n```typespec\\r\\n// Represent an object where all the values are int32.\\r\\nalias T = Record\\u003cint32\\u003e;\\r\\n\\r\\n// Valid\\r\\nalias S = {\\r\\n  foo: 123;\\r\\n  bar: 345;\\r\\n};\\r\\nalias S = {\\r\\n  foo: int8;\\r\\n  bar: int32;\\r\\n};\\r\\nmodel S is Record\\u003cint32\\u003e;\\r\\nmodel S is Record\\u003cint32\\u003e {\\r\\n  foo: 123;\\r\\n}\\r\\n\\r\\n// Invalid\\r\\nalias S = {\\r\\n  foo: \\\"abc\\\";\\r\\n  bar: 456;\\r\\n};\\r\\nalias S = {\\r\\n  foo: int64;\\r\\n  bar: int32;\\r\\n};\\r\\nmodel S {\\r\\n  foo: 123;\\r\\n  bar: 456;\\r\\n}\\r\\n```\\r\\n\\r\\n#### Why isn't the last case assignable to `Record\\u003cint32\\u003e`?\\r\\n\\r\\nIn this scenario,\\r\\n\\r\\n```typespec\\r\\nalias T = Record\\u003cint32\\u003e;\\r\\nmodel S {\\r\\n  foo: 123;\\r\\n  bar: 456;\\r\\n}\\r\\n```\\r\\n\\r\\nThe reason why `model S` is not assignable, but the model expression `{ foo: 123; bar: 456; }` is, is because model S could be extended with additional properties that might not be compatible.\\r\\n\\r\\nFor instance, if you add a new model,\\r\\n\\r\\n```typespec\\r\\nmodel Foo is S {\\r\\n  otherProp: string;\\r\\n}\\r\\n```\\r\\n\\r\\nHere, `Foo` is assignable to `S` following the [model with property logic](#model-with-properties), and if `S` was assignable to `Record\\u003cint32\\u003e`, `Foo` would also be passable. However, this is now invalid as `otherProp` is not an `int32` property.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"Azure REST API, SDK development process with TypeSpec\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure-REST-API,-SDK-development-process-with-TypeSpec.md\\n\\n# Azure REST API, SDK development process with TypeSpec\\n\\n## Table Of Content\\n\\n1. Introduction\\r\\n2. Repo setup \\u0026 prerequisites\\r\\n3. Creating a new TypeSpec project\\r\\n4. Prepare and submit a Pull Request for reviewing\\r\\n5. Generate SDK code from a TypeSpec project\\n\\n### 1. Introduction\\n\\nThis document describes the processes of developing Azure REST APIs and SDKs with TypeSpec language. The steps below\\r\\n assumes that you are developing TypeSpec API specifications in the `azure-rest-api-specs` and `azure-rest-api-specs-pr`repos.\\r\\nIf you are developing within your own ADO repo first and then submitting into `azure-rest-api-specs` repos for review and\\r\\n release, you will need to copy the TypeSpec files over.\\n\\n### 2. Repo setup \\u0026 prerequisites\\n\\n- The main repos for Azure REST APIs are [azure-rest-api-specs](https://github.com/azure/azure-rest-api-specs) and [azure-rest-api-specs-pr](https://github.com/azure/azure-rest-api-specs-pr)\\r\\n repos. The `-pr` repo contains `RPSaaSMaster` and `RPSaaSDev` branches for ProviderHub based ARM service specs.\\r\\n#### 2.1 With local machine development\\r\\n- [Node.js LTS](https://nodejs.org/en) version 18 or above (LTS Recommended).\\r\\n Ensure you can run the npm command in a command prompt:\\r\\n  ```npm\\r\\n    npm --version\\r\\n  ```\\r\\n- Run following command in the **repository root folder**. This will install required packages such as TypeSpec\\r\\n compilers and Azure Library packages.\\r\\n  ```npm\\r\\n     npm ci\\r\\n  ```\\r\\n- Ensure you can run TypeSpec command within the repo folders.\\r\\n  ```npm\\r\\n     npx tsp --version\\r\\n  ```\\r\\n- One-time set up: Install TypeSpec VisualStudio or VS Code extensions to get syntex highlighting, tool tips in IDE:  \\r\\n  ```npm\\r\\n    npx tsp code install\\r\\n  ```\\r\\n  OR\\r\\n    ```npm\\r\\n      npx tsp vs install\\r\\n    ```\\r\\n#### 2.2  VS Code with local docker .devcontainer\\r\\nAll prerequisites have been installed in the dev container. You should to have `Docker Desktop` and `WSL2` running if\\r\\n you are on Windows machine.\\r\\nTo start, you just need to install `Dev Containers` VS code extension, then open the repo path.\\r\\n- VS Code will detect the .devcontainer and prompt you to reopen the workspace.\\r\\n- Alternatively, you can use Command Palette -\\u003e Dev Containers: Reopen in Container.  \\r\\nOnce VS Code reopened in Container, you can run any of the program below in the VS Code integrated terminal.\\r\\n#### 2.2 VS Code in browser via GitHub codespaces\\r\\nGitHub codespaces leverage the same dev container in the repo. The difference is it is hosted in cloud with VS Code in\\r\\n browser.\\r\\nTo start, you just need to browse to the `azure-rest-api-specs` repo, select `\\u003c\\u003e Code` drop down and follow `Codespaces`\\r\\n instructions.\\n\\n### 3. Creating a new TypeSpec project\\n\\nPlease first review recommended folder structure detailed in [this document](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/directory-structure.md).\\r\\n1. Under `[reporoot]\\\\specification`, create service folder directly.\\r\\n   - Select `(rest-api-spec repo) ARM` or `(rest-api-spec repo) Data-plane` and answer appropriate naming questions.\\r\\n   - If it's ARM service, the service folder would be `specification/{organization}/resource-manager/\\u003cRPNS\\u003e/{service}`.\\r\\n   - If it's Data Plane service, the service folder would be `specification/{organization}/data-plane/{service}`\\r\\n2. Create a new TypeSpec project based on Azure template with command:\\r\\n    ```cli\\r\\n       npx tsp init https://aka.ms/typespec/azure-init\\r\\n    ```\\r\\n3. Compile the generated TypeSpec project with command:\\r\\n    ```cli\\r\\n      npx tsp compile .\\r\\n    ```\\r\\n    The generated OpenAPI files should be correctly placed in the `{service}`folders following the naming conventions.\\r\\n4. Now the project has been set up. You can modify the sample and develop your own APIs with TypeSpec.\\n\\n### 4. Prepare and submit a Pull Request for reviewing\\n\\n1. Create a branch in your local repository for your changes.\\r\\n2. Create or update the TypeSpec files for your service.\\r\\n3. Add or update 'examples' files for each operation of your OpenAPI file.\\r\\n   The [oav](https://github.com/Azure/oav) provides two ways to generate OpenAPI examples:\\r\\n   1. Generating basic examples and then manually modify the values. It will generate two examples for each operation:\\r\\n    one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated\\r\\n     examples consist of random values for most types, you need replace them with meaningful values.\\r\\n       ```bash\\r\\n       oav generate-examples openapi.json\\r\\n       ```\\r\\n    Note, latest OAV tool should automatically generate the following. However, if you are generating the examples manually,\\r\\n     please ensure you have:\\r\\n    - include `title` field and make sure it is descriptive and unique for each operation.\\r\\n    - include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in OpenAPI.\\r\\n4. Add/update the `readme.md` file in the `{service}` folder to specify the version and location of the OpenAPI files. The `readme.md` is needed for both management-plane and data-plane services for REST API Docs generation.\\r\\n   Example:[sample-readme](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/readme.md)\\r\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\n\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\r\\n   - send a pull request to the original repo from your forked repo.\\r\\n   See the ARM Wiki for information on the [supported repos and branches for management-plane services](https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches).\\r\\n#### 4.1 Fix the errors of PR reviewing CI checks\\r\\nThe CI checks result will be commented on the PR. you can refer to the [CI fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\\r\\nNote:\\r\\nSince the OpenAPI is generated from TypeSpec, to change the OpenAPI, you must update the TypeSpec file and regenerate the\\r\\n OpenAPI and avoid updating OpenAPI directly to keep the consistency between OpenAPI and TypeSpec.\\r\\nFor support \\u0026 help, you can post a message to [TypeSpec Discussion - teams channel](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\\n\\n### 5. Generate SDK code from a TypeSpec project\\n\\nRefer to [Develop client libraries](https://eng.ms/docs/products/azure-developer-experience/develop/sdk-develop?tabs=management) for more details.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_17.md\",\"document_title\":\"Many Swagger ModelValidation Error:　XMS_EXAMPLE_NOTFOUND_ERROR\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_17.md\\n\\n# Many Swagger ModelValidation Error:　XMS_EXAMPLE_NOTFOUND_ERROR\\n\\n## question\\n\\nThis is my [PR](https://github.com/Azure/azure-rest-api-specs/pull/36687). And I got so many Swagger ModelValidation errors : XMS_EXAMPLE_NOTFOUND_ERROR ,  please check the [link](https://github.com/Azure/azure-rest-api-specs/actions/runs/18519995562/job/52777696829?pr=36687).\\r\\n```\\r\\nError reported:\\r\\n\\r\\n{\\r\\n  code: 'XMS_EXAMPLE_NOTFOUND_ERROR',\\r\\n  message: 'x-ms-example not found in Provider_GetAvailableStacks.',\\r\\n  schemaUrl: 'specification/web/resource-manager/Microsoft.Web/AppService/stable/2025-03-01/openapi.json',\\r\\n  exampleUrl: undefined,\\r\\n  schemaPosition: { line: 456, column: 14 },\\r\\n  schemaJsonPath: undefined,\\r\\n  examplePosition: undefined,\\r\\n  exampleJsonPath: undefined,\\r\\n  severity: 0,\\r\\n  source: 'global',\\r\\n  operationId: 'Provider_GetAvailableStacks',\\r\\n  level: '\\\\x1B[31merror\\\\x1B[39m'\\r\\n}\\r\\n...\\r\\n``` \\r\\nActually, there is not any related example in the operation in the origin swagger.  \\r\\nI could find the latest merged [PR](https://github.com/Azure/azure-rest-api-specs/pull/37883)  and it does not have the same problem. \\r\\nThanks for your support.\\n\\n## answer\\n\\nThe errors are indicating that your operations are missing examples. ModelValidation requires an example for each operation, so the next steps are either to add examples or apply a suppression. Since ModelValidation has bugs in suppressions, you can unblock the PR by using the label Approved-ModelValidation, or alternatively, generate the missing examples.\"},{\"document_source\":\"static_typespec_to_swagger_mapping\",\"document_filename\":\"TypeSpec-ARM-Models-Documentation.md\",\"document_title\":\"TypeSpec ARM Model Mapping to Swagger Documentation\",\"document_link\":\"\",\"content\":\"# TypeSpec-ARM-Models-Documentation.md\\n\\n# TypeSpec ARM Model Mapping to Swagger Documentation\\n\\n## 37. ProxyResource\\n\\n### Description\\n\\nConcrete proxy resource types can be created by aliasing this type using a specific property type. See more details on [different Azure Resource Manager resource type here.](https://azure.github.io/typespec-azure/docs/howtos/ARM/resource-type)\\n\\n### TypeSpec Example\\n\\ndata\\\",\\r\\n          \\\"additionalProperties\\\": {\\r\\n            \\\"type\\\": \\\"string\\\"\\r\\n          }\\r\\n        },\\r\\n        \\\"configurationType\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"Configuration type\\\",\\r\\n          \\\"enum\\\": [\\r\\n            \\\"Basic\\\",\\r\\n            \\\"Advanced\\\",\\r\\n            \\\"Custom\\\"\\r\\n          ],\\r\\n          \\\"x-ms-enum\\\": {\\r\\n            \\\"modelAsString\\\": false\\r\\n          }\\r\\n        },\\r\\n        \\\"lastModified\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"format\\\": \\\"date-time\\\",\\r\\n          \\\"description\\\": \\\"Last modified timestamp\\\"\\r\\n        },\\r\\n        \\\"provisioningState\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"Provisioning state\\\",\\r\\n          \\\"enum\\\": [\\r\\n            \\\"Succeeded\\\",\\r\\n            \\\"Failed\\\",\\r\\n            \\\"Canceled\\\",\\r\\n            \\\"InProgress\\\"\\r\\n          ],\\r\\n          \\\"x-ms-enum\\\": {\\r\\n            \\\"modelAsString\\\": false\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\n\\n```typescript\\r\\n/** Configuration resource demonstrating ProxyResource */\\r\\nmodel Configuration is ProxyResource\\u003cConfigurationProperties\\u003e {\\r\\n  /** The configuration name */\\r\\n  @pattern(\\\"^[a-zA-Z0-9-_]+$\\\")\\r\\n  @key(\\\"configName\\\")\\r\\n  @path\\r\\n  @segment(\\\"configurations\\\")\\r\\n  name: string;\\r\\n}\\r\\n\\r\\n/** Properties for configuration */\\r\\nmodel ConfigurationProperties {\\r\\n  /** Configuration data */\\r\\n  configData?: Record\\u003cstring\\u003e;\\r\\n  \\r\\n  /** Configuration type */\\r\\n  configurationType?: \\\"Basic\\\" | \\\"Advanced\\\" | \\\"Custom\\\";\\r\\n  \\r\\n  /** Last modified timestamp */\\r\\n  lastModified?: utcDateTime;\\r\\n\\r\\n  /** Provisioning state */\\r\\n  provisioningState?: \\\"Succeeded\\\" | \\\"Failed\\\" | \\\"Canceled\\\" | \\\"InProgress\\\";\\r\\n}\\r\\n```\\r\\n**Swagger Output:**\\r\\n```json\\r\\n{\\r\\n  \\\"definitions\\\": {\\r\\n    \\\"Configuration\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"Configuration resource demonstrating ProxyResource\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"properties\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/ConfigurationProperties\\\",\\r\\n          \\\"description\\\": \\\"The resource-specific properties for this resource.\\\"\\r\\n        }\\r\\n      },\\r\\n      \\\"allOf\\\": [\\r\\n        {\\r\\n          \\\"$ref\\\": \\\"../../../../../../../../../common-types/resource-management/v3/types.json#/definitions/ProxyResource\\\"\\r\\n        }\\r\\n      ]\\r\\n    },\\r\\n    \\\"ConfigurationProperties\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"Properties for configuration\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"configData\\\": {\\r\\n          \\\"type\\\": \\\"object\\\",\\r\\n          \\\"description\\\": \\\"Configuration data\\\",\\r\\n          \\\"additionalProperties\\\": {\\r\\n            \\\"type\\\": \\\"string\\\"\\r\\n          }\\r\\n        },\\r\\n        \\\"configurationType\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"Configuration type\\\",\\r\\n          \\\"enum\\\": [\\r\\n            \\\"Basic\\\",\\r\\n            \\\"Advanced\\\",\\r\\n            \\\"Custom\\\"\\r\\n          ],\\r\\n          \\\"x-ms-enum\\\": {\\r\\n            \\\"modelAsString\\\": false\\r\\n          }\\r\\n        },\\r\\n        \\\"lastModified\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"format\\\": \\\"date-time\\\",\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_17.md\",\"document_title\":\"having trouble with examples not matching @pattern rules in github actions\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_17.md\\n\\n# having trouble with examples not matching @pattern rules in github actions\\n\\n## question\\n\\nI think I'm doing something wrong when I generate my examples... what should i be doing?\\r\\n \\r\\nfor example this tsp:\\r\\n```\\r\\nmodel AcStorConfiguration is ExtensionResource\\u003cAcStorConfigurationProperties\\u003e {\\r\\n  ...ResourceNameParameter\\u003c\\r\\n    AcStorConfiguration,\\r\\n    NamePattern = \\\"^acstor-configuration$\\\"\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\nthen:\\r\\n```\\r\\noav generate-examples ./specification/arccontainerstorage/resource-manager/Microsoft.ArcContainerStorage/preview/2024-10-01-preview/arccontainerstorage.json\\r\\n```\\r\\nand i run \\r\\n```\\r\\nnpx prettier --write specification/arccontainerstorage/resource-manager/Microsoft.ArcContainerStorage/preview/2024-10-01-preview/examples/*  \\r\\n npx tsv specification/arccontainerstorage/ArcContainerStorage.Management    \\r\\n```\\r\\nexample github action failure:https://github.com/Azure/azure-rest-api-specs-pr/pull/23604/checks?check_run_id=46129519720\\n\\n## answer\\n\\nI think you need to manually update the auto-generated strings to satisfy the regexes. \\r\\n \\r\\nmost of the errors, the example itself tells you to update the string:\\r\\n \\r\\n```\\r\\nGitHub Actions / [TEST-IGNORE] Swagger ModelValidation\\r\\n\\r\\nPATTERN: String does not match pattern ^acstor-configuration$: Replace this value with a string matching RegExp ^acstor-configuration$\\r\\n```\\r\\nThis one is a little unusual, but I think just update the string to something that works, unless your spec is doing something unusual with this id property.\\r\\n```\\r\\nGitHub Actions / [TEST-IGNORE] Swagger ModelValidation\\r\\n\\r\\nINVALID_FORMAT: Object didn't pass validation for format arm-id: gkbwmag\\r\\n```\\r\\nExamples generation was written to produce a structure that you can update, but there is more work necessary to fully generate the placholders. It's just not been prioritized work unfortunately.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Typespec Validation issue\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Typespec Validation issue\\n\\n## question\\n\\nI've a PR where the Typespec validation is failing with some weird error. This is not being reproduced locally - \\r\\n```\\r\\n  specification/storagedatamanagementrp/Private.StorageDataManagement.Management/main.tsp:17:10 - error expect-value: Is a model expression type, but is being used as a value here. Use #{} to create an object value.\\r\\n53  \\u003e 17 | @service({\\r\\n54       |          ^\\r\\n55  \\u003e 18 |   title: \\\"Storage Data Management Resource Provider\\\",\\r\\n56       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n57  \\u003e 19 | })\\r\\n58       | ^^\\r\\n```\\r\\n```\\r\\nspecification/storagedatamanagementrp/Private.StorageDataManagement.Management/Connectors/connectorModels.tsp:19:15 - error invalid-argument: Argument of type '\\\"read\\\"' is not assignable to parameter of type 'valueof EnumMember'\\r\\n60  \\u003e 19 |   @visibility(\\\"read\\\")\\r\\n61       |               ^^^^^^\\r\\n```\\r\\nI'm not sure how to resolve this error. Could someone please help here?\\r\\n[Update Connector and DataShare Swagger by ujjawaljain-msft · Pull Request #21997 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/21997)\\n\\n## answer\\n\\nYou may need to update to the latest typespec version - some of these particular properties have changed in a recent version. What you are using here isn't the latest style to specify these things.\\r\\nDoc for future reference: https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally :\\r\\n```\\r\\nRunning Locally\\r\\nTo ensure you see the same results from TypeSpecValidation in your PR check and tsv on your local machine:\\r\\nMerge latest from parent (e.g. main or RPSaaSMaster) to your PR branch\\r\\nRun locally\\r\\ngit clean -xdf (may revert any local changes)\\r\\ngit pull\\r\\nnpm ci\\r\\nnpx tsv specification/contosowidgetmanager/Contoso.Management\\r\\ngit status\\r\\nIf any changes, git add, git commit, git push to update your PR.\\r\\nIf you are still having problems, try cloning your branch to a new folder, or try on another machine.\\r\\nIf the problem can be reproduced on a clean machine, request assistance from the TypeSpec Discussion teams channel.\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_17.md\",\"document_title\":\"Many Swagger ModelValidation Error:　XMS_EXAMPLE_NOTFOUND_ERROR\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_17.md\\n\\n# Many Swagger ModelValidation Error:　XMS_EXAMPLE_NOTFOUND_ERROR\\n\\n## question\\n\\nThis is my [PR](https://github.com/Azure/azure-rest-api-specs/pull/36687). And I got so many Swagger ModelValidation errors : XMS_EXAMPLE_NOTFOUND_ERROR ,  please check the [link](https://github.com/Azure/azure-rest-api-specs/actions/runs/18519995562/job/52777696829?pr=36687).\\r\\n```\\r\\nError reported:\\r\\n\\r\\n{\\r\\n  code: 'XMS_EXAMPLE_NOTFOUND_ERROR',\\r\\n  message: 'x-ms-example not found in Provider_GetAvailableStacks.',\\r\\n  schemaUrl: 'specification/web/resource-manager/Microsoft.Web/AppService/stable/2025-03-01/openapi.json',\\r\\n  exampleUrl: undefined,\\r\\n  schemaPosition: { line: 456, column: 14 },\\r\\n  schemaJsonPath: undefined,\\r\\n  examplePosition: undefined,\\r\\n  exampleJsonPath: undefined,\\r\\n  severity: 0,\\r\\n  source: 'global',\\r\\n  operationId: 'Provider_GetAvailableStacks',\\r\\n  level: '\\\\x1B[31merror\\\\x1B[39m'\\r\\n}\\r\\n...\\r\\n``` \\r\\nActually, there is not any related example in the operation in the origin swagger.  \\r\\nI could find the latest merged [PR](https://github.com/Azure/azure-rest-api-specs/pull/37883)  and it does not have the same problem. \\r\\nThanks for your support.\\n\\n## answer\\n\\nThe errors are indicating that your operations are missing examples. ModelValidation requires an example for each operation, so the next steps are either to add examples or apply a suppression. Since ModelValidation has bugs in suppressions, you can unblock the PR by using the label Approved-ModelValidation, or alternatively, generate the missing examples.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_03.md\",\"document_title\":\"AdditionalProperties added to swagger for Record\\u003cunknown\\u003e property\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_03.md\\n\\n# AdditionalProperties added to swagger for Record\\u003cunknown\\u003e property\\n\\n## question\\n\\nHi, I am trying to convert existing APIs (released to customers) to be generated from TypeSpec. The initial Swagger contained Record\\u003cunknown\\u003e, and I would like to keep the API spec the same as before. The new generated Swagger now contains an empty additionalProperties property. How can I avoid adding this additionalProperties in the Swagger?\\r\\n \\r\\nHere is the generated swagger:\\r\\n```\\r\\n    \\\"ArmTemplateInfo\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"Information about a generated ARM template.\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"template\\\": {\\r\\n          \\\"type\\\": \\\"object\\\",\\r\\n          \\\"description\\\": \\\"The template's contents.\\\",\\r\\n          \\\"additionalProperties\\\": {}\\r\\n        },\\r\\n        \\\"parameters\\\": {\\r\\n          \\\"type\\\": \\\"object\\\",\\r\\n          \\\"description\\\": \\\"The parameters of the ARM template.\\\",\\r\\n          \\\"additionalProperties\\\": {}\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n```\\r\\n Here is how the original swagger looked:\\r\\n```\\r\\n    \\\"ArmTemplateInfo\\\": {\\r\\n      \\\"description\\\": \\\"Information about a generated ARM template.\\\",\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"template\\\": {\\r\\n          \\\"description\\\": \\\"The template's contents.\\\",\\r\\n          \\\"type\\\": \\\"object\\\"\\r\\n        },\\r\\n        \\\"parameters\\\": {\\r\\n          \\\"description\\\": \\\"The parameters of the ARM template.\\\",\\r\\n          \\\"type\\\": \\\"object\\\"\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n```\\r\\nHere is the model:\\r\\n```\\r\\nmodel ArmTemplateInfo {\\r\\n  /**\\r\\n   * The template's contents.\\r\\n   */\\r\\n  #suppress \\\"@azure-tools/typespec-azure-resource-manager/arm-no-record\\\" \\\"For backward compatibility\\\"\\r\\n  template?: Record\\u003cunknown\\u003e;\\r\\n\\r\\n  /**\\r\\n   * The parameters of the ARM template.\\r\\n   */\\r\\n  #suppress \\\"@azure-tools/typespec-azure-resource-manager/arm-no-record\\\" \\\"For backward compatibility\\\"\\r\\n  parameters?: Record\\u003cunknown\\u003e;\\r\\n}\\r\\n```\\r\\nPR link: https://github.com/Azure/azure-rest-api-specs/pull/35346\\n\\n## answer\\n\\nthis is an accurate equivalent, do not try to make the swagger match exactly here\\r\\n \\r\\nthat property should either be `Record\\u003cunknown` or `unknown` depending on what was the target. Either way it won't produce the exact same swagger\"},{\"document_source\":\"static_typespec_to_swagger_mapping\",\"document_filename\":\"TypeSpec-ARM-Interfaces-Documentation.md\",\"document_title\":\"TypeSpec ARM Interface Mapping to Swagger Documentation\",\"document_link\":\"\",\"content\":\"# TypeSpec-ARM-Interfaces-Documentation.md\\n\\n# TypeSpec ARM Interface Mapping to Swagger Documentation\\n\\n## 4. Operations\\n\\n### Description\\n\\nThis is the interface that implements the standard Azure Resource Manager operation that returns all supported RP operations. You should have exactly one declaration for each Azure Resource Manager service. It implements GET \\\"/providers/Microsoft.ContosoProviderHub/operations\\\"\\n\\n### TypeSpec Example\\n\\n```typescript\\r\\nop Azure.ResourceManager.Operations.list(apiVersion: string, provider: \\\"Microsoft.ThisWillBeReplaced\\\"): Azure.ResourceManager.ArmResponse\\u003cAzure.ResourceManager.CommonTypes.OperationListResult\\u003e | Azure.ResourceManager.CommonTypes.ErrorResponse\\r\\n```\\n\\n### Swagger Output\\n\\n\\\"description\\\": \\\"List of operations supported by the resource provider\\\",\\r\\n          \\\"items\\\": {\\r\\n            \\\"$ref\\\": \\\"#/definitions/Operation\\\"\\r\\n          }\\r\\n        },\\r\\n        \\\"nextLink\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"format\\\": \\\"uri\\\",\\r\\n          \\\"description\\\": \\\"URL to get the next set of operation list results (if there are any)\\\",\\r\\n          \\\"readOnly\\\": true\\r\\n        }\\r\\n      },\\r\\n      \\\"required\\\": [\\r\\n        \\\"value\\\"\\r\\n      ]\\r\\n    },\\r\\n    \\\"Operation\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"Details of a REST API operation, returned from the Resource Provider Operations API\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"name\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The name of the operation, as per Resource-Based Access Control (RBAC). Examples: \\\\\\\"Microsoft.Compute/virtualMachines/write\\\\\\\", \\\\\\\"Microsoft.Compute/virtualMachines/capture/action\\\\\\\"\\\",\\r\\n          \\\"readOnly\\\": true\\r\\n        },\\r\\n        \\\"isDataAction\\\": {\\r\\n          \\\"type\\\": \\\"boolean\\\",\\r\\n          \\\"description\\\": \\\"Whether the operation applies to data-plane. This is \\\\\\\"true\\\\\\\" for data-plane operations and \\\\\\\"false\\\\\\\" for ARM/control-plane operations.\\\",\\r\\n          \\\"readOnly\\\": true\\r\\n        },\\r\\n        \\\"display\\\": {\\r\\n          \\\"$ref\\\": \\\"#/definitions/OperationDisplay\\\"\\r\\n        }\\r\\n      }\\r\\n    },\\r\\n    \\\"OperationDisplay\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"Localized display information for this particular operation.\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"provider\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The localized friendly form of the resource provider name, e.g. \\\\\\\"Microsoft Monitoring Insights\\\\\\\" or \\\\\\\"Microsoft Compute\\\\\\\".\\\",\\r\\n          \\\"readOnly\\\": true\\r\\n        },\\r\\n        \\\"resource\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The localized friendly name of the resource type related to this operation. E.g. \\\\\\\"Virtual Machines\\\\\\\" or \\\\\\\"Job Schedule Collections\\\\\\\".\\\",\\r\\n          \\\"readOnly\\\": true\\r\\n        },\\r\\n        \\\"operation\\\": {\\n\\n\\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The localized friendly form of the resource provider name, e.g. \\\\\\\"Microsoft Monitoring Insights\\\\\\\" or \\\\\\\"Microsoft Compute\\\\\\\".\\\",\\r\\n          \\\"readOnly\\\": true\\r\\n        },\\r\\n        \\\"resource\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The localized friendly name of the resource type related to this operation. E.g. \\\\\\\"Virtual Machines\\\\\\\" or \\\\\\\"Job Schedule Collections\\\\\\\".\\\",\\r\\n          \\\"readOnly\\\": true\\r\\n        },\\r\\n        \\\"operation\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The concise, localized friendly name for the operation; suitable for dropdowns. E.g. \\\\\\\"Create or Update Virtual Machine\\\\\\\", \\\\\\\"Restart Virtual Machine\\\\\\\".\\\",\\r\\n          \\\"readOnly\\\": true\\r\\n        },\\r\\n        \\\"description\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"description\\\": \\\"The short, localized friendly description of the operation; suitable for tool tips and detailed views.\\\",\\r\\n          \\\"readOnly\\\": true\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\n\\nBased on the actual test implementation:\\r\\n```json\\r\\n{\\r\\n  \\\"paths\\\": {\\r\\n    \\\"/providers/Azure.ResourceManager.MethodSubscriptionId/operations\\\": {\\r\\n      \\\"get\\\": {\\r\\n        \\\"operationId\\\": \\\"Operations_List\\\",\\r\\n        \\\"tags\\\": [\\r\\n          \\\"Operations\\\"\\r\\n        ],\\r\\n        \\\"description\\\": \\\"List all operations provided by Azure.ResourceManager.MethodSubscriptionId resource provider\\\",\\r\\n        \\\"parameters\\\": [\\r\\n          {\\r\\n            \\\"name\\\": \\\"api-version\\\",\\r\\n            \\\"in\\\": \\\"query\\\",\\r\\n            \\\"required\\\": true,\\r\\n            \\\"type\\\": \\\"string\\\",\\r\\n            \\\"description\\\": \\\"The API version to use for this operation.\\\",\\r\\n            \\\"x-ms-parameter-location\\\": \\\"method\\\"\\r\\n          }\\r\\n        ],\\r\\n        \\\"responses\\\": {\\r\\n          \\\"200\\\": {\\r\\n            \\\"description\\\": \\\"Azure operation completed successfully.\\\",\\r\\n            \\\"schema\\\": {\\r\\n              \\\"$ref\\\": \\\"#/definitions/OperationListResult\\\"\\r\\n            }\\r\\n          },\\r\\n          \\\"default\\\": {\\r\\n            \\\"description\\\": \\\"An unexpected error response.\\\",\\r\\n            \\\"schema\\\": {\\r\\n              \\\"$ref\\\": \\\"#/definitions/ErrorResponse\\\"\\r\\n            }\\r\\n          }\\r\\n        },\\r\\n        \\\"x-ms-pageable\\\": {\\r\\n          \\\"nextLinkName\\\": \\\"nextLink\\\"\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  },\\r\\n  \\\"definitions\\\": {\\r\\n    \\\"OperationListResult\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\\r\\n      \\\"description\\\": \\\"A list of REST API operations supported by an Azure Resource Provider.\\\",\\r\\n      \\\"properties\\\": {\\r\\n        \\\"value\\\": {\\r\\n          \\\"type\\\": \\\"array\\\",\\r\\n          \\\"description\\\": \\\"List of operations supported by the resource provider\\\",\\r\\n          \\\"items\\\": {\\r\\n            \\\"$ref\\\": \\\"#/definitions/Operation\\\"\\r\\n          }\\r\\n        },\\r\\n        \\\"nextLink\\\": {\\r\\n          \\\"type\\\": \\\"string\\\",\\r\\n          \\\"format\\\": \\\"uri\\\",\\r\\n          \\\"description\\\": \\\"URL to get the next set of operation list results (if there are any)\\\",\\r\\n          \\\"readOnly\\\": true\\r\\n        }\\r\\n      },\\r\\n      \\\"required\\\": [\\r\\n        \\\"value\\\"\\r\\n      ]\\r\\n    },\\r\\n    \\\"Operation\\\": {\\r\\n      \\\"type\\\": \\\"object\\\",\"},{\"document_source\":\"static_typespec_to_swagger_mapping\",\"document_filename\":\"TypeSpec-ARM.CommonTypes-Models-Documentation.md\",\"document_title\":\"TypeSpec Azure.ResourceManager.CommonTypes Models Mapping to Swagger Documentation\",\"document_link\":\"\",\"content\":\"# TypeSpec-ARM.CommonTypes-Models-Documentation.md\\n\\n# TypeSpec Azure.ResourceManager.CommonTypes Models Mapping to Swagger Documentation\\n\\n## 67. UserAssignedIdentities\\n\\n### Description\\n\\nThe set of user assigned identities associated with the resource.\\n\\n### TypeSpec Example\\n\\n```typespec\\r\\nmodel ManagedServiceIdentity {\\r\\n  userAssignedIdentities?: UserAssignedIdentities;\\r\\n}\\r\\n```\\n\\n### Swagger Output\\n\\n```json\\r\\n{\\r\\n  \\\"UserAssignedIdentities\\\": {\\r\\n    \\\"type\\\": \\\"object\\\",\\r\\n    \\\"additionalProperties\\\": {\\r\\n      \\\"$ref\\\": \\\"#/definitions/UserAssignedIdentity\\\"\\r\\n    },\\r\\n    \\\"description\\\": \\\"The set of user assigned identities associated with the resource. The userAssignedIdentities dictionary keys will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'. The dictionary values can be empty objects ({}) in requests.\\\"\\r\\n  }\\r\\n}\\r\\n```\"},{\"document_source\":\"azure_resource_manager_rpc\",\"document_filename\":\"v1.0#subscription-lifecycle-api-reference.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/subscription-lifecycle-api-reference.md\",\"content\":\"# Subscription Lifecycle API Reference\\n## Creating or Updating a Subscription\\n### Request\\nhas been registered under RP namespace and platform namespace (Microsoft.Resources).  Null or an empty array would mean that there are no registered features for the given subscription. |\\r\\n| **properties.availabilityZones** | Optional. Physical to logical zone mapping. This mapping will be per location (region). |\\r\\n| **properties.spendingLimit** | Optional. Whether the subscription has a spending limit (\\\"On\\\", \\\"Off\\\", or \\\"CurrentPeriodOff\\\"). |\\r\\n| **Properties.accountOwner** | Optional. Identity information for the subscription's account owner. |\\r\\n| **properties.managedByTenants** | Optional. All tenants managing the subscription. Null or empty means that there are no managing tenants. |\\r\\n| **properties.additionalProperties** | Required. AdditionalProperty bag, which is a dictionary of JTokens. More details can be found below. |\\r\\n\\r\\n#### AdditionalProperties\\r\\n\\r\\nAdditional Properties property would be a dictionary of JTokens. Please note that in the future the dictionary may be appended with additional JTokens. Also, the JTokens may also be modified to have additional data. Resource Providers should develop code that can handle modifications, and should not strongly parse this dictionary.\\r\\n\\r\\n```json\\r\\n{\\r\\n    \\\"properties\\\": {\\r\\n        \\\"additionalProperties\\\": {\\r\\n            \\\"billingProperties\\\": {\\r\\n                \\\"costCategory\\\": \\\"FR | FG | FS | FX | FB | None\\\",\\r\\n                \\\"channelType\\\": \\\"Internal | FieldLed | CustomerLed | PartnerLed | None\\\",\\r\\n                \\\"billingType\\\": \\\"Legacy| Modern\\\",\\r\\n                \\\"paymentType\\\": \\\"Paid |Free| Entitlement| SponsoredPlus | Sponsored | Benefit | None\\\",\\r\\n                \\\"workloadType\\\": \\\"Production | DevTest | None\\\",\\r\\n                \\\"tier\\\": \\\"Standard | Premium | Priority | Unknown \\\",\\r\\n                \\\"billingAccount\\\": {\\r\\n                    \\\"id\\\": \\\"/providers/Microsoft.Billing/billingAccounts/54731783\\\"\\r\\n                },\\r\\n                \\\"additionalStateInformation\\\": {\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#json-schema#reference#emitter.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/emitters/json-schema/reference/emitter\",\"content\":\"# Emitter usage\\n## Emitter options\\n### `polymorphic-models-strategy`\\n**Type:** `\\\"ignore\\\" | \\\"oneOf\\\" | \\\"anyOf\\\"`\\r\\nStrategy for emitting models with the @discriminator decorator:\\r\\n- ignore: Emit as regular object schema (default). Derived models use allOf to reference their base model.\\r\\n- oneOf: Emit a oneOf schema with references to all derived models (closed union)\\r\\n- anyOf: Emit an anyOf schema with references to all derived models (open union)\\r\\nWhen using oneOf or anyOf, derived models will inline all properties from their base model\\r\\ninstead of using allOf references. This avoids circular references in the generated schemas,\\r\\nsince the base model references derived models via oneOf/anyOf.\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#x-ms-examples.mdx\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/x-ms-examples\",\"content\":\"# x-ms-examples example files\\n## Generate the examples\\nTo generate the examples you can use [oav](https://github.com/Azure/oav). You can run that on the generated openapi.json file.\\r\\n\\r\\nGenerating basic examples and then manually modify the values. It will generate two examples for each operation: one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated examples consist of random values for most types, you need replace them with meaningful values.\\r\\n\\r\\n```bash\\r\\noav generate-examples openapi.json\\r\\n```\\r\\n\\r\\nNote, latest OAV tool should automatically generate the following. However, if you are generating the examples manually, please ensure you have:\\r\\n\\r\\n- include `title` field and make sure it is descriptive and unique for each operation.\\r\\n- include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in swagger.\\r\\n\\r\\n:::caution\\r\\nThe examples are now in the examples directory relative to the output openapi.json. You must now copy them to the examples directory in the project root. The typespec-autorest emitter will then copy them back to the correct location when generating the OpenAPI 2.0.\\r\\n:::\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#typespec-for-openapi-dev.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/getting-started/typespec-for-openapi-dev\",\"content\":\"# TypeSpec for OpenAPI Developers\\n## Data Types\\n### JSON Schema assertions\\nOpenAPI supports a variety of \\\"assertions\\\" that can be used to further restrict the values allowed for a data type.\\r\\nThese are actually borrowed into OpenAPI from JSON Schema.\\r\\n\\r\\nFor `type: integer` and `type: number` data types:\\r\\n\\r\\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\\r\\n| --------------------------- | ---------------------------- | ----- |\\r\\n| `minimum: value`            | `@minValue(value)` decorator |       |\\r\\n| `maximum: value`            | `@maxValue(value)` decorator |       |\\r\\n\\r\\nFor `type: string` data types:\\r\\n\\r\\n| OpenAPI/JSON Schema keyword | TypeSpec construct            | Notes |\\r\\n| --------------------------- | ----------------------------- | ----- |\\r\\n| `minLength: value`          | `@minLength(value)` decorator |       |\\r\\n| `maxLength: value`          | `@maxLength(value)` decorator |       |\\r\\n| `pattern: regex`            | `@pattern(regex)` decorator   |       |\\r\\n\\r\\nFor `type: array` data types:\\r\\n\\r\\n| OpenAPI/JSON Schema keyword | TypeSpec construct           | Notes |\\r\\n| --------------------------- | ---------------------------- | ----- |\\r\\n| `minItems: value`           | `@minItems(value)` decorator |       |\\r\\n| `maxItems: value`           | `@maxItems(value)` decorator |       |\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"libraries#openapi#reference#data-types.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/libraries/openapi/reference/data-types\",\"content\":\"# Data types\\n## TypeSpec.OpenAPI\\n### `AdditionalInfo` {#TypeSpec.OpenAPI.AdditionalInfo}\\nAdditional information for the OpenAPI document.\\r\\n\\r\\n```typespec\\r\\nmodel TypeSpec.OpenAPI.AdditionalInfo\\r\\n```\\r\\n\\r\\n#### Properties\\r\\n\\r\\n| Name            | Type                                                  | Description                                                                                                                       |\\r\\n| --------------- | ----------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |\\r\\n| title?          | `string`                                              | The title of the API. Overrides the `@service` title.                                                                             |\\r\\n| summary?        | `string`                                              | A short summary of the API. Overrides the `@summary` provided on the service namespace.                                           |\\r\\n| version?        | `string`                                              | The version of the OpenAPI document (which is distinct from the OpenAPI Specification version or the API implementation version). |\\r\\n| termsOfService? | `url`                                                 | A URL to the Terms of Service for the API. MUST be in the format of a URL.                                                        |\\r\\n| contact?        | [`Contact`](./data-types.md#TypeSpec.OpenAPI.Contact) | The contact information for the exposed API.                                                                                      |\\r\\n| license?        | [`License`](./data-types.md#TypeSpec.OpenAPI.License) | The license information for the exposed API.                                                                                      |\\r\\n|                 | `unknown`                                             | Additional properties\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"language-basics#visibility.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/language-basics/visibility\",\"content\":\"# Visibility\\n## Lifecycle visibility\\nschema:\\r\\n                $ref: \\\"#/components/schemas/Example\\\"\\r\\n    patch:\\r\\n      parameters:\\r\\n        - name: id\\r\\n          in: path\\r\\n          required: true\\r\\n          schema:\\r\\n            type: string\\r\\n      responses:\\r\\n        \\\"200\\\":\\r\\n          content:\\r\\n            application/json:\\r\\n              schema:\\r\\n                $ref: \\\"#/components/schemas/Example\\\"\\r\\n      requestBody:\\r\\n        required: true\\r\\n        content:\\r\\n          application/json:\\r\\n            schema:\\r\\n              $ref: \\\"#/components/schemas/ExampleUpdate\\\"\\r\\ncomponents:\\r\\n  schemas:\\r\\n    Example:\\r\\n      type: object\\r\\n      required:\\r\\n        - id\\r\\n        - name\\r\\n        - description\\r\\n      properties:\\r\\n        id:\\r\\n          type: string\\r\\n          readOnly: true\\r\\n        name:\\r\\n          type: string\\r\\n        description:\\r\\n          type: string\\r\\n    ExampleUpdate:\\r\\n      type: object\\r\\n      properties:\\r\\n        description:\\r\\n          type: string\\r\\n```\\r\\n\\r\\nNotice:\\r\\n\\r\\n- The `id` property is marked `readOnly: true` because it is only visible when reading the resource.\\r\\n- The `ExampleUpdate` schema only includes the `description` property because it is the only property that is visible\\r\\n  when updating the resource.\\r\\n- Each of the `paths` reference the correct schema based on the lifecycle phase that the operations use.\\r\\n- The TypeSpec model is only defined _once_, and any changes in the output schemas are derived from the lifecycle\\r\\n  visibility of the properties in the model.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# Suppress validation failures on a PR\\n## Suppress AutoRest extension\\n### Obtain error code\\nTo get error code,  i.e. the value for `- code:`:\\r\\n\\r\\n- For `SemanticValidation` and `ModelValidation`, refer to [error definition](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/Semantic-and-Model-Violations-Reference.md).\\r\\n- For `LintDiff` and `LintDiff(RPaaS)`, refer to [rules.md](https://github.com/Azure/azure-openapi-validator/blob/main/docs/rules.md).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-openapi.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-openapi\",\"content\":\"# What is OpenAPI?\\n\\u003e [!IMPORTANT]\\r\\n\\u003e TypeSpec Azure usage for API definition is a mandatory requirement for all new (greenfield) data plane and management plane\\r\\n\\u003e services. This requirement is enforced by the ARM API Review Board for management plane services and by the API\\r\\n\\u003e Stewardship Board for data plane services.\\r\\n\\u003e Brownfield services will eventually be required to transition to TypeSpec Azure as well.  PRs for brownfields services\\r\\n\\u003e that have not transitioned to TypeSpec Azure will receive notices in FY2024, followed by warnings in FY2025 and\\r\\n\\u003e errors in FY2027. The requirement to move to TypeSpec Azure will ensure a consistent, high-quality developer experience across\\r\\n\\u003e Azure that aligns with Azure SDK guidelines. For more information on TypeSpec Azure visit [here](xref:api-typespec).\\r\\n\\r\\nThe OpenAPI Specification (formerly known as the Swagger Specification) is an API description format for REST APIs.\\r\\nAn OpenAPI file allows you to describe your entire API, including:\\r\\n\\r\\n- Available endpoints (/users) and operations on each endpoint (GET /users, POST /users)\\r\\n- Operation parameters input and output for each operation\\r\\n- Authentication methods\\r\\n- Contact information, license, terms of use and other information\\r\\n\\r\\nOpenAPI uses [JSON Schema] to describe the format of primitive and structured data, specifically [JSON Schema Draft 4]\\r\\nin OpenAPI v2.\\r\\n\\r\\nOpenAPI descriptions of Azure services must conform to the OpenAPI v2 Specification and the applicable parts of\\r\\nJSON Schema. In addition:\\r\\n\\r\\n- Azure management plane services must conform to the ARM [Resource Provider Guidelines]\\r\\n- Azure data plane services must conform to the [Azure REST API Guidelines] and the Azure OpenAPI Style Guide.\\r\\n\\r\\nOpenAPI allows [specification extensions], properties with an `x-` prefix, to provide additional information for\\r\\nparticular use cases.\\r\\n\\r\\nAzure uses the [specification extensions for the AutoRest client library generator][autorest specification extensions]\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-tooling.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-tooling\",\"content\":\"# Use tools to create and validate Azure REST APIs specs\\n## [Author with OpenAPI](#tab/author-with-openapi)\\nAuthor specs with OpenAPI (**legacy approach**)\\r\\n\\r\\nFor REST APIs that cannot be written in TypeSpec and still must be written directly in the OpenAPI format, you can:\\r\\n\\r\\n- Use [OpenAPI Initiative Swagger editor] for basic authoring.\\r\\n- Learn about the [spec directory structure].\\r\\n- Use the [Spectral linter] and the [Azure Spectral ruleset] to validate your OpenAPI definition against the Azure API\\r\\n  guidelines.\\r\\n  - Spectral provides a [VSCode plugin][Spectral VSCode plugin] that will highlight errors and warnings in your\\r\\n    OpenAPI definition in VSCode.\\r\\n\\r\\nYour OpenAPI definitions, to be published, will have to end up in the specs repos as explained in  \\r\\n[this article](xref:api-specs). As such, they will be subject to additional mandatory validation requirements.\\r\\nSee [validate your REST API](#validate-your-rest-api-specs) section to learn about them.\"}]",
            "inputs.latency": 801.6356310844421,
            "inputs.response_length": 2381,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://typespec.io/docs/getting-started/typespec-for-openapi-dev",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec",
                "https://typespec.io/docs/language-basics/type-relations"
            ],
            "inputs.testcase": "Generating Dictionary<string,object> type for swagger",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1848,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1849,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Generating Dictionary<string,object> type for swagger\\\\n\\\\nquestion: Hi API Spec Review,\\\\nWe are currently using `IDictionary<string, object>` in our models to allow passing through various key-value pairs, where the values can be a string, an array, or other types. So I defined the property in Swagger and provided examples in one PR, but encountered errors during PR validation.\\\\nCould you please suggest the right way to define such a flexible dictionary type in Swagger, and provide an example?\\\\nPR Link: [Add AddtionalProperties for DataConnector by LaylaLiu-gmail \\\\u00b7 Pull Request #38644 \\\\u00b7 Azure/azure-res\\\\u2026](https://github.com/Azure/azure-rest-api-specs/pull/38644/files#diff-2770767541dae7e1213d29b59c6e3bed488a458947839f25fdc31b3c7844ad42)\\\\nDictionary Definition in PR:\\\\n```\\\\n\\\\\\\"extendedProperties\\\\\\\": {\\\\n\\\\\\\"type\\\\\\\": \\\\\\\"object\\\\\\\",\\\\n\\\\\\\"additionalProperties\\\\\\\": {\\\\n\\\\\\\"type\\\\\\\": \\\\\\\"object\\\\\\\"\\\\n}\\\\n```\\\\nExamples in PR:\\\\n```\\\\n\\\\\\\"extendedProperties\\\\\\\": {\\\\n\\\\\\\"environment\\\\\\\": \\\\\\\"production\\\\\\\",\\\\n\\\\\\\"owner\\\\\\\": \\\\\\\"alice\\\\\\\",\\\\n\\\\\\\"additionalEndpoints\\\\\\\": [\\\\n\\\\\\\"https://foo.kusto.windows.net/databasename\\\\\\\",\\\\n\\\\\\\"https://bar.kusto.windows.net/databasename\\\\\\\"\\\\n]\\\\n}\\\\n```\\\\nValidation Error:\\\\n```\\\\n\\\\u274c  Check failure on line 8 in specification/app/resource-manager/Microsoft.App/ContainerApps/stable/2026-01-01/examples/Ag...\\\\nGitHub Actions / Swagger ModelValidation - Analyze Code\\\\nINVALID_TYPE: Expected type object but found type array\\\\n\\\\u274c  Check failure on line 8 in specification/app/resource-manager/Microsoft.App/ContainerApps/stable/2026-01-01/examples/Ag...\\\\nGitHub Actions / Swagger ModelValidation - Analyze Code\\\\nINVALID_TYPE: Expected type object but found type string\\\\n```\\\", \\\"response\\\": \\\"To correctly define a flexible dictionary property in Swagger/OpenAPI (for Azure REST APIs) where values can be string, array, or other types, you must use `additionalProperties` with an explicit schema that matches the types you want to allow. \\\\n\\\\nYour current definition uses:\\\\n```json\\\\n\\\\\\\"extendedProperties\\\\\\\": {\\\\n  \\\\\\\"type\\\\\\\": \\\\\\\"object\\\\\\\",\\\\n  \\\\\\\"additionalProperties\\\\\\\": {\\\\n    \\\\\\\"type\\\\\\\": \\\\\\\"object\\\\\\\"\\\\n  }\\\\n}\\\\n```\\\\n\\\\nHowever, this means each value in the dictionary must be an object, so simple values like strings or arrays will fail ModelValidation. \\\\n\\\\n**Best Practice (per Azure REST API guidelines):**\\\\nTo allow values to be string, array, or object, you should use `oneOf` inside `additionalProperties` to describe all allowed types. For example:\\\\n```json\\\\n\\\\\\\"extendedProperties\\\\\\\": {\\\\n  \\\\\\\"type\\\\\\\": \\\\\\\"object\\\\\\\",\\\\n  \\\\\\\"additionalProperties\\\\\\\": {\\\\n    \\\\\\\"oneOf\\\\\\\": [\\\\n      { \\\\\\\"type\\\\\\\": \\\\\\\"string\\\\\\\" },\\\\n      { \\\\\\\"type\\\\\\\": \\\\\\\"array\\\\\\\", \\\\\\\"items\\\\\\\": { \\\\\\\"type\\\\\\\": \\\\\\\"string\\\\\\\" } },\\\\n      { \\\\\\\"type\\\\\\\": \\\\\\\"object\\\\\\\" }\\\\n    ]\\\\n  }\\\\n}\\\\n```\\\\n\\\\nThis schema means any key can have a string, an array of strings, or an object as its value. If you need more types, add more entries to the `oneOf` array.\\\\n\\\\n**Example that matches the schema:**\\\\n```json\\\\n\\\\\\\"extendedProperties\\\\\\\": {\\\\n  \\\\\\\"environment\\\\\\\": \\\\\\\"production\\\\\\\",                  // string\\\\n  \\\\\\\"owner\\\\\\\": \\\\\\\"alice\\\\\\\",                            // string\\\\n  \\\\\\\"additionalEndpoints\\\\\\\": [                      // array of strings\\\\n    \\\\\\\"https://foo.kusto.windows.net/databasename\\\\\\\",\\\\n    \\\\\\\"https://bar.kusto.windows.net/databasename\\\\\\\"\\\\n  ],\\\\n  \\\\\\\"extraInfo\\\\\\\": { \\\\\\\"createdBy\\\\\\\": \\\\\\\"bob\\\\\\\" }         // object\\\\n}\\\\n```\\\\n\\\\n**Why the error occurred:**\\\\nThe validation error 'Expected type object but found type array/string' happens because your schema required each value to be an object, but your example used a string or array. The fix is to use `oneOf` to allow the expected types.\\\\n\\\\n**TypeSpec equivalent:**\\\\nIf you are writing TypeSpec, the closest equivalent is:\\\\n```typespec\\\\nmodel DataConnector {\\\\n  extendedProperties?: Record<string | string[] | object>;\\\\n}\\\\n```\\\\nBut for OpenAPI, you must express this with `oneOf` as shown above.\\\\n\\\\n**Summary:**\\\\n- Use `additionalProperties` with `oneOf` for multiple allowed value types.\\\\n- Your example must match one of the types defined in `oneOf`.\\\\n- This pattern is compliant with Azure REST API guidelines and will pass ModelValidation.\\\\n\\\\nIf you have a fixed set of types or want to restrict to specific schemas, add them to the `oneOf` array.\\\", \\\"ground_truth\\\": \\\"I think what you want (unfortunately) is\\\\n```\\\\n\\\\\\\"extendedProperties\\\\\\\": {\\\\n\\\\\\\"type\\\\\\\": \\\\\\\"object\\\\\\\",\\\\n\\\\\\\"additionalProperties\\\\\\\": {}\\\\n}\\\\n```\\\\nstrictly speaking, these should be the same, but autorest interprets {} to be any json value\\\\nIn typespec this would be `Record<unknown>`  (a dictionary in which the properties can be any json type)\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: SDK Validation - .NET\n\nquestion: I have an open PR [inital genome api spec by samira-farhin · Pull Request #25097 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/25097) that's currently failing on [SDK Validation - .NET - PR](https://github.com/Azure/azure-rest-api-specs-pr/pull/25097/checks?check_run_id=53550607849). My latest changes to resolve SDK Validation in \"tspconfig.yaml\" are included below. After these updates, the SDK validation issues for Go and Java were resolved, but the C# issue still remains. I'm unsure what else needs to be addressed.\n[inital genome api spec by samira-farhin · Pull Request #25097 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/25097/commits/85af075feeb98889d8dc27bdd838d409239f5eab)\n[inital genome api spec by samira-farhin · Pull Request #25097 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/25097/commits/a43851cea6c490ee183943383e817d882b85be23)\n```\ncommand  pwsh ./eng/scripts/Automation-Sdk-Init.ps1 ../azure-sdk-for-net-pr_tmp/initInput.json ../azure-sdk-for-net-pr_tmp/initOutput.json\ncommand  pwsh ./eng/scripts/Invoke-GenerateAndBuildV2.ps1 ../azure-sdk-for-net-pr_tmp/generateInput.json ../azure-sdk-for-net-pr_tmp/generateOutput.json\ncmdout  [.Net] Start to call tsp-client to generate package:Azure.ResourceManager.Genome\ncmdout  [.Net] Start to build sdk project: /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\ncmdout  [.Net]     8 Error(s)\ncmdout  [.Net] [ERROR] Failed to build the sdk project: Azure.ResourceManager.Genome for service: genome. Exit code: False. Please review the detail errors for potential fixes. If the issue persists, contact the DotNet language support channel at https://aka.ms/azsdk/dotnet-teams-channel and include this spec pull request.\n```",
            "inputs.ground_truth": "First, your PR is to branch `main` of repo `specs-pr`.  Such PRs can be used to preview check results, but they cannot be merged.  Did you intend to open a PR to `RPSaaSMaster` or the public `specs` repo?\nSecond, `check SDK Validation - .NET - PR` is not required, so you can merge a PR with it failing, if you are OK with it failing.  If you want support on the check failure:\nDocs: https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation\nTeams: [Code Generation - .NET | Azure SDK | Microsoft Teams](https://teams.microsoft.com/l/channel/19%3Aacbd512e57bd475198ea6bf4564599e3%40thread.skype/Code%20Generation%20-%20.NET?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)",
            "inputs.response": "Your .NET SDK validation errors (CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level) are caused by a code generation issue: the TypeSpec C# emitter is referencing an internal (non-public) helper type, which results in build failures when the generated code tries to use it.\n\nThis is not a spec modeling or tspconfig.yaml configuration problem—it's an emitter/tooling issue. In particular, the Azure ResourceManager C# SDK generator sometimes emits calls to helper classes (like GeneratorPageableHelpers) that are internal and therefore inaccessible to the generated public code.\n\n**Recommended Actions:**\n\n1. **Do not attempt to workaround this by changing your TypeSpec or tspconfig.yaml**—these errors are not fixable at the spec/config level.\n2. **Contact the .NET SDK tooling team** as directed in the error output:\n   - Use the DotNet language support channel: https://aka.ms/azsdk/dotnet-teams-channel\n   - Reference your PR and the specific error details. This is a known issue with the C# ResourceManager emitter and needs their intervention.\n3. If your repo is missing required emitter/tool updates, check that you are using the latest version of `@azure-tools/typespec-csharp` in your `tspconfig.yaml` options, and that your repo has up-to-date build scripts. However, if Go and Java are passing and only .NET fails, this is almost certainly a .NET emitter bug.\n\n**Summary:**\n- You cannot resolve this error by modifying your spec or config.\n- The .NET generator is emitting calls to internal helpers. This must be fixed in the generator/emitter, not your repo.\n- Contact the .NET team per the instructions for resolution.\n\nIf you want to double-check your tspconfig.yaml settings, you can refer to the Contoso sample for management plane emitters (see reference below), but this will not resolve internal visibility errors.\n\n**Next Steps:**\n- Report the error and your PR to the DotNet support channel for a fix or workaround.\n- Once the emitter is patched, re-run validation/build.\n\nFor more on SDK generation config and emitter settings, see the references below.",
            "inputs.context": "[{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#Guidelines.md\",\"document_title\":\"Microsoft Azure REST API Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md\",\"content\":\"# azure#Guidelines.md\\n\\n# Microsoft Azure REST API Guidelines\\n\\n\\u003c!-- cspell:ignore autorest, BYOS, etag, idempotency, maxpagesize, innererror, trippable, nextlink, condreq, etags --\\u003e\\r\\n\\u003c!-- markdownlint-disable MD033 MD049 MD055 --\\u003e\\r\\n\\r\\n\\u003c!--\\r\\nNote to contributors: All guidelines now have an anchor tag to allow cross-referencing from associated tooling.\\r\\nThe anchor tags within a section using a common prefix to ensure uniqueness with anchor tags in other sections.\\r\\nPlease ensure that you add an anchor tag to any new guidelines that you add and maintain the naming convention.\\r\\n--\\u003e\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2025-Mar-28 | Added guidelines about JSON ID and null values                 |\\r\\n| 2024-Mar-17 | Updated LRO guidelines                                         |\\r\\n| 2024-Jan-17 | Added guidelines on returning string offsets \\u0026 lengths         |\\r\\n| 2023-May-12 | Explain service response for missing/unsupported `api-version` |\\r\\n| 2023-Apr-21 | Update/clarify guidelines on POST method repeatability         |\\r\\n| 2023-Apr-07 | Update/clarify guidelines on polymorphism                      |\\r\\n| 2022-Sep-07 | Updated URL guidelines for DNS Done Right                      |\\r\\n| 2022-Jul-15 | Update guidance on long-running operations                     |\\r\\n| 2022-May-11 | Drop guidance on version discovery                             |\\r\\n| 2022-Mar-29 | Add guidelines about using durations                           |\\r\\n| 2022-Mar-25 | Update guideline for date values in headers to follow RFC 7231 |\\r\\n| 2022-Feb-01 | Updated error guidance                                         |\\r\\n| 2021-Sep-11 | Add long-running operations guidance                           |\\r\\n| 2021-Aug-06 | Updated Azure REST Guidelines per Azure API Stewardship Board. |\\r\\n| 2020-Jul-31 | Added service advice for initial versions                      |\\r\\n| 2020-Mar-31 | 1st public release of the Azure REST API Guidelines            |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Introduction\\n\\nThese guidelines apply to Azure service teams implementing _data plane_ APIs. They offer prescriptive guidance that Azure service teams MUST follow ensuring that customers have a great experience by designing APIs meeting these goals:\\r\\n- Developer friendly via consistent patterns \\u0026 web standards (HTTP, REST, JSON)\\r\\n- Efficient \\u0026 cost-effective\\r\\n- Work well with SDKs in many programming languages\\r\\n- Customers can create fault-tolerant apps by supporting retries/idempotency/optimistic concurrency\\r\\n- Sustainable \\u0026 versionable via clear API contracts with 2 requirements:\\r\\n  1. Customer workloads must never break due to a service change\\r\\n  2. Customers can adopt a version without requiring code changes\\r\\n\\r\\nTechnology and software is constantly changing and evolving, and as such, this is intended to be a living document. [Open an issue](https://github.com/microsoft/api-guidelines/issues/new/choose) to suggest a change or propose a new idea. Please read the [Considerations for Service Design](./ConsiderationsForServiceDesign.md) for an introduction to the topic of API design for Azure services. *For an existing GA'd service, don't change/break its existing API; instead, leverage these concepts for future APIs while prioritizing consistency within your existing service.*\\r\\n\\r\\n*Note: If you are creating a management plane (ARM) API, please refer to the [Azure Resource Manager Resource Provider Contract](https://github.com/cloud-and-ai-microsoft/resource-provider-contract).*\\n\\n### Prescriptive Guidance\\n\\nThis document offers prescriptive guidance labeled as follows:\\r\\n\\r\\n:white_check_mark: **DO** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n:ballot_box_with_check: **YOU SHOULD** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:heavy_check_mark: **YOU MAY** consider this pattern if appropriate to your situation. No notification to the Azure HTTP/REST Stewardship Board is required.\\r\\n\\r\\n:warning: **YOU SHOULD NOT** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:no_entry: **DO NOT** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n*If you feel you need an exception, or need clarity based on your situation, please contact the Azure HTTP/REST Stewardship Board **prior** to release of your API.*\\n\\n## Building Blocks: HTTP, REST, \\u0026 JSON\\n\\nThe Microsoft Azure Cloud platform exposes its APIs through the core building blocks of the Internet; namely HTTP, REST, and JSON. This section provides you with a general understanding of how these technologies should be applied when creating your service.\\r\\n\\r\\n\\u003ca href=\\\"#http\\\" name=\\\"http\\\"\\u003e\\u003c/a\\u003e\\n\\n### HTTP\\n\\ncase-sensitive, multiple delimiter\\r\\nUUID      | 123e4567-e89b-12d3-a456-426614174000 (no {}s, hyphens, case-insensitive) [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)\\r\\nDate/Time (Header) | Sun, 06 Nov 1994 08:49:37 GMT [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1)\\r\\nDate/Time (Query parameter) | YYYY-MM-DDTHH:mm:ss.sssZ (with at most 3 digits of fractional seconds) [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)\\r\\nByte array | Base-64 encoded, max length\\r\\nArray      | One of a) a comma-separated list of values (preferred), or b) separate `name=value` parameter instances for each value of the array\\r\\n\\r\\n\\r\\nThe table below lists the headers most used by Azure services:\\r\\n\\r\\nHeader Key          | Applies to | Example\\r\\n------------------- | ---------- | -------------\\r\\n_authorization_     | Request    | Bearer eyJ0...Xd6j (Support Azure Active Directory)\\r\\n_x-ms-useragent_    | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntraceparent         | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntracecontext        | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\naccept              | Request    | application/json\\r\\nIf-Match            | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-None-Match       | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-Modified-Since   | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\nIf-Unmodified-Since | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\ndate                | Both       | Sun, 06 Nov 1994 08:49:37 GMT (see [RFC 7231, Section 7.1.1.2](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2))\\r\\n_content-type_      | Both       | application/merge-patch+json\\n\\nname=\\\"http-header-names-casing\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** specify headers using kebab-casing\\r\\n\\r\\n\\u003ca href=\\\"#http-header-names-case-sensitivity\\\" name=\\\"http-header-names-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header names using case-insensitivity\\r\\n\\r\\n\\u003ca href=\\\"#http-header-values-case-sensitivity\\\" name=\\\"http-header-values-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header values using case-sensitivity if the header name requires it\\r\\n\\r\\n\\u003ca href=\\\"#http-header-date-values\\\" name=\\\"http-header-date-values\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** accept date values in headers in HTTP-Date format and return date values in headers in the IMF-fixdate format as defined in [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1), e.g. \\\"Sun, 06 Nov 1994 08:49:37 GMT\\\".\\r\\n\\r\\nNote: The RFC 7231 IMF-fixdate format is a \\\"fixed-length and single-zone subset\\\" of the RFC 1123 / RFC 5822 format, which means: a) year must be four digits, b) the seconds component of time is required, and c) the timezone must be GMT.\\r\\n\\r\\n\\u003ca href=\\\"#http-header-request-id\\\" name=\\\"http-header-request-id\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** create an opaque value that uniquely identifies the request and return this value in the `x-ms-request-id` response header.\\r\\n\\r\\nYour service should include the `x-ms-request-id` value in error logs so that users can submit support requests for specific failures using this value.\\r\\n\\r\\n\\u003ca href=\\\"#http-allow-unrecognized-headers\\\" name=\\\"http-allow-unrecognized-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** fail a request that contains an unrecognized header. Headers may be added by API gateways or middleware and this must be tolerated\\r\\n\\r\\n\\u003ca href=\\\"#http-no-x-custom-headers\\\" name=\\\"http-no-x-custom-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** use \\\"x-\\\" prefix for custom headers, unless the header already exists in production [[RFC 6648](https://datatracker.ietf.org/doc/html/rfc6648)].\\r\\n\\r\\n**Additional References**\\n\\nAzure services must adhere to the HTTP specification, [RFC 7231](https://tools.ietf.org/html/rfc7231). This section further refines and constrains how service implementors should apply the constructs defined in the HTTP specification. It is therefore, important that you have a firm understanding of the following concepts:\\r\\n\\r\\n- [Uniform Resource Locators (URLs)](#uniform-resource-locators-urls)\\r\\n- [HTTP Request / Response Pattern](#http-request--response-pattern)\\r\\n- [HTTP Query Parameters and Header Values](#http-query-parameters-and-header-values)\\r\\n\\r\\n#### Uniform Resource Locators (URLs)\\r\\n\\r\\nA Uniform Resource Locator (URL) is how developers access the resources of your service. Ultimately, URLs are how developers form a cognitive model of your service's resources.\\r\\n\\r\\n\\u003ca href=\\\"#http-url-pattern\\\" name=\\\"http-url-pattern\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** use this URL pattern:\\r\\n```text\\r\\nhttps://\\u003ctenant\\u003e.\\u003cregion\\u003e.\\u003cservice\\u003e.\\u003ccloud\\u003e/\\u003cservice-root\\u003e/\\u003cresource-collection\\u003e/\\u003cresou\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#ConsiderationsForServiceDesign.md\",\"document_title\":\"Considerations for Service Design\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/ConsiderationsForServiceDesign.md\",\"content\":\"# azure#ConsiderationsForServiceDesign.md\\n\\n# Considerations for Service Design\\n\\n\\u003c!-- cspell:ignore autorest, etag, idempotency, maxpagesize, openapi --\\u003e\\r\\n\\u003c!-- markdownlint-disable MD033 --\\u003e\\n\\n## History\\n\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2024-Mar-17 | Updated LRO guidelines                                         |\\r\\n| 2024-Jan-17 | Added guidelines on returning string offsets \\u0026 lengths         |\\r\\n| 2022-Jul-15 | Update guidance on long-running operations                     |\\r\\n| 2022-Feb-01 | Updated error guidance                                         |\\r\\n| 2021-Sep-11 | Add long-running operations guidance                           |\\r\\n| 2021-Aug-06 | Updated Azure REST Guidelines per Azure API Stewardship Board. |\\n\\n## Introduction\\n\\nGreat APIs make your service usable to customers. They are intuitive, naturally reflecting and communicating the underlying model and its behavior. They lend themselves easily to client library implementations in multiple programming languages. And they don't \\\"get in the way\\\" of the developer, by remaining stable and predictable, _especially over time_.\\r\\n\\r\\nThis document provides Microsoft teams building Azure services with a set of guidelines that  help service teams build great APIs. The guidelines create APIs that are approachable, sustainable, and consistent across the Azure platform. We do this by applying a common set of patterns and web standards to the design and development of the API.\\r\\nFor developers, a well defined and constructed API enables them to build fault-tolerant applications that are easy to maintain, support, and grow. For Azure service teams, the API is often the source of code generation enabling a broad audience of developers across multiple languages.\\r\\n\\r\\nAzure Service teams should engage the Azure HTTP/REST Stewardship Board early in the development lifecycle for guidance, discussion, and review of their API. In addition, it is good practice to perform a security review, especially if you are concerned about PII leakage, compliance with GDPR, or any other considerations relative to your situation.\\r\\n\\r\\nIt is critically important to design your service to avoid disrupting users as the API evolves:\\r\\n\\r\\n\\u003ca href=\\\"#principles-api-versioning\\\" name=\\\"principles-api-versioning\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** implement API versioning starting with the very first release of the service.\\r\\n\\r\\n\\u003ca href=\\\"#principles-compatibility\\\" name=\\\"principles-compatibility\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** ensure that customer workloads never break\\n\\nwith GDPR, or any other considerations relative to your situation.\\r\\n\\r\\nIt is critically important to design your service to avoid disrupting users as the API evolves:\\r\\n\\r\\n\\u003ca href=\\\"#principles-api-versioning\\\" name=\\\"principles-api-versioning\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** implement API versioning starting with the very first release of the service.\\r\\n\\r\\n\\u003ca href=\\\"#principles-compatibility\\\" name=\\\"principles-compatibility\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** ensure that customer workloads never break\\r\\n\\r\\n\\u003ca href=\\\"#principles-backward-compatibility\\\" name=\\\"principles-backward-compatibility\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** ensure that customers are able to adopt a new version of service or SDK client library **without requiring code changes**\\n\\n## Azure Management Plane vs Data Plane\\n\\n_Note: Developing a new service requires the development of at least 1 (management plane) API and potentially one or more additional (data plane) APIs.  When reviewing v1 service APIs, we see common advice provided during the review._\\r\\n\\r\\nA **management plane** API is implemented through the Azure Resource Manager (ARM) and is used to provision and control the operational state of resources.\\r\\nA **data plane** API is used by developers to implement applications. Occasionally, some operations are useful for provisioning/control and applications. In this case, the operation can appear in both APIs.\\r\\nAlthough, best practices and patterns described in this document apply to all HTTP/REST APIs, they are especially important for **data plane** services because it is the primary interface for developers using your service. The **management plane** APIs may have other preferred practices based on the conventions of the [Azure RPC](https://aka.ms/azurerpc).\\n\\n## Start with the Developer Experience\\n\\nA great API starts with a well thought out and designed service. Your service should define simple/understandable abstractions with each given a clear name that you use consistently throughout your API and documentation. There must also be an unambiguous relationship between these abstractions.\\r\\n\\r\\nFollow these practices to create clear names for your abstractions:\\r\\n- Don't invent fancy terms or use fancy words. Try explaining the abstraction to someone that is not a domain expert and then name the abstraction using similar verbiage.\\r\\n- Don't include \\\"throwaway\\\" words in names, like \\\"response\\\", \\\"object\\\", \\\"payload\\\", etc.\\r\\n- Avoid generic names. Names should be specific to the abstraction and highlight how it is different from other abstractions in your service or related services.\\r\\n- Pick one word/term out of a set of synonyms and stick to it.\\r\\n\\r\\nIt is extremely difficult to create an elegant API that works well on top of a poorly designed service; the service team and customers will live with this pain for years to come. So, the service team should empathize with customers by:\\r\\n- Building apps that consume the API\\r\\n- Hold reviews and share what is learned with your team\\r\\n- Get customer feedback from API previews\\r\\n- Thinking about the code that a customer writes both before and after an HTTP operation\\r\\n- Initializing and reading from the data structures your service requires\\r\\n- Thinking about which errors are recoverable at runtime as opposed to indicating a bug in the customer code that must be fixed\\r\\n\\r\\nThe whole purpose of a preview to address feedback by improving abstractions, naming, relationships, API operations, and so on. It is OK to make breaking changes during a preview to improve the experience now so that it is sustainable long term.\\n\\n## Focus on Hero Scenarios\\n\\nIt is important to realize that writing an API is, in many cases, the easiest part of providing a delightful developer experience. There are a large number of downstream activities for each API, e.g. testing, documentation, client libraries, examples, blog posts, videos, and supporting customers in perpetuity. In fact, implementing an API is of miniscule cost compared to all the other downstream activities.\\r\\n\\r\\n_For this reason, it is **much better** to ship with fewer features and only add new features over time as required by customers._\\r\\n\\r\\nFocusing on hero scenarios reduces development, support, and maintenance costs; enables teams to align and reach consensus faster; and accelerates the time to delivery. A telltale sign of a service that has not focused on hero scenarios is \\\"API drift,\\\" where endpoints are inconsistent, incomplete, or juxtaposed to one another.\\r\\n\\r\\n\\u003ca href=\\\"#hero-scenarios-design\\\" name=\\\"hero-scenarios-design\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** define \\\"hero scenarios\\\" first including abstractions, naming, relationships, and then define the API describing the operations required.\\r\\n\\r\\n\\u003ca href=\\\"#hero-scenarios-examples\\\" name=\\\"hero-scenarios-examples\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** provide example code demonstrating the \\\"Hero Scenarios\\\".\\r\\n\\r\\n\\u003ca href=\\\"#hero-scenarios-high-level-languages\\\" name=\\\"hero-scenarios-high-level-languages\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** consider how your abstractions will be represented in different high-level languages.\\r\\n\\r\\n\\u003ca href=\\\"#hero-scenarios-hll-examples\\\" name=\\\"hero-scenarios-hll-examples\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** develop code examples in at least one dynamically typed language (for example, Python or JavaScript) and one statically typed language (for example, Java or C#) to illustrate your abstractions and high-level language representations.\\r\\n\\r\\n\\u003ca href=\\\"#hero-scenarios-yagni\\\" name=\\\"hero-scenarios-yagni\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** proactively add APIs for speculative features customers might want.\\n\\n### Start with your API Definition\\n\\nUnderstanding how your service is used and defining its model and interaction patterns--its API--should be one of the earliest activities a service team undertakes. It reflects the abstractions \\u0026 naming decisions and makes it easy for developers to implement the hero scenarios.\\r\\n\\r\\n\\u003ca href=\\\"#openapi-description\\\" name=\\\"openapi-description\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** create an [OpenAPI description](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/2.0.md) (with [autorest extensions](https://github.com/Azure/autorest/blob/master/docs/extensions/readme.md)) for the service API. The OpenAPI description is a key element of the Azure SDK plan and is essential for documentation, usability and discoverability of service APIs.\\n\\n## Design for Change Resiliency\\n\\nAs you build out your service and API, there are a number of decisions that can be made up front that add resiliency to client implementations. Addressing these as early as possible will help you iterate faster and avoid breaking changes.\\r\\n\\r\\n\\u003ca href=\\\"#resiliency-enums\\\" name=\\\"resiliency-enums\\\"\\u003e:ballot_box_with_check:\\u003c/a\\u003e **YOU SHOULD** use extensible enumerations. Extensible enumerations are modeled as strings - expanding an extensible enumeration is not a breaking change.\\r\\n\\r\\n\\u003ca href=\\\"#resiliency-conditional-requests\\\" name=\\\"resiliency-conditional-requests\\\"\\u003e:ballot_box_with_check:\\u003c/a\\u003e **YOU SHOULD** implement [conditional requests](https://tools.ietf.org/html/rfc7232) early. This allows you to support concurrency, which tends to be a concern later on.\\n\\n## Use Good Names\\n\\nGood names for resources, properties, operations, and parameters are essential to a great developer experience.\\r\\n\\r\\nResources are described by nouns. Resource and property names must be descriptive and easy for c\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#createproject.md\",\"document_title\":\"Creating a project\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/createproject\",\"content\":\"# getstarted#createproject.md\\n\\n# Creating a project\\n\\nIf you've installed TypeSpec on your local machine, you can create a new TypeSpec project by following these steps:\\r\\n1. **Open your command prompt** (PowerShell, cmd.exe, bash, etc.), create an empty folder for your new project, and `cd` into it.\\r\\n2. If creating a new service in the [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) repository, create the new service folder following our [directory structure guidelines](https://aka.ms/azsdk/spec-dirs).\\r\\n3. To create a new Azure service specification, use the `tsp init` command:\\r\\n```bash\\r\\ntsp init https://aka.ms/typespec/azure-init\\r\\n```\\r\\nYou will be prompted with a few questions regarding the service template, project name, and library updates.\\n\\n### Understanding Project Templates\\n\\nWhen initializing a new project, you'll encounter four templates:\\r\\n| Template Name                                                   | Description                                                                                                                                                                          |\\r\\n| --------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\\r\\n| **(rest-api-spec repo) Azure Data Plane Service Project**       | This template is configured for projects within the `azure-rest-api-specs` repository, with settings that comply with the repo's requirements, such as file paths and linting rules. |\\r\\n| **(rest-api-spec repo) Azure Resource Manager Service Project** | Similar to the above, but tailored for Azure Resource Manager services within the `azure-rest-api-specs` repository.                                                                 |\\r\\n| **(standalone) Azure Data Plane Service Project**               | This template is configured for local use or in a personal repo, allowing for API development without the specific directory structure of the `azure-rest-api-specs` repo.           |\\r\\n| **(standalone) Azure Resource Manager Service Project**         | Similar to the above but designed for Azure Resource Manager services, configured for local use or in a personal repo.                                                               |\\n\\n### Target Users\\n\\n- **Rest-API-Spec Repo Projects**: Ideal for those contributing directly to the Azure REST API specifications, ensuring production-quality SDK generation.\\r\\n- **Standalone Projects**: Suited for API-first development, allowing users to generate OpenAPI specs, service code, and clients without conforming to the specs repo's structure.\\n\\n### Install the dependencies\\n\\nNow that the new project has been created, you can install the dependencies by running the following command:\\r\\n- `npm ci` - If in the `azure-rest-api-specs` repo.\\r\\n- `tsp install` - If a standalone project\\r\\nAfter setting up your project, run `tsp install` to install dependencies. You can then open the file `main.tsp` to continue with the tutorial. Choose the tutorial that matches your chosen project template:\\r\\n| Azure Service Type       | Tutorial                                      | Produces                   |\\r\\n| ------------------------ | --------------------------------------------- | -------------------------- |\\r\\n| Azure Data-Plane Service | [Azure-Core tutorial](azure-core/step01)      | OpenApi 2.0 (Swagger) spec |\\r\\n| Azure Management Service | [ARM tutorial](azure-resource-manager/step00) | OpenApi 2.0 (Swagger) spec |\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#getting-started-rest#03-handling-errors.md\",\"document_title\":\"Handling Errors\",\"document_link\":\"https://typespec.io/docs/getting-started/getting-started-rest/03-handling-errors\",\"content\":\"# getting-started#getting-started-rest#03-handling-errors.md\\n\\n# Handling Errors\\n\\n## Introduction\\n\\nIn this section, we'll focus on handling errors in your REST API. We'll define error models and demonstrate how to add them as possible responses to your CRUD operations.\\n\\n## Why Use Error Models?\\n\\nUsing error models instead of raw status codes offers several advantages:\\r\\n\\r\\n1. **Consistency**: Error models ensure that error responses are consistent across your API. This makes it easier for clients to handle errors predictably.\\r\\n2. **Clarity**: Error models provide clear, structured information about the error, including error codes, messages, and additional details. This helps developers understand what went wrong and how to fix it.\\r\\n3. **Extensibility**: Error models can be extended to include additional information, such as error details, validation issues, or links to documentation. This makes it easier to provide comprehensive error information.\\r\\n4. **Documentation**: Error models improve the generated API documentation by clearly defining the structure of error responses. This helps API consumers understand the possible error responses and how to handle them.\\r\\n5. **Type Safety**: In strongly-typed languages, using error models can provide type safety, ensuring that error responses conform to the expected structure.\\n\\n## Defining Error Models\\n\\nError models can be used to represent different types of errors that your API might return. Let's start by defining some common error models.\\n\\n### Example: Defining Common Error Models\\n\\nWe'll define models to represent validation errors, not-found errors, and internal server errors:\\r\\n\\r\\n```tsp title=main.tsp tryit=\\\"{\\\"emit\\\": [\\\"@typespec/openapi3\\\"]}\\\"\\r\\nimport \\\"@typespec/http\\\";\\r\\n\\r\\nusing Http;\\r\\n\\r\\n@service(#{ title: \\\"Pet Store\\\" })\\r\\n@server(\\\"https://example.com\\\", \\\"Single server endpoint\\\")\\r\\nnamespace PetStore;\\r\\n\\r\\nmodel Pet {\\r\\n  id: int32;\\r\\n\\r\\n  @minLength(1)\\r\\n  name: string;\\r\\n\\r\\n  @minValue(0)\\r\\n  @maxValue(100)\\r\\n  age: int32;\\r\\n\\r\\n  kind: petType;\\r\\n}\\r\\n\\r\\nenum petType {\\r\\n  dog: \\\"dog\\\",\\r\\n  cat: \\\"cat\\\",\\r\\n  fish: \\\"fish\\\",\\r\\n  bird: \\\"bird\\\",\\r\\n  reptile: \\\"reptile\\\",\\r\\n}\\r\\n\\r\\n@route(\\\"/pets\\\")\\r\\nnamespace Pets {\\r\\n  @get\\r\\n  op listPets(): {\\r\\n    @statusCode statusCode: 200;\\r\\n    @body pets: Pet[];\\r\\n  };\\r\\n\\r\\n  @get\\r\\n  op getPet(@path petId: int32): {\\r\\n    @statusCode statusCode: 200;\\r\\n    @body pet: Pet;\\r\\n  } | {\\r\\n    @statusCode statusCode: 404;\\r\\n\\r\\n    // highlight-next-line\\r\\n    @body error: NotFoundError;\\r\\n  };\\r\\n\\r\\n  @post\\r\\n  op createPet(@body pet: Pet): {\\r\\n    @statusCode statusCode: 201;\\r\\n    @body newPet: Pet;\\r\\n  } | {\\r\\n    @statusCode statusCode: 202;\\r\\n    @body acceptedPet: Pet;\\r\\n    // highlight-start\\r\\n  } | {\\r\\n    @statusCode statusCode: 400;\\r\\n    @body error: ValidationError;\\r\\n  };\\r\\n  // highlight-end\\r\\n\\r\\n  @put\\r\\n  op updatePet(@path petId: int32, @body pet: Pet):\\r\\n    | {\\r\\n        @statusCode statusCode: 200;\\r\\n        @body updatedPet: Pet;\\r\\n        // highlight-start\\r\\n      }\\r\\n    | {\\r\\n        @statusCode statusCode: 400;\\r\\n        @body error: ValidationError;\\r\\n      }\\r\\n    | {\\r\\n        @statusCode statusCode: 404;\\r\\n        @body error: NotFoundError;\\r\\n      }\\r\\n    | {\\r\\n        @statusCode statusCode: 500;\\r\\n        @body error: InternalServerError;\\r\\n        // highlight-end\\r\\n      };\\r\\n\\r\\n  @delete\\r\\n  op deletePet(@path petId: int32): {\\r\\n    @statusCode statusCode: 204;\\r\\n  };\\r\\n}\\r\\n\\r\\n// highlight-start\\r\\n@error\\r\\nmodel NotFoundError {\\r\\n  code: \\\"NOT_FOUND\\\";\\r\\n  message: string;\\r\\n}\\r\\n\\r\\n@error\\r\\nmodel ValidationError {\\r\\n  code: \\\"VALIDATION_ERROR\\\";\\r\\n  message: string;\\n\\n}\\r\\n    | {\\r\\n        @statusCode statusCode: 404;\\r\\n        @body error: NotFoundError;\\r\\n      }\\r\\n    | {\\r\\n        @statusCode statusCode: 500;\\r\\n        @body error: InternalServerError;\\r\\n        // highlight-end\\r\\n      };\\r\\n\\r\\n  @delete\\r\\n  op deletePet(@path petId: int32): {\\r\\n    @statusCode statusCode: 204;\\r\\n  };\\r\\n}\\r\\n\\r\\n// highlight-start\\r\\n@error\\r\\nmodel NotFoundError {\\r\\n  code: \\\"NOT_FOUND\\\";\\r\\n  message: string;\\r\\n}\\r\\n\\r\\n@error\\r\\nmodel ValidationError {\\r\\n  code: \\\"VALIDATION_ERROR\\\";\\r\\n  message: string;\\r\\n  details: string[];\\r\\n}\\r\\n\\r\\n@error\\r\\nmodel InternalServerError {\\r\\n  code: \\\"INTERNAL_SERVER_ERROR\\\";\\r\\n  message: string;\\r\\n}\\r\\n// highlight-end\\r\\n```\\r\\n\\r\\nIn this example:\\r\\n\\r\\n- The `NotFoundError`, `ValidationError`, and `InternalServerError` models are defined to represent different types of errors.\\r\\n- The `@error` decorator is used to indicate that these models represent error responses.\\r\\n- The Pet Store operations are updated to return the appropriate error models when the service can't perform the requested operation.\\n\\n## Conclusion\\n\\nIn this section, we focused on defining error handling in your REST API. We introduced error models and demonstrated how to represent different operation response scenarios in TypeSpec.\\r\\n\\r\\nIn the next section, we'll dive into reusing common parameters in your REST API.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"ARM-Auto-SignOff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/ARM-Auto-SignOff\",\"content\":\"# ARM-Auto-SignOff.md\\n\\n## Remaining Work\\n\\n- [ARM Auto SignOff] Update for GA: https://github.com/Azure/azure-rest-api-specs/pull/33440\\n\\n## Test PRs\\n\\n- RM TSP: https://github.com/Azure/azure-rest-api-specs/pull/32545\\r\\n- DP TSP: https://github.com/Azure/azure-rest-api-specs/pull/32694\\n\\n## Issue Queries\\n\\n```\\r\\nbase:main AND\\r\\nis:pr AND\\r\\nis:open AND\\r\\n(label:ARMAutoSignedOff OR\\r\\n (label:TypeSpec AND\\r\\n  label:ARMReview AND\\r\\n  -label:NotReadyForARMReview AND\\r\\n  (-label:SuppressionReviewRequired OR\\r\\n   label:Approved-Suppression)))\\r\\n```\\r\\nhttps://github.com/Azure/azure-rest-api-specs/issues?q=base%3Amain%20AND%20is%3Apr%20AND%20is%3Aopen%20AND%20(label%3AARMAutoSignedOff%20OR%20(label%3ATypeSpec%20AND%20label%3AARMReview%20AND%20-label%3ANotReadyForARMReview%20AND%20(-label%3ASuppressionReviewRequired%20OR%20label%3AApproved-Suppression)))\\r\\n\\r\\nhttps://github.com/Azure/azure-rest-api-specs-pr/issues?q=base%3Amain%20AND%20is%3Apr%20AND%20is%3Aopen%20AND%20(label%3AARMAutoSignedOff%20OR%20(label%3ATypeSpec%20AND%20label%3AARMReview%20AND%20-label%3ANotReadyForARMReview%20AND%20(-label%3ASuppressionReviewRequired%20OR%20label%3AApproved-Suppression)))\\n\\n## Source Code\\n\\n* ARM Incremental TypeSpec\\r\\n  * Determines if PR contains only incremental changes to an existing TypeSpec RP\\r\\n  * https://github.com/Azure/azure-rest-api-specs/blob/main/.github/workflows/arm-incremental-typespec.yaml\\r\\n* ARM Auto SignOff\\r\\n  * Combines results of \\\"ARM Incremental TypeSpec\\\", labels, and checks to determine if PR is eligible for auto sign-off\\r\\n  * https://github.com/Azure/azure-rest-api-specs/blob/main/.github/workflows/arm-auto-signoff.yaml\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"SecurityDefinitionsStructure error on PR\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# SecurityDefinitionsStructure error on PR\\n\\n## question\\n\\nHi,\\r\\nI am seeing this error after adding auth section in my typespec. [Add Azure Health Model Query APIs by vikashy-microsoft · Pull Request #22787 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/22787/checks?check_run_id=42815390637)\\r\\nThe structure looks correct to me except casing for \\\"azure_auth\\\" which is in pascal case \\\"AzureAuth\\\". Am I missing something?\\r\\n \\r\\nI also see some typespec validation failures, I don't see any errors locally when I run `npx tsv .\\\\specification\\\\cloudhealth\\\\CloudHealth.HealthModels.Data`, how can I debug that further? [Add Azure Health Model Query APIs · Azure/azure-rest-api-specs-pr@cfc193c](https://github.com/Azure/azure-rest-api-specs-pr/actions/runs/15220602300/job/42815390614)\\n\\n## answer\\n\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\\r\\n![image](https://github.com/jianingwang123/test/blob/main/image/image%20(11).png?raw=true)\\r\\nyou need to run \\\"tsp format\\\" (which is handled by \\\"npx tsv\\\") and commit the results\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"TypeSpec Validation failed\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# TypeSpec Validation failed\\n\\n## question\\n\\nIn this [PR](https://github.com/Azure/azure-rest-api-specs/pull/34282), [TypeSpec Validation](https://github.com/Azure/azure-rest-api-specs/actions/runs/15438271648/job/43449735963?pr=34282) failed. I cannot repro in my local machine.\\n\\n## answer\\n\\nRepros locally for me on linux.  Follow instructions here: https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\\r\\n \\r\\nProblem is PR isn't using consistent casing in filenames.\\r\\n```\\r\\n$ git status\\r\\nUntracked files:\\r\\n  (use \\\"git add \\u003cfile\\u003e...\\\" to include in what will be committed)\\r\\n        specification/powerbidedicated/resource-manager/Microsoft.PowerBIDedicated/\\r\\n \\r\\n$ ls specification/powerbidedicated/resource-manager\\r\\nMicrosoft.PowerBIdedicated  readme.go.md  readme.nodejs.md  readme.typescript.md\\r\\nMicrosoft.PowerBIDedicated  readme.md     readme.python.md\\r\\n```\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#generate-with-tsp-client#repo_setup.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/generate-with-tsp-client/repo_setup\",\"content\":\"# Repo setup\\nEach repository that intends to support `tsp-client` for generating and updating client libraries will need to set up an `emitter-package.json` file under the `eng/` directory at the root of the repository. Client libraries generated with this tool will be outputted based on the information in the tspconfig.yaml file of the TypeSpec specification. The service directory is specified through the `parameters.service-dir.default` parameter in the tspconfig.yaml, additionally the `emitter-output-dir` option for the specific emitter is appended to the end of the path.\\r\\n\\r\\nSee the following example of a valid tspconfig.yaml file: https://github.com/Azure/azure-rest-api-specs/blob/main/specification/contosowidgetmanager/Contoso.WidgetManager/tspconfig.yaml\\r\\n\\r\\nUsing the tspconfig.yaml linked above, by default, the client libraries will be generated in the following directory for C#: `\\u003crepo\\u003e/sdk/contosowidgetmanager/Azure.Template.Contoso/`.\"},{\"document_source\":\"azure-sdk-guidelines\",\"document_filename\":\"cpp_introduction.html\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/azure-sdk/cpp_introduction.html\",\"content\":\"# C++ Guidelines: Introduction\\n## Azure SDK API Design {#cpp-api}\\n### Namespaces {#cpp-namespace-naming}\\nrequirement/MAY id=\\\"cpp-design-internal-types-change\\\" %} introduce breaking changes to internal types as long as those breaking changes will not break existing Azure SDK clients.\\r\\n\\r\\n{% include requirement/MAY id=\\\"cpp-design-internal-types-public-exception1\\\" %} *reference* internal types in public headers.\\r\\n\\r\\n{% include requirement/MAY id=\\\"cpp-design-internal-types-public-exception2\\\" %} include template specializations for internal templates in public headers to simplify the implementation.\\r\\n\\r\\nNOTE: Since these types are typically located in the `azure-core` package, care must be made when introducing breaking changes to these types, and when adding new internal types. For changes to the types, the `azure-core` implementation typically has to be released *before* any Azure SDK packages can take dependencies on those types.\\r\\n\\r\\nIn addition, it is critical to realize that the only dependencies between Azure SDK packages is a \\u003e= dependency. That means that a particular version of an existing Azure SDK package is expected to work with any future versions of other Azure SDK packages, even of those packages on which it depends. That means that any breaking changes to internal types MUST be upward compatible.\\r\\n\\r\\n##### Private types\\r\\n\\r\\nPrivate types  are types located in a `_detail` namespace. Private types are only intended to be called within a single package, and follow the following requirements:\\r\\n\\r\\n{% include requirement/MUSTNOT id=\\\"cpp-design-private-types-in-headers\\\" %} define private types in public Azure SDK headers.\\r\\n\\r\\n{% include requirement/MUSTNOT id=\\\"cpp-design-private-types-private\\\" %} consume internal types outside the package in which they are defined.\\r\\n\\r\\n{% include requirement/SHOULD id=\\\"cpp-design-private-types-private-location\\\" %} declare and/or define private types under a `private` directory.\\r\\n\\r\\n{% include requirement/MAY id=\\\"cpp-design-private-types-private-no-guarantees\\\" %} modify private types without fear of introducing breaking changes.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# TypeSpec\\n## `XmsEnumValidation`\\nTypeSpec using `OAuth2Auth` may generate the following OpenAPI:\\r\\n``` yaml\\r\\n\\\"type\\\": {\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"description\\\": \\\"OAuth2 authentication\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"oauth2\\\"\\r\\n  ]\\r\\n},\\r\\n```\\r\\n\\r\\nWhich causes error `XmsEnumValidation`.  The recommended workaround is to add `omit-unreachable-types: true` to your `tspconfig.yaml`.\\r\\n\\r\\n## `XmsPageableForListCalls`\\r\\nIf `XmsPageableForListCalls` are failing for OpenAPI generated from TypeSpec using `@singleton` (OpenAPI path ends with `/default`), we believe this is a false positive: https://github.com/Azure/azure-openapi-validator/issues/646\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"libraries#typespec-client-generator-core#reference#data-types.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/libraries/typespec-client-generator-core/reference/data-types\",\"content\":\"# Data types\\n## Azure.ClientGenerator.Core\\n### `Access` {#Azure.ClientGenerator.Core.Access}\\nAccess value.\\r\\n```typespec\\r\\nenum Azure.ClientGenerator.Core.Access\\r\\n```\\r\\n| Name     | Value        | Description    |\\r\\n| -------- | ------------ | -------------- |\\r\\n| public   | `\\\"public\\\"`   | Open to user   |\\r\\n| internal | `\\\"internal\\\"` | Hide from user |\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-spec-gen-sdk-config.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-spec-gen-sdk-config\",\"content\":\"# SDK generation configuration\\n## Enable SDK generation\\n### [TypeSpec](#tab/typespec)\\nAdd the specific SDK language emitter settings to `tspconfig.yaml`. For example, to generate CSharp SDK code from your TypeSpecs:\\r\\n\\r\\n1. Add `@azure-tools/typespec-csharp` to the `options` settings in `tspconfig.yaml`.\\r\\n2. Refer to the 'ContosoWidgetManager' samples to set the default values for each SDK language emitter:\\r\\n    - For management plane TypeSpecs, refer to [Contoso.Management tspconfig.yaml](https://aka.ms/azsdk/tspconfig-sample-mpg).\\r\\n    - For data plane TypeSpecs, refer to [Contoso.WidgetManager tspconfig.yaml](https://aka.ms/azsdk/tspconfig-sample-dpg).\\r\\n\\r\\n````\\r\\n\\\"@azure-tools/typespec-csharp\\\":\\r\\n    flavor: azure\\r\\n    package-dir: \\\"Azure.ResourceManager.Contoso\\\"\\r\\n    clear-output-folder: true\\r\\n    model-namespace: true\\r\\n    namespace: \\\"{package-dir}\\\"\\r\\n````\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#code-generation-csharp.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/getting-started/code-generation-csharp\",\"content\":\"# Getting started with TypeSpec server code generation for C#\\n## 3. Understanding the default TypeSpec service\\nThe `main.tsp` file contains a default \\\"Widget Service\\\" example that defines:\\r\\n\\r\\n```typespec\\r\\nimport \\\"@typespec/http\\\";\\r\\n\\r\\nusing TypeSpec.Http;\\r\\n@service(#{ title: \\\"Widget Service\\\" })\\r\\nnamespace DemoService;\\r\\n\\r\\nmodel Widget {\\r\\n  id: string;\\r\\n  weight: int32;\\r\\n  color: \\\"red\\\" | \\\"blue\\\";\\r\\n}\\r\\n\\r\\nmodel WidgetList {\\r\\n  items: Widget[];\\r\\n}\\r\\n\\r\\n@error\\r\\nmodel Error {\\r\\n  code: int32;\\r\\n  message: string;\\r\\n}\\r\\n\\r\\nmodel AnalyzeResult {\\r\\n  id: string;\\r\\n  analysis: string;\\r\\n}\\r\\n\\r\\n@route(\\\"/widgets\\\")\\r\\n@tag(\\\"Widgets\\\")\\r\\ninterface Widgets {\\r\\n  /** List widgets */\\r\\n  @get list(): WidgetList | Error;\\r\\n  /** Read widgets */\\r\\n  @get read(@path id: string): Widget | Error;\\r\\n  /** Create a widget */\\r\\n  @post create(@body body: Widget): Widget | Error;\\r\\n  /** Update a widget */\\r\\n  @patch update(@path id: string, @body body: Widget): Widget | Error;\\r\\n  /** Delete a widget */\\r\\n  @delete delete(@path id: string): void | Error;\\r\\n\\r\\n  /** Analyze a widget */\\r\\n  @route(\\\"{id}/analyze\\\") @post analyze(@path id: string): AnalyzeResult | Error;\\r\\n}\\r\\n```\\r\\n\\r\\nThis defines:\\r\\n\\r\\n- A `Widget` model with properties for id, weight, and color\\r\\n- A REST API with standard CRUD operations (list, read, create, update, delete)\\r\\n- A special `analyze` operation for widgets\\r\\n\\r\\nThe `tspconfig.yaml` file configures your emitters:\\r\\n\\r\\n```yaml\\r\\nemit:\\r\\n  - \\\"@typespec/openapi3\\\"\\r\\n  - \\\"@typespec/http-server-csharp\\\"\\r\\noptions:\\r\\n  \\\"@typespec/openapi3\\\":\\r\\n    emitter-output-dir: \\\"{output-dir}/schema\\\"\\r\\n    openapi-versions:\\r\\n      - 3.1.0\\r\\n  \\\"@typespec/http-server-csharp\\\":\\r\\n    emitter-output-dir: \\\"{output-dir}/server/generated\\\"\\r\\n```\\r\\n\\r\\nThis configuration:\\r\\n\\r\\n- Generates OpenAPI 3.1.0 schema in the `tsp-output/schema` directory\\r\\n- Generates C# server code in the `tsp-output/server/generated` directory\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#rest-api-publish#buildpipelines.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/rest-api-publish/buildpipelines\",\"content\":\"# Using Build Pipelines with TypeSpec\\nThis doc will help you get started with using TypeSpec in your build pipelines in your own repository. [See here for more how to use in the azure-rest-api-specs repo](./checking-in-api-specs-guide.md)\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Folder-Structure.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Folder-Structure\",\"content\":\"# Versions\\n## Version 2\\n### Sample\\nhttps://github.com/Azure/azure-rest-api-specs/tree/main/specification/widget\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Folder-Structure.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Folder-Structure\",\"content\":\"# Versions\\n## Version 1\\n### Sample\\nhttps://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager\"},{\"document_source\":\"azure_sdk_for_go_docs\",\"document_filename\":\"development#ARM#new-version-quickstart.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-sdk-for-go/blob/main/documentation/development/ARM/new-version-quickstart.md\",\"content\":\"# Getting Started - New Azure Go SDK\\n## Prerequisites\\nYou will need [supported](https://github.com/Azure/azure-sdk-for-go/blob/main/README.md#go-version-support) version of Go and latest version of resource management modules.\\r\\n\\r\\nYou will need to authenticate to Azure either by using Azure CLI to sign in or setting environment variables.\"},{\"document_source\":\"azure_sdk_for_python_docs\",\"document_filename\":\"dev#sample_guide.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/sample_guide.md\",\"content\":\"# Samples, Snippets, and How-To Guides\\nDevelopers like to learn by looking at code, and so the Azure SDK comes with a myriad of code samples in the form of short code snippets, sample applications, and how-to guides. This document describes where to find all these resources.\"},{\"document_source\":\"azure_sdk_for_python_docs\",\"document_filename\":\"dev#issues#resolve_issues_effectively.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-sdk-for-python/blob/main/doc/dev/issues/resolve_issues_effectively.md\",\"content\":\"# Resolve Issues Effectively\\n## Feature Request (For users)\\nPython SDKs are automatically generated based on REST API, so we generally do not recommend modifying SDK code manually. If you need a new function, but the SDK does not provide it, you need to open an issue in the [REST API repository](https://github.com/Azure/azure-rest-api-specs/issues) to describe clearly the feature you want.\"},{\"document_source\":\"azure-sdk-guidelines\",\"document_filename\":\"policies_adoption.html\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/azure-sdk/policies_adoption.html\",\"content\":\"# Policies: Guideline Adoption\\n## Engineering systems policy changes\\nThe engineering systems policies (which includes everything under the `/docs/policies` folder within the `azure/azure-sdk` repository) are also proposed via PR and subject to review:\\r\\n\\r\\n* PR is reviewed with relevant stake holders, as determined by the engineering systems dev lead (such as service teams, security, and CSS).\\r\\n* PR is approved by the engineering systems dev lead or designate.\\r\\n* If the proposal affects client libraries in a specific language, then the proposal must also be approved by the language dev lead.\"},{\"document_source\":\"azure-sdk-guidelines\",\"document_filename\":\"dotnet_implementation.html\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/azure-sdk/dotnet_implementation.html\",\"content\":\"# C#.NET Guidelines: Implementation\\n## API Implementation\\nThis section describes guidelines for implementing Azure SDK client libraries. Please note that some of these guidelines are automatically enforced by code generation tools.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"support#troubleshoot#PR-failing.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/support/troubleshoot/PR-failing\",\"content\":\"# I've submitted a pull request, but the build isn't succeeding or tests are failing!\\n\\u003e [!NOTE]\\r\\n\\u003e If you are looking for help with a PR submitted to one of [the Azure REST API specs repositories](xref:api-repos),\\r\\n\\u003e please refer to [this support page](xref:support#get-help-with-prs-submitted-against-the-azure-rest-api-specification-repositories).\\r\\n\\r\\nCongratulations! You've submitted a pull request. As part of the pull request approval process we ensure that the code\\r\\nbuild and tests successfully, as well as performing a range of other validation steps. Generally speaking the build\\r\\nerrors associated with the pipeline run are sufficient to diagnose and fix any issues with your PR. You can access\\r\\nthe build logs by clicking on the failing check run, and then using the view details link to navigate to the error in\\r\\nAzure Pipelines.\\r\\n\\r\\nIf you cannot understand the reason for the failure, ask a question in the _language team_ channel appropriate to the\\r\\nrepository that you are working in. Each language team is the first point of contact for build failures within their\\r\\nrepository.\\r\\n\\r\\nReach to the [language specific Team's channel](xref:support#get-help-with-the-azure-sdks-development).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"faqs#faqs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/faqs/faqs\",\"content\":\"# Azure SDK frequently asked questions\\n## TypeSpec / OpenAPI specs\\nThis FAQ pertains to generic questions about TypeSpec / OpenAPI specifications. If you have a question related\\r\\nto your PR updating such specifications, see [Azure REST API specs PRs FAQ](#azure-rest-api-specs-prs).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-repos.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-repos\",\"content\":\"# Azure REST API specs repositories on GitHub\\n## Publishing your spec to the spec repos\\nTo publish your spec to the API specs repositories, you must first understand what kind of API version you are\\r\\ntrying to publish and make a PR to appropriate branch based on that. Read about this in [this article](xref:pr-move-private-to-public).\\r\\n\\r\\n\\u003c!-- links --\\u003e\\r\\n[Azure/azure-rest-api-specs]: https://github.com/Azure/azure-rest-api-specs\\r\\n[Azure/azure-rest-api-specs-pr]: https://github.com/Azure/azure-rest-api-specs-pr\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"onboard#access.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/onboard/access\",\"content\":\"## Request access to Azure REST API and SDK repositories\\n### Request access to REST API or SDK repositories\\nIf you are working on your [REST API spec](xref:api-repos) or building client libraries (SDKs) for your service you will\\r\\nneed to request the appropriate permissions needed for that work.\\r\\n\\r\\nThese permissions control access to the repositories such as `Azure/azure-rest-api-specs[-pr]` or `Azure/azure-sdk-for-[lang][-pr]`.\"}]",
            "inputs.latency": 846.3710401058197,
            "inputs.response_length": 2104,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://eng.ms/docs/products/azure-developer-experience/design/api-spec-gen-sdk-config",
                "https://azure.github.io/azure-sdk/dotnet_implementation.html",
                "https://eng.ms/docs/products/azure-developer-experience/faqs/faqs",
                "https://eng.ms/docs/products/azure-developer-experience/support/troubleshoot/PR-failing"
            ],
            "inputs.testcase": "SDK Validation - .NET",
            "outputs.similarity.similarity": 3.0,
            "outputs.similarity.gpt_similarity": 3.0,
            "outputs.similarity.similarity_result": "fail",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 3749,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 3750,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: SDK Validation - .NET\\\\n\\\\nquestion: I have an open PR [inital genome api spec by samira-farhin \\\\u00b7 Pull Request #25097 \\\\u00b7 Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/25097) that's currently failing on [SDK Validation - .NET - PR](https://github.com/Azure/azure-rest-api-specs-pr/pull/25097/checks?check_run_id=53550607849). My latest changes to resolve SDK Validation in \\\\\\\"tspconfig.yaml\\\\\\\" are included below. After these updates, the SDK validation issues for Go and Java were resolved, but the C# issue still remains. I'm unsure what else needs to be addressed.\\\\n[inital genome api spec by samira-farhin \\\\u00b7 Pull Request #25097 \\\\u00b7 Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/25097/commits/85af075feeb98889d8dc27bdd838d409239f5eab)\\\\n[inital genome api spec by samira-farhin \\\\u00b7 Pull Request #25097 \\\\u00b7 Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/25097/commits/a43851cea6c490ee183943383e817d882b85be23)\\\\n```\\\\ncommand\\\\u2003\\\\u2003pwsh ./eng/scripts/Automation-Sdk-Init.ps1 ../azure-sdk-for-net-pr_tmp/initInput.json ../azure-sdk-for-net-pr_tmp/initOutput.json\\\\ncommand\\\\u2003\\\\u2003pwsh ./eng/scripts/Invoke-GenerateAndBuildV2.ps1 ../azure-sdk-for-net-pr_tmp/generateInput.json ../azure-sdk-for-net-pr_tmp/generateOutput.json\\\\ncmdout\\\\u2003\\\\u2003[.Net] Start to call tsp-client to generate package:Azure.ResourceManager.Genome\\\\ncmdout\\\\u2003\\\\u2003[.Net] Start to build sdk project: /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=netstandard2.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(69,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/Extensions/MockableGenomeSubscriptionResource.cs(99,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(270,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net] /mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Generated/GenomeAccountCollection.cs(300,20): error CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level [/mnt/vss/_work/1/s/azure-sdk-for-net-pr/sdk/genome/Azure.ResourceManager.Genome/src/Azure.ResourceManager.Genome.csproj::TargetFramework=net8.0]\\\\ncmdout\\\\u2003\\\\u2003[.Net]     8 Error(s)\\\\ncmdout\\\\u2003\\\\u2003[.Net] [ERROR] Failed to build the sdk project: Azure.ResourceManager.Genome for service: genome. Exit code: False. Please review the detail errors for potential fixes. If the issue persists, contact the DotNet language support channel at https://aka.ms/azsdk/dotnet-teams-channel and include this spec pull request.\\\\n```\\\", \\\"response\\\": \\\"Your .NET SDK validation errors (CS0122: 'GeneratorPageableHelpers' is inaccessible due to its protection level) are caused by a code generation issue: the TypeSpec C# emitter is referencing an internal (non-public) helper type, which results in build failures when the generated code tries to use it.\\\\n\\\\nThis is not a spec modeling or tspconfig.yaml configuration problem\\\\u2014it's an emitter/tooling issue. In particular, the Azure ResourceManager C# SDK generator sometimes emits calls to helper classes (like GeneratorPageableHelpers) that are internal and therefore inaccessible to the generated public code.\\\\n\\\\n**Recommended Actions:**\\\\n\\\\n1. **Do not attempt to workaround this by changing your TypeSpec or tspconfig.yaml**\\\\u2014these errors are not fixable at the spec/config level.\\\\n2. **Contact the .NET SDK tooling team** as directed in the error output:\\\\n   - Use the DotNet language support channel: https://aka.ms/azsdk/dotnet-teams-channel\\\\n   - Reference your PR and the specific error details. This is a known issue with the C# ResourceManager emitter and needs their intervention.\\\\n3. If your repo is missing required emitter/tool updates, check that you are using the latest version of `@azure-tools/typespec-csharp` in your `tspconfig.yaml` options, and that your repo has up-to-date build scripts. However, if Go and Java are passing and only .NET fails, this is almost certainly a .NET emitter bug.\\\\n\\\\n**Summary:**\\\\n- You cannot resolve this error by modifying your spec or config.\\\\n- The .NET generator is emitting calls to internal helpers. This must be fixed in the generator/emitter, not your repo.\\\\n- Contact the .NET team per the instructions for resolution.\\\\n\\\\nIf you want to double-check your tspconfig.yaml settings, you can refer to the Contoso sample for management plane emitters (see reference below), but this will not resolve internal visibility errors.\\\\n\\\\n**Next Steps:**\\\\n- Report the error and your PR to the DotNet support channel for a fix or workaround.\\\\n- Once the emitter is patched, re-run validation/build.\\\\n\\\\nFor more on SDK generation config and emitter settings, see the references below.\\\", \\\"ground_truth\\\": \\\"First, your PR is to branch `main` of repo `specs-pr`.  Such PRs can be used to preview check results, but they cannot be merged.  Did you intend to open a PR to `RPSaaSMaster` or the public `specs` repo?\\\\nSecond, `check SDK Validation - .NET - PR` is not required, so you can merge a PR with it failing, if you are OK with it failing.  If you want support on the check failure:\\\\nDocs: https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Validation\\\\nTeams: [Code Generation - .NET | Azure SDK | Microsoft Teams](https://teams.microsoft.com/l/channel/19%3Aacbd512e57bd475198ea6bf4564599e3%40thread.skype/Code%20Generation%20-%20.NET?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"
        },
        {
            "inputs.query": "title: PR Review for GalleryRP 2025-03-03 Release\n\nquestion: Hello Team! Running into some issues with BreakingChange-Go-Sdk and BreakingChange-Javascript-Sdk labels on two PRs that we are trying to approve for the GalleryRP 2025-03-03 Release. I'm not sure if this is the right channel to be asking in but we need these Breaking Changes approved before moving forward with the Release, thank you for the help!\nThe links to the PRs are as follows:\nIntroducing New Resource Type - Gallery Scripts found [here](https://github.com/Azure/azure-rest-api-specs/pull/35887)\nAdding New Property StorageAccountStrategy found [here](https://github.com/Azure/azure-rest-api-specs/pull/35769)\n```\nGitHub Notifications\nPull Request | Azure/azure-rest-api-specs #35887\nNew resource type - Gallery Scripts\nARM (Control Plane) API Specification Update Pull Request\ngrizzlytheodore wants to merge 18 commits from galleryTsp-GalleryScript into feature/cplat-2025-03-03-tsp\n```",
            "inputs.ground_truth": "both your PRs are to a feature branch (feature/cplat-2025-03-03-tsp), which has no required checks.  you will need to get these breaking changes reviewed when you try to merge to a release branch like main or RPSaaSMaster.\nhttps://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md#sdk-breaking-change-review",
            "inputs.response": "Based on the Azure SDK and API guidelines, the BreakingChange-Go-Sdk and BreakingChange-Javascript-Sdk labels are applied automatically when a PR introduces breaking changes for those SDK languages. According to the suppression process documented in the Azure REST API Specs Wiki and SDK Breaking Changes guidelines, the next steps are:\n\n1. You (the PR author or service team) must create a `sdk-suppressions.yaml` file in your TypeSpec project root (the same directory as your `tspconfig.yaml`). This file should list all the SDK breaking changes that are flagged by the validation pipeline. \n2. To find the specific breaking changes that need suppression, download the pipeline artifact named `*-gen-result.html` (spec-gen-sdk logs) from the CI build. Look for the `Absent SDK breaking changes suppressions` section in the HTML report and copy each item into your suppression file under the respective language.\n3. Example format for `sdk-suppressions.yaml`:\n\n```yaml\nsuppressions:\n  azure-sdk-for-go:\n    - package: 'sdk/resourcemanager/compute/armcompute'\n      breaking-changes:\n        - Function `*GalleryScriptsClient.BeginCreateOrUpdate` has been removed\n        - Function `*GalleryScriptsClient.NewListPager` has been removed\n  azure-sdk-for-js:\n    - package: '@azure/arm-compute'\n      breaking-changes:\n        - Method `GalleryScriptsClient.createOrUpdate` has changed signature\n```\n\n4. Commit and push this suppression file as part of your PR. The bot will then add the suppression labels (e.g., `BreakingChange-Go-Sdk-Suppression` and `BreakingChange-JavaScript-Sdk-Suppression`) to your PR.\n5. The SDK reviewers will evaluate your suppressions and either approve or provide feedback. Once approved, the labels will change to `...Suppression-Approved` and you may proceed with the release.\n\nIf you need a reference or step-by-step instructions, see the [SDK-Breaking-Changes.md](https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Breaking-Changes) wiki.\n\n**Note:** Suppression is only recommended when you cannot update your API design to remove the breaking changes. The preferred path is to update the TypeSpec and API design so the breaking changes do not occur.\n\nIf you have already created the suppression file and still see issues, ensure you have the correct suppression format and that it covers all items flagged by the pipeline. If suppressions are missing, the CI will block the PR until addressed.\n\nIf you need further help, provide the list of breaking changes from the CI logs and your current suppression file content for review.",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"Create a PR against main\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\\n\\n# Create a PR against main\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nWhen you're ready for a final review, it's time to create a pull request (PR) from your release branch you created\\r\\noriginally to the `main` branch on [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n* :warning: Do not merge `main` or other release branches unless you know there are changes required.\\r\\n* :white_check_mark: Rebase on `main` if changes are required in a separate topic branch.\\n\\n## Clean PR against main\\n\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\\n\\n## Update your branch with changes from main\\n\\nIf you know there are other changes in the `main` branch or that other services have updated shared files in `main`\\r\\nalready and you need to pick up changes before merging, we recommend you take a merge from main. This is particularly interesting\\r\\nfor common infrastructure changes that are committed in the repo (i.e. github actions, tools, etc). Depending on how old your\\r\\nbranch is some of the pull request checks may not correctly function without taking a merge from main. \\r\\n\\r\\nIf you are working in a non-protected branch you can do a `git merge main` like you would normally do a merge and then push\\r\\nyour changes to your remote branch. However, if you are working in a branch with branch protection enabled (i.e. `release-*`) then\\r\\nyou will need to make a pull request to your branch with the merge. Depending on how out-of-date your branch is from `main` your \\r\\nmerge may have a lot of unwanted and unnecessary changes and the checks not pass. In such cases see below on how to [update the infrastructure](#updating-only-the-infrastructure-changes-from-main).\\n\\n### Updating only the infrastructure changes from main\\n\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\\n\\n## Next steps\\n\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# design#specs-pr-guides#pr-brch-deep.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-brch-deep](https://aka.ms/azsdk/pr-brch-deep) |\\r\\n| --- | --- |\\n\\n# Deep-dive into breaking changes on spec PRs\\n\\n## Important information about this article\\n\\nThis article provides a deep-dive into breaking changes on spec PRs. It applies if your spec PR has\\r\\n`BreakingChangeReviewRequired` or `VersioningReviewRequired` label.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e This is an advanced deep-dive. If your PR is blocked on breaking changes or versioning issues, you should always\\r\\n\\u003e start by following the guidance at [aka.ms/brch].\\n\\n### Prerequisites\\n\\nThis article assumes you are familiar with [API versions and branches](xref:api-versions-and-branches).\\n\\n### Video overview and slides\\n\\nFor video overview of the breaking changes process, see this [Azure Core Day of Learning talk from March 6, 2024].\\r\\nSlides for the talk are available [here][talk slides].\\n\\n### Summary\\n\\nPer the [PR diagram], the first step of getting your specs PR approved is ensuring your PR obeys the  \\r\\n[Azure Versioning and Breaking Changes Policy]. Relevant details of this policy follow.\\r\\n\\r\\n- Once published, no changes to given API version are allowed, except when fixing the spec to match\\r\\nactual implementation (see the `-Approved-BugFix` labels in this doc).\\r\\nThis applies regardless of whether the API version is for `private preview`, `public preview`, or `GA`.\\r\\n- When introducing a new API version (any `preview` or `GA`), the new API version must be backwards compatible with\\r\\nthe previous, latest `GA` API version.\\r\\n- During a (`private` or `public`) `preview` cycle, a new `preview` API version does not have to be backwards\\r\\ncompatible with the previous `preview` API version.\\r\\n- The rules listed above are checked by automated GitHub checks. The exact ruleset is given in [`oadMessagesRuleMap.ts`].\\r\\nDetails follow.\\n\\n## Breaking changes and versioning issues\\n\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\\n\\n### `BreakingChangeReviewRequired` label\\n\\nThe label `BreakingChangeReviewRequired` is added to your PR if the tooling detects a change that could\\r\\nbe breaking for customers. This can happen in two cases:\\r\\n\\r\\n- In your PR you have possibly introduced a breaking change in a new API version, placed in a new folder,\\r\\nas compared to most recent previous `GA`.\\r\\nThe new API version can be either `preview` or `GA`.\\r\\n  - For example, an existing `GA` API version in leaf folder of `2023-11-15`\\r\\nmay contain API route of `GET .../resoruces/{resourceName}`, but a new `preview` API version of `2024-03-15-preview`\\r\\nmay no longer have this route (REST API path), because you are removing the `resoruces` typo and instead introducing\\r\\n`GET .../resources/{resourceName}` route.\\r\\n- In your PR you are modifying existing `GA` API version in-place. For example, you have recently released\\r\\n`2024-03-18` API version and realized you made a typo and are editing the contents of the leaf folder `2024-03-18`\\r\\ncontaining that API version.\\n\\n### `VersioningReviewRequired` label\\n\\nThe label `VersioningReviewRequired` denotes that your PR has a **versioning issue** possibly violating the  \\r\\n[Azure Versioning and Breaking Changes Policy]. This happens when you made a **non-breaking change**,\\r\\naka **compatible change** to an API version that was already published (merged to a production branch).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e According to [the policy][Azure Versioning and Breaking Changes Policy], compatible (non-breaking changes) are not\\r\\n\\u003e allowed within an existing API version. You must create a new API version. Otherwise, we would confuse our customers\\r\\n\\u003e by having to explain \\\"which version of given API version\\\" has a particular change/feature.\\r\\n\\r\\n`VersioningReviewRequired` label is added by automation if:\\r\\n\\r\\n- You made any compatible changes **within** any API version, `GA` or `preview`.\\r\\n- You made any breaking changes in a `preview` API version.\\r\\n\\r\\nIf your PR has both breaking changes and versioning issues, only `BreakingChangeReviewRequired` label\\r\\nis added to it.\\n\\n### In case there is no latest GA API version\\n\\nIf there is no latest GA OpenAPI spec, then the the cross-version check is instead comparing to\\r\\nlatest available preview if it more than 1 year old.\\r\\n\\r\\nIf neither a GA API version or at least 1 year old preview version exists, then the cross-version check automatically\\r\\npasses.\\n\\n### Diagram explaining breaking changes and versioning issues\\n\\nThe logic for automation adding `BreakingChangeReviewRequired` and `VersioningReviewRequired` labels explained above\\r\\ncan be summarized in the following diagram:\\r\\n\\r\\n![Breaking Changes Confusion Matrix](../../img/breaking_changes_confusion_matrix.png)\\n\\n## Addressing `BreakingChangeReviewRequired`\\n\\nIf your PR is labelled with `BreakingChangeReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the breaking changes in your PR are acceptable, they will be\\r\\napproved by one of these labels:\\n\\n### `BreakingChange-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `BreakingChange-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-UserImpact`\\n\\n- The spec PR describes actual breaking changes to the service.\\r\\n- This is the only case that triggers customer notifications, a 3 year migration period (possibly shorter), etc.\\r\\n- Within this set, the changes may be distinguished further for security or legal compliance, which may be granted\\r\\na shorter migration period.\\r\\n- Details at [aka.ms/brch].\\n\\n### `BreakingChange-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Addressing `VersioningReviewRequired`\\n\\nIf your PR is labelled with `VersioningReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the versioning issue in your PR caused by non-breaking (compatible)\\r\\nchanges is acceptable, the board will approve it by one of these labels:\\n\\n### `Versioning-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `Versioning-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-PrivatePreview`\\n\\nThe API version change that triggered the review is in `private preview`, and non-breaking changes are permitted\\r\\nin the same API version during `private preview`.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-PrivatePreview` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Common misconceptions\\n\\n### FALSE: compatible (non-breaking) changes are allowed in published API versions\\n\\n**Why?**\\r\\n\\r\\nAn API version is a contract, and once the contract is published it cannot be changed.\\r\\nOtherwise, it would create customer confusion about \\\"which version of this API version\\\" are they using.\\r\\n\\r\\nAny change of this kind w\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Breaking-Changes.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Breaking-Changes\",\"content\":\"# SDK-Breaking-Changes.md\\n\\n| Short Link: | [aka.ms/azsdk/sdk-suppression](https://aka.ms/azsdk/sdk-suppression) |\\r\\n|--|--|\\n\\n# Table of Contents\\n\\n- [Overview](#overview)\\r\\n- [How to Suppress the SDK Breaking Changes](#how-to-suppress-the-sdk-breaking-changes)\\r\\n- [How Does the Suppression Work](#how-does-the-suppression-work)\\r\\n- [How to Get the Suppression Reviewed](#how-to-get-the-suppression-reviewed)\\n\\n## Overview\\n\\nWhen a specification pull request has breaking change for a specific SDK language, such as `Go`, the pull request will be labelled with \\\"BreakingChange-Go-Sdk\\\". According to [the design principles of Azure SDK](https://azure.github.io/azure-sdk/general_introduction.html#dependable), breaking changes are more harmful to a user’s experience than most new features and improvements are beneficial. Therefore, the pull request author will be strongly encouraged to update the API specification to remove the breaking changes for the SDK. If the breaking change cannot be mitigated by a specification change, the author will need to suppress the breaking changes and have the suppression reviewed. See the following section for details on how to suppress breaking changes.\\r\\n\\r\\nOnce the suppression is added to the pull request, SDK reviewers will evaluate the suppressions and either provide feedback or approve the suppressions. When the suppressions have been approved, the SDK breaking change review is complete and the pull request can proceed to the next stage.\\r\\n\\r\\n\\u003e Note: both the suppressions review and the SDK breaking change review will be conducted proactively by SDK reviewers, and the expected completion time is around 48 business hours.\\n\\n## How to Suppress the SDK Breaking Changes\\n\\nTo suppress SDK breaking changes, go to the `SDK Validation *` CI check result for a specific SDK language, such as \\\"SDK Validation - Go\\\". Click on the link of **View more details on Azure Pipelines** to browse to the azure pipeline result page. Then download the artifact of **spec-gen-sdk logs**. There is a html report with the name ended by \\\"-gen-result.html\\\". Open the html report then look for the `Absent SDK breaking changes suppressions` section, as shown in the following code block:\\r\\n\\r\\n```yaml\\r\\nAbsent SDK breaking changes suppressions\\r\\n- Function `*LinkerClient.BeginCreateOrUpdate` has been removed\\r\\n- Function `*LinkerClient.NewListPager` has been removed\\r\\n```\\r\\n\\r\\n\\u003e Note: refer to https://aka.ms/azsdk/sdk-automation-faq to download the html report.\\n\\n### Next Steps\\n\\n1. The pull request authors create a file called `sdk-suppressions.yaml` if it doesn't already exist in your service folder in the `azure-rest-api-specs` repository.\\r\\n    - For TypeSpec scenarios, `sdk-suppressions.yaml` should be placed in the root folder of the TypeSpec project, which also contains the `tspconfig.yaml` file. For example, refers to the location for [Contoso.Management](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/Contoso.Management).\\r\\n    - For OpenAPI scenarios, `sdk-suppressions.yaml` should be placed in the `{service}\\\\resource-manager` folder. For example, see the location for the [contosowidgetmanager resource provider](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/resource-manager).\\r\\n\\r\\n2. The pull request authors copy every line under the `Absent SDK breaking changes suppressions` section to the suppression file in the following format:\\r\\n\\r\\n``` yaml\\r\\nsuppressions:\\r\\n  azure-sdk-for-go:\\r\\n    - package: 'sdk/resourcemanager/servicelinker/armservicelinker'\\r\\n      breaking-changes:\\r\\n        - Function `*LinkerClient.BeginCreateOrUpdate` has been removed\\r\\n        - Function `*LinkerClient.NewListPager` has been removed\\r\\n```\\r\\n\\r\\n3. The pull request authors add this suppression file change to your spec pull request. Then the suppressions will be recognized by the bot, and the corresponding suppression label will be added to the spec pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression` will be added to the pull request.\\r\\n\\r\\n4. The SDK reviewers will evaluate the suppressions and either approve them or provide feedback. If the suppressions are approved, the corresponding approval label will be added to the pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression-Approved` will be added to the pull request.\\n\\n## How Does the Suppression Work\\n\\nThe suppression file will remain with the specification move with it to other branches or repositories(such as from the private specification repository to the public specification repository). The suppressions can be deleted after the SDK has been released to the public.\\n\\n## How to Get the Suppression Reviewed\\n\\nSDK reviewers will monitor the specification pull requests with breaking change suppression lables. For example, for the  `azure-sdk-for-go`, the label is `BreakingChange-Go-Sdk-Suppression`. They will evaluate the suppressions and either approve them or provide feedback. If the suppressions are approved, the corresponding approval label will be added to the pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression-Approved` will be added to the pull request. Once the suppression review is complete, the pull request can proceed to the next stage.\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#VersioningGuidelines.md\",\"document_title\":\"Azure Versioning Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/VersioningGuidelines.md\",\"content\":\"# azure#VersioningGuidelines.md\\n\\n# Azure Versioning Guidelines\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2024-Nov-14 | Azure Service Versioning \\u0026 Breaking Change Guidelines       |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Guidelines\\n\\n**DO** remove retired API versions from the azure-rest-api-specs repo.\\r\\n\\r\\n:white_check_mark: **DO** review any change to service behavior that could disrupt customers with the Azure Breaking Changes review board, even if the change is not part of the API definition.\\r\\n\\r\\nSome examples of behavior changes that must be reviewed are:\\r\\n- Introducing or changing rate limits to be more restrictive than previously\\r\\n- Changing the permissions required to successfully execute an operation\\r\\n\\r\\n:no_entry: **DO NOT** change the behavior of an API version that is available to customers either in public preview or GA.\\r\\nChanges in behavior should always be introduced in a new API version, with prior versions working as before.\\r\\n\\r\\n:no_entry: **DO NOT** introduce breaking changes from a prior GA version just to satisfy ARM or Azure API guidelines.\\r\\n\\r\\nAvoiding breaking changes in a GA API takes precedence over adherence to API guidelines and resolving linter errors.\\r\\n\\r\\n:no_entry: **DO NOT** keep a preview feature in preview for more than 1 year; it must go GA (or be removed) within 1 year after introduction.\\n\\nThis document provides a \\\"Dos and Don'ts\\\" list for complying with the Azure Versioning and Breaking Change Policy,\\r\\nas documented [internally](aka.ms/AzBreakingChangesPolicy) and [externally](https://learn.microsoft.com/azure/developer/intro/azure-service-sdk-tool-versioning).\\r\\n\\r\\n:white_check_mark: **DO** thoroughly ensure/test the API contract is entirely correct before merging it into a production branch of the specs repo.\\r\\n\\r\\nTesting helps avoid \\\"BugFix\\\" changes to the API definition. Testing should be done at the HTTP level as well as through generated SDKs.\\r\\n\\r\\n:white_check_mark: **DO** retire all prior preview API versions 90 days after a new GA or preview API version is released.\\r\\n\\r\\n:white_check_mark: **DO** contact the Azure Breaking Change Review board to coordinate communications to customers\\r\\nwhen releasing an API version requiring the retirement of a prior version.\\r\\n\\r\\n:white_check_mark: **DO** create a new preview API version for any features that should remain in preview following a new GA release.\\r\\n\\r\\n:white_check_mark: **DO** use a date strictly later than the most recent GA API version when releasing\\r\\na new preview API version.\\r\\n\\r\\n:white_check_mark: **DO** deprovision any API version that has been retired. Retired APIs versions should behave like\\r\\nan unknown API version (see [ref](https://aka.ms/azapi/guidelines#versioning-api-version-unsupported)).\\r\\n\\r\\n:white_check_mark: **DO** remove retired API versions from the azure-rest-api-specs repo.\\r\\n\\r\\n:white_check_mark: **DO** review any change to service behavior that could disrupt customers with the Azure Breaking Changes review board, even if the change is not part of the API definition.\\r\\n\\r\\nSome examples of behavior changes that must be reviewed are:\\r\\n- Introducing or changing rate limits to be more restrictive than previously\\r\\n- Changing the permissions required to successfully execute an operation\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#pipeline.md\",\"document_title\":\"Resolving Pipeline Failures\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline\",\"content\":\"# migrate-swagger#faq#pipeline.md\\n\\n# Resolving Pipeline Failures\\n\\nThis document explains how to resolve pipeline failures in TypeSpec migration PRs.\\n\\n## Swagger BreakingChange\\n\\n### Multiple OpenAPI Files Before Migration\\n\\nThis pipeline will fail if there is more than one OpenAPI file in the latest version. See the detailed explanation in this [issue](https://github.com/Azure/typespec-azure/issues/2194#issue-2844564216).\\r\\n\\r\\nTo properly identify real breaking changes, use the \\\"TypeSpec Migration Validation\\\" pipeline instead:\\r\\n\\r\\n1. Navigate to the TypeSpec Migration Validation pipeline\\r\\n2. Check the report on the \\\"Summary\\\" page\\r\\n3. The output should match exactly what you see in [this step](../01-get-started.md#review-and-adjust-the-typespec) on the local machine\\r\\n4. Review the changes to verify they are expected\\n\\n### Single OpenAPI File Before Migration\\n\\nIf you have only one OpenAPI file in the latest version, use this pipeline to detect breaking changes. If it fails, refer to [Resolving OpenAPI Breaking Change Violations](./faq/breakingchange.md).\\r\\n\\r\\n**Known Issues**: The following pipeline failures are false alerts and can be safely ignored:\\r\\n\\r\\n#### 1017 - ReferenceRedirection\\r\\n\\r\\nThis typically occurs when an inlined anonymous enum becomes a named enum.\\r\\n\\r\\n**Before:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"enumProperty\\\": {\\r\\n    \\\"type\\\": \\\"string\\\",\\r\\n    \\\"enum\\\": [\\r\\n      \\\"If\\\",\\r\\n      \\\"Else\\\",\\r\\n      \\\"None\\\"\\r\\n    ],\\r\\n    \\\"x-ms-enum\\\": {\\r\\n      \\\"name\\\": \\\"EnumType\\\",\\r\\n      \\\"modelAsString\\\": true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n**After:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"enumProperty\\\": {\\r\\n    \\\"$ref\\\": \\\"#/definitions/EnumType\\\"\\r\\n  }\\r\\n},\\r\\n\\\"EnumType\\\": {\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"If\\\",\\r\\n    \\\"Else\\\",\\r\\n    \\\"None\\\"\\r\\n  ],\\r\\n  \\\"x-ms-enum\\\": {\\r\\n    \\\"name\\\": \\\"EnumType\\\",\\r\\n    \\\"modelAsString\\\": true\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n#### 1023 - TypeFormatChanged\\r\\n\\r\\nThe error message `The new version has a different format 'uri' than the previous one ''.` on the `nextLink` property is expected because the [page template defines the `nextLink` as `uri`](./mustread.md#using-page-model-from-azurecore-library).\\r\\n\\r\\n#### 1047 - XmsEnumChanged\\r\\n\\r\\nAfter migration, all models (including enums) will have capitalized names.\\r\\n\\r\\n**Before:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"someProperty\\\": {\\r\\n    \\\"type\\\": \\\"string\\\",\\r\\n    \\\"enum\\\": [\\r\\n      \\\"If\\\"\\r\\n    ],\\r\\n    \\\"x-ms-enum\\\": {\\r\\n      \\\"name\\\": \\\"someName\\\",\\r\\n      \\\"modelAsString\\\": true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n**After:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"someProperty\\\": {\\r\\n    \\\"$ref\\\": \\\"#/definitions/SomeName\\\"\\r\\n  }\\r\\n},\\r\\n\\\"SomeName\\\": {\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"If\\\"\\r\\n  ],\\r\\n  \\\"x-ms-enum\\\": {\\r\\n    \\\"name\\\": \\\"SomeName\\\",\\r\\n    \\\"modelAsString\\\": true\\r\\n  }\\r\\n}\\r\\n```\\n\\n## Swagger ModelValidation\\n\\nSome validation rules may fail because TypeSpec fixes certain legacy patterns. Review the known issues below and take appropriate action.\\n\\n### INVALID_FORMAT: Object didn't pass validation for format uri: {nextlink}\\n\\n#### Root Cause\\r\\n\\r\\nThe response model of a pageable operation uses the Azure.Core.Page template:\\r\\n\\r\\n```typespec\\r\\nmodel ResponseModel is Azure.Core.Page\\u003cItemType\\u003e;\\r\\n```\\r\\n\\r\\nThis standardized approach changes the `nextLink` type from plain `string` to `uri`. If previous example's `nextLink` value isn't a valid URI, it will cause a validation error.\\r\\n\\r\\n#### Resolution\\r\\n\\r\\nChoose one of the following options:\\r\\n\\r\\n1. **Update your example** to include a valid URI value, or\\r\\n2. **Modify your TypeSpec response model** to use a custom definition if the nextLink returned by the service is not a URI:\\r\\n\\r\\n```typespec\\r\\nmodel ResponseModel {\\r\\n  @pageItems\\r\\n  value: ItemType[];\\r\\n\\r\\n  @nextLink\\r\\n  nextLink?: string;\\r\\n}\\r\\n```\\n\\n### INVALID_FORMAT: Object didn't pass validation for format arm-id\\n\\n#### Root Cause\\r\\n\\r\\nThis error typically occurs when a custom resource definition is mapped to a resource defined in common-types. See [this section](./breakingchange.md#using-resources-from-common-types) for details. The `id` property for `Resource` in common-types may use the `arm-id` format, depending on the version of common-types used.\\r\\n\\r\\n#### Resolution\\r\\n\\r\\nUpdate the value in the example file to meet the `arm-id` format requirements.\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_10.md\",\"document_title\":\"Service under conversation label\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_10.md\\n\\n# Service under conversation label\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\nMy team currently has a PR open to release a new stable API. However, due to backend delays, it’s been open since July. During that time, the [typespec migration PR](https://github.com/Azure/azure-rest-api-specs/pull/36556) was drafted against our preview API. Now, the service-under-conversion label has been added to our stable PR. I’d like to understand does this label indicate a delay in merging in our [stable api PR](https://github.com/Azure/azure-rest-api-specs/pull/36219), or will we need to make additional changes?\\n\\n## answer\\n\\nThe label should not impact your previous PR, and , if this is a later api-version thatn the conversion PR, the conversion would normally be based on that version once checked in.  Adding Janine Zhang for awareness about the conversion.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_17.md\",\"document_title\":\"Unknown decorator @flattenProperty\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_17.md\\n\\n# Unknown decorator @flattenProperty\\n\\n## question\\n\\nI'm getting the below errors and something like this, which I had never run into before.  The target branch (which I based my dev branch from) of my PR didn't run into that either.  Looking for some advice or clue about what is causing this and how to fix, or perhaps bypass them.\\r\\n```\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:49:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:52:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:45:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:47:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n```\\r\\nhttps://github.com/Azure/azure-rest-api-specs/pull/37909\\n\\n## answer\\n\\nyour release branch has fallen far behind main.  it will need to be updated or recreated. \\r\\nyou can try this, but if your release branch is too old, it will likely need to be recreated \\r\\nhttps://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish#update-your-branch-with-changes-from-main\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_31.md\",\"document_title\":\"TypeSpec Validation error\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_31.md\\n\\n# TypeSpec Validation error\\n\\n## question\\n\\nI have error: https://github.com/Azure/azure-rest-api-specs/actions/runs/16475997770/job/46577654359?pr=35887:\\r\\n```\\r\\nRule Compile failed\\r\\n  {\\\"not_added\\\":[],\\\"conflicted\\\":[],\\\"created\\\":[],\\\"deleted\\\":[],\\\"modified\\\":[\\\"specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\\"],\\\"renamed\\\":[],\\\"files\\\":[{\\\"path\\\":\\\"specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\\",\\\"index\\\":\\\" \\\",\\\"working_dir\\\":\\\"M\\\"}],\\\"staged\\\":[],\\\"ahead\\\":0,\\\"behind\\\":0,\\\"current\\\":\\\"HEAD\\\",\\\"tracking\\\":null,\\\"detached\\\":true}diff --git a/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json b/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\r\\n  index 58f42ef3f..cc93d3906 100644\\r\\n  --- a/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\r\\n  +++ b/specification/compute/resource-manager/Microsoft.Compute/GalleryRP/stable/2025-03-03/GalleryRP.json\\r\\n  @@ -7079,8 +7079,7 @@\\r\\n             \\\"description\\\": \\\"Optional. Any input parameters that needs to passed to the script and are accessed within the script for its execution.\\\",\\r\\n             \\\"items\\\": {\\r\\n               \\\"$ref\\\": \\\"#/definitions/GalleryScriptParameter\\\"\\r\\n  -          },\\r\\n  -          \\\"x-ms-identifiers\\\": []\\r\\n  +          }\\r\\n           }\\r\\n         },\\r\\n         \\\"required\\\": [\\r\\n  \\r\\n  Files have been changed after `tsp compile`. Run `tsp compile` and ensure all files are included in your change.\\r\\n  Error: TypeSpec Validation failed for project specification/compute/Gallery.Management run the following command locally to validate.\\r\\n   \\u003e npm ci\\r\\n   \\u003e npx tsv specification/compute/Gallery.Management\\r\\n  For more detailed docs see https://aka.ms/azsdk/specs/typespec-validation\\r\\n```\\r\\n \\r\\nIs it because I have\\r\\n```\\r\\n  @@ -7079,8 +7079,7 @@\\r\\n             \\\"description\\\": \\\"Optional.\\n\\nFiles have been changed after `tsp compile`. Run `tsp compile` and ensure all files are included in your change.\\r\\n  Error: TypeSpec Validation failed for project specification/compute/Gallery.Management run the following command locally to validate.\\r\\n   \\u003e npm ci\\r\\n   \\u003e npx tsv specification/compute/Gallery.Management\\r\\n  For more detailed docs see https://aka.ms/azsdk/specs/typespec-validation\\r\\n```\\r\\n \\r\\nIs it because I have\\r\\n```\\r\\n  @@ -7079,8 +7079,7 @@\\r\\n             \\\"description\\\": \\\"Optional. Any input parameters that needs to passed to the script and are accessed within the script for its execution.\\\",\\r\\n             \\\"items\\\": {\\r\\n               \\\"$ref\\\": \\\"#/definitions/GalleryScriptParameter\\\"\\r\\n  -          },\\r\\n  -          \\\"x-ms-identifiers\\\": []\\r\\n  +          }\\r\\n           }\\r\\n         },\\r\\n         \\\"required\\\": [\\r\\n```\\r\\nwhere x-ms-identifier is empty? That is intended.\\n\\n## answer\\n\\nThe swagger generated by TypeSpec is constantly changing across TypeSpec versions.  Do you believe the new swagger is incorrect?\\r\\n \\r\\nAlso, keep in mind the version of TypeSpec may be different in main, the base and source branches of your PR, and locally.  Unless you think the new generated swagger is incorrect, you want to update forward.\\r\\nx-ms-identifier is no longer needed https://github.com/Azure/typespec-azure/issues/2868:\\r\\n```\\r\\nissue 2868:\\r\\ntitle: [Deprecation] x-ms-identifiers extension is no longer useful\\r\\ncontent: As title, and confirmed by @cweining, this swagger extension is completely useless for them who is from the original team that added this extension in swagger. Please remove it from typespec-autorest emitter\\r\\n```\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-07-17.md\",\"document_title\":\"path lack of \\\"A/B\\\"   instead of \\\"A/{B}\\\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-07-17.md\\n\\n# path lack of \\\"A/B\\\"   instead of \\\"A/{B}\\\"\\n\\n## question\\n\\nthe path lack of segment \\\"A/B\\\"   instead of \\\"A/{B}\\\"\\n\\n## answer\\n\\n```\\r\\n#suppress \\\"@azure-tools/typespec-azure-resource-manager/arm-resource-interface-requires-decorator\\\" \\\"FIXME: Update justification, follow aka.ms/tsp/conversion\\\"\\r\\ninterface OrganizationResourceRoleBindingIdOps\\r\\n    extends Azure.ResourceManager.Legacy.LegacyOperations {\\r\\n    ...ApiVersionParameter,\\r\\n    ...SubscriptionIdParameter,\\r\\n    ...ResourceGroupParameter,\\r\\n    ...Azure.ResourceManager.Legacy.Provider,\\r\\n\\r\\n    /**\\r\\n     * Organization resource name\\r\\n     */\\r\\n    @path\\r\\n    @segment(\\\"organizations\\\")\\r\\n    organizationName: string,\\r\\n},\\r\\n{\\r\\n@path\\r\\naccess: \\\"access\\\",\\r\\n\\r\\n@path\\r\\ndefault: \\\"default\\\",\\r\\n\\r\\n/**\\r\\n * Confluent Role binding id\\r\\n */\\r\\n@path\\r\\n@segment(\\\"deleteRoleBinding\\\")\\r\\nroleBindingId: string,\\r\\n}，\\r\\nResourceProviderDefaultErrorResponse\\r\\n{}\\r\\n```\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-08-07.md\",\"document_title\":\"Typespec Validation failed\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-08-07.md\\n\\n# Typespec Validation failed\\n\\n## question\\n\\n```\\r\\nOutput folder 'specification/newrelic/resource-manager/NewRelic.Observability' appears to contain TypeSpec-generated swagger files, not generated from the current TypeSpec sources. Perhaps you deleted a version from your TypeSpec, but didn't delete the associated swaggers?\\r\\n\\r\\nspecification/newrelic/resource-manager/NewRelic.Observability/preview/2023-10-01-preview/NewRelic.json  \\r\\nspecification/newrelic/resource-manager/NewRelic.Observability/preview/2022-07-01-preview/NewRelic.json  \\r\\nspecification/newrelic/resource-manager/NewRelic.Observability/preview/2023-11-01-preview/NewRelic.json  \\r\\nspecification/newrelic/resource-manager/NewRelic.Observability/preview/2024-01-01-preview/NewRelic.json  \\r\\nspecification/newrelic/resource-manager/NewRelic.Observability/stable/2022-07-01/NewRelic.json  \\r\\nspecification/newrelic/resource-manager/NewRelic.Observability/stable/2024-01-01/NewRelic.json  \\r\\nspecification/newrelic/resource-manager/NewRelic.Observability/stable/2024-03-01/NewRelic.json  \\r\\nspecification/newrelic/resource-manager/NewRelic.Observability/stable/2024-10-01/New Relicson\\r\\n```\\n\\n## answer\\n\\ndelete x-cadl-generated in all files in resource-manager, such as\\r\\n```diff\\r\\n      \\\"title\\\": \\\"NewRelic.Observability\\\",\\r\\n-     \\\"version\\\": \\\"2022-07-01-preview\\\",\\r\\n-     \\\"x-cadl-generated\\\": [\\r\\n-       {\\r\\n-         \\\"emitter\\\": \\\"@azure-tools/cadl-autorest\\\"\\r\\n-       }\\r\\n-     ]   \\r\\n+     \\\"version\\\": \\\"2022-07-01-preview\\\"\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-versioning.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-versioning\",\"content\":\"# Azure REST API versioning\\n## Resources\\n- [Azure Service Versioning Policy](https://github.com/Azure/azure-rest-api-specs/wiki/Azure-Service-Versioning-Guideline)\\r\\n- [Azure Versioning and Breaking Changes Policy](https://aka.ms/AzBreakingChangesPolicy)\\r\\n- [Breaking change guidelines](https://eng.ms/docs/cloud-ai-platform/azure-core/azure-core-product/product-lifecycle-management-plm/service-lifecycle-and-actions-team/service-lifecycle-actions-team/cpex/media/overview_breaking_changes)\\r\\n- [Azure REST API Versioning Guidelines](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-versioning)\\r\\n- [Versioning policy for Azure services, SDKs, and CLI tools]\\r\\n\\r\\n[spec directory structure]: https://aka.ms/azsdk/spec-dirs\\r\\n[Versioning policy for Azure services, SDKs, and CLI tools]: https://learn.microsoft.com/en-us/azure/developer/intro/azure-service-sdk-tool-versioning\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\n## MULTIPLE_API_VERSION\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Validation.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation\",\"content\":\"# Running Locally\\nTo ensure you see the same results from TypeSpecValidation in your PR check and `tsv` on your local machine:\\r\\n1. Merge latest from parent (e.g. `main` or `RPSaaSMaster`) to your PR branch\\r\\n2. Run locally\\r\\n   1. `git clean -xdf` (may revert any local changes)\\r\\n   2. `git pull`\\r\\n   3. `npm ci`\\r\\n   4. `npx tsv specification/widget/resource-manager/Microsoft.Widget/Widget`\\r\\n   5. `git status`\\r\\n   6. If any changes, `git add`, `git commit`, `git push` to update your PR.\\r\\n3. If you are still having problems, try cloning your branch to a new folder, or try on another machine.\\r\\n4. If the problem can be reproduced on a clean machine, request assistance from the [TypeSpec Discussion](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) teams channel.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# Suppress validation failures on a PR\\n## Suppression cases table\\n|\\r\\n| Swagger LintDiff                   | See [aka.ms/ci-fix]                       | `Approved-LintDiff`                                  | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| Swagger LintDiff(RPaaS)            | See [aka.ms/ci-fix]                       | `Approved-LintRPaaS`                                 | See [suppress AutoRest extension](#suppress-autorest-extension) |\\r\\n| SDK azure-sdk-for-net              | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-net-track2       | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-go               | See [step 3 in the diagram] but note [1]. | `BreakingChange-Go-Sdk-Suppression-Approved`         | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-java             | Not possible ([#6509])                    |                                                      | Not possible                                                    |\\r\\n| SDK azure-sdk-for-js               | See [step 3 in the diagram] but note [1]. | `BreakingChange-JavaScript-Sdk-Suppression-Approved` | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python           | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| SDK azure-sdk-for-python-track2    | See [step 3 in the diagram] but note [1]. | `BreakingChange-Python-Sdk-Suppression-Approved`     | Same as **PR suppression**                                      |\\r\\n| Automated merging requirements met |\"}]",
            "inputs.latency": 912.1456534862518,
            "inputs.response_length": 2565,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Breaking-Changes",
                "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions"
            ],
            "inputs.testcase": "PR Review for GalleryRP 2025-03-03 Release",
            "outputs.similarity.similarity": 3.0,
            "outputs.similarity.gpt_similarity": 3.0,
            "outputs.similarity.similarity_result": "fail",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1685,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1686,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: PR Review for GalleryRP 2025-03-03 Release\\\\n\\\\nquestion: Hello Team! Running into some issues with BreakingChange-Go-Sdk and BreakingChange-Javascript-Sdk labels on two PRs that we are trying to approve for the GalleryRP 2025-03-03 Release. I'm not sure if this is the right channel to be asking in but we need these Breaking Changes approved before moving forward with the Release, thank you for the help!\\\\nThe links to the PRs are as follows:\\\\nIntroducing New Resource Type - Gallery Scripts found [here](https://github.com/Azure/azure-rest-api-specs/pull/35887)\\\\nAdding New Property StorageAccountStrategy found [here](https://github.com/Azure/azure-rest-api-specs/pull/35769)\\\\n```\\\\nGitHub Notifications\\\\nPull Request | Azure/azure-rest-api-specs #35887\\\\nNew resource type - Gallery Scripts\\\\nARM (Control Plane) API Specification Update Pull Request\\\\ngrizzlytheodore wants to merge 18 commits from galleryTsp-GalleryScript into feature/cplat-2025-03-03-tsp\\\\n```\\\", \\\"response\\\": \\\"Based on the Azure SDK and API guidelines, the BreakingChange-Go-Sdk and BreakingChange-Javascript-Sdk labels are applied automatically when a PR introduces breaking changes for those SDK languages. According to the suppression process documented in the Azure REST API Specs Wiki and SDK Breaking Changes guidelines, the next steps are:\\\\n\\\\n1. You (the PR author or service team) must create a `sdk-suppressions.yaml` file in your TypeSpec project root (the same directory as your `tspconfig.yaml`). This file should list all the SDK breaking changes that are flagged by the validation pipeline. \\\\n2. To find the specific breaking changes that need suppression, download the pipeline artifact named `*-gen-result.html` (spec-gen-sdk logs) from the CI build. Look for the `Absent SDK breaking changes suppressions` section in the HTML report and copy each item into your suppression file under the respective language.\\\\n3. Example format for `sdk-suppressions.yaml`:\\\\n\\\\n```yaml\\\\nsuppressions:\\\\n  azure-sdk-for-go:\\\\n    - package: 'sdk/resourcemanager/compute/armcompute'\\\\n      breaking-changes:\\\\n        - Function `*GalleryScriptsClient.BeginCreateOrUpdate` has been removed\\\\n        - Function `*GalleryScriptsClient.NewListPager` has been removed\\\\n  azure-sdk-for-js:\\\\n    - package: '@azure/arm-compute'\\\\n      breaking-changes:\\\\n        - Method `GalleryScriptsClient.createOrUpdate` has changed signature\\\\n```\\\\n\\\\n4. Commit and push this suppression file as part of your PR. The bot will then add the suppression labels (e.g., `BreakingChange-Go-Sdk-Suppression` and `BreakingChange-JavaScript-Sdk-Suppression`) to your PR.\\\\n5. The SDK reviewers will evaluate your suppressions and either approve or provide feedback. Once approved, the labels will change to `...Suppression-Approved` and you may proceed with the release.\\\\n\\\\nIf you need a reference or step-by-step instructions, see the [SDK-Breaking-Changes.md](https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Breaking-Changes) wiki.\\\\n\\\\n**Note:** Suppression is only recommended when you cannot update your API design to remove the breaking changes. The preferred path is to update the TypeSpec and API design so the breaking changes do not occur.\\\\n\\\\nIf you have already created the suppression file and still see issues, ensure you have the correct suppression format and that it covers all items flagged by the pipeline. If suppressions are missing, the CI will block the PR until addressed.\\\\n\\\\nIf you need further help, provide the list of breaking changes from the CI logs and your current suppression file content for review.\\\", \\\"ground_truth\\\": \\\"both your PRs are to a feature branch (feature/cplat-2025-03-03-tsp), which has no required checks.  you will need to get these breaking changes reviewed when you try to merge to a release branch like main or RPSaaSMaster.\\\\nhttps://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md#sdk-breaking-change-review\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"
        },
        {
            "inputs.query": "title: Stuck in license/cla and Automated Merge checks for more than 1 hour\n\nquestion: Hi, my PR got ARMSignoff and all requirements seem to have met. But it is still waiting on these 2 required checks - \"license/cla\" and \"Automated Merge\" which I verified that are completed and succeeded. It is stuck here for more than an hour. Is this expected or known issue? Any pointers would help. Thanks!\nPR - [Add ACA env connection to caphost by sarajag · Pull Request #38223 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/38223)",
            "inputs.ground_truth": "this membership must be public: https://github.com/orgs/Azure/people?query=sarajag\nplease follow all the steps here: https://aka.ms/azsdk/access\nyou should also join Microsoft org (and make your membership public):\nhttps://github.com/orgs/Microsoft/people?query=sarajag\nafter fixing your org memberships, push another commit to your PR to re-run checks",
            "inputs.response": "This situation is not expected and is a known issue that can occasionally affect PRs in the Azure/azure-rest-api-specs repo, especially regarding required GitHub checks like \"license/cla\" and \"Automated Merge\" showing as stuck or not updating their status even after successful completion. \n\nAccording to the PR workflow guidance, once all required checks (including license/cla and Automated Merge) are green, and you have the necessary approvals (like ARMSignoff), you should be able to merge your PR. If you observe that these checks are stuck in a waiting state, the most common causes are:\n\n- Transient GitHub status update issues (cache, webhook delivery, etc.)\n- Permission or membership problems (though not usually the case if you already see succeeded status)\n- Rare infra delays\n\nRecommended next steps:\n1. Try closing and reopening the PR (this can retrigger the checks and often resolves the stuck state).\n2. Ensure your Azure organization membership is public and you are part of the Azure SDK Partners group (see https://aka.ms/azsdk/access), but this is less likely if the checks are green.\n3. If the issue persists, reach out in your PR comments or via https://aka.ms/azsdk/pr-getting-help for repo admin assistance.\n\nThis kind of issue has been observed before and is generally resolved by retriggering the checks or with admin intervention. You do not need to rebase or force-push unless specifically advised.",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"Create a PR against main\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\\n\\n# Create a PR against main\\n\\n\\u003e [!NOTE]\\r\\n\\u003e You must have a [GitHub account linked with your Microsoft account](xref:access) and permissions to any of the\\r\\n\\u003e repositories listed in this tutorial.\\r\\n\\r\\nWhen you're ready for a final review, it's time to create a pull request (PR) from your release branch you created\\r\\noriginally to the `main` branch on [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n* :warning: Do not merge `main` or other release branches unless you know there are changes required.\\r\\n* :white_check_mark: Rebase on `main` if changes are required in a separate topic branch.\\n\\n## Clean PR against main\\n\\nIf you're fairly certain there should be no conflicting changes in files you added or modified in the release branch,\\r\\nyou can most often just create a pull request (PR) against `main` on  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs).\\r\\n\\r\\n1. Go to your branch in [Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) or  \\r\\n   [Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr). Read more about  \\r\\n   [our repositories](xref:api-repos) for what is public and what is private.\\r\\n\\r\\n2. If you do not already see an open PR in the upper-right just above the list of files, click **Contribute** and click\\r\\n   **Open pull request** to open a new one.\\r\\n\\r\\n3. Select either the **Control Plane (ARM) API** or **Data Plane API** PR template, depending on the type of REST API\\r\\nspec updates you are submitting.\\r\\n\\r\\n\\u003c!-- Todo: Figure out best way to embed videos on site.\\r\\n:::video source=\\\"https://microsoft.sharepoint.com/teams/AzureDeveloperExperience/_layouts/15/embed.aspx?UniqueId=b199159f-5d7c-4b22-8ba4-98025a2a1f2e\\\":::\\r\\n--\\u003e\\n\\n## Update your branch with changes from main\\n\\nIf you know there are other changes in the `main` branch or that other services have updated shared files in `main`\\r\\nalready and you need to pick up changes before merging, we recommend you take a merge from main. This is particularly interesting\\r\\nfor common infrastructure changes that are committed in the repo (i.e. github actions, tools, etc). Depending on how old your\\r\\nbranch is some of the pull request checks may not correctly function without taking a merge from main. \\r\\n\\r\\nIf you are working in a non-protected branch you can do a `git merge main` like you would normally do a merge and then push\\r\\nyour changes to your remote branch. However, if you are working in a branch with branch protection enabled (i.e. `release-*`) then\\r\\nyou will need to make a pull request to your branch with the merge. Depending on how out-of-date your branch is from `main` your \\r\\nmerge may have a lot of unwanted and unnecessary changes and the checks not pass. In such cases see below on how to [update the infrastructure](#updating-only-the-infrastructure-changes-from-main).\\n\\n### Updating only the infrastructure changes from main\\n\\nIn cases you need to only update the infrastructure code and not the specifications we have a helper pipeline \\r\\nwhich you can run that will create a pull request with a selective merge. The selective merge will include everything except for specs \\r\\nunder the specifications folder. This will enable you to only update the infrastructure and not other specs which should get your checks \\r\\npassing in your protected branch. Follow these steps to run the helper pipeline.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e This should only be needed for protected branches, such as `release-*`. If you are in an unprotected branch, just use a normal `git merge main`.\\r\\n\\r\\n1. Go to [tools - update-release-branch-in-specs](https://dev.azure.com/azure-sdk/internal/_build?definitionId=7487) and select **Run Pipeline**.\\r\\nIf you don't have permission see [GitHub account linked with your Microsoft account](xref:access).\\r\\n\\r\\n2. Enter the name of your branch in the **BranchToMergeTo** parameter. Usually this will be in the form `release-\\u003cname\\u003e`.  You shouldn't need to set \\r\\nthe other parameters but if your branch is in the private repo then you will need to update **Repo** to be `Azure/azure-rest-api-specs-pr`.\\r\\n\\r\\n3. Click the **Run** button.\\r\\n\\r\\n4. The pipeline should only take a few minutes to run and once it is complete then go find the pull request it created. You can find a link to it in the \\r\\npipeline logs under the **Create Pull Request to merge** step. \\r\\n\\r\\n5. Monitor the created pull request and approve it. Once the checks are green then merge the pull request and then your branch should be updated with the latest infrastructure changes.\\r\\nIf you have open PRs against your branch with failing checks, go to those PRs and retrigger the checks. The easiest way to retrigger all checks\\r\\nis to hit the close button followed by the open button, which should cause the checks to re-run.\\n\\n## Next steps\\n\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure_resource_manager_rpc\",\"document_filename\":\"v1.0#common-api-details.md\",\"document_title\":\"Common API Details\",\"document_link\":\"https://github.com/cloud-and-ai-microsoft/resource-provider-contract/blob/master/v1.0/common-api-details.md\",\"content\":\"# v1.0#common-api-details.md\\n\\n# Common API Details\\n\\n## Table of Contents ##\\n\\n- [Proxy Request Header Modifications](#proxy-request-header-modifications) \\u003c/br\\u003e\\r\\n- [Client Request Headers](#client-request-headers) \\u003c/br\\u003e\\r\\n- [Request Query Parameters](#request-query-parameters) \\u003c/br\\u003e\\r\\n- [Case Insensitivity for Requests](#case-insensitivity-for-requests) \\u003c/br\\u003e\\r\\n- [Client Request Timeout](#client-request-timeout) \\u003c/br\\u003e\\r\\n- [Request Throttling](#request-throttling) \\u003c/br\\u003e\\r\\n- [Common API Response Details](#common-api-response-details) \\u003c/br\\u003e\\n\\n## Proxy Request Header Modifications ##\\n\\nthe admins of the tenant which issued the JWT. | 1st party only |\\r\\n| x-ms-client-authentication-methods | Always added. Set to the authentication method references of client JWT. | 1st party only|\\r\\n| x-ms-management-group-ancestors | Always added. Set to the management groups that subscription might belong to. If there are multiple ancestors they will be comma separated. Example: `d27e3b8a-3d55-44b7-b2ba-1b3ef9227527, NonProduction` | 1st party only|\\r\\n| x-ms-arm-resource-routing-location | Added when extension resources or child proxy resources are routed regionally. Set to the endpoint location the request is routed to in the region's lower-case normalized form (i.e. `eastus2`). The endpoint location will be decided by the location of the closest tracked ancestor. If there is no tracked ancestor, the header will not be set. If the request is routed to the global endpoint because there is no matching regional endpoint, it will be set to an empty string. | 1st and 3rd party |\\n\\ntenant ID of the client JWT making the request. | 1st party only |\\r\\n| x-ms-home-tenant-id | Added for requests at or below subscription scopes. Set to the tenant ID of the subscription. This will be different from `x-ms-client-tenant-id` in cross-tenant scenarios. | 1st party only |\\r\\n| x-ms-client-audience | Always added. Set to the audience of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-issuer | Always added. Set to the issuer of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-object-id | Always added. Set to the object Id of the client JWT making the request. Not all users have object Id. For CSP (reseller) scenarios for example, object Id is not available. | 1st party only |\\r\\n| x-ms-client-app-id | Always added. Set to the app Id of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-app-id-acr | Always added. Set to the app Id acr claim of the client JWT making the request. This is the application authentication context class reference claim which indicates how the client was authenticated. | 1st party only |\\r\\n| x-ms-client-authorization-source | Always added. Specifies the authorization source of the token. It\\u0026#39;s value can be NotSpecified, Legacy, RoleBased, Bypassed, Direct and Management. | 1st party only |\\r\\n| x-ms-client-identity-provider | Always added. Set to the identity provider of the client JWT. |1st party only |\\r\\n| x-ms-client-wids | Always added. Set to the wids of the client JWT. These identify the admins of the tenant which issued the JWT. | 1st party only |\\r\\n| x-ms-client-authentication-methods | Always added. Set to the authentication method references of client JWT. | 1st party only|\\r\\n| x-ms-management-group-ancestors | Always added. Set to the management groups that subscription might belong to. If there are multiple ancestors they will be comma separated. Example: `d27e3b8a-3d55-44b7-b2ba-1b3ef9227527, NonProduction` | 1st party only|\\r\\n| x-ms-arm-resource-routing-location |\\n\\nThe resource provider proxy will preserve all the client requests headers, with the exception of modifications per the details below. The headers below are reserved and cannot be set by clients.\\r\\n\\r\\n\\r\\n| Header                     | Description |  1st or 3rd Party |\\r\\n| :----------------------------| :------------------------| :-----------------------------------|\\r\\n| referer | Always added. Set to the full URI that the client connected to (which will be different than the RP URI, since it will have the public hostname instead of the RP hostname). This value can be used in generating FQDN for Location headers or other requests since RPs should not reference their endpoint name. |  1st and 3rd party |\\r\\n| authorization | Always removed/changed. The authorization used by the client to the proxy will be different than the authorization used to communicate from the proxy to the resource provider. | 1st and 3rd party |\\r\\n| x-ms-client-ip-address | Always added . Set to the client IP address used in the request; this is required since the resource provider will not have access to the client IP. | 1st and 3rd party |\\r\\n| x-ms-client-principal-name | Always added. Set to the principal name / UPN of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-principal-id | Added when available. Set to the principal Id of the client JWT making the request. Service principal will not have the principal Id. | 1st party only |\\r\\n| x-ms-client-tenant-id | Always added. Set to the tenant ID of the client JWT making the request. | 1st party only |\\r\\n| x-ms-home-tenant-id | Added for requests at or below subscription scopes. Set to the tenant ID of the subscription. This will be different from `x-ms-client-tenant-id` in cross-tenant scenarios. | 1st party only |\\r\\n| x-ms-client-audience | Always added. Set to the audience of the client JWT making the request. | 1st party only |\\r\\n| x-ms-client-issuer | Always added. Set to the issuer of the client JWT making the request. |\\n\\n## Client Request Headers ##\\n\\nAny non-reserved headers provided by the client will pass as-is to the resource provider. All requests to resource providers may include the following standard headers and **must** be supported:\\r\\n\\r\\n| Header | Description |\\r\\n| --- | --- |\\r\\n| Content-Type | Set to application/json. This header is not sent in requests that don\\u0026#39;t have any content, such as all GET calls. |\\r\\n| Accept-Language | Specifies the preferred language for the response; all RPs should use this header when generating error messages or client facing text. |\\r\\n| x-ms-client-request-id | Caller-specified value identifying the request, in the form of a GUID with no decoration such as curly braces (e.g. `client-request-id: 9C4D50EE-2D56-4CD3-8152-34347DC9F2B0`). If the caller provides this header – the resource provider **must** log this with their traces to facilitate tracing a single request. If specified, this will be included in response information as a way to map the request if \\\"x-ms-return-client-request-id\\\"; is specified as \\\"true\\\". Because this header can be client-generated, it should not be assumed to be unique by the RP implementation. |\\r\\n| x-ms-correlation-request-id | Optional. Caller-specified value identifying a set of related operations that the request belongs to, in the form of a GUID. If the caller does not specify this header, ARM will randomly generate a unique GUID. Used for tracing the correlation Id of the request; the resource provider **must** log this so that end-to-end requests can be correlated across Azure. Because this header can be client-generated or re-used for multiple requests, it should not be assumed to be unique by the RP implementation. |\\r\\n| x-ms-return-client-request-id | Optional. True or false and indicates if a client-request-id should be included in the response. Default is false. |\\n\\n## Request Query Parameters ##\\n\\nARM will proxy request parameters (e.g. $filter; $expand; $skipToken; etc.) as-is to the Resource Providers. It will not delete, modify or add any query parameters before relaying the request. The only exceptions are the following query parameters which are not supported on requests into ARM and will cause the request to be rejected with a 400 status code:\\r\\n\\r\\n- `sub`\\r\\n- `subId`\\r\\n- `subscription`\\r\\n- `subscriptionId`\\n\\n## Case Insensitivity for Requests ##\\n\\nWhen satisfying incoming requests, it is assumed that the following values are stored / indexed / compared in a case **insensitive** way:\\r\\n\\r\\n- Resource group name\\r\\n- Resource name\\r\\n- Other names of entities in the URL, even if they are not resources.\\n\\n## Client Request Timeout ##\\n\\nRequests proxied to the resource provider are made with a client timeout of 60 seconds. If requests take more than 60 seconds please consider using asynchronous request/response pattern.\\r\\n\\r\\nThe resource provider must respond within that time interval or the client will receive a 504 (timeout) error code and will not see the response from the RP.\\n\\n## Request Throttling ##\\n\\nARM provides subscription level throttling. More details on these limits can be found [here](https://azure.microsoft.com/en-us/documentation/articles/azure-subscription-service-limits/#overview).\\n\\n## Common API Response Details ##\\n\\n### Response Headers ###\\n\\nAll responses from resource providers should include the following headers:\\r\\n\\r\\n| Header | Description |\\r\\n| --- | --- |\\r\\n| `Content-Type` | Set to application/json. This header is not required in responses that don\\u0026#39;t have any content. |\\r\\n| `Date` | The date that the request was processed, in RFC 1123 format. |\\r\\n| `x-ms-request-id` | A unique identifier for the current operation, service generated. All the resource providers \\\\*must\\\\* return this value in the response headers to facilitate debugging. |\\r\\n| `x-ms-failurecause` | An ___optional___ header used to provide additional failure attribution on error responses. See [below](#x-ms-failurecause-header) for additional information. |\\r\\n\\r\\nAll long running operations response details are described below.\\n\\n### Error Response Content ###\\n\\n\\\"policyAssignmentDisplayName\\\": \\\"Allow Central US and WEU only\\\",\\r\\n              \\\"policyAsssignmentId\\\": \\\"/subscriptions/00000-00000-0000-000/providers/Microsoft.Authorization/policyAssignments/TestAssignment1\\\"\\r\\n            }\\r\\n          },\\r\\n          {\\r\\n            \\\"type\\\": \\\"SomeOtherViolation\\\",\\r\\n            \\\"info\\\": {\\r\\n              \\\"innerException\\\": \\\"innerException Details\\\"\\r\\n       \"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"troubleshoot#status-read-only-error.md\",\"document_title\":\"`ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error\",\"content\":\"# troubleshoot#status-read-only-error.md\\n\\n# `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\\n\\nWhen trying to check in an ARM specification to the `azure-rest-api-specs` repository, your specification\\r\\nshows violations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\\n\\n## Symptoms\\n\\nIn the `Swagger LintDiff` or `Swagger(RPaaS) LintDiff` checks, your specification shows one or more\\r\\nviolations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\\n\\n## Cause\\n\\nThe LintDiff swagger scripts use an old validation mechanism that does not detect `readOnly` properties, but requires the\\r\\ntype schema referenced by the properties to be `readOnly` instead.\\n\\n## Workaround\\n\\nUntil this validation is fixed, you can configure the `@azure-tools/typespec-autorest` emitter in `tspConfig.yaml`\\r\\nto always output any `ProvisioningState` schema as readOnly, using the `read-only-status-schema` option. This\\r\\nresolves the LintDiff violation. Note that if you use the scaffolding template for `ARM`, this configuration is\\r\\nenabled automatically.\\r\\n\\r\\n```diff lang=yaml title=tspconfig.yaml\\r\\nemit:\\r\\n  - \\\"@azure-tools/typespec-autorest\\\"\\r\\noptions:\\r\\n  \\\"@azure-tools/typespec-autorest\\\":\\r\\n+    use-read-only-status-schema: true\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#diagnostics.md\",\"document_title\":\"Diagnostics\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/diagnostics\",\"content\":\"# emitters#openapi3#diagnostics.md\\n\\n# Diagnostics\\n\\nThe OpenAPI emitter may produce any of the following diagnostic messages.\\r\\n\\r\\n\\u003c!-- Topics within this section should be ordered alphabetically for easy lookup --\\u003e\\n\\n## duplicate-header\\n\\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\\r\\n\\r\\nTo fix this issue, ensure that each response header is defined only once for each status code.\\n\\n### Example\\n\\n```yaml\\r\\nresponses:\\r\\n  \\\"200\\\":\\r\\n    description: Successful response\\r\\n    headers:\\r\\n      X-Rate-Limit:\\r\\n        description: The number of allowed requests in the current period\\r\\n        schema:\\r\\n          type: integer\\r\\n      X-Rate-Limit:\\r\\n        description: The number of allowed requests in the current period\\r\\n        schema:\\r\\n          type: integer\\r\\n```\\r\\n\\r\\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\\n\\n## duplicate-type-name\\n\\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\\r\\n\\r\\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\\n\\n### Example\\n\\n```typespec\\r\\n@friendlyName(\\\"User\\\")\\r\\nmodel Customer {\\r\\n  id: string;\\r\\n}\\r\\n\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\r\\n\\r\\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\\n\\n## inline-cycle\\n\\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\\r\\n\\r\\nTo fix this issue, refactor the schemas to remove the cyclic reference.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    Node:\\r\\n      type: object\\r\\n      properties:\\r\\n        value:\\r\\n          type: string\\r\\n        next:\\r\\n          $ref: \\\"#/components/schemas/Node\\\"\\r\\n```\\r\\n\\r\\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\\n\\n## invalid-default\\n\\nThis diagnostic is issued when a default value is invalid for the specified schema type.\\r\\n\\r\\nTo fix this issue, ensure that the default value is valid for the schema type.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    User:\\r\\n      type: object\\r\\n      properties:\\r\\n        age:\\r\\n          type: integer\\r\\n          default: \\\"twenty\\\"\\r\\n```\\r\\n\\r\\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\\n\\n## invalid-extension-key\\n\\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \\\"x-\\\" as\\r\\nrequired by the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, change the extension name to start with \\\"x-\\\".\\n\\n### Example\\n\\n```typespec\\r\\n@extension(\\\"invalid-name\\\", \\\"value\\\")\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\r\\n\\r\\nShould be changed to:\\r\\n\\r\\n```typespec\\r\\n@extension(\\\"x-valid-name\\\", \\\"value\\\")\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\n\\n## invalid-schema\\n\\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    User:\\r\\n      type: object\\r\\n      properties:\\r\\n        id:\\r\\n          type: string\\r\\n        age:\\r\\n          type: integer\\r\\n          format: \\\"int\\\" # Invalid format\\r\\n```\\r\\n\\r\\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\\n\\n## invalid-server-variable\\n\\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\\r\\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\\r\\n\\r\\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\\n\\n### Example\\n\\n```typespec\\r\\n@server(\\\"{protocol}://{host}/api/{version}\\\", \\\"Custom endpoint\\\", {\\r\\n  protocol: \\\"http\\\" | \\\"https\\\",\\r\\n  host: string,\\r\\n  version: 1, // Should be a string: \\\"1\\\"\\r\\n})\\r\\n```\\n\\n## path-query\\n\\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\\r\\n\\r\\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\\n\\n### Example\\n\\nInstead of:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users?filter={filter}\\\")\\r\\nop getUsers(filter: string): User[];\\r\\n```\\r\\n\\r\\nUse:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users\\\")\\r\\nop getUsers(@query filter?: string): User[];\\r\\n```\\r\\n\\r\\nAlternatively, you can leverage TypeSpec's support for URI templates:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users{?filter}\\\")\\r\\nop getUsers(filter?: string): User[];\\r\\n```\\n\\n## union-null\\n\\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\\r\\nrepresented in OpenAPI.\\r\\n\\r\\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\\n\\n## union-unsupported\\n\\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\\r\\n\\r\\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"ARM-Auto-SignOff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/ARM-Auto-SignOff\",\"content\":\"# ARM-Auto-SignOff.md\\n\\n## Remaining Work\\n\\n- [ARM Auto SignOff] Update for GA: https://github.com/Azure/azure-rest-api-specs/pull/33440\\n\\n## Test PRs\\n\\n- RM TSP: https://github.com/Azure/azure-rest-api-specs/pull/32545\\r\\n- DP TSP: https://github.com/Azure/azure-rest-api-specs/pull/32694\\n\\n## Issue Queries\\n\\n```\\r\\nbase:main AND\\r\\nis:pr AND\\r\\nis:open AND\\r\\n(label:ARMAutoSignedOff OR\\r\\n (label:TypeSpec AND\\r\\n  label:ARMReview AND\\r\\n  -label:NotReadyForARMReview AND\\r\\n  (-label:SuppressionReviewRequired OR\\r\\n   label:Approved-Suppression)))\\r\\n```\\r\\nhttps://github.com/Azure/azure-rest-api-specs/issues?q=base%3Amain%20AND%20is%3Apr%20AND%20is%3Aopen%20AND%20(label%3AARMAutoSignedOff%20OR%20(label%3ATypeSpec%20AND%20label%3AARMReview%20AND%20-label%3ANotReadyForARMReview%20AND%20(-label%3ASuppressionReviewRequired%20OR%20label%3AApproved-Suppression)))\\r\\n\\r\\nhttps://github.com/Azure/azure-rest-api-specs-pr/issues?q=base%3Amain%20AND%20is%3Apr%20AND%20is%3Aopen%20AND%20(label%3AARMAutoSignedOff%20OR%20(label%3ATypeSpec%20AND%20label%3AARMReview%20AND%20-label%3ANotReadyForARMReview%20AND%20(-label%3ASuppressionReviewRequired%20OR%20label%3AApproved-Suppression)))\\n\\n## Source Code\\n\\n* ARM Incremental TypeSpec\\r\\n  * Determines if PR contains only incremental changes to an existing TypeSpec RP\\r\\n  * https://github.com/Azure/azure-rest-api-specs/blob/main/.github/workflows/arm-incremental-typespec.yaml\\r\\n* ARM Auto SignOff\\r\\n  * Combines results of \\\"ARM Incremental TypeSpec\\\", labels, and checks to determine if PR is eligible for auto sign-off\\r\\n  * https://github.com/Azure/azure-rest-api-specs/blob/main/.github/workflows/arm-auto-signoff.yaml\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_14.md\",\"document_title\":\"Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_14.md\\n\\n# Looking for someone to suppress CI failures https://github.com/Azure/azure-rest-api-specs/pull/36221\\n\\n## question\\n\\nHi I'm looking for someone to help suppress CI Failure on this PR [new addProxyAgentExtension property for proxyagentsettings by huiminyan2017 · Pull Request #36221 · Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/36221)\\r\\n \\r\\nCompute has multiple API versions so the Avacado check failure is expected.\\n\\n## answer\\n\\nYour PR is to a feature branch, so no checks are required.\\r\\n \\r\\nHowever, your PR may be blocked when you try to merge to main, so I recommend following the instructions here now:\\r\\n \\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado#multiple_api_version\\r\\n```\\r\\nMULTIPLE_API_VERSION\\r\\nRule MULTIPLE_API_VERSION was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this Uniform Versioning Violation Guide wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_29.md\",\"document_title\":\"PR gateway pipelines not starting/waiting for long time\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_29.md\\n\\n# PR gateway pipelines not starting/waiting for long time\\n\\n## question\\n\\nHi team,\\r\\n \\r\\nwe are adding new api version to our current swagger and in that 2 pipeline checks are queued/waiting from long time and not getting the status reported due to which we cant merge the swagger as these are required ones.\\r\\n```\\r\\n2 pending checks  \\r\\nSDK Validation Status  Expected — Waiting for status to be reported  Required  \\r\\nSwagger PrettierCheck  Expected — Waiting for status to be reported  Required  \\r\\n```\\r\\nPR - [Swagger Changes for Solution Metadata RT by AbhishekSinha-AEP · Pull Request #24090 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/24090)\\r\\n\\r\\nWe also tried to create same new PR in thought that old PR may have some transient issue but in newly create same PR we are facing same issue\\r\\nNew PR: [Swagger Changes for Solution Metadata RT by AbhishekSinha-AEP · Pull Request #24204 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/24204)\\r\\n\\r\\nIn both PRs. same facing same issue and cannot head towards merge.\\r\\n\\r\\nCan some one help here.\\r\\n\\r\\nThanks\\n\\n## answer\\n\\nLooks like a permissions issue.  The PR author needs to make their membership in Azure public, not private.  And also join the Azure SDK Partners group.\\r\\n\\r\\nhttps://aka.ms/azsdk/access\\r\\n\\r\\nhttps://github.com/orgs/Azure/people?query=AbhishekSinha-AEP\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_12.md\",\"document_title\":\"SDK Validation steps are failing with not much helpful logs\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_12.md\\n\\n# SDK Validation steps are failing with not much helpful logs\\n\\n## question\\n\\nWe’re in the process of creating a new API version within our RP. However, all SDK-related checks are currently failing, and we’re unable to identify any issues flagged in our changes.\\r\\n \\r\\nCould you please assist us in resolving these failures at the earliest? Your support will help us move forward without further delays.\\r\\n\\r\\n```\\r\\nErrors occurred while generating SDK from specification/advisor. Follow the steps at https://aka.ms/azsdk/sdk-automation-faq#how-to-view-the-detailed-sdk-generation-errors to view detailed errors.\\r\\n[ERROR] total 1 error(s):\\r\\n[ERROR] failed to execute `tsp-client init --update-if-exists --tsp-config /mnt/vss/_work/1/s/azure-rest-api-specs-pr/specification/advisor/Advisor.Management/tspconfig.yaml --commit 028d4d7cae9471f24a06aea6a1f60bf01f37f567 --repo Azure/azure-rest-api-specs-pr --local-spec-repo /mnt/vss/_work/1/s/azure-rest-api-specs-pr/specification/advisor/Advisor.Management --emitter-options module-version=0.1.0 --debug`\\r\\n[ERROR] Please update your tspconfig.yaml to include the \\\"emitter-output-dir\\\" option under the \\\"@azure-tools/typespec-go\\\" emitter options. \\\"package-dir\\\" support is deprecated and will be removed in future versions.\\r\\n[ERROR] Error reading tsp-location.yaml: Error: ENOENT: no such file or directory, stat '/mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/tsp-location.yaml'\\r\\n[ERROR] Diagnostics were reported during compilation. Use the `--debug` flag to see if there is warning diagnostic output.\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\n\\noutput.\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:7:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/back-compatible.tsp:10:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go-pr/sdk/resourcemanager/advisor/armadvisor/TempTypeSpecFiles/Advisor.Management/client.tsp:10:37 - error invalid-ref: Namespace Azure.ClientGenerator.Core.Legacy doesn't have member flattenProperty\\r\\n```\\r\\n\\r\\n```\\r\\nSome checks were not successful\\r\\n7 failing, 2 pending, 1 queued, 31 successful checks\\r\\n\\r\\n7 failing checks\\r\\nprivate.rest-api-specs-pr Failing after 1m — Build #Azure OpenAPI failed\\r\\nprivate.rest-api-specs-pr (BranchProtectionForPrivateRepo) Failing after 1m — BranchProtectionForPriv...\\r\\nSDK Validation - .NET - PR Failing after 7m — Build #20250911.25 failed\\r\\nSDK Validation - Go - PR Failing after 4m — Build #20250911.25 failed\\r\\nSDK Validation - Java - PR Failing after 4m — Build #20250911.25 failed\\r\\nSDK Validation - JS - PR Failing after 3m — Build #20250911.25 failed\\r\\nSDK Validation - Python - PR Failing after 7m — Build #20250911.25 failed\\r\\n\\r\\nMerging is blocked\\r\\n```\\r\\n\\r\\nPR: [Advisor Risks : 2025-09-01-preview by pranatiy0701 · Pull Request #24395 · Azure/azure-rest-api-spe…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24395)\\n\\n## answer\\n\\nIt looks like your PR is against the main branch of the private repo - we don't check api specs into this branch.  The sdk failures for flattenProperty are due to those SDKs not being up-to-date with the latest version of typespec-client-generator-core, which was released earlier this week.  Since you are not checking this spec in to the main branch of the private repo, these can be safely ignored.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_17.md\",\"document_title\":\"Many Swagger ModelValidation Error:　XMS_EXAMPLE_NOTFOUND_ERROR\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_17.md\\n\\n# Many Swagger ModelValidation Error:　XMS_EXAMPLE_NOTFOUND_ERROR\\n\\n## question\\n\\nThis is my [PR](https://github.com/Azure/azure-rest-api-specs/pull/36687). And I got so many Swagger ModelValidation errors : XMS_EXAMPLE_NOTFOUND_ERROR ,  please check the [link](https://github.com/Azure/azure-rest-api-specs/actions/runs/18519995562/job/52777696829?pr=36687).\\r\\n```\\r\\nError reported:\\r\\n\\r\\n{\\r\\n  code: 'XMS_EXAMPLE_NOTFOUND_ERROR',\\r\\n  message: 'x-ms-example not found in Provider_GetAvailableStacks.',\\r\\n  schemaUrl: 'specification/web/resource-manager/Microsoft.Web/AppService/stable/2025-03-01/openapi.json',\\r\\n  exampleUrl: undefined,\\r\\n  schemaPosition: { line: 456, column: 14 },\\r\\n  schemaJsonPath: undefined,\\r\\n  examplePosition: undefined,\\r\\n  exampleJsonPath: undefined,\\r\\n  severity: 0,\\r\\n  source: 'global',\\r\\n  operationId: 'Provider_GetAvailableStacks',\\r\\n  level: '\\\\x1B[31merror\\\\x1B[39m'\\r\\n}\\r\\n...\\r\\n``` \\r\\nActually, there is not any related example in the operation in the origin swagger.  \\r\\nI could find the latest merged [PR](https://github.com/Azure/azure-rest-api-specs/pull/37883)  and it does not have the same problem. \\r\\nThanks for your support.\\n\\n## answer\\n\\nThe errors are indicating that your operations are missing examples. ModelValidation requires an example for each operation, so the next steps are either to add examples or apply a suppression. Since ModelValidation has bugs in suppressions, you can unblock the PR by using the label Approved-ModelValidation, or alternatively, generate the missing examples.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_10.md\",\"document_title\":\"Service under conversation label\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_10.md\\n\\n# Service under conversation label\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\nMy team currently has a PR open to release a new stable API. However, due to backend delays, it’s been open since July. During that time, the [typespec migration PR](https://github.com/Azure/azure-rest-api-specs/pull/36556) was drafted against our preview API. Now, the service-under-conversion label has been added to our stable PR. I’d like to understand does this label indicate a delay in merging in our [stable api PR](https://github.com/Azure/azure-rest-api-specs/pull/36219), or will we need to make additional changes?\\n\\n## answer\\n\\nThe label should not impact your previous PR, and , if this is a later api-version thatn the conversion PR, the conversion would normally be based on that version once checked in.  Adding Janine Zhang for awareness about the conversion.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_26.md\",\"document_title\":\"Is TypeSpec migration complete for folder: recoveryservicesbackup.\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_26.md\\n\\n# Is TypeSpec migration complete for folder: recoveryservicesbackup.\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\nWe had PR in flight: [Adding stable 2025 08 01 for completeness by risraj10 · Pull Request #37381 · Azure/azure-rest-api-…](https://github.com/Azure/azure-rest-api-specs/pull/37381)\\r\\nHowever, I see that TypeSpec migration was done couple of days ago for this folder. \\r\\nI have cancelled the above PR and trying to raise a new PR. However, just running npx tsp compile without any change is giving errors.\\r\\nAnd also it is making unintended change to OpenAPI json file even to existing version. I guess the tsp and OpenAPI json are not in sync.\\r\\nHence, wanted to check if the migration is really complete for this folder.\\n\\n## answer\\n\\nMain typespec validation should always be passing are you sure you are up you are with dependencies locally?\\r\\nMake sure to follow instructions here https://aka.ms/ci-fix\\r\\nJust to reiterate, this is almost always because you need to pull the latest from the target branch into your local clone of the repo, and re-install dependencies at the root.\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_29.md\",\"document_title\":\"PR gateway pipelines not starting/waiting for long time\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_29.md\\n\\n# PR gateway pipelines not starting/waiting for long time\\n\\n## question\\n\\nHi team,\\r\\n \\r\\nwe are adding new api version to our current swagger and in that 2 pipeline checks are queued/waiting from long time and not getting the status reported due to which we cant merge the swagger as these are required ones.\\r\\n```\\r\\n2 pending checks  \\r\\nSDK Validation Status  Expected — Waiting for status to be reported  Required  \\r\\nSwagger PrettierCheck  Expected — Waiting for status to be reported  Required  \\r\\n```\\r\\nPR - [Swagger Changes for Solution Metadata RT by AbhishekSinha-AEP · Pull Request #24090 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/24090)\\r\\n\\r\\nWe also tried to create same new PR in thought that old PR may have some transient issue but in newly create same PR we are facing same issue\\r\\nNew PR: [Swagger Changes for Solution Metadata RT by AbhishekSinha-AEP · Pull Request #24204 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/24204)\\r\\n\\r\\nIn both PRs. same facing same issue and cannot head towards merge.\\r\\n\\r\\nCan some one help here.\\r\\n\\r\\nThanks\\n\\n## answer\\n\\nLooks like a permissions issue.  The PR author needs to make their membership in Azure public, not private.  And also join the Azure SDK Partners group.\\r\\n\\r\\nhttps://aka.ms/azsdk/access\\r\\n\\r\\nhttps://github.com/orgs/Azure/people?query=AbhishekSinha-AEP\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"troubleshoot#status-read-only-error.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/troubleshoot/status-read-only-error\",\"content\":\"# `ProvisioningStateMustBeReadOnly` lintdiff violation in TypeSpec for ARM Service\\nWhen trying to check in an ARM specification to the `azure-rest-api-specs` repository, your specification\\r\\nshows violations of the `ProvisioningStateMustBeReadOnly` lintdiff check.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-specs-pr.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr\",\"content\":\"# Create a pull request with your Azure REST API spec update\\n## Get your PR merged\\n| Short Link: | [aka.ms/azsdk/specreview/merge](https://aka.ms/azsdk/specreview/merge) |\\r\\n|-|-|\\r\\n\\r\\nTo get your PR merged:\\r\\n\\r\\n1. Ensure the `Next Steps to Merge` comment and `Automated merging requirements met` check are green. \\r\\n1. Ensure at least one person has approved your PR. Generally another person from your team that has [write access] to the repo.\\r\\n1. Ensure all required checks are passing and at least investigate to understand any other non-required checks that may be failing. \\r\\n1. Once all required checks are green and any other issues understood you can merge the PR yourself as long as you have [write access] to the repo.\\r\\n1. If your PR is targeting public `main` you will need to first apply the `PublishToCustomers` label to acknowledge you understand this \\r\\n   will cause your spec to be published so customers can consume it.\\r\\n1. If your PR is targeting private repo `main` branch, it **cannot** be merged.\\r\\n   Instead, you can publish your changes to customers by following the guide at [aka.ms/azsdk/move-pr].\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\nWorkaround is for PR reviewer to apply label `Approved-Avocado` until tool issues are fixed.\\r\\n\\r\\n1. [Allow specs with readme.md in sub-folders under resource-manager](https://github.com/Azure/azure-rest-api-specs/issues/32445)\\r\\n2. [[MISSING_APIS_IN_DEFAULT_TAG] False positive on deprecated APIs](https://github.com/Azure/avocado/issues/150)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Branch protection rules table\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\nThis table shows which GitHub checks are marked as `required` on respective branches. Even when a check is marked as ❌\\r\\nit **may** still be running on given branch; just that if it fails, the PR won't be blocked from merging.\\r\\n\\r\\n| Branch | Merge | SDK | TSVal | BrCh | BrChC | LintRPaaS | LintDiff | Model | Semantic | Spell | Prettier | license | approver |\\r\\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\\r\\n| public `main`                  | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSMaster`         | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| public/private `release-*`     | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSDev`            | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `InternalARMContracts` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `ARMCoreRPDev`         | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n\\r\\nLegend:\\r\\n\\r\\n| Column name | Full GitHub check name               |\\r\\n|-------------|--------------------------------------|\\r\\n| `BrCh`      | `Swagger BreakingChange`             |\\r\\n| `BrChC`     | `Breaking Change(Cross-Version)`     |\\r\\n| `license`   | `license/cla`                        |\\r\\n| `LintDiff`  | `Swagger LintDiff`                   |\\r\\n| `LintRPaaS` | `Swagger Lint(RPaaS)`                |\\r\\n| `Merge`     | `Automated merging requirements met` |\\r\\n| `Model`     | `Swagger ModelValidation`            |\\r\\n| `Prettier`  | `PrettierCheck`                      |\\r\\n| `SDK`       | `SDK azure-sdk-for-go`               |\\r\\n| `Semantic`  | `Swagger SemanticValidation`         |\\r\\n| `Spell`     | `SpellCheck`                         |\\r\\n| `TSVal`     | `TypeScript Validation`              |\\r\\n| `approver`  | Requires team member approval        |\\r\\n\\r\\nFor more information on these checks, see:\\r\\n\\r\\n- https://aka.ms/azsdk/pr-getting-help\\r\\n- https://aka.ms/ci-fix\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#reproducibility.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/handbook/reproducibility\",\"content\":\"# Reproducibility\\nA crucial aspect of service definition is ensuring consistent output over time. This is important in scenarios such as:\\r\\n\\r\\n- An update to a dependency or sub-dependency introduces an unexpected breaking change.\\r\\n- Updates to a new version of a service should not impact older versions.\\r\\n- Modifications are made to the TypeSpec specification.\\r\\n\\r\\nThese issues can be mitigated with a few precautionary measures:\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"libraries#http#authentication.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/libraries/http/authentication\",\"content\":\"# Authentication\\n## Available security schemes\\nSecurity scheme models can be found in the [TypeSpec HTTP library](https://github.com/microsoft/typespec/blob/main/packages/http/lib/auth.tsp)\"},{\"document_source\":\"typespec_http_specs\",\"document_filename\":\"authentication#http#custom#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/authentication/http/custom/main.tsp\",\"content\":\"# Usages for Illustrates clients generated with generic HTTP auth.\\n## Scenario: Expects header 'Authorization': 'SharedAccessKey valid-key'\\nCheck whether client is authenticated\\r\\n``` typespec\\r\\n@doc(\\\"Check whether client is authenticated\\\")\\r\\n@get\\r\\n@route(\\\"/valid\\\")\\r\\nop valid(): NoContentResponse;\\r\\n```\\r\\n\\r\\n## Scenario: Check whether client is authenticated.\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_http_specs\",\"document_filename\":\"authentication#union#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/authentication/union/main.tsp\",\"content\":\"# Usages for Illustrates clients generated with ApiKey and OAuth2 authentication.\\n## Scenario: Check whether client is authenticated\\n``` typespec\\r\\n@doc(\\\"Check whether client is authenticated\\\")\\r\\n@get\\r\\n@route(\\\"/validkey\\\")\\r\\nop validKey(): NoContentResponse;\\r\\n```\\r\\n\\r\\n## Scenario: Check whether client is authenticated\\r\\n\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-suppressions.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions\",\"content\":\"# Suppress validation failures on a PR\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nOn your Azure REST API specs PR, some of the GitHub check failures (see the `Checks` tab on your PR) can be suppressed.\\r\\nThe suppression can be either just for the PR, or permanent.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Addressing `VersioningReviewRequired`\\n### `Versioning-Approved-Previously`\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-arm-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-arm-review\",\"content\":\"# Get your PR reviewed by ARM\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nIf your Azure REST API specs PR pertains to ARM (see [glossary](xref:glossary#arm)) specs,\\r\\nthen the second step of the PR approval process per the [PR workflow diagram] (https://aka.ms/azsdk/pr-diagram)\\r\\nis the ARM review. The overall PR approval process is explained at https://aka.ms/azsdk/specreview/merge.\\r\\n\\r\\nIf your PR does not pertain to ARM specs, then this article won't be relevant to you.\\r\\nSee instead [`Getting help` section] on your PR (https://aka.ms/azsdk/pr-getting-help).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-review\",\"content\":\"# Schedule a data plane REST API spec review\\n## Requesting an offline REST API review\\n### When offline reviews are appropriate\\nAn offline review is appropriate when the following conditions hold:\\r\\n\\r\\n- The prior API version was reviewed and approved by the API Stewardship board.\\r\\n- The new API version makes only minor changes to the prior API version, such as\\r\\n  - Fields added to an API response\\r\\n  - Optional parameters or fields added to a request\\r\\n- The PR for the new API version is passing all PR pipeline checks.\\r\\n- The TypeSpec and OpenAPI APIViews for the PR were successfully generated and clearly show\\r\\nthe changes without extra \\\"noise\\\".\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Advanced cases\\n### Internal-only services\\nThere are some services that are \\\"internal only\\\" - none of their API versions are published in the public specs repo.\\r\\nThe Azure SDK team tooling running on the specs PRs may need to be updated to handle such cases.  \\r\\n[source](https://github.com/Azure/azure-sdk-tools/issues/7697#issuecomment-1980956741).\"}]",
            "inputs.latency": 968.1977262496948,
            "inputs.response_length": 1428,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-specs-pr",
                "https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches"
            ],
            "inputs.testcase": "Stuck in license/cla and Automated Merge checks for more than 1 hour",
            "outputs.similarity.similarity": 3.0,
            "outputs.similarity.gpt_similarity": 3.0,
            "outputs.similarity.similarity_result": "fail",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1342,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1343,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Stuck in license/cla and Automated Merge checks for more than 1 hour\\\\n\\\\nquestion: Hi, my PR got ARMSignoff and all requirements seem to have met. But it is still waiting on these 2 required checks - \\\\\\\"license/cla\\\\\\\" and \\\\\\\"Automated Merge\\\\\\\" which I verified that are completed and succeeded. It is stuck here for more than an hour. Is this expected or known issue? Any pointers would help. Thanks!\\\\nPR - [Add ACA env connection to caphost by sarajag \\\\u00b7 Pull Request #38223 \\\\u00b7 Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs/pull/38223)\\\", \\\"response\\\": \\\"This situation is not expected and is a known issue that can occasionally affect PRs in the Azure/azure-rest-api-specs repo, especially regarding required GitHub checks like \\\\\\\"license/cla\\\\\\\" and \\\\\\\"Automated Merge\\\\\\\" showing as stuck or not updating their status even after successful completion. \\\\n\\\\nAccording to the PR workflow guidance, once all required checks (including license/cla and Automated Merge) are green, and you have the necessary approvals (like ARMSignoff), you should be able to merge your PR. If you observe that these checks are stuck in a waiting state, the most common causes are:\\\\n\\\\n- Transient GitHub status update issues (cache, webhook delivery, etc.)\\\\n- Permission or membership problems (though not usually the case if you already see succeeded status)\\\\n- Rare infra delays\\\\n\\\\nRecommended next steps:\\\\n1. Try closing and reopening the PR (this can retrigger the checks and often resolves the stuck state).\\\\n2. Ensure your Azure organization membership is public and you are part of the Azure SDK Partners group (see https://aka.ms/azsdk/access), but this is less likely if the checks are green.\\\\n3. If the issue persists, reach out in your PR comments or via https://aka.ms/azsdk/pr-getting-help for repo admin assistance.\\\\n\\\\nThis kind of issue has been observed before and is generally resolved by retriggering the checks or with admin intervention. You do not need to rebase or force-push unless specifically advised.\\\", \\\"ground_truth\\\": \\\"this membership must be public: https://github.com/orgs/Azure/people?query=sarajag\\\\nplease follow all the steps here: https://aka.ms/azsdk/access\\\\nyou should also join Microsoft org (and make your membership public):\\\\nhttps://github.com/orgs/Microsoft/people?query=sarajag\\\\nafter fixing your org memberships, push another commit to your PR to re-run checks\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"
        },
        {
            "inputs.query": "title: Copy-ApiVersion.ps1 is no longer available\n\nquestion: I am networking team and working on creation of new swagger release branch for api version 2025-05-01. As part of the process, we used to execute Copy-ApiVersion.ps1 command to update some of the references form old version to new version\nI see that above script file is no longer available. Could you please suggest if there is any alternative script added in place of this or do we need to perform the changes manually?",
            "inputs.ground_truth": "The script is deprecated, and no longer supported.  It was removed in these PRs, which you can view for context on the change:\nhttps://github.com/Azure/azure-rest-api-specs/pull/37818\nhttps://dev.azure.com/azure-sdk/internal/_git/azure-sdk-docs-eng.ms/pullrequest/1323\nThe new docs have (brief) instructions you can use in place of the script:\n```\nCreate a new directory that will include all the OpenAPI spec files and examples.\nCopy the OpenAPI specs files from an existing version to use it as a base for your new work, and update all the old version references in said specs files to the new version.\nUpdate the Autorest configuration readme with the new version Tag.\n```",
            "inputs.response": "Based on the latest Azure API spec and TypeSpec processes, there is currently **no direct replacement script** for Copy-ApiVersion.ps1. The recommended approach is to manually perform the necessary changes for your new release branch:\n\n- **Create a new release branch** (as before) for the new API version.\n- **Copy all relevant spec files and examples** from the previous version directory to the new version's directory.\n- **Update all version references** in the spec files, examples, and configuration files (e.g., readme.md) to the new API version (2025-05-01).\n\nThis is in alignment with the documented Azure REST API and TypeSpec workflow. For TypeSpec-based APIs, you encode versioning changes using decorators (like @added, @removed, @renamedFrom) rather than duplicating the whole API spec, which makes the process simpler. For Swagger/OpenAPI-based APIs, the process is still manual: copy, update references, and update the readme tag for the new version.\n\nThere is no automated script provided by the Azure REST API specs repo to replace Copy-ApiVersion.ps1 at this time. You may create your own automation for repetitive tasks, but official guidance is to perform these steps manually.",
            "inputs.context": "[{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#Guidelines.md\",\"document_title\":\"Microsoft Azure REST API Guidelines\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md\",\"content\":\"# azure#Guidelines.md\\n\\n# Microsoft Azure REST API Guidelines\\n\\n\\u003c!-- cspell:ignore autorest, BYOS, etag, idempotency, maxpagesize, innererror, trippable, nextlink, condreq, etags --\\u003e\\r\\n\\u003c!-- markdownlint-disable MD033 MD049 MD055 --\\u003e\\r\\n\\r\\n\\u003c!--\\r\\nNote to contributors: All guidelines now have an anchor tag to allow cross-referencing from associated tooling.\\r\\nThe anchor tags within a section using a common prefix to ensure uniqueness with anchor tags in other sections.\\r\\nPlease ensure that you add an anchor tag to any new guidelines that you add and maintain the naming convention.\\r\\n--\\u003e\\n\\n## History\\n\\n\\u003cdetails\\u003e\\r\\n  \\u003csummary\\u003eExpand change history\\u003c/summary\\u003e\\r\\n\\r\\n| Date        | Notes                                                          |\\r\\n| ----------- | -------------------------------------------------------------- |\\r\\n| 2025-Mar-28 | Added guidelines about JSON ID and null values                 |\\r\\n| 2024-Mar-17 | Updated LRO guidelines                                         |\\r\\n| 2024-Jan-17 | Added guidelines on returning string offsets \\u0026 lengths         |\\r\\n| 2023-May-12 | Explain service response for missing/unsupported `api-version` |\\r\\n| 2023-Apr-21 | Update/clarify guidelines on POST method repeatability         |\\r\\n| 2023-Apr-07 | Update/clarify guidelines on polymorphism                      |\\r\\n| 2022-Sep-07 | Updated URL guidelines for DNS Done Right                      |\\r\\n| 2022-Jul-15 | Update guidance on long-running operations                     |\\r\\n| 2022-May-11 | Drop guidance on version discovery                             |\\r\\n| 2022-Mar-29 | Add guidelines about using durations                           |\\r\\n| 2022-Mar-25 | Update guideline for date values in headers to follow RFC 7231 |\\r\\n| 2022-Feb-01 | Updated error guidance                                         |\\r\\n| 2021-Sep-11 | Add long-running operations guidance                           |\\r\\n| 2021-Aug-06 | Updated Azure REST Guidelines per Azure API Stewardship Board. |\\r\\n| 2020-Jul-31 | Added service advice for initial versions                      |\\r\\n| 2020-Mar-31 | 1st public release of the Azure REST API Guidelines            |\\r\\n\\r\\n\\u003c/details\\u003e\\n\\n## Introduction\\n\\nThese guidelines apply to Azure service teams implementing _data plane_ APIs. They offer prescriptive guidance that Azure service teams MUST follow ensuring that customers have a great experience by designing APIs meeting these goals:\\r\\n- Developer friendly via consistent patterns \\u0026 web standards (HTTP, REST, JSON)\\r\\n- Efficient \\u0026 cost-effective\\r\\n- Work well with SDKs in many programming languages\\r\\n- Customers can create fault-tolerant apps by supporting retries/idempotency/optimistic concurrency\\r\\n- Sustainable \\u0026 versionable via clear API contracts with 2 requirements:\\r\\n  1. Customer workloads must never break due to a service change\\r\\n  2. Customers can adopt a version without requiring code changes\\r\\n\\r\\nTechnology and software is constantly changing and evolving, and as such, this is intended to be a living document. [Open an issue](https://github.com/microsoft/api-guidelines/issues/new/choose) to suggest a change or propose a new idea. Please read the [Considerations for Service Design](./ConsiderationsForServiceDesign.md) for an introduction to the topic of API design for Azure services. *For an existing GA'd service, don't change/break its existing API; instead, leverage these concepts for future APIs while prioritizing consistency within your existing service.*\\r\\n\\r\\n*Note: If you are creating a management plane (ARM) API, please refer to the [Azure Resource Manager Resource Provider Contract](https://github.com/cloud-and-ai-microsoft/resource-provider-contract).*\\n\\n### Prescriptive Guidance\\n\\nThis document offers prescriptive guidance labeled as follows:\\r\\n\\r\\n:white_check_mark: **DO** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n:ballot_box_with_check: **YOU SHOULD** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:heavy_check_mark: **YOU MAY** consider this pattern if appropriate to your situation. No notification to the Azure HTTP/REST Stewardship Board is required.\\r\\n\\r\\n:warning: **YOU SHOULD NOT** adopt this pattern. If not following this advice, you MUST disclose your reason during the Azure HTTP/REST Stewardship Board review.\\r\\n\\r\\n:no_entry: **DO NOT** adopt this pattern. If you feel you need an exception, contact the Azure HTTP/REST Stewardship Board **prior** to implementation.\\r\\n\\r\\n*If you feel you need an exception, or need clarity based on your situation, please contact the Azure HTTP/REST Stewardship Board **prior** to release of your API.*\\n\\n## Building Blocks: HTTP, REST, \\u0026 JSON\\n\\nThe Microsoft Azure Cloud platform exposes its APIs through the core building blocks of the Internet; namely HTTP, REST, and JSON. This section provides you with a general understanding of how these technologies should be applied when creating your service.\\r\\n\\r\\n\\u003ca href=\\\"#http\\\" name=\\\"http\\\"\\u003e\\u003c/a\\u003e\\n\\n### HTTP\\n\\ncase-sensitive, multiple delimiter\\r\\nUUID      | 123e4567-e89b-12d3-a456-426614174000 (no {}s, hyphens, case-insensitive) [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122)\\r\\nDate/Time (Header) | Sun, 06 Nov 1994 08:49:37 GMT [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1)\\r\\nDate/Time (Query parameter) | YYYY-MM-DDTHH:mm:ss.sssZ (with at most 3 digits of fractional seconds) [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339)\\r\\nByte array | Base-64 encoded, max length\\r\\nArray      | One of a) a comma-separated list of values (preferred), or b) separate `name=value` parameter instances for each value of the array\\r\\n\\r\\n\\r\\nThe table below lists the headers most used by Azure services:\\r\\n\\r\\nHeader Key          | Applies to | Example\\r\\n------------------- | ---------- | -------------\\r\\n_authorization_     | Request    | Bearer eyJ0...Xd6j (Support Azure Active Directory)\\r\\n_x-ms-useragent_    | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntraceparent         | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\ntracecontext        | Request    | (see [Distributed Tracing \\u0026 Telemetry](#distributed-tracing--telemetry))\\r\\naccept              | Request    | application/json\\r\\nIf-Match            | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-None-Match       | Request    | \\\"67ab43\\\" or * (no quotes) (see [Conditional Requests](#conditional-requests))\\r\\nIf-Modified-Since   | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\nIf-Unmodified-Since | Request    | Sun, 06 Nov 1994 08:49:37 GMT (see [Conditional Requests](#conditional-requests))\\r\\ndate                | Both       | Sun, 06 Nov 1994 08:49:37 GMT (see [RFC 7231, Section 7.1.1.2](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.2))\\r\\n_content-type_      | Both       | application/merge-patch+json\\n\\nname=\\\"http-header-names-casing\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** specify headers using kebab-casing\\r\\n\\r\\n\\u003ca href=\\\"#http-header-names-case-sensitivity\\\" name=\\\"http-header-names-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header names using case-insensitivity\\r\\n\\r\\n\\u003ca href=\\\"#http-header-values-case-sensitivity\\\" name=\\\"http-header-values-case-sensitivity\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** compare request header values using case-sensitivity if the header name requires it\\r\\n\\r\\n\\u003ca href=\\\"#http-header-date-values\\\" name=\\\"http-header-date-values\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** accept date values in headers in HTTP-Date format and return date values in headers in the IMF-fixdate format as defined in [RFC 7231, Section 7.1.1.1](https://datatracker.ietf.org/doc/html/rfc7231#section-7.1.1.1), e.g. \\\"Sun, 06 Nov 1994 08:49:37 GMT\\\".\\r\\n\\r\\nNote: The RFC 7231 IMF-fixdate format is a \\\"fixed-length and single-zone subset\\\" of the RFC 1123 / RFC 5822 format, which means: a) year must be four digits, b) the seconds component of time is required, and c) the timezone must be GMT.\\r\\n\\r\\n\\u003ca href=\\\"#http-header-request-id\\\" name=\\\"http-header-request-id\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** create an opaque value that uniquely identifies the request and return this value in the `x-ms-request-id` response header.\\r\\n\\r\\nYour service should include the `x-ms-request-id` value in error logs so that users can submit support requests for specific failures using this value.\\r\\n\\r\\n\\u003ca href=\\\"#http-allow-unrecognized-headers\\\" name=\\\"http-allow-unrecognized-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** fail a request that contains an unrecognized header. Headers may be added by API gateways or middleware and this must be tolerated\\r\\n\\r\\n\\u003ca href=\\\"#http-no-x-custom-headers\\\" name=\\\"http-no-x-custom-headers\\\"\\u003e:no_entry:\\u003c/a\\u003e **DO NOT** use \\\"x-\\\" prefix for custom headers, unless the header already exists in production [[RFC 6648](https://datatracker.ietf.org/doc/html/rfc6648)].\\r\\n\\r\\n**Additional References**\\n\\nAzure services must adhere to the HTTP specification, [RFC 7231](https://tools.ietf.org/html/rfc7231). This section further refines and constrains how service implementors should apply the constructs defined in the HTTP specification. It is therefore, important that you have a firm understanding of the following concepts:\\r\\n\\r\\n- [Uniform Resource Locators (URLs)](#uniform-resource-locators-urls)\\r\\n- [HTTP Request / Response Pattern](#http-request--response-pattern)\\r\\n- [HTTP Query Parameters and Header Values](#http-query-parameters-and-header-values)\\r\\n\\r\\n#### Uniform Resource Locators (URLs)\\r\\n\\r\\nA Uniform Resource Locator (URL) is how developers access the resources of your service. Ultimately, URLs are how developers form a cognitive model of your service's resources.\\r\\n\\r\\n\\u003ca href=\\\"#http-url-pattern\\\" name=\\\"http-url-pattern\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** use this URL pattern:\\r\\n```text\\r\\nhttps://\\u003ctenant\\u003e.\\u003cregion\\u003e.\\u003cservice\\u003e.\\u003ccloud\\u003e/\\u003cservice-root\\u003e/\\u003cresource-collection\\u003e/\\u003cresou\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"howtos#arm#versioning.md\",\"document_title\":\"Versioning\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/howtos/arm/versioning\",\"content\":\"# howtos#arm#versioning.md\\n\\n# Versioning\\n\\nThis document explains how to manage versioning in TypeSpec projects, including how to add, remove, or modify resources, operations, and properties across API versions.\\n\\n## Introduction\\n\\nVersioning allows you to evolve your API without breaking existing clients. By using versioning decorators, you can specify when resources, operations, or properties are added, removed, or changed.\\n\\n## Declaring Versions\\n\\nDefine your API versions in an enum. For each version, specify dependencies and common types as needed.\\r\\n\\r\\n```tsp\\r\\n/** Contoso API versions */\\r\\nenum Versions {\\r\\n  /** 2021-10-01-preview version */\\r\\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\\r\\n  v1,\\r\\n\\r\\n  /** 2022-11-01-preview version */\\r\\n  @armCommonTypesVersion(Azure.ResourceManager.CommonTypes.Versions.v5)\\r\\n  v2,\\r\\n}\\r\\n```\\r\\n\\r\\nAfter defining your enum, link it to your namespace using the `@versioned` decorator:\\r\\n\\r\\n```tsp\\r\\n@versioned(Versions)\\r\\nnamespace Microsoft.ContosoProviderHub;\\r\\n```\\r\\n\\r\\n\\u003e **Note:** Add dependencies and common types for each version. After defining a new version, the emitter will produce outputs for all versions. You can then adapt your TypeSpec code for the latest version.\\n\\n## Simple Scenarios\\n\\nThese examples show how to add models, operations, properties, and parameters in specific versions using TypeSpec versioning decorators.\\n\\n### Adding Decoration to an Existing Type\\n\\nThis scenario demonstrates how to change a decorator’s usage across versions.\\r\\n\\r\\nSuppose you have a model property with a decorator:\\r\\n\\r\\n```tsp\\r\\nmodel Employee {\\r\\n  @visibility(Lifecycle.Read)\\r\\n  experience: string;\\r\\n}\\r\\n```\\r\\n\\r\\nIn the next version (v2), the visibility changes so that the property can be read or created. To achieve this, you can use a combination of `@removed`, `@added`, and `@renamedFrom` decorators:\\r\\n\\r\\n```tsp\\r\\nmodel Employee {\\r\\n  @removed(Versions.v2)\\r\\n  @visibility(Lifecycle.Read)\\r\\n  @renamedFrom(Versions.v2, \\\"experience\\\")\\r\\n  oldExperience: string;\\r\\n\\r\\n  @added(Versions.v2)\\r\\n  @visibility(Lifecycle.Read, Lifecycle.Create)\\r\\n  experience: string;\\r\\n}\\r\\n```\\n\\n### Adding a Parameter to an Operation and Making Another Parameter Optional\\n\\nThis scenario shows how to add a parameter and make another optional in an operation.\\r\\n\\r\\nSuppose you start with the following operation in v1:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  listBySubscription is ArmListBySubscription\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      @header\\r\\n      location: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\nIn version `v2`, you want to:\\r\\n\\r\\n- Make the `location` header parameter optional.\\r\\n- Add a new optional query parameter `orderBy`.\\r\\n\\r\\nYou can achieve this using the `@madeOptional` and `@added` decorators:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  listBySubscription is ArmListBySubscription\\u003c\\r\\n    Employee,\\r\\n    Parameters = {\\r\\n      @madeOptional(Versions.v2)\\r\\n      @header\\r\\n      location?: string;\\r\\n\\r\\n      @added(Versions.v2)\\r\\n      @query(\\\"order-by\\\")\\r\\n      orderBy?: string;\\r\\n    }\\r\\n  \\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\n**Explanation:**\\r\\n\\r\\n- `@madeOptional(Versions.v2)` makes `location` optional starting in v2.\\r\\n- `@added(Versions.v2)` adds the `orderBy` query parameter in v2 and later.\\n\\n### Converting an Operation from Synchronous to Asynchronous\\n\\nThis scenario illustrates converting a synchronous operation to an asynchronous one across versions.\\r\\n\\r\\nSuppose you start with the following synchronous operation in `v1`:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceSync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\nIn version `v2`, you update this operation to be asynchronous as follows:\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  @removed(Versions.v2)\\r\\n  @renamedFrom(Versions.v2, \\\"createOrUpdate\\\")\\r\\n  @sharedRoute\\r\\n  createOrUpdateV1 is ArmResourceCreateOrReplaceSync\\u003cEmployee\\u003e;\\r\\n\\r\\n  @added(Versions.v2)\\r\\n  @sharedRoute\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\r\\n\\r\\n**Explanation:**\\r\\n\\r\\n- `@removed(Versions.v2)` removes the original synchronous operation in v2 and later.\\r\\n- `@renamedFrom(Versions.v2, \\\"createOrUpdate\\\")` keeps the original name for v1.\\r\\n- `@added(Versions.v2)` adds the new asynchronous operation in v2 and later.\\r\\n- `@sharedRoute` ensures both operations can use the same route.\\n\\n## Versioning Decorators\\n\\n### @added\\n\\nYou can add new models, properties, or operations in a specific version and all subsequent versions using the `@added` decorator.\\r\\n\\r\\n- The `version` argument is the version where the element is introduced.\\r\\n- The element will be present in that version and all later versions.\\r\\n\\r\\n**Example: Adding a model and property across versions**\\r\\n\\r\\nFor example, suppose you want to add a new model and then add a property to it in a later version:\\r\\n\\r\\n```tsp\\r\\n// v1: No Employee model exists\\r\\n\\r\\n// v2: Add Employee model\\r\\n@added(Versions.v2)\\r\\nmodel Employee {\\r\\n  name?: string;\\r\\n}\\r\\n\\r\\n// v3: Add 'city' property to Employee\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n\\r\\n  @added(Versions.v3)\\r\\n  city?: string;\\r\\n}\\r\\n```\\r\\n\\r\\n**Example: Adding an operation in a later version**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n  // v3: Add createOrUpdate operation\\r\\n  @added(Versions.v3)\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\n\\n### @removed\\n\\nTo remove models, properties, or operations starting from a specific version, use the `@removed` decorator.\\r\\n\\r\\n- The `version` argument is the version where the element is removed.\\r\\n- The element will not be present in that version or any later versions.\\r\\n\\r\\n**Example: Removing a property and a model across versions**\\r\\n\\r\\nFor example:\\r\\n\\r\\n```tsp\\r\\n// v1: Employee model with 'city' property\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n  city?: string;\\r\\n}\\r\\n\\r\\n// v2: Remove 'city' property\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n\\r\\n  @removed(Versions.v2)\\r\\n  city?: string;\\r\\n}\\r\\n\\r\\n// v3: Remove Employee model entirely\\r\\n@removed(Versions.v3)\\r\\nmodel Employee {\\r\\n  name: string;\\r\\n}\\r\\n```\\r\\n\\r\\n**Example: Removing an operation**\\r\\n\\r\\n```tsp\\r\\n@armResourceOperations\\r\\ninterface Employees {\\r\\n  get is ArmResourceRead\\u003cEmployee\\u003e;\\r\\n  @removed(Versions.v3)\\r\\n  createOrUpdate is ArmResourceCreateOrReplaceAsync\\u003cEmployee\\u003e;\\r\\n}\\r\\n```\\n\\n### @madeRequired and @madeOptional\\n\\nUse these decorators to change whether a property is required or optional in a specific version.\\r\\n\\r\\n- Use `@madeOptional(Versions.version)` to make a property optional starting in that version.\\r\\n- Use `@madeRequired(Versions.version)` to make a property required starting in that version.\\r\\n\\r\\n**Example: Changing a property from required to optional, then back to required**\\r\\n\\r\\nFor example:\\r\\n\\r\\n```tsp\\r\\n// v1: movingStatus is required\\r\\nmodel MoveResponse {\\r\\n  movingStatus: string;\\r\\n}\\r\\n\\r\\n// v2: movingStatus becomes optional\\r\\nmodel MoveResponse {\\r\\n  @madeOptional(Versions.v2)\\r\\n  movingStatus?: string;\\r\\n}\\r\\n```\\n\\n### @renamedFrom\\n\\nUse `@renamedFrom` to rename models, properties, operations, enums, etc., in a specific version.\\r\\n\\r\\n- The `version` argument is the version where the name changed.\\r\\n- The `oldName` argument is the previous name.\\r\\n\\r\\n**Example: Renaming a property and a model across versions**\\r\\n\\r\\nFor example:\\r\\n\\r\\n```tsp\\r\\n// v1: Model and property have original names\\r\\nmodel WorkerProperties {\\r\\n  state?: string;\\r\\n}\\r\\n\\r\\n// v2: Rename property 'state' to 'city'\\r\\nmodel WorkerProperties {\\r\\n  @renamedFrom(Versions.v2, \\\"state\\\")\\r\\n  city?: string;\\r\\n}\\r\\n\\r\\n// v3: Rename model 'WorkerProperties' to 'EmployeeProperties'\\r\\n@renamedFrom(Versions.v3, \\\"WorkerProperties\\\")\\r\\nmodel EmployeeProperties {\\r\\n  @renamedFrom(Versions.v2, \\\"state\\\")\\r\\n  city?: string;\\r\\n}\\r\\n```\\n\\n## FAQ\\n\\n### How do I version a pattern?\\n\\nI have this model and I would like to change the pattern in v2\\r\\n\\r\\n```tsp\\r\\nmodel EmployeeProperties {\\r\\n  @pattern(\\\"^[a-z]+$\\\")\\r\\n  state: string;\\r\\n}\\r\\n```\\r\\n\\r\\n:::caution\\r\\n\\r\\nUpdating a pattern could be a breaking change:\\r\\n\\r\\n- A **more restrictive pattern** for input data would break existing clients that send previously valid data\\r\\n- A **less restrictive pattern** for output data could break client assumptions and validation logic\\r\\n\\r\\n:::\\r\\n\\r\\nThe key question is: **Does the pattern change apply to all API versions, or only to the new version?**\\r\\n\\r\\n#### 1. Pattern changes for all versions\\r\\n\\r\\nIf the pattern change reflects how your service actually behaves across all versions, update the pattern directly. The specification should accurately reflect the current state of your service.\\r\\n\\r\\n```diff lang=tsp\\r\\nmodel EmployeeProperties {\\r\\n-  @pattern(\\\"^[a-z]+$\\\")\\r\\n+  @pattern(\\\"^[a-zA-Z]+$\\\")\\r\\n   state: string;\\r\\n}\\r\\n```\\r\\n\\r\\n:::note\\r\\nThis will update all openapi specs versions with the new pattern which is the desired behavior.\\r\\n:::\\r\\n\\r\\n#### 2. Different patterns per version (**Very unlikely**)\\r\\n\\r\\nIf older API versions truly enforce a different pattern than newer versions, you need to model this explicitly using versioning decorators:\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#getting-started-rest#06-versioning.mdx\",\"document_title\":\"Versioning\",\"document_link\":\"https://typespec.io/docs/getting-started/getting-started-rest/06-versioning\",\"content\":\"# getting-started#getting-started-rest#06-versioning.mdx\\n\\n# Versioning\\n\\nimport { FileTree } from \\\"@astrojs/starlight/components\\\";\\n\\n## Introduction\\n\\nIn this section, we'll focus on implementing versioning in your REST API. Versioning allows you to manage changes to your API over time without breaking existing clients. We'll introduce the `@versioned` decorator, show how to define versions with enums, and demonstrate how to use the `@added` decorator to specify version-specific models and operations.\\n\\n## Adding the Versioning Library\\n\\nBefore we can use the versioning decorators, we need to add the `@typespec/versioning` library to our project. This involves updating the `package.json` file and installing the necessary dependencies.\\n\\n### Step 1: Update `package.json`\\n\\nAdd the `@typespec/versioning` library to your `package.json` file, in both the `peerDependencies` and `devDependencies` sections. Your updated `package.json` should look like this:\\r\\n\\r\\n```json\\r\\n{\\r\\n  \\\"name\\\": \\\"typespec-petstore\\\",\\r\\n  \\\"version\\\": \\\"0.1.0\\\",\\r\\n  \\\"type\\\": \\\"module\\\",\\r\\n  \\\"peerDependencies\\\": {\\r\\n    \\\"@typespec/compiler\\\": \\\"latest\\\",\\r\\n    \\\"@typespec/http\\\": \\\"latest\\\",\\r\\n    \\\"@typespec/openapi3\\\": \\\"latest\\\",\\r\\n    // highlight-next-line\\r\\n    \\\"@typespec/versioning\\\": \\\"latest\\\"\\r\\n  },\\r\\n  \\\"devDependencies\\\": {\\r\\n    \\\"@typespec/compiler\\\": \\\"latest\\\",\\r\\n    \\\"@typespec/http\\\": \\\"latest\\\",\\r\\n    \\\"@typespec/openapi3\\\": \\\"latest\\\",\\r\\n    // highlight-next-line\\r\\n    \\\"@typespec/versioning\\\": \\\"latest\\\"\\r\\n  },\\r\\n  \\\"private\\\": true\\r\\n}\\r\\n```\\n\\n### Step 2: Install Dependencies\\n\\nRun the following command to install the new dependencies:\\r\\n\\r\\n```sh\\r\\ntsp install\\r\\n```\\n\\n## Introduction to the `@versioned` Decorator\\n\\nThe [`@versioned`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.versioned) decorator is used to define different versions of your API. This decorator allows you to specify the versions that your API supports and manage changes across these versions.\\n\\n### Example: Defining API Versions\\n\\ndifferences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\\r\\n\\r\\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\\r\\n\\r\\n## Using the `@added` Decorator\\r\\n\\r\\nThe [`@added`](../../../libraries/versioning/reference/decorators/#@TypeSpec.Versioning.added) decorator is used to indicate that a model or operation was added in a specific version of the API. This allows you to manage changes and additions to your API over time.\\r\\n\\r\\n### Example: Adding a New Model in a Specific Version\\r\\n\\r\\nLet's add a `Toy` model that is only available in version 2 of the API:\\r\\n\\r\\n```\\n\\nLet's define two versions of our API, `v1` and `v2`:\\r\\n\\r\\n```tsp title=main.tsp tryit=\\\"{\\\"emit\\\": [\\\"@typespec/openapi3\\\"]}\\\"\\r\\nimport \\\"@typespec/http\\\";\\r\\n// highlight-next-line\\r\\nimport \\\"@typespec/versioning\\\";\\r\\n\\r\\nusing Http;\\r\\n// highlight-next-line\\r\\nusing Versioning;\\r\\n\\r\\n@service(#{ title: \\\"Pet Store\\\" })\\r\\n@server(\\\"https://example.com\\\", \\\"Single server endpoint\\\")\\r\\n// highlight-next-line\\r\\n@versioned(Versions)\\r\\nnamespace PetStore;\\r\\n\\r\\n// highlight-start\\r\\nenum Versions {\\r\\n  v1: \\\"1.0\\\",\\r\\n  v2: \\\"2.0\\\",\\r\\n}\\r\\n// highlight-end\\r\\n```\\r\\n\\r\\nIn this example:\\r\\n\\r\\n- We're importing and using a new module, `@typespec/versioning`, which provides versioning support.\\r\\n- The `@versioned` decorator is used to define the versions supported by the API, defined in the `Versions` enum.\\r\\n- The `Versions` enum specifies two versions: `v1` (1.0) and `v2` (2.0).\\r\\n\\r\\n### Generating OpenAPI Specifications for Different Versions\\r\\n\\r\\nOnce versions are added, the TypeSpec compiler generates individual OpenAPI specifications for each version.\\r\\n\\r\\n{/* prettier-ignore */}\\r\\n\\u003cFileTree\\u003e\\r\\n- main.tsp\\r\\n- tspconfig.yaml\\r\\n- package.json\\r\\n- node_modules/\\r\\n- tsp-output/\\r\\n  - @typespec/\\r\\n    - openapi3\\r\\n      - openapi.1.0.yaml\\r\\n      - openapi.2.0.yaml\\r\\n\\u003c/FileTree\\u003e\\r\\n\\r\\nGenerating separate specs for each version ensures backward compatibility, provides clear documentation for developers to understand differences between versions, and simplifies maintenance by allowing independent updates to each version's specifications.\\r\\n\\r\\nBy encapsulating different versions of the API within the context of the same TypeSpec project, we can manage all versions in a unified manner. This approach makes it easier to maintain consistency, apply updates, and ensure that all versions are properly documented and aligned with the overall API strategy.\\r\\n\\r\\n## Using the `@added` Decorator\\r\\n\\r\\nThe [`@added`](../../..\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"About-the-Wiki.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/About-the-Wiki\",\"content\":\"# About-the-Wiki.md\\n\\n## Overview\\n\\nFor an overview of this Wiki, see [[Home]].\\n\\n## Editing\\n\\nThe wiki can be edited using the GitHub UI (click \\\"Edit\\\" or \\\"New Page\\\"), or by cloning and pushing changes directly.  Unfortunately there is no way to make a Pull Request to the wiki repo.\\r\\n\\r\\n1. `git clone https://github.com/azure/azure-rest-api-specs.wiki.git`\\r\\n2. Make changes\\r\\n3. `git push` your changes to `master`\\r\\n   * Branch must be named `master`, not `main`.  The GitHub Wiki code appears to hardcode `origin/master` instead of using `origin/HEAD`.\\n\\n## Old Content\\n\\nContent prior to 6/20/24 was moved to branch `master-backup`, which can be viewed using `git` but not the GitHub Wiki UI.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"azure#apiVersionEvolution.md\",\"document_title\":\"Scenarios for API Evolution\",\"document_link\":\"\",\"content\":\"# azure#apiVersionEvolution.md\\n\\n# Scenarios for API Evolution\\n\\nThis document describe how to evolute api version for a management plane services.\\n\\n## Scenarios to Consider\\n\\nadd a new stable version\\r\\nadd a new preview version\\r\\nMaking a preview api stable\\r\\nReplacing a preview API with a new preview API\\r\\nReplacing a preview API with a stable API\\r\\nReplacing a preview API with a stable API and a new preview API\\r\\nAdding a preview API (previous stable API)\\r\\nConverting existing specs with mixes of preview and stable APIs\\r\\nNote that, in this new scenario, new services will always have only a single version in their specs until they have their first stable version.  This should drastically reduce the amount of decoration in preview APIs\\n\\n## Add a new stable version\\n\\n### TypeSpec Steps\\n\\n1. Check the Latest Version\\r\\n   1. Determine whether the latest version is a preview version or a stable (GA) version.\\r\\n2. If the Latest Version is Stable (GA):\\r\\n   1. Add a new entry for the new stable version at the bottom of the Versions enumeration\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Make changes to the API using versioning decorators to mark each change\\r\\n3. if the latest version is preview version: \\r\\n   1. Add a new stable (GA) version enum before the existing preview enum value.\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Update all items that are GA’ing:\\r\\n      1. Change their @added version value to match the new GA enum value.\\r\\n   4. Handle remaining preview-only features:\\r\\n      1. If some features are not GAed, create a new preview version and Decorate non-GA items with @added pointing to the new preview version.\\r\\n      2. If all features in the preview version are GAed, delete the existing preview version.\\n\\n## Replacing a Preview API with a new Preview API (Adding a Preview API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new preview api-version\\r\\n- rename the example folder to use the new version\\r\\n- Remove any api changes not in the new version (simply remove types or type change decorators that do not apply)\\r\\n- Change the API inline decorating any type changes or new types in the new versionSome tooling to pick which resources, types, and operations are part of the new API could be useful.\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a Stable API (Adding a stable API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new stable api-version. \\r\\n- Remove any @previewVersion decorator\\r\\n- rename the example folder to use the new stable api version\\r\\n- Remove any api changes not in the new stable API version. Some tooling to pick which resources, types, and operations are part of the new API could be useful.\\r\\n- Add any api changes in the new stable version, using versioning decorators unless it is the only api-version\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a new Stable and a Preview API (previous stable API exists)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the preview version in the \\\"versions\\\" enumeration to match the new preview version and all references\\r\\n- Add a new Stable version entry immediately before the renamed version entry\\r\\n- rename the example folder to use the new preview api version\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Relabel any api changes in the new stable API version, that is, any changes in the preview that are now considered stable. \\r\\n    - Some tooling to pick which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any api changes in the new stable version, using versioning decorators (automatically included in the new preview version)\\r\\n- Add any api changes still in preview in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with the first Stable API and a new Preview API (no previous stable api)\\n\\n### TypeSpec Steps\\n\\n- Replace the current versions enum member with the new stable api-version (first) and the new preview api-version (last)\\r\\n- Decorate the preview api-version with the @previewVersion decorator\\r\\n- Rename the example folder to use the new preview api version and update examples as needed\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Leave any resources, types and operations in the new stable version undecorated (automatically included in both the new stable and the new preview version)\\r\\n- Decorate any resources, types, and operations only in the new preview API version, that is, any types that are not considered stable. Some tooling to pick - which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any new preview api changes in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Adding a Preview API (Previous Stable API)\\n\\n### TypeSpec Steps\\n\\n- Add a new entry for the new preview version at the bottom of the Versions enumeration and decorate with @previewVersion\\r\\n- Add a new example folder for the new version and copy any still-relevant examples\\r\\n- Make changes to the API using versioning decorators to mark each change\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n## Converting Existing Specs With mixes of Preview and Stable APIs\\n\\n### TypeSpec Steps\\n\\n- For each preview api-version, in order\\r\\n  - For each versioning decorator, forward the version to the next version, except\\r\\n    - if this would result in a duplicated decorator application (including all decorator parameters) at that version, discard the forwarded decorator\\r\\n    - if this would result in an @added and @removed pair at a version, then discard the forwarded decorator\\r\\n    - If this would result in @typeChangedFrom or @renamedFrom with conflicting parameters, use the forwarded decorator\\r\\n  - Remove the preview api-version\\r\\n- For the first stable version\\r\\n  - Remove any @madeOptional, @added,  @typeChangedFrom, or @renamedFrom decorators\\r\\n  - Remove any types marked with the @removed decorator, unless they have @added decoration in subsequent versions\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n## Rules for api-version Changes\\n\\n@typeChangedFrom(b, string) myType: int32\\r\\nsafe: @madeOptional(a) @renamedFrom(b, \\\"oldName\\\") newName?: string -\\u003e @madeOptional(b) @renamedFrom(b, \\\"oldName\\\") newName: string\\r\\n  - This is also true for @typeChangedFrom decorators w.r.t @madeOptional and renamedFrom decorators, and @renamedFrom decorators w.r.t @madeOptional and @typeChangedFrom decorators:safe: @typeChangedFrom(a, string) @madeOptional(b) myType?: int32 -\\u003e @typeChangedFrom(b, string) @madeOptional(b) myType: int32\\r\\nsafe: @typeChangedFrom(a, string) @renamedFrom(b, \\\"oldName\\\") newName: int32 -\\u003e @typeChangedFrom(b, string) @renamedFrom(b, \\\"oldName\\\") newName: int32\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @madeOptional(b) newName?: string -\\u003e @renamedFrom(b, \\\"oldName\\\") @madeOptional(b) newName?: string\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @typeChangedFrom(b, string) newName?: int32-\\u003e @renamedFrom(b, \\\"oldName\\\") @typeChangedFrom(b, string)) newName?: int32\\r\\n  - It is safe for @typeChangedFrom, @renamedFrom, @madeOptional decorators in version a to be forwarded to version b if the type is removed in version bsafe: @renamedFrom(a, \\\"oldName\\\") @removed(b) newName: string -\\u003e @renamedFrom(b, \\\"oldName\\\") removed(b) newName: string\\r\\n  - if there is an@removed decorator in version a and an  @added decorator in version b, both decorators can be removedsafe: @removed(a) @added(b) myType: string-\\u003e myType: string\\r\\n  - if there is an@addeddecorator in version a and an  @removeddecorator in version b, safe: @added(a) @removed(b) myType: string-\\u003e \\r\\n  - There should never be a backward-looking decorator from version a forwarded to version b if version b has an @added decoratorThis is because such a versioning would already be inconsistent:  A type cannot be transformed before it exists\\n\\ndecorator on type T from a to b, provided there are no other versioning decorators on type T that use version b.\\r\\n    - safe:  @added(a) -\\u003e @added(b)\\r\\n    - possibly unsafe: @added(a)@removed(b) -\\u003e @added(b) @removed(b)\\r\\n  - It is safe to forward an @added decorator on type T from a to b and remove any backward-looking decorator on type T using version b:\\r\\n    - safe: @added(a) @added(b) -\\u003e @added(b)\\r\\n    - safe: @added(a) @madeOptional(b) myType?: int32 -\\u003e @added(b) myType?: int32\\r\\n    - safe: @added(a) @typeChangedFrom(b, string) myType: int32 -\\u003e @added(b) myType: int32\\r\\n    - safe: @added(a) @renamedFrom(b, \\\"oldName\\\") newName: string -\\u003e @added(b) newName: string\\r\\n  - It is safe to forward a @madeOpt\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Oav generate-examples failed\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Oav generate-examples failed\\n\\n## question\\n\\nSteps to reproduce:\\r\\n1. clone https://github.com/minhng22/azure-rest-api-specs/tree/nguyenmin/targetk8sversionchannel\\r\\n2. Run \\r\\n```\\r\\noav generate-examples specification/containerservice/resource-manager/Microsoft.ContainerService/fleet/preview/2025-07-01-preview/fleets.json\\r\\n```\\r\\n```\\r\\nError \\r\\n(node:53300) [DEP0040] DeprecationWarning: The `punycode` module is deprecated. Please use a userland alternative instead.\\r\\n(Use `node --trace-deprecation ...` to show where the warning was created)\\r\\n{\\r\\n  message: 'array details item is null, it may be caused by circular reference',\\r\\n  level: '\\\\x1B[33mwarn\\\\x1B[39m'\\r\\n}\\r\\n{\\r\\n  message: 'fatal error: Maximum call stack size exceeded, {}',\\r\\n  level: '\\\\x1B[31merror\\\\x1B[39m'\\r\\n}\\r\\nfatal error: Maximum call stack size exceeded, {}\\r\\n```\\r\\nDoes any one know why this error happens TypeSpec Discussion?\\r\\nThis branch is based on branch `dev-aks-fleet-2025-07-01-preview` . For diff, pls see https://github.com/Azure/azure-rest-api-specs/pull/34812\\n\\n## answer\\n\\nFirst thing to understand there are two copies of all examples when you're using TSP\\r\\n \\r\\nSwagger copy: https://github.com/Azure/azure-rest-api-specs/tree/33737ff460f78153f4cc21ef5d2d4586fcbae107/specification/containerservice/resource-manager/Microsoft.ContainerService/fleet/preview/2025-07-01-preview/examples\\r\\n \\r\\nTypeSpec copy: https://github.com/Azure/azure-rest-api-specs/tree/33737ff460f78153f4cc21ef5d2d4586fcbae107/specification/containerservice/Fleet.Management/examples/2025-07-01-preview\\r\\n \\r\\nProcess is you update examples in TypeSpec copy, then run \\\"tsp compile\\\" which copies them to swagger folder\\r\\n \\r\\nYour TSV may have been failing, if you changed one copy but not the other\\r\\n \\r\\nSecond, you can generate examples manually or using `oav` , whatever you prefer, is more efficient for your workflow, etc\\r\\n \\r\\nIf you think you're hitting a bug in `oav`, you can open an issue here, or discuss in any of our teams channels.\\r\\n \\r\\nhttps://github.com/Azure/oav/issues\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"azure#apiVersionEvolution.md\",\"document_title\":\"Scenarios for API Evolution\",\"document_link\":\"\",\"content\":\"# azure#apiVersionEvolution.md\\n\\n# Scenarios for API Evolution\\n\\nThis document describe how to evolute api version for a management plane services.\\n\\n## Scenarios to Consider\\n\\nadd a new stable version\\r\\nadd a new preview version\\r\\nMaking a preview api stable\\r\\nReplacing a preview API with a new preview API\\r\\nReplacing a preview API with a stable API\\r\\nReplacing a preview API with a stable API and a new preview API\\r\\nAdding a preview API (previous stable API)\\r\\nConverting existing specs with mixes of preview and stable APIs\\r\\nNote that, in this new scenario, new services will always have only a single version in their specs until they have their first stable version.  This should drastically reduce the amount of decoration in preview APIs\\n\\n## Add a new stable version\\n\\n### TypeSpec Steps\\n\\n1. Check the Latest Version\\r\\n   1. Determine whether the latest version is a preview version or a stable (GA) version.\\r\\n2. If the Latest Version is Stable (GA):\\r\\n   1. Add a new entry for the new stable version at the bottom of the Versions enumeration\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Make changes to the API using versioning decorators to mark each change\\r\\n3. if the latest version is preview version: \\r\\n   1. Add a new stable (GA) version enum before the existing preview enum value.\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Update all items that are GA’ing:\\r\\n      1. Change their @added version value to match the new GA enum value.\\r\\n   4. Handle remaining preview-only features:\\r\\n      1. If some features are not GAed, create a new preview version and Decorate non-GA items with @added pointing to the new preview version.\\r\\n      2. If all features in the preview version are GAed, delete the existing preview version.\\n\\n## Replacing a Preview API with a new Preview API (Adding a Preview API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new preview api-version\\r\\n- rename the example folder to use the new version\\r\\n- Remove any api changes not in the new version (simply remove types or type change decorators that do not apply)\\r\\n- Change the API inline decorating any type changes or new types in the new versionSome tooling to pick which resources, types, and operations are part of the new API could be useful.\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a Stable API (Adding a stable API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new stable api-version. \\r\\n- Remove any @previewVersion decorator\\r\\n- rename the example folder to use the new stable api version\\r\\n- Remove any api changes not in the new stable API version. Some tooling to pick which resources, types, and operations are part of the new API could be useful.\\r\\n- Add any api changes in the new stable version, using versioning decorators unless it is the only api-version\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a new Stable and a Preview API (previous stable API exists)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the preview version in the \\\"versions\\\" enumeration to match the new preview version and all references\\r\\n- Add a new Stable version entry immediately before the renamed version entry\\r\\n- rename the example folder to use the new preview api version\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Relabel any api changes in the new stable API version, that is, any changes in the preview that are now considered stable. \\r\\n    - Some tooling to pick which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any api changes in the new stable version, using versioning decorators (automatically included in the new preview version)\\r\\n- Add any api changes still in preview in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with the first Stable API and a new Preview API (no previous stable api)\\n\\n### TypeSpec Steps\\n\\n- Replace the current versions enum member with the new stable api-version (first) and the new preview api-version (last)\\r\\n- Decorate the preview api-version with the @previewVersion decorator\\r\\n- Rename the example folder to use the new preview api version and update examples as needed\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Leave any resources, types and operations in the new stable version undecorated (automatically included in both the new stable and the new preview version)\\r\\n- Decorate any resources, types, and operations only in the new preview API version, that is, any types that are not considered stable. Some tooling to pick - which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any new preview api changes in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Adding a Preview API (Previous Stable API)\\n\\n### TypeSpec Steps\\n\\n- Add a new entry for the new preview version at the bottom of the Versions enumeration and decorate with @previewVersion\\r\\n- Add a new example folder for the new version and copy any still-relevant examples\\r\\n- Make changes to the API using versioning decorators to mark each change\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n## Converting Existing Specs With mixes of Preview and Stable APIs\\n\\n### TypeSpec Steps\\n\\n- For each preview api-version, in order\\r\\n  - For each versioning decorator, forward the version to the next version, except\\r\\n    - if this would result in a duplicated decorator application (including all decorator parameters) at that version, discard the forwarded decorator\\r\\n    - if this would result in an @added and @removed pair at a version, then discard the forwarded decorator\\r\\n    - If this would result in @typeChangedFrom or @renamedFrom with conflicting parameters, use the forwarded decorator\\r\\n  - Remove the preview api-version\\r\\n- For the first stable version\\r\\n  - Remove any @madeOptional, @added,  @typeChangedFrom, or @renamedFrom decorators\\r\\n  - Remove any types marked with the @removed decorator, unless they have @added decoration in subsequent versions\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n## Rules for api-version Changes\\n\\n@typeChangedFrom(b, string) myType: int32\\r\\nsafe: @madeOptional(a) @renamedFrom(b, \\\"oldName\\\") newName?: string -\\u003e @madeOptional(b) @renamedFrom(b, \\\"oldName\\\") newName: string\\r\\n  - This is also true for @typeChangedFrom decorators w.r.t @madeOptional and renamedFrom decorators, and @renamedFrom decorators w.r.t @madeOptional and @typeChangedFrom decorators:safe: @typeChangedFrom(a, string) @madeOptional(b) myType?: int32 -\\u003e @typeChangedFrom(b, string) @madeOptional(b) myType: int32\\r\\nsafe: @typeChangedFrom(a, string) @renamedFrom(b, \\\"oldName\\\") newName: int32 -\\u003e @typeChangedFrom(b, string) @renamedFrom(b, \\\"oldName\\\") newName: int32\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @madeOptional(b) newName?: string -\\u003e @renamedFrom(b, \\\"oldName\\\") @madeOptional(b) newName?: string\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @typeChangedFrom(b, string) newName?: int32-\\u003e @renamedFrom(b, \\\"oldName\\\") @typeChangedFrom(b, string)) newName?: int32\\r\\n  - It is safe for @typeChangedFrom, @renamedFrom, @madeOptional decorators in version a to be forwarded to version b if the type is removed in version bsafe: @renamedFrom(a, \\\"oldName\\\") @removed(b) newName: string -\\u003e @renamedFrom(b, \\\"oldName\\\") removed(b) newName: string\\r\\n  - if there is an@removed decorator in version a and an  @added decorator in version b, both decorators can be removedsafe: @removed(a) @added(b) myType: string-\\u003e myType: string\\r\\n  - if there is an@addeddecorator in version a and an  @removeddecorator in version b, safe: @added(a) @removed(b) myType: string-\\u003e \\r\\n  - There should never be a backward-looking decorator from version a forwarded to version b if version b has an @added decoratorThis is because such a versioning would already be inconsistent:  A type cannot be transformed before it exists\\n\\ndecorator on type T from a to b, provided there are no other versioning decorators on type T that use version b.\\r\\n    - safe:  @added(a) -\\u003e @added(b)\\r\\n    - possibly unsafe: @added(a)@removed(b) -\\u003e @added(b) @removed(b)\\r\\n  - It is safe to forward an @added decorator on type T from a to b and remove any backward-looking decorator on type T using version b:\\r\\n    - safe: @added(a) @added(b) -\\u003e @added(b)\\r\\n    - safe: @added(a) @madeOptional(b) myType?: int32 -\\u003e @added(b) myType?: int32\\r\\n    - safe: @added(a) @typeChangedFrom(b, string) myType: int32 -\\u003e @added(b) myType: int32\\r\\n    - safe: @added(a) @renamedFrom(b, \\\"oldName\\\") newName: string -\\u003e @added(b) newName: string\\r\\n  - It is safe to forward a @madeOpt\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"azure#apiVersionEvolution.md\",\"document_title\":\"Scenarios for API Evolution\",\"document_link\":\"\",\"content\":\"# azure#apiVersionEvolution.md\\n\\n# Scenarios for API Evolution\\n\\nThis document describe how to evolute api version for a management plane services.\\n\\n## Scenarios to Consider\\n\\nadd a new stable version\\r\\nadd a new preview version\\r\\nMaking a preview api stable\\r\\nReplacing a preview API with a new preview API\\r\\nReplacing a preview API with a stable API\\r\\nReplacing a preview API with a stable API and a new preview API\\r\\nAdding a preview API (previous stable API)\\r\\nConverting existing specs with mixes of preview and stable APIs\\r\\nNote that, in this new scenario, new services will always have only a single version in their specs until they have their first stable version.  This should drastically reduce the amount of decoration in preview APIs\\n\\n## Add a new stable version\\n\\n### TypeSpec Steps\\n\\n1. Check the Latest Version\\r\\n   1. Determine whether the latest version is a preview version or a stable (GA) version.\\r\\n2. If the Latest Version is Stable (GA):\\r\\n   1. Add a new entry for the new stable version at the bottom of the Versions enumeration\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Make changes to the API using versioning decorators to mark each change\\r\\n3. if the latest version is preview version: \\r\\n   1. Add a new stable (GA) version enum before the existing preview enum value.\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Update all items that are GA’ing:\\r\\n      1. Change their @added version value to match the new GA enum value.\\r\\n   4. Handle remaining preview-only features:\\r\\n      1. If some features are not GAed, create a new preview version and Decorate non-GA items with @added pointing to the new preview version.\\r\\n      2. If all features in the preview version are GAed, delete the existing preview version.\\n\\n## Replacing a Preview API with a new Preview API (Adding a Preview API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new preview api-version\\r\\n- rename the example folder to use the new version\\r\\n- Remove any api changes not in the new version (simply remove types or type change decorators that do not apply)\\r\\n- Change the API inline decorating any type changes or new types in the new versionSome tooling to pick which resources, types, and operations are part of the new API could be useful.\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a Stable API (Adding a stable API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new stable api-version. \\r\\n- Remove any @previewVersion decorator\\r\\n- rename the example folder to use the new stable api version\\r\\n- Remove any api changes not in the new stable API version. Some tooling to pick which resources, types, and operations are part of the new API could be useful.\\r\\n- Add any api changes in the new stable version, using versioning decorators unless it is the only api-version\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a new Stable and a Preview API (previous stable API exists)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the preview version in the \\\"versions\\\" enumeration to match the new preview version and all references\\r\\n- Add a new Stable version entry immediately before the renamed version entry\\r\\n- rename the example folder to use the new preview api version\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Relabel any api changes in the new stable API version, that is, any changes in the preview that are now considered stable. \\r\\n    - Some tooling to pick which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any api changes in the new stable version, using versioning decorators (automatically included in the new preview version)\\r\\n- Add any api changes still in preview in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with the first Stable API and a new Preview API (no previous stable api)\\n\\n### TypeSpec Steps\\n\\n- Replace the current versions enum member with the new stable api-version (first) and the new preview api-version (last)\\r\\n- Decorate the preview api-version with the @previewVersion decorator\\r\\n- Rename the example folder to use the new preview api version and update examples as needed\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Leave any resources, types and operations in the new stable version undecorated (automatically included in both the new stable and the new preview version)\\r\\n- Decorate any resources, types, and operations only in the new preview API version, that is, any types that are not considered stable. Some tooling to pick - which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any new preview api changes in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Adding a Preview API (Previous Stable API)\\n\\n### TypeSpec Steps\\n\\n- Add a new entry for the new preview version at the bottom of the Versions enumeration and decorate with @previewVersion\\r\\n- Add a new example folder for the new version and copy any still-relevant examples\\r\\n- Make changes to the API using versioning decorators to mark each change\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n## Converting Existing Specs With mixes of Preview and Stable APIs\\n\\n### TypeSpec Steps\\n\\n- For each preview api-version, in order\\r\\n  - For each versioning decorator, forward the version to the next version, except\\r\\n    - if this would result in a duplicated decorator application (including all decorator parameters) at that version, discard the forwarded decorator\\r\\n    - if this would result in an @added and @removed pair at a version, then discard the forwarded decorator\\r\\n    - If this would result in @typeChangedFrom or @renamedFrom with conflicting parameters, use the forwarded decorator\\r\\n  - Remove the preview api-version\\r\\n- For the first stable version\\r\\n  - Remove any @madeOptional, @added,  @typeChangedFrom, or @renamedFrom decorators\\r\\n  - Remove any types marked with the @removed decorator, unless they have @added decoration in subsequent versions\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n## Rules for api-version Changes\\n\\n@typeChangedFrom(b, string) myType: int32\\r\\nsafe: @madeOptional(a) @renamedFrom(b, \\\"oldName\\\") newName?: string -\\u003e @madeOptional(b) @renamedFrom(b, \\\"oldName\\\") newName: string\\r\\n  - This is also true for @typeChangedFrom decorators w.r.t @madeOptional and renamedFrom decorators, and @renamedFrom decorators w.r.t @madeOptional and @typeChangedFrom decorators:safe: @typeChangedFrom(a, string) @madeOptional(b) myType?: int32 -\\u003e @typeChangedFrom(b, string) @madeOptional(b) myType: int32\\r\\nsafe: @typeChangedFrom(a, string) @renamedFrom(b, \\\"oldName\\\") newName: int32 -\\u003e @typeChangedFrom(b, string) @renamedFrom(b, \\\"oldName\\\") newName: int32\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @madeOptional(b) newName?: string -\\u003e @renamedFrom(b, \\\"oldName\\\") @madeOptional(b) newName?: string\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @typeChangedFrom(b, string) newName?: int32-\\u003e @renamedFrom(b, \\\"oldName\\\") @typeChangedFrom(b, string)) newName?: int32\\r\\n  - It is safe for @typeChangedFrom, @renamedFrom, @madeOptional decorators in version a to be forwarded to version b if the type is removed in version bsafe: @renamedFrom(a, \\\"oldName\\\") @removed(b) newName: string -\\u003e @renamedFrom(b, \\\"oldName\\\") removed(b) newName: string\\r\\n  - if there is an@removed decorator in version a and an  @added decorator in version b, both decorators can be removedsafe: @removed(a) @added(b) myType: string-\\u003e myType: string\\r\\n  - if there is an@addeddecorator in version a and an  @removeddecorator in version b, safe: @added(a) @removed(b) myType: string-\\u003e \\r\\n  - There should never be a backward-looking decorator from version a forwarded to version b if version b has an @added decoratorThis is because such a versioning would already be inconsistent:  A type cannot be transformed before it exists\\n\\ndecorator on type T from a to b, provided there are no other versioning decorators on type T that use version b.\\r\\n    - safe:  @added(a) -\\u003e @added(b)\\r\\n    - possibly unsafe: @added(a)@removed(b) -\\u003e @added(b) @removed(b)\\r\\n  - It is safe to forward an @added decorator on type T from a to b and remove any backward-looking decorator on type T using version b:\\r\\n    - safe: @added(a) @added(b) -\\u003e @added(b)\\r\\n    - safe: @added(a) @madeOptional(b) myType?: int32 -\\u003e @added(b) myType?: int32\\r\\n    - safe: @added(a) @typeChangedFrom(b, string) myType: int32 -\\u003e @added(b) myType: int32\\r\\n    - safe: @added(a) @renamedFrom(b, \\\"oldName\\\") newName: string -\\u003e @added(b) newName: string\\r\\n  - It is safe to forward a @madeOpt\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Does TypeSpec support example generation for new added versions?\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Does TypeSpec support example generation for new added versions?\\n\\n## question\\n\\nHi team, when adding a new api version in the TypeSpec, is there any way I can generate thoes example Json files from preview version and with the \\\"api-version\\\" property changed? Or I will need to manually cope the example Json files from preview version and update the \\\"api-version\\\" property inside all of them?\\n\\n## answer\\n\\nExample generation for specs works the same way as it did before.\\r\\nYou will need to place version specific examples under `examples\\\\[version]`. So if you are adding a new version, you can copy over the example files and make appropriate add/remove/update to them including the `api-version`\\r\\nNote that you can also use swagger-based example generation, for the new version (which is less attractive if you have customized the examples)\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_08_21.md\",\"document_title\":\"Release new api version process with TypeSpec\",\"document_link\":\"\",\"content\":\"# typespec_2025_08_21.md\\n\\n# Release new api version process with TypeSpec\\n\\n## question\\n\\nHi folks,\\r\\n \\r\\nDo you have any process or script to execute when creating a new api version with TypeSpec which is similar to current [Copy-ApiVersion.ps1](https://github.com/Azure/azure-rest-api-specs/blob/main/eng/scripts/Copy-ApiVersion.ps1) script with API Spec? \\r\\n \\r\\nAs within the TypeSpec, those examples needs to be added manually and change the api version in it. I wonder if there are any existing script for doing this. Thanks!\\n\\n## answer\\n\\nIn TypeSPec, this is much simpler.  You don't need to replicate your old APIs, you just encode the changes in the api and tag them with decorators from the versioning library, as discussed here: [Versioning | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/howtos/arm/versioning/)\\r\\n \\r\\nYou will need to copy the example files from the example directory from the last version into a new example directory for the new version, and add any new examples.\\r\\n \\r\\nIf you run into any issues, don't hesitate to ask questions here, or come to our office hours on Monday.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_17.md\",\"document_title\":\"Unknown decorator @flattenProperty\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_17.md\\n\\n# Unknown decorator @flattenProperty\\n\\n## question\\n\\nI'm getting the below errors and something like this, which I had never run into before.  The target branch (which I based my dev branch from) of my PR didn't run into that either.  Looking for some advice or clue about what is causing this and how to fix, or perhaps bypass them.\\r\\n```\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:49:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:52:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:45:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n[ERROR] /mnt/vss/_work/1/s/azure-sdk-for-go/sdk/resourcemanager/containerservicefleet/armcontainerservicefleet/TempTypeSpecFiles/Fleet.Management/client.tsp:47:3 - error invalid-ref: Unknown decorator @flattenProperty\\r\\n```\\r\\nhttps://github.com/Azure/azure-rest-api-specs/pull/37909\\n\\n## answer\\n\\nyour release branch has fallen far behind main.  it will need to be updated or recreated. \\r\\nyou can try this, but if your release branch is too old, it will likely need to be recreated \\r\\nhttps://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish#update-your-branch-with-changes-from-main\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-specs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-specs\",\"content\":\"# Create or update an Azure REST API spec\\n## Create your REST API definition\\n### [OpenAPI Specs](#tab/openapi)\\n| Short Link: | [https://aka.ms/azsdkdocs/createopenapispec](https://aka.ms/azsdkdocs/createopenapispec) |\\r\\n| --- | --- |\\r\\n\\r\\nTo update an existing OpenAPI specification, just edit the specification file and skip to the [Next steps](##next-steps) section.\\r\\nTo create a new OpenAPI spec, additional steps must be taken for services that still rely on OpenAPI:\\r\\n\\r\\n#### Create new OpenAPI specs\\r\\n\\r\\nTo create a new OpenAPI specs version you need to create a new directory with all the specs files, examples,\\r\\nand update the readme configuration file manually.\\r\\n\\r\\n#### Required steps for new OpenAPI versions\\r\\n\\r\\nWhen creating a new OpenAPI spec version, you'll need to:\\r\\n\\r\\n- Create a new directory that will include all the OpenAPI spec files and examples.\\r\\n- Copy the OpenAPI specs files from an existing version to use it as a base for your new work, and update all the\\r\\n  old version references in said specs files to the new version.\\r\\n- Update the Autorest configuration readme with the new version Tag.\\r\\n\\r\\nAfter making these changes, commit them to your branch and make the wanted changes in the specification files.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"getting-started#code-generation-csharp.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/getting-started/code-generation-csharp\",\"content\":\"# Getting started with TypeSpec server code generation for C#\\n## 9. Evolving your API\\nAs your API evolves, you'll need to update your TypeSpec definition and regenerate code:\\r\\n\\r\\n1. Modify your TypeSpec definition (e.g., add new models or operations)\\r\\n\\r\\n2. Recompile to update the generated code:\\r\\n\\r\\n```bash\\r\\ntsp compile .\\r\\n```\\r\\n\\r\\nThis updates the generated files (controllers, interfaces, models) but preserves your implementation files.\\r\\n\\r\\n3. If you've added entirely new resources that require new implementation files:\\r\\n\\r\\n```bash\\r\\nnpx hscs-scaffold main.tsp\\r\\n```\\r\\n\\r\\nThis is particularly useful when you've added new interfaces in your TypeSpec. For example, if you add a new `Categories` interface:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/categories\\\")\\r\\n@tag(\\\"Categories\\\")\\r\\ninterface Categories {\\r\\n  /** List categories */\\r\\n  @get list(): CategoryList | Error;\\r\\n  // More operations...\\r\\n}\\r\\n```\\r\\n\\r\\nWhen you run the scaffolding step again:\\r\\n\\r\\n- It will create new files for the new `Categories` interface (`CategoriesController.cs`, `ICategories.cs`, and `CategoriesImpl.cs`)\\r\\n- It won't overwrite your existing `Widgets.cs` with your custom business logic\\r\\n- This allows you to incrementally add new resources without losing your existing implementations\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"libraries#azure-core#rules#require-versioned.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/require-versioned\",\"content\":\"# require-versioned\\n```text title=\\\"Full name\\\"\\r\\n@azure-tools/typespec-azure-core/require-versioned\\r\\n```\\r\\n\\r\\nAzure services should always use the versioning library even if they have a single version. This ensures that the service is ready for future versions and generate the OpenAPI 2.0 in the correct location.\\r\\n\\r\\n#### ❌ Incorrect\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"getstarted#versioning.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/getstarted/versioning\",\"content\":\"# Versioning\\nVersioning lets you evolve your API without breaking existing clients. This guide covers the basics of declaring versions and adding new resources, operations, and properties in a clear, easy-to-follow way. For more advanced scenarios, see the [full versioning documentation](../howtos/ARM/versioning.md).\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure REST API, SDK development process with TypeSpec\\n## Table Of Content\\n### 4. Prepare and submit a Pull Request for reviewing\\n1. Create a branch in your local repository for your changes.\\r\\n2. Create or update the TypeSpec files for your service.\\r\\n3. Add or update 'examples' files for each operation of your OpenAPI file.\\r\\n   The [oav](https://github.com/Azure/oav) provides two ways to generate OpenAPI examples:\\r\\n   1. Generating basic examples and then manually modify the values. It will generate two examples for each operation:\\r\\n    one contains minimal properties set, the other contains the maximal properties set. Since the auto-generated\\r\\n     examples consist of random values for most types, you need replace them with meaningful values.\\r\\n       ```bash\\r\\n       oav generate-examples openapi.json\\r\\n       ```\\r\\n    Note, latest OAV tool should automatically generate the following. However, if you are generating the examples manually,\\r\\n     please ensure you have:\\r\\n    - include `title` field and make sure it is descriptive and unique for each operation.\\r\\n    - include `operationId`. This is used to match with declared operations in TypeSpec and correctly output in OpenAPI.\\r\\n4. Add/update the `readme.md` file in the `{service}` folder to specify the version and location of the OpenAPI files. The `readme.md` is needed for both management-plane and data-plane services for REST API Docs generation.\\r\\n   Example:[sample-readme](https://github.com/Azure/azure-rest-api-specs/blob/main/specification/widget/resource-manager/Microsoft.Widget/Widget/readme.md)\\r\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-1-branch.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-1-branch\",\"content\":\"# Create a new branch\\nYou'll first want to create a new branch in which to do your work and that everyone working on changes can target.\\r\\nWe support different type of branches. To learn more about them see [here](xref:api-versions-and-branches).\\r\\n\\r\\n- :white_check_mark: Create a separate branch for each release that a team can work on together, whether\\r\\npreview or stable.\\r\\n- :ballot_box_with_check: Consider customizing the branch name to something discoverable, memorable, and consistent.\\r\\n\\r\\n\\u003e [!Note]\\r\\n\\u003e This tutorial uses the *release* branch, which has branch protection rules against it. Learn more about the different\\r\\n\\u003e branches and branch protection rules [here](xref:api-versions-and-branches).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs#api-specs.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-specs\",\"content\":\"# Create or update an Azure REST API spec\\n## Create a branch in the specs repo\\nYou first need to create a branch for you and your team to update the specifications.\\r\\n\\r\\n1. Clone the [repository](xref:api-repos) where you want the API spec to be published\\r\\n2. Create a new branch and make sure to include your GitHub alias as the prefix for the branch name.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e If multiple people will work on the same branch consider using a `release` branch.\\r\\n\\u003e Go to [API versions and branches](xref:api-versions-and-branches) to learn more about\\r\\n\\u003e branch protection rules in the repos.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-1-branch.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-1-branch\",\"content\":\"# Create a new branch\\n## How to create a new release branch\\n1. Clone the [repository](xref:api-repos) where you want the API spec to be published\\r\\n2. Create a new release branch manually:\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#pr-move-private-to-public.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/pr-move-private-to-public\",\"content\":\"# Move private specs to public\\n\\u003e [!CAUTION]\\r\\n\\u003e Copying over specs from private specs repo to public specs repo is effectively converting a `private preview`\\r\\n\\u003e API version to `public preview`. The copying of specs is only one element of a larger process.\\r\\n\\u003e Consult with the service \\u0026 spec owner to ensure you complete all the required steps, like disabling [AFEC] flags,\\r\\n\\u003e publishing relevant docs to external customers, etc.\\r\\n\\u003e ([example requirements doc for ARM][ARM lifecycle stages requirements])\\r\\n\\u003e Do this consultation **before you open the PR** to the public specs repo.\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e These instructions replace the former OpenAPI Hub feature **Publish a pull request**\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial\",\"content\":\"# Tutorial: Create a new service spec\\n## Next steps\\n1. [Create a new branch](xref:api-tutorial-branch)\\r\\n2. [Work against the release branch](xref:api-tutorial-update)\\r\\n3. [Create a PR against main](xref:api-tutorial-publish)\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-3-publish.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-3-publish\",\"content\":\"# Create a PR against main\\n## Next steps\\n1. [Create a new branch](api-tutorial-1-branch.md)\\r\\n2. [Work against the release branch](api-tutorial-2-update.md)\\r\\n3. Create a PR against main\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial-2-update.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial-2-update\",\"content\":\"# Work against the release branch\\n## Make changes to a REST API definition for a release\\n### [Create OpenAPI specs](#tab/create-openapi)\\nFollow instructions on [Create your REST API definition](xref:api-specs?tabs=openapi)\\r\\n\\r\\n#### Start working on your new OpenAPI specs\\r\\n\\r\\nMake the desired changes on your new OpenAPI specification files.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## API versions and specs repos branches\\nThe automated breaking change and versioning issue validation is tightly coupled to the concepts of API versions\\r\\nand relevant specs repo branches. Having good understanding of these concepts will help you understand the nature\\r\\nof breaking changes and versioning issues. Read more about these concepts in [API versions and branches](xref:api-versions-and-branches).\"}]",
            "inputs.latency": 1016.6000113487244,
            "inputs.response_length": 1198,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://eng.ms/docs/products/azure-developer-experience/design/api-specs/api-specs",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec"
            ],
            "inputs.testcase": "Copy-ApiVersion.ps1 is no longer available",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1334,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1335,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: Copy-ApiVersion.ps1 is no longer available\\\\n\\\\nquestion: I am networking team and working on creation of new swagger release branch for api version 2025-05-01. As part of the process, we used to execute Copy-ApiVersion.ps1 command to update some of the references form old version to new version\\\\nI see that above script file is no longer available. Could you please suggest if there is any alternative script added in place of this or do we need to perform the changes manually?\\\", \\\"response\\\": \\\"Based on the latest Azure API spec and TypeSpec processes, there is currently **no direct replacement script** for Copy-ApiVersion.ps1. The recommended approach is to manually perform the necessary changes for your new release branch:\\\\n\\\\n- **Create a new release branch** (as before) for the new API version.\\\\n- **Copy all relevant spec files and examples** from the previous version directory to the new version's directory.\\\\n- **Update all version references** in the spec files, examples, and configuration files (e.g., readme.md) to the new API version (2025-05-01).\\\\n\\\\nThis is in alignment with the documented Azure REST API and TypeSpec workflow. For TypeSpec-based APIs, you encode versioning changes using decorators (like @added, @removed, @renamedFrom) rather than duplicating the whole API spec, which makes the process simpler. For Swagger/OpenAPI-based APIs, the process is still manual: copy, update references, and update the readme tag for the new version.\\\\n\\\\nThere is no automated script provided by the Azure REST API specs repo to replace Copy-ApiVersion.ps1 at this time. You may create your own automation for repetitive tasks, but official guidance is to perform these steps manually.\\\", \\\"ground_truth\\\": \\\"The script is deprecated, and no longer supported.  It was removed in these PRs, which you can view for context on the change:\\\\nhttps://github.com/Azure/azure-rest-api-specs/pull/37818\\\\nhttps://dev.azure.com/azure-sdk/internal/_git/azure-sdk-docs-eng.ms/pullrequest/1323\\\\nThe new docs have (brief) instructions you can use in place of the script:\\\\n```\\\\nCreate a new directory that will include all the OpenAPI spec files and examples.\\\\nCopy the OpenAPI specs files from an existing version to use it as a base for your new work, and update all the old version references in said specs files to the new version.\\\\nUpdate the Autorest configuration readme with the new version Tag.\\\\n```\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: RPSaaSMaster - Simple string change pullrequest marked as a breaking-change for unrelated packages\n\nquestion: I submitted this pullrequest to clean up some references that were missed when we changed a new resource name\nBranch: RPSaaSMaster\nService: Microsoft.PortalServices/copilot\nPR: [Typo Fix: Clean up old copilotPlans references in Microsoft.PortalServices/copilots 2025-10-01-prev…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24760)\nIt has failed validation for breaking change - looking at the results, the errors appear to reference unrelated services/packages as the source of the breaking change:\nExample:\n```\n❌ Breaking Change(Cross-Version) - Analyze Code\nappendOadRuntimeErrors: {\"type\":\"Raw\",\"level\":\"Error\",\"message\":\"Runtime Exception\",\"time\":\"2025-09-24T16:53:33.708Z\",\"groupName\":\"stable\",\"extra\":{\"new\":\"https://github.com/Azure/azure-rest-api-specs-pr/blob/05536a3ad9be35b516ecb39df1c828ba8fdacc9b/specification/devcenter/resource-manager/Microsoft.DevCenter/preview/2023-11-01-preview/devcenter.json\",\"old\":\"https://github.com/Azure/azure-rest-api-specs-pr/blob/main/specification/devcenter/resource-manager/Microsoft.DevCenter/stable/2023-04-01/devcenter.json\",\"details\":\"incompatible properties : resourceId\\n    definitions/OperationStatus/properties/resourceId\\n    at file:///home/runner/work/azure-rest-api-specs-pr/azure-rest-api-specs-pr/specification/devcenter/resource-manager/Microsoft.DevCenter/preview/2023-11-01-preview/devcenter.json#L5192:8\\n    definitions/OperationStatusResult/properties/resourceId\\n    at file:///home/runner/work/azure-rest-api-specs-pr/azure-rest-api-specs-pr/specification/common-types/resource-management/v5/types.json#L279:8\"}}\n```\nAm I misreading these errors? or is there a problem with the validation - if so do we need to request a sign off?",
            "inputs.ground_truth": "Something about the history of the head branch of your PR, is confusing our BreakingChanges check, to thinking you modified more files than shown in the \"diff\" of your PR.  Maybe an unusual merge or something.\nEasiest fix:\npull latest changes in RPSaaSMaster\ncreate a new branch from RPSaaSMaster\ncreate a single commit with the changes you want\ncreate a new PR, using this as the head branch",
            "inputs.response": "You are not misreading the errors—it's common for Azure REST API spec validation pipelines (especially the Breaking Change(Cross-Version) and Swagger BreakingChange checks) to report breaking changes from unrelated services/packages if the underlying validation tooling encounters issues elsewhere in the repo during the PR run. This typically happens due to one of the following reasons:\n\n1. **Global/Repo-wide Validation**: The pipeline does a cross-version comparison for *all* services in the repository, not just your PR's changes. If there are errors in other specs (e.g., Microsoft.DevCenter) that exist in the repo or are touched by branch merges, these will show up in your PR validation output.\n\n2. **Stale Dependencies or Out-of-sync Branches**: If your PR branch is not up to date with the target branch (`RPSaaSMaster`), validation may compare against outdated or incompatible files, causing errors unrelated to your changes.\n\n3. **Unintended Spec Interactions**: Sometimes, small changes (like typo fixes or reference clean-ups) can trigger downstream issues in shared/common types or dependencies, which appear as unrelated errors.\n\n**What should you do?**\n- First, ensure your branch is fully up to date with `RPSaaSMaster` by following the instructions in [TypeSpec Validation - Running Locally](https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally):\n  - `git clean -xdf` (to clean the repo)\n  - `git pull` (to sync with latest)\n  - `npm ci` (to install dependencies)\n  - Re-compile and re-run validation.\n- If errors persist and clearly reference unrelated services (not impacted by your PR), document this in your PR description. Azure's breaking change policy requires you to address *actual* breaking changes only.\n- If these errors are not caused by your changes, you do **not** need to request a sign-off for breaking changes. You should reach out to the TypeSpec Discussion channel or tag the API Stewardship team to confirm these are false positives. See [Resolving Pipeline Failures](https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline) and [Swagger BreakingChange FAQ](https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-BreakingChange) for more troubleshooting.\n\n**Summary:**\n- Your simple string/reference cleanup should not cause breaking changes in unrelated packages. Most likely, these are validation artifacts from global pipeline checks or out-of-date dependencies. Fix by syncing your branch and dependencies, and only escalate to sign-off if your change actually introduces a breaking change in your service.\n\nFor persistent or unexplained errors, contact the TypeSpec Discussion channel with the details and pipeline logs.",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-review\",\"content\":\"# design#api-review.md\\n\\n| Short Link: | [azsdk/onboarding/restapischedule](https://aka.ms/azsdk/onboarding/restapischedule) |\\r\\n| --- | --- |\\n\\n# Schedule a data plane REST API spec review\\n\\n## Purpose\\n\\nA data plane REST API review is designed to help you create developer-friendly and consistent REST (data plane) APIs\\r\\nfor your service. All Azure REST APIs need to be reviewed and approved prior to publication.\\n\\n## Before you begin\\n\\n\\u003e [!NOTE]\\r\\n\\u003e For management plane (ARM-based) APIs, you need to create a pull request (PR) in the [Azure REST API specification repositories](xref:api-repos).\\r\\n\\u003e Such PR is a part of the [release plan](xref:release-plan). The ARM review will happen during the [PR process](xref:api-specs-pr).\\r\\n\\r\\nEnsure that:\\r\\n\\r\\n- You have [access](xref:access) to the GitHub repositories and respective Azure open source organization.\\n\\n## Prepare for API review\\n\\nWhen you have your REST API definition ready for review, [create a pull request with your Azure REST API spec update](xref:api-specs-pr).\\r\\n\\r\\nYou should prepare and be ready to present the following information during your review:\\r\\n\\r\\n| Title | Importance | Brief description | Example and support documentation |\\r\\n| --- | --- | --- | --- |\\r\\n\\r\\nAPI spec PR link | Must Have | PR with your API spec definition against [azure/azure-rest-api-specs-pr](https://github.com/azure/azure-rest-api-specs-pr) or [azure/azure-rest-api-specs](https://github.com/azure/azure-rest-api-specs) | In order to access the PR, it may be necessary to join the [Azure GitHub organization](https://repos.opensource.microsoft.com/orgs/Azure). \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to https://repos.opensource.microsoft.com/orgs/Azure\\u003c/li\\u003e\\u003cli\\u003eClick **Join Organization**.\\u003c/li\\u003e\\u003c/ol\\u003e\\u003cp\\u003e\\u003cp\\u003eThe PR should be linked to the issue no less than 2 days before your meeting. To properly link your PR, in the issue click on the settings icon next to `Development` on the right side:\\u003cp\\u003e\\u003cp\\u003e![Screenshot](../img/link-pr.png)  |\\r\\nAPI spec PR CI checks | Important |Make sure all CI is passing before requesting a review. | [ci-fix](https://aka.ms/ci-fix) |\\r\\nCore concepts | Must have | A glossary of nouns and verbs  | [Example](https://github.com/Azure/azure-sdk-pr/blob/main/onboarding/Core_Concepts.pdf)\\r\\nAPI reference docs | Good to have | Your API documentation consists of two parts, the API spec document (TypeSpec/OpenAPI spec), and the generated developer docs. These docs are often the first experience a developer will have with your service. Make a good first impression!!| **Recommended for OpenAPI spec**: [VS Code extension](https://marketplace.visualstudio.com/items?itemName=42Crunch.vscode-openapi) load this extension and then open your OpenAPI spec file in VS Code and select **Preview**. \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to your PR and look for the comment added by the `openapi-pipeline-app bot` and title `Swagger Generation Artifacts`.\\n\\ngenerated developer docs. These docs are often the first experience a developer will have with your service. Make a good first impression!!| **Recommended for OpenAPI spec**: [VS Code extension](https://marketplace.visualstudio.com/items?itemName=42Crunch.vscode-openapi) load this extension and then open your OpenAPI spec file in VS Code and select **Preview**. \\u003cp\\u003e\\u003cp\\u003e\\u003col\\u003e\\u003cli\\u003eGo to your PR and look for the comment added by the `openapi-pipeline-app bot` and title `Swagger Generation Artifacts`. In the comment posted by the bot, you will find a link to your generated documentation under `ApiDocPreview`.\\u003c/li\\u003e\\u003cli\\u003eExpand `Detail` and look for `Click here to preview`.\\u003c/li\\u003e\\u003cli\\u003eReview your docs! Ensure that `Summary` and `Description` fields are accurate and complete.\\u003c/li\\u003e\\u003c/ol\\u003e|\\r\\nHero scenarios | Good to have | Top scenarios on how service is consumed. | [Guidelines on how to identify hero scenarios](https://github.com/Azure/azure-sdk-pr/blob/main/training/azure-sdk-apis/principles/approachable/README.md#hero-scenarios)\\u003cp\\u003e\\u003cp\\u003e [Examples](https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/appconfiguration/Azure.Data.AppConfiguration#examples)\\r\\nReview [API style guidelines](https://aka.ms/azapi/style) | Good to do | Review to learn about the Spectral linting tool that can be used inside of VS Code. Running this tool will help you identify and address many of the common issues and greatly improve your OpenAPI spec. | [API style guidelines](https://aka.ms/azapi/style)|\\n\\n### Join the REST API Stewardship Teams channel\\n\\nThe meeting chat is mirrored in the [General channel](https://teams.microsoft.com/l/channel/19%3a3ebb18fded0e47938f998e196a52952f%40thread.tacv2/General?groupId=1a10b50c-e870-4fe0-8483-bf5542a8d2d8\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47)\\r\\nof the [API Stewardship Team room](https://teams.microsoft.com/l/team/19%3a3ebb18fded0e47938f998e196a52952f%40thread.tacv2/conversations?groupId=1a10b50c-e870-4fe0-8483-bf5542a8d2d8\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\\r\\n\\r\\nTo participate in the chat:\\r\\n\\r\\n1. Go to [Discover Teams](https://teams.microsoft.com/_#/discover)\\r\\n2. Enter the code `uprrab9` to join the team.\\n\\n### Review our style guide\\n\\nReview the [API style guidelines](https://aka.ms/azapi/style) to learn about the Spectral linting tool that can be used\\r\\ninside of VS Code. Running this tool will help you identify and address many of the common issues and greatly improve\\r\\nyour OpenAPI spec.\\n\\n## Schedule a meeting\\n\\nOne of the tasks of your release plan is to **Schedule REST API review meeting** with the Azure REST API Stewardship board.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e Reviews must be scheduled ideally at least two days in advance to give the team time to prepare.\\r\\n\\u003e \\u003e\\r\\n\\u003e For small changes, consider asking for an offline review. See the\\r\\n\\u003e [Requesting an offline REST API review](#requesting-an-offline-rest-api-review) section below.\\r\\n\\r\\n1. Log in to [Azure SDK Release Planner](https://aka.ms/azsdk/sdk-release-planner).\\r\\n2. Choose the top-level service that your product is associated with.\\r\\n3. Click **Your release plans** and select the release plan you are interested in.\\r\\n4. The **Summary** view will provide information about where you are in the process and who the contacts are.\\r\\n5. Click on **Milestones** and select **Data-plane API Readiness**. This will open the app with the specific task to\\r\\naccomplish before you schedule the meeting.\\r\\n6. The **Schedule a REST API review** task contains the information to schedule the meeting with the  \\r\\n[Azure SDK Scheduler](https://aka.ms/azsdk/scheduleapi) app.\\r\\n7. Once in the scheduler app click **Create new**.\\r\\n8. Choose a meeting slot and select meeting attendees.\\r\\nIn the **Meeting attendees** field, be sure to include the Cloud Product Excellence (CPEX) PM or owner who is\\r\\nresponsible for updating your product in Cloud Lifecycle, as well as any engineering team members that will be\\r\\ngenerating or updating SDKs.\\r\\n9. Indicate whether your REST API changes will be public or private.\\r\\n10. Provide a link to the REST API specs pull request that contains your latest changes.\\r\\n11. Provide links to your [hero scenarios](xref:api-design#start-with-hero-scenarios) and [core concepts](xref:api-design#define-terms-and-concepts).\\r\\nThese fields will be auto populated if you have provided these documents when you [onboarded to the Azure SDK team](xref:onboard).\\n\\n## Requesting an offline REST API review\\n\\nFor small changes, consider asking for an offline review. This may be a better use of your time and leave the meeting\\r\\ntime for teams with larger changes - especially important prior to large customer engagements like Build or Ignite.\\n\\n### When offline reviews are appropriate\\n\\nAn offline review is appropriate when the following conditions hold:\\r\\n\\r\\n- The prior API version was reviewed and approved by the API Stewardship board.\\r\\n- The new API version makes only minor changes to the prior API version, such as\\r\\n  - Fields added to an API response\\r\\n  - Optional parameters or fields added to a request\\r\\n- The PR for the new API version is passing all PR pipeline checks.\\r\\n- The TypeSpec and OpenAPI APIViews for the PR were successfully generated and clearly show\\r\\nthe changes without extra \\\"noise\\\".\\n\\n### How to request an offline review\\n\\nThe service team should schedule a review meeting using the scheduling tool for the next available open review slot.\\r\\nThis will create an API review issue that will record the progress / status of the API review.\\r\\n\\r\\nMake sure that the API review issue contains:\\r\\n\\r\\n- A link to the PR for the new API version\\r\\n- Links to design docs / hero scenarios (even if these are unchanged)\\r\\n\\r\\nThen the service team should post a comment in the API review issue with the following information:\\r\\n\\r\\n- A link to the API review issue for the prior API version\\r\\n- A description of the changes being made in the new API version\\r\\n\\r\\nThen send a e-mail to the Azure review board core e-mail alias\\r\\n[azureapirbcore@microsoft.com](mailto:azureapirbcore@microsoft.com) including the link to the review issue and\\r\\nrequesting an offline review.\\r\\n\\r\\nAdd the `offline-review-requested` label to the PR to make it easier for API reviewers to search for PRs to\\r\\nbe reviewed offline.\\n\\n### Conducting the offline review\\n\\nUpon receiving the email requesting offline review, API Stewardship board members may review the PR and leave comments.\\r\\nThe service team may use the Teams chat for the meeting to communicate with the review board\\r\\nto recruit reviewers or answer questions.\\r\\n\\r\\nWhen an API Steward has reviewed the PR and has no concerns they submit an \\\"Approved\\\" review.\\r\\nWhen at least two API stewards have approved and none have requested changes, any member of the Stewardship board\\r\\ncan add the \\\"signedOff\\\" label and the review is complete.\\n\\n### Following a completed offline review\\n\\nOnce the PR has received sign off, the service team should cancel the review meeting\\r\\nto free up the slot for another team.\\r\\n\\r\\nThe signedOff label will unblock merge for the PR, but merging should be done only when the API version is ready\\r\\nto be released to customers.\\n\\n## What happens during the review\\n\\n\\u003e [!NOTE]\\r\\n\\u003e The m\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#pipeline.md\",\"document_title\":\"Resolving Pipeline Failures\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline\",\"content\":\"# migrate-swagger#faq#pipeline.md\\n\\n# Resolving Pipeline Failures\\n\\nThis document explains how to resolve pipeline failures in TypeSpec migration PRs.\\n\\n## Swagger BreakingChange\\n\\n### Multiple OpenAPI Files Before Migration\\n\\nThis pipeline will fail if there is more than one OpenAPI file in the latest version. See the detailed explanation in this [issue](https://github.com/Azure/typespec-azure/issues/2194#issue-2844564216).\\r\\n\\r\\nTo properly identify real breaking changes, use the \\\"TypeSpec Migration Validation\\\" pipeline instead:\\r\\n\\r\\n1. Navigate to the TypeSpec Migration Validation pipeline\\r\\n2. Check the report on the \\\"Summary\\\" page\\r\\n3. The output should match exactly what you see in [this step](../01-get-started.md#review-and-adjust-the-typespec) on the local machine\\r\\n4. Review the changes to verify they are expected\\n\\n### Single OpenAPI File Before Migration\\n\\nIf you have only one OpenAPI file in the latest version, use this pipeline to detect breaking changes. If it fails, refer to [Resolving OpenAPI Breaking Change Violations](./faq/breakingchange.md).\\r\\n\\r\\n**Known Issues**: The following pipeline failures are false alerts and can be safely ignored:\\r\\n\\r\\n#### 1017 - ReferenceRedirection\\r\\n\\r\\nThis typically occurs when an inlined anonymous enum becomes a named enum.\\r\\n\\r\\n**Before:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"enumProperty\\\": {\\r\\n    \\\"type\\\": \\\"string\\\",\\r\\n    \\\"enum\\\": [\\r\\n      \\\"If\\\",\\r\\n      \\\"Else\\\",\\r\\n      \\\"None\\\"\\r\\n    ],\\r\\n    \\\"x-ms-enum\\\": {\\r\\n      \\\"name\\\": \\\"EnumType\\\",\\r\\n      \\\"modelAsString\\\": true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n**After:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"enumProperty\\\": {\\r\\n    \\\"$ref\\\": \\\"#/definitions/EnumType\\\"\\r\\n  }\\r\\n},\\r\\n\\\"EnumType\\\": {\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"If\\\",\\r\\n    \\\"Else\\\",\\r\\n    \\\"None\\\"\\r\\n  ],\\r\\n  \\\"x-ms-enum\\\": {\\r\\n    \\\"name\\\": \\\"EnumType\\\",\\r\\n    \\\"modelAsString\\\": true\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n#### 1023 - TypeFormatChanged\\r\\n\\r\\nThe error message `The new version has a different format 'uri' than the previous one ''.` on the `nextLink` property is expected because the [page template defines the `nextLink` as `uri`](./mustread.md#using-page-model-from-azurecore-library).\\r\\n\\r\\n#### 1047 - XmsEnumChanged\\r\\n\\r\\nAfter migration, all models (including enums) will have capitalized names.\\r\\n\\r\\n**Before:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"someProperty\\\": {\\r\\n    \\\"type\\\": \\\"string\\\",\\r\\n    \\\"enum\\\": [\\r\\n      \\\"If\\\"\\r\\n    ],\\r\\n    \\\"x-ms-enum\\\": {\\r\\n      \\\"name\\\": \\\"someName\\\",\\r\\n      \\\"modelAsString\\\": true\\r\\n    }\\r\\n  }\\r\\n}\\r\\n```\\r\\n\\r\\n**After:**\\r\\n\\r\\n```json\\r\\n\\\"SomeModel\\\": {\\r\\n  \\\"someProperty\\\": {\\r\\n    \\\"$ref\\\": \\\"#/definitions/SomeName\\\"\\r\\n  }\\r\\n},\\r\\n\\\"SomeName\\\": {\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"If\\\"\\r\\n  ],\\r\\n  \\\"x-ms-enum\\\": {\\r\\n    \\\"name\\\": \\\"SomeName\\\",\\r\\n    \\\"modelAsString\\\": true\\r\\n  }\\r\\n}\\r\\n```\\n\\n## Swagger ModelValidation\\n\\nSome validation rules may fail because TypeSpec fixes certain legacy patterns. Review the known issues below and take appropriate action.\\n\\n### INVALID_FORMAT: Object didn't pass validation for format uri: {nextlink}\\n\\n#### Root Cause\\r\\n\\r\\nThe response model of a pageable operation uses the Azure.Core.Page template:\\r\\n\\r\\n```typespec\\r\\nmodel ResponseModel is Azure.Core.Page\\u003cItemType\\u003e;\\r\\n```\\r\\n\\r\\nThis standardized approach changes the `nextLink` type from plain `string` to `uri`. If previous example's `nextLink` value isn't a valid URI, it will cause a validation error.\\r\\n\\r\\n#### Resolution\\r\\n\\r\\nChoose one of the following options:\\r\\n\\r\\n1. **Update your example** to include a valid URI value, or\\r\\n2. **Modify your TypeSpec response model** to use a custom definition if the nextLink returned by the service is not a URI:\\r\\n\\r\\n```typespec\\r\\nmodel ResponseModel {\\r\\n  @pageItems\\r\\n  value: ItemType[];\\r\\n\\r\\n  @nextLink\\r\\n  nextLink?: string;\\r\\n}\\r\\n```\\n\\n### INVALID_FORMAT: Object didn't pass validation for format arm-id\\n\\n#### Root Cause\\r\\n\\r\\nThis error typically occurs when a custom resource definition is mapped to a resource defined in common-types. See [this section](./breakingchange.md#using-resources-from-common-types) for details. The `id` property for `Resource` in common-types may use the `arm-id` format, depending on the version of common-types used.\\r\\n\\r\\n#### Resolution\\r\\n\\r\\nUpdate the value in the example file to meet the `arm-id` format requirements.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"emitters#openapi3#diagnostics.md\",\"document_title\":\"Diagnostics\",\"document_link\":\"https://typespec.io/docs/emitters/openapi3/diagnostics\",\"content\":\"# emitters#openapi3#diagnostics.md\\n\\n# Diagnostics\\n\\nThe OpenAPI emitter may produce any of the following diagnostic messages.\\r\\n\\r\\n\\u003c!-- Topics within this section should be ordered alphabetically for easy lookup --\\u003e\\n\\n## duplicate-header\\n\\nThis diagnostic is issued when a response header is defined more than once for a response of a specific status code.\\r\\n\\r\\nTo fix this issue, ensure that each response header is defined only once for each status code.\\n\\n### Example\\n\\n```yaml\\r\\nresponses:\\r\\n  \\\"200\\\":\\r\\n    description: Successful response\\r\\n    headers:\\r\\n      X-Rate-Limit:\\r\\n        description: The number of allowed requests in the current period\\r\\n        schema:\\r\\n          type: integer\\r\\n      X-Rate-Limit:\\r\\n        description: The number of allowed requests in the current period\\r\\n        schema:\\r\\n          type: integer\\r\\n```\\r\\n\\r\\nIn this example, the `X-Rate-Limit` header is defined twice for the `200` status code. To fix this issue, remove the duplicate header definition.\\n\\n## duplicate-type-name\\n\\nThis diagnostic is issued when a schema or parameter name is a duplicate of another schema or parameter. This generally happens when a model or parameter is renamed with the `@friendlyName` decorator, resulting in two different TypeSpec types getting the same name in the OpenAPI output.\\r\\n\\r\\nTo fix this issue, change the name or friendly-name of one of the models or parameters.\\n\\n### Example\\n\\n```typespec\\r\\n@friendlyName(\\\"User\\\")\\r\\nmodel Customer {\\r\\n  id: string;\\r\\n}\\r\\n\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\r\\n\\r\\nIn this example, both `Customer` and `User` would appear as `User` in the OpenAPI output, causing a conflict.\\n\\n## inline-cycle\\n\\nThis diagnostic is issued when a cyclic reference is detected within inline schemas.\\r\\n\\r\\nTo fix this issue, refactor the schemas to remove the cyclic reference.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    Node:\\r\\n      type: object\\r\\n      properties:\\r\\n        value:\\r\\n          type: string\\r\\n        next:\\r\\n          $ref: \\\"#/components/schemas/Node\\\"\\r\\n```\\r\\n\\r\\nIn this example, the `Node` schema references itself, creating a cyclic reference. To fix this issue, refactor the schema to remove the cyclic reference.\\n\\n## invalid-default\\n\\nThis diagnostic is issued when a default value is invalid for the specified schema type.\\r\\n\\r\\nTo fix this issue, ensure that the default value is valid for the schema type.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    User:\\r\\n      type: object\\r\\n      properties:\\r\\n        age:\\r\\n          type: integer\\r\\n          default: \\\"twenty\\\"\\r\\n```\\r\\n\\r\\nIn this example, the `default` value for the `age` property is invalid because it is a string instead of an integer. To fix this issue, provide a valid default value, such as `20`.\\n\\n## invalid-extension-key\\n\\nThis diagnostic is issued by the `@extension` decorator when the extension key does not start with \\\"x-\\\" as\\r\\nrequired by the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, change the extension name to start with \\\"x-\\\".\\n\\n### Example\\n\\n```typespec\\r\\n@extension(\\\"invalid-name\\\", \\\"value\\\")\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\r\\n\\r\\nShould be changed to:\\r\\n\\r\\n```typespec\\r\\n@extension(\\\"x-valid-name\\\", \\\"value\\\")\\r\\nmodel User {\\r\\n  id: string;\\r\\n}\\r\\n```\\n\\n## invalid-schema\\n\\nThis diagnostic is issued when a schema is invalid according to the OpenAPI v3 specification.\\r\\n\\r\\nTo fix this issue, review your TypeSpec definitions to ensure they map to valid OpenAPI schemas.\\n\\n### Example\\n\\n```yaml\\r\\ncomponents:\\r\\n  schemas:\\r\\n    User:\\r\\n      type: object\\r\\n      properties:\\r\\n        id:\\r\\n          type: string\\r\\n        age:\\r\\n          type: integer\\r\\n          format: \\\"int\\\" # Invalid format\\r\\n```\\r\\n\\r\\nIn this example, the `format` value for the `age` property is invalid. To fix this issue, provide a valid format value such as `int32` or `int64`.\\n\\n## invalid-server-variable\\n\\nThis diagnostic is issued when a variable in the `@server` decorator is not defined as a string type.\\r\\nSince server variables are substituted into the server URL which is a string, all variables must have string values.\\r\\n\\r\\nTo fix this issue, make sure all server variables are of a type that is assignable to `string`.\\n\\n### Example\\n\\n```typespec\\r\\n@server(\\\"{protocol}://{host}/api/{version}\\\", \\\"Custom endpoint\\\", {\\r\\n  protocol: \\\"http\\\" | \\\"https\\\",\\r\\n  host: string,\\r\\n  version: 1, // Should be a string: \\\"1\\\"\\r\\n})\\r\\n```\\n\\n## path-query\\n\\nThis diagnostic is issued when the OpenAPI emitter finds an `@route` decorator that specifies a path that contains a query parameter. This is not permitted by the OpenAPI v3 specification, which requires query parameters to be defined separately.\\r\\n\\r\\nTo fix this issue, redesign the API to only use paths without query parameters, and define query parameters using the `@query` decorator.\\n\\n### Example\\n\\nInstead of:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users?filter={filter}\\\")\\r\\nop getUsers(filter: string): User[];\\r\\n```\\r\\n\\r\\nUse:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users\\\")\\r\\nop getUsers(@query filter?: string): User[];\\r\\n```\\r\\n\\r\\nAlternatively, you can leverage TypeSpec's support for URI templates:\\r\\n\\r\\n```typespec\\r\\n@route(\\\"/users{?filter}\\\")\\r\\nop getUsers(filter?: string): User[];\\r\\n```\\n\\n## union-null\\n\\nThis diagnostic is issued when the result of model composition is effectively a `null` schema which cannot be\\r\\nrepresented in OpenAPI.\\r\\n\\r\\nTo fix this issue, review your model compositions to ensure they produce valid schemas with actual properties or types.\\n\\n## union-unsupported\\n\\nThis diagnostic is issued when the OpenAPI emitter finds a union of two incompatible types that cannot be represented in OpenAPI. OpenAPI has limited support for union types, and some combinations cannot be expressed.\\r\\n\\r\\nTo fix this issue, consider restructuring your types to avoid incompatible unions, or split the operation into multiple operations with different return types.\"},{\"document_source\":\"typespec_http_specs\",\"document_filename\":\"type#model#usage#main.md\",\"document_title\":\"Usages for Illustrates usage of Record in different places(Operation parameters, return type or both).\",\"document_link\":\"https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/type/model/usage/main.tsp\",\"content\":\"# type#model#usage#main.md\\n\\n# Usages for Illustrates usage of Record in different places(Operation parameters, return type or both).\\n\\n## Scenario: Send a POST request with the following body {requiredProp: \\\"example-value\\\"}\\n\\n``` typespec\\r\\n\\r\\n@route(\\\"/input\\\")\\r\\nop input(@body input: InputRecord): void;\\r\\n\\r\\n\\r\\n```\\r\\n\\r\\n## Scenario: Send a GET request which return the following body {requiredProp: \\\"example-value\\\"}\\r\\n\\r\\n```\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Swagger breaking change\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Swagger breaking change\\n\\n## question\\n\\nPR check run: https://github.com/Azure/azure-rest-api-specs/pull/35346/checks?check_run_id=44501918225\\r\\nMy typespec conversion PR is failing in swagger breaking change check with the following error: \\r\\n\\\"new\\\":\\\"https://github.com/Azure/azure-rest-api-specs/blob/a1ac3f6f98bb1ea3583b765d00dfceab6d85654f/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json\\\",\\r\\n\\\"old\\\":\\\"https://github.com/Azure/azure-rest-api-specs/blob/main/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json\\\",\\r\\n\\\"details\\\":\\\"incompatible properties : tags\\\\n definitions/TrackedResource/properties/tags\\\\n at file:///mnt/vss/_work/1/azure-rest-api-specs/specification/common-types/resource-management/v3/types.json#L489:8\\\\n definitions/Resource/properties/tags\\\\n at file:///mnt/vss/_work/1/azure-rest-api-specs/specification/devtestlabs/resource-manager/Microsoft.DevTestLab/stable/2018-09-15/DTL.json#L12397:8\\\" \\r\\nThis PR is just having typespec conversion change and I am avoiding any change to the swagger file that is generated as part of typespec conversion. In the old swagger there is a Resource definitionwhich is similar Azure resource definition. Should I suppress this check and how to do it?\\n\\n## answer\\n\\nThis occurs because in your original swagger, you did not use swagger common-types. \\r\\nThe 'tags' definitions are compatible, so there is no change in the actual api from this.  This could result in changes in some management sdks, although this change to using the common resource types has generally been accepted. \\r\\ndocs on suppressions for false positives are here: [Suppress validation failures on a PR](https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-suppressions) \\r\\nNote that it is important to go through these violations, as the conversion is not guaranteed to be 100% accurate.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Typespec Validation issue\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Typespec Validation issue\\n\\n## question\\n\\nI've a PR where the Typespec validation is failing with some weird error. This is not being reproduced locally - \\r\\n```\\r\\n  specification/storagedatamanagementrp/Private.StorageDataManagement.Management/main.tsp:17:10 - error expect-value: Is a model expression type, but is being used as a value here. Use #{} to create an object value.\\r\\n53  \\u003e 17 | @service({\\r\\n54       |          ^\\r\\n55  \\u003e 18 |   title: \\\"Storage Data Management Resource Provider\\\",\\r\\n56       | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\r\\n57  \\u003e 19 | })\\r\\n58       | ^^\\r\\n```\\r\\n```\\r\\nspecification/storagedatamanagementrp/Private.StorageDataManagement.Management/Connectors/connectorModels.tsp:19:15 - error invalid-argument: Argument of type '\\\"read\\\"' is not assignable to parameter of type 'valueof EnumMember'\\r\\n60  \\u003e 19 |   @visibility(\\\"read\\\")\\r\\n61       |               ^^^^^^\\r\\n```\\r\\nI'm not sure how to resolve this error. Could someone please help here?\\r\\n[Update Connector and DataShare Swagger by ujjawaljain-msft · Pull Request #21997 · Azure/azure-rest-api-specs-pr](https://github.com/Azure/azure-rest-api-specs-pr/pull/21997)\\n\\n## answer\\n\\nYou may need to update to the latest typespec version - some of these particular properties have changed in a recent version. What you are using here isn't the latest style to specify these things.\\r\\nDoc for future reference: https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally :\\r\\n```\\r\\nRunning Locally\\r\\nTo ensure you see the same results from TypeSpecValidation in your PR check and tsv on your local machine:\\r\\nMerge latest from parent (e.g. main or RPSaaSMaster) to your PR branch\\r\\nRun locally\\r\\ngit clean -xdf (may revert any local changes)\\r\\ngit pull\\r\\nnpm ci\\r\\nnpx tsv specification/contosowidgetmanager/Contoso.Management\\r\\ngit status\\r\\nIf any changes, git add, git commit, git push to update your PR.\\r\\nIf you are still having problems, try cloning your branch to a new folder, or try on another machine.\\r\\nIf the problem can be reproduced on a clean machine, request assistance from the TypeSpec Discussion teams channel.\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Typespec Validation required check\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Typespec Validation required check\\n\\n## question\\n\\n\\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\". Please add \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-fakes\\\". Please add \\\"options.@azure-tools/typespec-go.generate-fakes\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.head-as-boolean\\\". Please add \\\"options.@azure-tools/typespec-go.head-as-boolean\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.inject-spans\\\". Please add \\\"options.@azure-tools/typespec-go.inject-spans\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-python.package-dir\\\". Please add \\\"options.@azure-tools/typespec-python.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-csharp.namespace \\\"Microsoft.Azure.Management.DevTestLabs\\\" does not match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter. Please update the value of \\\"options.@azure-tools/typespec-csharp.namespace\\\" to match \\\"{package-dir}\\\" or the value of \\\"package-dir\\\" option or parameter.\\r\\nPlease see https://aka.ms/azsdk/spec-gen-sdk-config for more info.\\r\\nFor additional information on TypeSpec validation, please refer to https://aka.ms/azsdk/specs/typespec-validation.\\r\\n```\\r\\nI have copied the namespace from the autorest readme files that we had before and it was responsible  to generate SDKs. Is it a requirement to update the namespace as suggested given we have already published the SDK before?\\n\\nPR: https://github.com/Azure/azure-rest-api-specs/pull/35346\\r\\nThis PR only has typespec conversion change and no API update. It is currently failing for required check - Typespec validation. When I run the npx tsmv command locally then I see the following error.\\r\\n```\\r\\nExecuting rule: SdkTspConfigValidation\\r\\nValidation on option \\\"options.@azure-tools/typespec-csharp.namespace\\\" in \\\"@azure-tools/typespec-csharp\\\" are failed. However, per @azure-tools/typespec-csharp’s decision, we will treat it as passed.\\r\\n[SdkTspConfigValidation]: validation failed.\\r\\n- Failed to find \\\"parameters.service-dir.default\\\". Please add \\\"parameters.service-dir.default\\\".\\r\\n- The value of options.@azure-tools/typespec-java.package-dir \\\"azure-mgmt-devtestlabs\\\" does not match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.package-dir\\\" to match \\\"/^azure-resourcemanager-[^\\\\/]+$/\\\".\\r\\n- The value of options.@azure-tools/typespec-java.namespace \\\"com.microsoft.azure.management.devtestlabs\\\" does not match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\". Please update the value of \\\"options.@azure-tools/typespec-java.namespace\\\" to match \\\"/^com\\\\.azure\\\\.resourcemanager\\\\.[^\\\\.]+$/\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.service-dir\\\". Please add \\\"options.@azure-tools/typespec-go.service-dir\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.package-dir\\\". Please add \\\"options.@azure-tools/typespec-go.package-dir\\\".\\r\\n- The value of options.@azure-tools/typespec-go.module \\\"github.com/Azure/azure-sdk-for-go/{module-name}\\\" does not match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\". Please update the value of \\\"options.@azure-tools/typespec-go.module\\\" to match \\\"github.com/Azure/azure-sdk-for-go/{service-dir}/{package-dir}\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\". Please add \\\"options.@azure-tools/typespec-go.fix-const-stuttering\\\".\\r\\n- Failed to find \\\"options.@azure-tools/typespec-go.generate-samples\\\".\\n\\n## answer\\n\\ntypeSpec validation is failing, but not for that reason.  The configuration for c-sharp emitter is a warning only.  The current failure is caused by diffs between the generated swagger included in your PR and the generated swagger when the ci compiles your spec.\\r\\n \\r\\nUsually this indicates that your local dependencies are out of date, and you need to pull the latest into your local branch and re-install at thetop level:\\r\\n \\r\\ngit fetch upstream main\\r\\ngit pull upstream main\\r\\nnpm ci\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_26.md\",\"document_title\":\"Is TypeSpec migration complete for folder: recoveryservicesbackup.\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_26.md\\n\\n# Is TypeSpec migration complete for folder: recoveryservicesbackup.\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\nWe had PR in flight: [Adding stable 2025 08 01 for completeness by risraj10 · Pull Request #37381 · Azure/azure-rest-api-…](https://github.com/Azure/azure-rest-api-specs/pull/37381)\\r\\nHowever, I see that TypeSpec migration was done couple of days ago for this folder. \\r\\nI have cancelled the above PR and trying to raise a new PR. However, just running npx tsp compile without any change is giving errors.\\r\\nAnd also it is making unintended change to OpenAPI json file even to existing version. I guess the tsp and OpenAPI json are not in sync.\\r\\nHence, wanted to check if the migration is really complete for this folder.\\n\\n## answer\\n\\nMain typespec validation should always be passing are you sure you are up you are with dependencies locally?\\r\\nMake sure to follow instructions here https://aka.ms/ci-fix\\r\\nJust to reiterate, this is almost always because you need to pull the latest from the target branch into your local clone of the repo, and re-install dependencies at the root.\\r\\nhttps://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally\"},{\"document_source\":\"static_typespec_migration_docs\",\"document_filename\":\"typespec-migration-docs-2025-08-14.md\",\"document_title\":\"The number of enums in the old and new Swagger don't match\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/breakingchange\",\"content\":\"# typespec-migration-docs-2025-08-14.md\\n\\n# The number of enums in the old and new Swagger don't match\\n\\n## question\\n\\n```diff\\r\\n{\\r\\n  \\\"name\\\": \\\"recommendationType\\\",\\r\\n  \\\"in\\\": \\\"query\\\",\\r\\n  \\\"type\\\": \\\"string\\\",\\r\\n  \\\"enum\\\": [\\r\\n    \\\"CreateIndex\\\",\\r\\n    \\\"DropIndex\\\",\\r\\n+   \\\"ReIndex\\\",\\r\\n    \\\"AnalyzeTable\\\"\\r\\n  ],\\r\\n  \\\"x-ms-enum\\\": {\\r\\n    \\\"name\\\": \\\"RecommendationType\\\",\\r\\n    \\\"modelAsString\\\": true\\r\\n  }\\r\\n}\\r\\n}，\\r\\n```\\n\\n## answer\\n\\nThis may be caused by two enums with the same name but different content being treated as the same enum by TypeSpec, which cannot be resolved at the moment and needs to be documented in the PR description\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"API-Spec-Review-FAQ.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/API-Spec-Review-FAQ\",\"content\":\"Answers to frequently asked questions in the [Api Spec Review](https://teams.microsoft.com/l/channel/19%3A0351f5f9404446e4b4fd4eaf2c27448d%40thread.skype/API%20Spec%20Review?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47). Within that channel, EngSys should be answering questions about validation pipelines and tools that run in those pipelines. Specific questions about typespec, the API Review process, etc. should be answered by others who specialize in those topics. \\r\\n\\r\\n| If the question is about | The answer should be | \\r\\n| --- | --- | \\r\\n| Authoring typespec | Send to [TypeSpec Discussions](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) | \\r\\n| My PR is ready to review, will someone review it? | See the \\\"Next steps to merge\\\" comment in your PR and follow directions to ensure you're in the review queue. No need to post here. | \\r\\n| API Doc Preview is broken | If the error message linked doesn't make sense, follow instructions at [Troubleshooting REST API documentation](https://eng.ms/docs/products/azure-developer-experience/design/api-docs-troubleshooting). API Doc Preview is not a required check so you can ignore the failure if it's not relevant to your documentation needs. |\\r\\n| My PR needs to be reviewed by the ARM team right now | PRs are generally reviewed in order of the ARM queue.  If your PR needs special treatment, you can contact the ARM team: https://aka.ms/armofficehoursinfo | \\r\\n| I need a review to merge changes to a non-standard branch (e.g. not `main`, `RPSaaSMaster`, etc.) | Contact the owner of that branch. |\\r\\n| EngSys is behaving badly in my non-standard/release branch | Update the state of the branch to match with `main`. The owner of the release branch is responsible for doing this.\"},{\"document_source\":\"azure_api_guidelines\",\"document_filename\":\"azure#Guidelines.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md\",\"content\":\"# Microsoft Azure REST API Guidelines\\n## Building Blocks: HTTP, REST, \\u0026 JSON\\n### REpresentational State Transfer (REST)\\nruntime\\r\\n- An error indicating a bug in customer code that is unlikely to be recoverable at runtime; the customer must just fix their code\\r\\n\\r\\n\\u003ca href=\\\"#rest-error-code-header\\\" name=\\\"rest-error-code-header\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** return an `x-ms-error-code` response header with a string error code indicating what went wrong.\\r\\n\\r\\n*NOTE: `x-ms-error-code` values are part of your API contract (because customer code is likely to do comparisons against them) and cannot change in the future.*\\r\\n\\r\\n\\u003ca href=\\\"#rest-error-code-enum\\\" name=\\\"rest-error-code-enum\\\"\\u003e:heavy_check_mark:\\u003c/a\\u003e **YOU MAY** implement the `x-ms-error-code` values as an enum with `\\\"modelAsString\\\": true` because it's possible add new values over time.  In particular, it's only a breaking change if the same conditions result in a *different* top-level error code.\\r\\n\\r\\n\\u003ca href=\\\"#rest-add-codes-in-new-api-version\\\" name=\\\"rest-add-codes-in-new-api-version\\\"\\u003e:warning:\\u003c/a\\u003e **YOU SHOULD NOT** add new top-level error codes to an existing API without bumping the service version.\\r\\n\\r\\n\\u003ca href=\\\"#rest-descriptive-error-code-values\\\" name=\\\"rest-descriptive-error-code-values\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** carefully craft unique `x-ms-error-code` string values for errors that are recoverable at runtime.  Reuse common error codes for usage errors that are not recoverable.\\r\\n\\r\\n\\u003ca href=\\\"#rest-error-code-grouping\\\" name=\\\"rest-error-code-grouping\\\"\\u003e:heavy_check_mark:\\u003c/a\\u003e **YOU MAY** group common customer code errors into a few `x-ms-error-code` string values.\\r\\n\\r\\n\\u003ca href=\\\"#rest-error-code-header-and-body-match\\\" name=\\\"rest-error-code-header-and-body-match\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** ensure that the top-level error's `code` value is identical to the `x-ms-error-code` header's value.\\r\\n\\r\\n\\u003ca href=\\\"#rest-error-response-body-structure\\\" name=\\\"rest-error-response-body-structure\\\"\\u003e:white_check_mark:\\u003c/a\\u003e **DO** provide a response body with the following structure:\\r\\n\\r\\n**ErrorResponse** : Object\\r\\n\\r\\nProperty | Type | Required | Description\"},{\"document_source\":\"typespec_azure_docs\",\"document_filename\":\"migrate-swagger#faq#pipeline.md\",\"document_title\":\"\",\"document_link\":\"https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline\",\"content\":\"# Resolving Pipeline Failures\\n## Swagger BreakingChange\\n### Multiple OpenAPI Files Before Migration\\nThis pipeline will fail if there is more than one OpenAPI file in the latest version. See the detailed explanation in this [issue](https://github.com/Azure/typespec-azure/issues/2194#issue-2844564216).\\r\\n\\r\\nTo properly identify real breaking changes, use the \\\"TypeSpec Migration Validation\\\" pipeline instead:\\r\\n\\r\\n1. Navigate to the TypeSpec Migration Validation pipeline\\r\\n2. Check the report on the \\\"Summary\\\" page\\r\\n3. The output should match exactly what you see in [this step](../01-get-started.md#review-and-adjust-the-typespec) on the local machine\\r\\n4. Review the changes to verify they are expected\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"SDK-Breaking-Changes.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/SDK-Breaking-Changes\",\"content\":\"# Table of Contents\\n## How to Suppress the SDK Breaking Changes\\n### Next Steps\\n1. The pull request authors create a file called `sdk-suppressions.yaml` if it doesn't already exist in your service folder in the `azure-rest-api-specs` repository.\\r\\n    - For TypeSpec scenarios, `sdk-suppressions.yaml` should be placed in the root folder of the TypeSpec project, which also contains the `tspconfig.yaml` file. For example, refers to the location for [Contoso.Management](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/Contoso.Management).\\r\\n    - For OpenAPI scenarios, `sdk-suppressions.yaml` should be placed in the `{service}\\\\resource-manager` folder. For example, see the location for the [contosowidgetmanager resource provider](https://github.com/Azure/azure-rest-api-specs/tree/main/specification/contosowidgetmanager/resource-manager).\\r\\n\\r\\n2. The pull request authors copy every line under the `Absent SDK breaking changes suppressions` section to the suppression file in the following format:\\r\\n\\r\\n``` yaml\\r\\nsuppressions:\\r\\n  azure-sdk-for-go:\\r\\n    - package: 'sdk/resourcemanager/servicelinker/armservicelinker'\\r\\n      breaking-changes:\\r\\n        - Function `*LinkerClient.BeginCreateOrUpdate` has been removed\\r\\n        - Function `*LinkerClient.NewListPager` has been removed\\r\\n```\\r\\n\\r\\n3. The pull request authors add this suppression file change to your spec pull request. Then the suppressions will be recognized by the bot, and the corresponding suppression label will be added to the spec pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression` will be added to the pull request.\\r\\n\\r\\n4. The SDK reviewers will evaluate the suppressions and either approve them or provide feedback. If the suppressions are approved, the corresponding approval label will be added to the pull request. For example, for the  `azure-sdk-for-go`, the label `BreakingChange-Go-Sdk-Suppression-Approved` will be added to the pull request.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-BreakingChange.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-BreakingChange\",\"content\":\"# AutoRest Exceptions\\nIf `Swagger BreakingChange` fails with `AutoRest threw a runtime error`, the root cause is likely a problem in your spec causing AutoRest to crash.  To debug (all commands run from repo root):\\r\\n\\r\\n1. Determine if the problem is \\\"before\\\" or \\\"after\\\" your PR (or both)\\r\\n   1. Checkout the target branch of your PR (likely `main` or `RPSaaSMaster`)\\r\\n   2. `npm i`\\r\\n   3. Run `@azure/oad` against the copy of your spec in the target branch.  Specify the same path twice, which should always pass unless AutoRest crashes.\\r\\n    ```\\r\\n    $ npx @azure/oad compare \\\\\\r\\n        specification/contosowidgetmanager/resource-manager/Microsoft.Contoso/stable/2021-11-01/contoso.json \\\\\\r\\n        specification/contosowidgetmanager/resource-manager/Microsoft.Contoso/stable/2021-11-01/contoso.json\\r\\n    ```\\r\\n   4. If your spec is valid, this should return `\\\"code\\\":\\\"NoVersionChange\\\"`, since you are comparing the spec to itself.  If your spec is invalid, this will fail with `AutoRest threw a runtime error`, and the stack trace should include `path` properties pointing to the error.  For instance, here's a failure caused by example with a disallowed property:\\r\\n\\r\\n    ```\\r\\n    code: 'OBJECT-ADDITIONAL-PROPERTIES'\\r\\n    params: [ [Array] ]\\r\\n    message: 'Additional properties not allowed: headers'\\r\\n    path: '#/paths/~1executions/post/x-ms-examples/CodeExecution-Execute-Async-Running'\\r\\n    ```\\r\\n\\r\\n   5. If `@azure/oad compare` passed on the copy of your spec in the target branch, repeat these steps on the copy of your spec in the source branch.\\r\\n2. If the problem is \\\"before\\\" your PR, open another PR dedicated to fixing just this problem.  BreakingChanges may fail in this fixup PR, but should pass going forward.\\r\\n3. If the problem is \\\"after\\\" your PR, just fix the problem in your PR.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# Deep-dive into breaking changes on spec PRs\\n## Breaking changes and versioning issues\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\n## MULTIPLE_API_VERSION\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\"},{\"document_source\":\"typespec_docs\",\"document_filename\":\"handbook#reproducibility.md\",\"document_title\":\"\",\"document_link\":\"https://typespec.io/docs/handbook/reproducibility\",\"content\":\"# Reproducibility\\nA crucial aspect of service definition is ensuring consistent output over time. This is important in scenarios such as:\\r\\n\\r\\n- An update to a dependency or sub-dependency introduces an unexpected breaking change.\\r\\n- Updates to a new version of a service should not impact older versions.\\r\\n- Modifications are made to the TypeSpec specification.\\r\\n\\r\\nThese issues can be mitigated with a few precautionary measures:\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"TypeSpec-Validation.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation\",\"content\":\"# Running Locally\\nTo ensure you see the same results from TypeSpecValidation in your PR check and `tsv` on your local machine:\\r\\n1. Merge latest from parent (e.g. `main` or `RPSaaSMaster`) to your PR branch\\r\\n2. Run locally\\r\\n   1. `git clean -xdf` (may revert any local changes)\\r\\n   2. `git pull`\\r\\n   3. `npm ci`\\r\\n   4. `npx tsv specification/widget/resource-manager/Microsoft.Widget/Widget`\\r\\n   5. `git status`\\r\\n   6. If any changes, `git add`, `git commit`, `git push` to update your PR.\\r\\n3. If you are still having problems, try cloning your branch to a new folder, or try on another machine.\\r\\n4. If the problem can be reproduced on a clean machine, request assistance from the [TypeSpec Discussion](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47) teams channel.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Resolving-Folder-Migration-Conflicts:-A-Guide-for-PR-Authors\",\"content\":\"# Resolving Folder Migration Conflicts: A Guide for PR Authors\\n## The impact to ongoing PRs\\n### After Resolution\\nMake sure to compile the TypeSpec project so that the TypeSpec Validation could pass.\\r\\n\\r\\n1. **Comprehensive validation**:\\r\\n   ```bash\\r\\n   # Run full validation suite\\r\\n   npm ci\\r\\n   npm run lint\\r\\n   npm run validate\\r\\n   \\r\\n   # Test TypeSpec compilation for your service\\r\\n   cd specification/app/data-plane/DynamicSessions/\\r\\n   npx tsp compile .\\r\\n   npx tsp compile . --emit @azure-tools/typespec-autorest\\r\\n   \\r\\n   # Verify generated files match expectations by checking if there's any diff with the OpenAPI json files.\\r\\n   ```\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure REST API, SDK development process with TypeSpec\\n## Table Of Content\\n### 4. Prepare and submit a Pull Request for reviewing\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\r\\n   - send a pull request to the original repo from your forked repo.\\r\\n   See the ARM Wiki for information on the [supported repos and branches for management-plane services](https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches).\\r\\n#### 4.1 Fix the errors of PR reviewing CI checks\\r\\nThe CI checks result will be commented on the PR. you can refer to the [CI fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\\r\\nNote:\\r\\nSince the OpenAPI is generated from TypeSpec, to change the OpenAPI, you must update the TypeSpec file and regenerate the\\r\\n OpenAPI and avoid updating OpenAPI directly to keep the consistency between OpenAPI and TypeSpec.\\r\\nFor support \\u0026 help, you can post a message to [TypeSpec Discussion - teams channel](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-LintDiff.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-LintDiff\",\"content\":\"# TypeSpec\\n## `AvoidAnonymousTypes`\\nData-plane specs can suppress violations of this rule, since it only exists for the benefit of SDKs generated from swagger, and data-plane SDKs are generated directly from TypeSpec.  Resource-manager specs should **not** suppress violations of this rule, since resource-manager SDKs are generated from OpenAPI, and rely on these errors being fixed.\"},{\"document_source\":\"typespec_http_specs\",\"document_filename\":\"type#model#empty#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/type/model/empty/main.tsp\",\"content\":\"# Usages for Illustrates usage of empty model used in operation's parameters and responses.\\n## Scenario: Send a PUT request with the following body {}\\n``` typespec\\r\\n@route(\\\"/alone\\\")\\r\\n@put\\r\\nop putEmpty(@body input: EmptyInput): void;\\r\\n```\\r\\n\\r\\n## Scenario: Send a GET request which returns the following body {}\\r\\n\\r\\n```\"},{\"document_source\":\"typespec_http_specs\",\"document_filename\":\"server#endpoint#not-defined#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/server/endpoint/not-defined/main.tsp\",\"content\":\"# Usages for Testserver without any endpoint\\n## Scenario: A simple operation in a server without defining a endpoint.\\n``` typespec\\r\\n@route(\\\"/valid\\\")\\r\\n@head\\r\\nop valid(): OkResponse;\\r\\n```\\r\\n\\r\\n## Full Sample: \\r\\n```\"},{\"document_source\":\"typespec_http_specs\",\"document_filename\":\"type#model#inheritance#not-discriminated#main.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/microsoft/typespec/tree/main/packages/http-specs/specs/type/model/inheritance/not-discriminated/main.tsp\",\"content\":\"# Usages for Illustrates not-discriminated inheritance model.\\n## Scenario: Generate and send model.\\n``` typespec\\r\\n@route(\\\"/valid\\\")\\r\\n@post\\r\\nop postValid(@body input: Siamese): NoContentResponse;\\r\\n```\\r\\n\\r\\n## Scenario: Generate and receive model.\\r\\n\\r\\n```\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-versions-and-branches.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches\",\"content\":\"# API versions and branches\\n## Branch protection rules table\\nThis table serves as a quick summary. Read the rest of the article for details.\\r\\n\\r\\nThis table shows which GitHub checks are marked as `required` on respective branches. Even when a check is marked as ❌\\r\\nit **may** still be running on given branch; just that if it fails, the PR won't be blocked from merging.\\r\\n\\r\\n| Branch | Merge | SDK | TSVal | BrCh | BrChC | LintRPaaS | LintDiff | Model | Semantic | Spell | Prettier | license | approver |\\r\\n|-|-|-|-|-|-|-|-|-|-|-|-|-|-|\\r\\n| public `main`                  | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSMaster`         | ✅ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| public/private `release-*`     | ✅ | ❌ | ✅ | ❌ | ❌ | ❌ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ | ✅ |\\r\\n| private `RPSaaSDev`            | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `InternalARMContracts` | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n| private `ARMCoreRPDev`         | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ❌ | ✅ |\\r\\n\\r\\nLegend:\\r\\n\\r\\n| Column name | Full GitHub check name               |\\r\\n|-------------|--------------------------------------|\\r\\n| `BrCh`      | `Swagger BreakingChange`             |\\r\\n| `BrChC`     | `Breaking Change(Cross-Version)`     |\\r\\n| `license`   | `license/cla`                        |\\r\\n| `LintDiff`  | `Swagger LintDiff`                   |\\r\\n| `LintRPaaS` | `Swagger Lint(RPaaS)`                |\\r\\n| `Merge`     | `Automated merging requirements met` |\\r\\n| `Model`     | `Swagger ModelValidation`            |\\r\\n| `Prettier`  | `PrettierCheck`                      |\\r\\n| `SDK`       | `SDK azure-sdk-for-go`               |\\r\\n| `Semantic`  | `Swagger SemanticValidation`         |\\r\\n| `Spell`     | `SpellCheck`                         |\\r\\n| `TSVal`     | `TypeScript Validation`              |\\r\\n| `approver`  | Requires team member approval        |\\r\\n\\r\\nFor more information on these checks, see:\\r\\n\\r\\n- https://aka.ms/azsdk/pr-getting-help\\r\\n- https://aka.ms/ci-fix\"}]",
            "inputs.latency": 1075.3434097766876,
            "inputs.response_length": 2722,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation",
                "https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline",
                "https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-BreakingChange"
            ],
            "inputs.testcase": "RPSaaSMaster - Simple string change pullrequest marked as a breaking-change for unrelated packages",
            "outputs.similarity.similarity": 4.0,
            "outputs.similarity.gpt_similarity": 4.0,
            "outputs.similarity.similarity_result": "pass",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1936,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1937,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: RPSaaSMaster - Simple string change pullrequest marked as a breaking-change for unrelated packages\\\\n\\\\nquestion: I submitted this pullrequest to clean up some references that were missed when we changed a new resource name\\\\nBranch: RPSaaSMaster\\\\nService: Microsoft.PortalServices/copilot\\\\nPR: [Typo Fix: Clean up old copilotPlans references in Microsoft.PortalServices/copilots 2025-10-01-prev\\\\u2026](https://github.com/Azure/azure-rest-api-specs-pr/pull/24760)\\\\nIt has failed validation for breaking change - looking at the results, the errors appear to reference unrelated services/packages as the source of the breaking change:\\\\nExample:\\\\n```\\\\n\\\\u274c Breaking Change(Cross-Version) - Analyze Code\\\\nappendOadRuntimeErrors: {\\\\\\\"type\\\\\\\":\\\\\\\"Raw\\\\\\\",\\\\\\\"level\\\\\\\":\\\\\\\"Error\\\\\\\",\\\\\\\"message\\\\\\\":\\\\\\\"Runtime Exception\\\\\\\",\\\\\\\"time\\\\\\\":\\\\\\\"2025-09-24T16:53:33.708Z\\\\\\\",\\\\\\\"groupName\\\\\\\":\\\\\\\"stable\\\\\\\",\\\\\\\"extra\\\\\\\":{\\\\\\\"new\\\\\\\":\\\\\\\"https://github.com/Azure/azure-rest-api-specs-pr/blob/05536a3ad9be35b516ecb39df1c828ba8fdacc9b/specification/devcenter/resource-manager/Microsoft.DevCenter/preview/2023-11-01-preview/devcenter.json\\\\\\\",\\\\\\\"old\\\\\\\":\\\\\\\"https://github.com/Azure/azure-rest-api-specs-pr/blob/main/specification/devcenter/resource-manager/Microsoft.DevCenter/stable/2023-04-01/devcenter.json\\\\\\\",\\\\\\\"details\\\\\\\":\\\\\\\"incompatible properties : resourceId\\\\\\\\n    definitions/OperationStatus/properties/resourceId\\\\\\\\n    at file:///home/runner/work/azure-rest-api-specs-pr/azure-rest-api-specs-pr/specification/devcenter/resource-manager/Microsoft.DevCenter/preview/2023-11-01-preview/devcenter.json#L5192:8\\\\\\\\n    definitions/OperationStatusResult/properties/resourceId\\\\\\\\n    at file:///home/runner/work/azure-rest-api-specs-pr/azure-rest-api-specs-pr/specification/common-types/resource-management/v5/types.json#L279:8\\\\\\\"}}\\\\n```\\\\nAm I misreading these errors? or is there a problem with the validation - if so do we need to request a sign off?\\\", \\\"response\\\": \\\"You are not misreading the errors\\\\u2014it's common for Azure REST API spec validation pipelines (especially the Breaking Change(Cross-Version) and Swagger BreakingChange checks) to report breaking changes from unrelated services/packages if the underlying validation tooling encounters issues elsewhere in the repo during the PR run. This typically happens due to one of the following reasons:\\\\n\\\\n1. **Global/Repo-wide Validation**: The pipeline does a cross-version comparison for *all* services in the repository, not just your PR's changes. If there are errors in other specs (e.g., Microsoft.DevCenter) that exist in the repo or are touched by branch merges, these will show up in your PR validation output.\\\\n\\\\n2. **Stale Dependencies or Out-of-sync Branches**: If your PR branch is not up to date with the target branch (`RPSaaSMaster`), validation may compare against outdated or incompatible files, causing errors unrelated to your changes.\\\\n\\\\n3. **Unintended Spec Interactions**: Sometimes, small changes (like typo fixes or reference clean-ups) can trigger downstream issues in shared/common types or dependencies, which appear as unrelated errors.\\\\n\\\\n**What should you do?**\\\\n- First, ensure your branch is fully up to date with `RPSaaSMaster` by following the instructions in [TypeSpec Validation - Running Locally](https://github.com/Azure/azure-rest-api-specs/wiki/TypeSpec-Validation#running-locally):\\\\n  - `git clean -xdf` (to clean the repo)\\\\n  - `git pull` (to sync with latest)\\\\n  - `npm ci` (to install dependencies)\\\\n  - Re-compile and re-run validation.\\\\n- If errors persist and clearly reference unrelated services (not impacted by your PR), document this in your PR description. Azure's breaking change policy requires you to address *actual* breaking changes only.\\\\n- If these errors are not caused by your changes, you do **not** need to request a sign-off for breaking changes. You should reach out to the TypeSpec Discussion channel or tag the API Stewardship team to confirm these are false positives. See [Resolving Pipeline Failures](https://azure.github.io/typespec-azure/docs/migrate-swagger/faq/pipeline) and [Swagger BreakingChange FAQ](https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-BreakingChange) for more troubleshooting.\\\\n\\\\n**Summary:**\\\\n- Your simple string/reference cleanup should not cause breaking changes in unrelated packages. Most likely, these are validation artifacts from global pipeline checks or out-of-date dependencies. Fix by syncing your branch and dependencies, and only escalate to sign-off if your change actually introduces a breaking change in your service.\\\\n\\\\nFor persistent or unexplained errors, contact the TypeSpec Discussion channel with the details and pipeline logs.\\\", \\\"ground_truth\\\": \\\"Something about the history of the head branch of your PR, is confusing our BreakingChanges check, to thinking you modified more files than shown in the \\\\\\\"diff\\\\\\\" of your PR.  Maybe an unusual merge or something.\\\\nEasiest fix:\\\\npull latest changes in RPSaaSMaster\\\\ncreate a new branch from RPSaaSMaster\\\\ncreate a single commit with the changes you want\\\\ncreate a new PR, using this as the head branch\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"4\"}]"
        },
        {
            "inputs.query": "title: DNS Resolver New Version Review\n\nquestion: Hi team, I am trying to get a review on my PR but bot removes the WaitForARMFeedback label. Could someone help take a look and approve/add the breaking change label? The breaking change CI/CD is flagging as a property has been changed from required to not required.\n```\nThe following breaking changes have been detected in comparison to the latest stable version\n❌ 1025 - RequiredStatusChange\nDisplaying 1 out of 1 occurrences.\nIndex | Description\n1 | The required status changed from the old version ('True') to the new version ('False').\nNew: DnsResolver/preview/2025-10-01-preview/openapi.json#L4901:7\ndefinitions.DnsSecurityRuleProperties.properties\nOld: DnsResolver/stable/2025-05-01/openapi.json#L4892:7\n❌ 1027 - DefaultValueChanged\nDisplaying 1 out of 1 occurrences.\nIndex | Description\n1 | The new version has a different default value than the previous one.\nNew: DnsResolver/preview/2025-10-01-preview/openapi.json#L4916:9\ndefinitions.DnsSecurityRuleProperties.properties.allowedDomainsLists\nOld: DnsResolver/stable/2025-05-01/openapi.json#L4907:9\n```\n[Release 2025-10-01-preview for DNS Resolver by jamesvoongms · Pull Request #24470 · Azure/azure-res…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24470)",
            "inputs.ground_truth": "In the \"next steps to merge\" comment, your PR indicates it's ready to merge.\nSince your PR is to a \"release-*\" branch, the Breaking Changes board will not review it, and the check is not required.  Your breaking changes will be reviewed when your release branch merges to main/RPSaaSMaster.\nhttps://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches#branch-protection-rules-table",
            "inputs.response": "Based on the Azure API versioning and breaking change policies, here is how your flagged changes are evaluated:\n\n1. **Changing a property from required to optional (RequiredStatusChange):**\n- This is considered a breaking change at the REST API level because existing client code that expects the property to always be present could break if it is omitted in the new version.\n- If this change is in a *new preview version* (e.g., 2025-10-01-preview), breaking changes compared to the previous preview are permitted. However, breaking changes compared to the latest GA (stable) version are **not allowed** unless approved through the Breaking Change Review process. \n- If your intention is to make this a non-breaking change, you should provide a default value for the property, as described in the non-breaking versioning guidance. But currently, there is no direct TypeSpec decorator for default values; instead, the recommended pattern is to use `@madeOptional` together with `@added`/`@removed` to manage optionality across versions. If a default value is present, it can mitigate breaking change impact for new clients, but the change must still be reviewed and approved for existing stable versions.\n\n2. **Changing the default value for a property (DefaultValueChanged):**\n- This is also considered a breaking change unless the property is new in the preview version, or unless the new default value does not impact client behavior (rare).\n- If you change a default value between stable and preview, clients relying on the previous default may be affected. This requires a breaking change review for stable versions.\n\n**Actions Required:**\n- For both changes, you must follow the Breaking Change Review process. Your PR will be blocked until the board reviews and either approves or rejects these changes. See [aka.ms/brch] for process details.\n- If you believe these are benign or bugfixes (e.g., the required status was incorrect, or the new default better matches service behavior), you may request a 'BreakingChange-Approved-BugFix' label and justify your reasoning in the PR description. Otherwise, you must go through full review.\n\n**How to Fix/Proceed:**\n- Do NOT attempt to suppress the error or change the OpenAPI manually. You must update your TypeSpec definition and go through the breaking change review.\n- You may provide evidence (in the PR) that no existing customer would be affected, or that the change is required for correctness, to accelerate review.\n\n**References and Examples:**\n- For making a property optional in a new version, use `@madeOptional(Versions.v2025_10_01_preview)` in TypeSpec. See the following example:\n\n```typespec\nmodel DnsSecurityRuleProperties {\n  // In previous stable version:\n  // property was required\n  // In new preview version:\n  @madeOptional(Versions.v2025_10_01_preview)\n  propertyName?: Type;\n}\n```\n- For changing default values, there is currently no direct versioned decorator, so you should use the `@added`/`@removed` pattern to replace the property with a new one if needed.\n\n**Summary:**\n- Both changes are breaking and require review/approval. Document your rationale and follow the process at [aka.ms/brch]. Once approved, the proper label will be added and your PR can proceed.",
            "inputs.context": "[{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-brch-deep.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep\",\"content\":\"# design#specs-pr-guides#pr-brch-deep.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-brch-deep](https://aka.ms/azsdk/pr-brch-deep) |\\r\\n| --- | --- |\\n\\n# Deep-dive into breaking changes on spec PRs\\n\\n## Important information about this article\\n\\nThis article provides a deep-dive into breaking changes on spec PRs. It applies if your spec PR has\\r\\n`BreakingChangeReviewRequired` or `VersioningReviewRequired` label.\\r\\n\\r\\n\\u003e [!IMPORTANT]\\r\\n\\u003e This is an advanced deep-dive. If your PR is blocked on breaking changes or versioning issues, you should always\\r\\n\\u003e start by following the guidance at [aka.ms/brch].\\n\\n### Prerequisites\\n\\nThis article assumes you are familiar with [API versions and branches](xref:api-versions-and-branches).\\n\\n### Video overview and slides\\n\\nFor video overview of the breaking changes process, see this [Azure Core Day of Learning talk from March 6, 2024].\\r\\nSlides for the talk are available [here][talk slides].\\n\\n### Summary\\n\\nPer the [PR diagram], the first step of getting your specs PR approved is ensuring your PR obeys the  \\r\\n[Azure Versioning and Breaking Changes Policy]. Relevant details of this policy follow.\\r\\n\\r\\n- Once published, no changes to given API version are allowed, except when fixing the spec to match\\r\\nactual implementation (see the `-Approved-BugFix` labels in this doc).\\r\\nThis applies regardless of whether the API version is for `private preview`, `public preview`, or `GA`.\\r\\n- When introducing a new API version (any `preview` or `GA`), the new API version must be backwards compatible with\\r\\nthe previous, latest `GA` API version.\\r\\n- During a (`private` or `public`) `preview` cycle, a new `preview` API version does not have to be backwards\\r\\ncompatible with the previous `preview` API version.\\r\\n- The rules listed above are checked by automated GitHub checks. The exact ruleset is given in [`oadMessagesRuleMap.ts`].\\r\\nDetails follow.\\n\\n## Breaking changes and versioning issues\\n\\nThere are two automatic checks running on your PR checking for conformance\\r\\nto the [Azure Versioning and Breaking Changes Policy]:\\r\\n\\r\\n- `Breaking Change(Cross-Version)` that ensures you don't introduce breaking changes or violate versioning policy\\r\\n*across* two API versions.\\r\\n- `Swagger BreakingChange` that ensures you didn't introduce breaking changes or violated versioning policy\\r\\n*within* any single API version.\\r\\n\\r\\nThe result of running these checks may result in one of these labels being applied: `BreakingChangeReviewRequired`\\r\\nor `VersioningReviewRequired`. If this happens, your PR is **blocked** from any further review, including ARM review,\\r\\nif applicable.\\r\\n\\r\\nThe breaking change/versioning checks are performed only on PRs targeting the `main` branch in the [public specs repo]\\r\\nor `RPSaaSMaster` branch of the [private specs repo].\\r\\n\\r\\nThese two branches are `production branches`. Merging an API specification to either of them publishes it\\r\\nfor all customers to use \\u0026 consume.\\n\\n### `BreakingChangeReviewRequired` label\\n\\nThe label `BreakingChangeReviewRequired` is added to your PR if the tooling detects a change that could\\r\\nbe breaking for customers. This can happen in two cases:\\r\\n\\r\\n- In your PR you have possibly introduced a breaking change in a new API version, placed in a new folder,\\r\\nas compared to most recent previous `GA`.\\r\\nThe new API version can be either `preview` or `GA`.\\r\\n  - For example, an existing `GA` API version in leaf folder of `2023-11-15`\\r\\nmay contain API route of `GET .../resoruces/{resourceName}`, but a new `preview` API version of `2024-03-15-preview`\\r\\nmay no longer have this route (REST API path), because you are removing the `resoruces` typo and instead introducing\\r\\n`GET .../resources/{resourceName}` route.\\r\\n- In your PR you are modifying existing `GA` API version in-place. For example, you have recently released\\r\\n`2024-03-18` API version and realized you made a typo and are editing the contents of the leaf folder `2024-03-18`\\r\\ncontaining that API version.\\n\\n### `VersioningReviewRequired` label\\n\\nThe label `VersioningReviewRequired` denotes that your PR has a **versioning issue** possibly violating the  \\r\\n[Azure Versioning and Breaking Changes Policy]. This happens when you made a **non-breaking change**,\\r\\naka **compatible change** to an API version that was already published (merged to a production branch).\\r\\n\\r\\n\\u003e [!NOTE]\\r\\n\\u003e According to [the policy][Azure Versioning and Breaking Changes Policy], compatible (non-breaking changes) are not\\r\\n\\u003e allowed within an existing API version. You must create a new API version. Otherwise, we would confuse our customers\\r\\n\\u003e by having to explain \\\"which version of given API version\\\" has a particular change/feature.\\r\\n\\r\\n`VersioningReviewRequired` label is added by automation if:\\r\\n\\r\\n- You made any compatible changes **within** any API version, `GA` or `preview`.\\r\\n- You made any breaking changes in a `preview` API version.\\r\\n\\r\\nIf your PR has both breaking changes and versioning issues, only `BreakingChangeReviewRequired` label\\r\\nis added to it.\\n\\n### In case there is no latest GA API version\\n\\nIf there is no latest GA OpenAPI spec, then the the cross-version check is instead comparing to\\r\\nlatest available preview if it more than 1 year old.\\r\\n\\r\\nIf neither a GA API version or at least 1 year old preview version exists, then the cross-version check automatically\\r\\npasses.\\n\\n### Diagram explaining breaking changes and versioning issues\\n\\nThe logic for automation adding `BreakingChangeReviewRequired` and `VersioningReviewRequired` labels explained above\\r\\ncan be summarized in the following diagram:\\r\\n\\r\\n![Breaking Changes Confusion Matrix](../../img/breaking_changes_confusion_matrix.png)\\n\\n## Addressing `BreakingChangeReviewRequired`\\n\\nIf your PR is labelled with `BreakingChangeReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the breaking changes in your PR are acceptable, they will be\\r\\napproved by one of these labels:\\n\\n### `BreakingChange-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `BreakingChange-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-UserImpact`\\n\\n- The spec PR describes actual breaking changes to the service.\\r\\n- This is the only case that triggers customer notifications, a 3 year migration period (possibly shorter), etc.\\r\\n- Within this set, the changes may be distinguished further for security or legal compliance, which may be granted\\r\\na shorter migration period.\\r\\n- Details at [aka.ms/brch].\\n\\n### `BreakingChange-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `BreakingChange-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `BreakingChange-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Addressing `VersioningReviewRequired`\\n\\nIf your PR is labelled with `VersioningReviewRequired`, per Step 1 from the [PR diagram],\\r\\nyou must follow the process given at [aka.ms/brch].\\r\\n\\r\\nIf the Breaking Change Review Board determines the versioning issue in your PR caused by non-breaking (compatible)\\r\\nchanges is acceptable, the board will approve it by one of these labels:\\n\\n### `Versioning-Approved-Benign`\\n\\nThe changes to the REST API definition are not breaking at the REST API level and have at most minor impact to\\r\\ngenerated SDKs, so the change is allowed.\\n\\n### `Versioning-Approved-BugFix`\\n\\nThe changes to the REST API definition are correcting the definition to accurately describe the service behavior.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BugFix` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-PrivatePreview`\\n\\nThe API version change that triggered the review is in `private preview`, and non-breaking changes are permitted\\r\\nin the same API version during `private preview`.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-PrivatePreview` label. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-BranchPolicyException`\\n\\nThe API version that triggered the review violates the GitHub repository branch policy, but we allow it.\\r\\nUsually this is because it has not yet been released, despite having been merged to a production branch.\\r\\n\\r\\n\\u003e [!TIP]\\r\\n\\u003e As a PR author, you are allowed to apply the `Versioning-Approved-BranchPolicyException` label,\\r\\n\\u003e but only in the [private specs repo]. See [aka.ms/brch] for details.\\n\\n### `Versioning-Approved-Previously`\\n\\n- The PR contains breaking changes that were previously reviewed and approved.\\r\\n- It is desirable but not mandatory to add a link the previously approved PR in a comment on given PR.\\r\\n- As of 3/11/2024 we have planned work to reduce occurrences of this scenario.\\r\\nSee [#7259](https://github.com/Azure/azure-sdk-tools/issues/7259) for details.\\n\\n## Common misconceptions\\n\\n### FALSE: compatible (non-breaking) changes are allowed in published API versions\\n\\n**Why?**\\r\\n\\r\\nAn API version is a contract, and once the contract is published it cannot be changed.\\r\\nOtherwise, it would create customer confusion about \\\"which version of this API version\\\" are they using.\\r\\n\\r\\nAny change of this kind w\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#specs-pr-guides#pr-arm-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-arm-review\",\"content\":\"# design#specs-pr-guides#pr-arm-review.md\\n\\n| Short Link: | [aka.ms/azsdk/pr-arm-review](https://aka.ms/azsdk/pr-arm-review) |\\r\\n|--|--|\\n\\n# Get your PR reviewed by ARM\\n\\n\\u003e [!NOTE]\\r\\n\\u003e This article assumes you came here from your REST API specs PR.\\r\\n\\u003e See [this documentation section description](xref:specs-pr-guides) for details.\\r\\n\\r\\nIf your Azure REST API specs PR pertains to ARM (see [glossary](xref:glossary#arm)) specs,\\r\\nthen the second step of the PR approval process per the [PR workflow diagram] (https://aka.ms/azsdk/pr-diagram)\\r\\nis the ARM review. The overall PR approval process is explained at https://aka.ms/azsdk/specreview/merge.\\r\\n\\r\\nIf your PR does not pertain to ARM specs, then this article won't be relevant to you.\\r\\nSee instead [`Getting help` section] on your PR (https://aka.ms/azsdk/pr-getting-help).\\n\\n## Review process\\n\\n- If your PR is in purview of ARM review then the automation will add the `ARMReview` label.\\r\\n- Your PR will start the ARM Review process. Your PR could be automatically reviewed or added to a review queue. \\r\\nRefer to the wiki [API Review wiki](https://eng.ms/docs/products/arm/rp_onboarding/process/api_review) for more\\r\\ninformation on the selection criteria.\\n\\n### About the ARM review queue\\n\\nThe PRs on the [ARM review queue] are processed by time opened, ascending.\\r\\n\\r\\nYour PR may show up on 2nd or later page on the GitHub web UI, so ensure to check these pages too.\\r\\n\\r\\nIf you addressed step 1 from [the diagram][PR workflow diagram] (breaking changes review) and your PR is not showing up\\r\\nin the queue, ensure the label `ARMChangesRequested` is removed from your PR.\\r\\nThis should cause the label `WaitForARMFeedback` to be added.\\r\\n\\r\\nThe ARM review queue is processed by the ARM reviewer on-call, per [IcM].\\r\\n\\r\\nThe ARM reviewer reviews approximately 10 PRs in a business day. This could vary based on the complexity of the PRs\\r\\nat any given time in the review queue. The ETA for a review therefore is approximately equal to\\r\\n`((The position of your PR in the review queue) / 10)(int) + 1` business days.\\r\\n\\r\\nFor example: if the position of your PR in the review queue is `12`, then the approximate ETA is:\\r\\n`12/10 + 1 = 1 + 1 = 2` business days.\\n\\n## Getting help for your ARM review\\n\\n\\u003e [!IMPORTANT]\\r\\n\\u003e If your PR has breaking changes you must solve them before asking the on-call ARM reviewer for help.\\r\\n\\r\\nIf you need help from the ARM reviewer, book the **ARM API Review Office Hours** per https://aka.ms/armofficehoursinfo.\\r\\n\\r\\nFor help with other topics, please use the prescribed methods mentioned in the [PR workflow diagram] and your\\r\\nPR description [`Getting help` section].\\r\\n\\r\\n[PR workflow diagram]: https://aka.ms/azsdk/pr-diagram\\r\\n[ARM review queue]: https://github.com/search?q=org%3AAzure+is%3Apr+is%3Aopen+label%3AWaitForARMFeedback+-label%3AIDCDevDiv++draft%3Afalse+sort%3Acreated-asc+\\u0026type=pullrequests\\r\\n[IcM]: https://portal.microsofticm.com/imp/v3/oncall/current?serviceId=20371\\u0026teamIds=51358\\u0026scheduleType=timeline\\u0026shiftType=current\\u0026viewType=1\\r\\n[`Getting help` section]: https://aka.ms/azsdk/pr-getting-help\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Summarize-Impact.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Summarize-Impact\",\"content\":\"# Summarize-Impact.md\\n\\n## Description\\n\\nThe `Summarize Impact` check is used to evaluate an incoming changeset on a PR to `azure-rest-api-specs` or `azure-rest-api-specs-pr`. This evaluation examines the code, and bucketizes the \\\"types\\\" of changes that are occurring. It is used so that the `summarize-checks` check can apply the correct labels and evaluate `automated merge requirements` without actually those details itself. Doing it this way creates a security boundary between the change itself and the code that will be executing privileged actions in the specs repo.\\r\\n\\r\\nQuestions that `Summarize Impact` answers will be similar to:\\r\\n\\r\\n\\u003e Does this PR add or modify suppressions?\\r\\n\\r\\n\\u003e Does this PR change TypeSpec?\\r\\n\\r\\n\\u003e Does it add a new RP that isn't RPaaS?\\r\\n\\r\\nAnd other `about` questions.\\n\\n## Troubleshooting details\\n\\n### Suppression change without triggering `Suppression Review Required`\\n\\nIn certain circumstances, devs can can modify the suppressions for a readme, _without_ requiring a suppression review. [This PR](https://github.com/Azure/azure-rest-api-specs/pull/36645/files) is one such example. It is adding two new suppressions to a new API version, but the suppressions themselves _already exist_ for a previous API version. In this case, `summarize impact` _intentionally_ evaluates this PR to not need suppression review. If the RP was approved previously, it should be approved for this new api version as well.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"azure#apiVersionEvolution.md\",\"document_title\":\"Scenarios for API Evolution\",\"document_link\":\"\",\"content\":\"# azure#apiVersionEvolution.md\\n\\n# Scenarios for API Evolution\\n\\nThis document describe how to evolute api version for a management plane services.\\n\\n## Scenarios to Consider\\n\\nadd a new stable version\\r\\nadd a new preview version\\r\\nMaking a preview api stable\\r\\nReplacing a preview API with a new preview API\\r\\nReplacing a preview API with a stable API\\r\\nReplacing a preview API with a stable API and a new preview API\\r\\nAdding a preview API (previous stable API)\\r\\nConverting existing specs with mixes of preview and stable APIs\\r\\nNote that, in this new scenario, new services will always have only a single version in their specs until they have their first stable version.  This should drastically reduce the amount of decoration in preview APIs\\n\\n## Add a new stable version\\n\\n### TypeSpec Steps\\n\\n1. Check the Latest Version\\r\\n   1. Determine whether the latest version is a preview version or a stable (GA) version.\\r\\n2. If the Latest Version is Stable (GA):\\r\\n   1. Add a new entry for the new stable version at the bottom of the Versions enumeration\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Make changes to the API using versioning decorators to mark each change\\r\\n3. if the latest version is preview version: \\r\\n   1. Add a new stable (GA) version enum before the existing preview enum value.\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Update all items that are GA’ing:\\r\\n      1. Change their @added version value to match the new GA enum value.\\r\\n   4. Handle remaining preview-only features:\\r\\n      1. If some features are not GAed, create a new preview version and Decorate non-GA items with @added pointing to the new preview version.\\r\\n      2. If all features in the preview version are GAed, delete the existing preview version.\\n\\n## Replacing a Preview API with a new Preview API (Adding a Preview API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new preview api-version\\r\\n- rename the example folder to use the new version\\r\\n- Remove any api changes not in the new version (simply remove types or type change decorators that do not apply)\\r\\n- Change the API inline decorating any type changes or new types in the new versionSome tooling to pick which resources, types, and operations are part of the new API could be useful.\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a Stable API (Adding a stable API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new stable api-version. \\r\\n- Remove any @previewVersion decorator\\r\\n- rename the example folder to use the new stable api version\\r\\n- Remove any api changes not in the new stable API version. Some tooling to pick which resources, types, and operations are part of the new API could be useful.\\r\\n- Add any api changes in the new stable version, using versioning decorators unless it is the only api-version\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a new Stable and a Preview API (previous stable API exists)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the preview version in the \\\"versions\\\" enumeration to match the new preview version and all references\\r\\n- Add a new Stable version entry immediately before the renamed version entry\\r\\n- rename the example folder to use the new preview api version\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Relabel any api changes in the new stable API version, that is, any changes in the preview that are now considered stable. \\r\\n    - Some tooling to pick which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any api changes in the new stable version, using versioning decorators (automatically included in the new preview version)\\r\\n- Add any api changes still in preview in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with the first Stable API and a new Preview API (no previous stable api)\\n\\n### TypeSpec Steps\\n\\n- Replace the current versions enum member with the new stable api-version (first) and the new preview api-version (last)\\r\\n- Decorate the preview api-version with the @previewVersion decorator\\r\\n- Rename the example folder to use the new preview api version and update examples as needed\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Leave any resources, types and operations in the new stable version undecorated (automatically included in both the new stable and the new preview version)\\r\\n- Decorate any resources, types, and operations only in the new preview API version, that is, any types that are not considered stable. Some tooling to pick - which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any new preview api changes in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Adding a Preview API (Previous Stable API)\\n\\n### TypeSpec Steps\\n\\n- Add a new entry for the new preview version at the bottom of the Versions enumeration and decorate with @previewVersion\\r\\n- Add a new example folder for the new version and copy any still-relevant examples\\r\\n- Make changes to the API using versioning decorators to mark each change\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n## Converting Existing Specs With mixes of Preview and Stable APIs\\n\\n### TypeSpec Steps\\n\\n- For each preview api-version, in order\\r\\n  - For each versioning decorator, forward the version to the next version, except\\r\\n    - if this would result in a duplicated decorator application (including all decorator parameters) at that version, discard the forwarded decorator\\r\\n    - if this would result in an @added and @removed pair at a version, then discard the forwarded decorator\\r\\n    - If this would result in @typeChangedFrom or @renamedFrom with conflicting parameters, use the forwarded decorator\\r\\n  - Remove the preview api-version\\r\\n- For the first stable version\\r\\n  - Remove any @madeOptional, @added,  @typeChangedFrom, or @renamedFrom decorators\\r\\n  - Remove any types marked with the @removed decorator, unless they have @added decoration in subsequent versions\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n## Rules for api-version Changes\\n\\n@typeChangedFrom(b, string) myType: int32\\r\\nsafe: @madeOptional(a) @renamedFrom(b, \\\"oldName\\\") newName?: string -\\u003e @madeOptional(b) @renamedFrom(b, \\\"oldName\\\") newName: string\\r\\n  - This is also true for @typeChangedFrom decorators w.r.t @madeOptional and renamedFrom decorators, and @renamedFrom decorators w.r.t @madeOptional and @typeChangedFrom decorators:safe: @typeChangedFrom(a, string) @madeOptional(b) myType?: int32 -\\u003e @typeChangedFrom(b, string) @madeOptional(b) myType: int32\\r\\nsafe: @typeChangedFrom(a, string) @renamedFrom(b, \\\"oldName\\\") newName: int32 -\\u003e @typeChangedFrom(b, string) @renamedFrom(b, \\\"oldName\\\") newName: int32\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @madeOptional(b) newName?: string -\\u003e @renamedFrom(b, \\\"oldName\\\") @madeOptional(b) newName?: string\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @typeChangedFrom(b, string) newName?: int32-\\u003e @renamedFrom(b, \\\"oldName\\\") @typeChangedFrom(b, string)) newName?: int32\\r\\n  - It is safe for @typeChangedFrom, @renamedFrom, @madeOptional decorators in version a to be forwarded to version b if the type is removed in version bsafe: @renamedFrom(a, \\\"oldName\\\") @removed(b) newName: string -\\u003e @renamedFrom(b, \\\"oldName\\\") removed(b) newName: string\\r\\n  - if there is an@removed decorator in version a and an  @added decorator in version b, both decorators can be removedsafe: @removed(a) @added(b) myType: string-\\u003e myType: string\\r\\n  - if there is an@addeddecorator in version a and an  @removeddecorator in version b, safe: @added(a) @removed(b) myType: string-\\u003e \\r\\n  - There should never be a backward-looking decorator from version a forwarded to version b if version b has an @added decoratorThis is because such a versioning would already be inconsistent:  A type cannot be transformed before it exists\\n\\ndecorator on type T from a to b, provided there are no other versioning decorators on type T that use version b.\\r\\n    - safe:  @added(a) -\\u003e @added(b)\\r\\n    - possibly unsafe: @added(a)@removed(b) -\\u003e @added(b) @removed(b)\\r\\n  - It is safe to forward an @added decorator on type T from a to b and remove any backward-looking decorator on type T using version b:\\r\\n    - safe: @added(a) @added(b) -\\u003e @added(b)\\r\\n    - safe: @added(a) @madeOptional(b) myType?: int32 -\\u003e @added(b) myType?: int32\\r\\n    - safe: @added(a) @typeChangedFrom(b, string) myType: int32 -\\u003e @added(b) myType: int32\\r\\n    - safe: @added(a) @renamedFrom(b, \\\"oldName\\\") newName: string -\\u003e @added(b) newName: string\\r\\n  - It is safe to forward a @madeOpt\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"azure#apiVersionEvolution.md\",\"document_title\":\"Scenarios for API Evolution\",\"document_link\":\"\",\"content\":\"# azure#apiVersionEvolution.md\\n\\n# Scenarios for API Evolution\\n\\nThis document describe how to evolute api version for a management plane services.\\n\\n## Scenarios to Consider\\n\\nadd a new stable version\\r\\nadd a new preview version\\r\\nMaking a preview api stable\\r\\nReplacing a preview API with a new preview API\\r\\nReplacing a preview API with a stable API\\r\\nReplacing a preview API with a stable API and a new preview API\\r\\nAdding a preview API (previous stable API)\\r\\nConverting existing specs with mixes of preview and stable APIs\\r\\nNote that, in this new scenario, new services will always have only a single version in their specs until they have their first stable version.  This should drastically reduce the amount of decoration in preview APIs\\n\\n## Add a new stable version\\n\\n### TypeSpec Steps\\n\\n1. Check the Latest Version\\r\\n   1. Determine whether the latest version is a preview version or a stable (GA) version.\\r\\n2. If the Latest Version is Stable (GA):\\r\\n   1. Add a new entry for the new stable version at the bottom of the Versions enumeration\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Make changes to the API using versioning decorators to mark each change\\r\\n3. if the latest version is preview version: \\r\\n   1. Add a new stable (GA) version enum before the existing preview enum value.\\r\\n   2. Add a new example folder for the new version and copy any still-relevant examples\\r\\n   3. Update all items that are GA’ing:\\r\\n      1. Change their @added version value to match the new GA enum value.\\r\\n   4. Handle remaining preview-only features:\\r\\n      1. If some features are not GAed, create a new preview version and Decorate non-GA items with @added pointing to the new preview version.\\r\\n      2. If all features in the preview version are GAed, delete the existing preview version.\\n\\n## Replacing a Preview API with a new Preview API (Adding a Preview API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new preview api-version\\r\\n- rename the example folder to use the new version\\r\\n- Remove any api changes not in the new version (simply remove types or type change decorators that do not apply)\\r\\n- Change the API inline decorating any type changes or new types in the new versionSome tooling to pick which resources, types, and operations are part of the new API could be useful.\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a Stable API (Adding a stable API to a spec with an active preview)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the version in the \\\"versions\\\" enumeration and all references to match the new stable api-version. \\r\\n- Remove any @previewVersion decorator\\r\\n- rename the example folder to use the new stable api version\\r\\n- Remove any api changes not in the new stable API version. Some tooling to pick which resources, types, and operations are part of the new API could be useful.\\r\\n- Add any api changes in the new stable version, using versioning decorators unless it is the only api-version\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with a new Stable and a Preview API (previous stable API exists)\\n\\n### TypeSpec Steps\\n\\n- Use 'rename symbol' to rename the preview version in the \\\"versions\\\" enumeration to match the new preview version and all references\\r\\n- Add a new Stable version entry immediately before the renamed version entry\\r\\n- rename the example folder to use the new preview api version\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Relabel any api changes in the new stable API version, that is, any changes in the preview that are now considered stable. \\r\\n    - Some tooling to pick which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any api changes in the new stable version, using versioning decorators (automatically included in the new preview version)\\r\\n- Add any api changes still in preview in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Replacing a Preview API with the first Stable API and a new Preview API (no previous stable api)\\n\\n### TypeSpec Steps\\n\\n- Replace the current versions enum member with the new stable api-version (first) and the new preview api-version (last)\\r\\n- Decorate the preview api-version with the @previewVersion decorator\\r\\n- Rename the example folder to use the new preview api version and update examples as needed\\r\\n- Create a new example folder for the stable API and copy relevant examples\\r\\n- Leave any resources, types and operations in the new stable version undecorated (automatically included in both the new stable and the new preview version)\\r\\n- Decorate any resources, types, and operations only in the new preview API version, that is, any types that are not considered stable. Some tooling to pick - which resources, types, and operations from the previous preview became stable and which ones became part of the new preview APIs.\\r\\n- Add any new preview api changes in the new preview API-version, using versioning decorators\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n### CI Checks and Process\\n\\n- Investigate whether ci checks will flag existing swagger generated from previous typespec and adjust checks as necessary\\r\\n- Cleanup process for retired api-versions\\n\\n## Adding a Preview API (Previous Stable API)\\n\\n### TypeSpec Steps\\n\\n- Add a new entry for the new preview version at the bottom of the Versions enumeration and decorate with @previewVersion\\r\\n- Add a new example folder for the new version and copy any still-relevant examples\\r\\n- Make changes to the API using versioning decorators to mark each change\\n\\n### Check-in Steps\\n\\n- Add new tag to readme (can this be automated)?\\n\\n## Converting Existing Specs With mixes of Preview and Stable APIs\\n\\n### TypeSpec Steps\\n\\n- For each preview api-version, in order\\r\\n  - For each versioning decorator, forward the version to the next version, except\\r\\n    - if this would result in a duplicated decorator application (including all decorator parameters) at that version, discard the forwarded decorator\\r\\n    - if this would result in an @added and @removed pair at a version, then discard the forwarded decorator\\r\\n    - If this would result in @typeChangedFrom or @renamedFrom with conflicting parameters, use the forwarded decorator\\r\\n  - Remove the preview api-version\\r\\n- For the first stable version\\r\\n  - Remove any @madeOptional, @added,  @typeChangedFrom, or @renamedFrom decorators\\r\\n  - Remove any types marked with the @removed decorator, unless they have @added decoration in subsequent versions\\n\\n### Check-in Steps\\n\\n- Add new tags to readme (can this be automated)?\\n\\n## Rules for api-version Changes\\n\\n@typeChangedFrom(b, string) myType: int32\\r\\nsafe: @madeOptional(a) @renamedFrom(b, \\\"oldName\\\") newName?: string -\\u003e @madeOptional(b) @renamedFrom(b, \\\"oldName\\\") newName: string\\r\\n  - This is also true for @typeChangedFrom decorators w.r.t @madeOptional and renamedFrom decorators, and @renamedFrom decorators w.r.t @madeOptional and @typeChangedFrom decorators:safe: @typeChangedFrom(a, string) @madeOptional(b) myType?: int32 -\\u003e @typeChangedFrom(b, string) @madeOptional(b) myType: int32\\r\\nsafe: @typeChangedFrom(a, string) @renamedFrom(b, \\\"oldName\\\") newName: int32 -\\u003e @typeChangedFrom(b, string) @renamedFrom(b, \\\"oldName\\\") newName: int32\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @madeOptional(b) newName?: string -\\u003e @renamedFrom(b, \\\"oldName\\\") @madeOptional(b) newName?: string\\r\\nsafe: @renamedFrom(a, \\\"oldName\\\") @typeChangedFrom(b, string) newName?: int32-\\u003e @renamedFrom(b, \\\"oldName\\\") @typeChangedFrom(b, string)) newName?: int32\\r\\n  - It is safe for @typeChangedFrom, @renamedFrom, @madeOptional decorators in version a to be forwarded to version b if the type is removed in version bsafe: @renamedFrom(a, \\\"oldName\\\") @removed(b) newName: string -\\u003e @renamedFrom(b, \\\"oldName\\\") removed(b) newName: string\\r\\n  - if there is an@removed decorator in version a and an  @added decorator in version b, both decorators can be removedsafe: @removed(a) @added(b) myType: string-\\u003e myType: string\\r\\n  - if there is an@addeddecorator in version a and an  @removeddecorator in version b, safe: @added(a) @removed(b) myType: string-\\u003e \\r\\n  - There should never be a backward-looking decorator from version a forwarded to version b if version b has an @added decoratorThis is because such a versioning would already be inconsistent:  A type cannot be transformed before it exists\\n\\ndecorator on type T from a to b, provided there are no other versioning decorators on type T that use version b.\\r\\n    - safe:  @added(a) -\\u003e @added(b)\\r\\n    - possibly unsafe: @added(a)@removed(b) -\\u003e @added(b) @removed(b)\\r\\n  - It is safe to forward an @added decorator on type T from a to b and remove any backward-looking decorator on type T using version b:\\r\\n    - safe: @added(a) @added(b) -\\u003e @added(b)\\r\\n    - safe: @added(a) @madeOptional(b) myType?: int32 -\\u003e @added(b) myType?: int32\\r\\n    - safe: @added(a) @typeChangedFrom(b, string) myType: int32 -\\u003e @added(b) myType: int32\\r\\n    - safe: @added(a) @renamedFrom(b, \\\"oldName\\\") newName: string -\\u003e @added(b) newName: string\\r\\n  - It is safe to forward a @madeOpt\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Handling multiple API versions using typespec\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Handling multiple API versions using typespec\\n\\n## question\\n\\nHi Team,\\r\\n \\r\\nI am releasing a new API version and looks there is a new validation to check existing swagger with new tsp file \\r\\n \\r\\n\\\"appears to contain TypeSpec-generated swagger files, not generated from the current TypeSpec sources. Perhaps you deleted a version from your TypeSpec, but didn't delete the associated swaggers?\\\"\\r\\n \\r\\nWe want to keep both old and new api versoins. What is the suggestion here? Do you suggest to create different TSP file for each version/use versioning in existing TSP? \\r\\n \\r\\nIf second case, can you share some example where APIs/Properties are added/removed in a newer version\\n\\n## answer\\n\\nThe idea behind TypeSpec versioning is to model the diffs in your API, encouraging best practices for API evolution. If you have questions about modeling particular changes, feel free to ask.\\r\\n\\r\\nAbout your concern: fixing a new validation causing changes to older APIs—this usually happens when new changes are added without using the appropriate version decorators. For example:\\r\\n\\r\\nIf you added properties or made a property optional, but didn’t annotate them with @added or @madeOptional, then they would apply to all versions by default, including older ones.\\r\\n\\r\\nThat’s likely why your stable version (e.g., 2024-12-01) got unintentionally updated when you only meant to target 2025-07-01-preview.\\r\\n\\r\\nTo avoid this, always use decorators like @added and @madeOptional to indicate version-specific changes.\\r\\n\\r\\nAs for the location field and the read/create mutability warning:\\r\\nThat rule is a warning meant to be advisory. In your case, it doesn’t seem to apply—so this is a good example where you should not change the service behavior just to satisfy a linting rule. It's fine to ignore the warning here.\\r\\n\\r\\nRegarding your question on renaming an API response (e.g., from MoveResponse to MoveResult):\\r\\nIf the new name is meant for a specific version, ensure it’s versioned properly in your TypeSpec. In your repro, the naming appears correct—MoveResult in 2021-10-01-preview, and MoveResponse in 2024-10-01-preview—so it’s working as expected.\\r\\n\\r\\nFinally, for adding or removing a parameter in only the new version:\\r\\nUnfortunately, you can’t directly decorate a spread parameter. The best way is to use operation-specific parameters, which you can decorate with versioning decorators. You could alternatively decorate the core parameter definition (e.g., with an augment decorator), but that would affect every usage—so for localized changes, use operation-specific ones. Since this is a method parameter, the APIs are equivalent and the change has no SDK impact.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_05_22.md\",\"document_title\":\"Why does the PR bot add the `WaitForARMFeedback` label when TypeSpec validation pipeline fails?\",\"document_link\":\"\",\"content\":\"# typespec_2025_05_22.md\\n\\n# Why does the PR bot add the `WaitForARMFeedback` label when TypeSpec validation pipeline fails?\\n\\n## question\\n\\nHi, not a typespec question per se, but I am curious why the PR bot now adds the WaitForARMFeedback label even when required checks fail? If I'm remembering correctly, this didn't used to be the case. \\r\\nAnd now that it does add the label, it seems like the reviewer will typically manually say \\\"Fix X pipeline check.\\\" and then switch it to \\\"ARMChangesRequested\\\". \\r\\nWould it be possible for that to happen automatically? I feel bad for wasting the reviewer's time if I don't sit around and wait for the pipeline to fail and then manually remove the label myself.  \\r\\nOr is the expectation that a commit shouldn't be pushed if I think the required checks may fail?\\n\\n## answer\\n\\nThe WaitForARMFeedback label being added even when required checks fail is intended behavior and has always worked this way, according to the ARM review team.\\r\\nIdeally, contributors should open a draft PR first and only mark it \\\"ready for review\\\" after all required checks pass. This avoids wasting reviewer time.\\r\\nThe suggestion to automatically change the label to ARMChangesRequested when checks fail is a good idea and is already on the backlog.\\r\\nThe engineering team is currently migrating the labeling system to GitHub Actions, which should make improvements like this easier in the future.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_06_26.md\",\"document_title\":\"Is it possible to make a field to be optional only on new api version?\",\"document_link\":\"\",\"content\":\"# typespec_2025_06_26.md\\n\\n# Is it possible to make a field to be optional only on new api version?\\n\\n## question\\n\\nHi TypeSpec Discussion,\\r\\n \\r\\nIn swagger, we have below data model. We want to make StageSpec.specification to be optional from 2025-06-01-preview version, but for older versions, it is still mandatory.\\r\\n \\r\\nI tried below implementation, but it failed during tsp compile. Compiler complains the field name is duplicated.\\r\\n \\r\\nIs there any way to achieve this? Really appreciate if there's any examples.\\r\\n```\\r\\nDiagnostics were reported during compilation:\\r\\n \\r\\n\\u001b[36mWorkflowVersion.tsp\\u001b[39m:\\u001b[33m95\\u001b[39m:\\u001b[33m3\\u001b[39m - \\u001b[31merror\\u001b[39m \\u001b[90mduplicate-property\\u001b[39m: Model already has \\r\\na property named specification\\r\\n\\u003e 95 |   specification?: Record\\u003cunknown\\u003e;\\r\\n     |   ^^^^^^^^^^^^^\\r\\n \\r\\nFound 1 error.\\r\\n```\\r\\n```\\r\\n@doc(\\\"Stage Properties\\\")\\r\\nmodel StageSpec {\\r\\n  @doc(\\\"Name of Stage\\\")\\r\\n  name: string;\\r\\n\\r\\n  @removed(Versions.v2025_06_01_preview)\\r\\n  @doc(\\\"Target ARM id\\\")\\r\\n  targetId?: string;\\r\\n\\r\\n  #suppress \\\"@azure-tools/typespec-azure-core/no-unknown\\\" \\\"Suppress no-unknown to handle the datatype object used in dependent service\\\"\\r\\n  #suppress \\\"@azure-tools/typespec-azure-resource-manager/arm-no-record\\\" \\\"Suppress arm-no-record to handle the datatype object used in dependent service\\\"\\r\\n  @doc(\\\"Stage specification\\\")\\r\\n  @removed(Versions.v2025_06_01_preview)\\r\\n  specification: Record\\u003cunknown\\u003e;\\r\\n\\r\\n  #suppress \\\"@azure-tools/typespec-azure-core/no-unknown\\\" \\\"Suppress no-unknown to handle the datatype object used in dependent service\\\"\\r\\n  #suppress \\\"@azure-tools/typespec-azure-resource-manager/arm-no-record\\\" \\\"Suppress arm-no-record to handle the datatype object used in dependent service\\\"\\r\\n  @doc(\\\"Stage specification\\\")\\r\\n  @added(Versions.v2025_06_01_preview)\\r\\n  specification?: Record\\u003cunknown\\u003e;\\r\\n\\r\\n  @added(Versions.v2025_06_01_preview)\\r\\n  @doc(\\\"List of tasks in the stage\\\")\\r\\n  tasks: TaskSpec[];\\r\\n\\r\\n  @added(Versions.v2025_06_01_preview)\\r\\n  @doc(\\\"Task option for the stage\\\")\\r\\n  taskOption?: TaskOption;\\r\\n}\\r\\n```\\n\\n## answer\\n\\nYou should use the @madeOptional decorator, here: [Decorators | TypeSpec](https://typespec.io/docs/libraries/versioning/reference/decorators/#@TypeSpec.Versioning.madeOptional).  Note that, making a property that occurs in responses optional is considered a breaking change.\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_07_10.md\",\"document_title\":\"Unresolved Breaking changes\",\"document_link\":\"\",\"content\":\"# typespec_2025_07_10.md\\n\\n# Unresolved Breaking changes\\n\\n## question\\n\\nWe are under the process of resolving breaking changes in the PR raised by the conversion team, we have resolved most of them.\\r\\nBut some of the breaking changes reported are not possible syntactically to achieve the exact output from typespec that we have in our current swagger spec in main.\\r\\nEx : https://github.com/Azure/openapi-diff/tree/master/docs/rules/1025.md\\r\\nIt's not possible to introduce 'all of' in typespec. \\r\\nSo will the service has to go through the complete breaking change review process for the semantically different new swagger output generated by typespec ?\\n\\n## answer\\n\\nOur principle is to ensure the functional equivalence. Since TypeSpec and swagger are actually two different \\\"languages\\\", we cannot ensure textual equivalence. The action at service's side is to ensure the TypeSpec are accurately representing service's API surface, because we don't have business knowledge. \\r\\nYou could use `extends` to represent `allof`\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_09_26.md\",\"document_title\":\"Changing Property to Optional with Default\",\"document_link\":\"\",\"content\":\"# typespec_2025_09_26.md\\n\\n# Changing Property to Optional with Default\\n\\n## question\\n\\nHi everyone, \\r\\nI am making a property optional in typespec and to be a non-breaking change, I see that is required to have a default. However my change seems to also change the existing version instead of only the new version. \\r\\nBefore:\\r\\n  @OpenAPI.extension(\\\"x-ms-identifiers\\\", #[])\\r\\n  dnsResolverDomainLists: SubResource[]; \\r\\nAfter:\\r\\n  @madeOptional(Versions.v2025_10_01_preview)\\r\\n  @OpenAPI.extension(\\\"x-ms-identifiers\\\", #[])\\r\\n  dnsResolverDomainLists?: SubResource[] = #[]; \\r\\n1) How can I make the change in typespec so that the generation of the openapi jsons will not affect the existing version? Currently generation also adds the empty array default to the existing API version (2025-05-01) which causes the breaking change CI to flag.\\r\\n2) Is there a way I can default the SubResource[] array to null instead? \\r\\nThis is in accordance to the documentation here (Made optional with/without default case): [non-breaking-versioning | TypeSpec Azure](https://azure.github.io/typespec-azure/docs/libraries/azure-core/rules/non-breaking-versioning/#-incorrect)\\r\\nMy PR: [Release 2025-10-01-preview for DNS Resolver by jamesvoongms · Pull Request #24470 · Azure/azure-res…](https://github.com/Azure/azure-rest-api-specs-pr/pull/24470)\\n\\n## answer\\n\\nYou should not add OpenApi extensions directly - x-ms-identifiers are automatically added based on the `@key` properties of a model,  or you should use the `@identifiers` decorator if you need to override the default setting. \\r\\nThe problem is that this is two changes (making a property optional and providing a default), but there is only versioning decoration for one change.  Compounding this, there is no versioning decoration for adding a default value, this is being tracked here: [Add additional versioning decorators · Issue #2761 · microsoft/typespec](https://github.com/microsoft/typespec/issues/2761).  Ideally we should combine these two changes into a single decorator to promote non-breaking changes. \\r\\nMeanwhile, you can do this using the added/removed/rename pattern to replace one property with another property in a new version, as this example.\\r\\n```\\r\\n/** Employee properties */\\r\\nmodel EmployeeProperties {\\r\\n  @removed(Versions.`2025-10-01-preview`)\\r\\n  @renamedFrom(Versions.`2025-10-01-preview`, \\\"stuff\\\")\\r\\n  @doc(\\\"The stuff\\\")\\r\\n  oldStuff: string[];\\r\\n\\r\\n  @added(Versions.`2025-10-01-preview`)\\r\\n  @doc(\\\"The stuff\\\")\\r\\n  stuff?: string[] = #[];\\r\\n}\\r\\n```\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_10.md\",\"document_title\":\"Hi team, could someone please help grant me permission to view the workflow for my Azure REST API PR?\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_10.md\\n\\n# Hi team, could someone please help grant me permission to view the workflow for my Azure REST API PR?\\n\\n## question\\n\\nRight now, after pushing my commit, I’m unable to see the error details for the validation checks, it just says “at least one review required to see the workflow.” This makes it difficult to verify if my changes are passing validation before the final review.\\r\\nWould it be possible to enable workflow visibility for me so I can debug and ensure everything is in order ahead of time? PR link: [Stable version 2025-09-01 with prevalidation and autoscale changes by prachinandi · Pull Request #3…](https://github.com/Azure/azure-rest-api-specs/pull/37218)\\n\\n## answer\\n\\nYou need to get the necessary permissions, see here: https://aka.ms/azsdk/access\"},{\"document_source\":\"static_typespec_qa\",\"document_filename\":\"typespec_2025_10_10.md\",\"document_title\":\"Service under conversation label\",\"document_link\":\"\",\"content\":\"# typespec_2025_10_10.md\\n\\n# Service under conversation label\\n\\n## question\\n\\nHi TypeSpec Discussion, \\r\\nMy team currently has a PR open to release a new stable API. However, due to backend delays, it’s been open since July. During that time, the [typespec migration PR](https://github.com/Azure/azure-rest-api-specs/pull/36556) was drafted against our preview API. Now, the service-under-conversion label has been added to our stable PR. I’d like to understand does this label indicate a delay in merging in our [stable api PR](https://github.com/Azure/azure-rest-api-specs/pull/36219), or will we need to make additional changes?\\n\\n## answer\\n\\nThe label should not impact your previous PR, and , if this is a later api-version thatn the conversion PR, the conversion would normally be based on that version once checked in.  Adding Janine Zhang for awareness about the conversion.\"},{\"document_source\":\"static_azure_docs\",\"document_filename\":\"Azure Versioning and Breaking Changes Policy V1.3.2.md\",\"document_title\":\"Azure Versioning and Breaking Changes Policy V1.3.2\",\"document_link\":\"\",\"content\":\"# Azure Versioning and Breaking Changes Policy V1.3.2.md\\n\\n# Azure Versioning and Breaking Changes Policy V1.3.2\\n\\n**DOCUMENT STATUS:** PUBLISHED  \\r\\n**AUTHORS:** JEFFREY RICHTER / SRIKANTH MANTHA / LULU REJON  \\r\\n**URL:** \\u003chttp://aka.ms/azbreakingchangespolicy\\u003e\\n\\n## 1. Policy Overview and Motivation\\n\\n### 1.1 Motivation\\n\\nBreaking changes introduce interruptions for our customers and negatively impacts the Azure brand. To maintain customer satisfaction, service teams are strongly encouraged to find other ways to introduce the functionality desired without breaking existing customers. If you believe a breaking change is mandatory, please continue to read the rest of the document on the policy and the process.\\n\\n### 1.2 Definition\\n\\nWe classify breaking changes as modifying or removing existing functionality in our Azure products, services, client libraries, APIs, SDKs, tools, and agents. This negatively impacts our customers' workloads, causes service interruption, and requires customer action to mitigate this negative impact (typically accomplished by updating code, testing, and re-deployment). This may also impact on how customers access existing capabilities.\\r\\n\\r\\n- Even small breaking changes cause customers' mission-critical applications/services to fail resulting in high costs and negative experience to customers. Furthermore, customers blame Microsoft/Azure for these failures damaging Azure's brand perception.\\r\\n\\r\\n- To be successful in the face of competition, it is imperative that Microsoft builds an ecosystem around Azure in the form of 3rd-party libraries, blog posts, conference sessions, documentation, samples, and so on. When an Azure service introduces a breaking change, many of these ecosystem assets also \\\"break\\\" and customers cannot trust them hindering Azure's success.\\r\\n\\r\\nFor the purposes of this document, any preview \\u003e 1 year is considered GA from a breaking change perspective.\\n\\n### 1.3 Purpose\\n\\nThe purpose of the policy outlined here is to enable breaking changes while limiting the negative impact to Azure customers. There are times when an Azure service team will want to introduce a breaking change typically to fix some security-related issue or to alter how something existing works in order to introduce some new functionality.\\n\\n## 2. The Azure Breaking Changes Policy\\n\\nNotifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\r\\n\\r\\n- For client SDK/tool changes, the notification informs customers that the old version will be supported for 1 more year and that customers should start using the new version as soon as possible. Furthermore, as soon as a new stable client library is available, old client libraries must be marked as deprecated in package managers with a note indicating that a newer/recommended version is now available with a link to the newer version. Here's an example of this notice:\\r\\n\\r\\n```\\r\\nMicrosoft.Azure.Storage.Blob\\r\\n11.2.3\\r\\n\\r\\nPrefix Reserved\\r\\n\\r\\n⚠ This package has been deprecated.\\r\\n\\r\\nSuggested Alternatives\\r\\nAzure.Storage.Blobs\\r\\n\\r\\nAdditional Details\\r\\n\\r\\nThank you for the interest in this package.\\r\\n\\r\\nIf you are looking for the latest packages to interact with Azure Storage, please use the following libraries:\\r\\n- Azure.Storage.Blobs\\r\\n- Azure.Storage.Queues\\r\\n- Azure.Storage.Blobs.Batch\\r\\n- Azure.Storage.Files.Shares\\r\\n```\\n\\n- Azure service teams should strive to not introduce breaking changes within or across versions of an Azure service, SDK, tool, agent, and so on as they evolve over time.\\r\\n\\r\\n- If, after serious consideration, a team believes that a breaking change is needed, the team must create a breaking-change proposal and have it reviewed before the change is allowed.\\r\\n\\r\\n**NOTE:** Be aware that the breaking change proposal may not be approved. Therefore, the change should not be implemented until after approval is granted; this avoids wasting resources and allows the team to get too emotionally attached to the change.\\r\\n\\r\\n**NOTE:** If a breaking change impacts a service's API, then the changes must be reviewed by the Azure REST API Stewardship Board (@azureapirbcore) and client library changes must be reviewed by the Azure SDK Architecture Team (@azsdksarch).\\r\\n\\r\\n- During the review, we discuss the proposed changes to a service's behavior and API, as well as impact to SDK client libraries and tool/agent changes. We consider how to minimize customer impact, the right customer communication, and decide timelines.\\r\\n\\r\\n- To get approval for a breaking change, teams start an intake request, completing the review/evaluation, and get signoffs. If approved, customers will be notified of the pending breaking change.\\r\\n\\r\\n**NOTE:** Notifications are batched and sent to customers once every quarter.\\r\\n\\r\\n- For service changes, the notification informs customers that they have three years to adopt the new service behavior and, if they do not adopt the new behavior, their application will stop working after this 3-year period. During the three-years, the service team must actively help customers transition to the latest version of the service to minimize the set of customers failing to adopt the new service version.\\n\\n### 2.1 Timeline Exceptions\\n\\n#### Security\\r\\n\\r\\nSecurity fixes due to data corruption and data exposure also require this review and once approved, result in a 1-year timeline.\\r\\n\\r\\n#### Non-Microsoft Component Dependencies\\r\\n\\r\\nA service experiencing a breaking change due to a dependency on a non-Microsoft component can shrink the three-year timeline to that of the dependency's support policy. During the breaking change review, the service team must provide publicly available documentation by the component's publisher showing the date when the dependency is no longer supported.\\r\\n\\r\\n#### Previews\\r\\n\\r\\nEach new preview version of the service must be backward compatible with the latest GA version. However, a new preview or GA version can make breaking changes as compared to the previous preview version. Once a new preview or GA version is available, notify customers that the previous preview version will stop working entirely in 90 days. You don't need to go through the Breaking Change or Retirement process. Reference External Communication (\\u003chttps://dev.azure.com/msazure/AzureWiki/_wiki/wikis/AzureWiki.wiki/37689/External-Communication\\u003e) to leverage CXP to send outbound communication. This encourages customers to adopt the latest preview version and allows the Azure service team to maintain old preview versions. Once the new GA version is available, again notify customers that the latest preview version will stop working entirely in 90 days. Again, this forces customers off of a preview version and on to a fully supported GA version and allows the service team to stop supporting customers on preview versions.\\n\\n## 3. Detailed Breaking Change Process\\n\\nService owners should start this process before making any breaking changes. Service owners should plan for at least 6-8 weeks (about 2 months) for the process to be completed. Here are the process steps:\\n\\n### 1. Intake Preparation (Owner: Service PM)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Create a new intake using the template for breaking changes: \\u003chttps://msazure.visualstudio.com/One/_workitems/create/Scenario?templateld=c815af37-5520-43ff-90c8-d985eaabcb6c\\u0026ownerld=85bb92fb-21fe-41ca-9309-47f2c5f57515\\u003e\\r\\n\\r\\n- Save Intake Request as New.\\r\\n\\r\\n- Please assign the intake to the service owner PM.\\r\\n\\r\\n- Add the \\\"Breaking Change\\\" tag.\\r\\n\\r\\n- Please ensure your request shows up in the dashboard (\\u003chttps://msazure.visualstudio.com/One/_dashboards/dashboard/f7db6895-7137-4695-b3f5-00dc4d36758f\\u003e)\\r\\n\\r\\n- Send email to @azbreakchangereview.\\r\\n\\r\\n- Attend weekly Office Hours to talk through the breaking change and seek approval. The office hours are on Mondays, 10 AM to 11 AM Pacific Time. Meeting details can be found here.\\n\\n### 2. Intake Evaluation (Owner: Service PM/Breaking Change review board)\\n\\n**Estimated time:** 1-2 weeks\\r\\n\\r\\n- Validate high-level business justification.\\r\\n\\r\\n- What is the proposal that is being reviewed?\\r\\n\\r\\n- Why do you need this breaking change?\\r\\n\\r\\n- What will your team do if the breaking change is not approved? There is a high chance the breaking change will NOT be approved.\\r\\n\\r\\n- Customer experience impact.\\r\\n\\r\\n- Number of customers affected.\\r\\n\\r\\n- How can you reduce the impact on customers?\\n\\n### 3. Intake decision (Owner: Breaking change Review Board)\\n\\n**Estimated time:** 1-3 days\\r\\n\\r\\n- Reviewing all the information, the Breaking Change Review Board will decide whether to approve the proposal, change it, or disapprove it.\\n\\n### 4. Intake approval from Azure REST API board (Owner: Service PM)\\n\\n**Estimated time:** 1 week\\r\\n\\r\\n- Once approved by the Breaking Change Review Board, status of the intake will be marked as approved by the Breaking Change Review Board.\\r\\n\\r\\n- If there is an SDK impact- then the proposal should be reviewed by API board to seek approval. Reference the API Breaking change documentation: \\u003chttps://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-changes-that-require-a-version-change\\u003e\\r\\n\\r\\n- Engage the SDK team and the SDK Review board to minimize the impact on client libraries.\\r\\n\\r\\n- Service teams should not implement the change until all approvals have been received.\\n\\n### 5. Communication Readiness (Owner: Service PM/Azure Marketing/CSS)\\n\\n**Estimated time:** 2-6 weeks\\r\\n\\r\\n- Service team owners will need to work with Azure PMM/ Service PM/ Sharon Loh (Breaking change Team - Marketing) - to lock on communication template. If breaking change impacts more than 20,000 subscription IDs, the customer email will be re\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Azure-REST-API,-SDK-development-process-with-TypeSpec.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Azure-REST-API,-SDK-development-process-with-TypeSpec\",\"content\":\"# Azure REST API, SDK development process with TypeSpec\\n## Table Of Content\\n### 4. Prepare and submit a Pull Request for reviewing\\n5. Generate OpenAPI files:\\r\\n   - sync with the target branch in the azure-rest-api-specs repo\\r\\n      ```git\\r\\n       git pull upstream \\u003ctarget-branch\\u003e\\r\\n      ```\\r\\n   - in the root directory, run `npm install`\\r\\n   - in the project directory, `npx tsp compile`. This will generate OpenAPI files under `{service}` folders.\\r\\n6. Ensure all generated files under `{service}` have been added to PR.\\r\\n7. Send a pull request .\\r\\n   - commit all your changes.\\r\\n   - push your branch to your fork of the repo.\\r\\n   - send a pull request to the original repo from your forked repo.\\r\\n   See the ARM Wiki for information on the [supported repos and branches for management-plane services](https://armwiki.azurewebsites.net/rpaas/swaggeronboarding.html#supported-github-reposbranches).\\r\\n#### 4.1 Fix the errors of PR reviewing CI checks\\r\\nThe CI checks result will be commented on the PR. you can refer to the [CI fix Guide](https://github.com/Azure/azure-rest-api-specs/blob/main/documentation/ci-fix.md).\\r\\nNote:\\r\\nSince the OpenAPI is generated from TypeSpec, to change the OpenAPI, you must update the TypeSpec file and regenerate the\\r\\n OpenAPI and avoid updating OpenAPI directly to keep the consistency between OpenAPI and TypeSpec.\\r\\nFor support \\u0026 help, you can post a message to [TypeSpec Discussion - teams channel](https://teams.microsoft.com/l/channel/19%3A906c1efbbec54dc8949ac736633e6bdf%40thread.skype/TypeSpec%20Discussion?groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121\\u0026tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47).\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-specs-pr#api-tutorial#api-tutorial.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-tutorial/api-tutorial\",\"content\":\"# Tutorial: Create a new service spec\\n## Why work in a separate branch?\\nThe [Microsoft Azure REST API Guidelines state](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md#api-versioning),\\r\\n\\r\\n\\u003e Azure services need to change over time. However, when changing a service, there are 2 requirements:\\r\\n\\u003e\\r\\n\\u003e 1. Already-running customer workloads must not break due to a service change.\\r\\n\\u003e 2. Customers can adopt a new service version without requiring any code changes.\\r\\n\\u003e    Of course, the customer must modify code to leverage any new service features.\\r\\n\\r\\nTogether with the [Breaking Changes Policy](http://aka.ms/AzBreakingChangesPolicy/), it effectively means that any\\r\\nchanges you merge directly into the `main` branch in  \\r\\n[Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs) must be supported for 90 days for preview\\r\\nversions, and 3 years for stable versions at a minimum.\\r\\n\\r\\nWorking in a separate branch allows your team to iterate on a design, make changes to the REST API definition or\\r\\neven the service as needed, and merge those changes to `main` - effectively publishing that service version -\\r\\nwhen you're ready.\"},{\"document_source\":\"azure_rest_api_specs_wiki\",\"document_filename\":\"Swagger-Avocado.md\",\"document_title\":\"\",\"document_link\":\"https://github.com/Azure/azure-rest-api-specs/wiki/Swagger-Avocado\",\"content\":\"# Known Issues\\n## MULTIPLE_API_VERSION\\nRule [MULTIPLE_API_VERSION](https://github.com/Azure/avocado?tab=readme-ov-file#multiple_api_version) was changed from a warning to an error on 7/1/2025. As this issue is a blocker to TypeSpec conversion which is an Azure wide effort to drive the API first design pattern among all Azure services.\\r\\n\\r\\nIf your PR is blocked due to this error, please check out this [Uniform Versioning Violation Guide](https://github.com/Azure/azure-rest-api-specs/wiki/Uniform-Versioning-Violation-Guide) wiki on how to resolve this.\\r\\n\\r\\nPlease check with azversioning@service.microsoft.com to see if your service can have one-time suppression if you are not sure.\"},{\"document_source\":\"azure-sdk-docs-eng\",\"document_filename\":\"design#api-review.md\",\"document_title\":\"\",\"document_link\":\"https://eng.ms/docs/products/azure-developer-experience/design/api-review\",\"content\":\"# Schedule a data plane REST API spec review\\n## Requesting an offline REST API review\\n### Conducting the offline review\\nUpon receiving the email requesting offline review, API Stewardship board members may review the PR and leave comments.\\r\\nThe service team may use the Teams chat for the meeting to communicate with the review board\\r\\nto recruit reviewers or answer questions.\\r\\n\\r\\nWhen an API Steward has reviewed the PR and has no concerns they submit an \\\"Approved\\\" review.\\r\\nWhen at least two API stewards have approved and none have requested changes, any member of the Stewardship board\\r\\ncan add the \\\"signedOff\\\" label and the review is complete.\"}]",
            "inputs.latency": 1147.2517492771149,
            "inputs.response_length": 3245,
            "inputs.expected_reference_urls": [],
            "inputs.reference_urls": [
                "https://eng.ms/docs/products/azure-developer-experience/design/specs-pr-guides/pr-brch-deep"
            ],
            "inputs.testcase": "DNS Resolver New Version Review",
            "outputs.similarity.similarity": 3.0,
            "outputs.similarity.gpt_similarity": 3.0,
            "outputs.similarity.similarity_result": "fail",
            "outputs.similarity.similarity_threshold": 4,
            "outputs.similarity.similarity_prompt_tokens": 1935,
            "outputs.similarity.similarity_completion_tokens": 1,
            "outputs.similarity.similarity_total_tokens": 1936,
            "outputs.similarity.similarity_finish_reason": "length",
            "outputs.similarity.similarity_model": "gpt-4.1-2025-04-14",
            "outputs.similarity.similarity_sample_input": "[{\"role\": \"user\", \"content\": \"{\\\"query\\\": \\\"title: DNS Resolver New Version Review\\\\n\\\\nquestion: Hi team, I am trying to get a review on my PR but bot removes the WaitForARMFeedback label. Could someone help take a look and approve/add the breaking change label? The breaking change CI/CD is flagging as a property has been changed from required to not required.\\\\n```\\\\nThe following breaking changes have been detected in comparison to the latest stable version\\\\n\\\\u274c 1025 - RequiredStatusChange\\\\nDisplaying 1 out of 1 occurrences.\\\\nIndex | Description\\\\n1 | The required status changed from the old version ('True') to the new version ('False').\\\\nNew: DnsResolver/preview/2025-10-01-preview/openapi.json#L4901:7\\\\ndefinitions.DnsSecurityRuleProperties.properties\\\\nOld: DnsResolver/stable/2025-05-01/openapi.json#L4892:7\\\\n\\\\u274c 1027 - DefaultValueChanged\\\\nDisplaying 1 out of 1 occurrences.\\\\nIndex | Description\\\\n1 | The new version has a different default value than the previous one.\\\\nNew: DnsResolver/preview/2025-10-01-preview/openapi.json#L4916:9\\\\ndefinitions.DnsSecurityRuleProperties.properties.allowedDomainsLists\\\\nOld: DnsResolver/stable/2025-05-01/openapi.json#L4907:9\\\\n```\\\\n[Release 2025-10-01-preview for DNS Resolver by jamesvoongms \\\\u00b7 Pull Request #24470 \\\\u00b7 Azure/azure-res\\\\u2026](https://github.com/Azure/azure-rest-api-specs-pr/pull/24470)\\\", \\\"response\\\": \\\"Based on the Azure API versioning and breaking change policies, here is how your flagged changes are evaluated:\\\\n\\\\n1. **Changing a property from required to optional (RequiredStatusChange):**\\\\n- This is considered a breaking change at the REST API level because existing client code that expects the property to always be present could break if it is omitted in the new version.\\\\n- If this change is in a *new preview version* (e.g., 2025-10-01-preview), breaking changes compared to the previous preview are permitted. However, breaking changes compared to the latest GA (stable) version are **not allowed** unless approved through the Breaking Change Review process. \\\\n- If your intention is to make this a non-breaking change, you should provide a default value for the property, as described in the non-breaking versioning guidance. But currently, there is no direct TypeSpec decorator for default values; instead, the recommended pattern is to use `@madeOptional` together with `@added`/`@removed` to manage optionality across versions. If a default value is present, it can mitigate breaking change impact for new clients, but the change must still be reviewed and approved for existing stable versions.\\\\n\\\\n2. **Changing the default value for a property (DefaultValueChanged):**\\\\n- This is also considered a breaking change unless the property is new in the preview version, or unless the new default value does not impact client behavior (rare).\\\\n- If you change a default value between stable and preview, clients relying on the previous default may be affected. This requires a breaking change review for stable versions.\\\\n\\\\n**Actions Required:**\\\\n- For both changes, you must follow the Breaking Change Review process. Your PR will be blocked until the board reviews and either approves or rejects these changes. See [aka.ms/brch] for process details.\\\\n- If you believe these are benign or bugfixes (e.g., the required status was incorrect, or the new default better matches service behavior), you may request a 'BreakingChange-Approved-BugFix' label and justify your reasoning in the PR description. Otherwise, you must go through full review.\\\\n\\\\n**How to Fix/Proceed:**\\\\n- Do NOT attempt to suppress the error or change the OpenAPI manually. You must update your TypeSpec definition and go through the breaking change review.\\\\n- You may provide evidence (in the PR) that no existing customer would be affected, or that the change is required for correctness, to accelerate review.\\\\n\\\\n**References and Examples:**\\\\n- For making a property optional in a new version, use `@madeOptional(Versions.v2025_10_01_preview)` in TypeSpec. See the following example:\\\\n\\\\n```typespec\\\\nmodel DnsSecurityRuleProperties {\\\\n  // In previous stable version:\\\\n  // property was required\\\\n  // In new preview version:\\\\n  @madeOptional(Versions.v2025_10_01_preview)\\\\n  propertyName?: Type;\\\\n}\\\\n```\\\\n- For changing default values, there is currently no direct versioned decorator, so you should use the `@added`/`@removed` pattern to replace the property with a new one if needed.\\\\n\\\\n**Summary:**\\\\n- Both changes are breaking and require review/approval. Document your rationale and follow the process at [aka.ms/brch]. Once approved, the proper label will be added and your PR can proceed.\\\", \\\"ground_truth\\\": \\\"In the \\\\\\\"next steps to merge\\\\\\\" comment, your PR indicates it's ready to merge.\\\\nSince your PR is to a \\\\\\\"release-*\\\\\\\" branch, the Breaking Changes board will not review it, and the check is not required.  Your breaking changes will be reviewed when your release branch merges to main/RPSaaSMaster.\\\\nhttps://eng.ms/docs/products/azure-developer-experience/design/api-specs-pr/api-versions-and-branches#branch-protection-rules-table\\\"}\"}]",
            "outputs.similarity.similarity_sample_output": "[{\"role\": \"assistant\", \"content\": \"3\"}]"
        }
    ],
    "metrics": {
        "similarity.similarity": 3.75,
        "similarity.gpt_similarity": 3.75,
        "similarity.similarity_threshold": 4.0,
        "similarity.binary_aggregate": 0.65
    },
    "studio_url": null
}